{
  "dir_path": "/app/cassandra_driver",
  "package_name": "cassandra_driver",
  "sample_name": "cassandra_driver-test_marshalling",
  "src_dir": "cassandra/",
  "test_dir": "tests/",
  "test_file": "tests/unit/test_marshalling.py",
  "test_code": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport sys\n\nfrom cassandra import ProtocolVersion\n\nimport unittest\n\nimport platform\nfrom datetime import datetime, date\nfrom decimal import Decimal\nfrom uuid import UUID\n\nfrom cassandra.cqltypes import lookup_casstype, DecimalType, UTF8Type, DateType\nfrom cassandra.util import OrderedMapSerializedKey, sortedset, Time, Date\n\nmarshalled_value_pairs = (\n    # binary form, type, python native type\n    (b'lorem ipsum dolor sit amet', 'AsciiType', 'lorem ipsum dolor sit amet'),\n    (b'', 'AsciiType', ''),\n    (b'\\x01', 'BooleanType', True),\n    (b'\\x00', 'BooleanType', False),\n    (b'', 'BooleanType', None),\n    (b'\\xff\\xfe\\xfd\\xfc\\xfb', 'BytesType', b'\\xff\\xfe\\xfd\\xfc\\xfb'),\n    (b'', 'BytesType', b''),\n    (b'\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff', 'CounterColumnType', 9223372036854775807),\n    (b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00', 'CounterColumnType', -9223372036854775808),\n    (b'', 'CounterColumnType', None),\n    (b'\\x00\\x00\\x013\\x7fb\\xeey', 'DateType', datetime(2011, 11, 7, 18, 55, 49, 881000)),\n    (b'\\x00\\x00\\x01P\\xc5~L\\x00', 'DateType', datetime(2015, 11, 2)),\n    (b'', 'DateType', None),\n    (b'\\x00\\x00\\x00\\r\\nJ\\x04\"^\\x91\\x04\\x8a\\xb1\\x18\\xfe', 'DecimalType', Decimal('1243878957943.1234124191998')),\n    (b'\\x00\\x00\\x00\\x06\\xe5\\xde]\\x98Y', 'DecimalType', Decimal('-112233.441191')),\n    (b'\\x00\\x00\\x00\\x14\\x00\\xfa\\xce', 'DecimalType', Decimal('0.00000000000000064206')),\n    (b'\\x00\\x00\\x00\\x14\\xff\\x052', 'DecimalType', Decimal('-0.00000000000000064206')),\n    (b'\\xff\\xff\\xff\\x9c\\x00\\xfa\\xce', 'DecimalType', Decimal('64206e100')),\n    (b'', 'DecimalType', None),\n    (b'@\\xd2\\xfa\\x08\\x00\\x00\\x00\\x00', 'DoubleType', 19432.125),\n    (b'\\xc0\\xd2\\xfa\\x08\\x00\\x00\\x00\\x00', 'DoubleType', -19432.125),\n    (b'\\x7f\\xef\\x00\\x00\\x00\\x00\\x00\\x00', 'DoubleType', 1.7415152243978685e+308),\n    (b'', 'DoubleType', None),\n    (b'F\\x97\\xd0@', 'FloatType', 19432.125),\n    (b'\\xc6\\x97\\xd0@', 'FloatType', -19432.125),\n    (b'\\xc6\\x97\\xd0@', 'FloatType', -19432.125),\n    (b'\\x7f\\x7f\\x00\\x00', 'FloatType', 338953138925153547590470800371487866880.0),\n    (b'', 'FloatType', None),\n    (b'\\x7f\\x50\\x00\\x00', 'Int32Type', 2135949312),\n    (b'\\xff\\xfd\\xcb\\x91', 'Int32Type', -144495),\n    (b'', 'Int32Type', None),\n    (b'f\\x1e\\xfd\\xf2\\xe3\\xb1\\x9f|\\x04_\\x15', 'IntegerType', 123456789123456789123456789),\n    (b'', 'IntegerType', None),\n    (b'\\x7f\\xff\\xff\\xff\\xff\\xff\\xff\\xff', 'LongType', 9223372036854775807),\n    (b'\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00', 'LongType', -9223372036854775808),\n    (b'', 'LongType', None),\n    (b'', 'InetAddressType', None),\n    (b'A46\\xa9', 'InetAddressType', '65.52.54.169'),\n    (b'*\\x00\\x13(\\xe1\\x02\\xcc\\xc0\\x00\\x00\\x00\\x00\\x00\\x00\\x01\"', 'InetAddressType', '2a00:1328:e102:ccc0::122'),\n    (b'\\xe3\\x81\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6', 'UTF8Type', u'\\u307e\\u3057\\u3066'),\n    (b'\\xe3\\x81\\xbe\\xe3\\x81\\x97\\xe3\\x81\\xa6' * 1000, 'UTF8Type', u'\\u307e\\u3057\\u3066' * 1000),\n    (b'', 'UTF8Type', u''),\n    (b'\\xff' * 16, 'UUIDType', UUID('ffffffff-ffff-ffff-ffff-ffffffffffff')),\n    (b'I\\x15~\\xfc\\xef<\\x9d\\xe3\\x16\\x98\\xaf\\x80\\x1f\\xb4\\x0b*', 'UUIDType', UUID('49157efc-ef3c-9de3-1698-af801fb40b2a')),\n    (b'', 'UUIDType', None),\n    (b'', 'MapType(AsciiType, BooleanType)', None),\n    (b'', 'ListType(FloatType)', None),\n    (b'', 'SetType(LongType)', None),\n    (b'\\x00\\x00', 'MapType(DecimalType, BooleanType)', OrderedMapSerializedKey(DecimalType, 0)),\n    (b'\\x00\\x00', 'ListType(FloatType)', []),\n    (b'\\x00\\x00', 'SetType(IntegerType)', sortedset()),\n    (b'\\x00\\x01\\x00\\x10\\xafYC\\xa3\\xea<\\x11\\xe1\\xabc\\xc4,\\x03\"y\\xf0', 'ListType(TimeUUIDType)', [UUID(bytes=b'\\xafYC\\xa3\\xea<\\x11\\xe1\\xabc\\xc4,\\x03\"y\\xf0')]),\n    (b'\\x80\\x00\\x00\\x01', 'SimpleDateType', Date(1)),\n    (b'\\x7f\\xff\\xff\\xff', 'SimpleDateType', Date('1969-12-31')),\n    (b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01', 'TimeType', Time(1)),\n    (b'\\x7f', 'ByteType', 127),\n    (b'\\x80', 'ByteType', -128),\n    (b'\\x7f\\xff', 'ShortType', 32767),\n    (b'\\x80\\x00', 'ShortType', -32768)\n)\n\nordered_map_value = OrderedMapSerializedKey(UTF8Type, 2)\nordered_map_value._insert(u'\\u307fbob', 199)\nordered_map_value._insert(u'', -1)\nordered_map_value._insert(u'\\\\', 0)\n\n# these following entries work for me right now, but they're dependent on\n# vagaries of internal python ordering for unordered types\nmarshalled_value_pairs_unsafe = (\n    (b'\\x00\\x03\\x00\\x06\\xe3\\x81\\xbfbob\\x00\\x04\\x00\\x00\\x00\\xc7\\x00\\x00\\x00\\x04\\xff\\xff\\xff\\xff\\x00\\x01\\\\\\x00\\x04\\x00\\x00\\x00\\x00', 'MapType(UTF8Type, Int32Type)', ordered_map_value),\n    (b'\\x00\\x02\\x00\\x08@\\x01\\x99\\x99\\x99\\x99\\x99\\x9a\\x00\\x08@\\x14\\x00\\x00\\x00\\x00\\x00\\x00', 'SetType(DoubleType)', sortedset([2.2, 5.0])),\n    (b'\\x00', 'IntegerType', 0),\n)\n\nif platform.python_implementation() == 'CPython':\n    # Only run tests for entries which depend on internal python ordering under\n    # CPython\n    marshalled_value_pairs += marshalled_value_pairs_unsafe\n\n\nclass UnmarshalTest(unittest.TestCase):\n    def test_unmarshalling(self):\n        for serializedval, valtype, nativeval in marshalled_value_pairs:\n            unmarshaller = lookup_casstype(valtype)\n            whatwegot = unmarshaller.from_binary(serializedval, 1)\n            self.assertEqual(whatwegot, nativeval,\n                             msg='Unmarshaller for %s (%s) failed: unmarshal(%r) got %r instead of %r'\n                                 % (valtype, unmarshaller, serializedval, whatwegot, nativeval))\n            self.assertEqual(type(whatwegot), type(nativeval),\n                             msg='Unmarshaller for %s (%s) gave wrong type (%s instead of %s)'\n                                 % (valtype, unmarshaller, type(whatwegot), type(nativeval)))\n\n    def test_marshalling(self):\n        for serializedval, valtype, nativeval in marshalled_value_pairs:\n            marshaller = lookup_casstype(valtype)\n            whatwegot = marshaller.to_binary(nativeval, 1)\n            self.assertEqual(whatwegot, serializedval,\n                             msg='Marshaller for %s (%s) failed: marshal(%r) got %r instead of %r'\n                                 % (valtype, marshaller, nativeval, whatwegot, serializedval))\n            self.assertEqual(type(whatwegot), type(serializedval),\n                             msg='Marshaller for %s (%s) gave wrong type (%s instead of %s)'\n                                 % (valtype, marshaller, type(whatwegot), type(serializedval)))\n\n    def test_date(self):\n        # separate test because it will deserialize as datetime\n        self.assertEqual(DateType.from_binary(DateType.to_binary(date(2015, 11, 2), 1), 1), datetime(2015, 11, 2))\n\n    def test_decimal(self):\n        # testing implicit numeric conversion\n        # int, tuple(sign, digits, exp), float\n        converted_types = (10001, (0, (1, 0, 0, 0, 0, 1), -3), 100.1, -87.629798)\n\n        for proto_ver in range(1, ProtocolVersion.MAX_SUPPORTED + 1):\n            for n in converted_types:\n                expected = Decimal(n)\n                self.assertEqual(DecimalType.from_binary(DecimalType.to_binary(n, proto_ver), proto_ver), expected)\n",
  "GT_file_code": {
    "cassandra/util.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom _weakref import ref\nimport calendar\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nimport datetime\nfrom functools import total_ordering\nfrom itertools import chain\nimport keyword\nimport logging\nimport pickle\nimport random\nimport re\nimport socket\nimport sys\nimport time\nimport uuid\n\n_HAS_GEOMET = True\ntry:\n    from geomet import wkt\nexcept:\n    _HAS_GEOMET = False\n\n\nfrom cassandra import DriverException\n\nDATETIME_EPOC = datetime.datetime(1970, 1, 1).replace(tzinfo=None)\nUTC_DATETIME_EPOC = datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc).replace(tzinfo=None)\n\n_nan = float('nan')\n\nlog = logging.getLogger(__name__)\n\nassert sys.byteorder in ('little', 'big')\nis_little_endian = sys.byteorder == 'little'\n\n\ndef datetime_from_timestamp(timestamp):\n    \"\"\"\n    Creates a timezone-agnostic datetime from timestamp (in seconds) in a consistent manner.\n    Works around a Windows issue with large negative timestamps (PYTHON-119),\n    and rounding differences in Python 3.4 (PYTHON-340).\n\n    :param timestamp: a unix timestamp, in seconds\n    \"\"\"\n    dt = DATETIME_EPOC + datetime.timedelta(seconds=timestamp)\n    return dt\n\n\ndef utc_datetime_from_ms_timestamp(timestamp):\n    \"\"\"\n    Creates a UTC datetime from a timestamp in milliseconds. See\n    :meth:`datetime_from_timestamp`.\n\n    Raises an `OverflowError` if the timestamp is out of range for\n    :class:`~datetime.datetime`.\n\n    :param timestamp: timestamp, in milliseconds\n    \"\"\"\n    return UTC_DATETIME_EPOC + datetime.timedelta(milliseconds=timestamp)\n\n\ndef ms_timestamp_from_datetime(dt):\n    \"\"\"\n    Converts a datetime to a timestamp expressed in milliseconds.\n\n    :param dt: a :class:`datetime.datetime`\n    \"\"\"\n    return int(round((dt - UTC_DATETIME_EPOC).total_seconds() * 1000))\n\n\ndef unix_time_from_uuid1(uuid_arg):\n    \"\"\"\n    Converts a version 1 :class:`uuid.UUID` to a timestamp with the same precision\n    as :meth:`time.time()` returns.  This is useful for examining the\n    results of queries returning a v1 :class:`~uuid.UUID`.\n\n    :param uuid_arg: a version 1 :class:`~uuid.UUID`\n    \"\"\"\n    return (uuid_arg.time - 0x01B21DD213814000) / 1e7\n\n\ndef datetime_from_uuid1(uuid_arg):\n    \"\"\"\n    Creates a timezone-agnostic datetime from the timestamp in the\n    specified type-1 UUID.\n\n    :param uuid_arg: a version 1 :class:`~uuid.UUID`\n    \"\"\"\n    return datetime_from_timestamp(unix_time_from_uuid1(uuid_arg))\n\n\ndef min_uuid_from_time(timestamp):\n    \"\"\"\n    Generates the minimum TimeUUID (type 1) for a given timestamp, as compared by Cassandra.\n\n    See :func:`uuid_from_time` for argument and return types.\n    \"\"\"\n    return uuid_from_time(timestamp, 0x808080808080, 0x80)  # Cassandra does byte-wise comparison; fill with min signed bytes (0x80 = -128)\n\n\ndef max_uuid_from_time(timestamp):\n    \"\"\"\n    Generates the maximum TimeUUID (type 1) for a given timestamp, as compared by Cassandra.\n\n    See :func:`uuid_from_time` for argument and return types.\n    \"\"\"\n    return uuid_from_time(timestamp, 0x7f7f7f7f7f7f, 0x3f7f)  # Max signed bytes (0x7f = 127)\n\n\ndef uuid_from_time(time_arg, node=None, clock_seq=None):\n    \"\"\"\n    Converts a datetime or timestamp to a type 1 :class:`uuid.UUID`.\n\n    :param time_arg:\n      The time to use for the timestamp portion of the UUID.\n      This can either be a :class:`datetime` object or a timestamp\n      in seconds (as returned from :meth:`time.time()`).\n    :type datetime: :class:`datetime` or timestamp\n\n    :param node:\n      None integer for the UUID (up to 48 bits). If not specified, this\n      field is randomized.\n    :type node: long\n\n    :param clock_seq:\n      Clock sequence field for the UUID (up to 14 bits). If not specified,\n      a random sequence is generated.\n    :type clock_seq: int\n\n    :rtype: :class:`uuid.UUID`\n\n    \"\"\"\n    if hasattr(time_arg, 'utctimetuple'):\n        seconds = int(calendar.timegm(time_arg.utctimetuple()))\n        microseconds = (seconds * 1e6) + time_arg.time().microsecond\n    else:\n        microseconds = int(time_arg * 1e6)\n\n    # 0x01b21dd213814000 is the number of 100-ns intervals between the\n    # UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.\n    intervals = int(microseconds * 10) + 0x01b21dd213814000\n\n    time_low = intervals & 0xffffffff\n    time_mid = (intervals >> 32) & 0xffff\n    time_hi_version = (intervals >> 48) & 0x0fff\n\n    if clock_seq is None:\n        clock_seq = random.getrandbits(14)\n    else:\n        if clock_seq > 0x3fff:\n            raise ValueError('clock_seq is out of range (need a 14-bit value)')\n\n    clock_seq_low = clock_seq & 0xff\n    clock_seq_hi_variant = 0x80 | ((clock_seq >> 8) & 0x3f)\n\n    if node is None:\n        node = random.getrandbits(48)\n\n    return uuid.UUID(fields=(time_low, time_mid, time_hi_version,\n                             clock_seq_hi_variant, clock_seq_low, node), version=1)\n\nLOWEST_TIME_UUID = uuid.UUID('00000000-0000-1000-8080-808080808080')\n\"\"\" The lowest possible TimeUUID, as sorted by Cassandra. \"\"\"\n\nHIGHEST_TIME_UUID = uuid.UUID('ffffffff-ffff-1fff-bf7f-7f7f7f7f7f7f')\n\"\"\" The highest possible TimeUUID, as sorted by Cassandra. \"\"\"\n\n\ndef _addrinfo_or_none(contact_point, port):\n    \"\"\"\n    A helper function that wraps socket.getaddrinfo and returns None\n    when it fails to, e.g. resolve one of the hostnames. Used to address\n    PYTHON-895.\n    \"\"\"\n    try:\n        value = socket.getaddrinfo(contact_point, port,\n                                  socket.AF_UNSPEC, socket.SOCK_STREAM)\n        return value\n    except socket.gaierror:\n        log.debug('Could not resolve hostname \"{}\" '\n                  'with port {}'.format(contact_point, port))\n        return None\n\n\ndef _addrinfo_to_ip_strings(addrinfo):\n    \"\"\"\n    Helper function that consumes the data output by socket.getaddrinfo and\n    extracts the IP address from the sockaddr portion of the result.\n\n    Since this is meant to be used in conjunction with _addrinfo_or_none,\n    this will pass None and EndPoint instances through unaffected.\n    \"\"\"\n    if addrinfo is None:\n        return None\n    return [(entry[4][0], entry[4][1]) for entry in addrinfo]\n\n\ndef _resolve_contact_points_to_string_map(contact_points):\n    return OrderedDict(\n        ('{cp}:{port}'.format(cp=cp, port=port), _addrinfo_to_ip_strings(_addrinfo_or_none(cp, port)))\n        for cp, port in contact_points\n    )\n\n\nclass _IterationGuard(object):\n    # This context manager registers itself in the current iterators of the\n    # weak container, such as to delay all removals until the context manager\n    # exits.\n    # This technique should be relatively thread-safe (since sets are).\n\n    def __init__(self, weakcontainer):\n        # Don't create cycles\n        self.weakcontainer = ref(weakcontainer)\n\n    def __enter__(self):\n        w = self.weakcontainer()\n        if w is not None:\n            w._iterating.add(self)\n        return self\n\n    def __exit__(self, e, t, b):\n        w = self.weakcontainer()\n        if w is not None:\n            s = w._iterating\n            s.remove(self)\n            if not s:\n                w._commit_removals()\n\n\nclass WeakSet(object):\n    def __init__(self, data=None):\n        self.data = set()\n\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)\n\n        self._remove = _remove\n        # A list of keys to be removed\n        self._pending_removals = []\n        self._iterating = set()\n        if data is not None:\n            self.update(data)\n\n    def _commit_removals(self):\n        l = self._pending_removals\n        discard = self.data.discard\n        while l:\n            discard(l.pop())\n\n    def __iter__(self):\n        with _IterationGuard(self):\n            for itemref in self.data:\n                item = itemref()\n                if item is not None:\n                    yield item\n\n    def __len__(self):\n        return sum(x() is not None for x in self.data)\n\n    def __contains__(self, item):\n        return ref(item) in self.data\n\n    def __reduce__(self):\n        return (self.__class__, (list(self),),\n                getattr(self, '__dict__', None))\n\n    __hash__ = None\n\n    def add(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.add(ref(item, self._remove))\n\n    def clear(self):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def pop(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            try:\n                itemref = self.data.pop()\n            except KeyError:\n                raise KeyError('pop from empty WeakSet')\n            item = itemref()\n            if item is not None:\n                return item\n\n    def remove(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.remove(ref(item))\n\n    def discard(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.discard(ref(item))\n\n    def update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if isinstance(other, self.__class__):\n            self.data.update(other.data)\n        else:\n            for element in other:\n                self.add(element)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    # Helper functions for simple delegating methods.\n    def _apply(self, other, method):\n        if not isinstance(other, self.__class__):\n            other = self.__class__(other)\n        newdata = method(other.data)\n        newset = self.__class__()\n        newset.data = newdata\n        return newset\n\n    def difference(self, other):\n        return self._apply(other, self.data.difference)\n    __sub__ = difference\n\n    def difference_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update(ref(item) for item in other)\n\n    def __isub__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update(ref(item) for item in other)\n        return self\n\n    def intersection(self, other):\n        return self._apply(other, self.data.intersection)\n    __and__ = intersection\n\n    def intersection_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update(ref(item) for item in other)\n\n    def __iand__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update(ref(item) for item in other)\n        return self\n\n    def issubset(self, other):\n        return self.data.issubset(ref(item) for item in other)\n    __lt__ = issubset\n\n    def __le__(self, other):\n        return self.data <= set(ref(item) for item in other)\n\n    def issuperset(self, other):\n        return self.data.issuperset(ref(item) for item in other)\n    __gt__ = issuperset\n\n    def __ge__(self, other):\n        return self.data >= set(ref(item) for item in other)\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.data == set(ref(item) for item in other)\n\n    def symmetric_difference(self, other):\n        return self._apply(other, self.data.symmetric_difference)\n    __xor__ = symmetric_difference\n\n    def symmetric_difference_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update(ref(item) for item in other)\n\n    def __ixor__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update(ref(item) for item in other)\n        return self\n\n    def union(self, other):\n        return self._apply(other, self.data.union)\n    __or__ = union\n\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n\n\nclass SortedSet(object):\n    '''\n    A sorted set based on sorted list\n\n    A sorted set implementation is used in this case because it does not\n    require its elements to be immutable/hashable.\n\n    #Not implemented: update functions, inplace operators\n    '''\n\n    def __init__(self, iterable=()):\n        self._items = []\n        self.update(iterable)\n\n    def __len__(self):\n        return len(self._items)\n\n    def __getitem__(self, i):\n        return self._items[i]\n\n    def __iter__(self):\n        return iter(self._items)\n\n    def __reversed__(self):\n        return reversed(self._items)\n\n    def __repr__(self):\n        return '%s(%r)' % (\n            self.__class__.__name__,\n            self._items)\n\n    def __reduce__(self):\n        return self.__class__, (self._items,)\n\n    def __eq__(self, other):\n        if isinstance(other, self.__class__):\n            return self._items == other._items\n        else:\n            try:\n                return len(other) == len(self._items) and all(item in self for item in other)\n            except TypeError:\n                return NotImplemented\n\n    def __ne__(self, other):\n        if isinstance(other, self.__class__):\n            return self._items != other._items\n        else:\n            try:\n                return len(other) != len(self._items) or any(item not in self for item in other)\n            except TypeError:\n                return NotImplemented\n\n    def __le__(self, other):\n        return self.issubset(other)\n\n    def __lt__(self, other):\n        return len(other) > len(self._items) and self.issubset(other)\n\n    def __ge__(self, other):\n        return self.issuperset(other)\n\n    def __gt__(self, other):\n        return len(self._items) > len(other) and self.issuperset(other)\n\n    def __and__(self, other):\n        return self._intersect(other)\n    __rand__ = __and__\n\n    def __iand__(self, other):\n        isect = self._intersect(other)\n        self._items = isect._items\n        return self\n\n    def __or__(self, other):\n        return self.union(other)\n    __ror__ = __or__\n\n    def __ior__(self, other):\n        union = self.union(other)\n        self._items = union._items\n        return self\n\n    def __sub__(self, other):\n        return self._diff(other)\n\n    def __rsub__(self, other):\n        return sortedset(other) - self\n\n    def __isub__(self, other):\n        diff = self._diff(other)\n        self._items = diff._items\n        return self\n\n    def __xor__(self, other):\n        return self.symmetric_difference(other)\n    __rxor__ = __xor__\n\n    def __ixor__(self, other):\n        sym_diff = self.symmetric_difference(other)\n        self._items = sym_diff._items\n        return self\n\n    def __contains__(self, item):\n        i = self._find_insertion(item)\n        return i < len(self._items) and self._items[i] == item\n\n    def __delitem__(self, i):\n        del self._items[i]\n\n    def __delslice__(self, i, j):\n        del self._items[i:j]\n\n    def add(self, item):\n        i = self._find_insertion(item)\n        if i < len(self._items):\n            if self._items[i] != item:\n                self._items.insert(i, item)\n        else:\n            self._items.append(item)\n\n    def update(self, iterable):\n        for i in iterable:\n            self.add(i)\n\n    def clear(self):\n        del self._items[:]\n\n    def copy(self):\n        new = sortedset()\n        new._items = list(self._items)\n        return new\n\n    def isdisjoint(self, other):\n        return len(self._intersect(other)) == 0\n\n    def issubset(self, other):\n        return len(self._intersect(other)) == len(self._items)\n\n    def issuperset(self, other):\n        return len(self._intersect(other)) == len(other)\n\n    def pop(self):\n        if not self._items:\n            raise KeyError(\"pop from empty set\")\n        return self._items.pop()\n\n    def remove(self, item):\n        i = self._find_insertion(item)\n        if i < len(self._items):\n            if self._items[i] == item:\n                self._items.pop(i)\n                return\n        raise KeyError('%r' % item)\n\n    def union(self, *others):\n        union = sortedset()\n        union._items = list(self._items)\n        for other in others:\n            for item in other:\n                union.add(item)\n        return union\n\n    def intersection(self, *others):\n        isect = self.copy()\n        for other in others:\n            isect = isect._intersect(other)\n            if not isect:\n                break\n        return isect\n\n    def difference(self, *others):\n        diff = self.copy()\n        for other in others:\n            diff = diff._diff(other)\n            if not diff:\n                break\n        return diff\n\n    def symmetric_difference(self, other):\n        diff_self_other = self._diff(other)\n        diff_other_self = other.difference(self)\n        return diff_self_other.union(diff_other_self)\n\n    def _diff(self, other):\n        diff = sortedset()\n        for item in self._items:\n            if item not in other:\n                diff.add(item)\n        return diff\n\n    def _intersect(self, other):\n        isect = sortedset()\n        for item in self._items:\n            if item in other:\n                isect.add(item)\n        return isect\n\n    def _find_insertion(self, x):\n        # this uses bisect_left algorithm unless it has elements it can't compare,\n        # in which case it defaults to grouping non-comparable items at the beginning or end,\n        # and scanning sequentially to find an insertion point\n        a = self._items\n        lo = 0\n        hi = len(a)\n        try:\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if a[mid] < x: lo = mid + 1\n                else: hi = mid\n        except TypeError:\n            # could not compare a[mid] with x\n            # start scanning to find insertion point while swallowing type errors\n            lo = 0\n            compared_one = False  # flag is used to determine whether uncomparables are grouped at the front or back\n            while lo < hi:\n                try:\n                    if a[lo] == x or a[lo] >= x: break\n                    compared_one = True\n                except TypeError:\n                    if compared_one: break\n                lo += 1\n        return lo\n\nsortedset = SortedSet  # backwards-compatibility\n\n\nclass OrderedMap(Mapping):\n    '''\n    An ordered map that accepts non-hashable types for keys. It also maintains the\n    insertion order of items, behaving as OrderedDict in that regard. These maps\n    are constructed and read just as normal mapping types, except that they may\n    contain arbitrary collections and other non-hashable items as keys::\n\n        >>> od = OrderedMap([({'one': 1, 'two': 2}, 'value'),\n        ...                  ({'three': 3, 'four': 4}, 'value2')])\n        >>> list(od.keys())\n        [{'two': 2, 'one': 1}, {'three': 3, 'four': 4}]\n        >>> list(od.values())\n        ['value', 'value2']\n\n    These constructs are needed to support nested collections in Cassandra 2.1.3+,\n    where frozen collections can be specified as parameters to others::\n\n        CREATE TABLE example (\n            ...\n            value map<frozen<map<int, int>>, double>\n            ...\n        )\n\n    This class derives from the (immutable) Mapping API. Objects in these maps\n    are not intended be modified.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        if len(args) > 1:\n            raise TypeError('expected at most 1 arguments, got %d' % len(args))\n\n        self._items = []\n        self._index = {}\n        if args:\n            e = args[0]\n            if callable(getattr(e, 'keys', None)):\n                for k in e.keys():\n                    self._insert(k, e[k])\n            else:\n                for k, v in e:\n                    self._insert(k, v)\n\n        for k, v in kwargs.items():\n            self._insert(k, v)\n\n    def _insert(self, key, value):\n        flat_key = self._serialize_key(key)\n        i = self._index.get(flat_key, -1)\n        if i >= 0:\n            self._items[i] = (key, value)\n        else:\n            self._items.append((key, value))\n            self._index[flat_key] = len(self._items) - 1\n\n    __setitem__ = _insert\n\n    def __getitem__(self, key):\n        try:\n            index = self._index[self._serialize_key(key)]\n            return self._items[index][1]\n        except KeyError:\n            raise KeyError(str(key))\n\n    def __delitem__(self, key):\n        # not efficient -- for convenience only\n        try:\n            index = self._index.pop(self._serialize_key(key))\n            self._index = dict((k, i if i < index else i - 1) for k, i in self._index.items())\n            self._items.pop(index)\n        except KeyError:\n            raise KeyError(str(key))\n\n    def __iter__(self):\n        for i in self._items:\n            yield i[0]\n\n    def __len__(self):\n        return len(self._items)\n\n    def __eq__(self, other):\n        if isinstance(other, OrderedMap):\n            return self._items == other._items\n        try:\n            d = dict(other)\n            return len(d) == len(self._items) and all(i[1] == d[i[0]] for i in self._items)\n        except KeyError:\n            return False\n        except TypeError:\n            pass\n        return NotImplemented\n\n    def __repr__(self):\n        return '%s([%s])' % (\n            self.__class__.__name__,\n            ', '.join(\"(%r, %r)\" % (k, v) for k, v in self._items))\n\n    def __str__(self):\n        return '{%s}' % ', '.join(\"%r: %r\" % (k, v) for k, v in self._items)\n\n    def popitem(self):\n        try:\n            kv = self._items.pop()\n            del self._index[self._serialize_key(kv[0])]\n            return kv\n        except IndexError:\n            raise KeyError()\n\n    def _serialize_key(self, key):\n        return pickle.dumps(key)\n\n\nclass OrderedMapSerializedKey(OrderedMap):\n\n    def __init__(self, cass_type, protocol_version):\n        super(OrderedMapSerializedKey, self).__init__()\n        self.cass_key_type = cass_type\n        self.protocol_version = protocol_version\n\n    def _insert_unchecked(self, key, flat_key, value):\n        self._items.append((key, value))\n        self._index[flat_key] = len(self._items) - 1\n\n    def _serialize_key(self, key):\n        return self.cass_key_type.serialize(key, self.protocol_version)\n\n\n@total_ordering\nclass Time(object):\n    '''\n    Idealized time, independent of day.\n\n    Up to nanosecond resolution\n    '''\n\n    MICRO = 1000\n    MILLI = 1000 * MICRO\n    SECOND = 1000 * MILLI\n    MINUTE = 60 * SECOND\n    HOUR = 60 * MINUTE\n    DAY = 24 * HOUR\n\n    nanosecond_time = 0\n\n    def __init__(self, value):\n        \"\"\"\n        Initializer value can be:\n\n        - integer_type: absolute nanoseconds in the day\n        - datetime.time: built-in time\n        - string_type: a string time of the form \"HH:MM:SS[.mmmuuunnn]\"\n        \"\"\"\n        if isinstance(value, int):\n            self._from_timestamp(value)\n        elif isinstance(value, datetime.time):\n            self._from_time(value)\n        elif isinstance(value, str):\n            self._from_timestring(value)\n        else:\n            raise TypeError('Time arguments must be a whole number, datetime.time, or string')\n\n    @property\n    def hour(self):\n        \"\"\"\n        The hour component of this time (0-23)\n        \"\"\"\n        return self.nanosecond_time // Time.HOUR\n\n    @property\n    def minute(self):\n        \"\"\"\n        The minute component of this time (0-59)\n        \"\"\"\n        minutes = self.nanosecond_time // Time.MINUTE\n        return minutes % 60\n\n    @property\n    def second(self):\n        \"\"\"\n        The second component of this time (0-59)\n        \"\"\"\n        seconds = self.nanosecond_time // Time.SECOND\n        return seconds % 60\n\n    @property\n    def nanosecond(self):\n        \"\"\"\n        The fractional seconds component of the time, in nanoseconds\n        \"\"\"\n        return self.nanosecond_time % Time.SECOND\n\n    def time(self):\n        \"\"\"\n        Return a built-in datetime.time (nanosecond precision truncated to micros).\n        \"\"\"\n        return datetime.time(hour=self.hour, minute=self.minute, second=self.second,\n                             microsecond=self.nanosecond // Time.MICRO)\n\n    def _from_timestamp(self, t):\n        if t >= Time.DAY:\n            raise ValueError(\"value must be less than number of nanoseconds in a day (%d)\" % Time.DAY)\n        self.nanosecond_time = t\n\n    def _from_timestring(self, s):\n        try:\n            parts = s.split('.')\n            base_time = time.strptime(parts[0], \"%H:%M:%S\")\n            self.nanosecond_time = (base_time.tm_hour * Time.HOUR +\n                                    base_time.tm_min * Time.MINUTE +\n                                    base_time.tm_sec * Time.SECOND)\n\n            if len(parts) > 1:\n                # right pad to 9 digits\n                nano_time_str = parts[1] + \"0\" * (9 - len(parts[1]))\n                self.nanosecond_time += int(nano_time_str)\n\n        except ValueError:\n            raise ValueError(\"can't interpret %r as a time\" % (s,))\n\n    def _from_time(self, t):\n        self.nanosecond_time = (t.hour * Time.HOUR +\n                                t.minute * Time.MINUTE +\n                                t.second * Time.SECOND +\n                                t.microsecond * Time.MICRO)\n\n    def __hash__(self):\n        return self.nanosecond_time\n\n    def __eq__(self, other):\n        if isinstance(other, Time):\n            return self.nanosecond_time == other.nanosecond_time\n\n        if isinstance(other, int):\n            return self.nanosecond_time == other\n\n        return self.nanosecond_time % Time.MICRO == 0 and \\\n            datetime.time(hour=self.hour, minute=self.minute, second=self.second,\n                          microsecond=self.nanosecond // Time.MICRO) == other\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(other, Time):\n            return NotImplemented\n        return self.nanosecond_time < other.nanosecond_time\n\n    def __repr__(self):\n        return \"Time(%s)\" % self.nanosecond_time\n\n    def __str__(self):\n        return \"%02d:%02d:%02d.%09d\" % (self.hour, self.minute,\n                                        self.second, self.nanosecond)\n\n\n@total_ordering\nclass Date(object):\n    '''\n    Idealized date: year, month, day\n\n    Offers wider year range than datetime.date. For Dates that cannot be represented\n    as a datetime.date (because datetime.MINYEAR, datetime.MAXYEAR), this type falls back\n    to printing days_from_epoch offset.\n    '''\n\n    MINUTE = 60\n    HOUR = 60 * MINUTE\n    DAY = 24 * HOUR\n\n    date_format = \"%Y-%m-%d\"\n\n    days_from_epoch = 0\n\n    def __init__(self, value):\n        \"\"\"\n        Initializer value can be:\n\n        - integer_type: absolute days from epoch (1970, 1, 1). Can be negative.\n        - datetime.date: built-in date\n        - string_type: a string time of the form \"yyyy-mm-dd\"\n        \"\"\"\n        if isinstance(value, int):\n            self.days_from_epoch = value\n        elif isinstance(value, (datetime.date, datetime.datetime)):\n            self._from_timetuple(value.timetuple())\n        elif isinstance(value, str):\n            self._from_datestring(value)\n        else:\n            raise TypeError('Date arguments must be a whole number, datetime.date, or string')\n\n    @property\n    def seconds(self):\n        \"\"\"\n        Absolute seconds from epoch (can be negative)\n        \"\"\"\n        return self.days_from_epoch * Date.DAY\n\n    def date(self):\n        \"\"\"\n        Return a built-in datetime.date for Dates falling in the years [datetime.MINYEAR, datetime.MAXYEAR]\n\n        ValueError is raised for Dates outside this range.\n        \"\"\"\n        try:\n            dt = datetime_from_timestamp(self.seconds)\n            return datetime.date(dt.year, dt.month, dt.day)\n        except Exception:\n            raise ValueError(\"%r exceeds ranges for built-in datetime.date\" % self)\n\n    def _from_timetuple(self, t):\n        self.days_from_epoch = calendar.timegm(t) // Date.DAY\n\n    def _from_datestring(self, s):\n        if s[0] == '+':\n            s = s[1:]\n        dt = datetime.datetime.strptime(s, self.date_format)\n        self._from_timetuple(dt.timetuple())\n\n    def __hash__(self):\n        return self.days_from_epoch\n\n    def __eq__(self, other):\n        if isinstance(other, Date):\n            return self.days_from_epoch == other.days_from_epoch\n\n        if isinstance(other, int):\n            return self.days_from_epoch == other\n\n        try:\n            return self.date() == other\n        except Exception:\n            return False\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(other, Date):\n            return NotImplemented\n        return self.days_from_epoch < other.days_from_epoch\n\n    def __repr__(self):\n        return \"Date(%s)\" % self.days_from_epoch\n\n    def __str__(self):\n        try:\n            dt = datetime_from_timestamp(self.seconds)\n            return \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n        except:\n            # If we overflow datetime.[MIN|MAX]\n            return str(self.days_from_epoch)\n\n\ninet_pton = socket.inet_pton\ninet_ntop = socket.inet_ntop\n\n\n# similar to collections.namedtuple, reproduced here because Python 2.6 did not have the rename logic\ndef _positional_rename_invalid_identifiers(field_names):\n    names_out = list(field_names)\n    for index, name in enumerate(field_names):\n        if (not all(c.isalnum() or c == '_' for c in name)\n            or keyword.iskeyword(name)\n            or not name\n            or name[0].isdigit()\n            or name.startswith('_')):\n            names_out[index] = 'field_%d_' % index\n    return names_out\n\n\ndef _sanitize_identifiers(field_names):\n    names_out = _positional_rename_invalid_identifiers(field_names)\n    if len(names_out) != len(set(names_out)):\n        observed_names = set()\n        for index, name in enumerate(names_out):\n            while names_out[index] in observed_names:\n                names_out[index] = \"%s_\" % (names_out[index],)\n            observed_names.add(names_out[index])\n    return names_out\n\n\ndef list_contents_to_tuple(to_convert):\n    if isinstance(to_convert, list):\n        for n, i in enumerate(to_convert):\n            if isinstance(to_convert[n], list):\n                to_convert[n] = tuple(to_convert[n])\n        return tuple(to_convert)\n    else:\n        return to_convert\n\n\nclass Point(object):\n    \"\"\"\n    Represents a point geometry for DSE\n    \"\"\"\n\n    x = None\n    \"\"\"\n    x coordinate of the point\n    \"\"\"\n\n    y = None\n    \"\"\"\n    y coordinate of the point\n    \"\"\"\n\n    def __init__(self, x=_nan, y=_nan):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return isinstance(other, Point) and self.x == other.x and self.y == other.y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the point\n        \"\"\"\n        return \"POINT (%r %r)\" % (self.x, self.y)\n\n    def __repr__(self):\n        return \"%s(%r, %r)\" % (self.__class__.__name__, self.x, self.y)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Point geometry from a wkt string and return a new Point object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException(\"Geomet is required to deserialize a wkt geometry.\")\n\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n\n        if geom['type'] != 'Point':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'Point', got '{0}': '{1}'\".format(geom['type'], s))\n\n        coords = geom['coordinates']\n        if len(coords) < 2:\n            x = y = _nan\n        else:\n            x = coords[0]\n            y = coords[1]\n\n        return Point(x=x, y=y)\n\n\nclass LineString(object):\n    \"\"\"\n    Represents a linestring geometry for DSE\n    \"\"\"\n\n    coords = None\n    \"\"\"\n    Tuple of (x, y) coordinates in the linestring\n    \"\"\"\n    def __init__(self, coords=tuple()):\n        \"\"\"\n        'coords`: a sequence of (x, y) coordinates of points in the linestring\n        \"\"\"\n        self.coords = tuple(coords)\n\n    def __eq__(self, other):\n        return isinstance(other, LineString) and self.coords == other.coords\n\n    def __hash__(self):\n        return hash(self.coords)\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the LineString\n        \"\"\"\n        if not self.coords:\n            return \"LINESTRING EMPTY\"\n        return \"LINESTRING (%s)\" % ', '.join(\"%r %r\" % (x, y) for x, y in self.coords)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.coords)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a LineString geometry from a wkt string and return a new LineString object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException(\"Geomet is required to deserialize a wkt geometry.\")\n\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n\n        if geom['type'] != 'LineString':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'LineString', got '{0}': '{1}'\".format(geom['type'], s))\n\n        geom['coordinates'] = list_contents_to_tuple(geom['coordinates'])\n\n        return LineString(coords=geom['coordinates'])\n\n\nclass _LinearRing(object):\n    # no validation, no implicit closing; just used for poly composition, to\n    # mimic that of shapely.geometry.Polygon\n    def __init__(self, coords=tuple()):\n        self.coords = list_contents_to_tuple(coords)\n\n    def __eq__(self, other):\n        return isinstance(other, _LinearRing) and self.coords == other.coords\n\n    def __hash__(self):\n        return hash(self.coords)\n\n    def __str__(self):\n        if not self.coords:\n            return \"LINEARRING EMPTY\"\n        return \"LINEARRING (%s)\" % ', '.join(\"%r %r\" % (x, y) for x, y in self.coords)\n\n    def __repr__(self):\n        return \"%s(%r)\" % (self.__class__.__name__, self.coords)\n\n\nclass Polygon(object):\n    \"\"\"\n    Represents a polygon geometry for DSE\n    \"\"\"\n\n    exterior = None\n    \"\"\"\n    _LinearRing representing the exterior of the polygon\n    \"\"\"\n\n    interiors = None\n    \"\"\"\n    Tuple of _LinearRings representing interior holes in the polygon\n    \"\"\"\n\n    def __init__(self, exterior=tuple(), interiors=None):\n        \"\"\"\n        'exterior`: a sequence of (x, y) coordinates of points in the linestring\n        `interiors`: None, or a sequence of sequences or (x, y) coordinates of points describing interior linear rings\n        \"\"\"\n        self.exterior = _LinearRing(exterior)\n        self.interiors = tuple(_LinearRing(e) for e in interiors) if interiors else tuple()\n\n    def __eq__(self, other):\n        return isinstance(other, Polygon) and self.exterior == other.exterior and self.interiors == other.interiors\n\n    def __hash__(self):\n        return hash((self.exterior, self.interiors))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the polygon\n        \"\"\"\n        if not self.exterior.coords:\n            return \"POLYGON EMPTY\"\n        rings = [ring.coords for ring in chain((self.exterior,), self.interiors)]\n        rings = [\"(%s)\" % ', '.join(\"%r %r\" % (x, y) for x, y in ring) for ring in rings]\n        return \"POLYGON (%s)\" % ', '.join(rings)\n\n    def __repr__(self):\n        return \"%s(%r, %r)\" % (self.__class__.__name__, self.exterior.coords, [ring.coords for ring in self.interiors])\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Polygon geometry from a wkt string and return a new Polygon object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException(\"Geomet is required to deserialize a wkt geometry.\")\n\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n\n        if geom['type'] != 'Polygon':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'Polygon', got '{0}': '{1}'\".format(geom['type'], s))\n\n        coords = geom['coordinates']\n        exterior = coords[0] if len(coords) > 0 else tuple()\n        interiors = coords[1:] if len(coords) > 1 else None\n\n        return Polygon(exterior=exterior, interiors=interiors)\n\n\n_distance_wkt_pattern = re.compile(\"distance *\\\\( *\\\\( *([\\\\d\\\\.-]+) *([\\\\d+\\\\.-]+) *\\\\) *([\\\\d+\\\\.-]+) *\\\\) *$\", re.IGNORECASE)\n\n\nclass Distance(object):\n    \"\"\"\n    Represents a Distance geometry for DSE\n    \"\"\"\n\n    x = None\n    \"\"\"\n    x coordinate of the center point\n    \"\"\"\n\n    y = None\n    \"\"\"\n    y coordinate of the center point\n    \"\"\"\n\n    radius = None\n    \"\"\"\n    radius to represent the distance from the center point\n    \"\"\"\n\n    def __init__(self, x=_nan, y=_nan, radius=_nan):\n        self.x = x\n        self.y = y\n        self.radius = radius\n\n    def __eq__(self, other):\n        return isinstance(other, Distance) and self.x == other.x and self.y == other.y and self.radius == other.radius\n\n    def __hash__(self):\n        return hash((self.x, self.y, self.radius))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the point\n        \"\"\"\n        return \"DISTANCE ((%r %r) %r)\" % (self.x, self.y, self.radius)\n\n    def __repr__(self):\n        return \"%s(%r, %r, %r)\" % (self.__class__.__name__, self.x, self.y, self.radius)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Distance geometry from a wkt string and return a new Distance object.\n        \"\"\"\n\n        distance_match = _distance_wkt_pattern.match(s)\n\n        if distance_match is None:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n\n        x, y, radius = distance_match.groups()\n        return Distance(x, y, radius)\n\n\nclass Duration(object):\n    \"\"\"\n    Cassandra Duration Type\n    \"\"\"\n\n    months = 0\n    \"\"\n    days = 0\n    \"\"\n    nanoseconds = 0\n    \"\"\n\n    def __init__(self, months=0, days=0, nanoseconds=0):\n        self.months = months\n        self.days = days\n        self.nanoseconds = nanoseconds\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.months == other.months and self.days == other.days and self.nanoseconds == other.nanoseconds\n\n    def __repr__(self):\n        return \"Duration({0}, {1}, {2})\".format(self.months, self.days, self.nanoseconds)\n\n    def __str__(self):\n        has_negative_values = self.months < 0 or self.days < 0 or self.nanoseconds < 0\n        return '%s%dmo%dd%dns' % (\n            '-' if has_negative_values else '',\n            abs(self.months),\n            abs(self.days),\n            abs(self.nanoseconds)\n        )\n\n\nclass DateRangePrecision(object):\n    \"\"\"\n    An \"enum\" representing the valid values for :attr:`DateRange.precision`.\n    \"\"\"\n    YEAR = 'YEAR'\n    \"\"\"\n    \"\"\"\n\n    MONTH = 'MONTH'\n    \"\"\"\n    \"\"\"\n\n    DAY = 'DAY'\n    \"\"\"\n    \"\"\"\n\n    HOUR = 'HOUR'\n    \"\"\"\n    \"\"\"\n\n    MINUTE = 'MINUTE'\n    \"\"\"\n    \"\"\"\n\n    SECOND = 'SECOND'\n    \"\"\"\n    \"\"\"\n\n    MILLISECOND = 'MILLISECOND'\n    \"\"\"\n    \"\"\"\n\n    PRECISIONS = (YEAR, MONTH, DAY, HOUR,\n                  MINUTE, SECOND, MILLISECOND)\n    \"\"\"\n    \"\"\"\n\n    @classmethod\n    def _to_int(cls, precision):\n        return cls.PRECISIONS.index(precision.upper())\n\n    @classmethod\n    def _round_to_precision(cls, ms, precision, default_dt):\n        try:\n            dt = utc_datetime_from_ms_timestamp(ms)\n        except OverflowError:\n            return ms\n        precision_idx = cls._to_int(precision)\n        replace_kwargs = {}\n        if precision_idx <= cls._to_int(DateRangePrecision.YEAR):\n            replace_kwargs['month'] = default_dt.month\n        if precision_idx <= cls._to_int(DateRangePrecision.MONTH):\n            replace_kwargs['day'] = default_dt.day\n        if precision_idx <= cls._to_int(DateRangePrecision.DAY):\n            replace_kwargs['hour'] = default_dt.hour\n        if precision_idx <= cls._to_int(DateRangePrecision.HOUR):\n            replace_kwargs['minute'] = default_dt.minute\n        if precision_idx <= cls._to_int(DateRangePrecision.MINUTE):\n            replace_kwargs['second'] = default_dt.second\n        if precision_idx <= cls._to_int(DateRangePrecision.SECOND):\n            # truncate to nearest 1000 so we deal in ms, not us\n            replace_kwargs['microsecond'] = (default_dt.microsecond // 1000) * 1000\n        if precision_idx == cls._to_int(DateRangePrecision.MILLISECOND):\n            replace_kwargs['microsecond'] = int(round(dt.microsecond, -3))\n        return ms_timestamp_from_datetime(dt.replace(**replace_kwargs))\n\n    @classmethod\n    def round_up_to_precision(cls, ms, precision):\n        # PYTHON-912: this is the only case in which we can't take as upper bound\n        # datetime.datetime.max because the month from ms may be February and we'd\n        # be setting 31 as the month day\n        if precision == cls.MONTH:\n            date_ms = utc_datetime_from_ms_timestamp(ms)\n            upper_date = datetime.datetime.max.replace(year=date_ms.year, month=date_ms.month,\n                                                       day=calendar.monthrange(date_ms.year, date_ms.month)[1])\n        else:\n            upper_date = datetime.datetime.max\n        return cls._round_to_precision(ms, precision, upper_date)\n\n    @classmethod\n    def round_down_to_precision(cls, ms, precision):\n        return cls._round_to_precision(ms, precision, datetime.datetime.min)\n\n\n@total_ordering\nclass DateRangeBound(object):\n    \"\"\"DateRangeBound(value, precision)\n    Represents a single date value and its precision for :class:`DateRange`.\n\n    .. attribute:: milliseconds\n\n        Integer representing milliseconds since the UNIX epoch. May be negative.\n\n    .. attribute:: precision\n\n        String representing the precision of a bound. Must be a valid\n        :class:`DateRangePrecision` member.\n\n    :class:`DateRangeBound` uses a millisecond offset from the UNIX epoch to\n    allow :class:`DateRange` to represent values `datetime.datetime` cannot.\n    For such values, string representions will show this offset rather than the\n    CQL representation.\n    \"\"\"\n    milliseconds = None\n    precision = None\n\n    def __init__(self, value, precision):\n        \"\"\"\n        :param value: a value representing ms since the epoch. Accepts an\n            integer or a datetime.\n        :param precision: a string representing precision\n        \"\"\"\n        if precision is not None:\n            try:\n                self.precision = precision.upper()\n            except AttributeError:\n                raise TypeError('precision must be a string; got %r' % precision)\n\n        if value is None:\n            milliseconds = None\n        elif isinstance(value, int):\n            milliseconds = value\n        elif isinstance(value, datetime.datetime):\n            value = value.replace(\n                microsecond=int(round(value.microsecond, -3))\n            )\n            milliseconds = ms_timestamp_from_datetime(value)\n        else:\n            raise ValueError('%r is not a valid value for DateRangeBound' % value)\n\n        self.milliseconds = milliseconds\n        self.validate()\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return (self.milliseconds == other.milliseconds and\n                self.precision == other.precision)\n\n    def __lt__(self, other):\n        return ((str(self.milliseconds), str(self.precision)) <\n                (str(other.milliseconds), str(other.precision)))\n\n    def datetime(self):\n        \"\"\"\n        Return :attr:`milliseconds` as a :class:`datetime.datetime` if possible.\n        Raises an `OverflowError` if the value is out of range.\n        \"\"\"\n        return utc_datetime_from_ms_timestamp(self.milliseconds)\n\n    def validate(self):\n        attrs = self.milliseconds, self.precision\n        if attrs == (None, None):\n            return\n        if None in attrs:\n            raise TypeError(\n                (\"%s.datetime and %s.precision must not be None unless both \"\n                 \"are None; Got: %r\") % (self.__class__.__name__,\n                                         self.__class__.__name__,\n                                         self)\n            )\n        if self.precision not in DateRangePrecision.PRECISIONS:\n            raise ValueError(\n                \"%s.precision: expected value in %r; got %r\" % (\n                    self.__class__.__name__,\n                    DateRangePrecision.PRECISIONS,\n                    self.precision\n                )\n            )\n\n    @classmethod\n    def from_value(cls, value):\n        \"\"\"\n        Construct a new :class:`DateRangeBound` from a given value. If\n        possible, use the `value['milliseconds']` and `value['precision']` keys\n        of the argument. Otherwise, use the argument as a `(milliseconds,\n        precision)` iterable.\n\n        :param value: a dictlike or iterable object\n        \"\"\"\n        if isinstance(value, cls):\n            return value\n\n        # if possible, use as a mapping\n        try:\n            milliseconds, precision = value.get('milliseconds'), value.get('precision')\n        except AttributeError:\n            milliseconds = precision = None\n        if milliseconds is not None and precision is not None:\n            return DateRangeBound(value=milliseconds, precision=precision)\n\n        # otherwise, use as an iterable\n        return DateRangeBound(*value)\n\n    def round_up(self):\n        if self.milliseconds is None or self.precision is None:\n            return self\n        self.milliseconds = DateRangePrecision.round_up_to_precision(\n            self.milliseconds, self.precision\n        )\n        return self\n\n    def round_down(self):\n        if self.milliseconds is None or self.precision is None:\n            return self\n        self.milliseconds = DateRangePrecision.round_down_to_precision(\n            self.milliseconds, self.precision\n        )\n        return self\n\n    _formatter_map = {\n        DateRangePrecision.YEAR: '%Y',\n        DateRangePrecision.MONTH: '%Y-%m',\n        DateRangePrecision.DAY: '%Y-%m-%d',\n        DateRangePrecision.HOUR: '%Y-%m-%dT%HZ',\n        DateRangePrecision.MINUTE: '%Y-%m-%dT%H:%MZ',\n        DateRangePrecision.SECOND: '%Y-%m-%dT%H:%M:%SZ',\n        DateRangePrecision.MILLISECOND: '%Y-%m-%dT%H:%M:%S',\n    }\n\n    def __str__(self):\n        if self == OPEN_BOUND:\n            return '*'\n\n        try:\n            dt = self.datetime()\n        except OverflowError:\n            return '%sms' % (self.milliseconds,)\n\n        formatted = dt.strftime(self._formatter_map[self.precision])\n\n        if self.precision == DateRangePrecision.MILLISECOND:\n            # we'd like to just format with '%Y-%m-%dT%H:%M:%S.%fZ', but %f\n            # gives us more precision than we want, so we strftime up to %S and\n            # do the rest ourselves\n            return '%s.%03dZ' % (formatted, dt.microsecond / 1000)\n\n        return formatted\n\n    def __repr__(self):\n        return '%s(milliseconds=%r, precision=%r)' % (\n            self.__class__.__name__, self.milliseconds, self.precision\n        )\n\n\nOPEN_BOUND = DateRangeBound(value=None, precision=None)\n\"\"\"\nRepresents `*`, an open value or bound for :class:`DateRange`.\n\"\"\"\n\n\n@total_ordering\nclass DateRange(object):\n    \"\"\"DateRange(lower_bound=None, upper_bound=None, value=None)\n    DSE DateRange Type\n\n    .. attribute:: lower_bound\n\n        :class:`~DateRangeBound` representing the lower bound of a bounded range.\n\n    .. attribute:: upper_bound\n\n        :class:`~DateRangeBound` representing the upper bound of a bounded range.\n\n    .. attribute:: value\n\n        :class:`~DateRangeBound` representing the value of a single-value range.\n\n    As noted in its documentation, :class:`DateRangeBound` uses a millisecond\n    offset from the UNIX epoch to allow :class:`DateRange` to represent values\n    `datetime.datetime` cannot. For such values, string representions will show\n    this offset rather than the CQL representation.\n    \"\"\"\n    lower_bound = None\n    upper_bound = None\n    value = None\n\n    def __init__(self, lower_bound=None, upper_bound=None, value=None):\n        \"\"\"\n        :param lower_bound: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as a\n            :attr:`lower_bound`. Mutually exclusive with `value`. If\n            `upper_bound` is specified and this is not, the :attr:`lower_bound`\n            will be open.\n        :param upper_bound: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as a\n            :attr:`upper_bound`. Mutually exclusive with `value`. If\n            `lower_bound` is specified and this is not, the :attr:`upper_bound`\n            will be open.\n        :param value: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as :attr:`value`. Mutually\n            exclusive with `lower_bound` and `lower_bound`.\n        \"\"\"\n\n        # if necessary, transform non-None args to DateRangeBounds\n        lower_bound = (DateRangeBound.from_value(lower_bound).round_down()\n                       if lower_bound else lower_bound)\n        upper_bound = (DateRangeBound.from_value(upper_bound).round_up()\n                       if upper_bound else upper_bound)\n        value = (DateRangeBound.from_value(value).round_down()\n                 if value else value)\n\n        # if we're using a 2-ended range but one bound isn't specified, specify\n        # an open bound\n        if lower_bound is None and upper_bound is not None:\n            lower_bound = OPEN_BOUND\n        if upper_bound is None and lower_bound is not None:\n            upper_bound = OPEN_BOUND\n\n        self.lower_bound, self.upper_bound, self.value = (\n            lower_bound, upper_bound, value\n        )\n        self.validate()\n\n    def validate(self):\n        if self.value is None:\n            if self.lower_bound is None or self.upper_bound is None:\n                raise ValueError(\n                    '%s instances where value attribute is None must set '\n                    'lower_bound or upper_bound; got %r' % (\n                        self.__class__.__name__,\n                        self\n                    )\n                )\n        else:  # self.value is not None\n            if self.lower_bound is not None or self.upper_bound is not None:\n                raise ValueError(\n                    '%s instances where value attribute is not None must not '\n                    'set lower_bound or upper_bound; got %r' % (\n                        self.__class__.__name__,\n                        self\n                    )\n                )\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return (self.lower_bound == other.lower_bound and\n                self.upper_bound == other.upper_bound and\n                self.value == other.value)\n\n    def __lt__(self, other):\n        return ((str(self.lower_bound), str(self.upper_bound), str(self.value)) <\n                (str(other.lower_bound), str(other.upper_bound), str(other.value)))\n\n    def __str__(self):\n        if self.value:\n            return str(self.value)\n        else:\n            return '[%s TO %s]' % (self.lower_bound, self.upper_bound)\n\n    def __repr__(self):\n        return '%s(lower_bound=%r, upper_bound=%r, value=%r)' % (\n            self.__class__.__name__,\n            self.lower_bound, self.upper_bound, self.value\n        )\n\n\n@total_ordering\nclass Version(object):\n    \"\"\"\n    Internal minimalist class to compare versions.\n    A valid version is: <int>.<int>.<int>.<int or str>.\n\n    TODO: when python2 support is removed, use packaging.version.\n    \"\"\"\n\n    _version = None\n    major = None\n    minor = 0\n    patch = 0\n    build = 0\n    prerelease = 0\n\n    def __init__(self, version):\n        self._version = version\n        if '-' in version:\n            version_without_prerelease, self.prerelease = version.split('-', 1)\n        else:\n            version_without_prerelease = version\n        parts = list(reversed(version_without_prerelease.split('.')))\n        if len(parts) > 4:\n            prerelease_string = \"-{}\".format(self.prerelease) if self.prerelease else \"\"\n            log.warning(\"Unrecognized version: {}. Only 4 components plus prerelease are supported. \"\n                        \"Assuming version as {}{}\".format(version, '.'.join(parts[:-5:-1]), prerelease_string))\n\n        try:\n            self.major = int(parts.pop())\n        except ValueError as e:\n            raise ValueError(\n                \"Couldn't parse version {}. Version should start with a number\".format(version))\\\n                .with_traceback(e.__traceback__)\n        try:\n            self.minor = int(parts.pop()) if parts else 0\n            self.patch = int(parts.pop()) if parts else 0\n\n            if parts:  # we have a build version\n                build = parts.pop()\n                try:\n                    self.build = int(build)\n                except ValueError:\n                    self.build = build\n        except ValueError:\n            assumed_version = \"{}.{}.{}.{}-{}\".format(self.major, self.minor, self.patch, self.build, self.prerelease)\n            log.warning(\"Unrecognized version {}. Assuming version as {}\".format(version, assumed_version))\n\n    def __hash__(self):\n        return self._version\n\n    def __repr__(self):\n        version_string = \"Version({0}, {1}, {2}\".format(self.major, self.minor, self.patch)\n        if self.build:\n            version_string += \", {}\".format(self.build)\n        if self.prerelease:\n            version_string += \", {}\".format(self.prerelease)\n        version_string += \")\"\n\n        return version_string\n\n    def __str__(self):\n        return self._version\n\n    @staticmethod\n    def _compare_version_part(version, other_version, cmp):\n        if not (isinstance(version, int) and\n                isinstance(other_version, int)):\n            version = str(version)\n            other_version = str(other_version)\n\n        return cmp(version, other_version)\n\n    def __eq__(self, other):\n        if not isinstance(other, Version):\n            return NotImplemented\n\n        return (self.major == other.major and\n                self.minor == other.minor and\n                self.patch == other.patch and\n                self._compare_version_part(self.build, other.build, lambda s, o: s == o) and\n                self._compare_version_part(self.prerelease, other.prerelease, lambda s, o: s == o)\n                )\n\n    def __gt__(self, other):\n        if not isinstance(other, Version):\n            return NotImplemented\n\n        is_major_ge = self.major >= other.major\n        is_minor_ge = self.minor >= other.minor\n        is_patch_ge = self.patch >= other.patch\n        is_build_gt = self._compare_version_part(self.build, other.build, lambda s, o: s > o)\n        is_build_ge = self._compare_version_part(self.build, other.build, lambda s, o: s >= o)\n\n        # By definition, a prerelease comes BEFORE the actual release, so if a version\n        # doesn't have a prerelease, it's automatically greater than anything that does\n        if self.prerelease and not other.prerelease:\n            is_prerelease_gt = False\n        elif other.prerelease and not self.prerelease:\n            is_prerelease_gt = True\n        else:\n            is_prerelease_gt = self._compare_version_part(self.prerelease, other.prerelease, lambda s, o: s > o) \\\n\n        return (self.major > other.major or\n                (is_major_ge and self.minor > other.minor) or\n                (is_major_ge and is_minor_ge and self.patch > other.patch) or\n                (is_major_ge and is_minor_ge and is_patch_ge and is_build_gt) or\n                (is_major_ge and is_minor_ge and is_patch_ge and is_build_ge and is_prerelease_gt)\n                )\n",
    "cassandra/cqltypes.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nRepresentation of Cassandra data types. These classes should make it simple for\nthe library (and caller software) to deal with Cassandra-style Java class type\nnames and CQL type specifiers, and convert between them cleanly. Parameterized\ntypes are fully supported in both flavors. Once you have the right Type object\nfor the type you want, you can use it to serialize, deserialize, or retrieve\nthe corresponding CQL or Cassandra type strings.\n\"\"\"\n\n# NOTE:\n# If/when the need arises for interpret types from CQL string literals in\n# different ways (for https://issues.apache.org/jira/browse/CASSANDRA-3799,\n# for example), these classes would be a good place to tack on\n# .from_cql_literal() and .as_cql_literal() classmethods (or whatever).\n\nfrom __future__ import absolute_import  # to enable import io from stdlib\nimport ast\nfrom binascii import unhexlify\nimport calendar\nfrom collections import namedtuple\nfrom decimal import Decimal\nimport io\nfrom itertools import chain\nimport logging\nimport re\nimport socket\nimport time\nimport struct\nimport sys\nfrom uuid import UUID\n\nfrom cassandra.marshal import (int8_pack, int8_unpack, int16_pack, int16_unpack,\n                               uint16_pack, uint16_unpack, uint32_pack, uint32_unpack,\n                               int32_pack, int32_unpack, int64_pack, int64_unpack,\n                               float_pack, float_unpack, double_pack, double_unpack,\n                               varint_pack, varint_unpack, point_be, point_le,\n                               vints_pack, vints_unpack, uvint_unpack, uvint_pack)\nfrom cassandra import util\n\n_little_endian_flag = 1  # we always serialize LE\nimport ipaddress\n\napache_cassandra_type_prefix = 'org.apache.cassandra.db.marshal.'\n\ncassandra_empty_type = 'org.apache.cassandra.db.marshal.EmptyType'\ncql_empty_type = 'empty'\n\nlog = logging.getLogger(__name__)\n\n_number_types = frozenset((int, float))\n\n\ndef _name_from_hex_string(encoded_name):\n    bin_str = unhexlify(encoded_name)\n    return bin_str.decode('ascii')\n\n\ndef trim_if_startswith(s, prefix):\n    if s.startswith(prefix):\n        return s[len(prefix):]\n    return s\n\n\n_casstypes = {}\n_cqltypes = {}\n\n\ncql_type_scanner = re.Scanner((\n    ('frozen', None),\n    (r'[a-zA-Z0-9_]+', lambda s, t: t),\n    (r'[\\s,<>]', None),\n))\n\n\ndef cql_types_from_string(cql_type):\n    return cql_type_scanner.scan(cql_type)[0]\n\n\nclass CassandraTypeType(type):\n    \"\"\"\n    The CassandraType objects in this module will normally be used directly,\n    rather than through instances of those types. They can be instantiated,\n    of course, but the type information is what this driver mainly needs.\n\n    This metaclass registers CassandraType classes in the global\n    by-cassandra-typename and by-cql-typename registries, unless their class\n    name starts with an underscore.\n    \"\"\"\n\n    def __new__(metacls, name, bases, dct):\n        dct.setdefault('cassname', name)\n        cls = type.__new__(metacls, name, bases, dct)\n        if not name.startswith('_'):\n            _casstypes[name] = cls\n            if not cls.typename.startswith(apache_cassandra_type_prefix):\n                _cqltypes[cls.typename] = cls\n        return cls\n\n\ncasstype_scanner = re.Scanner((\n    (r'[()]', lambda s, t: t),\n    (r'[a-zA-Z0-9_.:=>]+', lambda s, t: t),\n    (r'[\\s,]', None),\n))\n\n\ndef cqltype_to_python(cql_string):\n    \"\"\"\n    Given a cql type string, creates a list that can be manipulated in python\n    Example:\n        int -> ['int']\n        frozen<tuple<text, int>> -> ['frozen', ['tuple', ['text', 'int']]]\n    \"\"\"\n    scanner = re.Scanner((\n        (r'[a-zA-Z0-9_]+', lambda s, t: \"'{}'\".format(t)),\n        (r'<', lambda s, t: ', ['),\n        (r'>', lambda s, t: ']'),\n        (r'[, ]', lambda s, t: t),\n        (r'\".*?\"', lambda s, t: \"'{}'\".format(t)),\n    ))\n\n    scanned_tokens = scanner.scan(cql_string)[0]\n    hierarchy = ast.literal_eval(''.join(scanned_tokens))\n    return [hierarchy] if isinstance(hierarchy, str) else list(hierarchy)\n\n\ndef python_to_cqltype(types):\n    \"\"\"\n    Opposite of the `cql_to_python` function. Given a python list, creates a cql type string from the representation\n    Example:\n        ['int'] -> int\n        ['frozen', ['tuple', ['text', 'int']]] -> frozen<tuple<text, int>>\n    \"\"\"\n    scanner = re.Scanner((\n        (r\"'[a-zA-Z0-9_]+'\", lambda s, t: t[1:-1]),\n        (r'^\\[', lambda s, t: None),\n        (r'\\]$', lambda s, t: None),\n        (r',\\s*\\[', lambda s, t: '<'),\n        (r'\\]', lambda s, t: '>'),\n        (r'[, ]', lambda s, t: t),\n        (r'\\'\".*?\"\\'', lambda s, t: t[1:-1]),\n    ))\n\n    scanned_tokens = scanner.scan(repr(types))[0]\n    cql = ''.join(scanned_tokens).replace('\\\\\\\\', '\\\\')\n    return cql\n\n\ndef _strip_frozen_from_python(types):\n    \"\"\"\n    Given a python list representing a cql type, removes 'frozen'\n    Example:\n        ['frozen', ['tuple', ['text', 'int']]] -> ['tuple', ['text', 'int']]\n    \"\"\"\n    while 'frozen' in types:\n        index = types.index('frozen')\n        types = types[:index] + types[index + 1] + types[index + 2:]\n    new_types = [_strip_frozen_from_python(item) if isinstance(item, list) else item for item in types]\n    return new_types\n\n\ndef strip_frozen(cql):\n    \"\"\"\n    Given a cql type string, and removes frozen\n    Example:\n        frozen<tuple<int>> -> tuple<int>\n    \"\"\"\n    types = cqltype_to_python(cql)\n    types_without_frozen = _strip_frozen_from_python(types)\n    cql = python_to_cqltype(types_without_frozen)\n    return cql\n\n\ndef lookup_casstype_simple(casstype):\n    \"\"\"\n    Given a Cassandra type name (either fully distinguished or not), hand\n    back the CassandraType class responsible for it. If a name is not\n    recognized, a custom _UnrecognizedType subclass will be created for it.\n\n    This function does not handle complex types (so no type parameters--\n    nothing with parentheses). Use lookup_casstype() instead if you might need\n    that.\n    \"\"\"\n    shortname = trim_if_startswith(casstype, apache_cassandra_type_prefix)\n    try:\n        typeclass = _casstypes[shortname]\n    except KeyError:\n        typeclass = mkUnrecognizedType(casstype)\n    return typeclass\n\n\ndef parse_casstype_args(typestring):\n    tokens, remainder = casstype_scanner.scan(typestring)\n    if remainder:\n        raise ValueError(\"weird characters %r at end\" % remainder)\n\n    # use a stack of (types, names) lists\n    args = [([], [])]\n    for tok in tokens:\n        if tok == '(':\n            args.append(([], []))\n        elif tok == ')':\n            types, names = args.pop()\n            prev_types, prev_names = args[-1]\n            prev_types[-1] = prev_types[-1].apply_parameters(types, names)\n        else:\n            types, names = args[-1]\n            parts = re.split(':|=>', tok)\n            tok = parts.pop()\n            if parts:\n                names.append(parts[0])\n            else:\n                names.append(None)\n\n            try:\n                ctype = int(tok)\n            except ValueError:\n                ctype = lookup_casstype_simple(tok)\n            types.append(ctype)\n\n    # return the first (outer) type, which will have all parameters applied\n    return args[0][0][0]\n\ndef lookup_casstype(casstype):\n    \"\"\"\n    Given a Cassandra type as a string (possibly including parameters), hand\n    back the CassandraType class responsible for it. If a name is not\n    recognized, a custom _UnrecognizedType subclass will be created for it.\n\n    Example:\n\n        >>> lookup_casstype('org.apache.cassandra.db.marshal.MapType(org.apache.cassandra.db.marshal.UTF8Type,org.apache.cassandra.db.marshal.Int32Type)')\n        <class 'cassandra.cqltypes.MapType(UTF8Type, Int32Type)'>\n\n    \"\"\"\n    if isinstance(casstype, (CassandraType, CassandraTypeType)):\n        return casstype\n    try:\n        return parse_casstype_args(casstype)\n    except (ValueError, AssertionError, IndexError) as e:\n        raise ValueError(\"Don't know how to parse type string %r: %s\" % (casstype, e))\n\n\ndef is_reversed_casstype(data_type):\n    return issubclass(data_type, ReversedType)\n\n\nclass EmptyValue(object):\n    \"\"\" See _CassandraType.support_empty_values \"\"\"\n\n    def __str__(self):\n        return \"EMPTY\"\n    __repr__ = __str__\n\nEMPTY = EmptyValue()\n\n\nclass _CassandraType(object, metaclass=CassandraTypeType):\n    subtypes = ()\n    num_subtypes = 0\n    empty_binary_ok = False\n\n    support_empty_values = False\n    \"\"\"\n    Back in the Thrift days, empty strings were used for \"null\" values of\n    all types, including non-string types.  For most users, an empty\n    string value in an int column is the same as being null/not present,\n    so the driver normally returns None in this case.  (For string-like\n    types, it *will* return an empty string by default instead of None.)\n\n    To avoid this behavior, set this to :const:`True`. Instead of returning\n    None for empty string values, the EMPTY singleton (an instance\n    of EmptyValue) will be returned.\n    \"\"\"\n\n    def __repr__(self):\n        return '<%s>' % (self.cql_parameterized_type())\n\n    @classmethod\n    def from_binary(cls, byts, protocol_version):\n        \"\"\"\n        Deserialize a bytestring into a value. See the deserialize() method\n        for more information. This method differs in that if None or the empty\n        string is passed in, None may be returned.\n        \"\"\"\n        if byts is None:\n            return None\n        elif len(byts) == 0 and not cls.empty_binary_ok:\n            return EMPTY if cls.support_empty_values else None\n        return cls.deserialize(byts, protocol_version)\n\n    @classmethod\n    def to_binary(cls, val, protocol_version):\n        \"\"\"\n        Serialize a value into a bytestring. See the serialize() method for\n        more information. This method differs in that if None is passed in,\n        the result is the empty string.\n        \"\"\"\n        return b'' if val is None else cls.serialize(val, protocol_version)\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        \"\"\"\n        Given a bytestring, deserialize into a value according to the protocol\n        for this type. Note that this does not create a new instance of this\n        class; it merely gives back a value that would be appropriate to go\n        inside an instance of this class.\n        \"\"\"\n        return byts\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        \"\"\"\n        Given a value appropriate for this class, serialize it according to the\n        protocol for this type and return the corresponding bytestring.\n        \"\"\"\n        return val\n\n    @classmethod\n    def cass_parameterized_type_with(cls, subtypes, full=False):\n        \"\"\"\n        Return the name of this type as it would be expressed by Cassandra,\n        optionally fully qualified. If subtypes is not None, it is expected\n        to be a list of other CassandraType subclasses, and the output\n        string includes the Cassandra names for those subclasses as well,\n        as parameters to this one.\n\n        Example:\n\n            >>> LongType.cass_parameterized_type_with(())\n            'LongType'\n            >>> LongType.cass_parameterized_type_with((), full=True)\n            'org.apache.cassandra.db.marshal.LongType'\n            >>> SetType.cass_parameterized_type_with([DecimalType], full=True)\n            'org.apache.cassandra.db.marshal.SetType(org.apache.cassandra.db.marshal.DecimalType)'\n        \"\"\"\n        cname = cls.cassname\n        if full and '.' not in cname:\n            cname = apache_cassandra_type_prefix + cname\n        if not subtypes:\n            return cname\n        sublist = ', '.join(styp.cass_parameterized_type(full=full) for styp in subtypes)\n        return '%s(%s)' % (cname, sublist)\n\n    @classmethod\n    def apply_parameters(cls, subtypes, names=None):\n        \"\"\"\n        Given a set of other CassandraTypes, create a new subtype of this type\n        using them as parameters. This is how composite types are constructed.\n\n            >>> MapType.apply_parameters([DateType, BooleanType])\n            <class 'cassandra.cqltypes.MapType(DateType, BooleanType)'>\n\n        `subtypes` will be a sequence of CassandraTypes.  If provided, `names`\n        will be an equally long sequence of column names or Nones.\n        \"\"\"\n        if cls.num_subtypes != 'UNKNOWN' and len(subtypes) != cls.num_subtypes:\n            raise ValueError(\"%s types require %d subtypes (%d given)\"\n                             % (cls.typename, cls.num_subtypes, len(subtypes)))\n        newname = cls.cass_parameterized_type_with(subtypes)\n        return type(newname, (cls,), {'subtypes': subtypes, 'cassname': cls.cassname, 'fieldnames': names})\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        \"\"\"\n        Return a CQL type specifier for this type. If this type has parameters,\n        they are included in standard CQL <> notation.\n        \"\"\"\n        if not cls.subtypes:\n            return cls.typename\n        return '%s<%s>' % (cls.typename, ', '.join(styp.cql_parameterized_type() for styp in cls.subtypes))\n\n    @classmethod\n    def cass_parameterized_type(cls, full=False):\n        \"\"\"\n        Return a Cassandra type specifier for this type. If this type has\n        parameters, they are included in the standard () notation.\n        \"\"\"\n        return cls.cass_parameterized_type_with(cls.subtypes, full=full)\n\n    @classmethod\n    def serial_size(cls):\n        return None\n\n# it's initially named with a _ to avoid registering it as a real type, but\n# client programs may want to use the name still for isinstance(), etc\nCassandraType = _CassandraType\n\n\nclass _UnrecognizedType(_CassandraType):\n    num_subtypes = 'UNKNOWN'\n\n\ndef mkUnrecognizedType(casstypename):\n    return CassandraTypeType(casstypename,\n                             (_UnrecognizedType,),\n                             {'typename': \"'%s'\" % casstypename})\n\n\nclass BytesType(_CassandraType):\n    typename = 'blob'\n    empty_binary_ok = True\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        return bytes(val)\n\n\nclass DecimalType(_CassandraType):\n    typename = 'decimal'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        scale = int32_unpack(byts[:4])\n        unscaled = varint_unpack(byts[4:])\n        return Decimal('%de%d' % (unscaled, -scale))\n\n    @staticmethod\n    def serialize(dec, protocol_version):\n        try:\n            sign, digits, exponent = dec.as_tuple()\n        except AttributeError:\n            try:\n                sign, digits, exponent = Decimal(dec).as_tuple()\n            except Exception:\n                raise TypeError(\"Invalid type for Decimal value: %r\", dec)\n        unscaled = int(''.join([str(digit) for digit in digits]))\n        if sign:\n            unscaled *= -1\n        scale = int32_pack(-exponent)\n        unscaled = varint_pack(unscaled)\n        return scale + unscaled\n\n\nclass UUIDType(_CassandraType):\n    typename = 'uuid'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return UUID(bytes=byts)\n\n    @staticmethod\n    def serialize(uuid, protocol_version):\n        try:\n            return uuid.bytes\n        except AttributeError:\n            raise TypeError(\"Got a non-UUID object for a UUID value\")\n\n    @classmethod\n    def serial_size(cls):\n        return 16\n\nclass BooleanType(_CassandraType):\n    typename = 'boolean'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return bool(int8_unpack(byts))\n\n    @staticmethod\n    def serialize(truth, protocol_version):\n        return int8_pack(truth)\n\n    @classmethod\n    def serial_size(cls):\n        return 1\n\nclass ByteType(_CassandraType):\n    typename = 'tinyint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int8_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int8_pack(byts)\n\n\nclass AsciiType(_CassandraType):\n    typename = 'ascii'\n    empty_binary_ok = True\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return byts.decode('ascii')\n\n    @staticmethod\n    def serialize(var, protocol_version):\n        try:\n            return var.encode('ascii')\n        except UnicodeDecodeError:\n            return var\n\n\nclass FloatType(_CassandraType):\n    typename = 'float'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return float_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return float_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 4\n\nclass DoubleType(_CassandraType):\n    typename = 'double'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return double_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return double_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass LongType(_CassandraType):\n    typename = 'bigint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int64_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int64_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass Int32Type(_CassandraType):\n    typename = 'int'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int32_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int32_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 4\n\nclass IntegerType(_CassandraType):\n    typename = 'varint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return varint_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return varint_pack(byts)\n\n\nclass InetAddressType(_CassandraType):\n    typename = 'inet'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        if len(byts) == 16:\n            return util.inet_ntop(socket.AF_INET6, byts)\n        else:\n            # util.inet_pton could also handle, but this is faster\n            # since we've already determined the AF\n            return socket.inet_ntoa(byts)\n\n    @staticmethod\n    def serialize(addr, protocol_version):\n        try:\n            if ':' in addr:\n                return util.inet_pton(socket.AF_INET6, addr)\n            else:\n                # util.inet_pton could also handle, but this is faster\n                # since we've already determined the AF\n                return socket.inet_aton(addr)\n        except:\n            if isinstance(addr, (ipaddress.IPv4Address, ipaddress.IPv6Address)):\n                return addr.packed\n            raise ValueError(\"can't interpret %r as an inet address\" % (addr,))\n\n\nclass CounterColumnType(LongType):\n    typename = 'counter'\n\ncql_timestamp_formats = (\n    '%Y-%m-%d %H:%M',\n    '%Y-%m-%d %H:%M:%S',\n    '%Y-%m-%dT%H:%M',\n    '%Y-%m-%dT%H:%M:%S',\n    '%Y-%m-%d'\n)\n\n_have_warned_about_timestamps = False\n\n\nclass DateType(_CassandraType):\n    typename = 'timestamp'\n\n    @staticmethod\n    def interpret_datestring(val):\n        if val[-5] in ('+', '-'):\n            offset = (int(val[-4:-2]) * 3600 + int(val[-2:]) * 60) * int(val[-5] + '1')\n            val = val[:-5]\n        else:\n            offset = -time.timezone\n        for tformat in cql_timestamp_formats:\n            try:\n                tval = time.strptime(val, tformat)\n            except ValueError:\n                continue\n            # scale seconds to millis for the raw value\n            return (calendar.timegm(tval) + offset) * 1e3\n        else:\n            raise ValueError(\"can't interpret %r as a date\" % (val,))\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        timestamp = int64_unpack(byts) / 1000.0\n        return util.datetime_from_timestamp(timestamp)\n\n    @staticmethod\n    def serialize(v, protocol_version):\n        try:\n            # v is datetime\n            timestamp_seconds = calendar.timegm(v.utctimetuple())\n            timestamp = timestamp_seconds * 1e3 + getattr(v, 'microsecond', 0) / 1e3\n        except AttributeError:\n            try:\n                timestamp = calendar.timegm(v.timetuple()) * 1e3\n            except AttributeError:\n                # Ints and floats are valid timestamps too\n                if type(v) not in _number_types:\n                    raise TypeError('DateType arguments must be a datetime, date, or timestamp')\n                timestamp = v\n\n        return int64_pack(int(timestamp))\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass TimestampType(DateType):\n    pass\n\n\nclass TimeUUIDType(DateType):\n    typename = 'timeuuid'\n\n    def my_timestamp(self):\n        return util.unix_time_from_uuid1(self.val)\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return UUID(bytes=byts)\n\n    @staticmethod\n    def serialize(timeuuid, protocol_version):\n        try:\n            return timeuuid.bytes\n        except AttributeError:\n            raise TypeError(\"Got a non-UUID object for a UUID value\")\n\n    @classmethod\n    def serial_size(cls):\n        return 16\n\nclass SimpleDateType(_CassandraType):\n    typename = 'date'\n    date_format = \"%Y-%m-%d\"\n\n    # Values of the 'date'` type are encoded as 32-bit unsigned integers\n    # representing a number of days with epoch (January 1st, 1970) at the center of the\n    # range (2^31).\n    EPOCH_OFFSET_DAYS = 2 ** 31\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        days = uint32_unpack(byts) - SimpleDateType.EPOCH_OFFSET_DAYS\n        return util.Date(days)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        try:\n            days = val.days_from_epoch\n        except AttributeError:\n            if isinstance(val, int):\n                # the DB wants offset int values, but util.Date init takes days from epoch\n                # here we assume int values are offset, as they would appear in CQL\n                # short circuit to avoid subtracting just to add offset\n                return uint32_pack(val)\n            days = util.Date(val).days_from_epoch\n        return uint32_pack(days + SimpleDateType.EPOCH_OFFSET_DAYS)\n\n\nclass ShortType(_CassandraType):\n    typename = 'smallint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int16_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int16_pack(byts)\n\nclass TimeType(_CassandraType):\n    typename = 'time'\n    # Time should be a fixed size 8 byte type but Cassandra 5.0 code marks it as\n    # variable size... and we have to match what the server expects since the server\n    # uses that specification to encode data of that type.\n    #@classmethod\n    #def serial_size(cls):\n    #    return 8\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return util.Time(int64_unpack(byts))\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        try:\n            nano = val.nanosecond_time\n        except AttributeError:\n            nano = util.Time(val).nanosecond_time\n        return int64_pack(nano)\n\n\nclass DurationType(_CassandraType):\n    typename = 'duration'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        months, days, nanoseconds = vints_unpack(byts)\n        return util.Duration(months, days, nanoseconds)\n\n    @staticmethod\n    def serialize(duration, protocol_version):\n        try:\n            m, d, n = duration.months, duration.days, duration.nanoseconds\n        except AttributeError:\n            raise TypeError('DurationType arguments must be a Duration.')\n        return vints_pack([m, d, n])\n\n\nclass UTF8Type(_CassandraType):\n    typename = 'text'\n    empty_binary_ok = True\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return byts.decode('utf8')\n\n    @staticmethod\n    def serialize(ustr, protocol_version):\n        try:\n            return ustr.encode('utf-8')\n        except UnicodeDecodeError:\n            # already utf-8\n            return ustr\n\n\nclass VarcharType(UTF8Type):\n    typename = 'varchar'\n\n\nclass _ParameterizedType(_CassandraType):\n    num_subtypes = 'UNKNOWN'\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't deserialize unparameterized %s\"\n                                      % cls.typename)\n        return cls.deserialize_safe(byts, protocol_version)\n\n    @classmethod\n    def serialize(cls, val, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't serialize unparameterized %s\"\n                                      % cls.typename)\n        return cls.serialize_safe(val, protocol_version)\n\n\nclass _SimpleParameterizedType(_ParameterizedType):\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        if protocol_version >= 3:\n            unpack = int32_unpack\n            length = 4\n        else:\n            unpack = uint16_unpack\n            length = 2\n        numelements = unpack(byts[:length])\n        p = length\n        result = []\n        inner_proto = max(3, protocol_version)\n        for _ in range(numelements):\n            itemlen = unpack(byts[p:p + length])\n            p += length\n            if itemlen < 0:\n                result.append(None)\n            else:\n                item = byts[p:p + itemlen]\n                p += itemlen\n                result.append(subtype.from_binary(item, inner_proto))\n        return cls.adapter(result)\n\n    @classmethod\n    def serialize_safe(cls, items, protocol_version):\n        if isinstance(items, str):\n            raise TypeError(\"Received a string for a type that expects a sequence\")\n\n        subtype, = cls.subtypes\n        pack = int32_pack if protocol_version >= 3 else uint16_pack\n        buf = io.BytesIO()\n        buf.write(pack(len(items)))\n        inner_proto = max(3, protocol_version)\n        for item in items:\n            itembytes = subtype.to_binary(item, inner_proto)\n            buf.write(pack(len(itembytes)))\n            buf.write(itembytes)\n        return buf.getvalue()\n\n\nclass ListType(_SimpleParameterizedType):\n    typename = 'list'\n    num_subtypes = 1\n    adapter = list\n\n\nclass SetType(_SimpleParameterizedType):\n    typename = 'set'\n    num_subtypes = 1\n    adapter = util.sortedset\n\n\nclass MapType(_ParameterizedType):\n    typename = 'map'\n    num_subtypes = 2\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        key_type, value_type = cls.subtypes\n        if protocol_version >= 3:\n            unpack = int32_unpack\n            length = 4\n        else:\n            unpack = uint16_unpack\n            length = 2\n        numelements = unpack(byts[:length])\n        p = length\n        themap = util.OrderedMapSerializedKey(key_type, protocol_version)\n        inner_proto = max(3, protocol_version)\n        for _ in range(numelements):\n            key_len = unpack(byts[p:p + length])\n            p += length\n            if key_len < 0:\n                keybytes = None\n                key = None\n            else:\n                keybytes = byts[p:p + key_len]\n                p += key_len\n                key = key_type.from_binary(keybytes, inner_proto)\n\n            val_len = unpack(byts[p:p + length])\n            p += length\n            if val_len < 0:\n                val = None\n            else:\n                valbytes = byts[p:p + val_len]\n                p += val_len\n                val = value_type.from_binary(valbytes, inner_proto)\n\n            themap._insert_unchecked(key, keybytes, val)\n        return themap\n\n    @classmethod\n    def serialize_safe(cls, themap, protocol_version):\n        key_type, value_type = cls.subtypes\n        pack = int32_pack if protocol_version >= 3 else uint16_pack\n        buf = io.BytesIO()\n        buf.write(pack(len(themap)))\n        try:\n            items = themap.items()\n        except AttributeError:\n            raise TypeError(\"Got a non-map object for a map value\")\n        inner_proto = max(3, protocol_version)\n        for key, val in items:\n            keybytes = key_type.to_binary(key, inner_proto)\n            valbytes = value_type.to_binary(val, inner_proto)\n            buf.write(pack(len(keybytes)))\n            buf.write(keybytes)\n            buf.write(pack(len(valbytes)))\n            buf.write(valbytes)\n        return buf.getvalue()\n\n\nclass TupleType(_ParameterizedType):\n    typename = 'tuple'\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        proto_version = max(3, protocol_version)\n        p = 0\n        values = []\n        for col_type in cls.subtypes:\n            if p == len(byts):\n                break\n            itemlen = int32_unpack(byts[p:p + 4])\n            p += 4\n            if itemlen >= 0:\n                item = byts[p:p + itemlen]\n                p += itemlen\n            else:\n                item = None\n            # collections inside UDTs are always encoded with at least the\n            # version 3 format\n            values.append(col_type.from_binary(item, proto_version))\n\n        if len(values) < len(cls.subtypes):\n            nones = [None] * (len(cls.subtypes) - len(values))\n            values = values + nones\n\n        return tuple(values)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        if len(val) > len(cls.subtypes):\n            raise ValueError(\"Expected %d items in a tuple, but got %d: %s\" %\n                             (len(cls.subtypes), len(val), val))\n\n        proto_version = max(3, protocol_version)\n        buf = io.BytesIO()\n        for item, subtype in zip(val, cls.subtypes):\n            if item is not None:\n                packed_item = subtype.to_binary(item, proto_version)\n                buf.write(int32_pack(len(packed_item)))\n                buf.write(packed_item)\n            else:\n                buf.write(int32_pack(-1))\n        return buf.getvalue()\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        subtypes_string = ', '.join(sub.cql_parameterized_type() for sub in cls.subtypes)\n        return 'frozen<tuple<%s>>' % (subtypes_string,)\n\n\nclass UserType(TupleType):\n    typename = \"org.apache.cassandra.db.marshal.UserType\"\n\n    _cache = {}\n    _module = sys.modules[__name__]\n\n    @classmethod\n    def make_udt_class(cls, keyspace, udt_name, field_names, field_types):\n        assert len(field_names) == len(field_types)\n\n        instance = cls._cache.get((keyspace, udt_name))\n        if not instance or instance.fieldnames != field_names or instance.subtypes != field_types:\n            instance = type(udt_name, (cls,), {'subtypes': field_types,\n                                               'cassname': cls.cassname,\n                                               'typename': udt_name,\n                                               'fieldnames': field_names,\n                                               'keyspace': keyspace,\n                                               'mapped_class': None,\n                                               'tuple_type': cls._make_registered_udt_namedtuple(keyspace, udt_name, field_names)})\n            cls._cache[(keyspace, udt_name)] = instance\n        return instance\n\n    @classmethod\n    def evict_udt_class(cls, keyspace, udt_name):\n        try:\n            del cls._cache[(keyspace, udt_name)]\n        except KeyError:\n            pass\n\n    @classmethod\n    def apply_parameters(cls, subtypes, names):\n        keyspace = subtypes[0].cass_parameterized_type()  # when parsed from cassandra type, the keyspace is created as an unrecognized cass type; This gets the name back\n        udt_name = _name_from_hex_string(subtypes[1].cassname)\n        field_names = tuple(_name_from_hex_string(encoded_name) for encoded_name in names[2:])  # using tuple here to match what comes into make_udt_class from other sources (for caching equality test)\n        return cls.make_udt_class(keyspace, udt_name, field_names, tuple(subtypes[2:]))\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        return \"frozen<%s>\" % (cls.typename,)\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        values = super(UserType, cls).deserialize_safe(byts, protocol_version)\n        if cls.mapped_class:\n            return cls.mapped_class(**dict(zip(cls.fieldnames, values)))\n        elif cls.tuple_type:\n            return cls.tuple_type(*values)\n        else:\n            return tuple(values)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        proto_version = max(3, protocol_version)\n        buf = io.BytesIO()\n        for i, (fieldname, subtype) in enumerate(zip(cls.fieldnames, cls.subtypes)):\n            # first treat as a tuple, else by custom type\n            try:\n                item = val[i]\n            except TypeError:\n                item = getattr(val, fieldname, None)\n                if item is None and not hasattr(val, fieldname):\n                    log.warning(f\"field {fieldname} is part of the UDT {cls.typename} but is not present in the value {val}\")\n\n            if item is not None:\n                packed_item = subtype.to_binary(item, proto_version)\n                buf.write(int32_pack(len(packed_item)))\n                buf.write(packed_item)\n            else:\n                buf.write(int32_pack(-1))\n        return buf.getvalue()\n\n    @classmethod\n    def _make_registered_udt_namedtuple(cls, keyspace, name, field_names):\n        # this is required to make the type resolvable via this module...\n        # required when unregistered udts are pickled for use as keys in\n        # util.OrderedMap\n        t = cls._make_udt_tuple_type(name, field_names)\n        if t:\n            qualified_name = \"%s_%s\" % (keyspace, name)\n            setattr(cls._module, qualified_name, t)\n        return t\n\n    @classmethod\n    def _make_udt_tuple_type(cls, name, field_names):\n        # fallback to positional named, then unnamed tuples\n        # for CQL identifiers that aren't valid in Python,\n        try:\n            t = namedtuple(name, field_names)\n        except ValueError:\n            try:\n                t = namedtuple(name, util._positional_rename_invalid_identifiers(field_names))\n                log.warning(\"could not create a namedtuple for '%s' because one or more \"\n                            \"field names are not valid Python identifiers (%s); \"\n                            \"returning positionally-named fields\" % (name, field_names))\n            except ValueError:\n                t = None\n                log.warning(\"could not create a namedtuple for '%s' because the name is \"\n                            \"not a valid Python identifier; will return tuples in \"\n                            \"its place\" % (name,))\n        return t\n\n\nclass CompositeType(_ParameterizedType):\n    typename = \"org.apache.cassandra.db.marshal.CompositeType\"\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        \"\"\"\n        There is no CQL notation for Composites, so we override this.\n        \"\"\"\n        typestring = cls.cass_parameterized_type(full=True)\n        return \"'%s'\" % (typestring,)\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        result = []\n        for subtype in cls.subtypes:\n            if not byts:\n                # CompositeType can have missing elements at the end\n                break\n\n            element_length = uint16_unpack(byts[:2])\n            element = byts[2:2 + element_length]\n\n            # skip element length, element, and the EOC (one byte)\n            byts = byts[2 + element_length + 1:]\n            result.append(subtype.from_binary(element, protocol_version))\n\n        return tuple(result)\n\n\nclass DynamicCompositeType(_ParameterizedType):\n    typename = \"org.apache.cassandra.db.marshal.DynamicCompositeType\"\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        sublist = ', '.join('%s=>%s' % (alias, typ.cass_parameterized_type(full=True)) for alias, typ in zip(cls.fieldnames, cls.subtypes))\n        return \"'%s(%s)'\" % (cls.typename, sublist)\n\n\nclass ColumnToCollectionType(_ParameterizedType):\n    \"\"\"\n    This class only really exists so that we can cleanly evaluate types when\n    Cassandra includes this. We don't actually need or want the extra\n    information.\n    \"\"\"\n    typename = \"org.apache.cassandra.db.marshal.ColumnToCollectionType\"\n\n\nclass ReversedType(_ParameterizedType):\n    typename = \"org.apache.cassandra.db.marshal.ReversedType\"\n    num_subtypes = 1\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.from_binary(byts, protocol_version)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.to_binary(val, protocol_version)\n\n\nclass FrozenType(_ParameterizedType):\n    typename = \"frozen\"\n    num_subtypes = 1\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.from_binary(byts, protocol_version)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.to_binary(val, protocol_version)\n\n\ndef is_counter_type(t):\n    if isinstance(t, str):\n        t = lookup_casstype(t)\n    return issubclass(t, CounterColumnType)\n\n\ndef cql_typename(casstypename):\n    \"\"\"\n    Translate a Cassandra-style type specifier (optionally-fully-distinguished\n    Java class names for data types, along with optional parameters) into a\n    CQL-style type specifier.\n\n        >>> cql_typename('DateType')\n        'timestamp'\n        >>> cql_typename('org.apache.cassandra.db.marshal.ListType(IntegerType)')\n        'list<varint>'\n    \"\"\"\n    return lookup_casstype(casstypename).cql_parameterized_type()\n\n\nclass WKBGeometryType(object):\n    POINT = 1\n    LINESTRING = 2\n    POLYGON = 3\n\n\nclass PointType(CassandraType):\n    typename = 'PointType'\n\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.POINT)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        return PointType._type + point_le.pack(val.x, val.y)\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        point = point_le if is_little_endian else point_be\n        return util.Point(*point.unpack_from(byts, 5))  # ofs = endian byte + int type\n\n\nclass LineStringType(CassandraType):\n    typename = 'LineStringType'\n\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.LINESTRING)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        num_points = len(val.coords)\n        return LineStringType._type + struct.pack('<I' + 'dd' * num_points, num_points, *(d for coords in val.coords for d in coords))\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        point = point_le if is_little_endian else point_be\n        coords = ((point.unpack_from(byts, offset) for offset in range(1 + 4 + 4, len(byts), point.size)))  # start = endian + int type + int count\n        return util.LineString(coords)\n\n\nclass PolygonType(CassandraType):\n    typename = 'PolygonType'\n\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.POLYGON)\n    _ring_count = struct.Struct('<I').pack\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        buf = io.BytesIO(PolygonType._type)\n        buf.seek(0, 2)\n\n        if val.exterior.coords:\n            num_rings = 1 + len(val.interiors)\n            buf.write(PolygonType._ring_count(num_rings))\n            for ring in chain((val.exterior,), val.interiors):\n                num_points = len(ring.coords)\n                buf.write(struct.pack('<I' + 'dd' * num_points, num_points, *(d for coord in ring.coords for d in coord)))\n        else:\n            buf.write(PolygonType._ring_count(0))\n        return buf.getvalue()\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        if is_little_endian:\n            int_fmt = '<i'\n            point = point_le\n        else:\n            int_fmt = '>i'\n            point = point_be\n        p = 5\n        ring_count = struct.unpack_from(int_fmt, byts, p)[0]\n        p += 4\n        rings = []\n        for _ in range(ring_count):\n            point_count = struct.unpack_from(int_fmt, byts, p)[0]\n            p += 4\n            end = p + point_count * point.size\n            rings.append([point.unpack_from(byts, offset) for offset in range(p, end, point.size)])\n            p = end\n        return util.Polygon(exterior=rings[0], interiors=rings[1:]) if rings else util.Polygon()\n\n\nclass BoundKind(object):\n    \"\"\"\n    \"Enum\" representing the 6 possible DateRangeTypes\n    \"\"\"\n    SINGLE_DATE = 'SINGLE_DATE'\n    CLOSED_RANGE = 'CLOSED_RANGE'\n    OPEN_RANGE_HIGH = 'OPEN_RANGE_HIGH'\n    OPEN_RANGE_LOW = 'OPEN_RANGE_LOW'\n    BOTH_OPEN_RANGE = 'BOTH_OPEN_RANGE'\n    SINGLE_DATE_OPEN = 'SINGLE_DATE_OPEN'\n\n    VALID_RANGE_BOUNDS = (SINGLE_DATE, CLOSED_RANGE, OPEN_RANGE_HIGH,\n                          OPEN_RANGE_LOW, BOTH_OPEN_RANGE,\n                          SINGLE_DATE_OPEN)\n\n    _bound_str_to_int_map = {\n        'SINGLE_DATE': 0,\n        'CLOSED_RANGE': 1,\n        'OPEN_RANGE_HIGH': 2,\n        'OPEN_RANGE_LOW': 3,\n        'BOTH_OPEN_RANGE': 4,\n        'SINGLE_DATE_OPEN': 5,\n    }\n    _bound_int_to_str_map = {i: s for i, s in _bound_str_to_int_map.items()}\n\n    @classmethod\n    def to_int(cls, bound_str):\n        \"\"\"\n        Encode a string as an int for serialization.\n        \"\"\"\n        return cls._bound_str_to_int_map[bound_str.upper()]\n\n    @classmethod\n    def to_str(cls, bound_int):\n        \"\"\"\n        Decode an int to a string for deserialization.\n        \"\"\"\n        return cls._bound_int_to_str_map[bound_int.upper()]\n\n\nclass DateRangeType(CassandraType):\n    typename = 'daterange'\n\n    _precision_str_to_int_map = {\n        'YEAR': 0,\n        'MONTH': 1,\n        'DAY': 2,\n        'HOUR': 3,\n        'MINUTE': 4,\n        'SECOND': 5,\n        'MILLISECOND': 6\n    }\n    _precision_int_to_str_map = {s: i for i, s in _precision_str_to_int_map.items()}\n\n    @classmethod\n    def _encode_precision(cls, precision_str):\n        normalized_str = precision_str.upper()\n        if normalized_str not in cls._precision_str_to_int_map:\n            raise ValueError(\n                '%s is not a valid DateRange precision string. Valid values: %s' %\n                (repr(precision_str), ', '.join(list(cls._precision_str_to_int_map)))\n            )\n\n        return cls._precision_str_to_int_map[normalized_str]\n\n    @classmethod\n    def _decode_precision(cls, precision_int):\n        if precision_int not in cls._precision_int_to_str_map:\n            raise ValueError(\n                '%s not a valid DateRange precision int. Valid values: %s' %\n                (precision_int, ', '.join([str(i) for i in cls._precision_int_to_str_map]))\n            )\n\n        return cls._precision_int_to_str_map[precision_int]\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        # <type>[<time0><precision0>[<time1><precision1>]]\n        type_ = int8_unpack(byts[0:1])\n\n        if type_ in (BoundKind.to_int(BoundKind.BOTH_OPEN_RANGE),\n                     BoundKind.to_int(BoundKind.SINGLE_DATE_OPEN)):\n            time0 = precision0 = None\n        else:\n            time0 = int64_unpack(byts[1:9])\n            precision0 = int8_unpack(byts[9:10])\n\n        if type_ == BoundKind.to_int(BoundKind.CLOSED_RANGE):\n            time1 = int64_unpack(byts[10:18])\n            precision1 = int8_unpack(byts[18:19])\n        else:\n            time1 = precision1 = None\n\n        if time0 is not None:\n            date_range_bound0 = util.DateRangeBound(\n                time0,\n                cls._decode_precision(precision0)\n            )\n        if time1 is not None:\n            date_range_bound1 = util.DateRangeBound(\n                time1,\n                cls._decode_precision(precision1)\n            )\n\n        if type_ == BoundKind.to_int(BoundKind.SINGLE_DATE):\n            return util.DateRange(value=date_range_bound0)\n        if type_ == BoundKind.to_int(BoundKind.CLOSED_RANGE):\n            return util.DateRange(lower_bound=date_range_bound0,\n                                  upper_bound=date_range_bound1)\n        if type_ == BoundKind.to_int(BoundKind.OPEN_RANGE_HIGH):\n            return util.DateRange(lower_bound=date_range_bound0,\n                                  upper_bound=util.OPEN_BOUND)\n        if type_ == BoundKind.to_int(BoundKind.OPEN_RANGE_LOW):\n            return util.DateRange(lower_bound=util.OPEN_BOUND,\n                                  upper_bound=date_range_bound0)\n        if type_ == BoundKind.to_int(BoundKind.BOTH_OPEN_RANGE):\n            return util.DateRange(lower_bound=util.OPEN_BOUND,\n                                  upper_bound=util.OPEN_BOUND)\n        if type_ == BoundKind.to_int(BoundKind.SINGLE_DATE_OPEN):\n            return util.DateRange(value=util.OPEN_BOUND)\n        raise ValueError('Could not deserialize %r' % (byts,))\n\n    @classmethod\n    def serialize(cls, v, protocol_version):\n        buf = io.BytesIO()\n        bound_kind, bounds = None, ()\n\n        try:\n            value = v.value\n        except AttributeError:\n            raise ValueError(\n                '%s.serialize expects an object with a value attribute; got'\n                '%r' % (cls.__name__, v)\n            )\n\n        if value is None:\n            try:\n                lower_bound, upper_bound = v.lower_bound, v.upper_bound\n            except AttributeError:\n                raise ValueError(\n                    '%s.serialize expects an object with lower_bound and '\n                    'upper_bound attributes; got %r' % (cls.__name__, v)\n                )\n            if lower_bound == util.OPEN_BOUND and upper_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.BOTH_OPEN_RANGE\n            elif lower_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.OPEN_RANGE_LOW\n                bounds = (upper_bound,)\n            elif upper_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.OPEN_RANGE_HIGH\n                bounds = (lower_bound,)\n            else:\n                bound_kind = BoundKind.CLOSED_RANGE\n                bounds = lower_bound, upper_bound\n        else:  # value is not None\n            if value == util.OPEN_BOUND:\n                bound_kind = BoundKind.SINGLE_DATE_OPEN\n            else:\n                bound_kind = BoundKind.SINGLE_DATE\n                bounds = (value,)\n\n        if bound_kind is None:\n            raise ValueError(\n                'Cannot serialize %r; could not find bound kind' % (v,)\n            )\n\n        buf.write(int8_pack(BoundKind.to_int(bound_kind)))\n        for bound in bounds:\n            buf.write(int64_pack(bound.milliseconds))\n            buf.write(int8_pack(cls._encode_precision(bound.precision)))\n\n        return buf.getvalue()\n\nclass VectorType(_CassandraType):\n    typename = 'org.apache.cassandra.db.marshal.VectorType'\n    vector_size = 0\n    subtype = None\n\n    @classmethod\n    def serial_size(cls):\n        serialized_size = cls.subtype.serial_size()\n        return cls.vector_size * serialized_size if serialized_size is not None else None\n\n    @classmethod\n    def apply_parameters(cls, params, names):\n        assert len(params) == 2\n        subtype = lookup_casstype(params[0])\n        vsize = params[1]\n        return type('%s(%s)' % (cls.cass_parameterized_type_with([]), vsize), (cls,), {'vector_size': vsize, 'subtype': subtype})\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        serialized_size = cls.subtype.serial_size()\n        if serialized_size is not None:\n            expected_byte_size = serialized_size * cls.vector_size\n            if len(byts) != expected_byte_size:\n                raise ValueError(\n                    \"Expected vector of type {0} and dimension {1} to have serialized size {2}; observed serialized size of {3} instead\"\\\n                    .format(cls.subtype.typename, cls.vector_size, expected_byte_size, len(byts)))\n            indexes = (serialized_size * x for x in range(0, cls.vector_size))\n            return [cls.subtype.deserialize(byts[idx:idx + serialized_size], protocol_version) for idx in indexes]\n\n        idx = 0\n        rv = []\n        while (len(rv) < cls.vector_size):\n            try:\n                size, bytes_read = uvint_unpack(byts[idx:])\n                idx += bytes_read\n                rv.append(cls.subtype.deserialize(byts[idx:idx + size], protocol_version))\n                idx += size\n            except:\n                raise ValueError(\"Error reading additional data during vector deserialization after successfully adding {} elements\"\\\n                .format(len(rv)))\n\n        # If we have any additional data in the serialized vector treat that as an error as well\n        if idx < len(byts):\n            raise ValueError(\"Additional bytes remaining after vector deserialization completed\")\n        return rv\n\n    @classmethod\n    def serialize(cls, v, protocol_version):\n        v_length = len(v)\n        if cls.vector_size != v_length:\n            raise ValueError(\n                \"Expected sequence of size {0} for vector of type {1} and dimension {0}, observed sequence of length {2}\"\\\n                .format(cls.vector_size, cls.subtype.typename, v_length))\n\n        serialized_size = cls.subtype.serial_size()\n        buf = io.BytesIO()\n        for item in v:\n            item_bytes = cls.subtype.serialize(item, protocol_version)\n            if serialized_size is None:\n                buf.write(uvint_pack(len(item_bytes)))\n            buf.write(item_bytes)\n        return buf.getvalue()\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        return \"%s<%s, %s>\" % (cls.typename, cls.subtype.cql_parameterized_type(), cls.vector_size)\n",
    "cassandra/__init__.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\n\nlogging.getLogger('cassandra').addHandler(NullHandler())\n\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n\n    ANY = 0\n    \"\"\"\n    Only requires that one replica receives the write *or* the coordinator\n    stores a hint to replay later. Valid only for writes.\n    \"\"\"\n\n    ONE = 1\n    \"\"\"\n    Only one replica needs to respond to consider the operation a success\n    \"\"\"\n\n    TWO = 2\n    \"\"\"\n    Two replicas must respond to consider the operation a success\n    \"\"\"\n\n    THREE = 3\n    \"\"\"\n    Three replicas must respond to consider the operation a success\n    \"\"\"\n\n    QUORUM = 4\n    \"\"\"\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\n    \"\"\"\n\n    ALL = 5\n    \"\"\"\n    All replicas must respond to consider the operation a success\n    \"\"\"\n\n    LOCAL_QUORUM = 6\n    \"\"\"\n    Requires a quorum of replicas in the local datacenter\n    \"\"\"\n\n    EACH_QUORUM = 7\n    \"\"\"\n    Requires a quorum of replicas in each datacenter\n    \"\"\"\n\n    SERIAL = 8\n    \"\"\"\n    For conditional inserts/updates that utilize Cassandra's lightweight\n    transactions, this requires consensus among all replicas for the\n    modified data.\n    \"\"\"\n\n    LOCAL_SERIAL = 9\n    \"\"\"\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\n    among replicas in the local datacenter.\n    \"\"\"\n\n    LOCAL_ONE = 10\n    \"\"\"\n    Sends a request only to replicas in the local datacenter and waits for\n    one response.\n    \"\"\"\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\n\n\nConsistencyLevel.value_to_name = {\n    ConsistencyLevel.ANY: 'ANY',\n    ConsistencyLevel.ONE: 'ONE',\n    ConsistencyLevel.TWO: 'TWO',\n    ConsistencyLevel.THREE: 'THREE',\n    ConsistencyLevel.QUORUM: 'QUORUM',\n    ConsistencyLevel.ALL: 'ALL',\n    ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM',\n    ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM',\n    ConsistencyLevel.SERIAL: 'SERIAL',\n    ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL',\n    ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'\n}\n\nConsistencyLevel.name_to_value = {\n    'ANY': ConsistencyLevel.ANY,\n    'ONE': ConsistencyLevel.ONE,\n    'TWO': ConsistencyLevel.TWO,\n    'THREE': ConsistencyLevel.THREE,\n    'QUORUM': ConsistencyLevel.QUORUM,\n    'ALL': ConsistencyLevel.ALL,\n    'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM,\n    'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM,\n    'SERIAL': ConsistencyLevel.SERIAL,\n    'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL,\n    'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE\n}\n\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else \"Not Set\"\n\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    \"\"\"\n    v1, supported in Cassandra 1.2-->2.2\n    \"\"\"\n\n    V2 = 2\n    \"\"\"\n    v2, supported in Cassandra 2.0-->2.2;\n    added support for lightweight transactions, batch operations, and automatic query paging.\n    \"\"\"\n\n    V3 = 3\n    \"\"\"\n    v3, supported in Cassandra 2.1-->3.x+;\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\n    \"\"\"\n\n    V4 = 4\n    \"\"\"\n    v4, supported in Cassandra 2.2-->3.x+;\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\n    \"\"\"\n\n    V5 = 5\n    \"\"\"\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\n    \"\"\"\n\n    V6 = 6\n    \"\"\"\n    v6, in beta from 4.0-beta5\n    \"\"\"\n\n    DSE_V1 = 0x41\n    \"\"\"\n    DSE private protocol v1, supported in DSE 5.1+\n    \"\"\"\n\n    DSE_V2 = 0x42\n    \"\"\"\n    DSE private protocol v2, supported in DSE 6.0+\n    \"\"\"\n\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    \"\"\"\n    A tuple of all supported protocol versions\n    \"\"\"\n\n    BETA_VERSIONS = (V6,)\n    \"\"\"\n    A tuple of all beta protocol versions\n    \"\"\"\n\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    \"\"\"\n    Minimum protocol version supported by this driver.\n    \"\"\"\n\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    \"\"\"\n    Maximum protocol version supported by this driver.\n    \"\"\"\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next(v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if\n                           v not in ProtocolVersion.BETA_VERSIONS and v < previous_version)\n        except StopIteration:\n            version = 0\n\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n\n    SIMPLE = 0\n    \"\"\"\n    A write to a single partition key. Such writes are guaranteed to be atomic\n    and isolated.\n    \"\"\"\n\n    BATCH = 1\n    \"\"\"\n    A write to multiple partition keys that used the distributed batch log to\n    ensure atomicity.\n    \"\"\"\n\n    UNLOGGED_BATCH = 2\n    \"\"\"\n    A write to multiple partition keys that did not use the distributed batch\n    log. Atomicity for such writes is not guaranteed.\n    \"\"\"\n\n    COUNTER = 3\n    \"\"\"\n    A counter write (for one or multiple partition keys). Such writes should\n    not be replayed in order to avoid overcount.\n    \"\"\"\n\n    BATCH_LOG = 4\n    \"\"\"\n    The initial write to the distributed batch log that Cassandra performs\n    internally before a BATCH write.\n    \"\"\"\n\n    CAS = 5\n    \"\"\"\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\n    \"\"\"\n\n    VIEW = 6\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete MV operations.\n    \"\"\"\n\n    CDC = 7\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete CDC operations.\n    \"\"\"\n\n\nWriteType.name_to_value = {\n    'SIMPLE': WriteType.SIMPLE,\n    'BATCH': WriteType.BATCH,\n    'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH,\n    'COUNTER': WriteType.COUNTER,\n    'BATCH_LOG': WriteType.BATCH_LOG,\n    'CAS': WriteType.CAS,\n    'VIEW': WriteType.VIEW,\n    'CDC': WriteType.CDC\n}\n\n\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return \"%s(%s)\" % (name, ','.join(t for t in argument_types))\n\n    def __repr__(self):\n        return \"%s(%s, %s)\" % (self.__class__.__name__, self.name, self.argument_types)\n\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the function\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the aggregate\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_replicas = None\n    \"\"\" The number of replicas that needed to be live to complete the operation \"\"\"\n\n    alive_replicas = None\n    \"\"\" The number of replicas that were actually alive \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' +\n                           repr({'consistency': consistency_value_to_name(consistency),\n                                 'required_replicas': required_replicas,\n                                 'alive_replicas': alive_replicas}))\n\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n\n        if \"write_type\" in kwargs:\n            kwargs[\"write_type\"] = WriteType.value_to_name[kwargs[\"write_type\"]]\n\n        info = {'consistency': consistency_value_to_name(consistency),\n                'required_responses': required_responses,\n                'received_responses': received_responses}\n        info.update(kwargs)\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs[\"write_type\"] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    failures = None\n    \"\"\"\n    The number of replicas that sent a failure message\n    \"\"\"\n\n    error_code_map = None\n    \"\"\"\n    A map of inet addresses to error codes representing replicas that sent\n    a failure message.  Only set when `protocol_version` is 5 or higher.\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n\n        info_dict = {\n            'consistency': consistency_value_to_name(consistency),\n            'required_responses': required_responses,\n            'received_responses': received_responses,\n            'failures': failures\n        }\n\n        if error_code_map is not None:\n            # make error codes look like \"0x002a\"\n            formatted_map = dict((addr, '0x%04x' % err_code)\n                                 for (addr, err_code) in error_code_map.items())\n            info_dict['error_code_map'] = formatted_map\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    Keyspace of the function\n    \"\"\"\n\n    function = None\n    \"\"\"\n    Name of the function\n    \"\"\"\n\n    arg_types = None\n    \"\"\"\n    List of argument type names of the function\n    \"\"\"\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    The name of the keyspace that already exists, or, if an attempt was\n    made to create a new table, the keyspace that the table is in.\n    \"\"\"\n\n    table = None\n    \"\"\"\n    The name of the table that already exists, or, if an attempt was\n    make to create a keyspace, :const:`None`.\n    \"\"\"\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n\n    errors = None\n    \"\"\"\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\n    \"\"\"\n\n    last_host = None\n    \"\"\"\n    The last :class:`~.Host` this operation was attempted against.\n    \"\"\"\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = \"errors=%s, last_host=%s\" % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n\n    excs = []\n    \"\"\"\n    A sequence of child exceptions\n    \"\"\"\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += (\"\\nThe following exceptions were observed: \\n - \" + '\\n - '.join(str(e) for e in excs))\n        Exception.__init__(self, complete_msg)\n"
  },
  "GT_src_dict": {
    "cassandra/util.py": {
      "SortedSet.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the SortedSet instance, formatted to include the class name and the contents of the set. The output includes the internal list of items (_items) that make up the SortedSet, ensuring that the order of elements is preserved as they were inserted. The representation is useful for debugging and provides insight into the current state of the collection.\n\nThis method does not take any parameters and does not produce side effects; it solely accesses the class's internal state for display purposes. The _items attribute is defined in the __init__ method of SortedSet, where it is initialized to store the sorted elements of the set.\"\"\"\n        return '%s(%r)' % (self.__class__.__name__, self._items)",
        "docstring": "Returns a string representation of the SortedSet instance, formatted to include the class name and the contents of the set. The output includes the internal list of items (_items) that make up the SortedSet, ensuring that the order of elements is preserved as they were inserted. The representation is useful for debugging and provides insight into the current state of the collection.\n\nThis method does not take any parameters and does not produce side effects; it solely accesses the class's internal state for display purposes. The _items attribute is defined in the __init__ method of SortedSet, where it is initialized to store the sorted elements of the set.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class SortedSet(object):"
      },
      "SortedSet.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Determines if two `SortedSet` instances are equal.\n\nParameters:\n- `other`: The object to compare against. It can be another instance of `SortedSet` or any iterable.\n\nReturns:\n- `True` if `other` is a `SortedSet` and has the same items as the current instance, or if `other` is an iterable with the same length as `_items` and all its elements are contained in the current set.\n- `NotImplemented` if `other` is neither a `SortedSet` nor a compatible iterable.\n\nNotes:\n- The comparison checks for equality of contents rather than reference equality. The method leverages the `__len__` method to compare lengths and utilizes the `__contains__` method to verify presence of items.\n- It allows for flexible comparisons with other iterable types, enhancing the usability of the `SortedSet` class.\"\"\"\n        if isinstance(other, self.__class__):\n            return self._items == other._items\n        else:\n            try:\n                return len(other) == len(self._items) and all((item in self for item in other))\n            except TypeError:\n                return NotImplemented",
        "docstring": "Determines if two `SortedSet` instances are equal.\n\nParameters:\n- `other`: The object to compare against. It can be another instance of `SortedSet` or any iterable.\n\nReturns:\n- `True` if `other` is a `SortedSet` and has the same items as the current instance, or if `other` is an iterable with the same length as `_items` and all its elements are contained in the current set.\n- `NotImplemented` if `other` is neither a `SortedSet` nor a compatible iterable.\n\nNotes:\n- The comparison checks for equality of contents rather than reference equality. The method leverages the `__len__` method to compare lengths and utilizes the `__contains__` method to verify presence of items.\n- It allows for flexible comparisons with other iterable types, enhancing the usability of the `SortedSet` class.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class SortedSet(object):"
      },
      "OrderedMap.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Determines equality between two OrderedMap instances or an OrderedMap and another mapping.\n\nParameters:\n- other: An object to compare against the current OrderedMap instance. This can be an instance of OrderedMap or any other mapping type.\n\nReturns:\n- True if the two mappings are equal, meaning they have the same items in the same order; otherwise, False. If `other` is a mapping but does not match in size or key-value pairs, it will return False as well.\n- If `other` is not comparable, it returns NotImplemented.\n\nThis method relies on the internal _items attribute, which holds the ordered pairs of keys and values in the OrderedMap. It supports nested collections by leveraging Python's built-in dict type for comparisons.\"\"\"\n        if isinstance(other, OrderedMap):\n            return self._items == other._items\n        try:\n            d = dict(other)\n            return len(d) == len(self._items) and all((i[1] == d[i[0]] for i in self._items))\n        except KeyError:\n            return False\n        except TypeError:\n            pass\n        return NotImplemented",
        "docstring": "Determines equality between two OrderedMap instances or an OrderedMap and another mapping.\n\nParameters:\n- other: An object to compare against the current OrderedMap instance. This can be an instance of OrderedMap or any other mapping type.\n\nReturns:\n- True if the two mappings are equal, meaning they have the same items in the same order; otherwise, False. If `other` is a mapping but does not match in size or key-value pairs, it will return False as well.\n- If `other` is not comparable, it returns NotImplemented.\n\nThis method relies on the internal _items attribute, which holds the ordered pairs of keys and values in the OrderedMap. It supports nested collections by leveraging Python's built-in dict type for comparisons.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class OrderedMap(Mapping):"
      },
      "OrderedMap.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the OrderedMap instance.\n\nThe representation consists of the class name followed by a list of its items formatted as tuples of key-value pairs. Each key-value pair is converted to a string using the representation format of the internal items, which are stored in the attribute `_items`. This method provides a readable format for debugging and logging purposes, reflecting the current state of the OrderedMap.\n\nReturns:\n    str: A string that represents the OrderedMap and its items.\"\"\"\n        return '%s([%s])' % (self.__class__.__name__, ', '.join(('(%r, %r)' % (k, v) for k, v in self._items)))",
        "docstring": "Returns a string representation of the OrderedMap instance.\n\nThe representation consists of the class name followed by a list of its items formatted as tuples of key-value pairs. Each key-value pair is converted to a string using the representation format of the internal items, which are stored in the attribute `_items`. This method provides a readable format for debugging and logging purposes, reflecting the current state of the OrderedMap.\n\nReturns:\n    str: A string that represents the OrderedMap and its items.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class OrderedMap(Mapping):"
      },
      "Time.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Compares two Time instances or a Time instance with an integer (representing absolute nanoseconds in a day).\n\nParameters:\n- other: The object to compare against. Can be another Time instance or an integer.\n\nReturns:\n- True if the two values are equal based on nanosecond precision; otherwise, False.\n\nThe method leverages the `nanosecond_time` attribute, which holds the absolute nanoseconds in the day for the Time instance being compared. If the 'other' parameter is a Time instance, their `nanosecond_time` values are directly compared. If it is an integer, it checks if the `nanosecond_time` equals that integer. If neither condition is met, the method attempts to convert the Time instance into a built-in `datetime.time` object (using the `hour`, `minute`, `second`, and `nanosecond` properties) and then compares it to 'other', while ensuring the `nanosecond_time` is rounded to the nearest microsecond. The `Time.MICRO` constant is used to help in this rounding process, indicating the number of nanoseconds in a microsecond (1000).\"\"\"\n        if isinstance(other, Time):\n            return self.nanosecond_time == other.nanosecond_time\n        if isinstance(other, int):\n            return self.nanosecond_time == other\n        return self.nanosecond_time % Time.MICRO == 0 and datetime.time(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.nanosecond // Time.MICRO) == other",
        "docstring": "Compares two Time instances or a Time instance with an integer (representing absolute nanoseconds in a day).\n\nParameters:\n- other: The object to compare against. Can be another Time instance or an integer.\n\nReturns:\n- True if the two values are equal based on nanosecond precision; otherwise, False.\n\nThe method leverages the `nanosecond_time` attribute, which holds the absolute nanoseconds in the day for the Time instance being compared. If the 'other' parameter is a Time instance, their `nanosecond_time` values are directly compared. If it is an integer, it checks if the `nanosecond_time` equals that integer. If neither condition is met, the method attempts to convert the Time instance into a built-in `datetime.time` object (using the `hour`, `minute`, `second`, and `nanosecond` properties) and then compares it to 'other', while ensuring the `nanosecond_time` is rounded to the nearest microsecond. The `Time.MICRO` constant is used to help in this rounding process, indicating the number of nanoseconds in a microsecond (1000).",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class Time(object):"
      },
      "Time.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the Time object, formatted as 'Time(nanosecond_time)', where `nanosecond_time` is the absolute time in nanoseconds since the start of the day. This representation is mainly used for debugging and logging purposes to provide a clear indication of the Time object's internal state. The `nanosecond_time` attribute is computed from various formats of time and is defined within the class, serving as a central point for all time-related calculations and operations. This method does not take any parameters and does not produce side effects.\"\"\"\n        return 'Time(%s)' % self.nanosecond_time",
        "docstring": "Returns a string representation of the Time object, formatted as 'Time(nanosecond_time)', where `nanosecond_time` is the absolute time in nanoseconds since the start of the day. This representation is mainly used for debugging and logging purposes to provide a clear indication of the Time object's internal state. The `nanosecond_time` attribute is computed from various formats of time and is defined within the class, serving as a central point for all time-related calculations and operations. This method does not take any parameters and does not produce side effects.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class Time(object):"
      },
      "Date.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two Date instances or between a Date instance and an integer representing days from epoch.\n\nParameters:\n- other: Can be an instance of Date, an integer, or any other type. If it is a Date, comparison is made with the `days_from_epoch` attribute. If it is an integer, the comparison is directly with `days_from_epoch`.\n\nReturns:\n- bool: True if the Date instance is equal to the other instance based on days from epoch, or if it is an equivalent integer representation. If the type of 'other' is incompatible or raises an exception during conversion to datetime, returns False.\n\nDependencies:\n- The class uses the `days_from_epoch` attribute, which is an integer representing the number of days since the UNIX epoch (1970-01-01). This attribute is crucial for determining equality with both other Date instances and integers.\"\"\"\n        if isinstance(other, Date):\n            return self.days_from_epoch == other.days_from_epoch\n        if isinstance(other, int):\n            return self.days_from_epoch == other\n        try:\n            return self.date() == other\n        except Exception:\n            return False",
        "docstring": "Checks for equality between two Date instances or between a Date instance and an integer representing days from epoch.\n\nParameters:\n- other: Can be an instance of Date, an integer, or any other type. If it is a Date, comparison is made with the `days_from_epoch` attribute. If it is an integer, the comparison is directly with `days_from_epoch`.\n\nReturns:\n- bool: True if the Date instance is equal to the other instance based on days from epoch, or if it is an equivalent integer representation. If the type of 'other' is incompatible or raises an exception during conversion to datetime, returns False.\n\nDependencies:\n- The class uses the `days_from_epoch` attribute, which is an integer representing the number of days since the UNIX epoch (1970-01-01). This attribute is crucial for determining equality with both other Date instances and integers.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class Date(object):"
      },
      "Date.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the Date object, displaying the internal state as the number of days from the epoch (January 1, 1970). This method does not take any parameters and outputs a formatted string indicating the absolute days offset. The `days_from_epoch` attribute, which is an integer representing the number of days from the epoch, is utilized in this representation. The output serves to give a succinct summary of the Date instance, useful for debugging and logging.\"\"\"\n        return 'Date(%s)' % self.days_from_epoch",
        "docstring": "Returns a string representation of the Date object, displaying the internal state as the number of days from the epoch (January 1, 1970). This method does not take any parameters and outputs a formatted string indicating the absolute days offset. The `days_from_epoch` attribute, which is an integer representing the number of days from the epoch, is utilized in this representation. The output serves to give a succinct summary of the Date instance, useful for debugging and logging.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class Date(object):"
      }
    },
    "cassandra/cqltypes.py": {
      "lookup_casstype": {
        "code": "def lookup_casstype(casstype):\n    \"\"\"Given a Cassandra type as a string, this function retrieves the corresponding CassandraType class responsible for that type, including support for parameterized types. If the type name is unrecognized, it creates and returns an instance of the _UnrecognizedType subclass to represent it.\n\nParameters:\n- casstype (str or CassandraType): A string representing the Cassandra type, which may include parameters in the form of parentheses, or an instance of CassandraType or CassandraTypeType.\n\nReturns:\n- CassandraType: The corresponding CassandraType class for the provided casstype, or an instance of _UnrecognizedType if the type is not recognized.\n\nThis function interacts with the `parse_casstype_args` function to interpret complex types, which may raise exceptions if the input string does not conform to the expected format. Additionally, it utilizes the constants `CassandraType` and `CassandraTypeType`, which serve as base classes for all Cassandra types and manage type registrations within the module.\"\"\"\n    \"\\n    Given a Cassandra type as a string (possibly including parameters), hand\\n    back the CassandraType class responsible for it. If a name is not\\n    recognized, a custom _UnrecognizedType subclass will be created for it.\\n\\n    Example:\\n\\n        >>> lookup_casstype('org.apache.cassandra.db.marshal.MapType(org.apache.cassandra.db.marshal.UTF8Type,org.apache.cassandra.db.marshal.Int32Type)')\\n        <class 'cassandra.cqltypes.MapType(UTF8Type, Int32Type)'>\\n\\n    \"\n    if isinstance(casstype, (CassandraType, CassandraTypeType)):\n        return casstype\n    try:\n        return parse_casstype_args(casstype)\n    except (ValueError, AssertionError, IndexError) as e:\n        raise ValueError(\"Don't know how to parse type string %r: %s\" % (casstype, e))",
        "docstring": "Given a Cassandra type as a string, this function retrieves the corresponding CassandraType class responsible for that type, including support for parameterized types. If the type name is unrecognized, it creates and returns an instance of the _UnrecognizedType subclass to represent it.\n\nParameters:\n- casstype (str or CassandraType): A string representing the Cassandra type, which may include parameters in the form of parentheses, or an instance of CassandraType or CassandraTypeType.\n\nReturns:\n- CassandraType: The corresponding CassandraType class for the provided casstype, or an instance of _UnrecognizedType if the type is not recognized.\n\nThis function interacts with the `parse_casstype_args` function to interpret complex types, which may raise exceptions if the input string does not conform to the expected format. Additionally, it utilizes the constants `CassandraType` and `CassandraTypeType`, which serve as base classes for all Cassandra types and manage type registrations within the module.",
        "signature": "def lookup_casstype(casstype):",
        "type": "Function",
        "class_signature": null
      },
      "_CassandraType.from_binary": {
        "code": "    def from_binary(cls, byts, protocol_version):\n        \"\"\"Deserialize a bytestring into a value while handling potential None or empty string inputs. This method checks if the input `byts` is None or an empty string. If it is None, the function returns None; if it is an empty string and the class doesn't allow for empty binary representations, it either returns the singleton `EMPTY` (an instance of `EmptyValue`) if `support_empty_values` is True, or None otherwise. For valid binary data, it invokes the class's `deserialize` method to convert the bytes into the appropriate value based on the provided protocol version.\n\nParameters:\n- `byts`: The input bytestring to be deserialized. It can be None or an empty string.\n- `protocol_version`: An integer representing the protocol version used for serialization and deserialization.\n\nReturns:\n- The deserialized value derived from the bytestring, which can be a valid type or None, depending on the input and class properties.\n\nDependencies:\n- The `EMPTY` constant is an instance of `EmptyValue`, defined at the module level to represent empty values in situations where empty strings are treated as nulls.\n- `support_empty_values`, a class attribute, is used to determine if the class should treat empty strings as valid values or return None instead.\"\"\"\n        '\\n        Deserialize a bytestring into a value. See the deserialize() method\\n        for more information. This method differs in that if None or the empty\\n        string is passed in, None may be returned.\\n        '\n        if byts is None:\n            return None\n        elif len(byts) == 0 and (not cls.empty_binary_ok):\n            return EMPTY if cls.support_empty_values else None\n        return cls.deserialize(byts, protocol_version)",
        "docstring": "Deserialize a bytestring into a value while handling potential None or empty string inputs. This method checks if the input `byts` is None or an empty string. If it is None, the function returns None; if it is an empty string and the class doesn't allow for empty binary representations, it either returns the singleton `EMPTY` (an instance of `EmptyValue`) if `support_empty_values` is True, or None otherwise. For valid binary data, it invokes the class's `deserialize` method to convert the bytes into the appropriate value based on the provided protocol version.\n\nParameters:\n- `byts`: The input bytestring to be deserialized. It can be None or an empty string.\n- `protocol_version`: An integer representing the protocol version used for serialization and deserialization.\n\nReturns:\n- The deserialized value derived from the bytestring, which can be a valid type or None, depending on the input and class properties.\n\nDependencies:\n- The `EMPTY` constant is an instance of `EmptyValue`, defined at the module level to represent empty values in situations where empty strings are treated as nulls.\n- `support_empty_values`, a class attribute, is used to determine if the class should treat empty strings as valid values or return None instead.",
        "signature": "def from_binary(cls, byts, protocol_version):",
        "type": "Method",
        "class_signature": "class _CassandraType(object, metaclass=CassandraTypeType):"
      },
      "_CassandraType.to_binary": {
        "code": "    def to_binary(cls, val, protocol_version):\n        \"\"\"Serialize a value into a bytestring representation for Cassandra. If the input value is None, the method returns an empty bytes string; otherwise, it delegates to the class-specific `serialize` method to convert the value appropriately based on the defined serialization protocol.\n\nParameters:\n- val: The value to serialize. Can be any data structure supported by the specific CassandraType.\n- protocol_version: An integer representing the protocol version that dictates the serialization format to use.\n\nReturns:\n- A bytestring representing the serialized data for non-None values, or an empty bytestring if the input is None.\n\nThis method relies on the `serialize` method, which must be implemented in the subclass of `_CassandraType`. The function utilizes the `b''` constant to signify an empty bytestring when the input value is None.\"\"\"\n        '\\n        Serialize a value into a bytestring. See the serialize() method for\\n        more information. This method differs in that if None is passed in,\\n        the result is the empty string.\\n        '\n        return b'' if val is None else cls.serialize(val, protocol_version)",
        "docstring": "Serialize a value into a bytestring representation for Cassandra. If the input value is None, the method returns an empty bytes string; otherwise, it delegates to the class-specific `serialize` method to convert the value appropriately based on the defined serialization protocol.\n\nParameters:\n- val: The value to serialize. Can be any data structure supported by the specific CassandraType.\n- protocol_version: An integer representing the protocol version that dictates the serialization format to use.\n\nReturns:\n- A bytestring representing the serialized data for non-None values, or an empty bytestring if the input is None.\n\nThis method relies on the `serialize` method, which must be implemented in the subclass of `_CassandraType`. The function utilizes the `b''` constant to signify an empty bytestring when the input value is None.",
        "signature": "def to_binary(cls, val, protocol_version):",
        "type": "Method",
        "class_signature": "class _CassandraType(object, metaclass=CassandraTypeType):"
      }
    },
    "cassandra/__init__.py": {}
  },
  "dependency_dict": {
    "cassandra/cqltypes.py:_CassandraType:to_binary": {
      "cassandra/cqltypes.py": {
        "BytesType.serialize": {
          "code": "    def serialize(val, protocol_version):\n        return bytes(val)",
          "docstring": "",
          "signature": "def serialize(val, protocol_version):",
          "type": "Method",
          "class_signature": "class BytesType(_CassandraType):"
        },
        "DecimalType.serialize": {
          "code": "    def serialize(dec, protocol_version):\n        try:\n            sign, digits, exponent = dec.as_tuple()\n        except AttributeError:\n            try:\n                sign, digits, exponent = Decimal(dec).as_tuple()\n            except Exception:\n                raise TypeError('Invalid type for Decimal value: %r', dec)\n        unscaled = int(''.join([str(digit) for digit in digits]))\n        if sign:\n            unscaled *= -1\n        scale = int32_pack(-exponent)\n        unscaled = varint_pack(unscaled)\n        return scale + unscaled",
          "docstring": "",
          "signature": "def serialize(dec, protocol_version):",
          "type": "Method",
          "class_signature": "class DecimalType(_CassandraType):"
        },
        "UUIDType.serialize": {
          "code": "    def serialize(uuid, protocol_version):\n        try:\n            return uuid.bytes\n        except AttributeError:\n            raise TypeError('Got a non-UUID object for a UUID value')",
          "docstring": "",
          "signature": "def serialize(uuid, protocol_version):",
          "type": "Method",
          "class_signature": "class UUIDType(_CassandraType):"
        },
        "BooleanType.serialize": {
          "code": "    def serialize(truth, protocol_version):\n        return int8_pack(truth)",
          "docstring": "",
          "signature": "def serialize(truth, protocol_version):",
          "type": "Method",
          "class_signature": "class BooleanType(_CassandraType):"
        },
        "ByteType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return int8_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class ByteType(_CassandraType):"
        },
        "AsciiType.serialize": {
          "code": "    def serialize(var, protocol_version):\n        try:\n            return var.encode('ascii')\n        except UnicodeDecodeError:\n            return var",
          "docstring": "",
          "signature": "def serialize(var, protocol_version):",
          "type": "Method",
          "class_signature": "class AsciiType(_CassandraType):"
        },
        "FloatType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return float_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class FloatType(_CassandraType):"
        },
        "DoubleType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return double_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class DoubleType(_CassandraType):"
        },
        "LongType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return int64_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class LongType(_CassandraType):"
        },
        "Int32Type.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return int32_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class Int32Type(_CassandraType):"
        },
        "IntegerType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return varint_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class IntegerType(_CassandraType):"
        },
        "InetAddressType.serialize": {
          "code": "    def serialize(addr, protocol_version):\n        try:\n            if ':' in addr:\n                return util.inet_pton(socket.AF_INET6, addr)\n            else:\n                return socket.inet_aton(addr)\n        except:\n            if isinstance(addr, (ipaddress.IPv4Address, ipaddress.IPv6Address)):\n                return addr.packed\n            raise ValueError(\"can't interpret %r as an inet address\" % (addr,))",
          "docstring": "",
          "signature": "def serialize(addr, protocol_version):",
          "type": "Method",
          "class_signature": "class InetAddressType(_CassandraType):"
        },
        "DateType.serialize": {
          "code": "    def serialize(v, protocol_version):\n        try:\n            timestamp_seconds = calendar.timegm(v.utctimetuple())\n            timestamp = timestamp_seconds * 1000.0 + getattr(v, 'microsecond', 0) / 1000.0\n        except AttributeError:\n            try:\n                timestamp = calendar.timegm(v.timetuple()) * 1000.0\n            except AttributeError:\n                if type(v) not in _number_types:\n                    raise TypeError('DateType arguments must be a datetime, date, or timestamp')\n                timestamp = v\n        return int64_pack(int(timestamp))",
          "docstring": "",
          "signature": "def serialize(v, protocol_version):",
          "type": "Method",
          "class_signature": "class DateType(_CassandraType):"
        },
        "SimpleDateType.serialize": {
          "code": "    def serialize(val, protocol_version):\n        try:\n            days = val.days_from_epoch\n        except AttributeError:\n            if isinstance(val, int):\n                return uint32_pack(val)\n            days = util.Date(val).days_from_epoch\n        return uint32_pack(days + SimpleDateType.EPOCH_OFFSET_DAYS)",
          "docstring": "",
          "signature": "def serialize(val, protocol_version):",
          "type": "Method",
          "class_signature": "class SimpleDateType(_CassandraType):"
        },
        "ShortType.serialize": {
          "code": "    def serialize(byts, protocol_version):\n        return int16_pack(byts)",
          "docstring": "",
          "signature": "def serialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class ShortType(_CassandraType):"
        },
        "TimeType.serialize": {
          "code": "    def serialize(val, protocol_version):\n        try:\n            nano = val.nanosecond_time\n        except AttributeError:\n            nano = util.Time(val).nanosecond_time\n        return int64_pack(nano)",
          "docstring": "",
          "signature": "def serialize(val, protocol_version):",
          "type": "Method",
          "class_signature": "class TimeType(_CassandraType):"
        },
        "UTF8Type.serialize": {
          "code": "    def serialize(ustr, protocol_version):\n        try:\n            return ustr.encode('utf-8')\n        except UnicodeDecodeError:\n            return ustr",
          "docstring": "",
          "signature": "def serialize(ustr, protocol_version):",
          "type": "Method",
          "class_signature": "class UTF8Type(_CassandraType):"
        },
        "_ParameterizedType.serialize": {
          "code": "    def serialize(cls, val, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't serialize unparameterized %s\" % cls.typename)\n        return cls.serialize_safe(val, protocol_version)",
          "docstring": "",
          "signature": "def serialize(cls, val, protocol_version):",
          "type": "Method",
          "class_signature": "class _ParameterizedType(_CassandraType):"
        }
      }
    },
    "cassandra/cqltypes.py:_CassandraType:from_binary": {
      "cassandra/cqltypes.py": {
        "_CassandraType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        \"\"\"\n        Given a bytestring, deserialize into a value according to the protocol\n        for this type. Note that this does not create a new instance of this\n        class; it merely gives back a value that would be appropriate to go\n        inside an instance of this class.\n        \"\"\"\n        return byts",
          "docstring": "Given a bytestring, deserialize into a value according to the protocol\nfor this type. Note that this does not create a new instance of this\nclass; it merely gives back a value that would be appropriate to go\ninside an instance of this class.",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class _CassandraType(object, metaclass=CassandraTypeType):"
        },
        "DecimalType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        scale = int32_unpack(byts[:4])\n        unscaled = varint_unpack(byts[4:])\n        return Decimal('%de%d' % (unscaled, -scale))",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class DecimalType(_CassandraType):"
        },
        "UUIDType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return UUID(bytes=byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class UUIDType(_CassandraType):"
        },
        "BooleanType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return bool(int8_unpack(byts))",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class BooleanType(_CassandraType):"
        },
        "ByteType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return int8_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class ByteType(_CassandraType):"
        },
        "AsciiType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return byts.decode('ascii')",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class AsciiType(_CassandraType):"
        },
        "FloatType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return float_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class FloatType(_CassandraType):"
        },
        "DoubleType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return double_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class DoubleType(_CassandraType):"
        },
        "LongType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return int64_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class LongType(_CassandraType):"
        },
        "Int32Type.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return int32_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class Int32Type(_CassandraType):"
        },
        "IntegerType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return varint_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class IntegerType(_CassandraType):"
        },
        "InetAddressType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        if len(byts) == 16:\n            return util.inet_ntop(socket.AF_INET6, byts)\n        else:\n            return socket.inet_ntoa(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class InetAddressType(_CassandraType):"
        },
        "DateType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        timestamp = int64_unpack(byts) / 1000.0\n        return util.datetime_from_timestamp(timestamp)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class DateType(_CassandraType):"
        },
        "SimpleDateType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        days = uint32_unpack(byts) - SimpleDateType.EPOCH_OFFSET_DAYS\n        return util.Date(days)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class SimpleDateType(_CassandraType):"
        },
        "ShortType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return int16_unpack(byts)",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class ShortType(_CassandraType):"
        },
        "TimeType.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return util.Time(int64_unpack(byts))",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class TimeType(_CassandraType):"
        },
        "UTF8Type.deserialize": {
          "code": "    def deserialize(byts, protocol_version):\n        return byts.decode('utf8')",
          "docstring": "",
          "signature": "def deserialize(byts, protocol_version):",
          "type": "Method",
          "class_signature": "class UTF8Type(_CassandraType):"
        },
        "_ParameterizedType.deserialize": {
          "code": "    def deserialize(cls, byts, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't deserialize unparameterized %s\" % cls.typename)\n        return cls.deserialize_safe(byts, protocol_version)",
          "docstring": "",
          "signature": "def deserialize(cls, byts, protocol_version):",
          "type": "Method",
          "class_signature": "class _ParameterizedType(_CassandraType):"
        }
      }
    },
    "cassandra/cqltypes.py:lookup_casstype": {
      "cassandra/cqltypes.py": {
        "parse_casstype_args": {
          "code": "def parse_casstype_args(typestring):\n    tokens, remainder = casstype_scanner.scan(typestring)\n    if remainder:\n        raise ValueError('weird characters %r at end' % remainder)\n    args = [([], [])]\n    for tok in tokens:\n        if tok == '(':\n            args.append(([], []))\n        elif tok == ')':\n            types, names = args.pop()\n            prev_types, prev_names = args[-1]\n            prev_types[-1] = prev_types[-1].apply_parameters(types, names)\n        else:\n            types, names = args[-1]\n            parts = re.split(':|=>', tok)\n            tok = parts.pop()\n            if parts:\n                names.append(parts[0])\n            else:\n                names.append(None)\n            try:\n                ctype = int(tok)\n            except ValueError:\n                ctype = lookup_casstype_simple(tok)\n            types.append(ctype)\n    return args[0][0][0]",
          "docstring": "",
          "signature": "def parse_casstype_args(typestring):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "cassandra/util.py:OrderedMap:__eq__": {},
    "cassandra/util.py:Date:__eq__": {},
    "cassandra/util.py:Time:__eq__": {}
  },
  "call_tree": {
    "tests/unit/test_marshalling.py:UnmarshalTest:test_date": {
      "cassandra/cqltypes.py:_CassandraType:to_binary": {
        "cassandra/cqltypes.py:DateType:serialize": {}
      },
      "cassandra/cqltypes.py:_CassandraType:from_binary": {
        "cassandra/cqltypes.py:DateType:deserialize": {
          "cassandra/util.py:datetime_from_timestamp": {}
        }
      }
    },
    "tests/unit/test_marshalling.py:UnmarshalTest:test_decimal": {
      "cassandra/cqltypes.py:_CassandraType:to_binary": {
        "cassandra/cqltypes.py:DecimalType:serialize": {
          "cassandra/marshal.py:varint_pack": {
            "cassandra/marshal.py:bit_length": {}
          }
        }
      },
      "cassandra/cqltypes.py:_CassandraType:from_binary": {
        "cassandra/cqltypes.py:DecimalType:deserialize": {
          "cassandra/marshal.py:varint_unpack": {}
        }
      }
    },
    "tests/unit/test_marshalling.py:UnmarshalTest:test_marshalling": {
      "cassandra/cqltypes.py:lookup_casstype": {
        "cassandra/cqltypes.py:parse_casstype_args": {
          "cassandra/cqltypes.py:lookup_casstype_simple": {
            "cassandra/cqltypes.py:trim_if_startswith": {}
          },
          "cassandra/cqltypes.py:_CassandraType:apply_parameters": {
            "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type_with": {
              "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type": {
                "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type_with": {
                  "[ignored_or_cut_off]": "..."
                }
              }
            },
            "cassandra/cqltypes.py:CassandraTypeType:__new__": {}
          }
        }
      },
      "cassandra/cqltypes.py:_CassandraType:to_binary": {
        "cassandra/cqltypes.py:AsciiType:serialize": {},
        "cassandra/cqltypes.py:BooleanType:serialize": {},
        "cassandra/cqltypes.py:BytesType:serialize": {},
        "cassandra/cqltypes.py:LongType:serialize": {},
        "cassandra/cqltypes.py:DateType:serialize": {},
        "cassandra/cqltypes.py:DecimalType:serialize": {
          "cassandra/marshal.py:varint_pack": {
            "cassandra/marshal.py:bit_length": {}
          }
        },
        "cassandra/cqltypes.py:DoubleType:serialize": {},
        "cassandra/cqltypes.py:FloatType:serialize": {},
        "cassandra/cqltypes.py:Int32Type:serialize": {},
        "cassandra/cqltypes.py:IntegerType:serialize": {
          "cassandra/marshal.py:varint_pack": {}
        },
        "cassandra/cqltypes.py:InetAddressType:serialize": {},
        "cassandra/cqltypes.py:UTF8Type:serialize": {},
        "cassandra/cqltypes.py:UUIDType:serialize": {},
        "cassandra/cqltypes.py:_ParameterizedType:serialize": {
          "cassandra/cqltypes.py:MapType:serialize_safe": {
            "cassandra/util.py:OrderedMap:__len__": {},
            "cassandra/util.py:OrderedMap:__iter__": {},
            "cassandra/util.py:OrderedMap:__getitem__": {
              "cassandra/util.py:OrderedMapSerializedKey:_serialize_key": {
                "cassandra/cqltypes.py:UTF8Type:serialize": {}
              }
            },
            "cassandra/cqltypes.py:_CassandraType:to_binary": {
              "[ignored_or_cut_off]": "..."
            }
          },
          "cassandra/cqltypes.py:_SimpleParameterizedType:serialize_safe": {
            "cassandra/util.py:SortedSet:__len__": {},
            "cassandra/util.py:SortedSet:__iter__": {},
            "cassandra/cqltypes.py:_CassandraType:to_binary": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "cassandra/cqltypes.py:SimpleDateType:serialize": {},
        "cassandra/cqltypes.py:TimeType:serialize": {},
        "cassandra/cqltypes.py:ByteType:serialize": {},
        "cassandra/cqltypes.py:ShortType:serialize": {}
      },
      "cassandra/util.py:OrderedMap:__repr__": {},
      "cassandra/util.py:SortedSet:__repr__": {},
      "cassandra/util.py:Date:__repr__": {},
      "cassandra/util.py:Time:__repr__": {}
    },
    "tests/unit/test_marshalling.py:UnmarshalTest:test_unmarshalling": {
      "cassandra/cqltypes.py:lookup_casstype": {
        "cassandra/cqltypes.py:parse_casstype_args": {
          "cassandra/cqltypes.py:lookup_casstype_simple": {
            "cassandra/cqltypes.py:trim_if_startswith": {}
          },
          "cassandra/cqltypes.py:_CassandraType:apply_parameters": {
            "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type_with": {
              "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type": {
                "cassandra/cqltypes.py:_CassandraType:cass_parameterized_type_with": {
                  "[ignored_or_cut_off]": "..."
                }
              }
            },
            "cassandra/cqltypes.py:CassandraTypeType:__new__": {}
          }
        }
      },
      "cassandra/cqltypes.py:_CassandraType:from_binary": {
        "cassandra/cqltypes.py:AsciiType:deserialize": {},
        "cassandra/cqltypes.py:BooleanType:deserialize": {},
        "cassandra/cqltypes.py:_CassandraType:deserialize": {},
        "cassandra/cqltypes.py:LongType:deserialize": {},
        "cassandra/cqltypes.py:DateType:deserialize": {
          "cassandra/util.py:datetime_from_timestamp": {}
        },
        "cassandra/cqltypes.py:DecimalType:deserialize": {
          "cassandra/marshal.py:varint_unpack": {}
        },
        "cassandra/cqltypes.py:DoubleType:deserialize": {},
        "cassandra/cqltypes.py:FloatType:deserialize": {},
        "cassandra/cqltypes.py:Int32Type:deserialize": {},
        "cassandra/cqltypes.py:IntegerType:deserialize": {
          "cassandra/marshal.py:varint_unpack": {}
        },
        "cassandra/cqltypes.py:InetAddressType:deserialize": {},
        "cassandra/cqltypes.py:UTF8Type:deserialize": {},
        "cassandra/cqltypes.py:UUIDType:deserialize": {},
        "cassandra/cqltypes.py:_ParameterizedType:deserialize": {
          "cassandra/cqltypes.py:MapType:deserialize_safe": {
            "cassandra/util.py:OrderedMapSerializedKey:__init__": {
              "cassandra/util.py:OrderedMap:__init__": {}
            },
            "cassandra/cqltypes.py:_CassandraType:from_binary": {
              "[ignored_or_cut_off]": "..."
            },
            "cassandra/util.py:OrderedMapSerializedKey:_insert_unchecked": {}
          },
          "cassandra/cqltypes.py:_SimpleParameterizedType:deserialize_safe": {
            "cassandra/util.py:SortedSet:__init__": {
              "cassandra/util.py:SortedSet:update": {
                "cassandra/util.py:SortedSet:add": {
                  "cassandra/util.py:SortedSet:_find_insertion": {}
                }
              }
            },
            "cassandra/cqltypes.py:_CassandraType:from_binary": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "cassandra/cqltypes.py:SimpleDateType:deserialize": {
          "cassandra/util.py:Date:__init__": {}
        },
        "cassandra/cqltypes.py:TimeType:deserialize": {
          "cassandra/util.py:Time:__init__": {
            "cassandra/util.py:Time:_from_timestamp": {}
          }
        },
        "cassandra/cqltypes.py:ByteType:deserialize": {},
        "cassandra/cqltypes.py:ShortType:deserialize": {}
      },
      "cassandra/util.py:OrderedMap:__repr__": {},
      "cassandra/util.py:OrderedMap:__eq__": {
        "cassandra/util.py:OrderedMap:OrderedMap": {}
      },
      "cassandra/util.py:SortedSet:__repr__": {},
      "cassandra/util.py:SortedSet:__eq__": {},
      "cassandra/util.py:Date:__repr__": {},
      "cassandra/util.py:Date:__eq__": {
        "cassandra/util.py:Date": {}
      },
      "cassandra/util.py:Time:__repr__": {},
      "cassandra/util.py:Time:__eq__": {
        "cassandra/util.py:Time": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/cassandra_driver-image-test_marshalling/cassandra_driver-test_marshalling/tests/integration/advanced/graph/test_graph.py:GraphTimeoutTests:test_server_timeout_less_then_request": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/cassandra_driver-image-test_marshalling/cassandra_driver-test_marshalling/tests/integration/advanced/graph/test_graph.py:GraphProfileTests:test_graph_profile": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    }
  },
  "PRD": "# PROJECT NAME: cassandra_driver-test_marshalling\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 cassandra/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 InvalidRequest.InvalidRequest\n    \u2502   \u2514\u2500\u2500 OperationTimedOut.OperationTimedOut\n    \u251c\u2500\u2500 cqltypes.py\n    \u2502   \u251c\u2500\u2500 _CassandraType.from_binary\n    \u2502   \u251c\u2500\u2500 _CassandraType.to_binary\n    \u2502   \u2514\u2500\u2500 lookup_casstype\n    \u2514\u2500\u2500 util.py\n        \u251c\u2500\u2500 Date.__eq__\n        \u251c\u2500\u2500 Date.__repr__\n        \u251c\u2500\u2500 OrderedMap.__eq__\n        \u251c\u2500\u2500 OrderedMap.__repr__\n        \u251c\u2500\u2500 SortedSet.__eq__\n        \u251c\u2500\u2500 SortedSet.__repr__\n        \u251c\u2500\u2500 Time.__eq__\n        \u2514\u2500\u2500 Time.__repr__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the serialization and deserialization of Cassandra data types, enabling seamless conversion between binary representations and native Python object types. It supports a wide range of Cassandra data types, including primitive types like integers, decimals, and UUIDs, as well as more complex collections such as maps, lists, and sets. By providing marshalling and unmarshalling capabilities, the module ensures efficient data exchange between Python applications and Cassandra databases while maintaining type integrity. This functionality simplifies the development process for users and developers by abstracting the complexities of data transformation, enabling consistent and accurate data handling in distributed database interactions.\n\n## FILE 1: cassandra/util.py\n\n- CLASS METHOD: OrderedMap.__repr__\n  - CLASS SIGNATURE: class OrderedMap(Mapping):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the OrderedMap instance.\n\nThe representation consists of the class name followed by a list of its items formatted as tuples of key-value pairs. Each key-value pair is converted to a string using the representation format of the internal items, which are stored in the attribute `_items`. This method provides a readable format for debugging and logging purposes, reflecting the current state of the OrderedMap.\n\nReturns:\n    str: A string that represents the OrderedMap and its items.\n\"\"\"\n```\n\n- CLASS METHOD: SortedSet.__repr__\n  - CLASS SIGNATURE: class SortedSet(object):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the SortedSet instance, formatted to include the class name and the contents of the set. The output includes the internal list of items (_items) that make up the SortedSet, ensuring that the order of elements is preserved as they were inserted. The representation is useful for debugging and provides insight into the current state of the collection.\n\nThis method does not take any parameters and does not produce side effects; it solely accesses the class's internal state for display purposes. The _items attribute is defined in the __init__ method of SortedSet, where it is initialized to store the sorted elements of the set.\n\"\"\"\n```\n\n- CLASS METHOD: Date.__eq__\n  - CLASS SIGNATURE: class Date(object):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two Date instances or between a Date instance and an integer representing days from epoch.\n\nParameters:\n- other: Can be an instance of Date, an integer, or any other type. If it is a Date, comparison is made with the `days_from_epoch` attribute. If it is an integer, the comparison is directly with `days_from_epoch`.\n\nReturns:\n- bool: True if the Date instance is equal to the other instance based on days from epoch, or if it is an equivalent integer representation. If the type of 'other' is incompatible or raises an exception during conversion to datetime, returns False.\n\nDependencies:\n- The class uses the `days_from_epoch` attribute, which is an integer representing the number of days since the UNIX epoch (1970-01-01). This attribute is crucial for determining equality with both other Date instances and integers.\n\"\"\"\n```\n\n- CLASS METHOD: Date.__repr__\n  - CLASS SIGNATURE: class Date(object):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the Date object, displaying the internal state as the number of days from the epoch (January 1, 1970). This method does not take any parameters and outputs a formatted string indicating the absolute days offset. The `days_from_epoch` attribute, which is an integer representing the number of days from the epoch, is utilized in this representation. The output serves to give a succinct summary of the Date instance, useful for debugging and logging.\n\"\"\"\n```\n\n- CLASS METHOD: OrderedMap.__eq__\n  - CLASS SIGNATURE: class OrderedMap(Mapping):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines equality between two OrderedMap instances or an OrderedMap and another mapping.\n\nParameters:\n- other: An object to compare against the current OrderedMap instance. This can be an instance of OrderedMap or any other mapping type.\n\nReturns:\n- True if the two mappings are equal, meaning they have the same items in the same order; otherwise, False. If `other` is a mapping but does not match in size or key-value pairs, it will return False as well.\n- If `other` is not comparable, it returns NotImplemented.\n\nThis method relies on the internal _items attribute, which holds the ordered pairs of keys and values in the OrderedMap. It supports nested collections by leveraging Python's built-in dict type for comparisons.\n\"\"\"\n```\n\n- CLASS METHOD: SortedSet.__eq__\n  - CLASS SIGNATURE: class SortedSet(object):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if two `SortedSet` instances are equal.\n\nParameters:\n- `other`: The object to compare against. It can be another instance of `SortedSet` or any iterable.\n\nReturns:\n- `True` if `other` is a `SortedSet` and has the same items as the current instance, or if `other` is an iterable with the same length as `_items` and all its elements are contained in the current set.\n- `NotImplemented` if `other` is neither a `SortedSet` nor a compatible iterable.\n\nNotes:\n- The comparison checks for equality of contents rather than reference equality. The method leverages the `__len__` method to compare lengths and utilizes the `__contains__` method to verify presence of items.\n- It allows for flexible comparisons with other iterable types, enhancing the usability of the `SortedSet` class.\n\"\"\"\n```\n\n- CLASS METHOD: Time.__eq__\n  - CLASS SIGNATURE: class Time(object):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares two Time instances or a Time instance with an integer (representing absolute nanoseconds in a day).\n\nParameters:\n- other: The object to compare against. Can be another Time instance or an integer.\n\nReturns:\n- True if the two values are equal based on nanosecond precision; otherwise, False.\n\nThe method leverages the `nanosecond_time` attribute, which holds the absolute nanoseconds in the day for the Time instance being compared. If the 'other' parameter is a Time instance, their `nanosecond_time` values are directly compared. If it is an integer, it checks if the `nanosecond_time` equals that integer. If neither condition is met, the method attempts to convert the Time instance into a built-in `datetime.time` object (using the `hour`, `minute`, `second`, and `nanosecond` properties) and then compares it to 'other', while ensuring the `nanosecond_time` is rounded to the nearest microsecond. The `Time.MICRO` constant is used to help in this rounding process, indicating the number of nanoseconds in a microsecond (1000).\n\"\"\"\n```\n\n- CLASS METHOD: Time.__repr__\n  - CLASS SIGNATURE: class Time(object):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the Time object, formatted as 'Time(nanosecond_time)', where `nanosecond_time` is the absolute time in nanoseconds since the start of the day. This representation is mainly used for debugging and logging purposes to provide a clear indication of the Time object's internal state. The `nanosecond_time` attribute is computed from various formats of time and is defined within the class, serving as a central point for all time-related calculations and operations. This method does not take any parameters and does not produce side effects.\n\"\"\"\n```\n\n## FILE 2: cassandra/cqltypes.py\n\n- CLASS METHOD: _CassandraType.from_binary\n  - CLASS SIGNATURE: class _CassandraType(object, metaclass=CassandraTypeType):\n  - SIGNATURE: def from_binary(cls, byts, protocol_version):\n  - DOCSTRING: \n```python\n\"\"\"\nDeserialize a bytestring into a value while handling potential None or empty string inputs. This method checks if the input `byts` is None or an empty string. If it is None, the function returns None; if it is an empty string and the class doesn't allow for empty binary representations, it either returns the singleton `EMPTY` (an instance of `EmptyValue`) if `support_empty_values` is True, or None otherwise. For valid binary data, it invokes the class's `deserialize` method to convert the bytes into the appropriate value based on the provided protocol version.\n\nParameters:\n- `byts`: The input bytestring to be deserialized. It can be None or an empty string.\n- `protocol_version`: An integer representing the protocol version used for serialization and deserialization.\n\nReturns:\n- The deserialized value derived from the bytestring, which can be a valid type or None, depending on the input and class properties.\n\nDependencies:\n- The `EMPTY` constant is an instance of `EmptyValue`, defined at the module level to represent empty values in situations where empty strings are treated as nulls.\n- `support_empty_values`, a class attribute, is used to determine if the class should treat empty strings as valid values or return None instead.\n\"\"\"\n```\n\n- FUNCTION NAME: lookup_casstype\n  - SIGNATURE: def lookup_casstype(casstype):\n  - DOCSTRING: \n```python\n\"\"\"\nGiven a Cassandra type as a string, this function retrieves the corresponding CassandraType class responsible for that type, including support for parameterized types. If the type name is unrecognized, it creates and returns an instance of the _UnrecognizedType subclass to represent it.\n\nParameters:\n- casstype (str or CassandraType): A string representing the Cassandra type, which may include parameters in the form of parentheses, or an instance of CassandraType or CassandraTypeType.\n\nReturns:\n- CassandraType: The corresponding CassandraType class for the provided casstype, or an instance of _UnrecognizedType if the type is not recognized.\n\nThis function interacts with the `parse_casstype_args` function to interpret complex types, which may raise exceptions if the input string does not conform to the expected format. Additionally, it utilizes the constants `CassandraType` and `CassandraTypeType`, which serve as base classes for all Cassandra types and manage type registrations within the module.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - cassandra/cqltypes.py:parse_casstype_args\n\n- CLASS METHOD: _CassandraType.to_binary\n  - CLASS SIGNATURE: class _CassandraType(object, metaclass=CassandraTypeType):\n  - SIGNATURE: def to_binary(cls, val, protocol_version):\n  - DOCSTRING: \n```python\n\"\"\"\nSerialize a value into a bytestring representation for Cassandra. If the input value is None, the method returns an empty bytes string; otherwise, it delegates to the class-specific `serialize` method to convert the value appropriately based on the defined serialization protocol.\n\nParameters:\n- val: The value to serialize. Can be any data structure supported by the specific CassandraType.\n- protocol_version: An integer representing the protocol version that dictates the serialization format to use.\n\nReturns:\n- A bytestring representing the serialized data for non-None values, or an empty bytestring if the input is None.\n\nThis method relies on the `serialize` method, which must be implemented in the subclass of `_CassandraType`. The function utilizes the `b''` constant to signify an empty bytestring when the input value is None.\n\"\"\"\n```\n\n## FILE 3: cassandra/__init__.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "cassandra/util.py": "from _weakref import ref\nimport calendar\nfrom collections import OrderedDict\nfrom collections.abc import Mapping\nimport datetime\nfrom functools import total_ordering\nfrom itertools import chain\nimport keyword\nimport logging\nimport pickle\nimport random\nimport re\nimport socket\nimport sys\nimport time\nimport uuid\n_HAS_GEOMET = True\ntry:\n    from geomet import wkt\nexcept:\n    _HAS_GEOMET = False\nfrom cassandra import DriverException\nDATETIME_EPOC = datetime.datetime(1970, 1, 1).replace(tzinfo=None)\nUTC_DATETIME_EPOC = datetime.datetime.fromtimestamp(0, tz=datetime.timezone.utc).replace(tzinfo=None)\n_nan = float('nan')\nlog = logging.getLogger(__name__)\nassert sys.byteorder in ('little', 'big')\nis_little_endian = sys.byteorder == 'little'\n\ndef datetime_from_timestamp(timestamp):\n    \"\"\"\n    Creates a timezone-agnostic datetime from timestamp (in seconds) in a consistent manner.\n    Works around a Windows issue with large negative timestamps (PYTHON-119),\n    and rounding differences in Python 3.4 (PYTHON-340).\n\n    :param timestamp: a unix timestamp, in seconds\n    \"\"\"\n    dt = DATETIME_EPOC + datetime.timedelta(seconds=timestamp)\n    return dt\n\ndef utc_datetime_from_ms_timestamp(timestamp):\n    \"\"\"\n    Creates a UTC datetime from a timestamp in milliseconds. See\n    :meth:`datetime_from_timestamp`.\n\n    Raises an `OverflowError` if the timestamp is out of range for\n    :class:`~datetime.datetime`.\n\n    :param timestamp: timestamp, in milliseconds\n    \"\"\"\n    return UTC_DATETIME_EPOC + datetime.timedelta(milliseconds=timestamp)\n\ndef ms_timestamp_from_datetime(dt):\n    \"\"\"\n    Converts a datetime to a timestamp expressed in milliseconds.\n\n    :param dt: a :class:`datetime.datetime`\n    \"\"\"\n    return int(round((dt - UTC_DATETIME_EPOC).total_seconds() * 1000))\n\ndef unix_time_from_uuid1(uuid_arg):\n    \"\"\"\n    Converts a version 1 :class:`uuid.UUID` to a timestamp with the same precision\n    as :meth:`time.time()` returns.  This is useful for examining the\n    results of queries returning a v1 :class:`~uuid.UUID`.\n\n    :param uuid_arg: a version 1 :class:`~uuid.UUID`\n    \"\"\"\n    return (uuid_arg.time - 122192928000000000) / 10000000.0\n\ndef datetime_from_uuid1(uuid_arg):\n    \"\"\"\n    Creates a timezone-agnostic datetime from the timestamp in the\n    specified type-1 UUID.\n\n    :param uuid_arg: a version 1 :class:`~uuid.UUID`\n    \"\"\"\n    return datetime_from_timestamp(unix_time_from_uuid1(uuid_arg))\n\ndef min_uuid_from_time(timestamp):\n    \"\"\"\n    Generates the minimum TimeUUID (type 1) for a given timestamp, as compared by Cassandra.\n\n    See :func:`uuid_from_time` for argument and return types.\n    \"\"\"\n    return uuid_from_time(timestamp, 141289400074368, 128)\n\ndef max_uuid_from_time(timestamp):\n    \"\"\"\n    Generates the maximum TimeUUID (type 1) for a given timestamp, as compared by Cassandra.\n\n    See :func:`uuid_from_time` for argument and return types.\n    \"\"\"\n    return uuid_from_time(timestamp, 140185576636287, 16255)\n\ndef uuid_from_time(time_arg, node=None, clock_seq=None):\n    \"\"\"\n    Converts a datetime or timestamp to a type 1 :class:`uuid.UUID`.\n\n    :param time_arg:\n      The time to use for the timestamp portion of the UUID.\n      This can either be a :class:`datetime` object or a timestamp\n      in seconds (as returned from :meth:`time.time()`).\n    :type datetime: :class:`datetime` or timestamp\n\n    :param node:\n      None integer for the UUID (up to 48 bits). If not specified, this\n      field is randomized.\n    :type node: long\n\n    :param clock_seq:\n      Clock sequence field for the UUID (up to 14 bits). If not specified,\n      a random sequence is generated.\n    :type clock_seq: int\n\n    :rtype: :class:`uuid.UUID`\n\n    \"\"\"\n    if hasattr(time_arg, 'utctimetuple'):\n        seconds = int(calendar.timegm(time_arg.utctimetuple()))\n        microseconds = seconds * 1000000.0 + time_arg.time().microsecond\n    else:\n        microseconds = int(time_arg * 1000000.0)\n    intervals = int(microseconds * 10) + 122192928000000000\n    time_low = intervals & 4294967295\n    time_mid = intervals >> 32 & 65535\n    time_hi_version = intervals >> 48 & 4095\n    if clock_seq is None:\n        clock_seq = random.getrandbits(14)\n    elif clock_seq > 16383:\n        raise ValueError('clock_seq is out of range (need a 14-bit value)')\n    clock_seq_low = clock_seq & 255\n    clock_seq_hi_variant = 128 | clock_seq >> 8 & 63\n    if node is None:\n        node = random.getrandbits(48)\n    return uuid.UUID(fields=(time_low, time_mid, time_hi_version, clock_seq_hi_variant, clock_seq_low, node), version=1)\nLOWEST_TIME_UUID = uuid.UUID('00000000-0000-1000-8080-808080808080')\n' The lowest possible TimeUUID, as sorted by Cassandra. '\nHIGHEST_TIME_UUID = uuid.UUID('ffffffff-ffff-1fff-bf7f-7f7f7f7f7f7f')\n' The highest possible TimeUUID, as sorted by Cassandra. '\n\ndef _addrinfo_or_none(contact_point, port):\n    \"\"\"\n    A helper function that wraps socket.getaddrinfo and returns None\n    when it fails to, e.g. resolve one of the hostnames. Used to address\n    PYTHON-895.\n    \"\"\"\n    try:\n        value = socket.getaddrinfo(contact_point, port, socket.AF_UNSPEC, socket.SOCK_STREAM)\n        return value\n    except socket.gaierror:\n        log.debug('Could not resolve hostname \"{}\" with port {}'.format(contact_point, port))\n        return None\n\ndef _addrinfo_to_ip_strings(addrinfo):\n    \"\"\"\n    Helper function that consumes the data output by socket.getaddrinfo and\n    extracts the IP address from the sockaddr portion of the result.\n\n    Since this is meant to be used in conjunction with _addrinfo_or_none,\n    this will pass None and EndPoint instances through unaffected.\n    \"\"\"\n    if addrinfo is None:\n        return None\n    return [(entry[4][0], entry[4][1]) for entry in addrinfo]\n\ndef _resolve_contact_points_to_string_map(contact_points):\n    return OrderedDict((('{cp}:{port}'.format(cp=cp, port=port), _addrinfo_to_ip_strings(_addrinfo_or_none(cp, port))) for cp, port in contact_points))\n\nclass _IterationGuard(object):\n\n    def __init__(self, weakcontainer):\n        self.weakcontainer = ref(weakcontainer)\n\n    def __enter__(self):\n        w = self.weakcontainer()\n        if w is not None:\n            w._iterating.add(self)\n        return self\n\n    def __exit__(self, e, t, b):\n        w = self.weakcontainer()\n        if w is not None:\n            s = w._iterating\n            s.remove(self)\n            if not s:\n                w._commit_removals()\n\nclass WeakSet(object):\n\n    def __init__(self, data=None):\n        self.data = set()\n\n        def _remove(item, selfref=ref(self)):\n            self = selfref()\n            if self is not None:\n                if self._iterating:\n                    self._pending_removals.append(item)\n                else:\n                    self.data.discard(item)\n        self._remove = _remove\n        self._pending_removals = []\n        self._iterating = set()\n        if data is not None:\n            self.update(data)\n\n    def _commit_removals(self):\n        l = self._pending_removals\n        discard = self.data.discard\n        while l:\n            discard(l.pop())\n\n    def __iter__(self):\n        with _IterationGuard(self):\n            for itemref in self.data:\n                item = itemref()\n                if item is not None:\n                    yield item\n\n    def __len__(self):\n        return sum((x() is not None for x in self.data))\n\n    def __contains__(self, item):\n        return ref(item) in self.data\n\n    def __reduce__(self):\n        return (self.__class__, (list(self),), getattr(self, '__dict__', None))\n    __hash__ = None\n\n    def add(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.add(ref(item, self._remove))\n\n    def clear(self):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.clear()\n\n    def copy(self):\n        return self.__class__(self)\n\n    def pop(self):\n        if self._pending_removals:\n            self._commit_removals()\n        while True:\n            try:\n                itemref = self.data.pop()\n            except KeyError:\n                raise KeyError('pop from empty WeakSet')\n            item = itemref()\n            if item is not None:\n                return item\n\n    def remove(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.remove(ref(item))\n\n    def discard(self, item):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.discard(ref(item))\n\n    def update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if isinstance(other, self.__class__):\n            self.data.update(other.data)\n        else:\n            for element in other:\n                self.add(element)\n\n    def __ior__(self, other):\n        self.update(other)\n        return self\n\n    def _apply(self, other, method):\n        if not isinstance(other, self.__class__):\n            other = self.__class__(other)\n        newdata = method(other.data)\n        newset = self.__class__()\n        newset.data = newdata\n        return newset\n\n    def difference(self, other):\n        return self._apply(other, self.data.difference)\n    __sub__ = difference\n\n    def difference_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update((ref(item) for item in other))\n\n    def __isub__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.difference_update((ref(item) for item in other))\n        return self\n\n    def intersection(self, other):\n        return self._apply(other, self.data.intersection)\n    __and__ = intersection\n\n    def intersection_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update((ref(item) for item in other))\n\n    def __iand__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        self.data.intersection_update((ref(item) for item in other))\n        return self\n\n    def issubset(self, other):\n        return self.data.issubset((ref(item) for item in other))\n    __lt__ = issubset\n\n    def __le__(self, other):\n        return self.data <= set((ref(item) for item in other))\n\n    def issuperset(self, other):\n        return self.data.issuperset((ref(item) for item in other))\n    __gt__ = issuperset\n\n    def __ge__(self, other):\n        return self.data >= set((ref(item) for item in other))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.data == set((ref(item) for item in other))\n\n    def symmetric_difference(self, other):\n        return self._apply(other, self.data.symmetric_difference)\n    __xor__ = symmetric_difference\n\n    def symmetric_difference_update(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update((ref(item) for item in other))\n\n    def __ixor__(self, other):\n        if self._pending_removals:\n            self._commit_removals()\n        if self is other:\n            self.data.clear()\n        else:\n            self.data.symmetric_difference_update((ref(item) for item in other))\n        return self\n\n    def union(self, other):\n        return self._apply(other, self.data.union)\n    __or__ = union\n\n    def isdisjoint(self, other):\n        return len(self.intersection(other)) == 0\n\nclass SortedSet(object):\n    \"\"\"\n    A sorted set based on sorted list\n\n    A sorted set implementation is used in this case because it does not\n    require its elements to be immutable/hashable.\n\n    #Not implemented: update functions, inplace operators\n    \"\"\"\n\n    def __init__(self, iterable=()):\n        self._items = []\n        self.update(iterable)\n\n    def __len__(self):\n        return len(self._items)\n\n    def __getitem__(self, i):\n        return self._items[i]\n\n    def __iter__(self):\n        return iter(self._items)\n\n    def __reversed__(self):\n        return reversed(self._items)\n\n    def __reduce__(self):\n        return (self.__class__, (self._items,))\n\n    def __ne__(self, other):\n        if isinstance(other, self.__class__):\n            return self._items != other._items\n        else:\n            try:\n                return len(other) != len(self._items) or any((item not in self for item in other))\n            except TypeError:\n                return NotImplemented\n\n    def __le__(self, other):\n        return self.issubset(other)\n\n    def __lt__(self, other):\n        return len(other) > len(self._items) and self.issubset(other)\n\n    def __ge__(self, other):\n        return self.issuperset(other)\n\n    def __gt__(self, other):\n        return len(self._items) > len(other) and self.issuperset(other)\n\n    def __and__(self, other):\n        return self._intersect(other)\n    __rand__ = __and__\n\n    def __iand__(self, other):\n        isect = self._intersect(other)\n        self._items = isect._items\n        return self\n\n    def __or__(self, other):\n        return self.union(other)\n    __ror__ = __or__\n\n    def __ior__(self, other):\n        union = self.union(other)\n        self._items = union._items\n        return self\n\n    def __sub__(self, other):\n        return self._diff(other)\n\n    def __rsub__(self, other):\n        return sortedset(other) - self\n\n    def __isub__(self, other):\n        diff = self._diff(other)\n        self._items = diff._items\n        return self\n\n    def __xor__(self, other):\n        return self.symmetric_difference(other)\n    __rxor__ = __xor__\n\n    def __ixor__(self, other):\n        sym_diff = self.symmetric_difference(other)\n        self._items = sym_diff._items\n        return self\n\n    def __contains__(self, item):\n        i = self._find_insertion(item)\n        return i < len(self._items) and self._items[i] == item\n\n    def __delitem__(self, i):\n        del self._items[i]\n\n    def __delslice__(self, i, j):\n        del self._items[i:j]\n\n    def add(self, item):\n        i = self._find_insertion(item)\n        if i < len(self._items):\n            if self._items[i] != item:\n                self._items.insert(i, item)\n        else:\n            self._items.append(item)\n\n    def update(self, iterable):\n        for i in iterable:\n            self.add(i)\n\n    def clear(self):\n        del self._items[:]\n\n    def copy(self):\n        new = sortedset()\n        new._items = list(self._items)\n        return new\n\n    def isdisjoint(self, other):\n        return len(self._intersect(other)) == 0\n\n    def issubset(self, other):\n        return len(self._intersect(other)) == len(self._items)\n\n    def issuperset(self, other):\n        return len(self._intersect(other)) == len(other)\n\n    def pop(self):\n        if not self._items:\n            raise KeyError('pop from empty set')\n        return self._items.pop()\n\n    def remove(self, item):\n        i = self._find_insertion(item)\n        if i < len(self._items):\n            if self._items[i] == item:\n                self._items.pop(i)\n                return\n        raise KeyError('%r' % item)\n\n    def union(self, *others):\n        union = sortedset()\n        union._items = list(self._items)\n        for other in others:\n            for item in other:\n                union.add(item)\n        return union\n\n    def intersection(self, *others):\n        isect = self.copy()\n        for other in others:\n            isect = isect._intersect(other)\n            if not isect:\n                break\n        return isect\n\n    def difference(self, *others):\n        diff = self.copy()\n        for other in others:\n            diff = diff._diff(other)\n            if not diff:\n                break\n        return diff\n\n    def symmetric_difference(self, other):\n        diff_self_other = self._diff(other)\n        diff_other_self = other.difference(self)\n        return diff_self_other.union(diff_other_self)\n\n    def _diff(self, other):\n        diff = sortedset()\n        for item in self._items:\n            if item not in other:\n                diff.add(item)\n        return diff\n\n    def _intersect(self, other):\n        isect = sortedset()\n        for item in self._items:\n            if item in other:\n                isect.add(item)\n        return isect\n\n    def _find_insertion(self, x):\n        a = self._items\n        lo = 0\n        hi = len(a)\n        try:\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if a[mid] < x:\n                    lo = mid + 1\n                else:\n                    hi = mid\n        except TypeError:\n            lo = 0\n            compared_one = False\n            while lo < hi:\n                try:\n                    if a[lo] == x or a[lo] >= x:\n                        break\n                    compared_one = True\n                except TypeError:\n                    if compared_one:\n                        break\n                lo += 1\n        return lo\nsortedset = SortedSet\n\nclass OrderedMap(Mapping):\n    \"\"\"\n    An ordered map that accepts non-hashable types for keys. It also maintains the\n    insertion order of items, behaving as OrderedDict in that regard. These maps\n    are constructed and read just as normal mapping types, except that they may\n    contain arbitrary collections and other non-hashable items as keys::\n\n        >>> od = OrderedMap([({'one': 1, 'two': 2}, 'value'),\n        ...                  ({'three': 3, 'four': 4}, 'value2')])\n        >>> list(od.keys())\n        [{'two': 2, 'one': 1}, {'three': 3, 'four': 4}]\n        >>> list(od.values())\n        ['value', 'value2']\n\n    These constructs are needed to support nested collections in Cassandra 2.1.3+,\n    where frozen collections can be specified as parameters to others::\n\n        CREATE TABLE example (\n            ...\n            value map<frozen<map<int, int>>, double>\n            ...\n        )\n\n    This class derives from the (immutable) Mapping API. Objects in these maps\n    are not intended be modified.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        if len(args) > 1:\n            raise TypeError('expected at most 1 arguments, got %d' % len(args))\n        self._items = []\n        self._index = {}\n        if args:\n            e = args[0]\n            if callable(getattr(e, 'keys', None)):\n                for k in e.keys():\n                    self._insert(k, e[k])\n            else:\n                for k, v in e:\n                    self._insert(k, v)\n        for k, v in kwargs.items():\n            self._insert(k, v)\n\n    def _insert(self, key, value):\n        flat_key = self._serialize_key(key)\n        i = self._index.get(flat_key, -1)\n        if i >= 0:\n            self._items[i] = (key, value)\n        else:\n            self._items.append((key, value))\n            self._index[flat_key] = len(self._items) - 1\n    __setitem__ = _insert\n\n    def __getitem__(self, key):\n        try:\n            index = self._index[self._serialize_key(key)]\n            return self._items[index][1]\n        except KeyError:\n            raise KeyError(str(key))\n\n    def __delitem__(self, key):\n        try:\n            index = self._index.pop(self._serialize_key(key))\n            self._index = dict(((k, i if i < index else i - 1) for k, i in self._index.items()))\n            self._items.pop(index)\n        except KeyError:\n            raise KeyError(str(key))\n\n    def __iter__(self):\n        for i in self._items:\n            yield i[0]\n\n    def __len__(self):\n        return len(self._items)\n\n    def __str__(self):\n        return '{%s}' % ', '.join(('%r: %r' % (k, v) for k, v in self._items))\n\n    def popitem(self):\n        try:\n            kv = self._items.pop()\n            del self._index[self._serialize_key(kv[0])]\n            return kv\n        except IndexError:\n            raise KeyError()\n\n    def _serialize_key(self, key):\n        return pickle.dumps(key)\n\nclass OrderedMapSerializedKey(OrderedMap):\n\n    def __init__(self, cass_type, protocol_version):\n        super(OrderedMapSerializedKey, self).__init__()\n        self.cass_key_type = cass_type\n        self.protocol_version = protocol_version\n\n    def _insert_unchecked(self, key, flat_key, value):\n        self._items.append((key, value))\n        self._index[flat_key] = len(self._items) - 1\n\n    def _serialize_key(self, key):\n        return self.cass_key_type.serialize(key, self.protocol_version)\n\n@total_ordering\nclass Time(object):\n    \"\"\"\n    Idealized time, independent of day.\n\n    Up to nanosecond resolution\n    \"\"\"\n    MICRO = 1000\n    MILLI = 1000 * MICRO\n    SECOND = 1000 * MILLI\n    MINUTE = 60 * SECOND\n    HOUR = 60 * MINUTE\n    DAY = 24 * HOUR\n    nanosecond_time = 0\n\n    def __init__(self, value):\n        \"\"\"\n        Initializer value can be:\n\n        - integer_type: absolute nanoseconds in the day\n        - datetime.time: built-in time\n        - string_type: a string time of the form \"HH:MM:SS[.mmmuuunnn]\"\n        \"\"\"\n        if isinstance(value, int):\n            self._from_timestamp(value)\n        elif isinstance(value, datetime.time):\n            self._from_time(value)\n        elif isinstance(value, str):\n            self._from_timestring(value)\n        else:\n            raise TypeError('Time arguments must be a whole number, datetime.time, or string')\n\n    @property\n    def hour(self):\n        \"\"\"\n        The hour component of this time (0-23)\n        \"\"\"\n        return self.nanosecond_time // Time.HOUR\n\n    @property\n    def minute(self):\n        \"\"\"\n        The minute component of this time (0-59)\n        \"\"\"\n        minutes = self.nanosecond_time // Time.MINUTE\n        return minutes % 60\n\n    @property\n    def second(self):\n        \"\"\"\n        The second component of this time (0-59)\n        \"\"\"\n        seconds = self.nanosecond_time // Time.SECOND\n        return seconds % 60\n\n    @property\n    def nanosecond(self):\n        \"\"\"\n        The fractional seconds component of the time, in nanoseconds\n        \"\"\"\n        return self.nanosecond_time % Time.SECOND\n\n    def time(self):\n        \"\"\"\n        Return a built-in datetime.time (nanosecond precision truncated to micros).\n        \"\"\"\n        return datetime.time(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.nanosecond // Time.MICRO)\n\n    def _from_timestamp(self, t):\n        if t >= Time.DAY:\n            raise ValueError('value must be less than number of nanoseconds in a day (%d)' % Time.DAY)\n        self.nanosecond_time = t\n\n    def _from_timestring(self, s):\n        try:\n            parts = s.split('.')\n            base_time = time.strptime(parts[0], '%H:%M:%S')\n            self.nanosecond_time = base_time.tm_hour * Time.HOUR + base_time.tm_min * Time.MINUTE + base_time.tm_sec * Time.SECOND\n            if len(parts) > 1:\n                nano_time_str = parts[1] + '0' * (9 - len(parts[1]))\n                self.nanosecond_time += int(nano_time_str)\n        except ValueError:\n            raise ValueError(\"can't interpret %r as a time\" % (s,))\n\n    def _from_time(self, t):\n        self.nanosecond_time = t.hour * Time.HOUR + t.minute * Time.MINUTE + t.second * Time.SECOND + t.microsecond * Time.MICRO\n\n    def __hash__(self):\n        return self.nanosecond_time\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(other, Time):\n            return NotImplemented\n        return self.nanosecond_time < other.nanosecond_time\n\n    def __str__(self):\n        return '%02d:%02d:%02d.%09d' % (self.hour, self.minute, self.second, self.nanosecond)\n\n@total_ordering\nclass Date(object):\n    \"\"\"\n    Idealized date: year, month, day\n\n    Offers wider year range than datetime.date. For Dates that cannot be represented\n    as a datetime.date (because datetime.MINYEAR, datetime.MAXYEAR), this type falls back\n    to printing days_from_epoch offset.\n    \"\"\"\n    MINUTE = 60\n    HOUR = 60 * MINUTE\n    DAY = 24 * HOUR\n    date_format = '%Y-%m-%d'\n    days_from_epoch = 0\n\n    def __init__(self, value):\n        \"\"\"\n        Initializer value can be:\n\n        - integer_type: absolute days from epoch (1970, 1, 1). Can be negative.\n        - datetime.date: built-in date\n        - string_type: a string time of the form \"yyyy-mm-dd\"\n        \"\"\"\n        if isinstance(value, int):\n            self.days_from_epoch = value\n        elif isinstance(value, (datetime.date, datetime.datetime)):\n            self._from_timetuple(value.timetuple())\n        elif isinstance(value, str):\n            self._from_datestring(value)\n        else:\n            raise TypeError('Date arguments must be a whole number, datetime.date, or string')\n\n    @property\n    def seconds(self):\n        \"\"\"\n        Absolute seconds from epoch (can be negative)\n        \"\"\"\n        return self.days_from_epoch * Date.DAY\n\n    def date(self):\n        \"\"\"\n        Return a built-in datetime.date for Dates falling in the years [datetime.MINYEAR, datetime.MAXYEAR]\n\n        ValueError is raised for Dates outside this range.\n        \"\"\"\n        try:\n            dt = datetime_from_timestamp(self.seconds)\n            return datetime.date(dt.year, dt.month, dt.day)\n        except Exception:\n            raise ValueError('%r exceeds ranges for built-in datetime.date' % self)\n\n    def _from_timetuple(self, t):\n        self.days_from_epoch = calendar.timegm(t) // Date.DAY\n\n    def _from_datestring(self, s):\n        if s[0] == '+':\n            s = s[1:]\n        dt = datetime.datetime.strptime(s, self.date_format)\n        self._from_timetuple(dt.timetuple())\n\n    def __hash__(self):\n        return self.days_from_epoch\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __lt__(self, other):\n        if not isinstance(other, Date):\n            return NotImplemented\n        return self.days_from_epoch < other.days_from_epoch\n\n    def __str__(self):\n        try:\n            dt = datetime_from_timestamp(self.seconds)\n            return '%04d-%02d-%02d' % (dt.year, dt.month, dt.day)\n        except:\n            return str(self.days_from_epoch)\ninet_pton = socket.inet_pton\ninet_ntop = socket.inet_ntop\n\ndef _positional_rename_invalid_identifiers(field_names):\n    names_out = list(field_names)\n    for index, name in enumerate(field_names):\n        if not all((c.isalnum() or c == '_' for c in name)) or keyword.iskeyword(name) or (not name) or name[0].isdigit() or name.startswith('_'):\n            names_out[index] = 'field_%d_' % index\n    return names_out\n\ndef _sanitize_identifiers(field_names):\n    names_out = _positional_rename_invalid_identifiers(field_names)\n    if len(names_out) != len(set(names_out)):\n        observed_names = set()\n        for index, name in enumerate(names_out):\n            while names_out[index] in observed_names:\n                names_out[index] = '%s_' % (names_out[index],)\n            observed_names.add(names_out[index])\n    return names_out\n\ndef list_contents_to_tuple(to_convert):\n    if isinstance(to_convert, list):\n        for n, i in enumerate(to_convert):\n            if isinstance(to_convert[n], list):\n                to_convert[n] = tuple(to_convert[n])\n        return tuple(to_convert)\n    else:\n        return to_convert\n\nclass Point(object):\n    \"\"\"\n    Represents a point geometry for DSE\n    \"\"\"\n    x = None\n    '\\n    x coordinate of the point\\n    '\n    y = None\n    '\\n    y coordinate of the point\\n    '\n\n    def __init__(self, x=_nan, y=_nan):\n        self.x = x\n        self.y = y\n\n    def __eq__(self, other):\n        return isinstance(other, Point) and self.x == other.x and (self.y == other.y)\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the point\n        \"\"\"\n        return 'POINT (%r %r)' % (self.x, self.y)\n\n    def __repr__(self):\n        return '%s(%r, %r)' % (self.__class__.__name__, self.x, self.y)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Point geometry from a wkt string and return a new Point object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException('Geomet is required to deserialize a wkt geometry.')\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n        if geom['type'] != 'Point':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'Point', got '{0}': '{1}'\".format(geom['type'], s))\n        coords = geom['coordinates']\n        if len(coords) < 2:\n            x = y = _nan\n        else:\n            x = coords[0]\n            y = coords[1]\n        return Point(x=x, y=y)\n\nclass LineString(object):\n    \"\"\"\n    Represents a linestring geometry for DSE\n    \"\"\"\n    coords = None\n    '\\n    Tuple of (x, y) coordinates in the linestring\\n    '\n\n    def __init__(self, coords=tuple()):\n        \"\"\"\n        'coords`: a sequence of (x, y) coordinates of points in the linestring\n        \"\"\"\n        self.coords = tuple(coords)\n\n    def __eq__(self, other):\n        return isinstance(other, LineString) and self.coords == other.coords\n\n    def __hash__(self):\n        return hash(self.coords)\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the LineString\n        \"\"\"\n        if not self.coords:\n            return 'LINESTRING EMPTY'\n        return 'LINESTRING (%s)' % ', '.join(('%r %r' % (x, y) for x, y in self.coords))\n\n    def __repr__(self):\n        return '%s(%r)' % (self.__class__.__name__, self.coords)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a LineString geometry from a wkt string and return a new LineString object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException('Geomet is required to deserialize a wkt geometry.')\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n        if geom['type'] != 'LineString':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'LineString', got '{0}': '{1}'\".format(geom['type'], s))\n        geom['coordinates'] = list_contents_to_tuple(geom['coordinates'])\n        return LineString(coords=geom['coordinates'])\n\nclass _LinearRing(object):\n\n    def __init__(self, coords=tuple()):\n        self.coords = list_contents_to_tuple(coords)\n\n    def __eq__(self, other):\n        return isinstance(other, _LinearRing) and self.coords == other.coords\n\n    def __hash__(self):\n        return hash(self.coords)\n\n    def __str__(self):\n        if not self.coords:\n            return 'LINEARRING EMPTY'\n        return 'LINEARRING (%s)' % ', '.join(('%r %r' % (x, y) for x, y in self.coords))\n\n    def __repr__(self):\n        return '%s(%r)' % (self.__class__.__name__, self.coords)\n\nclass Polygon(object):\n    \"\"\"\n    Represents a polygon geometry for DSE\n    \"\"\"\n    exterior = None\n    '\\n    _LinearRing representing the exterior of the polygon\\n    '\n    interiors = None\n    '\\n    Tuple of _LinearRings representing interior holes in the polygon\\n    '\n\n    def __init__(self, exterior=tuple(), interiors=None):\n        \"\"\"\n        'exterior`: a sequence of (x, y) coordinates of points in the linestring\n        `interiors`: None, or a sequence of sequences or (x, y) coordinates of points describing interior linear rings\n        \"\"\"\n        self.exterior = _LinearRing(exterior)\n        self.interiors = tuple((_LinearRing(e) for e in interiors)) if interiors else tuple()\n\n    def __eq__(self, other):\n        return isinstance(other, Polygon) and self.exterior == other.exterior and (self.interiors == other.interiors)\n\n    def __hash__(self):\n        return hash((self.exterior, self.interiors))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the polygon\n        \"\"\"\n        if not self.exterior.coords:\n            return 'POLYGON EMPTY'\n        rings = [ring.coords for ring in chain((self.exterior,), self.interiors)]\n        rings = ['(%s)' % ', '.join(('%r %r' % (x, y) for x, y in ring)) for ring in rings]\n        return 'POLYGON (%s)' % ', '.join(rings)\n\n    def __repr__(self):\n        return '%s(%r, %r)' % (self.__class__.__name__, self.exterior.coords, [ring.coords for ring in self.interiors])\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Polygon geometry from a wkt string and return a new Polygon object.\n        \"\"\"\n        if not _HAS_GEOMET:\n            raise DriverException('Geomet is required to deserialize a wkt geometry.')\n        try:\n            geom = wkt.loads(s)\n        except ValueError:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n        if geom['type'] != 'Polygon':\n            raise ValueError(\"Invalid WKT geometry type. Expected 'Polygon', got '{0}': '{1}'\".format(geom['type'], s))\n        coords = geom['coordinates']\n        exterior = coords[0] if len(coords) > 0 else tuple()\n        interiors = coords[1:] if len(coords) > 1 else None\n        return Polygon(exterior=exterior, interiors=interiors)\n_distance_wkt_pattern = re.compile('distance *\\\\( *\\\\( *([\\\\d\\\\.-]+) *([\\\\d+\\\\.-]+) *\\\\) *([\\\\d+\\\\.-]+) *\\\\) *$', re.IGNORECASE)\n\nclass Distance(object):\n    \"\"\"\n    Represents a Distance geometry for DSE\n    \"\"\"\n    x = None\n    '\\n    x coordinate of the center point\\n    '\n    y = None\n    '\\n    y coordinate of the center point\\n    '\n    radius = None\n    '\\n    radius to represent the distance from the center point\\n    '\n\n    def __init__(self, x=_nan, y=_nan, radius=_nan):\n        self.x = x\n        self.y = y\n        self.radius = radius\n\n    def __eq__(self, other):\n        return isinstance(other, Distance) and self.x == other.x and (self.y == other.y) and (self.radius == other.radius)\n\n    def __hash__(self):\n        return hash((self.x, self.y, self.radius))\n\n    def __str__(self):\n        \"\"\"\n        Well-known text representation of the point\n        \"\"\"\n        return 'DISTANCE ((%r %r) %r)' % (self.x, self.y, self.radius)\n\n    def __repr__(self):\n        return '%s(%r, %r, %r)' % (self.__class__.__name__, self.x, self.y, self.radius)\n\n    @staticmethod\n    def from_wkt(s):\n        \"\"\"\n        Parse a Distance geometry from a wkt string and return a new Distance object.\n        \"\"\"\n        distance_match = _distance_wkt_pattern.match(s)\n        if distance_match is None:\n            raise ValueError(\"Invalid WKT geometry: '{0}'\".format(s))\n        x, y, radius = distance_match.groups()\n        return Distance(x, y, radius)\n\nclass Duration(object):\n    \"\"\"\n    Cassandra Duration Type\n    \"\"\"\n    months = 0\n    ''\n    days = 0\n    ''\n    nanoseconds = 0\n    ''\n\n    def __init__(self, months=0, days=0, nanoseconds=0):\n        self.months = months\n        self.days = days\n        self.nanoseconds = nanoseconds\n\n    def __eq__(self, other):\n        return isinstance(other, self.__class__) and self.months == other.months and (self.days == other.days) and (self.nanoseconds == other.nanoseconds)\n\n    def __repr__(self):\n        return 'Duration({0}, {1}, {2})'.format(self.months, self.days, self.nanoseconds)\n\n    def __str__(self):\n        has_negative_values = self.months < 0 or self.days < 0 or self.nanoseconds < 0\n        return '%s%dmo%dd%dns' % ('-' if has_negative_values else '', abs(self.months), abs(self.days), abs(self.nanoseconds))\n\nclass DateRangePrecision(object):\n    \"\"\"\n    An \"enum\" representing the valid values for :attr:`DateRange.precision`.\n    \"\"\"\n    YEAR = 'YEAR'\n    '\\n    '\n    MONTH = 'MONTH'\n    '\\n    '\n    DAY = 'DAY'\n    '\\n    '\n    HOUR = 'HOUR'\n    '\\n    '\n    MINUTE = 'MINUTE'\n    '\\n    '\n    SECOND = 'SECOND'\n    '\\n    '\n    MILLISECOND = 'MILLISECOND'\n    '\\n    '\n    PRECISIONS = (YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MILLISECOND)\n    '\\n    '\n\n    @classmethod\n    def _to_int(cls, precision):\n        return cls.PRECISIONS.index(precision.upper())\n\n    @classmethod\n    def _round_to_precision(cls, ms, precision, default_dt):\n        try:\n            dt = utc_datetime_from_ms_timestamp(ms)\n        except OverflowError:\n            return ms\n        precision_idx = cls._to_int(precision)\n        replace_kwargs = {}\n        if precision_idx <= cls._to_int(DateRangePrecision.YEAR):\n            replace_kwargs['month'] = default_dt.month\n        if precision_idx <= cls._to_int(DateRangePrecision.MONTH):\n            replace_kwargs['day'] = default_dt.day\n        if precision_idx <= cls._to_int(DateRangePrecision.DAY):\n            replace_kwargs['hour'] = default_dt.hour\n        if precision_idx <= cls._to_int(DateRangePrecision.HOUR):\n            replace_kwargs['minute'] = default_dt.minute\n        if precision_idx <= cls._to_int(DateRangePrecision.MINUTE):\n            replace_kwargs['second'] = default_dt.second\n        if precision_idx <= cls._to_int(DateRangePrecision.SECOND):\n            replace_kwargs['microsecond'] = default_dt.microsecond // 1000 * 1000\n        if precision_idx == cls._to_int(DateRangePrecision.MILLISECOND):\n            replace_kwargs['microsecond'] = int(round(dt.microsecond, -3))\n        return ms_timestamp_from_datetime(dt.replace(**replace_kwargs))\n\n    @classmethod\n    def round_up_to_precision(cls, ms, precision):\n        if precision == cls.MONTH:\n            date_ms = utc_datetime_from_ms_timestamp(ms)\n            upper_date = datetime.datetime.max.replace(year=date_ms.year, month=date_ms.month, day=calendar.monthrange(date_ms.year, date_ms.month)[1])\n        else:\n            upper_date = datetime.datetime.max\n        return cls._round_to_precision(ms, precision, upper_date)\n\n    @classmethod\n    def round_down_to_precision(cls, ms, precision):\n        return cls._round_to_precision(ms, precision, datetime.datetime.min)\n\n@total_ordering\nclass DateRangeBound(object):\n    \"\"\"DateRangeBound(value, precision)\n    Represents a single date value and its precision for :class:`DateRange`.\n\n    .. attribute:: milliseconds\n\n        Integer representing milliseconds since the UNIX epoch. May be negative.\n\n    .. attribute:: precision\n\n        String representing the precision of a bound. Must be a valid\n        :class:`DateRangePrecision` member.\n\n    :class:`DateRangeBound` uses a millisecond offset from the UNIX epoch to\n    allow :class:`DateRange` to represent values `datetime.datetime` cannot.\n    For such values, string representions will show this offset rather than the\n    CQL representation.\n    \"\"\"\n    milliseconds = None\n    precision = None\n\n    def __init__(self, value, precision):\n        \"\"\"\n        :param value: a value representing ms since the epoch. Accepts an\n            integer or a datetime.\n        :param precision: a string representing precision\n        \"\"\"\n        if precision is not None:\n            try:\n                self.precision = precision.upper()\n            except AttributeError:\n                raise TypeError('precision must be a string; got %r' % precision)\n        if value is None:\n            milliseconds = None\n        elif isinstance(value, int):\n            milliseconds = value\n        elif isinstance(value, datetime.datetime):\n            value = value.replace(microsecond=int(round(value.microsecond, -3)))\n            milliseconds = ms_timestamp_from_datetime(value)\n        else:\n            raise ValueError('%r is not a valid value for DateRangeBound' % value)\n        self.milliseconds = milliseconds\n        self.validate()\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.milliseconds == other.milliseconds and self.precision == other.precision\n\n    def __lt__(self, other):\n        return (str(self.milliseconds), str(self.precision)) < (str(other.milliseconds), str(other.precision))\n\n    def datetime(self):\n        \"\"\"\n        Return :attr:`milliseconds` as a :class:`datetime.datetime` if possible.\n        Raises an `OverflowError` if the value is out of range.\n        \"\"\"\n        return utc_datetime_from_ms_timestamp(self.milliseconds)\n\n    def validate(self):\n        attrs = (self.milliseconds, self.precision)\n        if attrs == (None, None):\n            return\n        if None in attrs:\n            raise TypeError('%s.datetime and %s.precision must not be None unless both are None; Got: %r' % (self.__class__.__name__, self.__class__.__name__, self))\n        if self.precision not in DateRangePrecision.PRECISIONS:\n            raise ValueError('%s.precision: expected value in %r; got %r' % (self.__class__.__name__, DateRangePrecision.PRECISIONS, self.precision))\n\n    @classmethod\n    def from_value(cls, value):\n        \"\"\"\n        Construct a new :class:`DateRangeBound` from a given value. If\n        possible, use the `value['milliseconds']` and `value['precision']` keys\n        of the argument. Otherwise, use the argument as a `(milliseconds,\n        precision)` iterable.\n\n        :param value: a dictlike or iterable object\n        \"\"\"\n        if isinstance(value, cls):\n            return value\n        try:\n            milliseconds, precision = (value.get('milliseconds'), value.get('precision'))\n        except AttributeError:\n            milliseconds = precision = None\n        if milliseconds is not None and precision is not None:\n            return DateRangeBound(value=milliseconds, precision=precision)\n        return DateRangeBound(*value)\n\n    def round_up(self):\n        if self.milliseconds is None or self.precision is None:\n            return self\n        self.milliseconds = DateRangePrecision.round_up_to_precision(self.milliseconds, self.precision)\n        return self\n\n    def round_down(self):\n        if self.milliseconds is None or self.precision is None:\n            return self\n        self.milliseconds = DateRangePrecision.round_down_to_precision(self.milliseconds, self.precision)\n        return self\n    _formatter_map = {DateRangePrecision.YEAR: '%Y', DateRangePrecision.MONTH: '%Y-%m', DateRangePrecision.DAY: '%Y-%m-%d', DateRangePrecision.HOUR: '%Y-%m-%dT%HZ', DateRangePrecision.MINUTE: '%Y-%m-%dT%H:%MZ', DateRangePrecision.SECOND: '%Y-%m-%dT%H:%M:%SZ', DateRangePrecision.MILLISECOND: '%Y-%m-%dT%H:%M:%S'}\n\n    def __str__(self):\n        if self == OPEN_BOUND:\n            return '*'\n        try:\n            dt = self.datetime()\n        except OverflowError:\n            return '%sms' % (self.milliseconds,)\n        formatted = dt.strftime(self._formatter_map[self.precision])\n        if self.precision == DateRangePrecision.MILLISECOND:\n            return '%s.%03dZ' % (formatted, dt.microsecond / 1000)\n        return formatted\n\n    def __repr__(self):\n        return '%s(milliseconds=%r, precision=%r)' % (self.__class__.__name__, self.milliseconds, self.precision)\nOPEN_BOUND = DateRangeBound(value=None, precision=None)\n'\\nRepresents `*`, an open value or bound for :class:`DateRange`.\\n'\n\n@total_ordering\nclass DateRange(object):\n    \"\"\"DateRange(lower_bound=None, upper_bound=None, value=None)\n    DSE DateRange Type\n\n    .. attribute:: lower_bound\n\n        :class:`~DateRangeBound` representing the lower bound of a bounded range.\n\n    .. attribute:: upper_bound\n\n        :class:`~DateRangeBound` representing the upper bound of a bounded range.\n\n    .. attribute:: value\n\n        :class:`~DateRangeBound` representing the value of a single-value range.\n\n    As noted in its documentation, :class:`DateRangeBound` uses a millisecond\n    offset from the UNIX epoch to allow :class:`DateRange` to represent values\n    `datetime.datetime` cannot. For such values, string representions will show\n    this offset rather than the CQL representation.\n    \"\"\"\n    lower_bound = None\n    upper_bound = None\n    value = None\n\n    def __init__(self, lower_bound=None, upper_bound=None, value=None):\n        \"\"\"\n        :param lower_bound: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as a\n            :attr:`lower_bound`. Mutually exclusive with `value`. If\n            `upper_bound` is specified and this is not, the :attr:`lower_bound`\n            will be open.\n        :param upper_bound: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as a\n            :attr:`upper_bound`. Mutually exclusive with `value`. If\n            `lower_bound` is specified and this is not, the :attr:`upper_bound`\n            will be open.\n        :param value: a :class:`DateRangeBound` or object accepted by\n            :meth:`DateRangeBound.from_value` to be used as :attr:`value`. Mutually\n            exclusive with `lower_bound` and `lower_bound`.\n        \"\"\"\n        lower_bound = DateRangeBound.from_value(lower_bound).round_down() if lower_bound else lower_bound\n        upper_bound = DateRangeBound.from_value(upper_bound).round_up() if upper_bound else upper_bound\n        value = DateRangeBound.from_value(value).round_down() if value else value\n        if lower_bound is None and upper_bound is not None:\n            lower_bound = OPEN_BOUND\n        if upper_bound is None and lower_bound is not None:\n            upper_bound = OPEN_BOUND\n        self.lower_bound, self.upper_bound, self.value = (lower_bound, upper_bound, value)\n        self.validate()\n\n    def validate(self):\n        if self.value is None:\n            if self.lower_bound is None or self.upper_bound is None:\n                raise ValueError('%s instances where value attribute is None must set lower_bound or upper_bound; got %r' % (self.__class__.__name__, self))\n        elif self.lower_bound is not None or self.upper_bound is not None:\n            raise ValueError('%s instances where value attribute is not None must not set lower_bound or upper_bound; got %r' % (self.__class__.__name__, self))\n\n    def __eq__(self, other):\n        if not isinstance(other, self.__class__):\n            return NotImplemented\n        return self.lower_bound == other.lower_bound and self.upper_bound == other.upper_bound and (self.value == other.value)\n\n    def __lt__(self, other):\n        return (str(self.lower_bound), str(self.upper_bound), str(self.value)) < (str(other.lower_bound), str(other.upper_bound), str(other.value))\n\n    def __str__(self):\n        if self.value:\n            return str(self.value)\n        else:\n            return '[%s TO %s]' % (self.lower_bound, self.upper_bound)\n\n    def __repr__(self):\n        return '%s(lower_bound=%r, upper_bound=%r, value=%r)' % (self.__class__.__name__, self.lower_bound, self.upper_bound, self.value)\n\n@total_ordering\nclass Version(object):\n    \"\"\"\n    Internal minimalist class to compare versions.\n    A valid version is: <int>.<int>.<int>.<int or str>.\n\n    TODO: when python2 support is removed, use packaging.version.\n    \"\"\"\n    _version = None\n    major = None\n    minor = 0\n    patch = 0\n    build = 0\n    prerelease = 0\n\n    def __init__(self, version):\n        self._version = version\n        if '-' in version:\n            version_without_prerelease, self.prerelease = version.split('-', 1)\n        else:\n            version_without_prerelease = version\n        parts = list(reversed(version_without_prerelease.split('.')))\n        if len(parts) > 4:\n            prerelease_string = '-{}'.format(self.prerelease) if self.prerelease else ''\n            log.warning('Unrecognized version: {}. Only 4 components plus prerelease are supported. Assuming version as {}{}'.format(version, '.'.join(parts[:-5:-1]), prerelease_string))\n        try:\n            self.major = int(parts.pop())\n        except ValueError as e:\n            raise ValueError(\"Couldn't parse version {}. Version should start with a number\".format(version)).with_traceback(e.__traceback__)\n        try:\n            self.minor = int(parts.pop()) if parts else 0\n            self.patch = int(parts.pop()) if parts else 0\n            if parts:\n                build = parts.pop()\n                try:\n                    self.build = int(build)\n                except ValueError:\n                    self.build = build\n        except ValueError:\n            assumed_version = '{}.{}.{}.{}-{}'.format(self.major, self.minor, self.patch, self.build, self.prerelease)\n            log.warning('Unrecognized version {}. Assuming version as {}'.format(version, assumed_version))\n\n    def __hash__(self):\n        return self._version\n\n    def __repr__(self):\n        version_string = 'Version({0}, {1}, {2}'.format(self.major, self.minor, self.patch)\n        if self.build:\n            version_string += ', {}'.format(self.build)\n        if self.prerelease:\n            version_string += ', {}'.format(self.prerelease)\n        version_string += ')'\n        return version_string\n\n    def __str__(self):\n        return self._version\n\n    @staticmethod\n    def _compare_version_part(version, other_version, cmp):\n        if not (isinstance(version, int) and isinstance(other_version, int)):\n            version = str(version)\n            other_version = str(other_version)\n        return cmp(version, other_version)\n\n    def __eq__(self, other):\n        if not isinstance(other, Version):\n            return NotImplemented\n        return self.major == other.major and self.minor == other.minor and (self.patch == other.patch) and self._compare_version_part(self.build, other.build, lambda s, o: s == o) and self._compare_version_part(self.prerelease, other.prerelease, lambda s, o: s == o)\n\n    def __gt__(self, other):\n        if not isinstance(other, Version):\n            return NotImplemented\n        is_major_ge = self.major >= other.major\n        is_minor_ge = self.minor >= other.minor\n        is_patch_ge = self.patch >= other.patch\n        is_build_gt = self._compare_version_part(self.build, other.build, lambda s, o: s > o)\n        is_build_ge = self._compare_version_part(self.build, other.build, lambda s, o: s >= o)\n        if self.prerelease and (not other.prerelease):\n            is_prerelease_gt = False\n        elif other.prerelease and (not self.prerelease):\n            is_prerelease_gt = True\n        else:\n            is_prerelease_gt = self._compare_version_part(self.prerelease, other.prerelease, lambda s, o: s > o)\n        return self.major > other.major or (is_major_ge and self.minor > other.minor) or (is_major_ge and is_minor_ge and (self.patch > other.patch)) or (is_major_ge and is_minor_ge and is_patch_ge and is_build_gt) or (is_major_ge and is_minor_ge and is_patch_ge and is_build_ge and is_prerelease_gt)",
    "cassandra/cqltypes.py": "\"\"\"\nRepresentation of Cassandra data types. These classes should make it simple for\nthe library (and caller software) to deal with Cassandra-style Java class type\nnames and CQL type specifiers, and convert between them cleanly. Parameterized\ntypes are fully supported in both flavors. Once you have the right Type object\nfor the type you want, you can use it to serialize, deserialize, or retrieve\nthe corresponding CQL or Cassandra type strings.\n\"\"\"\nfrom __future__ import absolute_import\nimport ast\nfrom binascii import unhexlify\nimport calendar\nfrom collections import namedtuple\nfrom decimal import Decimal\nimport io\nfrom itertools import chain\nimport logging\nimport re\nimport socket\nimport time\nimport struct\nimport sys\nfrom uuid import UUID\nfrom cassandra.marshal import int8_pack, int8_unpack, int16_pack, int16_unpack, uint16_pack, uint16_unpack, uint32_pack, uint32_unpack, int32_pack, int32_unpack, int64_pack, int64_unpack, float_pack, float_unpack, double_pack, double_unpack, varint_pack, varint_unpack, point_be, point_le, vints_pack, vints_unpack, uvint_unpack, uvint_pack\nfrom cassandra import util\n_little_endian_flag = 1\nimport ipaddress\napache_cassandra_type_prefix = 'org.apache.cassandra.db.marshal.'\ncassandra_empty_type = 'org.apache.cassandra.db.marshal.EmptyType'\ncql_empty_type = 'empty'\nlog = logging.getLogger(__name__)\n_number_types = frozenset((int, float))\n\ndef _name_from_hex_string(encoded_name):\n    bin_str = unhexlify(encoded_name)\n    return bin_str.decode('ascii')\n\ndef trim_if_startswith(s, prefix):\n    if s.startswith(prefix):\n        return s[len(prefix):]\n    return s\n_casstypes = {}\n_cqltypes = {}\ncql_type_scanner = re.Scanner((('frozen', None), ('[a-zA-Z0-9_]+', lambda s, t: t), ('[\\\\s,<>]', None)))\n\ndef cql_types_from_string(cql_type):\n    return cql_type_scanner.scan(cql_type)[0]\n\nclass CassandraTypeType(type):\n    \"\"\"\n    The CassandraType objects in this module will normally be used directly,\n    rather than through instances of those types. They can be instantiated,\n    of course, but the type information is what this driver mainly needs.\n\n    This metaclass registers CassandraType classes in the global\n    by-cassandra-typename and by-cql-typename registries, unless their class\n    name starts with an underscore.\n    \"\"\"\n\n    def __new__(metacls, name, bases, dct):\n        dct.setdefault('cassname', name)\n        cls = type.__new__(metacls, name, bases, dct)\n        if not name.startswith('_'):\n            _casstypes[name] = cls\n            if not cls.typename.startswith(apache_cassandra_type_prefix):\n                _cqltypes[cls.typename] = cls\n        return cls\ncasstype_scanner = re.Scanner((('[()]', lambda s, t: t), ('[a-zA-Z0-9_.:=>]+', lambda s, t: t), ('[\\\\s,]', None)))\n\ndef cqltype_to_python(cql_string):\n    \"\"\"\n    Given a cql type string, creates a list that can be manipulated in python\n    Example:\n        int -> ['int']\n        frozen<tuple<text, int>> -> ['frozen', ['tuple', ['text', 'int']]]\n    \"\"\"\n    scanner = re.Scanner((('[a-zA-Z0-9_]+', lambda s, t: \"'{}'\".format(t)), ('<', lambda s, t: ', ['), ('>', lambda s, t: ']'), ('[, ]', lambda s, t: t), ('\".*?\"', lambda s, t: \"'{}'\".format(t))))\n    scanned_tokens = scanner.scan(cql_string)[0]\n    hierarchy = ast.literal_eval(''.join(scanned_tokens))\n    return [hierarchy] if isinstance(hierarchy, str) else list(hierarchy)\n\ndef python_to_cqltype(types):\n    \"\"\"\n    Opposite of the `cql_to_python` function. Given a python list, creates a cql type string from the representation\n    Example:\n        ['int'] -> int\n        ['frozen', ['tuple', ['text', 'int']]] -> frozen<tuple<text, int>>\n    \"\"\"\n    scanner = re.Scanner(((\"'[a-zA-Z0-9_]+'\", lambda s, t: t[1:-1]), ('^\\\\[', lambda s, t: None), ('\\\\]$', lambda s, t: None), (',\\\\s*\\\\[', lambda s, t: '<'), ('\\\\]', lambda s, t: '>'), ('[, ]', lambda s, t: t), ('\\\\\\'\".*?\"\\\\\\'', lambda s, t: t[1:-1])))\n    scanned_tokens = scanner.scan(repr(types))[0]\n    cql = ''.join(scanned_tokens).replace('\\\\\\\\', '\\\\')\n    return cql\n\ndef _strip_frozen_from_python(types):\n    \"\"\"\n    Given a python list representing a cql type, removes 'frozen'\n    Example:\n        ['frozen', ['tuple', ['text', 'int']]] -> ['tuple', ['text', 'int']]\n    \"\"\"\n    while 'frozen' in types:\n        index = types.index('frozen')\n        types = types[:index] + types[index + 1] + types[index + 2:]\n    new_types = [_strip_frozen_from_python(item) if isinstance(item, list) else item for item in types]\n    return new_types\n\ndef strip_frozen(cql):\n    \"\"\"\n    Given a cql type string, and removes frozen\n    Example:\n        frozen<tuple<int>> -> tuple<int>\n    \"\"\"\n    types = cqltype_to_python(cql)\n    types_without_frozen = _strip_frozen_from_python(types)\n    cql = python_to_cqltype(types_without_frozen)\n    return cql\n\ndef lookup_casstype_simple(casstype):\n    \"\"\"\n    Given a Cassandra type name (either fully distinguished or not), hand\n    back the CassandraType class responsible for it. If a name is not\n    recognized, a custom _UnrecognizedType subclass will be created for it.\n\n    This function does not handle complex types (so no type parameters--\n    nothing with parentheses). Use lookup_casstype() instead if you might need\n    that.\n    \"\"\"\n    shortname = trim_if_startswith(casstype, apache_cassandra_type_prefix)\n    try:\n        typeclass = _casstypes[shortname]\n    except KeyError:\n        typeclass = mkUnrecognizedType(casstype)\n    return typeclass\n\ndef parse_casstype_args(typestring):\n    tokens, remainder = casstype_scanner.scan(typestring)\n    if remainder:\n        raise ValueError('weird characters %r at end' % remainder)\n    args = [([], [])]\n    for tok in tokens:\n        if tok == '(':\n            args.append(([], []))\n        elif tok == ')':\n            types, names = args.pop()\n            prev_types, prev_names = args[-1]\n            prev_types[-1] = prev_types[-1].apply_parameters(types, names)\n        else:\n            types, names = args[-1]\n            parts = re.split(':|=>', tok)\n            tok = parts.pop()\n            if parts:\n                names.append(parts[0])\n            else:\n                names.append(None)\n            try:\n                ctype = int(tok)\n            except ValueError:\n                ctype = lookup_casstype_simple(tok)\n            types.append(ctype)\n    return args[0][0][0]\n\ndef is_reversed_casstype(data_type):\n    return issubclass(data_type, ReversedType)\n\nclass EmptyValue(object):\n    \"\"\" See _CassandraType.support_empty_values \"\"\"\n\n    def __str__(self):\n        return 'EMPTY'\n    __repr__ = __str__\nEMPTY = EmptyValue()\n\nclass _CassandraType(object, metaclass=CassandraTypeType):\n    subtypes = ()\n    num_subtypes = 0\n    empty_binary_ok = False\n    support_empty_values = False\n    '\\n    Back in the Thrift days, empty strings were used for \"null\" values of\\n    all types, including non-string types.  For most users, an empty\\n    string value in an int column is the same as being null/not present,\\n    so the driver normally returns None in this case.  (For string-like\\n    types, it *will* return an empty string by default instead of None.)\\n\\n    To avoid this behavior, set this to :const:`True`. Instead of returning\\n    None for empty string values, the EMPTY singleton (an instance\\n    of EmptyValue) will be returned.\\n    '\n\n    def __repr__(self):\n        return '<%s>' % self.cql_parameterized_type()\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        \"\"\"\n        Given a bytestring, deserialize into a value according to the protocol\n        for this type. Note that this does not create a new instance of this\n        class; it merely gives back a value that would be appropriate to go\n        inside an instance of this class.\n        \"\"\"\n        return byts\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        \"\"\"\n        Given a value appropriate for this class, serialize it according to the\n        protocol for this type and return the corresponding bytestring.\n        \"\"\"\n        return val\n\n    @classmethod\n    def cass_parameterized_type_with(cls, subtypes, full=False):\n        \"\"\"\n        Return the name of this type as it would be expressed by Cassandra,\n        optionally fully qualified. If subtypes is not None, it is expected\n        to be a list of other CassandraType subclasses, and the output\n        string includes the Cassandra names for those subclasses as well,\n        as parameters to this one.\n\n        Example:\n\n            >>> LongType.cass_parameterized_type_with(())\n            'LongType'\n            >>> LongType.cass_parameterized_type_with((), full=True)\n            'org.apache.cassandra.db.marshal.LongType'\n            >>> SetType.cass_parameterized_type_with([DecimalType], full=True)\n            'org.apache.cassandra.db.marshal.SetType(org.apache.cassandra.db.marshal.DecimalType)'\n        \"\"\"\n        cname = cls.cassname\n        if full and '.' not in cname:\n            cname = apache_cassandra_type_prefix + cname\n        if not subtypes:\n            return cname\n        sublist = ', '.join((styp.cass_parameterized_type(full=full) for styp in subtypes))\n        return '%s(%s)' % (cname, sublist)\n\n    @classmethod\n    def apply_parameters(cls, subtypes, names=None):\n        \"\"\"\n        Given a set of other CassandraTypes, create a new subtype of this type\n        using them as parameters. This is how composite types are constructed.\n\n            >>> MapType.apply_parameters([DateType, BooleanType])\n            <class 'cassandra.cqltypes.MapType(DateType, BooleanType)'>\n\n        `subtypes` will be a sequence of CassandraTypes.  If provided, `names`\n        will be an equally long sequence of column names or Nones.\n        \"\"\"\n        if cls.num_subtypes != 'UNKNOWN' and len(subtypes) != cls.num_subtypes:\n            raise ValueError('%s types require %d subtypes (%d given)' % (cls.typename, cls.num_subtypes, len(subtypes)))\n        newname = cls.cass_parameterized_type_with(subtypes)\n        return type(newname, (cls,), {'subtypes': subtypes, 'cassname': cls.cassname, 'fieldnames': names})\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        \"\"\"\n        Return a CQL type specifier for this type. If this type has parameters,\n        they are included in standard CQL <> notation.\n        \"\"\"\n        if not cls.subtypes:\n            return cls.typename\n        return '%s<%s>' % (cls.typename, ', '.join((styp.cql_parameterized_type() for styp in cls.subtypes)))\n\n    @classmethod\n    def cass_parameterized_type(cls, full=False):\n        \"\"\"\n        Return a Cassandra type specifier for this type. If this type has\n        parameters, they are included in the standard () notation.\n        \"\"\"\n        return cls.cass_parameterized_type_with(cls.subtypes, full=full)\n\n    @classmethod\n    def serial_size(cls):\n        return None\nCassandraType = _CassandraType\n\nclass _UnrecognizedType(_CassandraType):\n    num_subtypes = 'UNKNOWN'\n\ndef mkUnrecognizedType(casstypename):\n    return CassandraTypeType(casstypename, (_UnrecognizedType,), {'typename': \"'%s'\" % casstypename})\n\nclass BytesType(_CassandraType):\n    typename = 'blob'\n    empty_binary_ok = True\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        return bytes(val)\n\nclass DecimalType(_CassandraType):\n    typename = 'decimal'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        scale = int32_unpack(byts[:4])\n        unscaled = varint_unpack(byts[4:])\n        return Decimal('%de%d' % (unscaled, -scale))\n\n    @staticmethod\n    def serialize(dec, protocol_version):\n        try:\n            sign, digits, exponent = dec.as_tuple()\n        except AttributeError:\n            try:\n                sign, digits, exponent = Decimal(dec).as_tuple()\n            except Exception:\n                raise TypeError('Invalid type for Decimal value: %r', dec)\n        unscaled = int(''.join([str(digit) for digit in digits]))\n        if sign:\n            unscaled *= -1\n        scale = int32_pack(-exponent)\n        unscaled = varint_pack(unscaled)\n        return scale + unscaled\n\nclass UUIDType(_CassandraType):\n    typename = 'uuid'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return UUID(bytes=byts)\n\n    @staticmethod\n    def serialize(uuid, protocol_version):\n        try:\n            return uuid.bytes\n        except AttributeError:\n            raise TypeError('Got a non-UUID object for a UUID value')\n\n    @classmethod\n    def serial_size(cls):\n        return 16\n\nclass BooleanType(_CassandraType):\n    typename = 'boolean'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return bool(int8_unpack(byts))\n\n    @staticmethod\n    def serialize(truth, protocol_version):\n        return int8_pack(truth)\n\n    @classmethod\n    def serial_size(cls):\n        return 1\n\nclass ByteType(_CassandraType):\n    typename = 'tinyint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int8_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int8_pack(byts)\n\nclass AsciiType(_CassandraType):\n    typename = 'ascii'\n    empty_binary_ok = True\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return byts.decode('ascii')\n\n    @staticmethod\n    def serialize(var, protocol_version):\n        try:\n            return var.encode('ascii')\n        except UnicodeDecodeError:\n            return var\n\nclass FloatType(_CassandraType):\n    typename = 'float'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return float_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return float_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 4\n\nclass DoubleType(_CassandraType):\n    typename = 'double'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return double_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return double_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass LongType(_CassandraType):\n    typename = 'bigint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int64_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int64_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass Int32Type(_CassandraType):\n    typename = 'int'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int32_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int32_pack(byts)\n\n    @classmethod\n    def serial_size(cls):\n        return 4\n\nclass IntegerType(_CassandraType):\n    typename = 'varint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return varint_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return varint_pack(byts)\n\nclass InetAddressType(_CassandraType):\n    typename = 'inet'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        if len(byts) == 16:\n            return util.inet_ntop(socket.AF_INET6, byts)\n        else:\n            return socket.inet_ntoa(byts)\n\n    @staticmethod\n    def serialize(addr, protocol_version):\n        try:\n            if ':' in addr:\n                return util.inet_pton(socket.AF_INET6, addr)\n            else:\n                return socket.inet_aton(addr)\n        except:\n            if isinstance(addr, (ipaddress.IPv4Address, ipaddress.IPv6Address)):\n                return addr.packed\n            raise ValueError(\"can't interpret %r as an inet address\" % (addr,))\n\nclass CounterColumnType(LongType):\n    typename = 'counter'\ncql_timestamp_formats = ('%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%dT%H:%M', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%d')\n_have_warned_about_timestamps = False\n\nclass DateType(_CassandraType):\n    typename = 'timestamp'\n\n    @staticmethod\n    def interpret_datestring(val):\n        if val[-5] in ('+', '-'):\n            offset = (int(val[-4:-2]) * 3600 + int(val[-2:]) * 60) * int(val[-5] + '1')\n            val = val[:-5]\n        else:\n            offset = -time.timezone\n        for tformat in cql_timestamp_formats:\n            try:\n                tval = time.strptime(val, tformat)\n            except ValueError:\n                continue\n            return (calendar.timegm(tval) + offset) * 1000.0\n        else:\n            raise ValueError(\"can't interpret %r as a date\" % (val,))\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        timestamp = int64_unpack(byts) / 1000.0\n        return util.datetime_from_timestamp(timestamp)\n\n    @staticmethod\n    def serialize(v, protocol_version):\n        try:\n            timestamp_seconds = calendar.timegm(v.utctimetuple())\n            timestamp = timestamp_seconds * 1000.0 + getattr(v, 'microsecond', 0) / 1000.0\n        except AttributeError:\n            try:\n                timestamp = calendar.timegm(v.timetuple()) * 1000.0\n            except AttributeError:\n                if type(v) not in _number_types:\n                    raise TypeError('DateType arguments must be a datetime, date, or timestamp')\n                timestamp = v\n        return int64_pack(int(timestamp))\n\n    @classmethod\n    def serial_size(cls):\n        return 8\n\nclass TimestampType(DateType):\n    pass\n\nclass TimeUUIDType(DateType):\n    typename = 'timeuuid'\n\n    def my_timestamp(self):\n        return util.unix_time_from_uuid1(self.val)\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return UUID(bytes=byts)\n\n    @staticmethod\n    def serialize(timeuuid, protocol_version):\n        try:\n            return timeuuid.bytes\n        except AttributeError:\n            raise TypeError('Got a non-UUID object for a UUID value')\n\n    @classmethod\n    def serial_size(cls):\n        return 16\n\nclass SimpleDateType(_CassandraType):\n    typename = 'date'\n    date_format = '%Y-%m-%d'\n    EPOCH_OFFSET_DAYS = 2 ** 31\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        days = uint32_unpack(byts) - SimpleDateType.EPOCH_OFFSET_DAYS\n        return util.Date(days)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        try:\n            days = val.days_from_epoch\n        except AttributeError:\n            if isinstance(val, int):\n                return uint32_pack(val)\n            days = util.Date(val).days_from_epoch\n        return uint32_pack(days + SimpleDateType.EPOCH_OFFSET_DAYS)\n\nclass ShortType(_CassandraType):\n    typename = 'smallint'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return int16_unpack(byts)\n\n    @staticmethod\n    def serialize(byts, protocol_version):\n        return int16_pack(byts)\n\nclass TimeType(_CassandraType):\n    typename = 'time'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return util.Time(int64_unpack(byts))\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        try:\n            nano = val.nanosecond_time\n        except AttributeError:\n            nano = util.Time(val).nanosecond_time\n        return int64_pack(nano)\n\nclass DurationType(_CassandraType):\n    typename = 'duration'\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        months, days, nanoseconds = vints_unpack(byts)\n        return util.Duration(months, days, nanoseconds)\n\n    @staticmethod\n    def serialize(duration, protocol_version):\n        try:\n            m, d, n = (duration.months, duration.days, duration.nanoseconds)\n        except AttributeError:\n            raise TypeError('DurationType arguments must be a Duration.')\n        return vints_pack([m, d, n])\n\nclass UTF8Type(_CassandraType):\n    typename = 'text'\n    empty_binary_ok = True\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        return byts.decode('utf8')\n\n    @staticmethod\n    def serialize(ustr, protocol_version):\n        try:\n            return ustr.encode('utf-8')\n        except UnicodeDecodeError:\n            return ustr\n\nclass VarcharType(UTF8Type):\n    typename = 'varchar'\n\nclass _ParameterizedType(_CassandraType):\n    num_subtypes = 'UNKNOWN'\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't deserialize unparameterized %s\" % cls.typename)\n        return cls.deserialize_safe(byts, protocol_version)\n\n    @classmethod\n    def serialize(cls, val, protocol_version):\n        if not cls.subtypes:\n            raise NotImplementedError(\"can't serialize unparameterized %s\" % cls.typename)\n        return cls.serialize_safe(val, protocol_version)\n\nclass _SimpleParameterizedType(_ParameterizedType):\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        if protocol_version >= 3:\n            unpack = int32_unpack\n            length = 4\n        else:\n            unpack = uint16_unpack\n            length = 2\n        numelements = unpack(byts[:length])\n        p = length\n        result = []\n        inner_proto = max(3, protocol_version)\n        for _ in range(numelements):\n            itemlen = unpack(byts[p:p + length])\n            p += length\n            if itemlen < 0:\n                result.append(None)\n            else:\n                item = byts[p:p + itemlen]\n                p += itemlen\n                result.append(subtype.from_binary(item, inner_proto))\n        return cls.adapter(result)\n\n    @classmethod\n    def serialize_safe(cls, items, protocol_version):\n        if isinstance(items, str):\n            raise TypeError('Received a string for a type that expects a sequence')\n        subtype, = cls.subtypes\n        pack = int32_pack if protocol_version >= 3 else uint16_pack\n        buf = io.BytesIO()\n        buf.write(pack(len(items)))\n        inner_proto = max(3, protocol_version)\n        for item in items:\n            itembytes = subtype.to_binary(item, inner_proto)\n            buf.write(pack(len(itembytes)))\n            buf.write(itembytes)\n        return buf.getvalue()\n\nclass ListType(_SimpleParameterizedType):\n    typename = 'list'\n    num_subtypes = 1\n    adapter = list\n\nclass SetType(_SimpleParameterizedType):\n    typename = 'set'\n    num_subtypes = 1\n    adapter = util.sortedset\n\nclass MapType(_ParameterizedType):\n    typename = 'map'\n    num_subtypes = 2\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        key_type, value_type = cls.subtypes\n        if protocol_version >= 3:\n            unpack = int32_unpack\n            length = 4\n        else:\n            unpack = uint16_unpack\n            length = 2\n        numelements = unpack(byts[:length])\n        p = length\n        themap = util.OrderedMapSerializedKey(key_type, protocol_version)\n        inner_proto = max(3, protocol_version)\n        for _ in range(numelements):\n            key_len = unpack(byts[p:p + length])\n            p += length\n            if key_len < 0:\n                keybytes = None\n                key = None\n            else:\n                keybytes = byts[p:p + key_len]\n                p += key_len\n                key = key_type.from_binary(keybytes, inner_proto)\n            val_len = unpack(byts[p:p + length])\n            p += length\n            if val_len < 0:\n                val = None\n            else:\n                valbytes = byts[p:p + val_len]\n                p += val_len\n                val = value_type.from_binary(valbytes, inner_proto)\n            themap._insert_unchecked(key, keybytes, val)\n        return themap\n\n    @classmethod\n    def serialize_safe(cls, themap, protocol_version):\n        key_type, value_type = cls.subtypes\n        pack = int32_pack if protocol_version >= 3 else uint16_pack\n        buf = io.BytesIO()\n        buf.write(pack(len(themap)))\n        try:\n            items = themap.items()\n        except AttributeError:\n            raise TypeError('Got a non-map object for a map value')\n        inner_proto = max(3, protocol_version)\n        for key, val in items:\n            keybytes = key_type.to_binary(key, inner_proto)\n            valbytes = value_type.to_binary(val, inner_proto)\n            buf.write(pack(len(keybytes)))\n            buf.write(keybytes)\n            buf.write(pack(len(valbytes)))\n            buf.write(valbytes)\n        return buf.getvalue()\n\nclass TupleType(_ParameterizedType):\n    typename = 'tuple'\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        proto_version = max(3, protocol_version)\n        p = 0\n        values = []\n        for col_type in cls.subtypes:\n            if p == len(byts):\n                break\n            itemlen = int32_unpack(byts[p:p + 4])\n            p += 4\n            if itemlen >= 0:\n                item = byts[p:p + itemlen]\n                p += itemlen\n            else:\n                item = None\n            values.append(col_type.from_binary(item, proto_version))\n        if len(values) < len(cls.subtypes):\n            nones = [None] * (len(cls.subtypes) - len(values))\n            values = values + nones\n        return tuple(values)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        if len(val) > len(cls.subtypes):\n            raise ValueError('Expected %d items in a tuple, but got %d: %s' % (len(cls.subtypes), len(val), val))\n        proto_version = max(3, protocol_version)\n        buf = io.BytesIO()\n        for item, subtype in zip(val, cls.subtypes):\n            if item is not None:\n                packed_item = subtype.to_binary(item, proto_version)\n                buf.write(int32_pack(len(packed_item)))\n                buf.write(packed_item)\n            else:\n                buf.write(int32_pack(-1))\n        return buf.getvalue()\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        subtypes_string = ', '.join((sub.cql_parameterized_type() for sub in cls.subtypes))\n        return 'frozen<tuple<%s>>' % (subtypes_string,)\n\nclass UserType(TupleType):\n    typename = 'org.apache.cassandra.db.marshal.UserType'\n    _cache = {}\n    _module = sys.modules[__name__]\n\n    @classmethod\n    def make_udt_class(cls, keyspace, udt_name, field_names, field_types):\n        assert len(field_names) == len(field_types)\n        instance = cls._cache.get((keyspace, udt_name))\n        if not instance or instance.fieldnames != field_names or instance.subtypes != field_types:\n            instance = type(udt_name, (cls,), {'subtypes': field_types, 'cassname': cls.cassname, 'typename': udt_name, 'fieldnames': field_names, 'keyspace': keyspace, 'mapped_class': None, 'tuple_type': cls._make_registered_udt_namedtuple(keyspace, udt_name, field_names)})\n            cls._cache[keyspace, udt_name] = instance\n        return instance\n\n    @classmethod\n    def evict_udt_class(cls, keyspace, udt_name):\n        try:\n            del cls._cache[keyspace, udt_name]\n        except KeyError:\n            pass\n\n    @classmethod\n    def apply_parameters(cls, subtypes, names):\n        keyspace = subtypes[0].cass_parameterized_type()\n        udt_name = _name_from_hex_string(subtypes[1].cassname)\n        field_names = tuple((_name_from_hex_string(encoded_name) for encoded_name in names[2:]))\n        return cls.make_udt_class(keyspace, udt_name, field_names, tuple(subtypes[2:]))\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        return 'frozen<%s>' % (cls.typename,)\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        values = super(UserType, cls).deserialize_safe(byts, protocol_version)\n        if cls.mapped_class:\n            return cls.mapped_class(**dict(zip(cls.fieldnames, values)))\n        elif cls.tuple_type:\n            return cls.tuple_type(*values)\n        else:\n            return tuple(values)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        proto_version = max(3, protocol_version)\n        buf = io.BytesIO()\n        for i, (fieldname, subtype) in enumerate(zip(cls.fieldnames, cls.subtypes)):\n            try:\n                item = val[i]\n            except TypeError:\n                item = getattr(val, fieldname, None)\n                if item is None and (not hasattr(val, fieldname)):\n                    log.warning(f'field {fieldname} is part of the UDT {cls.typename} but is not present in the value {val}')\n            if item is not None:\n                packed_item = subtype.to_binary(item, proto_version)\n                buf.write(int32_pack(len(packed_item)))\n                buf.write(packed_item)\n            else:\n                buf.write(int32_pack(-1))\n        return buf.getvalue()\n\n    @classmethod\n    def _make_registered_udt_namedtuple(cls, keyspace, name, field_names):\n        t = cls._make_udt_tuple_type(name, field_names)\n        if t:\n            qualified_name = '%s_%s' % (keyspace, name)\n            setattr(cls._module, qualified_name, t)\n        return t\n\n    @classmethod\n    def _make_udt_tuple_type(cls, name, field_names):\n        try:\n            t = namedtuple(name, field_names)\n        except ValueError:\n            try:\n                t = namedtuple(name, util._positional_rename_invalid_identifiers(field_names))\n                log.warning(\"could not create a namedtuple for '%s' because one or more field names are not valid Python identifiers (%s); returning positionally-named fields\" % (name, field_names))\n            except ValueError:\n                t = None\n                log.warning(\"could not create a namedtuple for '%s' because the name is not a valid Python identifier; will return tuples in its place\" % (name,))\n        return t\n\nclass CompositeType(_ParameterizedType):\n    typename = 'org.apache.cassandra.db.marshal.CompositeType'\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        \"\"\"\n        There is no CQL notation for Composites, so we override this.\n        \"\"\"\n        typestring = cls.cass_parameterized_type(full=True)\n        return \"'%s'\" % (typestring,)\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        result = []\n        for subtype in cls.subtypes:\n            if not byts:\n                break\n            element_length = uint16_unpack(byts[:2])\n            element = byts[2:2 + element_length]\n            byts = byts[2 + element_length + 1:]\n            result.append(subtype.from_binary(element, protocol_version))\n        return tuple(result)\n\nclass DynamicCompositeType(_ParameterizedType):\n    typename = 'org.apache.cassandra.db.marshal.DynamicCompositeType'\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        sublist = ', '.join(('%s=>%s' % (alias, typ.cass_parameterized_type(full=True)) for alias, typ in zip(cls.fieldnames, cls.subtypes)))\n        return \"'%s(%s)'\" % (cls.typename, sublist)\n\nclass ColumnToCollectionType(_ParameterizedType):\n    \"\"\"\n    This class only really exists so that we can cleanly evaluate types when\n    Cassandra includes this. We don't actually need or want the extra\n    information.\n    \"\"\"\n    typename = 'org.apache.cassandra.db.marshal.ColumnToCollectionType'\n\nclass ReversedType(_ParameterizedType):\n    typename = 'org.apache.cassandra.db.marshal.ReversedType'\n    num_subtypes = 1\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.from_binary(byts, protocol_version)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.to_binary(val, protocol_version)\n\nclass FrozenType(_ParameterizedType):\n    typename = 'frozen'\n    num_subtypes = 1\n\n    @classmethod\n    def deserialize_safe(cls, byts, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.from_binary(byts, protocol_version)\n\n    @classmethod\n    def serialize_safe(cls, val, protocol_version):\n        subtype, = cls.subtypes\n        return subtype.to_binary(val, protocol_version)\n\ndef is_counter_type(t):\n    if isinstance(t, str):\n        t = lookup_casstype(t)\n    return issubclass(t, CounterColumnType)\n\ndef cql_typename(casstypename):\n    \"\"\"\n    Translate a Cassandra-style type specifier (optionally-fully-distinguished\n    Java class names for data types, along with optional parameters) into a\n    CQL-style type specifier.\n\n        >>> cql_typename('DateType')\n        'timestamp'\n        >>> cql_typename('org.apache.cassandra.db.marshal.ListType(IntegerType)')\n        'list<varint>'\n    \"\"\"\n    return lookup_casstype(casstypename).cql_parameterized_type()\n\nclass WKBGeometryType(object):\n    POINT = 1\n    LINESTRING = 2\n    POLYGON = 3\n\nclass PointType(CassandraType):\n    typename = 'PointType'\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.POINT)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        return PointType._type + point_le.pack(val.x, val.y)\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        point = point_le if is_little_endian else point_be\n        return util.Point(*point.unpack_from(byts, 5))\n\nclass LineStringType(CassandraType):\n    typename = 'LineStringType'\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.LINESTRING)\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        num_points = len(val.coords)\n        return LineStringType._type + struct.pack('<I' + 'dd' * num_points, num_points, *(d for coords in val.coords for d in coords))\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        point = point_le if is_little_endian else point_be\n        coords = (point.unpack_from(byts, offset) for offset in range(1 + 4 + 4, len(byts), point.size))\n        return util.LineString(coords)\n\nclass PolygonType(CassandraType):\n    typename = 'PolygonType'\n    _type = struct.pack('<BI', _little_endian_flag, WKBGeometryType.POLYGON)\n    _ring_count = struct.Struct('<I').pack\n\n    @staticmethod\n    def serialize(val, protocol_version):\n        buf = io.BytesIO(PolygonType._type)\n        buf.seek(0, 2)\n        if val.exterior.coords:\n            num_rings = 1 + len(val.interiors)\n            buf.write(PolygonType._ring_count(num_rings))\n            for ring in chain((val.exterior,), val.interiors):\n                num_points = len(ring.coords)\n                buf.write(struct.pack('<I' + 'dd' * num_points, num_points, *(d for coord in ring.coords for d in coord)))\n        else:\n            buf.write(PolygonType._ring_count(0))\n        return buf.getvalue()\n\n    @staticmethod\n    def deserialize(byts, protocol_version):\n        is_little_endian = bool(byts[0])\n        if is_little_endian:\n            int_fmt = '<i'\n            point = point_le\n        else:\n            int_fmt = '>i'\n            point = point_be\n        p = 5\n        ring_count = struct.unpack_from(int_fmt, byts, p)[0]\n        p += 4\n        rings = []\n        for _ in range(ring_count):\n            point_count = struct.unpack_from(int_fmt, byts, p)[0]\n            p += 4\n            end = p + point_count * point.size\n            rings.append([point.unpack_from(byts, offset) for offset in range(p, end, point.size)])\n            p = end\n        return util.Polygon(exterior=rings[0], interiors=rings[1:]) if rings else util.Polygon()\n\nclass BoundKind(object):\n    \"\"\"\n    \"Enum\" representing the 6 possible DateRangeTypes\n    \"\"\"\n    SINGLE_DATE = 'SINGLE_DATE'\n    CLOSED_RANGE = 'CLOSED_RANGE'\n    OPEN_RANGE_HIGH = 'OPEN_RANGE_HIGH'\n    OPEN_RANGE_LOW = 'OPEN_RANGE_LOW'\n    BOTH_OPEN_RANGE = 'BOTH_OPEN_RANGE'\n    SINGLE_DATE_OPEN = 'SINGLE_DATE_OPEN'\n    VALID_RANGE_BOUNDS = (SINGLE_DATE, CLOSED_RANGE, OPEN_RANGE_HIGH, OPEN_RANGE_LOW, BOTH_OPEN_RANGE, SINGLE_DATE_OPEN)\n    _bound_str_to_int_map = {'SINGLE_DATE': 0, 'CLOSED_RANGE': 1, 'OPEN_RANGE_HIGH': 2, 'OPEN_RANGE_LOW': 3, 'BOTH_OPEN_RANGE': 4, 'SINGLE_DATE_OPEN': 5}\n    _bound_int_to_str_map = {i: s for i, s in _bound_str_to_int_map.items()}\n\n    @classmethod\n    def to_int(cls, bound_str):\n        \"\"\"\n        Encode a string as an int for serialization.\n        \"\"\"\n        return cls._bound_str_to_int_map[bound_str.upper()]\n\n    @classmethod\n    def to_str(cls, bound_int):\n        \"\"\"\n        Decode an int to a string for deserialization.\n        \"\"\"\n        return cls._bound_int_to_str_map[bound_int.upper()]\n\nclass DateRangeType(CassandraType):\n    typename = 'daterange'\n    _precision_str_to_int_map = {'YEAR': 0, 'MONTH': 1, 'DAY': 2, 'HOUR': 3, 'MINUTE': 4, 'SECOND': 5, 'MILLISECOND': 6}\n    _precision_int_to_str_map = {s: i for i, s in _precision_str_to_int_map.items()}\n\n    @classmethod\n    def _encode_precision(cls, precision_str):\n        normalized_str = precision_str.upper()\n        if normalized_str not in cls._precision_str_to_int_map:\n            raise ValueError('%s is not a valid DateRange precision string. Valid values: %s' % (repr(precision_str), ', '.join(list(cls._precision_str_to_int_map))))\n        return cls._precision_str_to_int_map[normalized_str]\n\n    @classmethod\n    def _decode_precision(cls, precision_int):\n        if precision_int not in cls._precision_int_to_str_map:\n            raise ValueError('%s not a valid DateRange precision int. Valid values: %s' % (precision_int, ', '.join([str(i) for i in cls._precision_int_to_str_map])))\n        return cls._precision_int_to_str_map[precision_int]\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        type_ = int8_unpack(byts[0:1])\n        if type_ in (BoundKind.to_int(BoundKind.BOTH_OPEN_RANGE), BoundKind.to_int(BoundKind.SINGLE_DATE_OPEN)):\n            time0 = precision0 = None\n        else:\n            time0 = int64_unpack(byts[1:9])\n            precision0 = int8_unpack(byts[9:10])\n        if type_ == BoundKind.to_int(BoundKind.CLOSED_RANGE):\n            time1 = int64_unpack(byts[10:18])\n            precision1 = int8_unpack(byts[18:19])\n        else:\n            time1 = precision1 = None\n        if time0 is not None:\n            date_range_bound0 = util.DateRangeBound(time0, cls._decode_precision(precision0))\n        if time1 is not None:\n            date_range_bound1 = util.DateRangeBound(time1, cls._decode_precision(precision1))\n        if type_ == BoundKind.to_int(BoundKind.SINGLE_DATE):\n            return util.DateRange(value=date_range_bound0)\n        if type_ == BoundKind.to_int(BoundKind.CLOSED_RANGE):\n            return util.DateRange(lower_bound=date_range_bound0, upper_bound=date_range_bound1)\n        if type_ == BoundKind.to_int(BoundKind.OPEN_RANGE_HIGH):\n            return util.DateRange(lower_bound=date_range_bound0, upper_bound=util.OPEN_BOUND)\n        if type_ == BoundKind.to_int(BoundKind.OPEN_RANGE_LOW):\n            return util.DateRange(lower_bound=util.OPEN_BOUND, upper_bound=date_range_bound0)\n        if type_ == BoundKind.to_int(BoundKind.BOTH_OPEN_RANGE):\n            return util.DateRange(lower_bound=util.OPEN_BOUND, upper_bound=util.OPEN_BOUND)\n        if type_ == BoundKind.to_int(BoundKind.SINGLE_DATE_OPEN):\n            return util.DateRange(value=util.OPEN_BOUND)\n        raise ValueError('Could not deserialize %r' % (byts,))\n\n    @classmethod\n    def serialize(cls, v, protocol_version):\n        buf = io.BytesIO()\n        bound_kind, bounds = (None, ())\n        try:\n            value = v.value\n        except AttributeError:\n            raise ValueError('%s.serialize expects an object with a value attribute; got%r' % (cls.__name__, v))\n        if value is None:\n            try:\n                lower_bound, upper_bound = (v.lower_bound, v.upper_bound)\n            except AttributeError:\n                raise ValueError('%s.serialize expects an object with lower_bound and upper_bound attributes; got %r' % (cls.__name__, v))\n            if lower_bound == util.OPEN_BOUND and upper_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.BOTH_OPEN_RANGE\n            elif lower_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.OPEN_RANGE_LOW\n                bounds = (upper_bound,)\n            elif upper_bound == util.OPEN_BOUND:\n                bound_kind = BoundKind.OPEN_RANGE_HIGH\n                bounds = (lower_bound,)\n            else:\n                bound_kind = BoundKind.CLOSED_RANGE\n                bounds = (lower_bound, upper_bound)\n        elif value == util.OPEN_BOUND:\n            bound_kind = BoundKind.SINGLE_DATE_OPEN\n        else:\n            bound_kind = BoundKind.SINGLE_DATE\n            bounds = (value,)\n        if bound_kind is None:\n            raise ValueError('Cannot serialize %r; could not find bound kind' % (v,))\n        buf.write(int8_pack(BoundKind.to_int(bound_kind)))\n        for bound in bounds:\n            buf.write(int64_pack(bound.milliseconds))\n            buf.write(int8_pack(cls._encode_precision(bound.precision)))\n        return buf.getvalue()\n\nclass VectorType(_CassandraType):\n    typename = 'org.apache.cassandra.db.marshal.VectorType'\n    vector_size = 0\n    subtype = None\n\n    @classmethod\n    def serial_size(cls):\n        serialized_size = cls.subtype.serial_size()\n        return cls.vector_size * serialized_size if serialized_size is not None else None\n\n    @classmethod\n    def apply_parameters(cls, params, names):\n        assert len(params) == 2\n        subtype = lookup_casstype(params[0])\n        vsize = params[1]\n        return type('%s(%s)' % (cls.cass_parameterized_type_with([]), vsize), (cls,), {'vector_size': vsize, 'subtype': subtype})\n\n    @classmethod\n    def deserialize(cls, byts, protocol_version):\n        serialized_size = cls.subtype.serial_size()\n        if serialized_size is not None:\n            expected_byte_size = serialized_size * cls.vector_size\n            if len(byts) != expected_byte_size:\n                raise ValueError('Expected vector of type {0} and dimension {1} to have serialized size {2}; observed serialized size of {3} instead'.format(cls.subtype.typename, cls.vector_size, expected_byte_size, len(byts)))\n            indexes = (serialized_size * x for x in range(0, cls.vector_size))\n            return [cls.subtype.deserialize(byts[idx:idx + serialized_size], protocol_version) for idx in indexes]\n        idx = 0\n        rv = []\n        while len(rv) < cls.vector_size:\n            try:\n                size, bytes_read = uvint_unpack(byts[idx:])\n                idx += bytes_read\n                rv.append(cls.subtype.deserialize(byts[idx:idx + size], protocol_version))\n                idx += size\n            except:\n                raise ValueError('Error reading additional data during vector deserialization after successfully adding {} elements'.format(len(rv)))\n        if idx < len(byts):\n            raise ValueError('Additional bytes remaining after vector deserialization completed')\n        return rv\n\n    @classmethod\n    def serialize(cls, v, protocol_version):\n        v_length = len(v)\n        if cls.vector_size != v_length:\n            raise ValueError('Expected sequence of size {0} for vector of type {1} and dimension {0}, observed sequence of length {2}'.format(cls.vector_size, cls.subtype.typename, v_length))\n        serialized_size = cls.subtype.serial_size()\n        buf = io.BytesIO()\n        for item in v:\n            item_bytes = cls.subtype.serialize(item, protocol_version)\n            if serialized_size is None:\n                buf.write(uvint_pack(len(item_bytes)))\n            buf.write(item_bytes)\n        return buf.getvalue()\n\n    @classmethod\n    def cql_parameterized_type(cls):\n        return '%s<%s, %s>' % (cls.typename, cls.subtype.cql_parameterized_type(), cls.vector_size)",
    "cassandra/__init__.py": "import logging\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\nlogging.getLogger('cassandra').addHandler(NullHandler())\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n    ANY = 0\n    '\\n    Only requires that one replica receives the write *or* the coordinator\\n    stores a hint to replay later. Valid only for writes.\\n    '\n    ONE = 1\n    '\\n    Only one replica needs to respond to consider the operation a success\\n    '\n    TWO = 2\n    '\\n    Two replicas must respond to consider the operation a success\\n    '\n    THREE = 3\n    '\\n    Three replicas must respond to consider the operation a success\\n    '\n    QUORUM = 4\n    '\\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\\n    '\n    ALL = 5\n    '\\n    All replicas must respond to consider the operation a success\\n    '\n    LOCAL_QUORUM = 6\n    '\\n    Requires a quorum of replicas in the local datacenter\\n    '\n    EACH_QUORUM = 7\n    '\\n    Requires a quorum of replicas in each datacenter\\n    '\n    SERIAL = 8\n    \"\\n    For conditional inserts/updates that utilize Cassandra's lightweight\\n    transactions, this requires consensus among all replicas for the\\n    modified data.\\n    \"\n    LOCAL_SERIAL = 9\n    '\\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\\n    among replicas in the local datacenter.\\n    '\n    LOCAL_ONE = 10\n    '\\n    Sends a request only to replicas in the local datacenter and waits for\\n    one response.\\n    '\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\nConsistencyLevel.value_to_name = {ConsistencyLevel.ANY: 'ANY', ConsistencyLevel.ONE: 'ONE', ConsistencyLevel.TWO: 'TWO', ConsistencyLevel.THREE: 'THREE', ConsistencyLevel.QUORUM: 'QUORUM', ConsistencyLevel.ALL: 'ALL', ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM', ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM', ConsistencyLevel.SERIAL: 'SERIAL', ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL', ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'}\nConsistencyLevel.name_to_value = {'ANY': ConsistencyLevel.ANY, 'ONE': ConsistencyLevel.ONE, 'TWO': ConsistencyLevel.TWO, 'THREE': ConsistencyLevel.THREE, 'QUORUM': ConsistencyLevel.QUORUM, 'ALL': ConsistencyLevel.ALL, 'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM, 'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM, 'SERIAL': ConsistencyLevel.SERIAL, 'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL, 'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE}\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else 'Not Set'\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    '\\n    v1, supported in Cassandra 1.2-->2.2\\n    '\n    V2 = 2\n    '\\n    v2, supported in Cassandra 2.0-->2.2;\\n    added support for lightweight transactions, batch operations, and automatic query paging.\\n    '\n    V3 = 3\n    '\\n    v3, supported in Cassandra 2.1-->3.x+;\\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\\n    '\n    V4 = 4\n    '\\n    v4, supported in Cassandra 2.2-->3.x+;\\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\\n    '\n    V5 = 5\n    '\\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\\n    '\n    V6 = 6\n    '\\n    v6, in beta from 4.0-beta5\\n    '\n    DSE_V1 = 65\n    '\\n    DSE private protocol v1, supported in DSE 5.1+\\n    '\n    DSE_V2 = 66\n    '\\n    DSE private protocol v2, supported in DSE 6.0+\\n    '\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    '\\n    A tuple of all supported protocol versions\\n    '\n    BETA_VERSIONS = (V6,)\n    '\\n    A tuple of all beta protocol versions\\n    '\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    '\\n    Minimum protocol version supported by this driver.\\n    '\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    '\\n    Maximum protocol version supported by this driver.\\n    '\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next((v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if v not in ProtocolVersion.BETA_VERSIONS and v < previous_version))\n        except StopIteration:\n            version = 0\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n    SIMPLE = 0\n    '\\n    A write to a single partition key. Such writes are guaranteed to be atomic\\n    and isolated.\\n    '\n    BATCH = 1\n    '\\n    A write to multiple partition keys that used the distributed batch log to\\n    ensure atomicity.\\n    '\n    UNLOGGED_BATCH = 2\n    '\\n    A write to multiple partition keys that did not use the distributed batch\\n    log. Atomicity for such writes is not guaranteed.\\n    '\n    COUNTER = 3\n    '\\n    A counter write (for one or multiple partition keys). Such writes should\\n    not be replayed in order to avoid overcount.\\n    '\n    BATCH_LOG = 4\n    '\\n    The initial write to the distributed batch log that Cassandra performs\\n    internally before a BATCH write.\\n    '\n    CAS = 5\n    '\\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\\n    '\n    VIEW = 6\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete MV operations.\\n    '\n    CDC = 7\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete CDC operations.\\n    '\nWriteType.name_to_value = {'SIMPLE': WriteType.SIMPLE, 'BATCH': WriteType.BATCH, 'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH, 'COUNTER': WriteType.COUNTER, 'BATCH_LOG': WriteType.BATCH_LOG, 'CAS': WriteType.CAS, 'VIEW': WriteType.VIEW, 'CDC': WriteType.CDC}\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return '%s(%s)' % (name, ','.join((t for t in argument_types)))\n\n    def __repr__(self):\n        return '%s(%s, %s)' % (self.__class__.__name__, self.name, self.argument_types)\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the function\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the aggregate\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_replicas = None\n    ' The number of replicas that needed to be live to complete the operation '\n    alive_replicas = None\n    ' The number of replicas that were actually alive '\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' + repr({'consistency': consistency_value_to_name(consistency), 'required_replicas': required_replicas, 'alive_replicas': alive_replicas}))\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        if 'write_type' in kwargs:\n            kwargs['write_type'] = WriteType.value_to_name[kwargs['write_type']]\n        info = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses}\n        info.update(kwargs)\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs['write_type'] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n    failures = None\n    '\\n    The number of replicas that sent a failure message\\n    '\n    error_code_map = None\n    '\\n    A map of inet addresses to error codes representing replicas that sent\\n    a failure message.  Only set when `protocol_version` is 5 or higher.\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n        info_dict = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses, 'failures': failures}\n        if error_code_map is not None:\n            formatted_map = dict(((addr, '0x%04x' % err_code) for addr, err_code in error_code_map.items()))\n            info_dict['error_code_map'] = formatted_map\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n    keyspace = None\n    '\\n    Keyspace of the function\\n    '\n    function = None\n    '\\n    Name of the function\\n    '\n    arg_types = None\n    '\\n    List of argument type names of the function\\n    '\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n    keyspace = None\n    '\\n    The name of the keyspace that already exists, or, if an attempt was\\n    made to create a new table, the keyspace that the table is in.\\n    '\n    table = None\n    '\\n    The name of the table that already exists, or, if an attempt was\\n    make to create a keyspace, :const:`None`.\\n    '\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n    errors = None\n    '\\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\\n    '\n    last_host = None\n    '\\n    The last :class:`~.Host` this operation was attempted against.\\n    '\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = 'errors=%s, last_host=%s' % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n    excs = []\n    '\\n    A sequence of child exceptions\\n    '\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += '\\nThe following exceptions were observed: \\n - ' + '\\n - '.join((str(e) for e in excs))\n        Exception.__init__(self, complete_msg)"
  }
}