{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_main",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/test_main.py",
  "test_code": "import sys\nfrom unittest.mock import MagicMock, patch\n\nfrom mypy_boto3_builder.main import get_available_service_names, get_selected_service_names, main\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\n\n\nclass TestMain:\n    def test_get_selected_service_names(self) -> None:\n        assert [\n            i.name\n            for i in get_selected_service_names(\n                [\"s3\", \"ec2\"],\n                [ServiceName(\"ec2\", \"EC2\"), ServiceName(\"other\", \"Other\")],\n            )\n        ] == [\"ec2\"]\n        assert [\n            i.name\n            for i in get_selected_service_names(\n                [\"all\", \"ec2\"],\n                [ServiceName(\"ec2\", \"EC2\"), ServiceName(\"other\", \"Other\")],\n            )\n        ] == [\"ec2\", \"other\"]\n        assert get_selected_service_names([\"s3\", \"ec2\"], []) == []\n        with patch.object(BotocoreChangelog, \"fetch_updated\") as fetch_updated_mock:\n            fetch_updated_mock.return_value = [\"ecs\"]\n            assert [\n                i.name\n                for i in get_selected_service_names(\n                    [\"updated\", \"ec2\"],\n                    [\n                        ServiceName(\"ec2\", \"EC2\"),\n                        ServiceName(\"ecs\", \"ECS\"),\n                        ServiceName(\"other\", \"Other\"),\n                    ],\n                )\n            ] == [\"ec2\", \"ecs\"]\n\n    def test_get_available_service_names(self) -> None:\n        session_mock = MagicMock()\n        session_mock.get_available_services.return_value = [\"s3\", \"ec2\", \"unsupported\"]\n        session_mock.get_service_data.return_value = {\n            \"metadata\": {\"serviceAbbreviation\": \"Amazon S3\", \"serviceId\": \"s3\"},\n        }\n        assert len(get_available_service_names(session_mock)) == 3\n\n    @patch(\"mypy_boto3_builder.main.get_available_service_names\")\n    @patch(\"mypy_boto3_builder.main.Boto3Generator\")\n    @patch.object(sys, \"argv\", [\"-o\", \"/tmp\", \"-b\", \"1.2.3.post4\"])  # noqa: S108\n    def test_main(\n        self,\n        Boto3GeneratorMock: MagicMock,\n        get_available_service_names_mock: MagicMock,\n    ) -> None:\n        main()\n        Boto3GeneratorMock().generate_product.assert_called()\n",
  "GT_file_code": {
    "mypy_boto3_builder/utils/botocore_changelog.py": "\"\"\"\nParser for boto3 changelog.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport re\n\nimport requests\n\nfrom mypy_boto3_builder.constants import REQUEST_TIMEOUT\nfrom mypy_boto3_builder.exceptions import BuildEnvError\n\n\nclass BotocoreChangelog:\n    \"\"\"\n    Parser for boto3 changelog.\n    \"\"\"\n\n    URL = \"https://raw.githubusercontent.com/boto/botocore/develop/CHANGELOG.rst\"\n    SERVICE_NAME_RE = re.compile(r\"``(\\S+)``\")\n\n    def __init__(self) -> None:\n        self._changelog: str = \"\"\n\n    @classmethod\n    def _get_changelog(cls) -> str:\n        response = requests.get(cls.URL, timeout=REQUEST_TIMEOUT)\n        if not response.ok:\n            raise BuildEnvError(\n                f\"Cannot retrieve {cls.URL}: {response.status_code} {response.text}\",\n            ) from None\n\n        return response.text\n\n    def _get_section(self, version: str) -> str:\n        result: list[str] = []\n        self._changelog = self._changelog or self._get_changelog()\n        found = False\n        for line in self._changelog.splitlines():\n            if line == version:\n                found = True\n                continue\n            if found and result and line.startswith(\"===\"):\n                result.pop()\n                break\n            if found:\n                result.append(line)\n\n        return \"\\n\".join(result[1:])\n\n    def fetch_updated(self, version: str) -> list[str]:\n        \"\"\"\n        Get a list of service names updated in `version` release.\n        \"\"\"\n        result: list[str] = []\n        section = self._get_section(version)\n        for match in self.SERVICE_NAME_RE.findall(section):\n            if match not in result:\n                result.append(match)\n\n        return result\n",
    "mypy_boto3_builder/cli_parser.py": "\"\"\"\nCLI parser.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport argparse\nimport enum\nimport logging\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any\n\nfrom mypy_boto3_builder.constants import PROG_NAME\nfrom mypy_boto3_builder.enums.product import Product\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.version import get_builder_version\n\n\ndef get_absolute_path(path: str) -> Path:\n    \"\"\"\n    Get absolute path from a string.\n\n    Arguments:\n        path -- String containing path.\n\n    Returns:\n        Absolute path.\n    \"\"\"\n    return Path(path).absolute()\n\n\nclass EnumListAction(argparse.Action):\n    \"\"\"\n    Argparse action for handling Enums.\n    \"\"\"\n\n    def __init__(\n        self,\n        type: type[enum.Enum],  # noqa: A002\n        option_strings: Sequence[str],\n        dest: str,\n        default: Sequence[enum.Enum] | None = None,\n        *,\n        required: bool = False,\n        **kwargs: str | None,\n    ) -> None:\n        self._enum_class = type\n\n        super().__init__(\n            choices=tuple(e.value for e in self._enum_class),\n            option_strings=option_strings,\n            default=default,\n            dest=dest,\n            type=None,\n            required=required,\n            **kwargs,\n        )\n\n    def __call__(\n        self,\n        parser: argparse.ArgumentParser,\n        namespace: argparse.Namespace,\n        value: str | Sequence[Any] | None,\n        _option_string: str | None = None,\n    ) -> None:\n        \"\"\"\n        Convert value back into an Enum.\n        \"\"\"\n        value_list: list[str] = []\n        if isinstance(value, str):\n            value_list.append(value)\n        if isinstance(value, list):\n            value_list.extend([i for i in value if isinstance(i, str)])\n        enum_values = [self._enum_class(i) for i in value_list]\n        setattr(namespace, self.dest, enum_values)\n\n\n@dataclass(kw_only=True, slots=True)\nclass CLINamespace:\n    \"\"\"\n    CLI arguments namespace.\n    \"\"\"\n\n    log_level: int\n    output_path: Path\n    service_names: list[str]\n    build_version: str\n    installed: bool\n    products: list[Product]\n    list_services: bool\n    partial_overload: bool\n    skip_published: bool\n    disable_smart_version: bool\n    download_static_stubs: bool\n\n\ndef parse_args(args: Sequence[str]) -> CLINamespace:\n    \"\"\"\n    Parse CLI arguments.\n\n    Returns:\n        Argument parser.\n    \"\"\"\n    version = get_builder_version()\n\n    parser = argparse.ArgumentParser(\n        PROG_NAME,\n        description=\"Builder for boto3-stubs and types-aiobotocore.\",\n    )\n    parser.add_argument(\"-d\", \"--debug\", action=\"store_true\", help=\"Show debug messages\")\n    parser.add_argument(\n        \"-b\",\n        \"--build-version\",\n        help=\"Set custom output version, otherwise smart versioning is used.\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=version)\n    parser.add_argument(\n        \"--product\",\n        dest=\"products\",\n        type=Product,\n        action=EnumListAction,\n        metavar=\"PRODUCT\",\n        nargs=\"+\",\n        default=(Product.boto3, Product.boto3_services),\n        help=\"Package to generate (default: boto3 boto3-stubs)\",\n    )\n    parser.add_argument(\n        \"--skip-published\",\n        action=\"store_true\",\n        help=\"Skip packages that are already on PyPI\",\n    )\n    parser.add_argument(\n        \"--no-smart-version\",\n        action=\"store_true\",\n        help=(\n            \"Disable version bump based od last PyPI version. \"\n            \"Set this flag to run packages build in offline mode. \"\n            \"skip-published flag is ignored in this case.\"\n        ),\n    )\n    parser.add_argument(\n        \"--download-static-stubs\",\n        action=\"store_true\",\n        help=\"Download static stubs from GitHub repositories instead of using built-in files.\",\n    )\n    parser.add_argument(\n        \"--panic\",\n        action=\"store_true\",\n        help=\"Raise exception on logger warning and above\",\n    )\n    parser.add_argument(\n        \"output_path\",\n        metavar=\"OUTPUT_PATH\",\n        help=\"Output path\",\n        type=get_absolute_path,\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--services\",\n        dest=\"service_names\",\n        nargs=\"*\",\n        metavar=\"NAME\",\n        help=(\n            \"List of AWS services, by default all services are used.\"\n            \" Use `updated` to build only services updated in the release.\"\n            \" Use `essential` to build only essential services.\"\n            \" Use `all` to build all services. (default: all)\"\n        ),\n        default=(ServiceName.ALL,),\n    )\n    parser.add_argument(\n        \"--partial-overload\",\n        action=\"store_true\",\n        help=\"Build boto3-stubs client/service overload only for selected services\",\n    )\n    parser.add_argument(\n        \"--installed\",\n        action=\"store_true\",\n        help=\"Generate already installed packages for typings directory.\",\n    )\n    parser.add_argument(\n        \"--list-services\",\n        action=\"store_true\",\n        help=\"List supported boto3 service names.\",\n    )\n    result = parser.parse_args(args)\n\n    return CLINamespace(\n        log_level=logging.DEBUG if result.debug else logging.INFO,\n        output_path=result.output_path,\n        service_names=result.service_names,\n        products=result.products,\n        build_version=result.build_version,\n        installed=result.installed,\n        list_services=result.list_services,\n        partial_overload=result.partial_overload,\n        skip_published=result.skip_published,\n        disable_smart_version=result.no_smart_version,\n        download_static_stubs=result.download_static_stubs,\n    )\n",
    "mypy_boto3_builder/utils/version_getters.py": "\"\"\"\nUtils for getting underlying package versions.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\n\nfrom mypy_boto3_builder.exceptions import BuildEnvError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.pypi_manager import PyPIManager\n\n\ndef get_botocore_version() -> str:\n    \"\"\"\n    Get botocore package version.\n    \"\"\"\n    try:\n        from botocore import __version__ as version  # noqa: PLC0415\n    except ImportError as e:\n        raise BuildEnvError(\"botocore is not installed\") from e\n    return f\"{version}\"\n\n\ndef get_boto3_version() -> str:\n    \"\"\"\n    Get boto3 package version.\n    \"\"\"\n    try:\n        from boto3 import __version__ as version  # noqa: PLC0415\n    except ImportError as e:\n        raise BuildEnvError(\"boto3 is not installed\") from e\n    return f\"{version}\"\n\n\n@functools.cache\ndef get_aiobotocore_version() -> str:\n    \"\"\"\n    Get aiobotocore package version.\n    \"\"\"\n    try:\n        from aiobotocore import __version__ as version  # type: ignore  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        return f\"{version}\"\n\n    logger = get_logger()\n    logger.warning(\"aiobotocore is not installed, using latest version from PyPI\")\n    pypi_manager = PyPIManager(\"aiobotocore\")\n    return pypi_manager.get_latest_stable_version()\n\n\n@functools.cache\ndef get_aioboto3_version() -> str:\n    \"\"\"\n    Get aioboto3 package version.\n    \"\"\"\n    try:\n        from aioboto3 import __version__ as version  # type: ignore  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        return f\"{version}\"\n\n    logger = get_logger()\n    logger.warning(\"aioboto3 is not installed, using latest version from PyPI\")\n    pypi_manager = PyPIManager(\"aioboto3\")\n    return pypi_manager.get_latest_stable_version()\n",
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\n\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\n\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\n\nRESERVED_NAMES: Final = {\n    *dir(typing),\n    *dir(builtins),\n    *keyword.kwlist,\n}\nAWS_LINK_RE: Final = re.compile(r\"`([^`]+\\S)\\s*<https://(\\S+)>`\\_*\")\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({\"\u2019\": \"'\", \"\u2013\": \"-\"})\n\n\ndef get_class_prefix(func_name: str) -> str:\n    \"\"\"\n    Get a valid Python class prefix from `func_name`.\n\n    Arguments:\n        func_name -- Any string.\n\n    Returns:\n        String with a class prefix.\n    \"\"\"\n    parts = [capitalize(i) for i in func_name.split(\"_\") if i]\n    return \"\".join(parts)\n\n\ndef get_anchor_link(text: str) -> str:\n    \"\"\"\n    Convert header to markdown anchor link.\n    \"\"\"\n    return text.strip().replace(\" \", \"-\").replace(\".\", \"\").lower()\n\n\ndef is_reserved(word: str) -> bool:\n    \"\"\"\n    Check whether variable name conflicts with Python reserved names.\n    \"\"\"\n    return word in RESERVED_NAMES\n\n\ndef get_short_docstring(doc: str) -> str:\n    \"\"\"\n    Create a short docstring from boto3 documentation.\n\n    Trims docstring to 300 chars.\n    Removes double and triple backticks.\n    Stops on `**Request syntax**` and `::`.\n    Ensures that backticks are closed.\n    Replaces `Text <link>` with [Text](link).\n    Wraps docstring to 80 chars.\n    \"\"\"\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f\"{doc[:DOCSTRING_MAX_LENGTH - 3]}...\"\n    result: list[str] = []\n    if not doc:\n        return \"\"\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix(\"::\")\n        if not line:\n            continue\n        if line.startswith(\":\") or line.lower().startswith(\"**request syntax**\"):\n            break\n        if \". \" in line:\n            result.append(line.split(\". \")[0])\n            break\n        result.append(line)\n        if line.endswith(\".\"):\n            break\n\n    result_str = \" \".join(result).replace(\"```\", \"`\").replace(\"``\", \"`\").replace(\"\\n\", \" \").strip()\n    return clean_artifacts(result_str)\n\n\ndef clean_artifacts(line: str) -> str:\n    \"\"\"\n    Remove common artifacts in botocre docs.\n    \"\"\"\n    if line.count(\"`\") % 2:\n        line = f\"{line}`\"\n    if line and not line.endswith(\".\"):\n        line = f\"{line}.\"\n\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n\n    if \"<https:\" in line:\n        line = AWS_LINK_RE.sub(r\"[\\g<1>](https://\\g<2>)\", line)\n        # FIXME: temporary fix for pca-connector-ad service\n        line = line.replace(\"https\\\\:\", \"https:\")\n        # FIXME: temporary fix for neptunedata service\n        line = line.replace(\"neptune-db\\\\:\", \"neptune-db:\")\n\n    return line\n\n\ndef textwrap(text: str, width: int = DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"\n    Wrap text to `width` chars.\n    \"\"\"\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(\" \", 0, width)\n            if space_index < 0:\n                space_index = line.find(\" \", width)\n\n            if space_index < 0:\n                result.append(line)\n                break\n\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n\n    return \"\\n\".join(result)\n\n\ndef get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"\n    Get Botocore class name from Service metadata.\n    \"\"\"\n    service_model = MagicMock()\n    service_model.service_name = metadata.get(\"serviceId\", \"\")\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)\n\n\ndef get_type_def_name(*parts: str) -> str:\n    \"\"\"\n    Get a valid Python TypeDef class name from `parts`.\n\n    Examples:\n        ```python\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\n        ```\n    \"\"\"\n    if not parts:\n        raise TypeAnnotationError(\"At least one part is required\")\n\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = \"\".join(parts_camelcased)\n    return f\"{name}TypeDef\"\n\n\ndef capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f\"{s[:1].upper()}{s[1:]}\"\n\n\ndef xform_name(name: str, sep: str = \"_\") -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError(\"Separator is required\")\n    return botocore_xform_name(name, sep)\n\n\ndef get_pypi_link(package_name: str) -> str:\n    \"\"\"\n    Get link to PyPI.\n    \"\"\"\n    if not package_name:\n        raise BuildInternalError(\"package_name is required\")\n    return f\"https://pypi.org/project/{package_name}/\"\n\n\ndef get_copyright() -> str:\n    \"\"\"\n    Get copyright notice.\n    \"\"\"\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f\"Copyright {now.year} Vlad Emelianov\"\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport logging\n\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n\n__all__ = (\"get_logger\",)\n\n\ndef get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger\n",
    "mypy_boto3_builder/main.py": "\"\"\"\nMain entrypoint for builder.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport datetime\nimport sys\nimport warnings\nfrom collections.abc import Iterable, Sequence\n\nfrom botocore.session import Session as BotocoreSession\n\nfrom mypy_boto3_builder.cli_parser import CLINamespace, parse_args\nfrom mypy_boto3_builder.constants import BUILDER_REPO_URL, PACKAGE_NAME\nfrom mypy_boto3_builder.enums.product import Product, ProductLibrary\nfrom mypy_boto3_builder.generators.aioboto3_generator import AioBoto3Generator\nfrom mypy_boto3_builder.generators.aiobotocore_generator import AioBotocoreGenerator\nfrom mypy_boto3_builder.generators.base_generator import BaseGenerator\nfrom mypy_boto3_builder.generators.boto3_generator import Boto3Generator\nfrom mypy_boto3_builder.jinja_manager import JinjaManager\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.utils.boto3_utils import get_boto3_session, get_botocore_session\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, get_botocore_class_name, get_copyright\nfrom mypy_boto3_builder.utils.type_checks import (\n    is_literal,\n    is_type_def,\n    is_type_parent,\n    is_typed_dict,\n    is_union,\n)\nfrom mypy_boto3_builder.utils.version import get_builder_version\nfrom mypy_boto3_builder.utils.version_getters import get_botocore_version\n\n\ndef get_selected_service_names(\n    selected: Iterable[str],\n    available: Iterable[ServiceName],\n) -> list[ServiceName]:\n    \"\"\"\n    Get a list of selected service names.\n\n    Supports `updated` to select only services updated in currect `boto3` release.\n    Supports `all` to select all available service names.\n\n    Arguments:\n        selected -- Selected service names as strings.\n        available -- All ServiceNames available in current boto3 release.\n\n    Returns:\n        A list of selected ServiceNames.\n    \"\"\"\n    logger = get_logger()\n    available_map = {i.name: i for i in available}\n    result: list[ServiceName] = []\n    selected_service_names = list(selected)\n    botocore_version = get_botocore_version()\n    if ServiceName.ALL in selected_service_names:\n        return list(available)\n    if ServiceName.UPDATED in selected_service_names:\n        selected_service_names.remove(ServiceName.UPDATED)\n        updated_service_names = BotocoreChangelog().fetch_updated(botocore_version)\n        selected_service_names.extend(\n            service_name_str\n            for service_name_str in updated_service_names\n            if service_name_str in available_map\n        )\n    if ServiceName.ESSENTIAL in selected_service_names:\n        selected_service_names.remove(ServiceName.ESSENTIAL)\n        selected_service_names.extend(\n            service_name_str\n            for service_name_str in available_map\n            if service_name_str in ServiceName.ESSENTIAL_NAMES\n        )\n\n    for service_name_str in selected_service_names:\n        if service_name_str not in available_map:\n            logger.info(f\"Service {service_name_str} is not provided by botocore, skipping\")\n            continue\n        result.append(available_map[service_name_str])\n\n    return result\n\n\ndef get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n    \"\"\"\n    Get a list of boto3 supported service names.\n\n    Arguments:\n        session -- Boto3 session\n\n    Returns:\n        A list of supported services.\n    \"\"\"\n    available_services = session.get_available_services()\n    result: list[ServiceName] = []\n    for name in available_services:\n        service_data = session.get_service_data(name)\n        metadata = service_data[\"metadata\"]\n        class_name = get_botocore_class_name(metadata)\n        service_name = ServiceNameCatalog.add(name, class_name)\n        result.append(service_name)\n    return result\n\n\ndef get_generator_cls(product: Product) -> type[BaseGenerator]:\n    \"\"\"\n    Get Generator class for a product.\n    \"\"\"\n    library = product.get_library()\n    match library:\n        case ProductLibrary.boto3:\n            return Boto3Generator\n        case ProductLibrary.aiobotocore:\n            return AioBotocoreGenerator\n        case ProductLibrary.aioboto3:\n            return AioBoto3Generator\n\n\ndef generate_product(\n    product: Product,\n    args: CLINamespace,\n    service_names: Sequence[ServiceName],\n    master_service_names: Sequence[ServiceName],\n) -> None:\n    \"\"\"\n    Generate a selected product.\n\n    Arguments:\n        product -- Product to generate\n        args -- CLI namespace\n        service_names -- Selected service names\n        master_service_names -- Service names included in master\n    \"\"\"\n    generator_cls = get_generator_cls(product)\n    generator = generator_cls(\n        service_names=service_names,\n        master_service_names=master_service_names,\n        config=args,\n        version=args.build_version,\n        cleanup=True,\n    )\n    generator.generate_product(product.get_type())\n    generator.cleanup_temporary_files()\n\n\ndef initialize_jinja_manager() -> None:\n    \"\"\"\n    Initialize Jinja manager with globals.\n    \"\"\"\n    jinja_manager = JinjaManager.singleton()\n    jinja_manager.update_globals(\n        builder_version=get_builder_version(),\n        current_year=str(datetime.datetime.now(datetime.timezone.utc).year),\n        get_anchor_link=get_anchor_link,\n        len=len,\n        sorted=sorted,\n        repr=repr,\n        builder_package_name=PACKAGE_NAME,\n        builder_repo_url=BUILDER_REPO_URL,\n        copyright=get_copyright(),\n        is_typed_dict=is_typed_dict,\n        is_union=is_union,\n        is_literal=is_literal,\n        is_type_def=is_type_def,\n        is_type_parent=is_type_parent,\n    )\n\n\ndef run(args: CLINamespace) -> None:\n    \"\"\"\n    Run builder.\n    \"\"\"\n    # FIXME: suppress botocore endpoint warning\n    warnings.filterwarnings(\"ignore\", category=FutureWarning, module=\"botocore.client\")\n\n    logger = get_logger(level=args.log_level)\n\n    initialize_jinja_manager()\n    session = get_boto3_session()\n\n    args.output_path.mkdir(exist_ok=True, parents=True)\n    available_service_names = get_available_service_names(get_botocore_session(session))\n\n    logger.info(f\"{len(available_service_names)} supported botocore services discovered\")\n    if args.list_services:\n        for service_name in available_service_names:\n            sys.stdout.write(\n                f\"- {service_name.name} : {service_name.class_name}\"\n                f\" {service_name.boto3_doc_link}\\n\",\n            )\n        return\n\n    service_names = get_selected_service_names(args.service_names, available_service_names)\n    master_service_names = service_names if args.partial_overload else available_service_names\n\n    for product in args.products:\n        logger.info(f\"Generating {product} product\")\n        generate_product(product, args, service_names, master_service_names)\n\n    logger.info(\"Completed\")\n\n\ndef main() -> None:\n    \"\"\"\n    CLI entrypoint.\n    \"\"\"\n    args = parse_args(sys.argv[1:])\n    run(args)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/utils/botocore_changelog.py": {
      "BotocoreChangelog.__init__": {
        "code": "    def __init__(self) -> None:\n        \"\"\"Initializer for the BotocoreChangelog class.\n\nThis constructor initializes an instance of the BotocoreChangelog class, setting up an empty string attribute `_changelog`. This attribute will later hold the contents of the changelog retrieved from the specified URL. There are no parameters or return values for this method.\n\nAttributes:\n- `_changelog` (str): Stores the raw changelog text fetched from the Botocore repository.\n\nThis class does not directly interact with any constants during initialization, but other methods such as `_get_changelog` rely on the constant `REQUEST_TIMEOUT` defined in the `mypy_boto3_builder.constants` module for managing request timeouts.\"\"\"\n        self._changelog: str = ''",
        "docstring": "Initializer for the BotocoreChangelog class.\n\nThis constructor initializes an instance of the BotocoreChangelog class, setting up an empty string attribute `_changelog`. This attribute will later hold the contents of the changelog retrieved from the specified URL. There are no parameters or return values for this method.\n\nAttributes:\n- `_changelog` (str): Stores the raw changelog text fetched from the Botocore repository.\n\nThis class does not directly interact with any constants during initialization, but other methods such as `_get_changelog` rely on the constant `REQUEST_TIMEOUT` defined in the `mypy_boto3_builder.constants` module for managing request timeouts.",
        "signature": "def __init__(self) -> None:",
        "type": "Method",
        "class_signature": "class BotocoreChangelog:"
      }
    },
    "mypy_boto3_builder/cli_parser.py": {
      "parse_args": {
        "code": "def parse_args(args: Sequence[str]) -> CLINamespace:\n    \"\"\"Parse command-line arguments for the boto3-stubs and types-aiobotocore builder tool.\n\nParameters:\n    args (Sequence[str]): A sequence of strings representing the command-line arguments to be parsed.\n\nReturns:\n    CLINamespace: An instance of CLINamespace containing parsed CLI argument values, including:\n        - log_level (int): Logging level set based on the --debug flag.\n        - output_path (Path): The absolute output path defined by the user.\n        - service_names (list[str]): List of specified AWS service names or defaults to all services.\n        - products (list[Product]): Products to generate, defaults to boto3 and boto3-stubs.\n        - build_version (str): Custom output version if provided.\n        - installed (bool): Flag indicating if already installed packages should be generated.\n        - list_services (bool): Flag to indicate whether to list supported services.\n        - partial_overload (bool): Flag for building overloads for selected services.\n        - skip_published (bool): Flag to skip packages already published on PyPI.\n        - disable_smart_version (bool): Flag to disable automatic version bump based on last PyPI version.\n        - download_static_stubs (bool): Flag to download static stubs from GitHub instead of using built-in ones.\n\nDependencies:\n    - PROG_NAME: A constant representing the program name, used for the argument parser description.\n    - get_builder_version: A function that retrieves the current builder version for the --version argument.\n    - Product: An enumeration used to specify different product packages that can be generated.\n    - get_absolute_path: A utility function to convert relative paths to absolute paths passed via the CLI.\"\"\"\n    '\\n    Parse CLI arguments.\\n\\n    Returns:\\n        Argument parser.\\n    '\n    version = get_builder_version()\n    parser = argparse.ArgumentParser(PROG_NAME, description='Builder for boto3-stubs and types-aiobotocore.')\n    parser.add_argument('-d', '--debug', action='store_true', help='Show debug messages')\n    parser.add_argument('-b', '--build-version', help='Set custom output version, otherwise smart versioning is used.')\n    parser.add_argument('-V', '--version', action='version', version=version)\n    parser.add_argument('--product', dest='products', type=Product, action=EnumListAction, metavar='PRODUCT', nargs='+', default=(Product.boto3, Product.boto3_services), help='Package to generate (default: boto3 boto3-stubs)')\n    parser.add_argument('--skip-published', action='store_true', help='Skip packages that are already on PyPI')\n    parser.add_argument('--no-smart-version', action='store_true', help='Disable version bump based od last PyPI version. Set this flag to run packages build in offline mode. skip-published flag is ignored in this case.')\n    parser.add_argument('--download-static-stubs', action='store_true', help='Download static stubs from GitHub repositories instead of using built-in files.')\n    parser.add_argument('--panic', action='store_true', help='Raise exception on logger warning and above')\n    parser.add_argument('output_path', metavar='OUTPUT_PATH', help='Output path', type=get_absolute_path)\n    parser.add_argument('-s', '--services', dest='service_names', nargs='*', metavar='NAME', help='List of AWS services, by default all services are used. Use `updated` to build only services updated in the release. Use `essential` to build only essential services. Use `all` to build all services. (default: all)', default=(ServiceName.ALL,))\n    parser.add_argument('--partial-overload', action='store_true', help='Build boto3-stubs client/service overload only for selected services')\n    parser.add_argument('--installed', action='store_true', help='Generate already installed packages for typings directory.')\n    parser.add_argument('--list-services', action='store_true', help='List supported boto3 service names.')\n    result = parser.parse_args(args)\n    return CLINamespace(log_level=logging.DEBUG if result.debug else logging.INFO, output_path=result.output_path, service_names=result.service_names, products=result.products, build_version=result.build_version, installed=result.installed, list_services=result.list_services, partial_overload=result.partial_overload, skip_published=result.skip_published, disable_smart_version=result.no_smart_version, download_static_stubs=result.download_static_stubs)",
        "docstring": "Parse command-line arguments for the boto3-stubs and types-aiobotocore builder tool.\n\nParameters:\n    args (Sequence[str]): A sequence of strings representing the command-line arguments to be parsed.\n\nReturns:\n    CLINamespace: An instance of CLINamespace containing parsed CLI argument values, including:\n        - log_level (int): Logging level set based on the --debug flag.\n        - output_path (Path): The absolute output path defined by the user.\n        - service_names (list[str]): List of specified AWS service names or defaults to all services.\n        - products (list[Product]): Products to generate, defaults to boto3 and boto3-stubs.\n        - build_version (str): Custom output version if provided.\n        - installed (bool): Flag indicating if already installed packages should be generated.\n        - list_services (bool): Flag to indicate whether to list supported services.\n        - partial_overload (bool): Flag for building overloads for selected services.\n        - skip_published (bool): Flag to skip packages already published on PyPI.\n        - disable_smart_version (bool): Flag to disable automatic version bump based on last PyPI version.\n        - download_static_stubs (bool): Flag to download static stubs from GitHub instead of using built-in ones.\n\nDependencies:\n    - PROG_NAME: A constant representing the program name, used for the argument parser description.\n    - get_builder_version: A function that retrieves the current builder version for the --version argument.\n    - Product: An enumeration used to specify different product packages that can be generated.\n    - get_absolute_path: A utility function to convert relative paths to absolute paths passed via the CLI.",
        "signature": "def parse_args(args: Sequence[str]) -> CLINamespace:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/utils/version_getters.py": {
      "get_botocore_version": {
        "code": "def get_botocore_version() -> str:\n    \"\"\"Retrieve the version of the botocore package.\n\nThis function attempts to import the `__version__` attribute from the `botocore` module. If the botocore package is not installed, it raises a `BuildEnvError` with a descriptive message. Upon successful import, it returns the version as a string.\n\nReturns:\n    str: The version of the botocore package.\n\nRaises:\n    BuildEnvError: If botocore is not installed.\n\nDependencies:\n    - Requires the `botocore` package to be installed.\n    - Interacts with the `BuildEnvError` class from the `mypy_boto3_builder.exceptions` module for error handling.\"\"\"\n    '\\n    Get botocore package version.\\n    '\n    try:\n        from botocore import __version__ as version\n    except ImportError as e:\n        raise BuildEnvError('botocore is not installed') from e\n    return f'{version}'",
        "docstring": "Retrieve the version of the botocore package.\n\nThis function attempts to import the `__version__` attribute from the `botocore` module. If the botocore package is not installed, it raises a `BuildEnvError` with a descriptive message. Upon successful import, it returns the version as a string.\n\nReturns:\n    str: The version of the botocore package.\n\nRaises:\n    BuildEnvError: If botocore is not installed.\n\nDependencies:\n    - Requires the `botocore` package to be installed.\n    - Interacts with the `BuildEnvError` class from the `mypy_boto3_builder.exceptions` module for error handling.",
        "signature": "def get_botocore_version() -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/utils/strings.py": {
      "get_botocore_class_name": {
        "code": "def get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"Get the Botocore class name derived from service metadata.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, \n    expected to include a \"serviceId\" key.\n\nReturns:\n    str: The capitalized name of the Botocore class corresponding to the \n    service, derived from the service metadata using the `get_service_module_name` function.\n\nNotes:\n    - This function relies on `MagicMock` from the `unittest.mock` module to simulate \n    a service model for extracting the class name.\n    - It uses the `capitalize` function to format the final class name.\"\"\"\n    '\\n    Get Botocore class name from Service metadata.\\n    '\n    service_model = MagicMock()\n    service_model.service_name = metadata.get('serviceId', '')\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)",
        "docstring": "Get the Botocore class name derived from service metadata.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, \n    expected to include a \"serviceId\" key.\n\nReturns:\n    str: The capitalized name of the Botocore class corresponding to the \n    service, derived from the service metadata using the `get_service_module_name` function.\n\nNotes:\n    - This function relies on `MagicMock` from the `unittest.mock` module to simulate \n    a service model for extracting the class name.\n    - It uses the `capitalize` function to format the final class name.",
        "signature": "def get_botocore_class_name(metadata: dict[str, str]) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.__init__": {
        "code": "    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        \"\"\"Initialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the AWS service (e.g. \"ec2\").\n- class_name (str): The class name associated with the service (e.g. \"EC2\").\n- override_boto3_name (str, optional): An optional name to override the default boto3 name for the service.\n\nAttributes initialized:\n- self.name: Stores the service name.\n- self.class_name: Stores the corresponding class name.\n- self.boto3_version: Initialized to the constant LATEST, representing the latest version of the service.\n- self.override_boto3_name: Stores the overridden boto3 name if provided. If not, it defaults to an empty string.\n\nThis constructor interacts with the class constants such as LATEST, which is used to set the default boto3 version for the service.\"\"\"\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name",
        "docstring": "Initialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the AWS service (e.g. \"ec2\").\n- class_name (str): The class name associated with the service (e.g. \"EC2\").\n- override_boto3_name (str, optional): An optional name to override the default boto3 name for the service.\n\nAttributes initialized:\n- self.name: Stores the service name.\n- self.class_name: Stores the corresponding class name.\n- self.boto3_version: Initialized to the constant LATEST, representing the latest version of the service.\n- self.override_boto3_name: Stores the overridden boto3 name if provided. If not, it defaults to an empty string.\n\nThis constructor interacts with the class constants such as LATEST, which is used to set the default boto3 version for the service.",
        "signature": "def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceNameCatalog.add": {
        "code": "    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"Add a new `ServiceName` to the catalog or modify an existing one.\n\nThis class method checks if the provided `name` already exists in the `ITEMS` dictionary. If it does, it updates the `class_name` of the existing `ServiceName` instance and returns it. If it does not exist, it creates a new `ServiceName` instance and adds it to `ITEMS`, then returns the new instance.\n\nParameters:\n- name (str): The name of the service to be added or modified.\n- class_name (str): The class name associated with the service.\n\nReturns:\n- ServiceName: An instance of the `ServiceName` class, representing either the newly added service or the modified existing service.\n\nThe `ITEMS` dictionary is a class-level attribute that serves as a catalog mapping service names to their corresponding `ServiceName` instances, facilitating lookups and ensuring uniqueness in the catalog.\"\"\"\n        '\\n        Add new ServiceName to catalog or modify existing one.\\n\\n        Returns:\\n            New ServiceName or modified if it exists.\\n        '\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name",
        "docstring": "Add a new `ServiceName` to the catalog or modify an existing one.\n\nThis class method checks if the provided `name` already exists in the `ITEMS` dictionary. If it does, it updates the `class_name` of the existing `ServiceName` instance and returns it. If it does not exist, it creates a new `ServiceName` instance and adds it to `ITEMS`, then returns the new instance.\n\nParameters:\n- name (str): The name of the service to be added or modified.\n- class_name (str): The class name associated with the service.\n\nReturns:\n- ServiceName: An instance of the `ServiceName` class, representing either the newly added service or the modified existing service.\n\nThe `ITEMS` dictionary is a class-level attribute that serves as a catalog mapping service names to their corresponding `ServiceName` instances, facilitating lookups and ensuring uniqueness in the catalog.",
        "signature": "def add(cls, name: str, class_name: str) -> ServiceName:",
        "type": "Method",
        "class_signature": "class ServiceNameCatalog:"
      }
    },
    "mypy_boto3_builder/logger.py": {
      "get_logger": {
        "code": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n    \"\"\"Get a configured logger instance.\n\nThis function initializes and returns a logging.Logger instance with a specified log level and name. If the logger does not have any handlers, it creates a StreamHandler, sets a custom formatter for the output, and adds it to the logger. The log level can be adjusted, affecting all existing handlers as well.\n\nParameters:\n    level (int | None): Optional log level. If None, defaults to logging.NOTSET.\n    name (str): The name of the logger, defaulting to LOGGER_NAME from mypy_boto3_builder.constants.\n\nReturns:\n    logging.Logger: The configured logger instance.\n\nDependencies:\n    The function relies on the logging module from the Python standard library. The LOGGER_NAME constant is sourced from the mypy_boto3_builder.constants module, defining the default name of the logger.\"\"\"\n    '\\n    Get Logger instance.\\n\\n    Arguments:\\n        level -- Log level.\\n\\n    Returns:\\n        Overriden Logger.\\n    '\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s %(name)s: %(levelname)-7s %(message)s', datefmt='%H:%M:%S')\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n    return logger",
        "docstring": "Get a configured logger instance.\n\nThis function initializes and returns a logging.Logger instance with a specified log level and name. If the logger does not have any handlers, it creates a StreamHandler, sets a custom formatter for the output, and adds it to the logger. The log level can be adjusted, affecting all existing handlers as well.\n\nParameters:\n    level (int | None): Optional log level. If None, defaults to logging.NOTSET.\n    name (str): The name of the logger, defaulting to LOGGER_NAME from mypy_boto3_builder.constants.\n\nReturns:\n    logging.Logger: The configured logger instance.\n\nDependencies:\n    The function relies on the logging module from the Python standard library. The LOGGER_NAME constant is sourced from the mypy_boto3_builder.constants module, defining the default name of the logger.",
        "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/main.py": {
      "get_selected_service_names": {
        "code": "def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:\n    \"\"\"Get a list of selected service names based on user input and available services.\n\nThis function processes a list of selected service names as strings, allowing support for special keywords such as `ServiceName.ALL` to return all available services, `ServiceName.UPDATED` to return only those services updated in the current Boto3 release, and `ServiceName.ESSENTIAL` to return a predefined essential set of services. The function interacts with the `BotocoreChangelog` to fetch updated services and utilizes the `ServiceNameCatalog` to manage available service names.\n\nParameters:\n    selected (Iterable[str]): A collection of service names as strings selected by the user.\n    available (Iterable[ServiceName]): A collection of all available ServiceNames from the current Boto3 release.\n\nReturns:\n    list[ServiceName]: A list of ServiceNames that correspond to the user's selection, filtered by availability.\n\nConstants Used:\n    ServiceName.ALL: Represents a request for all available services.\n    ServiceName.UPDATED: Indicates the selection of only services that have been updated.\n    ServiceName.ESSENTIAL: Represents a request for essential services.\n    ServiceName.ESSENTIAL_NAMES: A predefined list of essential service names.\nThese constants are used to direct the function's behavior in filtering service names as per user requirements.\"\"\"\n    '\\n    Get a list of selected service names.\\n\\n    Supports `updated` to select only services updated in currect `boto3` release.\\n    Supports `all` to select all available service names.\\n\\n    Arguments:\\n        selected -- Selected service names as strings.\\n        available -- All ServiceNames available in current boto3 release.\\n\\n    Returns:\\n        A list of selected ServiceNames.\\n    '\n    logger = get_logger()\n    available_map = {i.name: i for i in available}\n    result: list[ServiceName] = []\n    selected_service_names = list(selected)\n    botocore_version = get_botocore_version()\n    if ServiceName.ALL in selected_service_names:\n        return list(available)\n    if ServiceName.UPDATED in selected_service_names:\n        selected_service_names.remove(ServiceName.UPDATED)\n        updated_service_names = BotocoreChangelog().fetch_updated(botocore_version)\n        selected_service_names.extend((service_name_str for service_name_str in updated_service_names if service_name_str in available_map))\n    if ServiceName.ESSENTIAL in selected_service_names:\n        selected_service_names.remove(ServiceName.ESSENTIAL)\n        selected_service_names.extend((service_name_str for service_name_str in available_map if service_name_str in ServiceName.ESSENTIAL_NAMES))\n    for service_name_str in selected_service_names:\n        if service_name_str not in available_map:\n            logger.info(f'Service {service_name_str} is not provided by botocore, skipping')\n            continue\n        result.append(available_map[service_name_str])\n    return result",
        "docstring": "Get a list of selected service names based on user input and available services.\n\nThis function processes a list of selected service names as strings, allowing support for special keywords such as `ServiceName.ALL` to return all available services, `ServiceName.UPDATED` to return only those services updated in the current Boto3 release, and `ServiceName.ESSENTIAL` to return a predefined essential set of services. The function interacts with the `BotocoreChangelog` to fetch updated services and utilizes the `ServiceNameCatalog` to manage available service names.\n\nParameters:\n    selected (Iterable[str]): A collection of service names as strings selected by the user.\n    available (Iterable[ServiceName]): A collection of all available ServiceNames from the current Boto3 release.\n\nReturns:\n    list[ServiceName]: A list of ServiceNames that correspond to the user's selection, filtered by availability.\n\nConstants Used:\n    ServiceName.ALL: Represents a request for all available services.\n    ServiceName.UPDATED: Indicates the selection of only services that have been updated.\n    ServiceName.ESSENTIAL: Represents a request for essential services.\n    ServiceName.ESSENTIAL_NAMES: A predefined list of essential service names.\nThese constants are used to direct the function's behavior in filtering service names as per user requirements.",
        "signature": "def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:",
        "type": "Function",
        "class_signature": null
      },
      "get_available_service_names": {
        "code": "def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n    \"\"\"Retrieve a list of service names supported by Boto3.\n\nThis function takes a Botocore session, queries available services, and constructs a list of ServiceName objects representing each service. It extracts service metadata and uses the `get_botocore_class_name` utility to derive class names for the services. The resulting list is populated from the `ServiceNameCatalog`, which serves as a registry for all service names and their associated classes.\n\nParameters:\n    session (BotocoreSession): A valid Boto3 session used to fetch available services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects, each representing a supported Boto3 service.\n\nDependencies:\n- `get_botocore_class_name`: A utility that retrieves the class name from metadata.\n- `ServiceNameCatalog`: A catalog that manages the registration of service names.\n- The method accesses the Botocore session to call `get_available_services` and `get_service_data` for fetching data.\"\"\"\n    '\\n    Get a list of boto3 supported service names.\\n\\n    Arguments:\\n        session -- Boto3 session\\n\\n    Returns:\\n        A list of supported services.\\n    '\n    available_services = session.get_available_services()\n    result: list[ServiceName] = []\n    for name in available_services:\n        service_data = session.get_service_data(name)\n        metadata = service_data['metadata']\n        class_name = get_botocore_class_name(metadata)\n        service_name = ServiceNameCatalog.add(name, class_name)\n        result.append(service_name)\n    return result",
        "docstring": "Retrieve a list of service names supported by Boto3.\n\nThis function takes a Botocore session, queries available services, and constructs a list of ServiceName objects representing each service. It extracts service metadata and uses the `get_botocore_class_name` utility to derive class names for the services. The resulting list is populated from the `ServiceNameCatalog`, which serves as a registry for all service names and their associated classes.\n\nParameters:\n    session (BotocoreSession): A valid Boto3 session used to fetch available services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects, each representing a supported Boto3 service.\n\nDependencies:\n- `get_botocore_class_name`: A utility that retrieves the class name from metadata.\n- `ServiceNameCatalog`: A catalog that manages the registration of service names.\n- The method accesses the Botocore session to call `get_available_services` and `get_service_data` for fetching data.",
        "signature": "def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(args: CLINamespace) -> None:\n    \"\"\"Run the builder by processing command-line arguments to generate AWS service client products.\n\nParameters:\n    args (CLINamespace): Parsed command-line arguments, including logging level, output path, service names to include, and product types to generate.\n\nReturns:\n    None\n\nThis function initializes the Jinja template manager, establishes a Boto3 session, and retrieves available services. It logs the number of discovered services and handles listing services if requested. It then selects specified service names, determines master service names (based on whether partial overload is enabled), and generates the requested product(s) using the `generate_product` function. \n\nConstants and functions used:\n- `get_logger`: retrieves a logger instance configured with the specified log level.\n- `initialize_jinja_manager`: sets up the Jinja template manager for generating output.\n- `get_boto3_session`: creates a new Boto3 session to interact with AWS services.\n- `get_botocore_session`: provides a Botocore session to obtain available service names.\n- `get_available_service_names`: fetches the list of services supported by the current Boto3 version.\n- `get_selected_service_names`: filters the services based on user input.\n- `args.output_path`: determines where the generated products will be saved, ensuring the directory exists.\n- `args.products`: specifies which AWS service products to generate.\"\"\"\n    '\\n    Run builder.\\n    '\n    warnings.filterwarnings('ignore', category=FutureWarning, module='botocore.client')\n    logger = get_logger(level=args.log_level)\n    initialize_jinja_manager()\n    session = get_boto3_session()\n    args.output_path.mkdir(exist_ok=True, parents=True)\n    available_service_names = get_available_service_names(get_botocore_session(session))\n    logger.info(f'{len(available_service_names)} supported botocore services discovered')\n    if args.list_services:\n        for service_name in available_service_names:\n            sys.stdout.write(f'- {service_name.name} : {service_name.class_name} {service_name.boto3_doc_link}\\n')\n        return\n    service_names = get_selected_service_names(args.service_names, available_service_names)\n    master_service_names = service_names if args.partial_overload else available_service_names\n    for product in args.products:\n        logger.info(f'Generating {product} product')\n        generate_product(product, args, service_names, master_service_names)\n    logger.info('Completed')",
        "docstring": "Run the builder by processing command-line arguments to generate AWS service client products.\n\nParameters:\n    args (CLINamespace): Parsed command-line arguments, including logging level, output path, service names to include, and product types to generate.\n\nReturns:\n    None\n\nThis function initializes the Jinja template manager, establishes a Boto3 session, and retrieves available services. It logs the number of discovered services and handles listing services if requested. It then selects specified service names, determines master service names (based on whether partial overload is enabled), and generates the requested product(s) using the `generate_product` function. \n\nConstants and functions used:\n- `get_logger`: retrieves a logger instance configured with the specified log level.\n- `initialize_jinja_manager`: sets up the Jinja template manager for generating output.\n- `get_boto3_session`: creates a new Boto3 session to interact with AWS services.\n- `get_botocore_session`: provides a Botocore session to obtain available service names.\n- `get_available_service_names`: fetches the list of services supported by the current Boto3 version.\n- `get_selected_service_names`: filters the services based on user input.\n- `args.output_path`: determines where the generated products will be saved, ensuring the directory exists.\n- `args.products`: specifies which AWS service products to generate.",
        "signature": "def run(args: CLINamespace) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "main": {
        "code": "def main() -> None:\n    \"\"\"CLI entrypoint that initiates the builder process for generating AWS service libraries. It parses command-line arguments using `parse_args()` and then calls the `run()` function with the parsed arguments. The `args` contains various options including the services to generate, the desired output path, and the log level.\n\nThis function does not return a value. It interacts with user-defined command-line inputs to execute the appropriate actions based on the specified options, ultimately affecting how the library generation occurs based on user preferences.\"\"\"\n    '\\n    CLI entrypoint.\\n    '\n    args = parse_args(sys.argv[1:])\n    run(args)",
        "docstring": "CLI entrypoint that initiates the builder process for generating AWS service libraries. It parses command-line arguments using `parse_args()` and then calls the `run()` function with the parsed arguments. The `args` contains various options including the services to generate, the desired output path, and the log level.\n\nThis function does not return a value. It interacts with user-defined command-line inputs to execute the appropriate actions based on the specified options, ultimately affecting how the library generation occurs based on user preferences.",
        "signature": "def main() -> None:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_main\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 cli_parser.py\n    \u2502   \u2514\u2500\u2500 parse_args\n    \u251c\u2500\u2500 logger.py\n    \u2502   \u2514\u2500\u2500 get_logger\n    \u251c\u2500\u2500 main.py\n    \u2502   \u251c\u2500\u2500 get_available_service_names\n    \u2502   \u251c\u2500\u2500 get_selected_service_names\n    \u2502   \u251c\u2500\u2500 main\n    \u2502   \u2514\u2500\u2500 run\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u251c\u2500\u2500 ServiceName.__init__\n    \u2502   \u2514\u2500\u2500 ServiceNameCatalog.add\n    \u2514\u2500\u2500 utils/\n        \u251c\u2500\u2500 botocore_changelog.py\n        \u2502   \u2514\u2500\u2500 BotocoreChangelog.__init__\n        \u251c\u2500\u2500 strings.py\n        \u2502   \u2514\u2500\u2500 get_botocore_class_name\n        \u2514\u2500\u2500 version_getters.py\n            \u2514\u2500\u2500 get_botocore_version\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the generation and customization of type-safe Python SDKs for AWS services using Boto3. It provides functionality to identify available and selected service names, manage service metadata, and generate SDKs with support for specific configurations or updates. By streamlining the handling of AWS service definitions and automating the SDK generation process, it enables developers to integrate type annotations and enhance IDE support, boosting development efficiency and reducing potential runtime errors. This module addresses the need for robust, maintainable, and scalable interaction with AWS services in Python applications.\n\n## FILE 1: mypy_boto3_builder/utils/botocore_changelog.py\n\n- CLASS METHOD: BotocoreChangelog.__init__\n  - CLASS SIGNATURE: class BotocoreChangelog:\n  - SIGNATURE: def __init__(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializer for the BotocoreChangelog class.\n\nThis constructor initializes an instance of the BotocoreChangelog class, setting up an empty string attribute `_changelog`. This attribute will later hold the contents of the changelog retrieved from the specified URL. There are no parameters or return values for this method.\n\nAttributes:\n- `_changelog` (str): Stores the raw changelog text fetched from the Botocore repository.\n\nThis class does not directly interact with any constants during initialization, but other methods such as `_get_changelog` rely on the constant `REQUEST_TIMEOUT` defined in the `mypy_boto3_builder.constants` module for managing request timeouts.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/cli_parser.py\n\n- FUNCTION NAME: parse_args\n  - SIGNATURE: def parse_args(args: Sequence[str]) -> CLINamespace:\n  - DOCSTRING: \n```python\n\"\"\"\nParse command-line arguments for the boto3-stubs and types-aiobotocore builder tool.\n\nParameters:\n    args (Sequence[str]): A sequence of strings representing the command-line arguments to be parsed.\n\nReturns:\n    CLINamespace: An instance of CLINamespace containing parsed CLI argument values, including:\n        - log_level (int): Logging level set based on the --debug flag.\n        - output_path (Path): The absolute output path defined by the user.\n        - service_names (list[str]): List of specified AWS service names or defaults to all services.\n        - products (list[Product]): Products to generate, defaults to boto3 and boto3-stubs.\n        - build_version (str): Custom output version if provided.\n        - installed (bool): Flag indicating if already installed packages should be generated.\n        - list_services (bool): Flag to indicate whether to list supported services.\n        - partial_overload (bool): Flag for building overloads for selected services.\n        - skip_published (bool): Flag to skip packages already published on PyPI.\n        - disable_smart_version (bool): Flag to disable automatic version bump based on last PyPI version.\n        - download_static_stubs (bool): Flag to download static stubs from GitHub instead of using built-in ones.\n\nDependencies:\n    - PROG_NAME: A constant representing the program name, used for the argument parser description.\n    - get_builder_version: A function that retrieves the current builder version for the --version argument.\n    - Product: An enumeration used to specify different product packages that can be generated.\n    - get_absolute_path: A utility function to convert relative paths to absolute paths passed via the CLI.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/cli_parser.py:get_absolute_path\n    - mypy_boto3_builder/main.py:main\n    - mypy_boto3_builder/utils/version.py:get_builder_version\n    - mypy_boto3_builder/cli_parser.py:EnumListAction:__init__\n\n## FILE 3: mypy_boto3_builder/utils/version_getters.py\n\n- FUNCTION NAME: get_botocore_version\n  - SIGNATURE: def get_botocore_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the version of the botocore package.\n\nThis function attempts to import the `__version__` attribute from the `botocore` module. If the botocore package is not installed, it raises a `BuildEnvError` with a descriptive message. Upon successful import, it returns the version as a string.\n\nReturns:\n    str: The version of the botocore package.\n\nRaises:\n    BuildEnvError: If botocore is not installed.\n\nDependencies:\n    - Requires the `botocore` package to be installed.\n    - Interacts with the `BuildEnvError` class from the `mypy_boto3_builder.exceptions` module for error handling.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/main.py:get_selected_service_names\n\n## FILE 4: mypy_boto3_builder/utils/strings.py\n\n- FUNCTION NAME: get_botocore_class_name\n  - SIGNATURE: def get_botocore_class_name(metadata: dict[str, str]) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the Botocore class name derived from service metadata.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, \n    expected to include a \"serviceId\" key.\n\nReturns:\n    str: The capitalized name of the Botocore class corresponding to the \n    service, derived from the service metadata using the `get_service_module_name` function.\n\nNotes:\n    - This function relies on `MagicMock` from the `unittest.mock` module to simulate \n    a service model for extracting the class name.\n    - It uses the `capitalize` function to format the final class name.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:capitalize\n    - mypy_boto3_builder/main.py:get_available_service_names\n\n## FILE 5: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.__init__\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the AWS service (e.g. \"ec2\").\n- class_name (str): The class name associated with the service (e.g. \"EC2\").\n- override_boto3_name (str, optional): An optional name to override the default boto3 name for the service.\n\nAttributes initialized:\n- self.name: Stores the service name.\n- self.class_name: Stores the corresponding class name.\n- self.boto3_version: Initialized to the constant LATEST, representing the latest version of the service.\n- self.override_boto3_name: Stores the overridden boto3 name if provided. If not, it defaults to an empty string.\n\nThis constructor interacts with the class constants such as LATEST, which is used to set the default boto3 version for the service.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceNameCatalog.add\n  - CLASS SIGNATURE: class ServiceNameCatalog:\n  - SIGNATURE: def add(cls, name: str, class_name: str) -> ServiceName:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a new `ServiceName` to the catalog or modify an existing one.\n\nThis class method checks if the provided `name` already exists in the `ITEMS` dictionary. If it does, it updates the `class_name` of the existing `ServiceName` instance and returns it. If it does not exist, it creates a new `ServiceName` instance and adds it to `ITEMS`, then returns the new instance.\n\nParameters:\n- name (str): The name of the service to be added or modified.\n- class_name (str): The class name associated with the service.\n\nReturns:\n- ServiceName: An instance of the `ServiceName` class, representing either the newly added service or the modified existing service.\n\nThe `ITEMS` dictionary is a class-level attribute that serves as a catalog mapping service names to their corresponding `ServiceName` instances, facilitating lookups and ensuring uniqueness in the catalog.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/logger.py\n\n- FUNCTION NAME: get_logger\n  - SIGNATURE: def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a configured logger instance.\n\nThis function initializes and returns a logging.Logger instance with a specified log level and name. If the logger does not have any handlers, it creates a StreamHandler, sets a custom formatter for the output, and adds it to the logger. The log level can be adjusted, affecting all existing handlers as well.\n\nParameters:\n    level (int | None): Optional log level. If None, defaults to logging.NOTSET.\n    name (str): The name of the logger, defaulting to LOGGER_NAME from mypy_boto3_builder.constants.\n\nReturns:\n    logging.Logger: The configured logger instance.\n\nDependencies:\n    The function relies on the logging module from the Python standard library. The LOGGER_NAME constant is sourced from the mypy_boto3_builder.constants module, defining the default name of the logger.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/main.py:get_selected_service_names\n\n## FILE 7: mypy_boto3_builder/main.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(args: CLINamespace) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nRun the builder by processing command-line arguments to generate AWS service client products.\n\nParameters:\n    args (CLINamespace): Parsed command-line arguments, including logging level, output path, service names to include, and product types to generate.\n\nReturns:\n    None\n\nThis function initializes the Jinja template manager, establishes a Boto3 session, and retrieves available services. It logs the number of discovered services and handles listing services if requested. It then selects specified service names, determines master service names (based on whether partial overload is enabled), and generates the requested product(s) using the `generate_product` function. \n\nConstants and functions used:\n- `get_logger`: retrieves a logger instance configured with the specified log level.\n- `initialize_jinja_manager`: sets up the Jinja template manager for generating output.\n- `get_boto3_session`: creates a new Boto3 session to interact with AWS services.\n- `get_botocore_session`: provides a Botocore session to obtain available service names.\n- `get_available_service_names`: fetches the list of services supported by the current Boto3 version.\n- `get_selected_service_names`: filters the services based on user input.\n- `args.output_path`: determines where the generated products will be saved, ensuring the directory exists.\n- `args.products`: specifies which AWS service products to generate.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/boto3_utils.py:get_boto3_session\n    - mypy_boto3_builder/main.py:generate_product\n    - mypy_boto3_builder/logger.py:get_logger\n    - mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session\n    - mypy_boto3_builder/enums/product.py:Product:__str__\n    - mypy_boto3_builder/main.py:get_selected_service_names\n    - mypy_boto3_builder/main.py:initialize_jinja_manager\n    - mypy_boto3_builder/main.py:main\n\n- FUNCTION NAME: get_selected_service_names\n  - SIGNATURE: def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a list of selected service names based on user input and available services.\n\nThis function processes a list of selected service names as strings, allowing support for special keywords such as `ServiceName.ALL` to return all available services, `ServiceName.UPDATED` to return only those services updated in the current Boto3 release, and `ServiceName.ESSENTIAL` to return a predefined essential set of services. The function interacts with the `BotocoreChangelog` to fetch updated services and utilizes the `ServiceNameCatalog` to manage available service names.\n\nParameters:\n    selected (Iterable[str]): A collection of service names as strings selected by the user.\n    available (Iterable[ServiceName]): A collection of all available ServiceNames from the current Boto3 release.\n\nReturns:\n    list[ServiceName]: A list of ServiceNames that correspond to the user's selection, filtered by availability.\n\nConstants Used:\n    ServiceName.ALL: Represents a request for all available services.\n    ServiceName.UPDATED: Indicates the selection of only services that have been updated.\n    ServiceName.ESSENTIAL: Represents a request for essential services.\n    ServiceName.ESSENTIAL_NAMES: A predefined list of essential service names.\nThese constants are used to direct the function's behavior in filtering service names as per user requirements.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/botocore_changelog.py:BotocoreChangelog:__init__\n    - mypy_boto3_builder/utils/version_getters.py:get_botocore_version\n    - mypy_boto3_builder/logger.py:get_logger\n\n- FUNCTION NAME: main\n  - SIGNATURE: def main() -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nCLI entrypoint that initiates the builder process for generating AWS service libraries. It parses command-line arguments using `parse_args()` and then calls the `run()` function with the parsed arguments. The `args` contains various options including the services to generate, the desired output path, and the log level.\n\nThis function does not return a value. It interacts with user-defined command-line inputs to execute the appropriate actions based on the specified options, ultimately affecting how the library generation occurs based on user preferences.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/main.py:run\n    - mypy_boto3_builder/cli_parser.py:parse_args\n\n- FUNCTION NAME: get_available_service_names\n  - SIGNATURE: def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a list of service names supported by Boto3.\n\nThis function takes a Botocore session, queries available services, and constructs a list of ServiceName objects representing each service. It extracts service metadata and uses the `get_botocore_class_name` utility to derive class names for the services. The resulting list is populated from the `ServiceNameCatalog`, which serves as a registry for all service names and their associated classes.\n\nParameters:\n    session (BotocoreSession): A valid Boto3 session used to fetch available services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects, each representing a supported Boto3 service.\n\nDependencies:\n- `get_botocore_class_name`: A utility that retrieves the class name from metadata.\n- `ServiceNameCatalog`: A catalog that manages the registration of service names.\n- The method accesses the Botocore session to call `get_available_services` and `get_service_data` for fetching data.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_botocore_class_name\n    - mypy_boto3_builder/service_name.py:ServiceNameCatalog:add\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/utils/botocore_changelog.py": "\"\"\"\nParser for boto3 changelog.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport re\nimport requests\nfrom mypy_boto3_builder.constants import REQUEST_TIMEOUT\nfrom mypy_boto3_builder.exceptions import BuildEnvError\n\nclass BotocoreChangelog:\n    \"\"\"\n    Parser for boto3 changelog.\n    \"\"\"\n    URL = 'https://raw.githubusercontent.com/boto/botocore/develop/CHANGELOG.rst'\n    SERVICE_NAME_RE = re.compile('``(\\\\S+)``')\n\n    @classmethod\n    def _get_changelog(cls) -> str:\n        response = requests.get(cls.URL, timeout=REQUEST_TIMEOUT)\n        if not response.ok:\n            raise BuildEnvError(f'Cannot retrieve {cls.URL}: {response.status_code} {response.text}') from None\n        return response.text\n\n    def _get_section(self, version: str) -> str:\n        result: list[str] = []\n        self._changelog = self._changelog or self._get_changelog()\n        found = False\n        for line in self._changelog.splitlines():\n            if line == version:\n                found = True\n                continue\n            if found and result and line.startswith('==='):\n                result.pop()\n                break\n            if found:\n                result.append(line)\n        return '\\n'.join(result[1:])\n\n    def fetch_updated(self, version: str) -> list[str]:\n        \"\"\"\n        Get a list of service names updated in `version` release.\n        \"\"\"\n        result: list[str] = []\n        section = self._get_section(version)\n        for match in self.SERVICE_NAME_RE.findall(section):\n            if match not in result:\n                result.append(match)\n        return result",
    "mypy_boto3_builder/cli_parser.py": "\"\"\"\nCLI parser.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport argparse\nimport enum\nimport logging\nfrom collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Any\nfrom mypy_boto3_builder.constants import PROG_NAME\nfrom mypy_boto3_builder.enums.product import Product\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.version import get_builder_version\n\ndef get_absolute_path(path: str) -> Path:\n    \"\"\"\n    Get absolute path from a string.\n\n    Arguments:\n        path -- String containing path.\n\n    Returns:\n        Absolute path.\n    \"\"\"\n    return Path(path).absolute()\n\nclass EnumListAction(argparse.Action):\n    \"\"\"\n    Argparse action for handling Enums.\n    \"\"\"\n\n    def __init__(self, type: type[enum.Enum], option_strings: Sequence[str], dest: str, default: Sequence[enum.Enum] | None=None, *, required: bool=False, **kwargs: str | None) -> None:\n        self._enum_class = type\n        super().__init__(choices=tuple((e.value for e in self._enum_class)), option_strings=option_strings, default=default, dest=dest, type=None, required=required, **kwargs)\n\n    def __call__(self, parser: argparse.ArgumentParser, namespace: argparse.Namespace, value: str | Sequence[Any] | None, _option_string: str | None=None) -> None:\n        \"\"\"\n        Convert value back into an Enum.\n        \"\"\"\n        value_list: list[str] = []\n        if isinstance(value, str):\n            value_list.append(value)\n        if isinstance(value, list):\n            value_list.extend([i for i in value if isinstance(i, str)])\n        enum_values = [self._enum_class(i) for i in value_list]\n        setattr(namespace, self.dest, enum_values)\n\n@dataclass(kw_only=True, slots=True)\nclass CLINamespace:\n    \"\"\"\n    CLI arguments namespace.\n    \"\"\"\n    log_level: int\n    output_path: Path\n    service_names: list[str]\n    build_version: str\n    installed: bool\n    products: list[Product]\n    list_services: bool\n    partial_overload: bool\n    skip_published: bool\n    disable_smart_version: bool\n    download_static_stubs: bool",
    "mypy_boto3_builder/utils/version_getters.py": "\"\"\"\nUtils for getting underlying package versions.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom mypy_boto3_builder.exceptions import BuildEnvError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.pypi_manager import PyPIManager\n\ndef get_boto3_version() -> str:\n    \"\"\"\n    Get boto3 package version.\n    \"\"\"\n    try:\n        from boto3 import __version__ as version\n    except ImportError as e:\n        raise BuildEnvError('boto3 is not installed') from e\n    return f'{version}'\n\n@functools.cache\ndef get_aiobotocore_version() -> str:\n    \"\"\"\n    Get aiobotocore package version.\n    \"\"\"\n    try:\n        from aiobotocore import __version__ as version\n    except ImportError:\n        pass\n    else:\n        return f'{version}'\n    logger = get_logger()\n    logger.warning('aiobotocore is not installed, using latest version from PyPI')\n    pypi_manager = PyPIManager('aiobotocore')\n    return pypi_manager.get_latest_stable_version()\n\n@functools.cache\ndef get_aioboto3_version() -> str:\n    \"\"\"\n    Get aioboto3 package version.\n    \"\"\"\n    try:\n        from aioboto3 import __version__ as version\n    except ImportError:\n        pass\n    else:\n        return f'{version}'\n    logger = get_logger()\n    logger.warning('aioboto3 is not installed, using latest version from PyPI')\n    pypi_manager = PyPIManager('aioboto3')\n    return pypi_manager.get_latest_stable_version()",
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\nRESERVED_NAMES: Final = {*dir(typing), *dir(builtins), *keyword.kwlist}\nAWS_LINK_RE: Final = re.compile('`([^`]+\\\\S)\\\\s*<https://(\\\\S+)>`\\\\_*')\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({'\u2019': \"'\", '\u2013': '-'})\n\ndef get_class_prefix(func_name: str) -> str:\n    \"\"\"\n    Get a valid Python class prefix from `func_name`.\n\n    Arguments:\n        func_name -- Any string.\n\n    Returns:\n        String with a class prefix.\n    \"\"\"\n    parts = [capitalize(i) for i in func_name.split('_') if i]\n    return ''.join(parts)\n\ndef get_anchor_link(text: str) -> str:\n    \"\"\"\n    Convert header to markdown anchor link.\n    \"\"\"\n    return text.strip().replace(' ', '-').replace('.', '').lower()\n\ndef is_reserved(word: str) -> bool:\n    \"\"\"\n    Check whether variable name conflicts with Python reserved names.\n    \"\"\"\n    return word in RESERVED_NAMES\n\ndef get_short_docstring(doc: str) -> str:\n    \"\"\"\n    Create a short docstring from boto3 documentation.\n\n    Trims docstring to 300 chars.\n    Removes double and triple backticks.\n    Stops on `**Request syntax**` and `::`.\n    Ensures that backticks are closed.\n    Replaces `Text <link>` with [Text](link).\n    Wraps docstring to 80 chars.\n    \"\"\"\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f'{doc[:DOCSTRING_MAX_LENGTH - 3]}...'\n    result: list[str] = []\n    if not doc:\n        return ''\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix('::')\n        if not line:\n            continue\n        if line.startswith(':') or line.lower().startswith('**request syntax**'):\n            break\n        if '. ' in line:\n            result.append(line.split('. ')[0])\n            break\n        result.append(line)\n        if line.endswith('.'):\n            break\n    result_str = ' '.join(result).replace('```', '`').replace('``', '`').replace('\\n', ' ').strip()\n    return clean_artifacts(result_str)\n\ndef clean_artifacts(line: str) -> str:\n    \"\"\"\n    Remove common artifacts in botocre docs.\n    \"\"\"\n    if line.count('`') % 2:\n        line = f'{line}`'\n    if line and (not line.endswith('.')):\n        line = f'{line}.'\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n    if '<https:' in line:\n        line = AWS_LINK_RE.sub('[\\\\g<1>](https://\\\\g<2>)', line)\n        line = line.replace('https\\\\:', 'https:')\n        line = line.replace('neptune-db\\\\:', 'neptune-db:')\n    return line\n\ndef textwrap(text: str, width: int=DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"\n    Wrap text to `width` chars.\n    \"\"\"\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(' ', 0, width)\n            if space_index < 0:\n                space_index = line.find(' ', width)\n            if space_index < 0:\n                result.append(line)\n                break\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n    return '\\n'.join(result)\n\ndef get_type_def_name(*parts: str) -> str:\n    \"\"\"\n    Get a valid Python TypeDef class name from `parts`.\n\n    Examples:\n        ```python\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\n        ```\n    \"\"\"\n    if not parts:\n        raise TypeAnnotationError('At least one part is required')\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = ''.join(parts_camelcased)\n    return f'{name}TypeDef'\n\ndef capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f'{s[:1].upper()}{s[1:]}'\n\ndef xform_name(name: str, sep: str='_') -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError('Separator is required')\n    return botocore_xform_name(name, sep)\n\ndef get_pypi_link(package_name: str) -> str:\n    \"\"\"\n    Get link to PyPI.\n    \"\"\"\n    if not package_name:\n        raise BuildInternalError('package_name is required')\n    return f'https://pypi.org/project/{package_name}/'\n\ndef get_copyright() -> str:\n    \"\"\"\n    Get copyright notice.\n    \"\"\"\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f'Copyright {now.year} Vlad Emelianov'",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport logging\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n__all__ = ('get_logger',)",
    "mypy_boto3_builder/main.py": "\"\"\"\nMain entrypoint for builder.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport datetime\nimport sys\nimport warnings\nfrom collections.abc import Iterable, Sequence\nfrom botocore.session import Session as BotocoreSession\nfrom mypy_boto3_builder.cli_parser import CLINamespace, parse_args\nfrom mypy_boto3_builder.constants import BUILDER_REPO_URL, PACKAGE_NAME\nfrom mypy_boto3_builder.enums.product import Product, ProductLibrary\nfrom mypy_boto3_builder.generators.aioboto3_generator import AioBoto3Generator\nfrom mypy_boto3_builder.generators.aiobotocore_generator import AioBotocoreGenerator\nfrom mypy_boto3_builder.generators.base_generator import BaseGenerator\nfrom mypy_boto3_builder.generators.boto3_generator import Boto3Generator\nfrom mypy_boto3_builder.jinja_manager import JinjaManager\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.utils.boto3_utils import get_boto3_session, get_botocore_session\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, get_botocore_class_name, get_copyright\nfrom mypy_boto3_builder.utils.type_checks import is_literal, is_type_def, is_type_parent, is_typed_dict, is_union\nfrom mypy_boto3_builder.utils.version import get_builder_version\nfrom mypy_boto3_builder.utils.version_getters import get_botocore_version\n\ndef get_generator_cls(product: Product) -> type[BaseGenerator]:\n    \"\"\"\n    Get Generator class for a product.\n    \"\"\"\n    library = product.get_library()\n    match library:\n        case ProductLibrary.boto3:\n            return Boto3Generator\n        case ProductLibrary.aiobotocore:\n            return AioBotocoreGenerator\n        case ProductLibrary.aioboto3:\n            return AioBoto3Generator\n\ndef generate_product(product: Product, args: CLINamespace, service_names: Sequence[ServiceName], master_service_names: Sequence[ServiceName]) -> None:\n    \"\"\"\n    Generate a selected product.\n\n    Arguments:\n        product -- Product to generate\n        args -- CLI namespace\n        service_names -- Selected service names\n        master_service_names -- Service names included in master\n    \"\"\"\n    generator_cls = get_generator_cls(product)\n    generator = generator_cls(service_names=service_names, master_service_names=master_service_names, config=args, version=args.build_version, cleanup=True)\n    generator.generate_product(product.get_type())\n    generator.cleanup_temporary_files()\n\ndef initialize_jinja_manager() -> None:\n    \"\"\"\n    Initialize Jinja manager with globals.\n    \"\"\"\n    jinja_manager = JinjaManager.singleton()\n    jinja_manager.update_globals(builder_version=get_builder_version(), current_year=str(datetime.datetime.now(datetime.timezone.utc).year), get_anchor_link=get_anchor_link, len=len, sorted=sorted, repr=repr, builder_package_name=PACKAGE_NAME, builder_repo_url=BUILDER_REPO_URL, copyright=get_copyright(), is_typed_dict=is_typed_dict, is_union=is_union, is_literal=is_literal, is_type_def=is_type_def, is_type_parent=is_type_parent)\nif __name__ == '__main__':\n    main()"
  },
  "call_tree": {
    "tests/test_main.py:TestMain:test_get_selected_service_names": {
      "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
      "mypy_boto3_builder/main.py:get_selected_service_names": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {},
        "mypy_boto3_builder/utils/botocore_changelog.py:BotocoreChangelog:__init__": {}
      }
    },
    "tests/test_main.py:TestMain:test_get_available_service_names": {
      "mypy_boto3_builder/main.py:get_available_service_names": {
        "mypy_boto3_builder/utils/strings.py:get_botocore_class_name": {
          "mypy_boto3_builder/utils/strings.py:capitalize": {}
        },
        "mypy_boto3_builder/service_name.py:ServiceNameCatalog:add": {
          "mypy_boto3_builder/service_name.py:ServiceName:__init__": {}
        }
      }
    },
    "tests/test_main.py:TestMain:test_main": {
      "mypy_boto3_builder/main.py:main": {
        "mypy_boto3_builder/cli_parser.py:parse_args": {
          "mypy_boto3_builder/utils/version.py:get_builder_version": {},
          "mypy_boto3_builder/cli_parser.py:EnumListAction:__init__": {},
          "mypy_boto3_builder/cli_parser.py:get_absolute_path": {}
        },
        "mypy_boto3_builder/main.py:run": {
          "mypy_boto3_builder/logger.py:get_logger": {},
          "mypy_boto3_builder/main.py:initialize_jinja_manager": {
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:singleton": {
              "mypy_boto3_builder/jinja_manager.py:JinjaManager:__init__": {}
            },
            "mypy_boto3_builder/utils/version.py:get_builder_version": {},
            "mypy_boto3_builder/utils/strings.py:get_copyright": {},
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:update_globals": {}
          },
          "mypy_boto3_builder/utils/boto3_utils.py:get_boto3_session": {},
          "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
          "mypy_boto3_builder/main.py:get_selected_service_names": {
            "mypy_boto3_builder/logger.py:get_logger": {},
            "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
          },
          "mypy_boto3_builder/enums/product.py:Product:__str__": {},
          "mypy_boto3_builder/main.py:generate_product": {
            "mypy_boto3_builder/main.py:get_generator_cls": {
              "mypy_boto3_builder/enums/product.py:Product:get_library": {}
            },
            "mypy_boto3_builder/enums/product.py:Product:get_type": {}
          }
        }
      }
    }
  }
}