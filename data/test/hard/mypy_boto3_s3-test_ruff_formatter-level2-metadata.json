{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_ruff_formatter",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/writers/test_ruff_formatter.py",
  "test_code": "import tempfile\nfrom pathlib import Path\n\nfrom mypy_boto3_builder.writers.ruff_formatter import RuffFormatter\n\n\nclass TestRuffFormatter:\n    def test_format(self) -> None:\n        formatter = RuffFormatter(\n            known_first_party=[\"local\"],\n            known_third_party=[\"extra\", \"local\"],\n        )\n        with tempfile.NamedTemporaryFile(\"+w\", encoding=\"utf-8\") as f:\n            f.write(\"import os\\n\")\n            f.write(\"import datetime\\n\")\n            f.write(\"import black\\n\")\n            f.write(\"import local\\n\")\n            f.write(\"import extra.new\\n\")\n            f.write(\"a   =datetime.datetime.now()\\n\")\n            f.flush()\n            formatter.format_python([Path(f.name)])\n            assert Path(f.name).read_text(encoding=\"utf-8\") == (\n                \"import datetime\\n\"\n                \"import os\\n\"\n                \"\\n\"\n                \"import black\\n\"\n                \"import extra.new\\n\"\n                \"\\n\"\n                \"import local\\n\"\n                \"\\n\"\n                \"a = datetime.datetime.now()\\n\"\n            )\n\n    def test_format_markdown(self) -> None:\n        formatter = RuffFormatter()\n        assert not formatter.format_markdown(\"\")\n        assert (\n            formatter.format_markdown(\"# a\\ntest\\n## b\\n## c\\ntest2\")\n            == \"# a\\ntest\\n## b\\n## c\\ntest2\"\n        )\n        assert formatter.format_markdown(\"# a\\n```python\\na=5\\n```\") == \"# a\\n```python\\na = 5\\n```\"\n        assert formatter.format_markdown(\"# a\\n```bash\\na=5\\n```\") == \"# a\\n```bash\\na=5\\n```\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/writers/ruff_formatter.py": "\"\"\"\nRuff formatter.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport json\nimport subprocess\nimport sys\nimport tempfile\nfrom collections.abc import Iterable, Sequence\nfrom pathlib import Path\n\nfrom mypy_boto3_builder.constants import LINE_LENGTH, SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.path import print_path\n\n\nclass RuffError(RuntimeError):\n    \"\"\"\n    Ruff error.\n    \"\"\"\n\n\nclass RuffFormatter:\n    \"\"\"\n    Ruff formatter.\n    \"\"\"\n\n    def __init__(\n        self,\n        known_first_party: Sequence[str] = (),\n        known_third_party: Sequence[str] = (),\n    ) -> None:\n        self.logger = get_logger()\n        self._target_version = self._get_target_version()\n        self._known_first_party = list(known_first_party)\n        self._known_third_party = [i for i in known_third_party if i not in self._known_first_party]\n\n    @staticmethod\n    def _get_target_version() -> str:\n        min_version = min(v for v in SUPPORTED_PY_VERSIONS if len(v) > 1)\n        return f\"py{min_version[0]}{min_version[1]}\"\n\n    def format_python(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python files with `ruff`.\n\n        Arguments:\n            path -- Target path.\n        \"\"\"\n        self.sort_imports(paths)\n        self.format_code(paths)\n\n    def _get_config_cli(self) -> list[str]:\n        overrides = [\n            f'target-version = \"{self._target_version}\"',\n            f\"line-length = {LINE_LENGTH}\",\n            'format.quote-style = \"double\"',\n            'format.line-ending = \"lf\"',\n            f\"lint.isort.known-first-party = {json.dumps(self._known_first_party)}\",\n            f\"lint.isort.known-third-party = {json.dumps(self._known_third_party)}\",\n        ]\n        result: list[str] = []\n        for option in overrides:\n            result.extend([\"--config\", option])\n\n        return result\n\n    def sort_imports(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Sort import lines with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output(\n                [\n                    sys.executable,\n                    \"-m\",\n                    \"ruff\",\n                    \"check\",\n                    \"--target-version\",\n                    self._target_version,\n                    *self._get_config_cli(),\n                    \"--select\",\n                    \"I\",\n                    \"--fix\",\n                    \"--isolated\",\n                    *(path.as_posix() for path in paths),\n                ],\n                stderr=subprocess.STDOUT,\n            )\n        except subprocess.CalledProcessError as e:\n            self.logger.warning(\n                f\"Sorting imports failed for paths {[print_path(path) for path in paths]}\",\n            )\n            self.logger.warning(e.output.decode())\n            raise RuffError(f\"Sorting imports failed with status {e.returncode}\") from None\n\n    def format_code(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python code with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output(\n                [\n                    sys.executable,\n                    \"-m\",\n                    \"ruff\",\n                    \"format\",\n                    \"--target-version\",\n                    self._target_version,\n                    *self._get_config_cli(),\n                    \"--isolated\",\n                    *(path.as_posix() for path in paths),\n                ],\n                stderr=subprocess.STDOUT,\n            )\n        except subprocess.CalledProcessError as e:\n            raise RuffError(f\"Formatting failed: {e.output}, paths: {paths}\") from None\n\n    def format_strings(self, codes: Iterable[str]) -> list[str]:\n        \"\"\"\n        Format python code as strings.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as dir_name:\n            paths: list[Path] = []\n            for index, code in enumerate(codes):\n                file_path = Path(dir_name) / f\"temp_{index}.py\"\n                file_path.write_text(code)\n                paths.append(file_path)\n\n            self.format_code(paths)\n            return [path.read_text().rstrip(\"\\n\") for path in paths]\n\n    def format_markdown(self, text: str) -> str:\n        \"\"\"\n        Format python codeblocks in markdown.\n        \"\"\"\n        blocks = text.split(\"\\n```\")\n        format_blocks: list[str] = []\n        format_block_indices: list[int] = []\n        for index, block in enumerate(blocks):\n            if block.startswith(\"python\"):\n                format_blocks.append(block)\n                format_block_indices.append(index)\n\n        if format_blocks:\n            for index, formatted_block in enumerate(self.format_strings(format_blocks)):\n                block_index = format_block_indices[index]\n                blocks[block_index] = formatted_block\n        return \"\\n```\".join(blocks)\n",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport logging\n\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n\n__all__ = (\"get_logger\",)\n\n\ndef get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/writers/ruff_formatter.py": {
      "RuffFormatter.__init__": {
        "code": "    def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:\n        \"\"\"Initialize a RuffFormatter instance to format Python code and manage imports.\n\nParameters:\n- known_first_party (Sequence[str], optional): A sequence of known first-party package names. Default is an empty tuple.\n- known_third_party (Sequence[str], optional): A sequence of known third-party package names. Default is an empty tuple.\n\nThis constructor initializes a logger using the `get_logger()` function from the `mypy_boto3_builder.logger` module, determines the target version of Python using the `_get_target_version()` method, and stores the known first and third party imports. It ensures that the third-party imports do not overlap with the first-party ones. \n\nThe constants `SUPPORTED_PY_VERSIONS` and `LINE_LENGTH` are used in the class, where `SUPPORTED_PY_VERSIONS` helps in determining the minimum Python version to target and `LINE_LENGTH` defines the maximum allowed line length for formatting.\"\"\"\n        self.logger = get_logger()\n        self._target_version = self._get_target_version()\n        self._known_first_party = list(known_first_party)\n        self._known_third_party = [i for i in known_third_party if i not in self._known_first_party]",
        "docstring": "Initialize a RuffFormatter instance to format Python code and manage imports.\n\nParameters:\n- known_first_party (Sequence[str], optional): A sequence of known first-party package names. Default is an empty tuple.\n- known_third_party (Sequence[str], optional): A sequence of known third-party package names. Default is an empty tuple.\n\nThis constructor initializes a logger using the `get_logger()` function from the `mypy_boto3_builder.logger` module, determines the target version of Python using the `_get_target_version()` method, and stores the known first and third party imports. It ensures that the third-party imports do not overlap with the first-party ones. \n\nThe constants `SUPPORTED_PY_VERSIONS` and `LINE_LENGTH` are used in the class, where `SUPPORTED_PY_VERSIONS` helps in determining the minimum Python version to target and `LINE_LENGTH` defines the maximum allowed line length for formatting.",
        "signature": "def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter._get_target_version": {
        "code": "    def _get_target_version() -> str:\n        \"\"\"Determine the target Python version for formatting.\n\nThis static method calculates the minimum supported Python version from the\nglobal constant `SUPPORTED_PY_VERSIONS`, which is defined in the `mypy_boto3_builder.constants`.\nThe result is returned in the format 'pyXY', where X and Y are the major and\nminor version numbers respectively. This version string is used for configuring\nthe behavior of the `ruff` formatter.\n\nReturns:\n    str: The target Python version in the format 'pyXY'.\n\nDependencies:\n- `SUPPORTED_PY_VERSIONS`: A constant that contains a list of supported Python version tuples.\"\"\"\n        min_version = min((v for v in SUPPORTED_PY_VERSIONS if len(v) > 1))\n        return f'py{min_version[0]}{min_version[1]}'",
        "docstring": "Determine the target Python version for formatting.\n\nThis static method calculates the minimum supported Python version from the\nglobal constant `SUPPORTED_PY_VERSIONS`, which is defined in the `mypy_boto3_builder.constants`.\nThe result is returned in the format 'pyXY', where X and Y are the major and\nminor version numbers respectively. This version string is used for configuring\nthe behavior of the `ruff` formatter.\n\nReturns:\n    str: The target Python version in the format 'pyXY'.\n\nDependencies:\n- `SUPPORTED_PY_VERSIONS`: A constant that contains a list of supported Python version tuples.",
        "signature": "def _get_target_version() -> str:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_python": {
        "code": "    def format_python(self, paths: Sequence[Path]) -> None:\n        \"\"\"Format Python files using `ruff` for import sorting and code formatting.\n\nParameters:\n    paths (Sequence[Path]): A sequence of Path objects representing the target Python files to format.\n\nThis method first sorts the import statements in the specified Python files by calling the `sort_imports` method, and then formats the code according to the defined rules by calling the `format_code` method. It utilizes the `_target_version` attribute to configure the target Python version for formatting, determined by the `_get_target_version` method, and relies on constants such as `LINE_LENGTH` defined in the `mypy_boto3_builder.constants` module for any line length specifications during formatting.\"\"\"\n        '\\n        Format python files with `ruff`.\\n\\n        Arguments:\\n            path -- Target path.\\n        '\n        self.sort_imports(paths)\n        self.format_code(paths)",
        "docstring": "Format Python files using `ruff` for import sorting and code formatting.\n\nParameters:\n    paths (Sequence[Path]): A sequence of Path objects representing the target Python files to format.\n\nThis method first sorts the import statements in the specified Python files by calling the `sort_imports` method, and then formats the code according to the defined rules by calling the `format_code` method. It utilizes the `_target_version` attribute to configure the target Python version for formatting, determined by the `_get_target_version` method, and relies on constants such as `LINE_LENGTH` defined in the `mypy_boto3_builder.constants` module for any line length specifications during formatting.",
        "signature": "def format_python(self, paths: Sequence[Path]) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.sort_imports": {
        "code": "    def sort_imports(self, paths: Sequence[Path]) -> None:\n        \"\"\"Sort import lines in the specified Python files using Ruff.\n\nThis method utilizes the Ruff tool to check and fix import statements in the provided file paths. It constructs a command that includes the target Python version derived from the `_target_version` attribute and additional configuration options obtained from `_get_config_cli()`. The method handles potential errors during the execution of the Ruff command and logs warnings if the sorting process fails.\n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to sort imports in.\n\nReturns:\n- None: This method does not return a value. However, it raises a `RuffError` if the sorting fails.\n\nDependencies:\n- `subprocess`: Used to run the Ruff commands.\n- `sys.executable`: Ensures the Ruff command is executed using the current Python interpreter.\n- `self._target_version`: A string representing the target Python version, defined by `_get_target_version()`.\n- `self._get_config_cli()`: A method that generates command-line arguments for configuring Ruff, including settings like line length and known imports.\n- `self.logger`: An instance of a logging utility for capturing warnings during execution.\"\"\"\n        '\\n        Sort import lines with `ruff`.\\n        '\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'check', '--target-version', self._target_version, *self._get_config_cli(), '--select', 'I', '--fix', '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            self.logger.warning(f'Sorting imports failed for paths {[print_path(path) for path in paths]}')\n            self.logger.warning(e.output.decode())\n            raise RuffError(f'Sorting imports failed with status {e.returncode}') from None",
        "docstring": "Sort import lines in the specified Python files using Ruff.\n\nThis method utilizes the Ruff tool to check and fix import statements in the provided file paths. It constructs a command that includes the target Python version derived from the `_target_version` attribute and additional configuration options obtained from `_get_config_cli()`. The method handles potential errors during the execution of the Ruff command and logs warnings if the sorting process fails.\n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to sort imports in.\n\nReturns:\n- None: This method does not return a value. However, it raises a `RuffError` if the sorting fails.\n\nDependencies:\n- `subprocess`: Used to run the Ruff commands.\n- `sys.executable`: Ensures the Ruff command is executed using the current Python interpreter.\n- `self._target_version`: A string representing the target Python version, defined by `_get_target_version()`.\n- `self._get_config_cli()`: A method that generates command-line arguments for configuring Ruff, including settings like line length and known imports.\n- `self.logger`: An instance of a logging utility for capturing warnings during execution.",
        "signature": "def sort_imports(self, paths: Sequence[Path]) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_code": {
        "code": "    def format_code(self, paths: Sequence[Path]) -> None:\n        \"\"\"Format Python code using the `ruff` formatter.\n\nThis method takes a sequence of file paths (as Path objects) and formats the corresponding Python code in each file using the `ruff` formatting tool. It constructs a command line call to `ruff`, passing necessary configuration options such as the target Python version and line length, both defined as constants in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nRaises:\n- RuffError: If the `ruff` command fails during formatting, the method logs a warning and raises a RuffError with details about the failure.\n\nConstants:\n- self._target_version: A string representing the target Python version determined by the `_get_target_version` method.\n- LINE_LENGTH: A constant from `mypy_boto3_builder.constants` that sets the maximum line length for the formatted code.\"\"\"\n        '\\n        Format python code with `ruff`.\\n        '\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'format', '--target-version', self._target_version, *self._get_config_cli(), '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            raise RuffError(f'Formatting failed: {e.output}, paths: {paths}') from None",
        "docstring": "Format Python code using the `ruff` formatter.\n\nThis method takes a sequence of file paths (as Path objects) and formats the corresponding Python code in each file using the `ruff` formatting tool. It constructs a command line call to `ruff`, passing necessary configuration options such as the target Python version and line length, both defined as constants in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nRaises:\n- RuffError: If the `ruff` command fails during formatting, the method logs a warning and raises a RuffError with details about the failure.\n\nConstants:\n- self._target_version: A string representing the target Python version determined by the `_get_target_version` method.\n- LINE_LENGTH: A constant from `mypy_boto3_builder.constants` that sets the maximum line length for the formatted code.",
        "signature": "def format_code(self, paths: Sequence[Path]) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_strings": {
        "code": "    def format_strings(self, codes: Iterable[str]) -> list[str]:\n        \"\"\"Format multiple Python code snippets as strings by writing them to temporary files and applying formatting with `ruff`.\n\nParameters:\n    codes (Iterable[str]): An iterable of Python code snippets as strings that need to be formatted.\n\nReturns:\n    list[str]: A list of formatted Python code snippets as strings, each stripped of trailing newlines.\n\nSide Effects:\n    Creates temporary files in a temporary directory to hold each code snippet for formatting purposes. The method uses `format_code` to invoke `ruff` for the actual formatting of the code, ensuring that the code adheres to the style defined in the class instance.\n\nDependencies:\n    - `tempfile`: Used to create a temporary directory for storing code snippets.\n    - `Path`: From `pathlib`, used to handle file paths and operations.\n    - `format_code`: A method of the `RuffFormatter` class that formats the Python files with `ruff`.\"\"\"\n        '\\n        Format python code as strings.\\n        '\n        with tempfile.TemporaryDirectory() as dir_name:\n            paths: list[Path] = []\n            for index, code in enumerate(codes):\n                file_path = Path(dir_name) / f'temp_{index}.py'\n                file_path.write_text(code)\n                paths.append(file_path)\n            self.format_code(paths)\n            return [path.read_text().rstrip('\\n') for path in paths]",
        "docstring": "Format multiple Python code snippets as strings by writing them to temporary files and applying formatting with `ruff`.\n\nParameters:\n    codes (Iterable[str]): An iterable of Python code snippets as strings that need to be formatted.\n\nReturns:\n    list[str]: A list of formatted Python code snippets as strings, each stripped of trailing newlines.\n\nSide Effects:\n    Creates temporary files in a temporary directory to hold each code snippet for formatting purposes. The method uses `format_code` to invoke `ruff` for the actual formatting of the code, ensuring that the code adheres to the style defined in the class instance.\n\nDependencies:\n    - `tempfile`: Used to create a temporary directory for storing code snippets.\n    - `Path`: From `pathlib`, used to handle file paths and operations.\n    - `format_code`: A method of the `RuffFormatter` class that formats the Python files with `ruff`.",
        "signature": "def format_strings(self, codes: Iterable[str]) -> list[str]:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_markdown": {
        "code": "    def format_markdown(self, text: str) -> str:\n        \"\"\"Format markdown text by processing Python code blocks for formatting.\n\nParameters:\n    text (str): The input markdown text containing Python code blocks.\n\nReturns:\n    str: The markdown text with formatted Python code blocks.\n\nThis method identifies code blocks in the given markdown text that start with the language identifier \"python\". It extracts these blocks, formats them using the `format_strings` method, and then reinserts the formatted code back into the original text. The `format_strings` method creates temporary files for formatting, which are then read back for the final output. This method depends on the `format_strings` method for actual code formatting, and utilizes temporary directory management to handle files safely.\"\"\"\n        '\\n        Format python codeblocks in markdown.\\n        '\n        blocks = text.split('\\n```')\n        format_blocks: list[str] = []\n        format_block_indices: list[int] = []\n        for index, block in enumerate(blocks):\n            if block.startswith('python'):\n                format_blocks.append(block)\n                format_block_indices.append(index)\n        if format_blocks:\n            for index, formatted_block in enumerate(self.format_strings(format_blocks)):\n                block_index = format_block_indices[index]\n                blocks[block_index] = formatted_block\n        return '\\n```'.join(blocks)",
        "docstring": "Format markdown text by processing Python code blocks for formatting.\n\nParameters:\n    text (str): The input markdown text containing Python code blocks.\n\nReturns:\n    str: The markdown text with formatted Python code blocks.\n\nThis method identifies code blocks in the given markdown text that start with the language identifier \"python\". It extracts these blocks, formats them using the `format_strings` method, and then reinserts the formatted code back into the original text. The `format_strings` method creates temporary files for formatting, which are then read back for the final output. This method depends on the `format_strings` method for actual code formatting, and utilizes temporary directory management to handle files safely.",
        "signature": "def format_markdown(self, text: str) -> str:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      }
    },
    "mypy_boto3_builder/logger.py": {
      "get_logger": {
        "code": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n    \"\"\"Retrieve a configured logger instance.\n\nThis function creates and returns a logger instance with a specified log level and name. If no handlers are attached to the logger, a new `StreamHandler` is created that outputs log messages to the console. The formatter is set to include the timestamp, logger name, log level, and message.\n\nParameters:\n    level (int | None): The logging level to set for the logger. If not specified, a default level of NOTSET is used.\n    name (str): The name of the logger, defaulting to the constant `LOGGER_NAME` imported from `mypy_boto3_builder.constants`.\n\nReturns:\n    logging.Logger: A configured logger instance.\n\nSide Effects:\n    If the logger does not already have handlers, a new handler is added which may affect the logging output. The log level is also adjusted for all handlers if specified.\"\"\"\n    '\\n    Get Logger instance.\\n\\n    Arguments:\\n        level -- Log level.\\n\\n    Returns:\\n        Overriden Logger.\\n    '\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s %(name)s: %(levelname)-7s %(message)s', datefmt='%H:%M:%S')\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n    return logger",
        "docstring": "Retrieve a configured logger instance.\n\nThis function creates and returns a logger instance with a specified log level and name. If no handlers are attached to the logger, a new `StreamHandler` is created that outputs log messages to the console. The formatter is set to include the timestamp, logger name, log level, and message.\n\nParameters:\n    level (int | None): The logging level to set for the logger. If not specified, a default level of NOTSET is used.\n    name (str): The name of the logger, defaulting to the constant `LOGGER_NAME` imported from `mypy_boto3_builder.constants`.\n\nReturns:\n    logging.Logger: A configured logger instance.\n\nSide Effects:\n    If the logger does not already have handlers, a new handler is added which may affect the logging output. The log level is also adjusted for all handlers if specified.",
        "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_ruff_formatter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 logger.py\n    \u2502   \u2514\u2500\u2500 get_logger\n    \u2514\u2500\u2500 writers/\n        \u2514\u2500\u2500 ruff_formatter.py\n            \u251c\u2500\u2500 RuffFormatter.__init__\n            \u251c\u2500\u2500 RuffFormatter._get_target_version\n            \u251c\u2500\u2500 RuffFormatter.format_code\n            \u251c\u2500\u2500 RuffFormatter.format_markdown\n            \u251c\u2500\u2500 RuffFormatter.format_python\n            \u251c\u2500\u2500 RuffFormatter.format_strings\n            \u2514\u2500\u2500 RuffFormatter.sort_imports\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for formatting Python and Markdown files with a focus on complying with established code style guidelines. It can reorder and structure Python imports based on custom categorization (e.g., separating first-party, third-party, and local imports) and apply consistent formatting rules to Python code blocks within Markdown files. This ensures a standardized and clean codebase that adheres to best practices, improving readability and maintainability for both developers and technical stakeholders. By automating formatting tasks, the module eliminates manual effort and reduces the risk of introducing stylistic inconsistencies in projects.\n\n## FILE 1: mypy_boto3_builder/writers/ruff_formatter.py\n\n- CLASS METHOD: RuffFormatter._get_target_version\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def _get_target_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine the target Python version for formatting.\n\nThis static method calculates the minimum supported Python version from the\nglobal constant `SUPPORTED_PY_VERSIONS`, which is defined in the `mypy_boto3_builder.constants`.\nThe result is returned in the format 'pyXY', where X and Y are the major and\nminor version numbers respectively. This version string is used for configuring\nthe behavior of the `ruff` formatter.\n\nReturns:\n    str: The target Python version in the format 'pyXY'.\n\nDependencies:\n- `SUPPORTED_PY_VERSIONS`: A constant that contains a list of supported Python version tuples.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.__init__\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a RuffFormatter instance to format Python code and manage imports.\n\nParameters:\n- known_first_party (Sequence[str], optional): A sequence of known first-party package names. Default is an empty tuple.\n- known_third_party (Sequence[str], optional): A sequence of known third-party package names. Default is an empty tuple.\n\nThis constructor initializes a logger using the `get_logger()` function from the `mypy_boto3_builder.logger` module, determines the target version of Python using the `_get_target_version()` method, and stores the known first and third party imports. It ensures that the third-party imports do not overlap with the first-party ones. \n\nThe constants `SUPPORTED_PY_VERSIONS` and `LINE_LENGTH` are used in the class, where `SUPPORTED_PY_VERSIONS` helps in determining the minimum Python version to target and `LINE_LENGTH` defines the maximum allowed line length for formatting.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.sort_imports\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def sort_imports(self, paths: Sequence[Path]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nSort import lines in the specified Python files using Ruff.\n\nThis method utilizes the Ruff tool to check and fix import statements in the provided file paths. It constructs a command that includes the target Python version derived from the `_target_version` attribute and additional configuration options obtained from `_get_config_cli()`. The method handles potential errors during the execution of the Ruff command and logs warnings if the sorting process fails.\n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to sort imports in.\n\nReturns:\n- None: This method does not return a value. However, it raises a `RuffError` if the sorting fails.\n\nDependencies:\n- `subprocess`: Used to run the Ruff commands.\n- `sys.executable`: Ensures the Ruff command is executed using the current Python interpreter.\n- `self._target_version`: A string representing the target Python version, defined by `_get_target_version()`.\n- `self._get_config_cli()`: A method that generates command-line arguments for configuring Ruff, including settings like line length and known imports.\n- `self.logger`: An instance of a logging utility for capturing warnings during execution.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_markdown\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_markdown(self, text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat markdown text by processing Python code blocks for formatting.\n\nParameters:\n    text (str): The input markdown text containing Python code blocks.\n\nReturns:\n    str: The markdown text with formatted Python code blocks.\n\nThis method identifies code blocks in the given markdown text that start with the language identifier \"python\". It extracts these blocks, formats them using the `format_strings` method, and then reinserts the formatted code back into the original text. The `format_strings` method creates temporary files for formatting, which are then read back for the final output. This method depends on the `format_strings` method for actual code formatting, and utilizes temporary directory management to handle files safely.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_strings\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_strings(self, codes: Iterable[str]) -> list[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat multiple Python code snippets as strings by writing them to temporary files and applying formatting with `ruff`.\n\nParameters:\n    codes (Iterable[str]): An iterable of Python code snippets as strings that need to be formatted.\n\nReturns:\n    list[str]: A list of formatted Python code snippets as strings, each stripped of trailing newlines.\n\nSide Effects:\n    Creates temporary files in a temporary directory to hold each code snippet for formatting purposes. The method uses `format_code` to invoke `ruff` for the actual formatting of the code, ensuring that the code adheres to the style defined in the class instance.\n\nDependencies:\n    - `tempfile`: Used to create a temporary directory for storing code snippets.\n    - `Path`: From `pathlib`, used to handle file paths and operations.\n    - `format_code`: A method of the `RuffFormatter` class that formats the Python files with `ruff`.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_code\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_code(self, paths: Sequence[Path]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat Python code using the `ruff` formatter.\n\nThis method takes a sequence of file paths (as Path objects) and formats the corresponding Python code in each file using the `ruff` formatting tool. It constructs a command line call to `ruff`, passing necessary configuration options such as the target Python version and line length, both defined as constants in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nRaises:\n- RuffError: If the `ruff` command fails during formatting, the method logs a warning and raises a RuffError with details about the failure.\n\nConstants:\n- self._target_version: A string representing the target Python version determined by the `_get_target_version` method.\n- LINE_LENGTH: A constant from `mypy_boto3_builder.constants` that sets the maximum line length for the formatted code.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_python\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_python(self, paths: Sequence[Path]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat Python files using `ruff` for import sorting and code formatting.\n\nParameters:\n    paths (Sequence[Path]): A sequence of Path objects representing the target Python files to format.\n\nThis method first sorts the import statements in the specified Python files by calling the `sort_imports` method, and then formats the code according to the defined rules by calling the `format_code` method. It utilizes the `_target_version` attribute to configure the target Python version for formatting, determined by the `_get_target_version` method, and relies on constants such as `LINE_LENGTH` defined in the `mypy_boto3_builder.constants` module for any line length specifications during formatting.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/logger.py\n\n- FUNCTION NAME: get_logger\n  - SIGNATURE: def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a configured logger instance.\n\nThis function creates and returns a logger instance with a specified log level and name. If no handlers are attached to the logger, a new `StreamHandler` is created that outputs log messages to the console. The formatter is set to include the timestamp, logger name, log level, and message.\n\nParameters:\n    level (int | None): The logging level to set for the logger. If not specified, a default level of NOTSET is used.\n    name (str): The name of the logger, defaulting to the constant `LOGGER_NAME` imported from `mypy_boto3_builder.constants`.\n\nReturns:\n    logging.Logger: A configured logger instance.\n\nSide Effects:\n    If the logger does not already have handlers, a new handler is added which may affect the logging output. The log level is also adjusted for all handlers if specified.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/writers/ruff_formatter.py": "\"\"\"\nRuff formatter.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport json\nimport subprocess\nimport sys\nimport tempfile\nfrom collections.abc import Iterable, Sequence\nfrom pathlib import Path\nfrom mypy_boto3_builder.constants import LINE_LENGTH, SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.path import print_path\n\nclass RuffError(RuntimeError):\n    \"\"\"\n    Ruff error.\n    \"\"\"\n\nclass RuffFormatter:\n    \"\"\"\n    Ruff formatter.\n    \"\"\"\n\n    def _get_config_cli(self) -> list[str]:\n        overrides = [f'target-version = \"{self._target_version}\"', f'line-length = {LINE_LENGTH}', 'format.quote-style = \"double\"', 'format.line-ending = \"lf\"', f'lint.isort.known-first-party = {json.dumps(self._known_first_party)}', f'lint.isort.known-third-party = {json.dumps(self._known_third_party)}']\n        result: list[str] = []\n        for option in overrides:\n            result.extend(['--config', option])\n        return result",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport logging\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n__all__ = ('get_logger',)"
  },
  "call_tree": {
    "tests/writers/test_ruff_formatter.py:TestRuffFormatter:test_format": {
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_target_version": {}
      },
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_python": {
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:sort_imports": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
        },
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_code": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
        }
      }
    },
    "tests/writers/test_ruff_formatter.py:TestRuffFormatter:test_format_markdown": {
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_target_version": {}
      },
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_markdown": {
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_strings": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_code": {
            "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
          }
        }
      }
    }
  }
}