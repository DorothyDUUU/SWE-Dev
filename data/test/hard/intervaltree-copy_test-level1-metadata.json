{
  "dir_path": "/app/intervaltree",
  "package_name": "intervaltree",
  "sample_name": "intervaltree-copy_test",
  "src_dir": "intervaltree/",
  "test_dir": "test/",
  "test_file": "test/intervaltree_methods/copy_test.py",
  "test_code": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nTest module: IntervalTree, Copying\n\nCopyright 2013-2018 Chaim Leib Halbert\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom __future__ import absolute_import\nfrom intervaltree import Interval, IntervalTree\nfrom test import data\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\n\ndef test_copy():\n    itree = IntervalTree([Interval(0, 1, \"x\"), Interval(1, 2, [\"x\"])])\n    itree.verify()\n\n    itree2 = IntervalTree(itree)  # Shares Interval objects\n    itree2.verify()\n\n    itree3 = itree.copy()         # Shallow copy (same as above, as Intervals are singletons)\n    itree3.verify()\n\n    itree4 = pickle.loads(pickle.dumps(itree))  # Deep copy\n    itree4.verify()\n\n    list(itree[1])[0].data[0] = \"y\"\n    assert sorted(itree) == [Interval(0, 1, 'x'), Interval(1, 2, ['y'])]\n    assert sorted(itree2) == [Interval(0, 1, 'x'), Interval(1, 2, ['y'])]\n    assert sorted(itree3) == [Interval(0, 1, 'x'), Interval(1, 2, ['y'])]\n    assert sorted(itree4) == [Interval(0, 1, 'x'), Interval(1, 2, ['x'])]\n\n\ndef test_copy_cast():\n    t = IntervalTree.from_tuples(data.ivs1.data)\n\n    tcopy = IntervalTree(t)\n    tcopy.verify()\n    assert t == tcopy\n\n    tlist = list(t)\n    for iv in tlist:\n        assert iv in t\n    for iv in t:\n        assert iv in tlist\n\n    tset = set(t)\n    assert tset == t.items()\n\n\nif __name__ == \"__main__\":\n    import pytest\n    pytest.main([__file__, '-v'])\n",
  "GT_file_code": {
    "intervaltree/intervaltree.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom .interval import Interval\nfrom .node import Node\nfrom numbers import Number\nfrom sortedcontainers import SortedDict\nfrom copy import copy\nfrom warnings import warn\n\ntry:\n    from collections.abc import MutableSet  # Python 3?\nexcept ImportError:\n    from collections import MutableSet\n\ntry:\n    xrange  # Python 2?\nexcept NameError:  # pragma: no cover\n    xrange = range\n\n\n# noinspection PyBroadException\nclass IntervalTree(MutableSet):\n    \"\"\"\n    A binary lookup tree of intervals.\n    The intervals contained in the tree are represented using ``Interval(a, b, data)`` objects.\n    Each such object represents a half-open interval ``[a, b)`` with optional data.\n\n    Examples:\n    ---------\n\n    Initialize a blank tree::\n\n        >>> tree = IntervalTree()\n        >>> tree\n        IntervalTree()\n\n    Initialize a tree from an iterable set of Intervals in O(n * log n)::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-20.0, -10.0)])\n        >>> tree\n        IntervalTree([Interval(-20.0, -10.0), Interval(-10, 10)])\n        >>> len(tree)\n        2\n\n    Note that this is a set, i.e. repeated intervals are ignored. However,\n    Intervals with different data fields are regarded as different::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-10, 10), Interval(-10, 10, \"x\")])\n        >>> tree\n        IntervalTree([Interval(-10, 10), Interval(-10, 10, 'x')])\n        >>> len(tree)\n        2\n\n    Insertions::\n        >>> tree = IntervalTree()\n        >>> tree[0:1] = \"data\"\n        >>> tree.add(Interval(10, 20))\n        >>> tree.addi(19.9, 20)\n        >>> tree\n        IntervalTree([Interval(0, 1, 'data'), Interval(10, 20), Interval(19.9, 20)])\n        >>> tree.update([Interval(19.9, 20.1), Interval(20.1, 30)])\n        >>> len(tree)\n        5\n\n        Inserting the same Interval twice does nothing::\n            >>> tree = IntervalTree()\n            >>> tree[-10:20] = \"arbitrary data\"\n            >>> tree[-10:20] = None  # Note that this is also an insertion\n            >>> tree\n            IntervalTree([Interval(-10, 20), Interval(-10, 20, 'arbitrary data')])\n            >>> tree[-10:20] = None  # This won't change anything\n            >>> tree[-10:20] = \"arbitrary data\" # Neither will this\n            >>> len(tree)\n            2\n\n    Deletions::\n        >>> tree = IntervalTree(Interval(b, e) for b, e in [(-10, 10), (-20, -10), (10, 20)])\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(-10, 10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        Traceback (most recent call last):\n        ...\n        ValueError\n        >>> tree.discard(Interval(-10, 10))  # Same as remove, but no exception on failure\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n\n    Delete intervals, overlapping a given point::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.1)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1)])\n\n    Delete intervals, overlapping an interval::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(0, 0.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.7, 1.8)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.6)  # Null interval does nothing\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.5)  # Ditto\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n\n    Delete intervals, enveloped in the range::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.0, 1.5)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.1, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.7)\n        >>> tree\n        IntervalTree()\n\n    Point queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[-1.1]   == set([Interval(-1.1, 1.1)])\n        >>> assert tree.at(1.1) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])   # Same as tree[1.1]\n        >>> assert tree.at(1.5) == set([Interval(0.5, 1.7)])                        # Same as tree[1.5]\n\n    Interval overlap queries\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.overlap(1.7, 1.8) == set()\n        >>> assert tree.overlap(1.5, 1.8) == set([Interval(0.5, 1.7)])\n        >>> assert tree[1.5:1.8] == set([Interval(0.5, 1.7)])                       # same as previous\n        >>> assert tree.overlap(1.1, 1.8) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[1.1:1.8] == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])  # same as previous\n\n    Interval envelop queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.envelop(-0.5, 0.5) == set()\n        >>> assert tree.envelop(-0.5, 1.5) == set([Interval(-0.5, 1.5)])\n\n    Membership queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> Interval(-0.5, 0.5) in tree\n        False\n        >>> Interval(-1.1, 1.1) in tree\n        True\n        >>> Interval(-1.1, 1.1, \"x\") in tree\n        False\n        >>> tree.overlaps(-1.1)\n        True\n        >>> tree.overlaps(1.7)\n        False\n        >>> tree.overlaps(1.7, 1.8)\n        False\n        >>> tree.overlaps(-1.2, -1.1)\n        False\n        >>> tree.overlaps(-1.2, -1.0)\n        True\n\n    Sizing::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> len(tree)\n        3\n        >>> tree.is_empty()\n        False\n        >>> IntervalTree().is_empty()\n        True\n        >>> not tree\n        False\n        >>> not IntervalTree()\n        True\n        >>> print(tree.begin())    # using print() because of floats in Python 2.6\n        -1.1\n        >>> print(tree.end())      # ditto\n        1.7\n\n    Iteration::\n\n        >>> tree = IntervalTree([Interval(-11, 11), Interval(-5, 15), Interval(5, 17)])\n        >>> [iv.begin for iv in sorted(tree)]\n        [-11, -5, 5]\n        >>> assert tree.items() == set([Interval(-5, 15), Interval(-11, 11), Interval(5, 17)])\n\n    Copy- and typecasting, pickling::\n\n        >>> tree0 = IntervalTree([Interval(0, 1, \"x\"), Interval(1, 2, [\"x\"])])\n        >>> tree1 = IntervalTree(tree0)  # Shares Interval objects\n        >>> tree2 = tree0.copy()         # Shallow copy (same as above, as Intervals are singletons)\n        >>> import pickle\n        >>> tree3 = pickle.loads(pickle.dumps(tree0))  # Deep copy\n        >>> list(tree0[1])[0].data[0] = \"y\"  # affects shallow copies, but not deep copies\n        >>> tree0\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree1\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree2\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree3\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['x'])])\n\n    Equality testing::\n\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1)])\n        True\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1, \"x\")])\n        False\n    \"\"\"\n    @classmethod\n    def from_tuples(cls, tups):\n        \"\"\"\n        Create a new IntervalTree from an iterable of 2- or 3-tuples,\n         where the tuple lists begin, end, and optionally data.\n        \"\"\"\n        ivs = [Interval(*t) for t in tups]\n        return IntervalTree(ivs)\n\n    def __init__(self, intervals=None):\n        \"\"\"\n        Set up a tree. If intervals is provided, add all the intervals\n        to the tree.\n\n        Completes in O(n*log n) time.\n        \"\"\"\n        intervals = set(intervals) if intervals is not None else set()\n        for iv in intervals:\n            if iv.is_null():\n                raise ValueError(\n                    \"IntervalTree: Null Interval objects not allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n        self.all_intervals = intervals\n        self.top_node = Node.from_intervals(self.all_intervals)\n        self.boundary_table = SortedDict()\n        for iv in self.all_intervals:\n            self._add_boundaries(iv)\n\n    def copy(self):\n        \"\"\"\n        Construct a new IntervalTree using shallow copies of the\n        intervals in the source tree.\n\n        Completes in O(n*log n) time.\n        :rtype: IntervalTree\n        \"\"\"\n        return IntervalTree(iv.copy() for iv in self)\n\n    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1\n\n    def _remove_boundaries(self, interval):\n        \"\"\"\n        Removes the boundaries of the interval from the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if self.boundary_table[begin] == 1:\n            del self.boundary_table[begin]\n        else:\n            self.boundary_table[begin] -= 1\n\n        if self.boundary_table[end] == 1:\n            del self.boundary_table[end]\n        else:\n            self.boundary_table[end] -= 1\n\n    def add(self, interval):\n        \"\"\"\n        Adds an interval to the tree, if not already present.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval in self:\n            return\n\n        if interval.is_null():\n            raise ValueError(\n                \"IntervalTree: Null Interval objects not allowed in IntervalTree:\"\n                \" {0}\".format(interval)\n            )\n\n        if not self.top_node:\n            self.top_node = Node.from_interval(interval)\n        else:\n            self.top_node = self.top_node.add(interval)\n        self.all_intervals.add(interval)\n        self._add_boundaries(interval)\n    append = add\n\n    def addi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for add(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.add(Interval(begin, end, data))\n    appendi = addi\n\n    def update(self, intervals):\n        \"\"\"\n        Given an iterable of intervals, add them to the tree.\n\n        Completes in O(m*log(n+m), where m = number of intervals to\n        add.\n        \"\"\"\n        for iv in intervals:\n            self.add(iv)\n\n    def remove(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, raises\n        ValueError.\n\n        Completes in O(log n) time.\n        \"\"\"\n        #self.verify()\n        if interval not in self:\n            #print(self.all_intervals)\n            raise ValueError\n        self.top_node = self.top_node.remove(interval)\n        self.all_intervals.remove(interval)\n        self._remove_boundaries(interval)\n        #self.verify()\n\n    def removei(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for remove(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.remove(Interval(begin, end, data))\n\n    def discard(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, does\n        nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval not in self:\n            return\n        self.all_intervals.discard(interval)\n        self.top_node = self.top_node.discard(interval)\n        self._remove_boundaries(interval)\n\n    def discardi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for discard(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.discard(Interval(begin, end, data))\n\n    def difference(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals in self but not\n        in other.\n        \"\"\"\n        ivs = set()\n        for iv in self:\n            if iv not in other:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def difference_update(self, other):\n        \"\"\"\n        Removes all intervals in other from self.\n        \"\"\"\n        for iv in other:\n            self.discard(iv)\n\n    def union(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals from self\n        and other.\n        \"\"\"\n        return IntervalTree(set(self).union(other))\n\n    def intersection(self, other):\n        \"\"\"\n        Returns a new tree of all intervals common to both self and\n        other.\n        \"\"\"\n        ivs = set()\n        shorter, longer = sorted([self, other], key=len)\n        for iv in shorter:\n            if iv in longer:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def intersection_update(self, other):\n        \"\"\"\n        Removes intervals from self unless they also exist in other.\n        \"\"\"\n        ivs = list(self)\n        for iv in ivs:\n            if iv not in other:\n                self.remove(iv)\n\n    def symmetric_difference(self, other):\n        \"\"\"\n        Return a tree with elements only in self or other but not\n        both.\n        \"\"\"\n        if not isinstance(other, set): other = set(other)\n        me = set(self)\n        ivs = me.difference(other).union(other.difference(me))\n        return IntervalTree(ivs)\n\n    def symmetric_difference_update(self, other):\n        \"\"\"\n        Throws out all intervals except those only in self or other,\n        not both.\n        \"\"\"\n        other = set(other)\n        ivs = list(self)\n        for iv in ivs:\n            if iv in other:\n                self.remove(iv)\n                other.remove(iv)\n        self.update(other)\n\n    def remove_overlap(self, begin, end=None):\n        \"\"\"\n        Removes all intervals overlapping the given point or range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range (this is 1 for a point)\n        \"\"\"\n        hitlist = self.at(begin) if end is None else self.overlap(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def remove_envelop(self, begin, end):\n        \"\"\"\n        Removes all intervals completely enveloped in the given range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range\n        \"\"\"\n        hitlist = self.envelop(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def chop(self, begin, end, datafunc=None):\n        \"\"\"\n        Like remove_envelop(), but trims back Intervals hanging into\n        the chopped area so that nothing overlaps.\n        \"\"\"\n        insertions = set()\n        begin_hits = [iv for iv in self.at(begin) if iv.begin < begin]\n        end_hits = [iv for iv in self.at(end) if iv.end > end]\n\n        if datafunc:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, datafunc(iv, True)))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, datafunc(iv, False)))\n        else:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, iv.data))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, iv.data))\n\n        self.remove_envelop(begin, end)\n        self.difference_update(begin_hits)\n        self.difference_update(end_hits)\n        self.update(insertions)\n\n    def slice(self, point, datafunc=None):\n        \"\"\"\n        Split Intervals that overlap point into two new Intervals. if\n        specified, uses datafunc(interval, islower=True/False) to\n        set the data field of the new Intervals.\n        :param point: where to slice\n        :param datafunc(interval, isupper): callable returning a new\n        value for the interval's data field\n        \"\"\"\n        hitlist = set(iv for iv in self.at(point) if iv.begin < point)\n        insertions = set()\n        if datafunc:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, datafunc(iv, True)))\n                insertions.add(Interval(point, iv.end, datafunc(iv, False)))\n        else:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, iv.data))\n                insertions.add(Interval(point, iv.end, iv.data))\n        self.difference_update(hitlist)\n        self.update(insertions)\n\n    def clear(self):\n        \"\"\"\n        Empties the tree.\n\n        Completes in O(1) tine.\n        \"\"\"\n        self.__init__()\n\n    def find_nested(self):\n        \"\"\"\n        Returns a dictionary mapping parent intervals to sets of\n        intervals overlapped by and contained in the parent.\n\n        Completes in O(n^2) time.\n        :rtype: dict of [Interval, set of Interval]\n        \"\"\"\n        result = {}\n\n        def add_if_nested():\n            if parent.contains_interval(child):\n                if parent not in result:\n                    result[parent] = set()\n                result[parent].add(child)\n\n        long_ivs = sorted(self.all_intervals, key=Interval.length, reverse=True)\n        for i, parent in enumerate(long_ivs):\n            for child in long_ivs[i + 1:]:\n                add_if_nested()\n        return result\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        point or range.\n\n        Completes in O(r*log n) time, where r is the size of the\n        search range.\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return self.overlaps_range(begin, end)\n        elif isinstance(begin, Number):\n            return self.overlaps_point(begin)\n        else:\n            return self.overlaps_range(begin.begin, begin.end)\n\n    def overlaps_point(self, p):\n        \"\"\"\n        Returns whether some interval in the tree overlaps p.\n\n        Completes in O(log n) time.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        return bool(self.top_node.contains_point(p))\n\n    def overlaps_range(self, begin, end):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        range. Returns False if given a null interval over which to\n        test.\n\n        Completes in O(r*log n) time, where r is the range length and n\n        is the table size.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        elif begin >= end:\n            return False\n        elif self.overlaps_point(begin):\n            return True\n        return any(\n            self.overlaps_point(bound)\n            for bound in self.boundary_table\n            if begin < bound < end\n        )\n\n    def split_overlaps(self):\n        \"\"\"\n        Finds all intervals with overlapping ranges and splits them\n        along the range boundaries.\n\n        Completes in worst-case O(n^2*log n) time (many interval\n        boundaries are inside many intervals), best-case O(n*log n)\n        time (small number of overlaps << n per interval).\n        \"\"\"\n        if not self:\n            return\n        if len(self.boundary_table) == 2:\n            return\n\n        bounds = sorted(self.boundary_table)  # get bound locations\n\n        new_ivs = set()\n        for lbound, ubound in zip(bounds[:-1], bounds[1:]):\n            for iv in self[lbound]:\n                new_ivs.add(Interval(lbound, ubound, iv.data))\n\n        self.__init__(new_ivs)\n\n    def merge_overlaps(self, data_reducer=None, data_initializer=None, strict=True):\n        \"\"\"\n        Finds all intervals with overlapping ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initializer created with copy.copy(data_initializer).\n\n        If strict is True (default), intervals are only merged if\n        their ranges actually overlap; adjacent, touching intervals\n        will not be merged. If strict is False, intervals are merged\n        even if they are only end-to-end adjacent.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                if (higher.begin < lower.end or\n                    not strict and higher.begin == lower.end):  # should merge\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:  # annihilate the data, since we don't know how to merge it\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def merge_equals(self, data_reducer=None, data_initializer=None):\n        \"\"\"\n        Finds all intervals with equal ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                if higher.range_matches(lower):  # should merge\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:  # annihilate the data, since we don't know how to merge it\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def merge_neighbors(\n        self,\n        data_reducer=None,\n        data_initializer=None,\n        distance=1,\n        strict=True,\n    ):\n        \"\"\"\n        Finds all adjacent intervals with range terminals less than or equal to\n        the given distance and merges them into a single interval. If provided,\n        uses data_reducer and data_initializer with similar semantics to\n        Python's built-in reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        If strict is True (default), only discrete intervals are merged if\n        their ranges are within the given distance; overlapping intervals\n        will not be merged. If strict is False, both neighbors and overlapping\n        intervals are merged.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                margin = higher.begin - lower.end\n                if margin <= distance:  # should merge\n                    if strict and margin < 0:\n                        new_series()\n                        continue\n                    else:\n                        upper_bound = max(lower.end, higher.end)\n                        if data_reducer is not None:\n                            current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                        else:  # annihilate the data, since we don't know how to merge it\n                            current_reduced[0] = None\n                        merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def items(self):\n        \"\"\"\n        Constructs and returns a set of all intervals in the tree.\n\n        Completes in O(n) time.\n        :rtype: set of Interval\n        \"\"\"\n        return set(self.all_intervals)\n\n    def is_empty(self):\n        \"\"\"\n        Returns whether the tree is empty.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return 0 == len(self)\n\n    def at(self, p):\n        \"\"\"\n        Returns the set of all intervals that contain p.\n\n        Completes in O(m + log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        return root.search_point(p, set())\n\n    def envelop(self, begin, end=None):\n        \"\"\"\n        Returns the set of all intervals fully contained in the range\n        [begin, end).\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.envelop(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set()) # bound_begin might be greater\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)  # up to, but not including end\n        result.update(root.search_overlap(\n            # slice notation is slightly slower\n            boundary_table.keys()[index] for index in xrange(bound_begin, bound_end)\n        ))\n\n        # TODO: improve envelop() to use node info instead of less-efficient filtering\n        result = set(\n            iv for iv in result\n            if iv.begin >= begin and iv.end <= end\n        )\n        return result\n\n    def overlap(self, begin, end=None):\n        \"\"\"\n        Returns a set of all intervals overlapping the given range.\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.overlap(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())  # bound_begin might be greater\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)  # up to, but not including end\n        result.update(root.search_overlap(\n            # slice notation is slightly slower\n            boundary_table.keys()[index] for index in xrange(bound_begin, bound_end)\n        ))\n        return result\n\n    def begin(self):\n        \"\"\"\n        Returns the lower bound of the first interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[0]\n\n    def end(self):\n        \"\"\"\n        Returns the upper bound of the last interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[-1]\n\n    def range(self):\n        \"\"\"\n        Returns a minimum-spanning Interval that encloses all the\n        members of this IntervalTree. If the tree is empty, returns\n        null Interval.\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin(), self.end())\n\n    def span(self):\n        \"\"\"\n        Returns the length of the minimum-spanning Interval that\n        encloses all the members of this IntervalTree. If the tree\n        is empty, return 0.\n        \"\"\"\n        if not self:\n            return 0\n        return self.end() - self.begin()\n\n    def print_structure(self, tostring=False):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Pretty-prints the structure of the tree.\n        If tostring is true, prints nothing and returns a string.\n        :rtype: None or str\n        \"\"\"\n        if self.top_node:\n            return self.top_node.print_structure(tostring=tostring)\n        else:\n            result = \"<empty IntervalTree>\"\n            if not tostring:\n                print(result)\n            else:\n                return result\n\n    def verify(self):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Checks the table to ensure that the invariants are held.\n        \"\"\"\n        if self.all_intervals:\n            ## top_node.all_children() == self.all_intervals\n            try:\n                assert self.top_node.all_children() == self.all_intervals\n            except AssertionError as e:\n                print(\n                    'Error: the tree and the membership set are out of sync!'\n                )\n                tivs = set(self.top_node.all_children())\n                print('top_node.all_children() - all_intervals:')\n                try:\n                    pprint\n                except NameError:\n                    from pprint import pprint\n                pprint(tivs - self.all_intervals)\n                print('all_intervals - top_node.all_children():')\n                pprint(self.all_intervals - tivs)\n                raise e\n\n            ## All members are Intervals\n            for iv in self:\n                assert isinstance(iv, Interval), (\n                    \"Error: Only Interval objects allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n\n            ## No null intervals\n            for iv in self:\n                assert not iv.is_null(), (\n                    \"Error: Null Interval objects not allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n\n            ## Reconstruct boundary_table\n            bound_check = {}\n            for iv in self:\n                if iv.begin in bound_check:\n                    bound_check[iv.begin] += 1\n                else:\n                    bound_check[iv.begin] = 1\n                if iv.end in bound_check:\n                    bound_check[iv.end] += 1\n                else:\n                    bound_check[iv.end] = 1\n\n            ## Reconstructed boundary table (bound_check) ==? boundary_table\n            assert set(self.boundary_table.keys()) == set(bound_check.keys()),\\\n                'Error: boundary_table is out of sync with ' \\\n                'the intervals in the tree!'\n\n            # For efficiency reasons this should be iteritems in Py2, but we\n            # don't care much for efficiency in debug methods anyway.\n            for key, val in self.boundary_table.items():\n                assert bound_check[key] == val, \\\n                    'Error: boundary_table[{0}] should be {1},' \\\n                    ' but is {2}!'.format(\n                        key, bound_check[key], val)\n\n            ## Internal tree structure\n            self.top_node.verify(set())\n        else:\n            ## Verify empty tree\n            assert not self.boundary_table, \\\n                \"Error: boundary table should be empty!\"\n            assert self.top_node is None, \\\n                \"Error: top_node isn't None!\"\n\n    def score(self, full_report=False):\n        \"\"\"\n        Returns a number between 0 and 1, indicating how suboptimal the tree\n        is. The lower, the better. Roughly, this number represents the\n        fraction of flawed Intervals in the tree.\n        :rtype: float\n        \"\"\"\n        if len(self) <= 2:\n            return 0.0\n\n        n = len(self)\n        m = self.top_node.count_nodes()\n\n        def s_center_score():\n            \"\"\"\n            Returns a normalized score, indicating roughly how many times\n            intervals share s_center with other intervals. Output is full-scale\n            from 0 to 1.\n            :rtype: float\n            \"\"\"\n            raw = n - m\n            maximum = n - 1\n            return raw / float(maximum)\n\n        report = {\n            \"depth\": self.top_node.depth_score(n, m),\n            \"s_center\": s_center_score(),\n        }\n        cumulative = max(report.values())\n        report[\"_cumulative\"] = cumulative\n        if full_report:\n            return report\n        return cumulative\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns a set of all intervals overlapping the given index or\n        slice.\n\n        Completes in O(k * log(n) + m) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range (this is 1 for a point)\n        :rtype: set of Interval\n        \"\"\"\n        try:\n            start, stop = index.start, index.stop\n            if start is None:\n                start = self.begin()\n                if stop is None:\n                    return set(self)\n            if stop is None:\n                stop = self.end()\n            return self.overlap(start, stop)\n        except AttributeError:\n            return self.at(index)\n\n    def __setitem__(self, index, value):\n        \"\"\"\n        Adds a new interval to the tree. A shortcut for\n        add(Interval(index.start, index.stop, value)).\n\n        If an identical Interval object with equal range and data\n        already exists, does nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        self.addi(index.start, index.stop, value)\n\n    def __delitem__(self, point):\n        \"\"\"\n        Delete all items overlapping point.\n        \"\"\"\n        self.remove_overlap(point)\n\n    def __contains__(self, item):\n        \"\"\"\n        Returns whether item exists as an Interval in the tree.\n        This method only returns True for exact matches; for\n        overlaps, see the overlaps() method.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        # Removed point-checking code; it might trick the user into\n        # thinking that this is O(1), which point-checking isn't.\n        #if isinstance(item, Interval):\n        return item in self.all_intervals\n        #else:\n        #    return self.contains_point(item)\n\n    def containsi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for (Interval(begin, end, data) in tree).\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return Interval(begin, end, data) in self\n\n    def __iter__(self):\n        \"\"\"\n        Returns an iterator over all the intervals in the tree.\n\n        Completes in O(1) time.\n        :rtype: collections.Iterable[Interval]\n        \"\"\"\n        return self.all_intervals.__iter__()\n    iter = __iter__\n\n    def __len__(self):\n        \"\"\"\n        Returns how many intervals are in the tree.\n\n        Completes in O(1) time.\n        :rtype: int\n        \"\"\"\n        return len(self.all_intervals)\n\n    def __eq__(self, other):\n        \"\"\"\n        Whether two IntervalTrees are equal.\n\n        Completes in O(n) time if sizes are equal; O(1) time otherwise.\n        :rtype: bool\n        \"\"\"\n        return (\n            isinstance(other, IntervalTree) and\n            self.all_intervals == other.all_intervals\n        )\n\n    def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        ivs = sorted(self)\n        if not ivs:\n            return \"IntervalTree()\"\n        else:\n            return \"IntervalTree({0})\".format(ivs)\n\n    __str__ = __repr__\n\n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :rtype: tuple\n        \"\"\"\n        return IntervalTree, (sorted(self.all_intervals),)\n\n",
    "intervaltree/interval.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nInterval class\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom numbers import Number\nfrom collections import namedtuple\n\n\n# noinspection PyBroadException\nclass Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n    __slots__ = ()  # Saves memory, avoiding the need to create __dict__ for each interval\n\n    def __new__(cls, begin, end, data=None):\n        return super(Interval, cls).__new__(cls, begin, end, data)\n    \n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Whether the interval overlaps the given point, range or Interval.\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            # An overlap means that some C exists that is inside both ranges:\n            #   begin <= C < end\n            # and \n            #   self.begin <= C < self.end\n            # See https://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap/3269471#3269471\n            return begin < self.end and end > self.begin\n        try:\n            return self.overlaps(begin.begin, begin.end)\n        except:\n            return self.contains_point(begin)\n\n    def overlap_size(self, begin, end=None):\n        \"\"\"\n        Return the overlap size between two intervals or a point\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: Return the overlap size, None if not overlap is found\n        :rtype: depends on the given input (e.g., int will be returned for int interval and timedelta for\n        datetime intervals)\n        \"\"\"\n        overlaps = self.overlaps(begin, end)\n        if not overlaps:\n            return 0\n\n        if end is not None:\n            # case end is given\n            i0 = max(self.begin, begin)\n            i1 = min(self.end, end)\n            return i1 - i0\n        # assume the type is interval, in other cases, an exception will be thrown\n        i0 = max(self.begin, begin.begin)\n        i1 = min(self.end, begin.end)\n        return i1 - i0\n\n    def contains_point(self, p):\n        \"\"\"\n        Whether the Interval contains p.\n        :param p: a point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= p < self.end\n    \n    def range_matches(self, other):\n        \"\"\"\n        Whether the begins equal and the ends equal. Compare __eq__().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin == other.begin and \n            self.end == other.end\n        )\n    \n    def contains_interval(self, other):\n        \"\"\"\n        Whether other is contained in this Interval.\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin <= other.begin and\n            self.end >= other.end\n        )\n    \n    def distance_to(self, other):\n        \"\"\"\n        Returns the size of the gap between intervals, or 0 \n        if they touch or overlap.\n        :param other: Interval or point\n        :return: distance\n        :rtype: Number\n        \"\"\"\n        if self.overlaps(other):\n            return 0\n        try:\n            if self.begin < other.begin:\n                return other.begin - self.end\n            else:\n                return self.begin - other.end\n        except:\n            if self.end <= other:\n                return other - self.end\n            else:\n                return self.begin - other\n\n    def is_null(self):\n        \"\"\"\n        Whether this equals the null interval.\n        :return: True if end <= begin else False\n        :rtype: bool\n        \"\"\"\n        return self.begin >= self.end\n\n    def length(self):\n        \"\"\"\n        The distance covered by this Interval.\n        :return: length\n        :type: Number\n        \"\"\"\n        if self.is_null():\n            return 0\n        return self.end - self.begin\n\n    def __hash__(self):\n        \"\"\"\n        Depends on begin and end only.\n        :return: hash\n        :rtype: Number\n        \"\"\"\n        return hash((self.begin, self.end))\n\n    def __eq__(self, other):\n        \"\"\"\n        Whether the begins equal, the ends equal, and the data fields\n        equal. Compare range_matches().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin == other.begin and\n            self.end == other.end and\n            self.data == other.data\n        )\n\n    def __cmp__(self, other):\n        \"\"\"\n        Tells whether other sorts before, after or equal to this\n        Interval.\n\n        Sorting is by begins, then by ends, then by data fields.\n\n        If data fields are not both sortable types, data fields are\n        compared alphabetically by type name.\n        :param other: Interval\n        :return: -1, 0, 1\n        :rtype: int\n        \"\"\"\n        s = self[0:2]\n        try:\n            o = other[0:2]\n        except:\n            o = (other,)\n        if s != o:\n            return -1 if s < o else 1\n        try:\n            if self.data == other.data:\n                return 0\n            return -1 if self.data < other.data else 1\n        except TypeError:\n            s = type(self.data).__name__\n            o = type(other.data).__name__\n            if s == o:\n                return 0\n            return -1 if s < o else 1\n\n    def __lt__(self, other):\n        \"\"\"\n        Less than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) < 0\n\n    def __gt__(self, other):\n        \"\"\"\n        Greater than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) > 0\n\n    def _raise_if_null(self, other):\n        \"\"\"\n        :raises ValueError: if either self or other is a null Interval\n        \"\"\"\n        if self.is_null():\n            raise ValueError(\"Cannot compare null Intervals!\")\n        if hasattr(other, 'is_null') and other.is_null():\n            raise ValueError(\"Cannot compare null Intervals!\")\n\n    def lt(self, other):\n        \"\"\"\n        Strictly less than. Returns True if no part of this Interval\n        extends higher than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'begin', other)\n\n    def le(self, other):\n        \"\"\"\n        Less than or overlaps. Returns True if no part of this Interval\n        extends higher than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'end', other)\n\n    def gt(self, other):\n        \"\"\"\n        Strictly greater than. Returns True if no part of this Interval\n        extends lower than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        if hasattr(other, 'end'):\n            return self.begin >= other.end\n        else:\n            return self.begin > other\n\n    def ge(self, other):\n        \"\"\"\n        Greater than or overlaps. Returns True if no part of this Interval\n        extends lower than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.begin >= getattr(other, 'begin', other)\n\n    def _get_fields(self):\n        \"\"\"\n        Used by str, unicode, repr and __reduce__.\n\n        Returns only the fields necessary to reconstruct the Interval.\n        :return: reconstruction info\n        :rtype: tuple\n        \"\"\"\n        if self.data is not None:\n            return self.begin, self.end, self.data\n        else:\n            return self.begin, self.end\n    \n    def __repr__(self):\n        \"\"\"\n        Executable string representation of this Interval.\n        :return: string representation\n        :rtype: str\n        \"\"\"\n        if isinstance(self.begin, Number):\n            s_begin = str(self.begin)\n            s_end = str(self.end)\n        else:\n            s_begin = repr(self.begin)\n            s_end = repr(self.end)\n        if self.data is None:\n            return \"Interval({0}, {1})\".format(s_begin, s_end)\n        else:\n            return \"Interval({0}, {1}, {2})\".format(s_begin, s_end, repr(self.data))\n\n    __str__ = __repr__\n\n    def copy(self):\n        \"\"\"\n        Shallow copy.\n        :return: copy of self\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin, self.end, self.data)\n    \n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :return: pickle data\n        :rtype: tuple\n        \"\"\"\n        return Interval, self._get_fields()\n"
  },
  "GT_src_dict": {
    "intervaltree/intervaltree.py": {
      "IntervalTree.from_tuples": {
        "code": "    def from_tuples(cls, tups):\n        \"\"\"Create a new IntervalTree from an iterable of 2- or 3-tuples representing intervals.\n\nParameters:\n- tups (iterable of tuples): An iterable containing tuples of either two or three elements, where each tuple consists of the start point, endpoint, and optionally associated data for an interval. The intervals are represented by the `Interval` class, which constructs half-open intervals `[begin, end)`.\n\nReturns:\n- IntervalTree: An instance of `IntervalTree` populated with the created `Interval` objects derived from the provided tuples.\n\nThis method leverages the `Interval` class defined in the `interval` module to create interval objects. Each interval is added to a new `IntervalTree`, which is a mutable and self-balancing structure capable of efficient interval queries and operations.\"\"\"\n        '\\n        Create a new IntervalTree from an iterable of 2- or 3-tuples,\\n         where the tuple lists begin, end, and optionally data.\\n        '\n        ivs = [Interval(*t) for t in tups]\n        return IntervalTree(ivs)",
        "docstring": "Create a new IntervalTree from an iterable of 2- or 3-tuples representing intervals.\n\nParameters:\n- tups (iterable of tuples): An iterable containing tuples of either two or three elements, where each tuple consists of the start point, endpoint, and optionally associated data for an interval. The intervals are represented by the `Interval` class, which constructs half-open intervals `[begin, end)`.\n\nReturns:\n- IntervalTree: An instance of `IntervalTree` populated with the created `Interval` objects derived from the provided tuples.\n\nThis method leverages the `Interval` class defined in the `interval` module to create interval objects. Each interval is added to a new `IntervalTree`, which is a mutable and self-balancing structure capable of efficient interval queries and operations.",
        "signature": "def from_tuples(cls, tups):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__init__": {
        "code": "    def __init__(self, intervals=None):\n        \"\"\"Initializes an IntervalTree instance, optionally populating it with a set of intervals. If provided, the intervals must not include any null intervals. During initialization, the function also constructs the tree's top node from the intervals and creates a boundary table for efficient interval management.\n\nParameters:\n-----------\nintervals : iterable of Interval, optional\n    A collection of Interval objects to be added to the tree. If None, initializes an empty tree.\n\nRaises:\n--------\nValueError\n    If any of the provided intervals is null, indicating that null Interval objects are not allowed.\n\nAttributes:\n-----------\nself.all_intervals : set\n    A set that stores all unique intervals added to the tree.\nself.top_node : Node\n    The root node of the interval tree, generated from the provided intervals.\nself.boundary_table : SortedDict\n    A sorted dictionary that keeps track of the boundaries (start and end points) of the intervals for efficient querying.\n\nPerformance:\n------------\nThis initialization process completes in O(n*log n) time, where n is the number of intervals, due to the need for sorting and tree construction.\"\"\"\n        '\\n        Set up a tree. If intervals is provided, add all the intervals\\n        to the tree.\\n\\n        Completes in O(n*log n) time.\\n        '\n        intervals = set(intervals) if intervals is not None else set()\n        for iv in intervals:\n            if iv.is_null():\n                raise ValueError('IntervalTree: Null Interval objects not allowed in IntervalTree: {0}'.format(iv))\n        self.all_intervals = intervals\n        self.top_node = Node.from_intervals(self.all_intervals)\n        self.boundary_table = SortedDict()\n        for iv in self.all_intervals:\n            self._add_boundaries(iv)",
        "docstring": "Initializes an IntervalTree instance, optionally populating it with a set of intervals. If provided, the intervals must not include any null intervals. During initialization, the function also constructs the tree's top node from the intervals and creates a boundary table for efficient interval management.\n\nParameters:\n-----------\nintervals : iterable of Interval, optional\n    A collection of Interval objects to be added to the tree. If None, initializes an empty tree.\n\nRaises:\n--------\nValueError\n    If any of the provided intervals is null, indicating that null Interval objects are not allowed.\n\nAttributes:\n-----------\nself.all_intervals : set\n    A set that stores all unique intervals added to the tree.\nself.top_node : Node\n    The root node of the interval tree, generated from the provided intervals.\nself.boundary_table : SortedDict\n    A sorted dictionary that keeps track of the boundaries (start and end points) of the intervals for efficient querying.\n\nPerformance:\n------------\nThis initialization process completes in O(n*log n) time, where n is the number of intervals, due to the need for sorting and tree construction.",
        "signature": "def __init__(self, intervals=None):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.copy": {
        "code": "    def copy(self):\n        \"\"\"Construct a new IntervalTree that is a shallow copy of the current tree, using shallow copies of the intervals it contains. \n\nThis method iterates through each interval in the source tree (`self`) and creates a new IntervalTree instance containing these copied intervals. It operates in O(n*log n) time, where n is the number of intervals, due to the insertion process in the new tree.\n\nReturns:\n    IntervalTree: A new IntervalTree instance containing shallow copies of the intervals from the original tree.\n\nNotes:\n    - Since the copying is shallow, any modifications to the data in the original interval objects will reflect in the copied intervals, as both the original and the copy reference the same interval data.\"\"\"\n        '\\n        Construct a new IntervalTree using shallow copies of the\\n        intervals in the source tree.\\n\\n        Completes in O(n*log n) time.\\n        :rtype: IntervalTree\\n        '\n        return IntervalTree((iv.copy() for iv in self))",
        "docstring": "Construct a new IntervalTree that is a shallow copy of the current tree, using shallow copies of the intervals it contains. \n\nThis method iterates through each interval in the source tree (`self`) and creates a new IntervalTree instance containing these copied intervals. It operates in O(n*log n) time, where n is the number of intervals, due to the insertion process in the new tree.\n\nReturns:\n    IntervalTree: A new IntervalTree instance containing shallow copies of the intervals from the original tree.\n\nNotes:\n    - Since the copying is shallow, any modifications to the data in the original interval objects will reflect in the copied intervals, as both the original and the copy reference the same interval data.",
        "signature": "def copy(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.items": {
        "code": "    def items(self):\n        \"\"\"Constructs and returns a set containing all the intervals stored in the IntervalTree. This method provides a straightforward way to access the intervals currently managed by the tree structure without altering its state. The operation completes in O(n) time, where n is the total number of intervals in the tree. The method relies on the `all_intervals` attribute, which is a set of `Interval` objects representing the intervals contained within the tree. This attribute is modified indirectly through various methods of the class that add or remove intervals, ensuring that it accurately reflects the current state of the IntervalTree.\"\"\"\n        '\\n        Constructs and returns a set of all intervals in the tree.\\n\\n        Completes in O(n) time.\\n        :rtype: set of Interval\\n        '\n        return set(self.all_intervals)",
        "docstring": "Constructs and returns a set containing all the intervals stored in the IntervalTree. This method provides a straightforward way to access the intervals currently managed by the tree structure without altering its state. The operation completes in O(n) time, where n is the total number of intervals in the tree. The method relies on the `all_intervals` attribute, which is a set of `Interval` objects representing the intervals contained within the tree. This attribute is modified indirectly through various methods of the class that add or remove intervals, ensuring that it accurately reflects the current state of the IntervalTree.",
        "signature": "def items(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.verify": {
        "code": "    def verify(self):\n        \"\"\"Checks the integrity and invariants of the IntervalTree structure. This method verifies that the `top_node`'s list of all child intervals matches the `all_intervals` set, ensuring consistency in membership. It also ensures that all members are valid Interval objects and that none are null intervals. The method reconstructs the `boundary_table` and checks its consistency with the intervals in the tree.\n\nRaises an AssertionError if any of the checks fail, providing detailed output of any discrepancies found in the internal structure or membership consistency of the tree.\n\nNo parameters are required, and it does not return any value. This method is primarily used for debugging purposes to maintain the integrity of the data structure.\"\"\"\n        '\\n        ## FOR DEBUGGING ONLY ##\\n        Checks the table to ensure that the invariants are held.\\n        '\n        if self.all_intervals:\n            try:\n                assert self.top_node.all_children() == self.all_intervals\n            except AssertionError as e:\n                print('Error: the tree and the membership set are out of sync!')\n                tivs = set(self.top_node.all_children())\n                print('top_node.all_children() - all_intervals:')\n                try:\n                    pprint\n                except NameError:\n                    from pprint import pprint\n                pprint(tivs - self.all_intervals)\n                print('all_intervals - top_node.all_children():')\n                pprint(self.all_intervals - tivs)\n                raise e\n            for iv in self:\n                assert isinstance(iv, Interval), 'Error: Only Interval objects allowed in IntervalTree: {0}'.format(iv)\n            for iv in self:\n                assert not iv.is_null(), 'Error: Null Interval objects not allowed in IntervalTree: {0}'.format(iv)\n            bound_check = {}\n            for iv in self:\n                if iv.begin in bound_check:\n                    bound_check[iv.begin] += 1\n                else:\n                    bound_check[iv.begin] = 1\n                if iv.end in bound_check:\n                    bound_check[iv.end] += 1\n                else:\n                    bound_check[iv.end] = 1\n            assert set(self.boundary_table.keys()) == set(bound_check.keys()), 'Error: boundary_table is out of sync with the intervals in the tree!'\n            for key, val in self.boundary_table.items():\n                assert bound_check[key] == val, 'Error: boundary_table[{0}] should be {1}, but is {2}!'.format(key, bound_check[key], val)\n            self.top_node.verify(set())\n        else:\n            assert not self.boundary_table, 'Error: boundary table should be empty!'\n            assert self.top_node is None, \"Error: top_node isn't None!\"",
        "docstring": "Checks the integrity and invariants of the IntervalTree structure. This method verifies that the `top_node`'s list of all child intervals matches the `all_intervals` set, ensuring consistency in membership. It also ensures that all members are valid Interval objects and that none are null intervals. The method reconstructs the `boundary_table` and checks its consistency with the intervals in the tree.\n\nRaises an AssertionError if any of the checks fail, providing detailed output of any discrepancies found in the internal structure or membership consistency of the tree.\n\nNo parameters are required, and it does not return any value. This method is primarily used for debugging purposes to maintain the integrity of the data structure.",
        "signature": "def verify(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__getitem__": {
        "code": "    def __getitem__(self, index):\n        \"\"\"Returns a set of all intervals in the IntervalTree that overlap the specified index or slice. The method first checks if the index is a slice (with start and stop attributes). If it is, it retrieves overlapping intervals using the `overlap` method; if the index is a single point, it uses the `at` method to get intervals containing that point. \n\nParameters:\n- index (slice or point): This can be a point or a slice specifying the range of indices to check for overlaps.\n\nReturns:\n- set of Interval: A set containing all intervals that overlap with the specified index or range.\n\nThe method operates in O(k * log(n) + m) time complexity, where n is the size of the tree, m is the number of matches found, and k is the size of the search range (1 for single points). Notably, it utilizes the `overlap` method for range queries and `at` for single point queries, making it efficient for checking intervals against the stored intervals in the tree.\"\"\"\n        '\\n        Returns a set of all intervals overlapping the given index or\\n        slice.\\n\\n        Completes in O(k * log(n) + m) time, where:\\n          * n = size of the tree\\n          * m = number of matches\\n          * k = size of the search range (this is 1 for a point)\\n        :rtype: set of Interval\\n        '\n        try:\n            start, stop = (index.start, index.stop)\n            if start is None:\n                start = self.begin()\n                if stop is None:\n                    return set(self)\n            if stop is None:\n                stop = self.end()\n            return self.overlap(start, stop)\n        except AttributeError:\n            return self.at(index)",
        "docstring": "Returns a set of all intervals in the IntervalTree that overlap the specified index or slice. The method first checks if the index is a slice (with start and stop attributes). If it is, it retrieves overlapping intervals using the `overlap` method; if the index is a single point, it uses the `at` method to get intervals containing that point. \n\nParameters:\n- index (slice or point): This can be a point or a slice specifying the range of indices to check for overlaps.\n\nReturns:\n- set of Interval: A set containing all intervals that overlap with the specified index or range.\n\nThe method operates in O(k * log(n) + m) time complexity, where n is the size of the tree, m is the number of matches found, and k is the size of the search range (1 for single points). Notably, it utilizes the `overlap` method for range queries and `at` for single point queries, making it efficient for checking intervals against the stored intervals in the tree.",
        "signature": "def __getitem__(self, index):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__contains__": {
        "code": "    def __contains__(self, item):\n        \"\"\"Returns whether the specified item exists as an exact match in the IntervalTree. This method only checks for exact interval matches, not overlaps; for checking if any interval overlaps with a point, use the `overlaps()` method instead. The search is conducted in constant time, O(1), by checking membership in `self.all_intervals`, which is a set maintaining all interval objects within the tree.\n\nParameters:\n- item: An instance of the `Interval` class or an object that is intended to be checked for membership in the tree.\n\nReturns:\n- bool: Returns True if the item matches an existing interval in the tree, otherwise returns False.\n\nDependencies:\n- Requires the `Interval` class to be correctly defined and comparable, as the membership check directly relies on the equality defined in the `__eq__` method of `Interval`. The attribute `self.all_intervals` holds all intervals in a set for efficient membership testing.\"\"\"\n        '\\n        Returns whether item exists as an Interval in the tree.\\n        This method only returns True for exact matches; for\\n        overlaps, see the overlaps() method.\\n\\n        Completes in O(1) time.\\n        :rtype: bool\\n        '\n        return item in self.all_intervals",
        "docstring": "Returns whether the specified item exists as an exact match in the IntervalTree. This method only checks for exact interval matches, not overlaps; for checking if any interval overlaps with a point, use the `overlaps()` method instead. The search is conducted in constant time, O(1), by checking membership in `self.all_intervals`, which is a set maintaining all interval objects within the tree.\n\nParameters:\n- item: An instance of the `Interval` class or an object that is intended to be checked for membership in the tree.\n\nReturns:\n- bool: Returns True if the item matches an existing interval in the tree, otherwise returns False.\n\nDependencies:\n- Requires the `Interval` class to be correctly defined and comparable, as the membership check directly relies on the equality defined in the `__eq__` method of `Interval`. The attribute `self.all_intervals` holds all intervals in a set for efficient membership testing.",
        "signature": "def __contains__(self, item):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__iter__": {
        "code": "    def __iter__(self):\n        \"\"\"Returns an iterator over all the intervals in the IntervalTree. This method allows for easy iteration over the contained Interval objects, facilitating operations such as looping through intervals or converting the IntervalTree into a list or other iterable types.\n\n:rtype: collections.Iterable[Interval]\"\"\"\n        '\\n        Returns an iterator over all the intervals in the tree.\\n\\n        Completes in O(1) time.\\n        :rtype: collections.Iterable[Interval]\\n        '\n        return self.all_intervals.__iter__()",
        "docstring": "Returns an iterator over all the intervals in the IntervalTree. This method allows for easy iteration over the contained Interval objects, facilitating operations such as looping through intervals or converting the IntervalTree into a list or other iterable types.\n\n:rtype: collections.Iterable[Interval]",
        "signature": "def __iter__(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__len__": {
        "code": "    def __len__(self):\n        \"\"\"Returns the number of intervals currently stored in the IntervalTree.\n\nThis method provides a quick access to the size of the tree, returning the length of the `all_intervals` set, which contains all the Interval objects managed by the tree. The operation is performed in constant time O(1), ensuring efficient retrieval of the tree's size.\n\nReturns:\n    int: The count of intervals present in the tree.\n\nDependencies:\n    - `self.all_intervals`: A set that holds all the intervals in the tree.\"\"\"\n        '\\n        Returns how many intervals are in the tree.\\n\\n        Completes in O(1) time.\\n        :rtype: int\\n        '\n        return len(self.all_intervals)",
        "docstring": "Returns the number of intervals currently stored in the IntervalTree.\n\nThis method provides a quick access to the size of the tree, returning the length of the `all_intervals` set, which contains all the Interval objects managed by the tree. The operation is performed in constant time O(1), ensuring efficient retrieval of the tree's size.\n\nReturns:\n    int: The count of intervals present in the tree.\n\nDependencies:\n    - `self.all_intervals`: A set that holds all the intervals in the tree.",
        "signature": "def __len__(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Determines whether two IntervalTree instances are equal by comparing their contained intervals.\n\nParameters:\n- other: The object to compare with the current IntervalTree. It can be another IntervalTree instance.\n\nReturns:\n- bool: Returns True if both instances are of the same type and contain the same intervals; otherwise returns False.\n\nNotes:\n- The comparison relies on `self.all_intervals`, which is a set of Interval objects within the tree. The equality is checked using the `==` operator on sets, which evaluates whether both sets have the same elements.\n- The method completes in O(n) time if the sizes of the trees are the same; otherwise, it completes in O(1) time by first checking the type and size.\"\"\"\n        '\\n        Whether two IntervalTrees are equal.\\n\\n        Completes in O(n) time if sizes are equal; O(1) time otherwise.\\n        :rtype: bool\\n        '\n        return isinstance(other, IntervalTree) and self.all_intervals == other.all_intervals",
        "docstring": "Determines whether two IntervalTree instances are equal by comparing their contained intervals.\n\nParameters:\n- other: The object to compare with the current IntervalTree. It can be another IntervalTree instance.\n\nReturns:\n- bool: Returns True if both instances are of the same type and contain the same intervals; otherwise returns False.\n\nNotes:\n- The comparison relies on `self.all_intervals`, which is a set of Interval objects within the tree. The equality is checked using the `==` operator on sets, which evaluates whether both sets have the same elements.\n- The method completes in O(n) time if the sizes of the trees are the same; otherwise, it completes in O(1) time by first checking the type and size.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__reduce__": {
        "code": "    def __reduce__(self):\n        \"\"\"Prepares the IntervalTree instance for pickling by returning a tuple containing the\n    class itself and a tuple of sorted intervals currently in the tree. This method allows\n    for object serialization, enabling the IntervalTree to be saved to a file or transmitted \n    over a network, and subsequently restored with the same structure and data.\n\n    Returns:\n        tuple: A tuple containing the class (IntervalTree) and a tuple of sorted \n        intervals (sorted(self.all_intervals)) which represents the state of the tree.\n\n    Dependencies:\n        - `self.all_intervals`: A set containing all Interval objects in the tree, which \n        is used to create the serialized version of the tree. The use of `sorted()` ensures \n        the order of intervals is maintained during serialization.\"\"\"\n        '\\n        For pickle-ing.\\n        :rtype: tuple\\n        '\n        return (IntervalTree, (sorted(self.all_intervals),))",
        "docstring": "Prepares the IntervalTree instance for pickling by returning a tuple containing the\nclass itself and a tuple of sorted intervals currently in the tree. This method allows\nfor object serialization, enabling the IntervalTree to be saved to a file or transmitted \nover a network, and subsequently restored with the same structure and data.\n\nReturns:\n    tuple: A tuple containing the class (IntervalTree) and a tuple of sorted \n    intervals (sorted(self.all_intervals)) which represents the state of the tree.\n\nDependencies:\n    - `self.all_intervals`: A set containing all Interval objects in the tree, which \n    is used to create the serialized version of the tree. The use of `sorted()` ensures \n    the order of intervals is maintained during serialization.",
        "signature": "def __reduce__(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      }
    },
    "intervaltree/interval.py": {
      "Interval.__new__": {
        "code": "    def __new__(cls, begin, end, data=None):\n        \"\"\"Creates a new instance of the Interval class. This method overrides the default instance creation behavior to ensure that the instance is initialized correctly using the parameters for the beginning, end, and optional data value of the interval.\n\nParameters:\n- cls: The class itself (Interval).\n- begin (Number): The starting point of the interval.\n- end (Number): The ending point of the interval.\n- data (optional): An optional value associated with the interval, defaults to None.\n\nReturns:\n- An instance of the Interval class with the specified begin, end, and data attributes.\n\nThis method interacts with the inherited functionality of namedtuple to create an immutable instance while allowing for efficient memory usage by defining __slots__ in the class to avoid the default __dict__ for each instance.\"\"\"\n        return super(Interval, cls).__new__(cls, begin, end, data)",
        "docstring": "Creates a new instance of the Interval class. This method overrides the default instance creation behavior to ensure that the instance is initialized correctly using the parameters for the beginning, end, and optional data value of the interval.\n\nParameters:\n- cls: The class itself (Interval).\n- begin (Number): The starting point of the interval.\n- end (Number): The ending point of the interval.\n- data (optional): An optional value associated with the interval, defaults to None.\n\nReturns:\n- An instance of the Interval class with the specified begin, end, and data attributes.\n\nThis method interacts with the inherited functionality of namedtuple to create an immutable instance while allowing for efficient memory usage by defining __slots__ in the class to avoid the default __dict__ for each instance.",
        "signature": "def __new__(cls, begin, end, data=None):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__hash__": {
        "code": "    def __hash__(self):\n        \"\"\"Calculates the hash value for the Interval instance, which is based on the `begin` and `end` attributes of the interval. This is crucial for using Interval objects as keys in hash-based collections like dictionaries or sets. The method returns a unique integer value derived from the tuple `(self.begin, self.end)`, ensuring that intervals with the same start and end points yield the same hash value. No parameters are required, and the operation does not modify the state of the instance.\"\"\"\n        '\\n        Depends on begin and end only.\\n        :return: hash\\n        :rtype: Number\\n        '\n        return hash((self.begin, self.end))",
        "docstring": "Calculates the hash value for the Interval instance, which is based on the `begin` and `end` attributes of the interval. This is crucial for using Interval objects as keys in hash-based collections like dictionaries or sets. The method returns a unique integer value derived from the tuple `(self.begin, self.end)`, ensuring that intervals with the same start and end points yield the same hash value. No parameters are required, and the operation does not modify the state of the instance.",
        "signature": "def __hash__(self):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Determines if the current Interval instance is equal to another Interval instance based on their starting point (`begin`), ending point (`end`), and associated data (`data`). This method allows for direct comparisons of Interval instances for equality. \n\nParameters:\n- `other` (Interval): The Interval instance to compare against.\n\nReturns:\n- bool: True if both intervals have the same `begin`, `end`, and `data`; otherwise, False.\n\nThis method reinforces the integrity of Interval comparisons by ensuring that all relevant attributes are considered during equality checks.\"\"\"\n        '\\n        Whether the begins equal, the ends equal, and the data fields\\n        equal. Compare range_matches().\\n        :param other: Interval\\n        :return: True or False\\n        :rtype: bool\\n        '\n        return self.begin == other.begin and self.end == other.end and (self.data == other.data)",
        "docstring": "Determines if the current Interval instance is equal to another Interval instance based on their starting point (`begin`), ending point (`end`), and associated data (`data`). This method allows for direct comparisons of Interval instances for equality. \n\nParameters:\n- `other` (Interval): The Interval instance to compare against.\n\nReturns:\n- bool: True if both intervals have the same `begin`, `end`, and `data`; otherwise, False.\n\nThis method reinforces the integrity of Interval comparisons by ensuring that all relevant attributes are considered during equality checks.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__lt__": {
        "code": "    def __lt__(self, other):\n        \"\"\"Less than operator for the Interval class. This method compares the current Interval instance with another Interval or point to determine if it is less than the specified other value. The comparison is facilitated by the __cmp__() method, which checks the order based on the 'begin' and 'end' attributes of the Intervals. \n\n:param other: An Interval instance or a single point value to compare against.\n:return: True if the current Interval is less than the other value, otherwise False.\n:rtype: bool\"\"\"\n        '\\n        Less than operator. Parrots __cmp__()\\n        :param other: Interval or point\\n        :return: True or False\\n        :rtype: bool\\n        '\n        return self.__cmp__(other) < 0",
        "docstring": "Less than operator for the Interval class. This method compares the current Interval instance with another Interval or point to determine if it is less than the specified other value. The comparison is facilitated by the __cmp__() method, which checks the order based on the 'begin' and 'end' attributes of the Intervals. \n\n:param other: An Interval instance or a single point value to compare against.\n:return: True if the current Interval is less than the other value, otherwise False.\n:rtype: bool",
        "signature": "def __lt__(self, other):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__reduce__": {
        "code": "    def __reduce__(self):\n        \"\"\"Returns the necessary data to reconstruct the Interval object for serialization using the pickle module. It leverages the _get_fields() method to extract the relevant fields (begin, end, and data) needed to reconstruct the Interval instance, ensuring that all necessary state information is captured. This method does not take any parameters and returns a tuple containing the class itself and the extracted fields. This interaction with _get_fields() enables the preservation of the internal data structures when an instance is serialized and later deserialized, facilitating the object's persistence.\"\"\"\n        '\\n        For pickle-ing.\\n        :return: pickle data\\n        :rtype: tuple\\n        '\n        return (Interval, self._get_fields())",
        "docstring": "Returns the necessary data to reconstruct the Interval object for serialization using the pickle module. It leverages the _get_fields() method to extract the relevant fields (begin, end, and data) needed to reconstruct the Interval instance, ensuring that all necessary state information is captured. This method does not take any parameters and returns a tuple containing the class itself and the extracted fields. This interaction with _get_fields() enables the preservation of the internal data structures when an instance is serialized and later deserialized, facilitating the object's persistence.",
        "signature": "def __reduce__(self):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      }
    }
  },
  "dependency_dict": {
    "intervaltree/intervaltree.py:IntervalTree:__init__": {
      "intervaltree/intervaltree.py": {
        "IntervalTree._add_boundaries": {
          "code": "    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1",
          "docstring": "Records the boundaries of the interval in the boundary table.",
          "signature": "def _add_boundaries(self, interval):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        }
      },
      "intervaltree/interval.py": {
        "Interval.is_null": {
          "code": "    def is_null(self):\n        \"\"\"\n        Whether this equals the null interval.\n        :return: True if end <= begin else False\n        :rtype: bool\n        \"\"\"\n        return self.begin >= self.end",
          "docstring": "Whether this equals the null interval.\n:return: True if end <= begin else False\n:rtype: bool",
          "signature": "def is_null(self):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      },
      "intervaltree/node.py": {
        "Node.from_intervals": {
          "code": "    def from_intervals(cls, intervals):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        if not intervals:\n            return None\n        return Node.from_sorted_intervals(sorted(intervals))",
          "docstring": ":rtype : Node",
          "signature": "def from_intervals(cls, intervals):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:verify": {
      "intervaltree/node.py": {
        "Node.all_children": {
          "code": "    def all_children(self):\n        return self.all_children_helper(set())",
          "docstring": "",
          "signature": "def all_children(self):",
          "type": "Method",
          "class_signature": "class Node(object):"
        },
        "Node.verify": {
          "code": "    def verify(self, parents=set()):\n        \"\"\"\n        ## DEBUG ONLY ##\n        Recursively ensures that the invariants of an interval subtree\n        hold.\n        \"\"\"\n        assert(isinstance(self.s_center, set))\n\n        bal = self.balance\n        assert abs(bal) < 2, \\\n            \"Error: Rotation should have happened, but didn't! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n        self.refresh_balance()\n        assert bal == self.balance, \\\n            \"Error: self.balance not set correctly! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n\n        assert self.s_center, \\\n            \"Error: s_center is empty! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n        for iv in self.s_center:\n            assert hasattr(iv, 'begin')\n            assert hasattr(iv, 'end')\n            assert iv.begin < iv.end\n            assert iv.overlaps(self.x_center)\n            for parent in sorted(parents):\n                assert not iv.contains_point(parent), \\\n                    \"Error: Overlaps ancestor ({})! \\n{}\\n\\n{}\".format(\n                        parent, iv, self.print_structure(tostring=True)\n                    )\n        if self[0]:\n            assert self[0].x_center < self.x_center, \\\n                \"Error: Out-of-order left child! {}\".format(self.x_center)\n            self[0].verify(parents.union([self.x_center]))\n        if self[1]:\n            assert self[1].x_center > self.x_center, \\\n                \"Error: Out-of-order right child! {}\".format(self.x_center)\n            self[1].verify(parents.union([self.x_center]))",
          "docstring": "## DEBUG ONLY ##\nRecursively ensures that the invariants of an interval subtree\nhold.",
          "signature": "def verify(self, parents=set()):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      },
      "intervaltree/interval.py": {
        "Interval.is_null": {
          "code": "    def is_null(self):\n        \"\"\"\n        Whether this equals the null interval.\n        :return: True if end <= begin else False\n        :rtype: bool\n        \"\"\"\n        return self.begin >= self.end",
          "docstring": "Whether this equals the null interval.\n:return: True if end <= begin else False\n:rtype: bool",
          "signature": "def is_null(self):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:copy": {},
    "intervaltree/intervaltree.py:IntervalTree:__reduce__": {},
    "intervaltree/interval.py:Interval:__reduce__": {
      "intervaltree/interval.py": {
        "Interval._get_fields": {
          "code": "    def _get_fields(self):\n        \"\"\"\n        Used by str, unicode, repr and __reduce__.\n\n        Returns only the fields necessary to reconstruct the Interval.\n        :return: reconstruction info\n        :rtype: tuple\n        \"\"\"\n        if self.data is not None:\n            return (self.begin, self.end, self.data)\n        else:\n            return (self.begin, self.end)",
          "docstring": "Used by str, unicode, repr and __reduce__.\n\nReturns only the fields necessary to reconstruct the Interval.\n:return: reconstruction info\n:rtype: tuple",
          "signature": "def _get_fields(self):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:__getitem__": {
      "intervaltree/intervaltree.py": {
        "IntervalTree.at": {
          "code": "    def at(self, p):\n        \"\"\"\n        Returns the set of all intervals that contain p.\n\n        Completes in O(m + log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        return root.search_point(p, set())",
          "docstring": "Returns the set of all intervals that contain p.\n\nCompletes in O(m + log n) time, where:\n  * n = size of the tree\n  * m = number of matches\n:rtype: set of Interval",
          "signature": "def at(self, p):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        }
      }
    },
    "intervaltree/interval.py:Interval:__lt__": {
      "intervaltree/interval.py": {
        "Interval.__cmp__": {
          "code": "    def __cmp__(self, other):\n        \"\"\"\n        Tells whether other sorts before, after or equal to this\n        Interval.\n\n        Sorting is by begins, then by ends, then by data fields.\n\n        If data fields are not both sortable types, data fields are\n        compared alphabetically by type name.\n        :param other: Interval\n        :return: -1, 0, 1\n        :rtype: int\n        \"\"\"\n        s = self[0:2]\n        try:\n            o = other[0:2]\n        except:\n            o = (other,)\n        if s != o:\n            return -1 if s < o else 1\n        try:\n            if self.data == other.data:\n                return 0\n            return -1 if self.data < other.data else 1\n        except TypeError:\n            s = type(self.data).__name__\n            o = type(other.data).__name__\n            if s == o:\n                return 0\n            return -1 if s < o else 1",
          "docstring": "Tells whether other sorts before, after or equal to this\nInterval.\n\nSorting is by begins, then by ends, then by data fields.\n\nIf data fields are not both sortable types, data fields are\ncompared alphabetically by type name.\n:param other: Interval\n:return: -1, 0, 1\n:rtype: int",
          "signature": "def __cmp__(self, other):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:from_tuples": {},
    "intervaltree/intervaltree.py:IntervalTree:__eq__": {},
    "intervaltree/intervaltree.py:IntervalTree:__contains__": {}
  },
  "call_tree": {
    "test/intervaltree_methods/copy_test.py:test_copy": {
      "intervaltree/interval.py:Interval:__new__": {},
      "intervaltree/intervaltree.py:IntervalTree:__init__": {
        "intervaltree/interval.py:Interval:__hash__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:from_intervals": {
          "intervaltree/interval.py:Interval:__lt__": {
            "intervaltree/interval.py:Interval:__cmp__": {}
          },
          "intervaltree/node.py:Node:from_sorted_intervals": {
            "intervaltree/node.py:Node:__init__": {
              "intervaltree/node.py:Node:rotate": {
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            },
            "intervaltree/node.py:Node:init_from_sorted": {
              "intervaltree/interval.py:Interval:__hash__": {},
              "intervaltree/node.py:Node:from_sorted_intervals": {
                "[ignored_or_cut_off]": "..."
              },
              "intervaltree/node.py:Node:rotate": {
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            }
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {},
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:verify": {
        "intervaltree/interval.py:Interval:Interval": {},
        "intervaltree/node.py:Node:all_children": {
          "intervaltree/node.py:Node:all_children_helper": {
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:all_children_helper": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:verify": {
          "intervaltree/node.py:Node:refresh_balance": {},
          "intervaltree/interval.py:Interval:overlaps": {
            "intervaltree/interval.py:Interval:contains_point": {}
          },
          "intervaltree/node.py:Node:__getitem__": {},
          "intervaltree/node.py:Node:verify": {
            "[ignored_or_cut_off]": "..."
          }
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:copy": {
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/intervaltree.py:IntervalTree:__init__": {
          "intervaltree/interval.py:Interval:copy": {
            "intervaltree/interval.py:Interval:__new__": {}
          },
          "intervaltree/interval.py:Interval:__hash__": {},
          "intervaltree/interval.py:Interval:is_null": {},
          "intervaltree/node.py:Node:from_intervals": {
            "intervaltree/interval.py:Interval:__lt__": {
              "intervaltree/interval.py:Interval:__cmp__": {}
            },
            "intervaltree/node.py:Node:from_sorted_intervals": {
              "intervaltree/node.py:Node:__init__": {
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              },
              "intervaltree/node.py:Node:init_from_sorted": {
                "intervaltree/interval.py:Interval:__hash__": {},
                "intervaltree/node.py:Node:from_sorted_intervals": {
                  "[ignored_or_cut_off]": "..."
                },
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              }
            }
          },
          "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {}
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:__reduce__": {
        "intervaltree/interval.py:Interval:__lt__": {
          "intervaltree/interval.py:Interval:__cmp__": {}
        }
      },
      "intervaltree/interval.py:Interval:__reduce__": {
        "intervaltree/interval.py:Interval:_get_fields": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:__getitem__": {
        "intervaltree/intervaltree.py:IntervalTree:at": {
          "intervaltree/node.py:Node:search_point": {
            "intervaltree/interval.py:Interval:__hash__": {}
          }
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
      "intervaltree/intervaltree.py:IntervalTree:__len__": {},
      "intervaltree/interval.py:Interval:__lt__": {
        "intervaltree/interval.py:Interval:__cmp__": {}
      },
      "intervaltree/interval.py:Interval:__eq__": {}
    },
    "test/intervaltree_methods/copy_test.py:test_copy_cast": {
      "intervaltree/intervaltree.py:IntervalTree:from_tuples": {
        "intervaltree/interval.py:Interval:__new__": {},
        "intervaltree/intervaltree.py:IntervalTree:__init__": {
          "intervaltree/interval.py:Interval:__hash__": {},
          "intervaltree/interval.py:Interval:is_null": {},
          "intervaltree/node.py:Node:from_intervals": {
            "intervaltree/interval.py:Interval:__lt__": {
              "intervaltree/interval.py:Interval:__cmp__": {}
            },
            "intervaltree/node.py:Node:from_sorted_intervals": {
              "intervaltree/node.py:Node:__init__": {
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              },
              "intervaltree/node.py:Node:init_from_sorted": {
                "intervaltree/interval.py:Interval:__hash__": {},
                "intervaltree/node.py:Node:from_sorted_intervals": {
                  "[ignored_or_cut_off]": "..."
                },
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              }
            }
          },
          "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {}
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:__init__": {
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/interval.py:Interval:__hash__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:from_intervals": {
          "intervaltree/interval.py:Interval:__lt__": {
            "intervaltree/interval.py:Interval:__cmp__": {}
          },
          "intervaltree/node.py:Node:from_sorted_intervals": {
            "intervaltree/node.py:Node:__init__": {
              "intervaltree/node.py:Node:rotate": {
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            },
            "intervaltree/node.py:Node:init_from_sorted": {
              "intervaltree/interval.py:Interval:__hash__": {},
              "intervaltree/node.py:Node:from_sorted_intervals": {
                "[ignored_or_cut_off]": "..."
              },
              "intervaltree/node.py:Node:rotate": {
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            }
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:verify": {
        "intervaltree/node.py:Node:all_children": {
          "intervaltree/node.py:Node:all_children_helper": {
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:all_children_helper": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:verify": {
          "intervaltree/node.py:Node:refresh_balance": {},
          "intervaltree/interval.py:Interval:overlaps": {
            "intervaltree/interval.py:Interval:contains_point": {}
          },
          "intervaltree/node.py:Node:__getitem__": {},
          "intervaltree/node.py:Node:verify": {
            "[ignored_or_cut_off]": "..."
          }
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:__eq__": {
        "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
      "intervaltree/intervaltree.py:IntervalTree:__len__": {},
      "intervaltree/intervaltree.py:IntervalTree:__contains__": {
        "intervaltree/interval.py:Interval:__hash__": {}
      },
      "intervaltree/interval.py:Interval:__eq__": {},
      "intervaltree/interval.py:Interval:__hash__": {},
      "intervaltree/intervaltree.py:IntervalTree:items": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-copy_test/intervaltree-copy_test/test/intervaltree_methods/setlike_test.py:test_update": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-copy_test/intervaltree-copy_test/test/intervaltree_methods/setlike_test.py:test_difference": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-copy_test/intervaltree-copy_test/test/intervaltree_methods/setlike_test.py:test_difference_operator": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-copy_test/intervaltree-copy_test/test/optimality/optimality_test_matrix.py:OptimalityTestMatrix:test_prebuilt": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-copy_test/intervaltree-copy_test/modified_testcases/optimality/optimality_test_matrix.py:OptimalityTestMatrix:test_prebuilt": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    }
  },
  "PRD": "# PROJECT NAME: intervaltree-copy_test\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 intervaltree/\n    \u251c\u2500\u2500 interval.py\n    \u2502   \u251c\u2500\u2500 Interval.__eq__\n    \u2502   \u251c\u2500\u2500 Interval.__hash__\n    \u2502   \u251c\u2500\u2500 Interval.__lt__\n    \u2502   \u251c\u2500\u2500 Interval.__new__\n    \u2502   \u2514\u2500\u2500 Interval.__reduce__\n    \u2514\u2500\u2500 intervaltree.py\n        \u251c\u2500\u2500 IntervalTree.IntervalTree\n        \u251c\u2500\u2500 IntervalTree.__contains__\n        \u251c\u2500\u2500 IntervalTree.__eq__\n        \u251c\u2500\u2500 IntervalTree.__getitem__\n        \u251c\u2500\u2500 IntervalTree.__init__\n        \u251c\u2500\u2500 IntervalTree.__iter__\n        \u251c\u2500\u2500 IntervalTree.__len__\n        \u251c\u2500\u2500 IntervalTree.__reduce__\n        \u251c\u2500\u2500 IntervalTree.copy\n        \u251c\u2500\u2500 IntervalTree.from_tuples\n        \u251c\u2500\u2500 IntervalTree.items\n        \u2514\u2500\u2500 IntervalTree.verify\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for creating, managing, and querying mutable, self-balancing interval trees, enabling efficient operations such as point-based lookups, range overlap searches, and range envelopment queries. It supports interval-based data structures with advanced features like copying (both shallow and deep copies) and serialization, ensuring flexibility and data consistency. By offering efficient and intuitive tools for interval manipulation, the module addresses complex use cases involving overlapping or nested intervals, such as scheduling, range conflict detection, and data indexing, simplifying development workflows for users and developers.\n\n## FILE 1: intervaltree/intervaltree.py\n\n- CLASS METHOD: IntervalTree.__contains__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __contains__(self, item):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns whether the specified item exists as an exact match in the IntervalTree. This method only checks for exact interval matches, not overlaps; for checking if any interval overlaps with a point, use the `overlaps()` method instead. The search is conducted in constant time, O(1), by checking membership in `self.all_intervals`, which is a set maintaining all interval objects within the tree.\n\nParameters:\n- item: An instance of the `Interval` class or an object that is intended to be checked for membership in the tree.\n\nReturns:\n- bool: Returns True if the item matches an existing interval in the tree, otherwise returns False.\n\nDependencies:\n- Requires the `Interval` class to be correctly defined and comparable, as the membership check directly relies on the equality defined in the `__eq__` method of `Interval`. The attribute `self.all_intervals` holds all intervals in a set for efficient membership testing.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__len__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __len__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the number of intervals currently stored in the IntervalTree.\n\nThis method provides a quick access to the size of the tree, returning the length of the `all_intervals` set, which contains all the Interval objects managed by the tree. The operation is performed in constant time O(1), ensuring efficient retrieval of the tree's size.\n\nReturns:\n    int: The count of intervals present in the tree.\n\nDependencies:\n    - `self.all_intervals`: A set that holds all the intervals in the tree.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__getitem__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __getitem__(self, index):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a set of all intervals in the IntervalTree that overlap the specified index or slice. The method first checks if the index is a slice (with start and stop attributes). If it is, it retrieves overlapping intervals using the `overlap` method; if the index is a single point, it uses the `at` method to get intervals containing that point. \n\nParameters:\n- index (slice or point): This can be a point or a slice specifying the range of indices to check for overlaps.\n\nReturns:\n- set of Interval: A set containing all intervals that overlap with the specified index or range.\n\nThe method operates in O(k * log(n) + m) time complexity, where n is the size of the tree, m is the number of matches found, and k is the size of the search range (1 for single points). Notably, it utilizes the `overlap` method for range queries and `at` for single point queries, making it efficient for checking intervals against the stored intervals in the tree.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.copy\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def copy(self):\n  - DOCSTRING: \n```python\n\"\"\"\nConstruct a new IntervalTree that is a shallow copy of the current tree, using shallow copies of the intervals it contains. \n\nThis method iterates through each interval in the source tree (`self`) and creates a new IntervalTree instance containing these copied intervals. It operates in O(n*log n) time, where n is the number of intervals, due to the insertion process in the new tree.\n\nReturns:\n    IntervalTree: A new IntervalTree instance containing shallow copies of the intervals from the original tree.\n\nNotes:\n    - Since the copying is shallow, any modifications to the data in the original interval objects will reflect in the copied intervals, as both the original and the copy reference the same interval data.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.verify\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def verify(self):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks the integrity and invariants of the IntervalTree structure. This method verifies that the `top_node`'s list of all child intervals matches the `all_intervals` set, ensuring consistency in membership. It also ensures that all members are valid Interval objects and that none are null intervals. The method reconstructs the `boundary_table` and checks its consistency with the intervals in the tree.\n\nRaises an AssertionError if any of the checks fail, providing detailed output of any discrepancies found in the internal structure or membership consistency of the tree.\n\nNo parameters are required, and it does not return any value. This method is primarily used for debugging purposes to maintain the integrity of the data structure.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.from_tuples\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def from_tuples(cls, tups):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new IntervalTree from an iterable of 2- or 3-tuples representing intervals.\n\nParameters:\n- tups (iterable of tuples): An iterable containing tuples of either two or three elements, where each tuple consists of the start point, endpoint, and optionally associated data for an interval. The intervals are represented by the `Interval` class, which constructs half-open intervals `[begin, end)`.\n\nReturns:\n- IntervalTree: An instance of `IntervalTree` populated with the created `Interval` objects derived from the provided tuples.\n\nThis method leverages the `Interval` class defined in the `interval` module to create interval objects. Each interval is added to a new `IntervalTree`, which is a mutable and self-balancing structure capable of efficient interval queries and operations.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__reduce__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __reduce__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nPrepares the IntervalTree instance for pickling by returning a tuple containing the\nclass itself and a tuple of sorted intervals currently in the tree. This method allows\nfor object serialization, enabling the IntervalTree to be saved to a file or transmitted \nover a network, and subsequently restored with the same structure and data.\n\nReturns:\n    tuple: A tuple containing the class (IntervalTree) and a tuple of sorted \n    intervals (sorted(self.all_intervals)) which represents the state of the tree.\n\nDependencies:\n    - `self.all_intervals`: A set containing all Interval objects in the tree, which \n    is used to create the serialized version of the tree. The use of `sorted()` ensures \n    the order of intervals is maintained during serialization.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__init__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __init__(self, intervals=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an IntervalTree instance, optionally populating it with a set of intervals. If provided, the intervals must not include any null intervals. During initialization, the function also constructs the tree's top node from the intervals and creates a boundary table for efficient interval management.\n\nParameters:\n-----------\nintervals : iterable of Interval, optional\n    A collection of Interval objects to be added to the tree. If None, initializes an empty tree.\n\nRaises:\n--------\nValueError\n    If any of the provided intervals is null, indicating that null Interval objects are not allowed.\n\nAttributes:\n-----------\nself.all_intervals : set\n    A set that stores all unique intervals added to the tree.\nself.top_node : Node\n    The root node of the interval tree, generated from the provided intervals.\nself.boundary_table : SortedDict\n    A sorted dictionary that keeps track of the boundaries (start and end points) of the intervals for efficient querying.\n\nPerformance:\n------------\nThis initialization process completes in O(n*log n) time, where n is the number of intervals, due to the need for sorting and tree construction.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__iter__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __iter__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns an iterator over all the intervals in the IntervalTree. This method allows for easy iteration over the contained Interval objects, facilitating operations such as looping through intervals or converting the IntervalTree into a list or other iterable types.\n\n:rtype: collections.Iterable[Interval]\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.items\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def items(self):\n  - DOCSTRING: \n```python\n\"\"\"\nConstructs and returns a set containing all the intervals stored in the IntervalTree. This method provides a straightforward way to access the intervals currently managed by the tree structure without altering its state. The operation completes in O(n) time, where n is the total number of intervals in the tree. The method relies on the `all_intervals` attribute, which is a set of `Interval` objects representing the intervals contained within the tree. This attribute is modified indirectly through various methods of the class that add or remove intervals, ensuring that it accurately reflects the current state of the IntervalTree.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__eq__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether two IntervalTree instances are equal by comparing their contained intervals.\n\nParameters:\n- other: The object to compare with the current IntervalTree. It can be another IntervalTree instance.\n\nReturns:\n- bool: Returns True if both instances are of the same type and contain the same intervals; otherwise returns False.\n\nNotes:\n- The comparison relies on `self.all_intervals`, which is a set of Interval objects within the tree. The equality is checked using the `==` operator on sets, which evaluates whether both sets have the same elements.\n- The method completes in O(n) time if the sizes of the trees are the same; otherwise, it completes in O(1) time by first checking the type and size.\n\"\"\"\n```\n\n## FILE 2: intervaltree/interval.py\n\n- CLASS METHOD: Interval.__lt__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __lt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nLess than operator for the Interval class. This method compares the current Interval instance with another Interval or point to determine if it is less than the specified other value. The comparison is facilitated by the __cmp__() method, which checks the order based on the 'begin' and 'end' attributes of the Intervals. \n\n:param other: An Interval instance or a single point value to compare against.\n:return: True if the current Interval is less than the other value, otherwise False.\n:rtype: bool\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__eq__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the current Interval instance is equal to another Interval instance based on their starting point (`begin`), ending point (`end`), and associated data (`data`). This method allows for direct comparisons of Interval instances for equality. \n\nParameters:\n- `other` (Interval): The Interval instance to compare against.\n\nReturns:\n- bool: True if both intervals have the same `begin`, `end`, and `data`; otherwise, False.\n\nThis method reinforces the integrity of Interval comparisons by ensuring that all relevant attributes are considered during equality checks.\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__hash__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __hash__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculates the hash value for the Interval instance, which is based on the `begin` and `end` attributes of the interval. This is crucial for using Interval objects as keys in hash-based collections like dictionaries or sets. The method returns a unique integer value derived from the tuple `(self.begin, self.end)`, ensuring that intervals with the same start and end points yield the same hash value. No parameters are required, and the operation does not modify the state of the instance.\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__new__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __new__(cls, begin, end, data=None):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates a new instance of the Interval class. This method overrides the default instance creation behavior to ensure that the instance is initialized correctly using the parameters for the beginning, end, and optional data value of the interval.\n\nParameters:\n- cls: The class itself (Interval).\n- begin (Number): The starting point of the interval.\n- end (Number): The ending point of the interval.\n- data (optional): An optional value associated with the interval, defaults to None.\n\nReturns:\n- An instance of the Interval class with the specified begin, end, and data attributes.\n\nThis method interacts with the inherited functionality of namedtuple to create an immutable instance while allowing for efficient memory usage by defining __slots__ in the class to avoid the default __dict__ for each instance.\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__reduce__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __reduce__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the necessary data to reconstruct the Interval object for serialization using the pickle module. It leverages the _get_fields() method to extract the relevant fields (begin, end, and data) needed to reconstruct the Interval instance, ensuring that all necessary state information is captured. This method does not take any parameters and returns a tuple containing the class itself and the extracted fields. This interaction with _get_fields() enables the preservation of the internal data structures when an instance is serialized and later deserialized, facilitating the object's persistence.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "intervaltree/intervaltree.py": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom .interval import Interval\nfrom .node import Node\nfrom numbers import Number\nfrom sortedcontainers import SortedDict\nfrom copy import copy\nfrom warnings import warn\ntry:\n    from collections.abc import MutableSet\nexcept ImportError:\n    from collections import MutableSet\ntry:\n    xrange\nexcept NameError:\n    xrange = range\n\nclass IntervalTree(MutableSet):\n    \"\"\"\n    A binary lookup tree of intervals.\n    The intervals contained in the tree are represented using ``Interval(a, b, data)`` objects.\n    Each such object represents a half-open interval ``[a, b)`` with optional data.\n\n    Examples:\n    ---------\n\n    Initialize a blank tree::\n\n        >>> tree = IntervalTree()\n        >>> tree\n        IntervalTree()\n\n    Initialize a tree from an iterable set of Intervals in O(n * log n)::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-20.0, -10.0)])\n        >>> tree\n        IntervalTree([Interval(-20.0, -10.0), Interval(-10, 10)])\n        >>> len(tree)\n        2\n\n    Note that this is a set, i.e. repeated intervals are ignored. However,\n    Intervals with different data fields are regarded as different::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-10, 10), Interval(-10, 10, \"x\")])\n        >>> tree\n        IntervalTree([Interval(-10, 10), Interval(-10, 10, 'x')])\n        >>> len(tree)\n        2\n\n    Insertions::\n        >>> tree = IntervalTree()\n        >>> tree[0:1] = \"data\"\n        >>> tree.add(Interval(10, 20))\n        >>> tree.addi(19.9, 20)\n        >>> tree\n        IntervalTree([Interval(0, 1, 'data'), Interval(10, 20), Interval(19.9, 20)])\n        >>> tree.update([Interval(19.9, 20.1), Interval(20.1, 30)])\n        >>> len(tree)\n        5\n\n        Inserting the same Interval twice does nothing::\n            >>> tree = IntervalTree()\n            >>> tree[-10:20] = \"arbitrary data\"\n            >>> tree[-10:20] = None  # Note that this is also an insertion\n            >>> tree\n            IntervalTree([Interval(-10, 20), Interval(-10, 20, 'arbitrary data')])\n            >>> tree[-10:20] = None  # This won't change anything\n            >>> tree[-10:20] = \"arbitrary data\" # Neither will this\n            >>> len(tree)\n            2\n\n    Deletions::\n        >>> tree = IntervalTree(Interval(b, e) for b, e in [(-10, 10), (-20, -10), (10, 20)])\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(-10, 10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        Traceback (most recent call last):\n        ...\n        ValueError\n        >>> tree.discard(Interval(-10, 10))  # Same as remove, but no exception on failure\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n\n    Delete intervals, overlapping a given point::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.1)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1)])\n\n    Delete intervals, overlapping an interval::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(0, 0.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.7, 1.8)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.6)  # Null interval does nothing\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.5)  # Ditto\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n\n    Delete intervals, enveloped in the range::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.0, 1.5)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.1, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.7)\n        >>> tree\n        IntervalTree()\n\n    Point queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[-1.1]   == set([Interval(-1.1, 1.1)])\n        >>> assert tree.at(1.1) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])   # Same as tree[1.1]\n        >>> assert tree.at(1.5) == set([Interval(0.5, 1.7)])                        # Same as tree[1.5]\n\n    Interval overlap queries\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.overlap(1.7, 1.8) == set()\n        >>> assert tree.overlap(1.5, 1.8) == set([Interval(0.5, 1.7)])\n        >>> assert tree[1.5:1.8] == set([Interval(0.5, 1.7)])                       # same as previous\n        >>> assert tree.overlap(1.1, 1.8) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[1.1:1.8] == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])  # same as previous\n\n    Interval envelop queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.envelop(-0.5, 0.5) == set()\n        >>> assert tree.envelop(-0.5, 1.5) == set([Interval(-0.5, 1.5)])\n\n    Membership queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> Interval(-0.5, 0.5) in tree\n        False\n        >>> Interval(-1.1, 1.1) in tree\n        True\n        >>> Interval(-1.1, 1.1, \"x\") in tree\n        False\n        >>> tree.overlaps(-1.1)\n        True\n        >>> tree.overlaps(1.7)\n        False\n        >>> tree.overlaps(1.7, 1.8)\n        False\n        >>> tree.overlaps(-1.2, -1.1)\n        False\n        >>> tree.overlaps(-1.2, -1.0)\n        True\n\n    Sizing::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> len(tree)\n        3\n        >>> tree.is_empty()\n        False\n        >>> IntervalTree().is_empty()\n        True\n        >>> not tree\n        False\n        >>> not IntervalTree()\n        True\n        >>> print(tree.begin())    # using print() because of floats in Python 2.6\n        -1.1\n        >>> print(tree.end())      # ditto\n        1.7\n\n    Iteration::\n\n        >>> tree = IntervalTree([Interval(-11, 11), Interval(-5, 15), Interval(5, 17)])\n        >>> [iv.begin for iv in sorted(tree)]\n        [-11, -5, 5]\n        >>> assert tree.items() == set([Interval(-5, 15), Interval(-11, 11), Interval(5, 17)])\n\n    Copy- and typecasting, pickling::\n\n        >>> tree0 = IntervalTree([Interval(0, 1, \"x\"), Interval(1, 2, [\"x\"])])\n        >>> tree1 = IntervalTree(tree0)  # Shares Interval objects\n        >>> tree2 = tree0.copy()         # Shallow copy (same as above, as Intervals are singletons)\n        >>> import pickle\n        >>> tree3 = pickle.loads(pickle.dumps(tree0))  # Deep copy\n        >>> list(tree0[1])[0].data[0] = \"y\"  # affects shallow copies, but not deep copies\n        >>> tree0\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree1\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree2\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree3\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['x'])])\n\n    Equality testing::\n\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1)])\n        True\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1, \"x\")])\n        False\n    \"\"\"\n\n    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1\n\n    def _remove_boundaries(self, interval):\n        \"\"\"\n        Removes the boundaries of the interval from the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if self.boundary_table[begin] == 1:\n            del self.boundary_table[begin]\n        else:\n            self.boundary_table[begin] -= 1\n        if self.boundary_table[end] == 1:\n            del self.boundary_table[end]\n        else:\n            self.boundary_table[end] -= 1\n\n    def add(self, interval):\n        \"\"\"\n        Adds an interval to the tree, if not already present.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval in self:\n            return\n        if interval.is_null():\n            raise ValueError('IntervalTree: Null Interval objects not allowed in IntervalTree: {0}'.format(interval))\n        if not self.top_node:\n            self.top_node = Node.from_interval(interval)\n        else:\n            self.top_node = self.top_node.add(interval)\n        self.all_intervals.add(interval)\n        self._add_boundaries(interval)\n    append = add\n\n    def addi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for add(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.add(Interval(begin, end, data))\n    appendi = addi\n\n    def update(self, intervals):\n        \"\"\"\n        Given an iterable of intervals, add them to the tree.\n\n        Completes in O(m*log(n+m), where m = number of intervals to\n        add.\n        \"\"\"\n        for iv in intervals:\n            self.add(iv)\n\n    def remove(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, raises\n        ValueError.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval not in self:\n            raise ValueError\n        self.top_node = self.top_node.remove(interval)\n        self.all_intervals.remove(interval)\n        self._remove_boundaries(interval)\n\n    def removei(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for remove(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.remove(Interval(begin, end, data))\n\n    def discard(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, does\n        nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval not in self:\n            return\n        self.all_intervals.discard(interval)\n        self.top_node = self.top_node.discard(interval)\n        self._remove_boundaries(interval)\n\n    def discardi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for discard(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.discard(Interval(begin, end, data))\n\n    def difference(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals in self but not\n        in other.\n        \"\"\"\n        ivs = set()\n        for iv in self:\n            if iv not in other:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def difference_update(self, other):\n        \"\"\"\n        Removes all intervals in other from self.\n        \"\"\"\n        for iv in other:\n            self.discard(iv)\n\n    def union(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals from self\n        and other.\n        \"\"\"\n        return IntervalTree(set(self).union(other))\n\n    def intersection(self, other):\n        \"\"\"\n        Returns a new tree of all intervals common to both self and\n        other.\n        \"\"\"\n        ivs = set()\n        shorter, longer = sorted([self, other], key=len)\n        for iv in shorter:\n            if iv in longer:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def intersection_update(self, other):\n        \"\"\"\n        Removes intervals from self unless they also exist in other.\n        \"\"\"\n        ivs = list(self)\n        for iv in ivs:\n            if iv not in other:\n                self.remove(iv)\n\n    def symmetric_difference(self, other):\n        \"\"\"\n        Return a tree with elements only in self or other but not\n        both.\n        \"\"\"\n        if not isinstance(other, set):\n            other = set(other)\n        me = set(self)\n        ivs = me.difference(other).union(other.difference(me))\n        return IntervalTree(ivs)\n\n    def symmetric_difference_update(self, other):\n        \"\"\"\n        Throws out all intervals except those only in self or other,\n        not both.\n        \"\"\"\n        other = set(other)\n        ivs = list(self)\n        for iv in ivs:\n            if iv in other:\n                self.remove(iv)\n                other.remove(iv)\n        self.update(other)\n\n    def remove_overlap(self, begin, end=None):\n        \"\"\"\n        Removes all intervals overlapping the given point or range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range (this is 1 for a point)\n        \"\"\"\n        hitlist = self.at(begin) if end is None else self.overlap(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def remove_envelop(self, begin, end):\n        \"\"\"\n        Removes all intervals completely enveloped in the given range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range\n        \"\"\"\n        hitlist = self.envelop(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def chop(self, begin, end, datafunc=None):\n        \"\"\"\n        Like remove_envelop(), but trims back Intervals hanging into\n        the chopped area so that nothing overlaps.\n        \"\"\"\n        insertions = set()\n        begin_hits = [iv for iv in self.at(begin) if iv.begin < begin]\n        end_hits = [iv for iv in self.at(end) if iv.end > end]\n        if datafunc:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, datafunc(iv, True)))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, datafunc(iv, False)))\n        else:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, iv.data))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, iv.data))\n        self.remove_envelop(begin, end)\n        self.difference_update(begin_hits)\n        self.difference_update(end_hits)\n        self.update(insertions)\n\n    def slice(self, point, datafunc=None):\n        \"\"\"\n        Split Intervals that overlap point into two new Intervals. if\n        specified, uses datafunc(interval, islower=True/False) to\n        set the data field of the new Intervals.\n        :param point: where to slice\n        :param datafunc(interval, isupper): callable returning a new\n        value for the interval's data field\n        \"\"\"\n        hitlist = set((iv for iv in self.at(point) if iv.begin < point))\n        insertions = set()\n        if datafunc:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, datafunc(iv, True)))\n                insertions.add(Interval(point, iv.end, datafunc(iv, False)))\n        else:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, iv.data))\n                insertions.add(Interval(point, iv.end, iv.data))\n        self.difference_update(hitlist)\n        self.update(insertions)\n\n    def clear(self):\n        \"\"\"\n        Empties the tree.\n\n        Completes in O(1) tine.\n        \"\"\"\n        self.__init__()\n\n    def find_nested(self):\n        \"\"\"\n        Returns a dictionary mapping parent intervals to sets of\n        intervals overlapped by and contained in the parent.\n\n        Completes in O(n^2) time.\n        :rtype: dict of [Interval, set of Interval]\n        \"\"\"\n        result = {}\n\n        def add_if_nested():\n            if parent.contains_interval(child):\n                if parent not in result:\n                    result[parent] = set()\n                result[parent].add(child)\n        long_ivs = sorted(self.all_intervals, key=Interval.length, reverse=True)\n        for i, parent in enumerate(long_ivs):\n            for child in long_ivs[i + 1:]:\n                add_if_nested()\n        return result\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        point or range.\n\n        Completes in O(r*log n) time, where r is the size of the\n        search range.\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return self.overlaps_range(begin, end)\n        elif isinstance(begin, Number):\n            return self.overlaps_point(begin)\n        else:\n            return self.overlaps_range(begin.begin, begin.end)\n\n    def overlaps_point(self, p):\n        \"\"\"\n        Returns whether some interval in the tree overlaps p.\n\n        Completes in O(log n) time.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        return bool(self.top_node.contains_point(p))\n\n    def overlaps_range(self, begin, end):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        range. Returns False if given a null interval over which to\n        test.\n\n        Completes in O(r*log n) time, where r is the range length and n\n        is the table size.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        elif begin >= end:\n            return False\n        elif self.overlaps_point(begin):\n            return True\n        return any((self.overlaps_point(bound) for bound in self.boundary_table if begin < bound < end))\n\n    def split_overlaps(self):\n        \"\"\"\n        Finds all intervals with overlapping ranges and splits them\n        along the range boundaries.\n\n        Completes in worst-case O(n^2*log n) time (many interval\n        boundaries are inside many intervals), best-case O(n*log n)\n        time (small number of overlaps << n per interval).\n        \"\"\"\n        if not self:\n            return\n        if len(self.boundary_table) == 2:\n            return\n        bounds = sorted(self.boundary_table)\n        new_ivs = set()\n        for lbound, ubound in zip(bounds[:-1], bounds[1:]):\n            for iv in self[lbound]:\n                new_ivs.add(Interval(lbound, ubound, iv.data))\n        self.__init__(new_ivs)\n\n    def merge_overlaps(self, data_reducer=None, data_initializer=None, strict=True):\n        \"\"\"\n        Finds all intervals with overlapping ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initializer created with copy.copy(data_initializer).\n\n        If strict is True (default), intervals are only merged if\n        their ranges actually overlap; adjacent, touching intervals\n        will not be merged. If strict is False, intervals are merged\n        even if they are only end-to-end adjacent.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                if higher.begin < lower.end or (not strict and higher.begin == lower.end):\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def merge_equals(self, data_reducer=None, data_initializer=None):\n        \"\"\"\n        Finds all intervals with equal ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                if higher.range_matches(lower):\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def merge_neighbors(self, data_reducer=None, data_initializer=None, distance=1, strict=True):\n        \"\"\"\n        Finds all adjacent intervals with range terminals less than or equal to\n        the given distance and merges them into a single interval. If provided,\n        uses data_reducer and data_initializer with similar semantics to\n        Python's built-in reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        If strict is True (default), only discrete intervals are merged if\n        their ranges are within the given distance; overlapping intervals\n        will not be merged. If strict is False, both neighbors and overlapping\n        intervals are merged.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                margin = higher.begin - lower.end\n                if margin <= distance:\n                    if strict and margin < 0:\n                        new_series()\n                        continue\n                    else:\n                        upper_bound = max(lower.end, higher.end)\n                        if data_reducer is not None:\n                            current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                        else:\n                            current_reduced[0] = None\n                        merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def is_empty(self):\n        \"\"\"\n        Returns whether the tree is empty.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return 0 == len(self)\n\n    def at(self, p):\n        \"\"\"\n        Returns the set of all intervals that contain p.\n\n        Completes in O(m + log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        return root.search_point(p, set())\n\n    def envelop(self, begin, end=None):\n        \"\"\"\n        Returns the set of all intervals fully contained in the range\n        [begin, end).\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.envelop(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)\n        result.update(root.search_overlap((boundary_table.keys()[index] for index in xrange(bound_begin, bound_end))))\n        result = set((iv for iv in result if iv.begin >= begin and iv.end <= end))\n        return result\n\n    def overlap(self, begin, end=None):\n        \"\"\"\n        Returns a set of all intervals overlapping the given range.\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.overlap(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)\n        result.update(root.search_overlap((boundary_table.keys()[index] for index in xrange(bound_begin, bound_end))))\n        return result\n\n    def begin(self):\n        \"\"\"\n        Returns the lower bound of the first interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[0]\n\n    def end(self):\n        \"\"\"\n        Returns the upper bound of the last interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[-1]\n\n    def range(self):\n        \"\"\"\n        Returns a minimum-spanning Interval that encloses all the\n        members of this IntervalTree. If the tree is empty, returns\n        null Interval.\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin(), self.end())\n\n    def span(self):\n        \"\"\"\n        Returns the length of the minimum-spanning Interval that\n        encloses all the members of this IntervalTree. If the tree\n        is empty, return 0.\n        \"\"\"\n        if not self:\n            return 0\n        return self.end() - self.begin()\n\n    def print_structure(self, tostring=False):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Pretty-prints the structure of the tree.\n        If tostring is true, prints nothing and returns a string.\n        :rtype: None or str\n        \"\"\"\n        if self.top_node:\n            return self.top_node.print_structure(tostring=tostring)\n        else:\n            result = '<empty IntervalTree>'\n            if not tostring:\n                print(result)\n            else:\n                return result\n\n    def score(self, full_report=False):\n        \"\"\"\n        Returns a number between 0 and 1, indicating how suboptimal the tree\n        is. The lower, the better. Roughly, this number represents the\n        fraction of flawed Intervals in the tree.\n        :rtype: float\n        \"\"\"\n        if len(self) <= 2:\n            return 0.0\n        n = len(self)\n        m = self.top_node.count_nodes()\n\n        def s_center_score():\n            \"\"\"\n            Returns a normalized score, indicating roughly how many times\n            intervals share s_center with other intervals. Output is full-scale\n            from 0 to 1.\n            :rtype: float\n            \"\"\"\n            raw = n - m\n            maximum = n - 1\n            return raw / float(maximum)\n        report = {'depth': self.top_node.depth_score(n, m), 's_center': s_center_score()}\n        cumulative = max(report.values())\n        report['_cumulative'] = cumulative\n        if full_report:\n            return report\n        return cumulative\n\n    def __setitem__(self, index, value):\n        \"\"\"\n        Adds a new interval to the tree. A shortcut for\n        add(Interval(index.start, index.stop, value)).\n\n        If an identical Interval object with equal range and data\n        already exists, does nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        self.addi(index.start, index.stop, value)\n\n    def __delitem__(self, point):\n        \"\"\"\n        Delete all items overlapping point.\n        \"\"\"\n        self.remove_overlap(point)\n\n    def containsi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for (Interval(begin, end, data) in tree).\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return Interval(begin, end, data) in self\n    iter = __iter__\n\n    def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        ivs = sorted(self)\n        if not ivs:\n            return 'IntervalTree()'\n        else:\n            return 'IntervalTree({0})'.format(ivs)\n    __str__ = __repr__",
    "intervaltree/interval.py": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nInterval class\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom numbers import Number\nfrom collections import namedtuple\n\nclass Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n    __slots__ = ()\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Whether the interval overlaps the given point, range or Interval.\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return begin < self.end and end > self.begin\n        try:\n            return self.overlaps(begin.begin, begin.end)\n        except:\n            return self.contains_point(begin)\n\n    def overlap_size(self, begin, end=None):\n        \"\"\"\n        Return the overlap size between two intervals or a point\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: Return the overlap size, None if not overlap is found\n        :rtype: depends on the given input (e.g., int will be returned for int interval and timedelta for\n        datetime intervals)\n        \"\"\"\n        overlaps = self.overlaps(begin, end)\n        if not overlaps:\n            return 0\n        if end is not None:\n            i0 = max(self.begin, begin)\n            i1 = min(self.end, end)\n            return i1 - i0\n        i0 = max(self.begin, begin.begin)\n        i1 = min(self.end, begin.end)\n        return i1 - i0\n\n    def contains_point(self, p):\n        \"\"\"\n        Whether the Interval contains p.\n        :param p: a point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= p < self.end\n\n    def range_matches(self, other):\n        \"\"\"\n        Whether the begins equal and the ends equal. Compare __eq__().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin == other.begin and self.end == other.end\n\n    def contains_interval(self, other):\n        \"\"\"\n        Whether other is contained in this Interval.\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= other.begin and self.end >= other.end\n\n    def distance_to(self, other):\n        \"\"\"\n        Returns the size of the gap between intervals, or 0 \n        if they touch or overlap.\n        :param other: Interval or point\n        :return: distance\n        :rtype: Number\n        \"\"\"\n        if self.overlaps(other):\n            return 0\n        try:\n            if self.begin < other.begin:\n                return other.begin - self.end\n            else:\n                return self.begin - other.end\n        except:\n            if self.end <= other:\n                return other - self.end\n            else:\n                return self.begin - other\n\n    def is_null(self):\n        \"\"\"\n        Whether this equals the null interval.\n        :return: True if end <= begin else False\n        :rtype: bool\n        \"\"\"\n        return self.begin >= self.end\n\n    def length(self):\n        \"\"\"\n        The distance covered by this Interval.\n        :return: length\n        :type: Number\n        \"\"\"\n        if self.is_null():\n            return 0\n        return self.end - self.begin\n\n    def __cmp__(self, other):\n        \"\"\"\n        Tells whether other sorts before, after or equal to this\n        Interval.\n\n        Sorting is by begins, then by ends, then by data fields.\n\n        If data fields are not both sortable types, data fields are\n        compared alphabetically by type name.\n        :param other: Interval\n        :return: -1, 0, 1\n        :rtype: int\n        \"\"\"\n        s = self[0:2]\n        try:\n            o = other[0:2]\n        except:\n            o = (other,)\n        if s != o:\n            return -1 if s < o else 1\n        try:\n            if self.data == other.data:\n                return 0\n            return -1 if self.data < other.data else 1\n        except TypeError:\n            s = type(self.data).__name__\n            o = type(other.data).__name__\n            if s == o:\n                return 0\n            return -1 if s < o else 1\n\n    def __gt__(self, other):\n        \"\"\"\n        Greater than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) > 0\n\n    def _raise_if_null(self, other):\n        \"\"\"\n        :raises ValueError: if either self or other is a null Interval\n        \"\"\"\n        if self.is_null():\n            raise ValueError('Cannot compare null Intervals!')\n        if hasattr(other, 'is_null') and other.is_null():\n            raise ValueError('Cannot compare null Intervals!')\n\n    def lt(self, other):\n        \"\"\"\n        Strictly less than. Returns True if no part of this Interval\n        extends higher than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'begin', other)\n\n    def le(self, other):\n        \"\"\"\n        Less than or overlaps. Returns True if no part of this Interval\n        extends higher than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'end', other)\n\n    def gt(self, other):\n        \"\"\"\n        Strictly greater than. Returns True if no part of this Interval\n        extends lower than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        if hasattr(other, 'end'):\n            return self.begin >= other.end\n        else:\n            return self.begin > other\n\n    def ge(self, other):\n        \"\"\"\n        Greater than or overlaps. Returns True if no part of this Interval\n        extends lower than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.begin >= getattr(other, 'begin', other)\n\n    def _get_fields(self):\n        \"\"\"\n        Used by str, unicode, repr and __reduce__.\n\n        Returns only the fields necessary to reconstruct the Interval.\n        :return: reconstruction info\n        :rtype: tuple\n        \"\"\"\n        if self.data is not None:\n            return (self.begin, self.end, self.data)\n        else:\n            return (self.begin, self.end)\n\n    def __repr__(self):\n        \"\"\"\n        Executable string representation of this Interval.\n        :return: string representation\n        :rtype: str\n        \"\"\"\n        if isinstance(self.begin, Number):\n            s_begin = str(self.begin)\n            s_end = str(self.end)\n        else:\n            s_begin = repr(self.begin)\n            s_end = repr(self.end)\n        if self.data is None:\n            return 'Interval({0}, {1})'.format(s_begin, s_end)\n        else:\n            return 'Interval({0}, {1}, {2})'.format(s_begin, s_end, repr(self.data))\n    __str__ = __repr__\n\n    def copy(self):\n        \"\"\"\n        Shallow copy.\n        :return: copy of self\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin, self.end, self.data)"
  }
}