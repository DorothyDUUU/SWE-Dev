{
  "dir_path": "/app/fhirclient",
  "package_name": "fhirclient",
  "sample_name": "fhirclient-fhirreference_test",
  "src_dir": "fhirclient/",
  "test_dir": "tests/",
  "test_file": "tests/fhirreference_test.py",
  "test_code": "import io\nimport json\nimport os.path\nimport logging\nimport unittest\nimport fhirclient.models.questionnaire as questionnaire\nimport fhirclient.models.medication as medication\nimport fhirclient.models.resource as resource\nimport fhirclient.models.valueset as valueset\nimport fhirclient.models.patient as patient\nimport fhirclient.models.bundle as bundle\nfrom fhirclient import server\n\n\nlogging.basicConfig(level=logging.CRITICAL)\n\n\nclass TestResourceReference(unittest.TestCase):\n\n    @staticmethod\n    def get_testfile(filename: str) -> str:\n        return os.path.join(os.path.dirname(__file__), 'data', filename)\n\n    def testContainedResourceDetection(self):\n        testfile = self.get_testfile('test_contained_resource.json')\n        with io.open(testfile, 'r', encoding='utf-8') as h:\n            data = json.load(h)\n        q = questionnaire.Questionnaire(data)\n        self.assertIsNotNone(q, \"Must instantiate Questionnaire\")\n        self.assertEqual('Questionnaire', q.resource_type)\n        \n        group = q.item[0].item[3]\n        self.assertEqual('Observation.subject', group.linkId)\n        question = group.item[0]\n        self.assertEqual('Observation.subject._type', question.linkId)\n        self.assertIsNotNone(question.answerOption)\n        with self.assertRaises(Exception):\n            question.answerOption[0].valueReference.resolved()\n        reference = question.answerOption[0].valueReference\n        # 1st resolve, extracting from contained resources\n        contained = reference.resolved(medication.Medication)\n        self.assertIsNone(contained, \"Must not resolve on resource type mismatch\")\n        contained = reference.resolved(valueset.ValueSet)\n        self.assertIsNotNone(contained, \"Must resolve contained ValueSet\")\n        self.assertEqual('ValueSet', contained.resource_type)\n        self.assertEqual('Type options for Observation.subject', contained.name)\n        \n        # 2nd resolve, should pull from cache\n        contained = reference.resolved(medication.Medication)\n        self.assertIsNone(contained, \"Must not resolve on resource type mismatch\")\n        contained = reference.resolved(resource.Resource)\n        self.assertIsNotNone(contained, \"Must resolve contained ValueSet even if requesting `Resource`\")\n        contained = reference.resolved(valueset.ValueSet)\n        self.assertIsNotNone(contained, \"Must resolve contained ValueSet\")\n        self.assertEqual('ValueSet', contained.resource_type)\n\n    def testRelativeReference(self):\n        testfile = self.get_testfile('test_relative_reference.json')\n        with io.open(testfile, 'r', encoding='utf-8') as h:\n            data = json.load(h)\n        q = questionnaire.Questionnaire(data)\n        self.assertIsNotNone(q, \"Must instantiate Questionnaire\")\n        self.assertEqual('Questionnaire', q.resource_type)\n        q._server = MockServer()\n        \n        group = q.item[0].item[0]\n        self.assertEqual('Observation.subject', group.linkId)\n        question = group.item[0]\n        self.assertEqual('Observation.subject._type', question.linkId)\n        self.assertIsNotNone(question.answerOption)\n        with self.assertRaises(Exception):\n            question.answerOption[0].valueReference.resolved()\n        reference = question.answerOption[0].valueReference\n        \n        # resolve relative resource\n        relative = reference.resolved(valueset.ValueSet)\n        self.assertIsNotNone(relative, \"Must resolve relative ValueSet\")\n        self.assertEqual('ValueSet', relative.resource_type)\n        self.assertEqual('Type options for Observation.subject', relative.name)\n        \n        # 2nd resolve, should pull from cache\n        relative = reference.resolved(medication.Medication)\n        self.assertIsNone(relative, \"Must not resolve on resource type mismatch\")\n        relative = reference.resolved(resource.Resource)\n        self.assertIsNotNone(relative, \"Must resolve relative ValueSet even if requesting `Resource`\")\n\n    def testBundleReferences(self):\n        testfile = self.get_testfile('test_bundle.json')\n        with io.open(testfile, 'r', encoding='utf-8') as h:\n            data = json.load(h)\n        b = bundle.Bundle(data)\n        self.assertIsNotNone(b, \"Must instantiate Bundle\")\n        self.assertEqual('Bundle', b.resource_type)\n        #b._server = MockServer()\n        \n        # get resources\n        pat23 = b.entry[0].resource\n        self.assertEqual('Patient', pat23.resource_type)\n        self.assertEqual('Darth', pat23.name[0].given[0])\n        patURN = b.entry[1].resource\n        self.assertEqual('Patient', patURN.resource_type)\n        self.assertEqual('Ben', patURN.name[0].given[0])\n        obs123 = b.entry[2].resource\n        self.assertEqual('Observation', obs123.resource_type)\n        obs56 = b.entry[3].resource\n        self.assertEqual('Observation', obs56.resource_type)\n        obs34 = b.entry[4].resource\n        self.assertEqual('Observation', obs34.resource_type)\n        \n        # test resolving w/o server (won't work)\n        res = obs123.subject.resolved(patient.Patient)\n        self.assertIsNone(res)\n        \n        # test resolving with server\n        b._server = MockServer()\n        res = obs123.subject.resolved(patient.Patient)\n        self.assertEqual(res, pat23)\n        res = obs123.subject.resolved(medication.Medication)\n        self.assertIsNone(res, \"Must not resolve on type mismatch\")\n        res = obs56.subject.resolved(patient.Patient)\n        self.assertEqual(res, patURN)\n        res = obs34.subject.resolved(patient.Patient)\n        self.assertIsNone(res, \"Must not resolve Patient on same server but different endpoint\")\n\n\nclass MockServer(server.FHIRServer):\n    \"\"\" Reads local files.\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__(None, base_uri='https://fhir.smarthealthit.org')\n    \n    def request_json(self, path, nosign=False):\n        assert path\n        datadir = os.path.join(os.path.dirname(__file__), 'data')\n        parts = os.path.split(path)\n        filename = os.path.join(datadir, '_'.join(parts) + '.json')\n        with io.open(filename, 'r', encoding='utf-8') as handle:\n            return json.load(handle)\n",
  "GT_file_code": {
    "fhirclient/models/fhirabstractbase.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  Base class for all FHIR elements.\n\nimport sys\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n\nclass FHIRValidationError(Exception):\n    \"\"\" Exception raised when one or more errors occurred during model\n    validation.\n    \"\"\"\n    \n    def __init__(self, errors, path=None):\n        \"\"\" Initializer.\n        \n        :param errors: List of Exception instances. Also accepts a string,\n            which is converted to a TypeError.\n        :param str path: The property path on the object where errors occurred\n        \"\"\"\n        if not isinstance(errors, list):\n            errors = [TypeError(errors)]\n        msgs = \"\\n  \".join([str(e).replace(\"\\n\", \"\\n  \") for e in errors])\n        message = \"{}:\\n  {}\".format(path or \"{root}\", msgs)\n        \n        super(FHIRValidationError, self).__init__(message)\n        \n        self.errors = errors\n        \"\"\" A list of validation errors encountered. Typically contains\n        TypeError, KeyError, possibly AttributeError and others. \"\"\"\n        \n        self.path = path\n        \"\"\" The path on the object where the errors occurred. \"\"\"\n    \n    def prefixed(self, path_prefix):\n        \"\"\" Creates a new instance of the receiver, with the given path prefix\n        applied. \"\"\"\n        path = '{}.{}'.format(path_prefix, self.path) if self.path is not None else path_prefix\n        return self.__class__(self.errors, path)\n\n\nclass FHIRAbstractBase(object):\n    \"\"\" Abstract base class for all FHIR elements.\n    \"\"\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initializer. If strict is true, raises on errors, otherwise uses\n        `logger.warning()`.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self._resolved = None\n        \"\"\" Dictionary of resolved resources. \"\"\"\n        \n        self._owner = None\n        \"\"\" Points to the parent resource, if there is one. \"\"\"\n        \n        if jsondict is not None:\n            if strict:\n                self.update_with_json(jsondict)\n            else:\n                try:\n                    self.update_with_json(jsondict)\n                except FHIRValidationError as e:\n                    for err in e.errors:\n                        logger.warning(err)\n    \n    \n    # MARK: Instantiation from JSON\n    \n    @classmethod\n    def with_json(cls, jsonobj):\n        \"\"\" Initialize an element from a JSON dictionary or array.\n        \n        If the JSON dictionary has a \"resourceType\" entry and the specified\n        resource type is not the receiving classes type, uses\n        `FHIRElementFactory` to return a correct class instance.\n        \n        :raises: TypeError on anything but dict or list of dicts\n        :raises: FHIRValidationError if instantiation fails\n        :param jsonobj: A dict or list of dicts to instantiate from\n        :returns: An instance or a list of instances created from JSON data\n        \"\"\"\n        if isinstance(jsonobj, dict):\n            return cls._with_json_dict(jsonobj)\n        \n        if isinstance(jsonobj, list):\n            arr = []\n            for jsondict in jsonobj:\n                try:\n                    arr.append(cls._with_json_dict(jsondict))\n                except FHIRValidationError as e:\n                    raise e.prefixed(str(len(arr)))\n            return arr\n        \n        raise TypeError(\"`with_json()` on {} only takes dict or list of dict, but you provided {}\"\n            .format(cls, type(jsonobj)))\n    \n    @classmethod\n    def _with_json_dict(cls, jsondict):\n        \"\"\" Internal method to instantiate from JSON dictionary.\n        \n        :raises: TypeError on anything but dict\n        :raises: FHIRValidationError if instantiation fails\n        :returns: An instance created from dictionary data\n        \"\"\"\n        if not isinstance(jsondict, dict):\n            raise TypeError(\"Can only use `_with_json_dict()` on {} with a dictionary, got {}\"\n                .format(type(self), type(jsondict)))\n        return cls(jsondict)\n    \n    @classmethod\n    def with_json_and_owner(cls, jsonobj, owner):\n        \"\"\" Instantiates by forwarding to `with_json()`, then remembers the\n        \"owner\" of the instantiated elements. The \"owner\" is the resource\n        containing the receiver and is used to resolve contained resources.\n        \n        :raises: TypeError on anything but dict or list of dicts\n        :raises: FHIRValidationError if instantiation fails\n        :param dict jsonobj: Decoded JSON dictionary (or list thereof)\n        :param FHIRElement owner: The owning parent\n        :returns: An instance or a list of instances created from JSON data\n        \"\"\"\n        instance = cls.with_json(jsonobj)\n        if isinstance(instance, list):\n            for inst in instance:\n                inst._owner = owner\n        else:\n            instance._owner = owner\n        \n        return instance\n    \n    \n    # MARK: (De)Serialization\n    \n    def elementProperties(self):\n        \"\"\" Returns a list of tuples, one tuple for each property that should\n        be serialized, as: (\"name\", \"json_name\", type, is_list, \"of_many\", not_optional)\n        \"\"\"\n        return []\n    \n    def update_with_json(self, jsondict):\n        \"\"\" Update the receiver with data in a JSON dictionary.\n        \n        :raises: FHIRValidationError on validation errors\n        :param dict jsondict: The JSON dictionary to use to update the receiver\n        :returns: None on success, a list of errors if there were errors\n        \"\"\"\n        if jsondict is None:\n            return\n        \n        if not isinstance(jsondict, dict):\n            raise FHIRValidationError(\"Non-dict type {} fed to `update_with_json` on {}\"\n                .format(type(jsondict), type(self)))\n        \n        # loop all registered properties and instantiate\n        errs = []\n        valid = set(['resourceType'])   # used to also contain `fhir_comments` until STU-3\n        found = set()\n        nonoptionals = set()\n        for name, jsname, typ, is_list, of_many, not_optional in self.elementProperties():\n            valid.add(jsname)\n            if of_many is not None:\n                valid.add(of_many)\n            \n            # bring the value in shape\n            err = None\n            value = jsondict.get(jsname)\n            if value is not None and hasattr(typ, 'with_json_and_owner'):\n                try:\n                    value = typ.with_json_and_owner(value, self)\n                except Exception as e:\n                    value = None\n                    err = e\n            \n            # got a value, test if it is of required type and assign\n            if value is not None:\n                testval = value\n                if is_list:\n                    if not isinstance(value, list):\n                        err = TypeError(\"Wrong type {} for list property \\\"{}\\\" on {}, expecting a list of {}\"\n                            .format(type(value), name, type(self), typ))\n                        testval = None\n                    else:\n                        testval = value[0] if value and len(value) > 0 else None\n                \n                if testval is not None and not self._matches_type(testval, typ):\n                    err = TypeError(\"Wrong type {} for property \\\"{}\\\" on {}, expecting {}\"\n                        .format(type(testval), name, type(self), typ))\n                else:\n                    setattr(self, name, value)\n                \n                found.add(jsname)\n                if of_many is not None:\n                    found.add(of_many)\n            \n            # not optional and missing, report (we clean `of_many` later on)\n            elif not_optional:\n                nonoptionals.add(of_many or jsname)\n            \n            # TODO: look at `_name` only if this is a primitive!\n            _jsname = '_'+jsname\n            _value = jsondict.get(_jsname)\n            if _value is not None:\n                valid.add(_jsname)\n                found.add(_jsname)\n            \n            # report errors\n            if err is not None:\n                errs.append(err.prefixed(name) if isinstance(err, FHIRValidationError) else FHIRValidationError([err], name))\n        \n        # were there missing non-optional entries?\n        if len(nonoptionals) > 0:\n            for miss in nonoptionals - found:\n                errs.append(KeyError(\"Non-optional property \\\"{}\\\" on {} is missing\"\n                    .format(miss, self)))\n        \n        # were there superfluous dictionary keys?\n        if len(set(jsondict.keys()) - valid) > 0:\n            for supflu in set(jsondict.keys()) - valid:\n                errs.append(AttributeError(\"Superfluous entry \\\"{}\\\" in data for {}\"\n                    .format(supflu, self)))\n        \n        if len(errs) > 0:\n            raise FHIRValidationError(errs)\n    \n    def as_json(self):\n        \"\"\" Serializes to JSON by inspecting `elementProperties()` and creating\n        a JSON dictionary of all registered properties. Checks:\n        \n        - whether required properties are not None (and lists not empty)\n        - whether not-None properties are of the correct type\n        \n        :raises: FHIRValidationError if properties have the wrong type or if\n            required properties are empty\n        :returns: A validated dict object that can be JSON serialized\n        \"\"\"\n        js = {}\n        errs = []\n        \n        # JSONify all registered properties\n        found = set()\n        nonoptionals = set()\n        for name, jsname, typ, is_list, of_many, not_optional in self.elementProperties():\n            if not_optional:\n                nonoptionals.add(of_many or jsname)\n            \n            err = None\n            value = getattr(self, name)\n            if value is None:\n                continue\n            \n            if is_list:\n                if not isinstance(value, list):\n                   err = TypeError(\"Expecting property \\\"{}\\\" on {} to be list, but is {}\"\n                       .format(name, type(self), type(value)))\n                elif len(value) > 0:\n                    if not self._matches_type(value[0], typ):\n                        err = TypeError(\"Expecting property \\\"{}\\\" on {} to be {}, but is {}\"\n                            .format(name, type(self), typ, type(value[0])))\n                    else:\n                        lst = []\n                        for v in value:\n                            try:\n                                lst.append(v.as_json() if hasattr(v, 'as_json') else v)\n                            except FHIRValidationError as e:\n                                err = e.prefixed(str(len(lst))).prefixed(name)\n                        found.add(of_many or jsname)\n                        js[jsname] = lst\n            else:\n                if not self._matches_type(value, typ):\n                    err = TypeError(\"Expecting property \\\"{}\\\" on {} to be {}, but is {}\"\n                        .format(name, type(self), typ, type(value)))\n                else:\n                    try:\n                        found.add(of_many or jsname)\n                        js[jsname] = value.as_json() if hasattr(value, 'as_json') else value\n                    except FHIRValidationError as e:\n                        err = e.prefixed(name)\n            \n            if err is not None:\n                errs.append(err if isinstance(err, FHIRValidationError) else FHIRValidationError([err], name))\n        \n        # any missing non-optionals?\n        if len(nonoptionals - found) > 0:\n            for nonop in nonoptionals - found:\n                errs.append(KeyError(\"Property \\\"{}\\\" on {} is not optional, you must provide a value for it\"\n                    .format(nonop, self)))\n        \n        if len(errs) > 0:\n            raise FHIRValidationError(errs)\n        return js\n    \n    def _matches_type(self, value, typ):\n        if value is None:\n            return True\n        if isinstance(value, typ):\n            return True\n        if int == typ or float == typ:\n            return (isinstance(value, int) or isinstance(value, float))\n        if (sys.version_info < (3, 0)) and (str == typ or unicode == typ):\n            return (isinstance(value, str) or isinstance(value, unicode))\n        return False\n    \n    \n    # MARK: Handling References\n    \n    def owningResource(self):\n        \"\"\" Walks the owner hierarchy and returns the next parent that is a\n        `DomainResource` instance.\n        \"\"\"\n        owner = self._owner\n        while owner is not None and not hasattr(owner, \"contained\"):\n            owner = owner._owner\n        return owner\n    \n    def owningBundle(self):\n        \"\"\" Walks the owner hierarchy and returns the next parent that is a\n        `Bundle` instance.\n        \"\"\"\n        owner = self._owner\n        while owner is not None and not 'Bundle' == owner.resource_type:\n            owner = owner._owner\n        return owner\n    \n    def resolvedReference(self, refid):\n        \"\"\" Returns the resolved reference with the given id, if it has been\n        resolved already. If it hasn't, forwards the call to its owner if it\n        has one.\n        \n        You should probably use `resolve()` on the `FHIRReference` itself.\n        \n        :param refid: The id of the resource to resolve\n        :returns: An instance of `Resource`, if it was found\n        \"\"\"\n        if self._resolved and refid in self._resolved:\n            return self._resolved[refid]\n        return self._owner.resolvedReference(refid) if self._owner is not None else None\n    \n    def didResolveReference(self, refid, resolved):\n        \"\"\" Called by `FHIRResource` when it resolves a reference. Stores the\n        resolved reference into the `_resolved` dictionary.\n        \n        :param refid: The id of the resource that was resolved\n        :param refid: The resolved resource, ready to be cached\n        \"\"\"\n        if self._resolved is not None:\n            self._resolved[refid] = resolved\n        else:\n            self._resolved = {refid: resolved}\n\n",
    "fhirclient/models/bundle.py": "# Generated from FHIR 4.0.1-9346c8cc45 (http://hl7.org/fhir/StructureDefinition/Bundle).\n# 2024, SMART Health IT.\n\n\nfrom . import resource\n\nclass Bundle(resource.Resource):\n    \"\"\" Contains a collection of resources.\n    \n    A container for a collection of resources.\n    \"\"\"\n    \n    resource_type = \"Bundle\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.entry = None\n        \"\"\" Entry in the bundle - will have a resource or information.\n        List of `BundleEntry` items (represented as `dict` in JSON). \"\"\"\n        \n        self.identifier = None\n        \"\"\" Persistent identifier for the bundle.\n        Type `Identifier` (represented as `dict` in JSON). \"\"\"\n        \n        self.link = None\n        \"\"\" Links related to this Bundle.\n        List of `BundleLink` items (represented as `dict` in JSON). \"\"\"\n        \n        self.signature = None\n        \"\"\" Digital Signature.\n        Type `Signature` (represented as `dict` in JSON). \"\"\"\n        \n        self.timestamp = None\n        \"\"\" When the bundle was assembled.\n        Type `FHIRInstant` (represented as `str` in JSON). \"\"\"\n        \n        self.total = None\n        \"\"\" If search, the total number of matches.\n        Type `int`. \"\"\"\n        \n        self.type = None\n        \"\"\" document | message | transaction | transaction-response | batch |\n        batch-response | history | searchset | collection.\n        Type `str`. \"\"\"\n        \n        super(Bundle, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(Bundle, self).elementProperties()\n        js.extend([\n            (\"entry\", \"entry\", BundleEntry, True, None, False),\n            (\"identifier\", \"identifier\", identifier.Identifier, False, None, False),\n            (\"link\", \"link\", BundleLink, True, None, False),\n            (\"signature\", \"signature\", signature.Signature, False, None, False),\n            (\"timestamp\", \"timestamp\", fhirinstant.FHIRInstant, False, None, False),\n            (\"total\", \"total\", int, False, None, False),\n            (\"type\", \"type\", str, False, None, True),\n        ])\n        return js\n\n\nfrom . import backboneelement\n\nclass BundleEntry(backboneelement.BackboneElement):\n    \"\"\" Entry in the bundle - will have a resource or information.\n    \n    An entry in a bundle resource - will either contain a resource or\n    information about a resource (transactions and history only).\n    \"\"\"\n    \n    resource_type = \"BundleEntry\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.fullUrl = None\n        \"\"\" URI for resource (Absolute URL server address or URI for UUID/OID).\n        Type `str`. \"\"\"\n        \n        self.link = None\n        \"\"\" Links related to this entry.\n        List of `BundleLink` items (represented as `dict` in JSON). \"\"\"\n        \n        self.request = None\n        \"\"\" Additional execution information (transaction/batch/history).\n        Type `BundleEntryRequest` (represented as `dict` in JSON). \"\"\"\n        \n        self.resource = None\n        \"\"\" A resource in the bundle.\n        Type `Resource` (represented as `dict` in JSON). \"\"\"\n        \n        self.response = None\n        \"\"\" Results of execution (transaction/batch/history).\n        Type `BundleEntryResponse` (represented as `dict` in JSON). \"\"\"\n        \n        self.search = None\n        \"\"\" Search related information.\n        Type `BundleEntrySearch` (represented as `dict` in JSON). \"\"\"\n        \n        super(BundleEntry, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(BundleEntry, self).elementProperties()\n        js.extend([\n            (\"fullUrl\", \"fullUrl\", str, False, None, False),\n            (\"link\", \"link\", BundleLink, True, None, False),\n            (\"request\", \"request\", BundleEntryRequest, False, None, False),\n            (\"resource\", \"resource\", resource.Resource, False, None, False),\n            (\"response\", \"response\", BundleEntryResponse, False, None, False),\n            (\"search\", \"search\", BundleEntrySearch, False, None, False),\n        ])\n        return js\n\n\nclass BundleEntryRequest(backboneelement.BackboneElement):\n    \"\"\" Additional execution information (transaction/batch/history).\n    \n    Additional information about how this entry should be processed as part of\n    a transaction or batch.  For history, it shows how the entry was processed\n    to create the version contained in the entry.\n    \"\"\"\n    \n    resource_type = \"BundleEntryRequest\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.ifMatch = None\n        \"\"\" For managing update contention.\n        Type `str`. \"\"\"\n        \n        self.ifModifiedSince = None\n        \"\"\" For managing cache currency.\n        Type `FHIRInstant` (represented as `str` in JSON). \"\"\"\n        \n        self.ifNoneExist = None\n        \"\"\" For conditional creates.\n        Type `str`. \"\"\"\n        \n        self.ifNoneMatch = None\n        \"\"\" For managing cache currency.\n        Type `str`. \"\"\"\n        \n        self.method = None\n        \"\"\" GET | HEAD | POST | PUT | DELETE | PATCH.\n        Type `str`. \"\"\"\n        \n        self.url = None\n        \"\"\" URL for HTTP equivalent of this entry.\n        Type `str`. \"\"\"\n        \n        super(BundleEntryRequest, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(BundleEntryRequest, self).elementProperties()\n        js.extend([\n            (\"ifMatch\", \"ifMatch\", str, False, None, False),\n            (\"ifModifiedSince\", \"ifModifiedSince\", fhirinstant.FHIRInstant, False, None, False),\n            (\"ifNoneExist\", \"ifNoneExist\", str, False, None, False),\n            (\"ifNoneMatch\", \"ifNoneMatch\", str, False, None, False),\n            (\"method\", \"method\", str, False, None, True),\n            (\"url\", \"url\", str, False, None, True),\n        ])\n        return js\n\n\nclass BundleEntryResponse(backboneelement.BackboneElement):\n    \"\"\" Results of execution (transaction/batch/history).\n    \n    Indicates the results of processing the corresponding 'request' entry in\n    the batch or transaction being responded to or what the results of an\n    operation where when returning history.\n    \"\"\"\n    \n    resource_type = \"BundleEntryResponse\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.etag = None\n        \"\"\" The Etag for the resource (if relevant).\n        Type `str`. \"\"\"\n        \n        self.lastModified = None\n        \"\"\" Server's date time modified.\n        Type `FHIRInstant` (represented as `str` in JSON). \"\"\"\n        \n        self.location = None\n        \"\"\" The location (if the operation returns a location).\n        Type `str`. \"\"\"\n        \n        self.outcome = None\n        \"\"\" OperationOutcome with hints and warnings (for batch/transaction).\n        Type `Resource` (represented as `dict` in JSON). \"\"\"\n        \n        self.status = None\n        \"\"\" Status response code (text optional).\n        Type `str`. \"\"\"\n        \n        super(BundleEntryResponse, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(BundleEntryResponse, self).elementProperties()\n        js.extend([\n            (\"etag\", \"etag\", str, False, None, False),\n            (\"lastModified\", \"lastModified\", fhirinstant.FHIRInstant, False, None, False),\n            (\"location\", \"location\", str, False, None, False),\n            (\"outcome\", \"outcome\", resource.Resource, False, None, False),\n            (\"status\", \"status\", str, False, None, True),\n        ])\n        return js\n\n\nclass BundleEntrySearch(backboneelement.BackboneElement):\n    \"\"\" Search related information.\n    \n    Information about the search process that lead to the creation of this\n    entry.\n    \"\"\"\n    \n    resource_type = \"BundleEntrySearch\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.mode = None\n        \"\"\" match | include | outcome - why this is in the result set.\n        Type `str`. \"\"\"\n        \n        self.score = None\n        \"\"\" Search ranking (between 0 and 1).\n        Type `float`. \"\"\"\n        \n        super(BundleEntrySearch, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(BundleEntrySearch, self).elementProperties()\n        js.extend([\n            (\"mode\", \"mode\", str, False, None, False),\n            (\"score\", \"score\", float, False, None, False),\n        ])\n        return js\n\n\nclass BundleLink(backboneelement.BackboneElement):\n    \"\"\" Links related to this Bundle.\n    \n    A series of links that provide context to this bundle.\n    \"\"\"\n    \n    resource_type = \"BundleLink\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.relation = None\n        \"\"\" See http://www.iana.org/assignments/link-relations/link-\n        relations.xhtml#link-relations-1.\n        Type `str`. \"\"\"\n        \n        self.url = None\n        \"\"\" Reference details for the link.\n        Type `str`. \"\"\"\n        \n        super(BundleLink, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(BundleLink, self).elementProperties()\n        js.extend([\n            (\"relation\", \"relation\", str, False, None, True),\n            (\"url\", \"url\", str, False, None, True),\n        ])\n        return js\n\n\nfrom . import fhirinstant\nfrom . import identifier\nfrom . import signature\n",
    "fhirclient/models/questionnaire.py": "# Generated from FHIR 4.0.1-9346c8cc45 (http://hl7.org/fhir/StructureDefinition/Questionnaire).\n# 2024, SMART Health IT.\n\n\nfrom . import domainresource\n\nclass Questionnaire(domainresource.DomainResource):\n    \"\"\" A structured set of questions.\n    \n    A structured set of questions intended to guide the collection of answers\n    from end-users. Questionnaires provide detailed control over order,\n    presentation, phraseology and grouping to allow coherent, consistent data\n    collection.\n    \"\"\"\n    \n    resource_type = \"Questionnaire\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.approvalDate = None\n        \"\"\" When the questionnaire was approved by publisher.\n        Type `FHIRDate` (represented as `str` in JSON). \"\"\"\n        \n        self.code = None\n        \"\"\" Concept that represents the overall questionnaire.\n        List of `Coding` items (represented as `dict` in JSON). \"\"\"\n        \n        self.contact = None\n        \"\"\" Contact details for the publisher.\n        List of `ContactDetail` items (represented as `dict` in JSON). \"\"\"\n        \n        self.copyright = None\n        \"\"\" Use and/or publishing restrictions.\n        Type `str`. \"\"\"\n        \n        self.date = None\n        \"\"\" Date last changed.\n        Type `FHIRDateTime` (represented as `str` in JSON). \"\"\"\n        \n        self.derivedFrom = None\n        \"\"\" Instantiates protocol or definition.\n        List of `str` items. \"\"\"\n        \n        self.description = None\n        \"\"\" Natural language description of the questionnaire.\n        Type `str`. \"\"\"\n        \n        self.effectivePeriod = None\n        \"\"\" When the questionnaire is expected to be used.\n        Type `Period` (represented as `dict` in JSON). \"\"\"\n        \n        self.experimental = None\n        \"\"\" For testing purposes, not real usage.\n        Type `bool`. \"\"\"\n        \n        self.identifier = None\n        \"\"\" Additional identifier for the questionnaire.\n        List of `Identifier` items (represented as `dict` in JSON). \"\"\"\n        \n        self.item = None\n        \"\"\" Questions and sections within the Questionnaire.\n        List of `QuestionnaireItem` items (represented as `dict` in JSON). \"\"\"\n        \n        self.jurisdiction = None\n        \"\"\" Intended jurisdiction for questionnaire (if applicable).\n        List of `CodeableConcept` items (represented as `dict` in JSON). \"\"\"\n        \n        self.lastReviewDate = None\n        \"\"\" When the questionnaire was last reviewed.\n        Type `FHIRDate` (represented as `str` in JSON). \"\"\"\n        \n        self.name = None\n        \"\"\" Name for this questionnaire (computer friendly).\n        Type `str`. \"\"\"\n        \n        self.publisher = None\n        \"\"\" Name of the publisher (organization or individual).\n        Type `str`. \"\"\"\n        \n        self.purpose = None\n        \"\"\" Why this questionnaire is defined.\n        Type `str`. \"\"\"\n        \n        self.status = None\n        \"\"\" draft | active | retired | unknown.\n        Type `str`. \"\"\"\n        \n        self.subjectType = None\n        \"\"\" Resource that can be subject of QuestionnaireResponse.\n        List of `str` items. \"\"\"\n        \n        self.title = None\n        \"\"\" Name for this questionnaire (human friendly).\n        Type `str`. \"\"\"\n        \n        self.url = None\n        \"\"\" Canonical identifier for this questionnaire, represented as a URI\n        (globally unique).\n        Type `str`. \"\"\"\n        \n        self.useContext = None\n        \"\"\" The context that the content is intended to support.\n        List of `UsageContext` items (represented as `dict` in JSON). \"\"\"\n        \n        self.version = None\n        \"\"\" Business version of the questionnaire.\n        Type `str`. \"\"\"\n        \n        super(Questionnaire, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(Questionnaire, self).elementProperties()\n        js.extend([\n            (\"approvalDate\", \"approvalDate\", fhirdate.FHIRDate, False, None, False),\n            (\"code\", \"code\", coding.Coding, True, None, False),\n            (\"contact\", \"contact\", contactdetail.ContactDetail, True, None, False),\n            (\"copyright\", \"copyright\", str, False, None, False),\n            (\"date\", \"date\", fhirdatetime.FHIRDateTime, False, None, False),\n            (\"derivedFrom\", \"derivedFrom\", str, True, None, False),\n            (\"description\", \"description\", str, False, None, False),\n            (\"effectivePeriod\", \"effectivePeriod\", period.Period, False, None, False),\n            (\"experimental\", \"experimental\", bool, False, None, False),\n            (\"identifier\", \"identifier\", identifier.Identifier, True, None, False),\n            (\"item\", \"item\", QuestionnaireItem, True, None, False),\n            (\"jurisdiction\", \"jurisdiction\", codeableconcept.CodeableConcept, True, None, False),\n            (\"lastReviewDate\", \"lastReviewDate\", fhirdate.FHIRDate, False, None, False),\n            (\"name\", \"name\", str, False, None, False),\n            (\"publisher\", \"publisher\", str, False, None, False),\n            (\"purpose\", \"purpose\", str, False, None, False),\n            (\"status\", \"status\", str, False, None, True),\n            (\"subjectType\", \"subjectType\", str, True, None, False),\n            (\"title\", \"title\", str, False, None, False),\n            (\"url\", \"url\", str, False, None, False),\n            (\"useContext\", \"useContext\", usagecontext.UsageContext, True, None, False),\n            (\"version\", \"version\", str, False, None, False),\n        ])\n        return js\n\n\nfrom . import backboneelement\n\nclass QuestionnaireItem(backboneelement.BackboneElement):\n    \"\"\" Questions and sections within the Questionnaire.\n    \n    A particular question, question grouping or display text that is part of\n    the questionnaire.\n    \"\"\"\n    \n    resource_type = \"QuestionnaireItem\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.answerOption = None\n        \"\"\" Permitted answer.\n        List of `QuestionnaireItemAnswerOption` items (represented as `dict` in JSON). \"\"\"\n        \n        self.answerValueSet = None\n        \"\"\" Valueset containing permitted answers.\n        Type `str`. \"\"\"\n        \n        self.code = None\n        \"\"\" Corresponding concept for this item in a terminology.\n        List of `Coding` items (represented as `dict` in JSON). \"\"\"\n        \n        self.definition = None\n        \"\"\" ElementDefinition - details for the item.\n        Type `str`. \"\"\"\n        \n        self.enableBehavior = None\n        \"\"\" all | any.\n        Type `str`. \"\"\"\n        \n        self.enableWhen = None\n        \"\"\" Only allow data when.\n        List of `QuestionnaireItemEnableWhen` items (represented as `dict` in JSON). \"\"\"\n        \n        self.initial = None\n        \"\"\" Initial value(s) when item is first rendered.\n        List of `QuestionnaireItemInitial` items (represented as `dict` in JSON). \"\"\"\n        \n        self.item = None\n        \"\"\" Nested questionnaire items.\n        List of `QuestionnaireItem` items (represented as `dict` in JSON). \"\"\"\n        \n        self.linkId = None\n        \"\"\" Unique id for item in questionnaire.\n        Type `str`. \"\"\"\n        \n        self.maxLength = None\n        \"\"\" No more than this many characters.\n        Type `int`. \"\"\"\n        \n        self.prefix = None\n        \"\"\" E.g. \"1(a)\", \"2.5.3\".\n        Type `str`. \"\"\"\n        \n        self.readOnly = None\n        \"\"\" Don't allow human editing.\n        Type `bool`. \"\"\"\n        \n        self.repeats = None\n        \"\"\" Whether the item may repeat.\n        Type `bool`. \"\"\"\n        \n        self.required = None\n        \"\"\" Whether the item must be included in data results.\n        Type `bool`. \"\"\"\n        \n        self.text = None\n        \"\"\" Primary text for the item.\n        Type `str`. \"\"\"\n        \n        self.type = None\n        \"\"\" group | display | boolean | decimal | integer | date | dateTime +.\n        Type `str`. \"\"\"\n        \n        super(QuestionnaireItem, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(QuestionnaireItem, self).elementProperties()\n        js.extend([\n            (\"answerOption\", \"answerOption\", QuestionnaireItemAnswerOption, True, None, False),\n            (\"answerValueSet\", \"answerValueSet\", str, False, None, False),\n            (\"code\", \"code\", coding.Coding, True, None, False),\n            (\"definition\", \"definition\", str, False, None, False),\n            (\"enableBehavior\", \"enableBehavior\", str, False, None, False),\n            (\"enableWhen\", \"enableWhen\", QuestionnaireItemEnableWhen, True, None, False),\n            (\"initial\", \"initial\", QuestionnaireItemInitial, True, None, False),\n            (\"item\", \"item\", QuestionnaireItem, True, None, False),\n            (\"linkId\", \"linkId\", str, False, None, True),\n            (\"maxLength\", \"maxLength\", int, False, None, False),\n            (\"prefix\", \"prefix\", str, False, None, False),\n            (\"readOnly\", \"readOnly\", bool, False, None, False),\n            (\"repeats\", \"repeats\", bool, False, None, False),\n            (\"required\", \"required\", bool, False, None, False),\n            (\"text\", \"text\", str, False, None, False),\n            (\"type\", \"type\", str, False, None, True),\n        ])\n        return js\n\n\nclass QuestionnaireItemAnswerOption(backboneelement.BackboneElement):\n    \"\"\" Permitted answer.\n    \n    One of the permitted answers for a \"choice\" or \"open-choice\" question.\n    \"\"\"\n    \n    resource_type = \"QuestionnaireItemAnswerOption\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.initialSelected = None\n        \"\"\" Whether option is selected by default.\n        Type `bool`. \"\"\"\n        \n        self.valueCoding = None\n        \"\"\" Answer value.\n        Type `Coding` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueDate = None\n        \"\"\" Answer value.\n        Type `FHIRDate` (represented as `str` in JSON). \"\"\"\n        \n        self.valueInteger = None\n        \"\"\" Answer value.\n        Type `int`. \"\"\"\n        \n        self.valueReference = None\n        \"\"\" Answer value.\n        Type `FHIRReference` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueString = None\n        \"\"\" Answer value.\n        Type `str`. \"\"\"\n        \n        self.valueTime = None\n        \"\"\" Answer value.\n        Type `FHIRTime` (represented as `str` in JSON). \"\"\"\n        \n        super(QuestionnaireItemAnswerOption, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(QuestionnaireItemAnswerOption, self).elementProperties()\n        js.extend([\n            (\"initialSelected\", \"initialSelected\", bool, False, None, False),\n            (\"valueCoding\", \"valueCoding\", coding.Coding, False, \"value\", True),\n            (\"valueDate\", \"valueDate\", fhirdate.FHIRDate, False, \"value\", True),\n            (\"valueInteger\", \"valueInteger\", int, False, \"value\", True),\n            (\"valueReference\", \"valueReference\", fhirreference.FHIRReference, False, \"value\", True),\n            (\"valueString\", \"valueString\", str, False, \"value\", True),\n            (\"valueTime\", \"valueTime\", fhirtime.FHIRTime, False, \"value\", True),\n        ])\n        return js\n\n\nclass QuestionnaireItemEnableWhen(backboneelement.BackboneElement):\n    \"\"\" Only allow data when.\n    \n    A constraint indicating that this item should only be enabled\n    (displayed/allow answers to be captured) when the specified condition is\n    true.\n    \"\"\"\n    \n    resource_type = \"QuestionnaireItemEnableWhen\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.answerBoolean = None\n        \"\"\" Value for question comparison based on operator.\n        Type `bool`. \"\"\"\n        \n        self.answerCoding = None\n        \"\"\" Value for question comparison based on operator.\n        Type `Coding` (represented as `dict` in JSON). \"\"\"\n        \n        self.answerDate = None\n        \"\"\" Value for question comparison based on operator.\n        Type `FHIRDate` (represented as `str` in JSON). \"\"\"\n        \n        self.answerDateTime = None\n        \"\"\" Value for question comparison based on operator.\n        Type `FHIRDateTime` (represented as `str` in JSON). \"\"\"\n        \n        self.answerDecimal = None\n        \"\"\" Value for question comparison based on operator.\n        Type `float`. \"\"\"\n        \n        self.answerInteger = None\n        \"\"\" Value for question comparison based on operator.\n        Type `int`. \"\"\"\n        \n        self.answerQuantity = None\n        \"\"\" Value for question comparison based on operator.\n        Type `Quantity` (represented as `dict` in JSON). \"\"\"\n        \n        self.answerReference = None\n        \"\"\" Value for question comparison based on operator.\n        Type `FHIRReference` (represented as `dict` in JSON). \"\"\"\n        \n        self.answerString = None\n        \"\"\" Value for question comparison based on operator.\n        Type `str`. \"\"\"\n        \n        self.answerTime = None\n        \"\"\" Value for question comparison based on operator.\n        Type `FHIRTime` (represented as `str` in JSON). \"\"\"\n        \n        self.operator = None\n        \"\"\" exists | = | != | > | < | >= | <=.\n        Type `str`. \"\"\"\n        \n        self.question = None\n        \"\"\" Question that determines whether item is enabled.\n        Type `str`. \"\"\"\n        \n        super(QuestionnaireItemEnableWhen, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(QuestionnaireItemEnableWhen, self).elementProperties()\n        js.extend([\n            (\"answerBoolean\", \"answerBoolean\", bool, False, \"answer\", True),\n            (\"answerCoding\", \"answerCoding\", coding.Coding, False, \"answer\", True),\n            (\"answerDate\", \"answerDate\", fhirdate.FHIRDate, False, \"answer\", True),\n            (\"answerDateTime\", \"answerDateTime\", fhirdatetime.FHIRDateTime, False, \"answer\", True),\n            (\"answerDecimal\", \"answerDecimal\", float, False, \"answer\", True),\n            (\"answerInteger\", \"answerInteger\", int, False, \"answer\", True),\n            (\"answerQuantity\", \"answerQuantity\", quantity.Quantity, False, \"answer\", True),\n            (\"answerReference\", \"answerReference\", fhirreference.FHIRReference, False, \"answer\", True),\n            (\"answerString\", \"answerString\", str, False, \"answer\", True),\n            (\"answerTime\", \"answerTime\", fhirtime.FHIRTime, False, \"answer\", True),\n            (\"operator\", \"operator\", str, False, None, True),\n            (\"question\", \"question\", str, False, None, True),\n        ])\n        return js\n\n\nclass QuestionnaireItemInitial(backboneelement.BackboneElement):\n    \"\"\" Initial value(s) when item is first rendered.\n    \n    One or more values that should be pre-populated in the answer when\n    initially rendering the questionnaire for user input.\n    \"\"\"\n    \n    resource_type = \"QuestionnaireItemInitial\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.valueAttachment = None\n        \"\"\" Actual value for initializing the question.\n        Type `Attachment` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueBoolean = None\n        \"\"\" Actual value for initializing the question.\n        Type `bool`. \"\"\"\n        \n        self.valueCoding = None\n        \"\"\" Actual value for initializing the question.\n        Type `Coding` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueDate = None\n        \"\"\" Actual value for initializing the question.\n        Type `FHIRDate` (represented as `str` in JSON). \"\"\"\n        \n        self.valueDateTime = None\n        \"\"\" Actual value for initializing the question.\n        Type `FHIRDateTime` (represented as `str` in JSON). \"\"\"\n        \n        self.valueDecimal = None\n        \"\"\" Actual value for initializing the question.\n        Type `float`. \"\"\"\n        \n        self.valueInteger = None\n        \"\"\" Actual value for initializing the question.\n        Type `int`. \"\"\"\n        \n        self.valueQuantity = None\n        \"\"\" Actual value for initializing the question.\n        Type `Quantity` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueReference = None\n        \"\"\" Actual value for initializing the question.\n        Type `FHIRReference` (represented as `dict` in JSON). \"\"\"\n        \n        self.valueString = None\n        \"\"\" Actual value for initializing the question.\n        Type `str`. \"\"\"\n        \n        self.valueTime = None\n        \"\"\" Actual value for initializing the question.\n        Type `FHIRTime` (represented as `str` in JSON). \"\"\"\n        \n        self.valueUri = None\n        \"\"\" Actual value for initializing the question.\n        Type `str`. \"\"\"\n        \n        super(QuestionnaireItemInitial, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(QuestionnaireItemInitial, self).elementProperties()\n        js.extend([\n            (\"valueAttachment\", \"valueAttachment\", attachment.Attachment, False, \"value\", True),\n            (\"valueBoolean\", \"valueBoolean\", bool, False, \"value\", True),\n            (\"valueCoding\", \"valueCoding\", coding.Coding, False, \"value\", True),\n            (\"valueDate\", \"valueDate\", fhirdate.FHIRDate, False, \"value\", True),\n            (\"valueDateTime\", \"valueDateTime\", fhirdatetime.FHIRDateTime, False, \"value\", True),\n            (\"valueDecimal\", \"valueDecimal\", float, False, \"value\", True),\n            (\"valueInteger\", \"valueInteger\", int, False, \"value\", True),\n            (\"valueQuantity\", \"valueQuantity\", quantity.Quantity, False, \"value\", True),\n            (\"valueReference\", \"valueReference\", fhirreference.FHIRReference, False, \"value\", True),\n            (\"valueString\", \"valueString\", str, False, \"value\", True),\n            (\"valueTime\", \"valueTime\", fhirtime.FHIRTime, False, \"value\", True),\n            (\"valueUri\", \"valueUri\", str, False, \"value\", True),\n        ])\n        return js\n\n\nfrom . import attachment\nfrom . import codeableconcept\nfrom . import coding\nfrom . import contactdetail\nfrom . import fhirdate\nfrom . import fhirdatetime\nfrom . import fhirreference\nfrom . import fhirtime\nfrom . import identifier\nfrom . import period\nfrom . import quantity\nfrom . import usagecontext\n",
    "fhirclient/models/fhirabstractresource.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  Base class for FHIR resources.\n#  2014, SMART Health IT.\n\nfrom . import fhirabstractbase\n\n\nclass FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):\n    \"\"\" Extends the FHIRAbstractBase with server talking capabilities.\n    \"\"\"\n    resource_type = 'FHIRAbstractResource'\n    \n    def __init__(self, jsondict=None, strict=True):\n        self._server = None\n        \"\"\" The server the instance was read from. \"\"\"\n        \n        # raise if \"resourceType\" does not match\n        if jsondict is not None and 'resourceType' in jsondict \\\n            and jsondict['resourceType'] != self.resource_type:\n            raise Exception(\"Attempting to instantiate {} with resource data that defines a resourceType of \\\"{}\\\"\"\n                .format(self.__class__, jsondict['resourceType']))\n        \n        super(FHIRAbstractResource, self).__init__(jsondict=jsondict, strict=strict)\n    \n    @classmethod\n    def _with_json_dict(cls, jsondict):\n        \"\"\" Overridden to use a factory if called when \"resourceType\" is\n        defined in the JSON but does not match the receiver's resource_type.\n        \"\"\"\n        if not isinstance(jsondict, dict):\n            raise Exception(\"Cannot use this method with anything but a JSON dictionary, got {}\"\n                .format(jsondict))\n        \n        res_type = jsondict.get('resourceType')\n        if res_type and res_type != cls.resource_type:\n            return fhirelementfactory.FHIRElementFactory.instantiate(res_type, jsondict)\n        return super(FHIRAbstractResource, cls)._with_json_dict(jsondict)\n    \n    def as_json(self):\n        js = super(FHIRAbstractResource, self).as_json()\n        js['resourceType'] = self.resource_type\n        return js\n    \n    \n    # MARK: Handling Paths\n    \n    def relativeBase(self):\n        return self.__class__.resource_type\n    \n    def relativePath(self):\n        if self.id is None:\n            return self.relativeBase()\n        return \"{}/{}\".format(self.relativeBase(), self.id)\n    \n    \n    # MARK: - Server Connection\n    \n    @property\n    def origin_server(self):\n        \"\"\" Walks the owner hierarchy until it finds an owner with a server.\n        \"\"\"\n        server = self._server\n        owner = self._owner\n        while server is None and owner is not None:\n            server = getattr(owner, '_server', None)\n            owner = owner._owner\n        return server\n\n    @origin_server.setter\n    def origin_server(self, server):\n        \"\"\" Sets the server on an element. \"\"\"\n        self._server = server\n    \n    @classmethod\n    def read(cls, rem_id, server):\n        \"\"\" Read the resource with the given id from the given server. The\n        passed-in server instance must support a `request_json()` method call,\n        taking a relative path as first (and only mandatory) argument.\n        \n        :param str rem_id: The id of the resource on the remote server\n        :param FHIRServer server: An instance of a FHIR server or compatible class\n        :returns: An instance of the receiving class\n        \"\"\"\n        if not rem_id:\n            raise Exception(\"Cannot read resource without remote id\")\n        \n        path = '{}/{}'.format(cls.resource_type, rem_id)\n        instance = cls.read_from(path, server)\n        instance._local_id = rem_id\n        \n        return instance\n    \n    @classmethod\n    def read_from(cls, path, server):\n        \"\"\" Requests data from the given REST path on the server and creates\n        an instance of the receiving class.\n        \n        :param str path: The REST path to read from\n        :param FHIRServer server: An instance of a FHIR server or compatible class\n        :returns: An instance of the receiving class\n        \"\"\"\n        if not path:\n            raise Exception(\"Cannot read resource without REST path\")\n        if server is None:\n            raise Exception(\"Cannot read resource without server instance\")\n        \n        ret = server.request_json(path)\n        instance = cls(jsondict=ret)\n        instance.origin_server = server\n        return instance\n\n    def createPath(self):\n        \"\"\" Get the endpoint on the server for creating the resource.\n\n        :returns: The resource endpoint or None for the root endpoint\n        \"\"\"\n        root_post_types = (\"batch\", \"transaction\")\n\n        if self.resource_type == \"Bundle\" and self.type in root_post_types:\n            return None\n\n        return self.relativeBase()\n\n    def create(self, server):\n        \"\"\" Attempt to create the receiver on the given server, using a POST\n        command.\n        \n        :param FHIRServer server: The server to create the receiver on\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception(\"Cannot create a resource without a server\")\n        if self.id:\n            raise Exception(\"This resource already has an id, cannot create\")\n\n        ret = srv.post_json(self.createPath(), self.as_json())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n    \n    def update(self, server=None):\n        \"\"\" Update the receiver's representation on the given server, issuing\n        a PUT command.\n        \n        :param FHIRServer server: The server to update the receiver on;\n            optional, will use the instance's `server` if needed.\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception(\"Cannot update a resource that does not have a server\")\n        if not self.id:\n            raise Exception(\"Cannot update a resource that does not have an id\")\n        \n        ret = srv.put_json(self.relativePath(), self.as_json())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n    \n    def delete(self, server=None):\n        \"\"\" Delete the receiver from the given server with a DELETE command.\n        \n        :param FHIRServer server: The server to update the receiver on;\n            optional, will use the instance's `server` if needed.\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception(\"Cannot delete a resource that does not have a server\")\n        if not self.id:\n            raise Exception(\"Cannot delete a resource that does not have an id\")\n        \n        ret = srv.delete_json(self.relativePath())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n    \n    \n    # MARK: - Search\n    \n    def search(self, struct=None):\n        \"\"\" Search can be started via a dictionary containing a search\n        construct.\n        \n        Calling this method with a search struct will return a `FHIRSearch`\n        object representing the search struct, with \"$type\" and \"id\" added.\n        \n        :param dict struct: An optional search structure\n        :returns: A FHIRSearch instance\n        \"\"\"\n        if struct is None:\n            struct = {'$type': self.__class__.resource_type}\n        if self._local_id is not None or self.id is not None:\n            struct['id'] = self._local_id or self.id\n        return self.__class__.where(struct)\n    \n    @classmethod\n    def where(cls, struct):\n        \"\"\" Search can be started via a dictionary containing a search\n        construct.\n        \n        Calling this method with a search struct will return a `FHIRSearch`\n        object representing the search struct\n        \n        :param dict struct: A search structure\n        :returns: A FHIRSearch instance\n        \"\"\"\n        return fhirsearch.FHIRSearch(cls, struct)\n\n\nfrom . import fhirsearch\nfrom . import fhirelementfactory\n",
    "fhirclient/models/fhirreference.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#  Subclassing FHIR's reference to add resolving capabilities\n\nimport logging\nfrom . import reference\n\nlogger = logging.getLogger(__name__)\n\n\nclass FHIRReference(reference.Reference):\n    \"\"\" Subclassing FHIR's `Reference` resource to add resolving capabilities.\n    \"\"\"\n    \n    def resolved(self, klass):\n        \"\"\" Resolves the reference and caches the result, returning instance(s)\n        of the referenced classes.\n        \n        :param klass: The expected class of the resource\n        :returns: An instance (or list thereof) of the resolved reference if\n            dereferencing was successful, `None` otherwise\n        \"\"\"\n        owning_resource = self.owningResource()\n        if owning_resource is None:\n            raise Exception(\"Cannot resolve reference without having an owner (which must be a `DomainResource`)\")\n        if klass is None:\n            raise Exception(\"Cannot resolve reference without knowing the class\")\n        \n        refid = self.processedReferenceIdentifier()\n        if not refid:\n            logger.warning(\"No `reference` set, cannot resolve\")\n            return None\n        \n        # already resolved and cached?\n        resolved = owning_resource.resolvedReference(refid)\n        if resolved is not None:\n            if isinstance(resolved, klass):\n                return resolved\n            logger.warning(\"Referenced resource {} is not a {} but a {}\".format(refid, klass, resolved.__class__))\n            return None\n        \n        # not yet resolved, see if it's a contained resource\n        if owning_resource.contained is not None:\n            for contained in owning_resource.contained:\n                if contained.id == refid:\n                    owning_resource.didResolveReference(refid, contained)\n                    if isinstance(contained, klass):\n                        return contained\n                    logger.warning(\"Contained resource {} is not a {} but a {}\".format(refid, klass, contained.__class__))\n                    return None\n        \n        # are we in a bundle?\n        ref_is_relative = '://' not in self.reference and 'urn:' != self.reference[:4]\n        bundle = self.owningBundle()\n        while bundle is not None:\n            if bundle.entry is not None:\n                fullUrl = self.reference\n                if ref_is_relative:\n                    base = bundle.origin_server.base_uri if bundle.origin_server else ''\n                    fullUrl = base + self.reference\n                \n                for entry in bundle.entry:\n                    if entry.fullUrl == fullUrl:\n                        found = entry.resource\n                        if isinstance(found, klass):\n                            return found\n                        logger.warning(\"Bundled resource {} is not a {} but a {}\".format(refid, klass, found.__class__))\n                        return None\n            bundle = bundle.owningBundle()\n        \n        # relative references, use the same server\n        server = None\n        if ref_is_relative:\n            server = owning_resource.origin_server if owning_resource else None\n        \n        # TODO: instantiate server for absolute resource\n        if server is None:\n            logger.warning(\"Not implemented: resolving absolute reference to resource {}\"\n                .format(self.reference))\n            return None\n        \n        # fetch remote resource; unable to verify klass since we use klass.read_from()\n        relative = klass.read_from(self.reference, server)\n        owning_resource.didResolveReference(refid, relative)\n        return relative\n    \n    def processedReferenceIdentifier(self):\n        \"\"\" Normalizes the reference-id.\n        \"\"\"\n        if self.reference and '#' == self.reference[0]:\n            return self.reference[1:]\n        return self.reference\n\n",
    "fhirclient/server.py": "import json\nimport requests\nimport logging\nimport urllib.parse as urlparse\n\nfrom .auth import FHIRAuth\n\nFHIRJSONMimeType = 'application/fhir+json'\n\nlogger = logging.getLogger(__name__)\n\n\nclass FHIRUnauthorizedException(Exception):\n    \"\"\" Indicating a 401 response.\n    \"\"\"\n    def __init__(self, response):\n        self.response = response\n\n\nclass FHIRPermissionDeniedException(Exception):\n    \"\"\" Indicating a 403 response.\n    \"\"\"\n    def __init__(self, response):\n        self.response = response\n\n\nclass FHIRNotFoundException(Exception):\n    \"\"\" Indicating a 404 response.\n    \"\"\"\n    def __init__(self, response):\n        self.response = response\n\n\nclass FHIRServer(object):\n    \"\"\" Handles talking to a FHIR server.\n    \"\"\"\n    \n    def __init__(self, client, base_uri=None, state=None):\n        self.client = client\n        self.auth = None\n        self.base_uri = None\n        self.aud = None\n\n        # Use a single requests Session for all \"requests\"\n        self.session = requests.Session()\n        \n        # A URI can't possibly be less than 11 chars\n        # make sure we end with \"/\", otherwise the last path component will be\n        # lost when creating URLs with urllib\n        if base_uri is not None and len(base_uri) > 10:\n            self.base_uri = base_uri if '/' == base_uri[-1] else base_uri + '/'\n            self.aud = base_uri\n        self._capability = None\n        if state is not None:\n            self.from_state(state)\n        if not self.base_uri or len(self.base_uri) <= 10:\n            raise Exception(\"FHIRServer must be initialized with `base_uri` or `state` containing the base-URI, but neither happened\")\n    \n    def should_save_state(self):\n        if self.client is not None:\n            self.client.save_state()\n    \n    \n    # MARK: Server CapabilityStatement\n    \n    @property\n    def capabilityStatement(self):\n        self.get_capability()\n        return self._capability\n    \n    def get_capability(self, force=False):\n        \"\"\" Returns the server's CapabilityStatement, retrieving it if needed\n        or forced.\n        \"\"\"\n        if self._capability is None or force:\n            logger.info('Fetching CapabilityStatement from {0}'.format(self.base_uri))\n            from .models import capabilitystatement\n            conf = capabilitystatement.CapabilityStatement.read_from('metadata', self)\n            self._capability = conf\n            \n            security = None\n            try:\n                security = conf.rest[0].security\n            except Exception as e:\n                logger.info(\"No REST security statement found in server capability statement\")\n            \n            settings = {\n                'aud': self.aud,\n                'app_id': self.client.app_id if self.client is not None else None,\n                'app_secret': self.client.app_secret if self.client is not None else None,\n                'redirect_uri': self.client.redirect if self.client is not None else None,\n                'jwt_token': self.client.jwt_token if self.client is not None else None,\n            }\n            self.auth = FHIRAuth.from_capability_security(security, settings)\n            self.should_save_state()\n    \n    \n    # MARK: Authorization\n    \n    @property\n    def desired_scope(self):\n        return self.client.desired_scope if self.client is not None else None\n    \n    @property\n    def launch_token(self):\n        return self.client.launch_token if self.client is not None else None\n    \n    @property\n    def authorize_uri(self):\n        if self.auth is None:\n            self.get_capability()\n        return self.auth.authorize_uri(self)\n    \n    def handle_callback(self, url):\n        if self.auth is None:\n            raise Exception(\"Not ready to handle callback, I do not have an auth instance\")\n        return self.auth.handle_callback(url, self)\n\n    def authorize(self):\n        if self.auth is None:\n            raise Exception(\"Not ready to authorize, I do not have an auth instance\")\n        return self.auth.authorize(self) if self.auth is not None else None\n\n    def reauthorize(self):\n        if self.auth is None:\n            raise Exception(\"Not ready to reauthorize, I do not have an auth instance\")\n        return self.auth.reauthorize(self) if self.auth is not None else None\n    \n    \n    # MARK: Requests\n    \n    @property\n    def ready(self):\n        \"\"\" Check whether the server is ready to make calls, i.e. is has\n        fetched its capability statement and its `auth` instance is ready.\n        \n        :returns: True if the server can make authenticated calls\n        \"\"\"\n        return self.auth.ready if self.auth is not None else False\n    \n    def prepare(self):\n        \"\"\" Check whether the server is ready to make calls, i.e. is has\n        fetched its capability statement and its `auth` instance is ready.\n        This method will fetch the capability statement if it hasn't already\n        been fetched.\n        \n        :returns: True if the server can make authenticated calls\n        \"\"\"\n        if self.auth is None:\n            self.get_capability()\n        return self.auth.ready if self.auth is not None else False\n    \n    def request_json(self, path, nosign=False):\n        \"\"\" Perform a request for JSON data against the server's base with the\n        given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: Decoded JSON response\n        \"\"\"\n        headers = {'Accept': 'application/json'}\n        res = self._get(path, headers, nosign)\n        \n        return res.json()\n    \n    def request_data(self, path, headers={}, nosign=False):\n        \"\"\" Perform a data request data against the server's base with the\n        given relative path.\n        \"\"\"\n        res = self._get(path, headers, nosign)\n        return res.content\n    \n    def _get(self, path, headers={}, nosign=False):\n        \"\"\" Issues a GET request.\n        \n        :returns: The response object\n        \"\"\"\n        assert self.base_uri and path\n        url = urlparse.urljoin(self.base_uri, path)\n        \n        header_defaults = {\n            'Accept': FHIRJSONMimeType,\n            'Accept-Charset': 'UTF-8',\n        }\n        # merge in user headers with defaults\n        header_defaults.update(headers)\n        # use the merged headers in the request\n        headers = header_defaults\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        \n        # perform the request but intercept 401 responses, raising our own Exception\n        res = self.session.get(url, headers=headers)\n        self.raise_for_status(res)\n        return res\n    \n    def put_json(self, path, resource_json, nosign=False):\n        \"\"\" Performs a PUT request of the given JSON, which should represent a\n        resource, to the given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param dict resource_json: The JSON representing the resource\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {\n            'Content-type': FHIRJSONMimeType,\n            'Accept': FHIRJSONMimeType,\n            'Accept-Charset': 'UTF-8',\n        }\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        \n        # perform the request but intercept 401 responses, raising our own Exception\n        res = self.session.put(url, headers=headers, data=json.dumps(resource_json))\n        self.raise_for_status(res)\n        return res\n    \n    def post_json(self, path, resource_json, nosign=False):\n        \"\"\" Performs a POST of the given JSON, which should represent a\n        resource, to the given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param dict resource_json: The JSON representing the resource\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {\n            'Content-type': FHIRJSONMimeType,\n            'Accept': FHIRJSONMimeType,\n            'Accept-Charset': 'UTF-8',\n        }\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        \n        # perform the request but intercept 401 responses, raising our own Exception\n        res = self.session.post(url, headers=headers, data=json.dumps(resource_json))\n        self.raise_for_status(res)\n        return res\n    \n    def post_as_form(self, url, formdata, auth=None):\n        \"\"\" Performs a POST request with form-data, expecting to receive JSON.\n        This method is used in the OAuth2 token exchange and thus doesn't\n        request fhir+json.\n        \n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        headers = {\n            'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',\n            'Accept': 'application/json',\n        }\n        res = self.session.post(url, data=formdata, auth=auth)\n        self.raise_for_status(res)\n        return res\n    \n    def delete_json(self, path, nosign=False):\n        \"\"\" Issues a DELETE command against the given relative path, accepting\n        a JSON response.\n        \n        :param str path: The relative URL path to issue a DELETE against\n        :param bool nosign: If set to True, the request will not be signed\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {\n            'Accept': FHIRJSONMimeType,\n            'Accept-Charset': 'UTF-8',\n        }\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        \n        # perform the request but intercept 401 responses, raising our own Exception\n        res = self.session.delete(url)\n        self.raise_for_status(res)\n        return res\n    \n    def raise_for_status(self, response):\n        if response.status_code < 400:\n            return\n        \n        if 401 == response.status_code:\n            raise FHIRUnauthorizedException(response)\n        elif 403 == response.status_code:\n            raise FHIRPermissionDeniedException(response)\n        elif 404 == response.status_code:\n            raise FHIRNotFoundException(response)\n        else:\n            response.raise_for_status()\n    \n    \n    # MARK: State Handling\n    \n    @property\n    def state(self):\n        \"\"\" Return current state.\n        \"\"\"\n        return {\n            'base_uri': self.base_uri,\n            'auth_type': self.auth.auth_type if self.auth is not None else 'none',\n            'auth': self.auth.state if self.auth is not None else None,\n        }\n    \n    def from_state(self, state):\n        \"\"\" Update ivars from given state information.\n        \"\"\"\n        assert state\n        self.base_uri = state.get('base_uri') or self.base_uri\n        self.auth = FHIRAuth.create(state.get('auth_type'), state=state.get('auth'))\n    \n",
    "fhirclient/models/domainresource.py": "# Generated from FHIR 4.0.1-9346c8cc45 (http://hl7.org/fhir/StructureDefinition/DomainResource).\n# 2024, SMART Health IT.\n\n\nfrom . import resource\n\nclass DomainResource(resource.Resource):\n    \"\"\" A resource with narrative, extensions, and contained resources.\n    \n    A resource that includes narrative, extensions, and contained resources.\n    \"\"\"\n    \n    resource_type = \"DomainResource\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.contained = None\n        \"\"\" Contained, inline Resources.\n        List of `Resource` items (represented as `dict` in JSON). \"\"\"\n        \n        self.extension = None\n        \"\"\" Additional content defined by implementations.\n        List of `Extension` items (represented as `dict` in JSON). \"\"\"\n        \n        self.modifierExtension = None\n        \"\"\" Extensions that cannot be ignored.\n        List of `Extension` items (represented as `dict` in JSON). \"\"\"\n        \n        self.text = None\n        \"\"\" Text summary of the resource, for human interpretation.\n        Type `Narrative` (represented as `dict` in JSON). \"\"\"\n        \n        super(DomainResource, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(DomainResource, self).elementProperties()\n        js.extend([\n            (\"contained\", \"contained\", resource.Resource, True, None, False),\n            (\"extension\", \"extension\", extension.Extension, True, None, False),\n            (\"modifierExtension\", \"modifierExtension\", extension.Extension, True, None, False),\n            (\"text\", \"text\", narrative.Narrative, False, None, False),\n        ])\n        return js\n\n\nfrom . import extension\nfrom . import narrative\n",
    "fhirclient/models/resource.py": "# Generated from FHIR 4.0.1-9346c8cc45 (http://hl7.org/fhir/StructureDefinition/Resource).\n# 2024, SMART Health IT.\n\n\nfrom . import fhirabstractresource\n\nclass Resource(fhirabstractresource.FHIRAbstractResource):\n    \"\"\" Base Resource.\n    \n    This is the base resource type for everything.\n    \"\"\"\n    \n    resource_type = \"Resource\"\n    \n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.id = None\n        \"\"\" Logical id of this artifact.\n        Type `str`. \"\"\"\n        \n        self.implicitRules = None\n        \"\"\" A set of rules under which this content was created.\n        Type `str`. \"\"\"\n        \n        self.language = None\n        \"\"\" Language of the resource content.\n        Type `str`. \"\"\"\n        \n        self.meta = None\n        \"\"\" Metadata about the resource.\n        Type `Meta` (represented as `dict` in JSON). \"\"\"\n        \n        super(Resource, self).__init__(jsondict=jsondict, strict=strict)\n    \n    def elementProperties(self):\n        js = super(Resource, self).elementProperties()\n        js.extend([\n            (\"id\", \"id\", str, False, None, False),\n            (\"implicitRules\", \"implicitRules\", str, False, None, False),\n            (\"language\", \"language\", str, False, None, False),\n            (\"meta\", \"meta\", meta.Meta, False, None, False),\n        ])\n        return js\n\n\nfrom . import meta\n"
  },
  "GT_src_dict": {
    "fhirclient/models/fhirabstractbase.py": {
      "FHIRAbstractBase.owningResource": {
        "code": "    def owningResource(self):\n        \"\"\"Walks up the owner hierarchy starting from the current instance and returns the next parent that is an instance of `DomainResource`. This method utilizes the `_owner` attribute, which holds a reference to the parent resource. If the owner is not found or does not exist, it returns None. The presence of the `contained` attribute is used to identify `DomainResource` instances in the hierarchy, as parent resources typically have this attribute defined. \n\nReturns:\n    DomainResource or None: The first encountered parent that is a `DomainResource` instance, or None if no such parent exists.\"\"\"\n        ' Walks the owner hierarchy and returns the next parent that is a\\n        `DomainResource` instance.\\n        '\n        owner = self._owner\n        while owner is not None and (not hasattr(owner, 'contained')):\n            owner = owner._owner\n        return owner",
        "docstring": "Walks up the owner hierarchy starting from the current instance and returns the next parent that is an instance of `DomainResource`. This method utilizes the `_owner` attribute, which holds a reference to the parent resource. If the owner is not found or does not exist, it returns None. The presence of the `contained` attribute is used to identify `DomainResource` instances in the hierarchy, as parent resources typically have this attribute defined. \n\nReturns:\n    DomainResource or None: The first encountered parent that is a `DomainResource` instance, or None if no such parent exists.",
        "signature": "def owningResource(self):",
        "type": "Method",
        "class_signature": "class FHIRAbstractBase(object):"
      },
      "FHIRAbstractBase.owningBundle": {
        "code": "    def owningBundle(self):\n        \"\"\"Walks the owner hierarchy of the current FHIR element instance and retrieves the nearest parent that is an instance of `Bundle`. \n\nThis method checks the `_owner` attribute, which points to the parent resource in the hierarchy. It iterates upwards through the owner chain until it finds a parent with a `resource_type` equal to 'Bundle' or until there are no more owners to check. \n\nReturns:\n    The nearest parent `Bundle` instance found. If no such parent exists, it returns `None`.\n\nDependencies:\n    - `self._owner`: A reference to the parent resource of the current instance.\n    - `owner.resource_type`: A property that denotes the type of the resource.\n\nThis method is crucial for contexts where resolving references or relationships to `Bundle` resources is necessary, such as in FHIR data processing.\"\"\"\n        ' Walks the owner hierarchy and returns the next parent that is a\\n        `Bundle` instance.\\n        '\n        owner = self._owner\n        while owner is not None and (not 'Bundle' == owner.resource_type):\n            owner = owner._owner\n        return owner",
        "docstring": "Walks the owner hierarchy of the current FHIR element instance and retrieves the nearest parent that is an instance of `Bundle`. \n\nThis method checks the `_owner` attribute, which points to the parent resource in the hierarchy. It iterates upwards through the owner chain until it finds a parent with a `resource_type` equal to 'Bundle' or until there are no more owners to check. \n\nReturns:\n    The nearest parent `Bundle` instance found. If no such parent exists, it returns `None`.\n\nDependencies:\n    - `self._owner`: A reference to the parent resource of the current instance.\n    - `owner.resource_type`: A property that denotes the type of the resource.\n\nThis method is crucial for contexts where resolving references or relationships to `Bundle` resources is necessary, such as in FHIR data processing.",
        "signature": "def owningBundle(self):",
        "type": "Method",
        "class_signature": "class FHIRAbstractBase(object):"
      },
      "FHIRAbstractBase.resolvedReference": {
        "code": "    def resolvedReference(self, refid):\n        \"\"\"Retrieves a resolved reference resource by its identifier. If the reference has previously been resolved and stored in the `_resolved` dictionary, it is returned directly. If not, the method checks if the instance has an owner (the parent resource) and forwards the resolution request to the owner's `resolvedReference` method.\n\nParameters:\n- refid (str): The identifier of the resource to resolve.\n\nReturns:\n- An instance of `Resource` if found, or `None` if the reference is not resolved and there is no owner to forward the request to.\n\nSide Effects:\n- Relies on the `_resolved` dictionary, which is utilized to cache resolved references, enabling efficient lookups. If the instance does not have the reference cached, it checks its owner for the resolution.\"\"\"\n        \" Returns the resolved reference with the given id, if it has been\\n        resolved already. If it hasn't, forwards the call to its owner if it\\n        has one.\\n        \\n        You should probably use `resolve()` on the `FHIRReference` itself.\\n        \\n        :param refid: The id of the resource to resolve\\n        :returns: An instance of `Resource`, if it was found\\n        \"\n        if self._resolved and refid in self._resolved:\n            return self._resolved[refid]\n        return self._owner.resolvedReference(refid) if self._owner is not None else None",
        "docstring": "Retrieves a resolved reference resource by its identifier. If the reference has previously been resolved and stored in the `_resolved` dictionary, it is returned directly. If not, the method checks if the instance has an owner (the parent resource) and forwards the resolution request to the owner's `resolvedReference` method.\n\nParameters:\n- refid (str): The identifier of the resource to resolve.\n\nReturns:\n- An instance of `Resource` if found, or `None` if the reference is not resolved and there is no owner to forward the request to.\n\nSide Effects:\n- Relies on the `_resolved` dictionary, which is utilized to cache resolved references, enabling efficient lookups. If the instance does not have the reference cached, it checks its owner for the resolution.",
        "signature": "def resolvedReference(self, refid):",
        "type": "Method",
        "class_signature": "class FHIRAbstractBase(object):"
      },
      "FHIRAbstractBase.didResolveReference": {
        "code": "    def didResolveReference(self, refid, resolved):\n        \"\"\"Stores a resolved reference into the `_resolved` dictionary for later retrieval. This method is called when a reference (identified by `refid`) to a resource is successfully resolved to an actual resource (`resolved`).\n\nParameters:\n- refid (str): The identifier of the resource that has been resolved.\n- resolved (Resource): The actual resource instance that corresponds to the given `refid`, ready to be cached for future reference.\n\nThis method modifies the `_resolved` attribute, which is a dictionary that maps reference IDs to their resolved resource instances. If `_resolved` is `None`, it is initialized as a new dictionary. The `_resolved` attribute plays a crucial role in managing and retrieving resolved references in the context of FHIR resources, streamlining access to linked resources across the FHIR data model.\"\"\"\n        ' Called by `FHIRResource` when it resolves a reference. Stores the\\n        resolved reference into the `_resolved` dictionary.\\n        \\n        :param refid: The id of the resource that was resolved\\n        :param refid: The resolved resource, ready to be cached\\n        '\n        if self._resolved is not None:\n            self._resolved[refid] = resolved\n        else:\n            self._resolved = {refid: resolved}",
        "docstring": "Stores a resolved reference into the `_resolved` dictionary for later retrieval. This method is called when a reference (identified by `refid`) to a resource is successfully resolved to an actual resource (`resolved`).\n\nParameters:\n- refid (str): The identifier of the resource that has been resolved.\n- resolved (Resource): The actual resource instance that corresponds to the given `refid`, ready to be cached for future reference.\n\nThis method modifies the `_resolved` attribute, which is a dictionary that maps reference IDs to their resolved resource instances. If `_resolved` is `None`, it is initialized as a new dictionary. The `_resolved` attribute plays a crucial role in managing and retrieving resolved references in the context of FHIR resources, streamlining access to linked resources across the FHIR data model.",
        "signature": "def didResolveReference(self, refid, resolved):",
        "type": "Method",
        "class_signature": "class FHIRAbstractBase(object):"
      }
    },
    "fhirclient/models/bundle.py": {
      "Bundle.__init__": {
        "code": "    def __init__(self, jsondict=None, strict=True):\n        \"\"\"Initialize a Bundle resource, which serves as a container for a collection of resources. This constructor sets up the necessary attributes for organizing entries, linking resources, and maintaining metadata about the bundle.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing the bundle's properties. If provided, it is parsed to populate the bundle's attributes.\n- strict (bool, default=True): When True, invalid variables will raise a TypeError, ensuring strict validation of the bundle's properties.\n\nAttributes:\n- entry (list): A list of entries in the bundle, each represented as `BundleEntry` items which may contain resources or associated information.\n- identifier (Identifier, optional): A persistent identifier for the bundle, represented as an `Identifier` object.\n- link (list): A list of `BundleLink` items, which provide links related to this bundle for navigation or context.\n- signature (Signature, optional): A digital signature for the bundle, represented as a `Signature` object to ensure integrity.\n- timestamp (FHIRInstant, optional): A timestamp indicating when the bundle was assembled, represented as a string in FHIR Instant format.\n- total (int, optional): The total number of matches if the bundle is the result of a search operation.\n- type (str, optional): A string indicating the type of the bundle, which can include 'document', 'message', 'transaction', and others as defined in the FHIR specification.\n\nThis constructor interacts with the parent class `Resource` to initialize any common resource properties and validates the bundle configuration based on the passed parameters.\"\"\"\n        ' Initialize all valid properties.\\n        \\n        :raises: FHIRValidationError on validation errors, unless strict is False\\n        :param dict jsondict: A JSON dictionary to use for initialization\\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\\n        '\n        self.entry = None\n        ' Entry in the bundle - will have a resource or information.\\n        List of `BundleEntry` items (represented as `dict` in JSON). '\n        self.identifier = None\n        ' Persistent identifier for the bundle.\\n        Type `Identifier` (represented as `dict` in JSON). '\n        self.link = None\n        ' Links related to this Bundle.\\n        List of `BundleLink` items (represented as `dict` in JSON). '\n        self.signature = None\n        ' Digital Signature.\\n        Type `Signature` (represented as `dict` in JSON). '\n        self.timestamp = None\n        ' When the bundle was assembled.\\n        Type `FHIRInstant` (represented as `str` in JSON). '\n        self.total = None\n        ' If search, the total number of matches.\\n        Type `int`. '\n        self.type = None\n        ' document | message | transaction | transaction-response | batch |\\n        batch-response | history | searchset | collection.\\n        Type `str`. '\n        super(Bundle, self).__init__(jsondict=jsondict, strict=strict)",
        "docstring": "Initialize a Bundle resource, which serves as a container for a collection of resources. This constructor sets up the necessary attributes for organizing entries, linking resources, and maintaining metadata about the bundle.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing the bundle's properties. If provided, it is parsed to populate the bundle's attributes.\n- strict (bool, default=True): When True, invalid variables will raise a TypeError, ensuring strict validation of the bundle's properties.\n\nAttributes:\n- entry (list): A list of entries in the bundle, each represented as `BundleEntry` items which may contain resources or associated information.\n- identifier (Identifier, optional): A persistent identifier for the bundle, represented as an `Identifier` object.\n- link (list): A list of `BundleLink` items, which provide links related to this bundle for navigation or context.\n- signature (Signature, optional): A digital signature for the bundle, represented as a `Signature` object to ensure integrity.\n- timestamp (FHIRInstant, optional): A timestamp indicating when the bundle was assembled, represented as a string in FHIR Instant format.\n- total (int, optional): The total number of matches if the bundle is the result of a search operation.\n- type (str, optional): A string indicating the type of the bundle, which can include 'document', 'message', 'transaction', and others as defined in the FHIR specification.\n\nThis constructor interacts with the parent class `Resource` to initialize any common resource properties and validates the bundle configuration based on the passed parameters.",
        "signature": "def __init__(self, jsondict=None, strict=True):",
        "type": "Method",
        "class_signature": "class Bundle(resource.Resource):"
      }
    },
    "fhirclient/models/questionnaire.py": {
      "Questionnaire.__init__": {
        "code": "    def __init__(self, jsondict=None, strict=True):\n        \"\"\"Initialize a Questionnaire instance.\n\nThis constructor initializes a Questionnaire object that represents a structured set of questions designed to guide data collection from users. The attributes of the Questionnaire class, which correlate with the properties defined in the FHIR Questionnaire specification, are set to None or to values provided in the optional jsondict argument. This allows instantiation with specific data if available.\n\nParameters:\n- jsondict (dict, optional): A dictionary containing data to initialize the Questionnaire attributes. If provided, the values will be parsed and assigned to the corresponding class attributes.\n- strict (bool, optional): If True (default), the constructor raises a TypeError on encountering invalid variables during initialization; if False, it silently ignores them.\n\nAttributes:\n- approvalDate: Date when the questionnaire was approved (FHIRDate type).\n- code: Concept representing the overall questionnaire (list of Coding items).\n- contact: Publisher's contact details (list of ContactDetail items).\n- copyright: Publishing restrictions (string).\n- date: Last modified date (FHIRDateTime type).\n- derivedFrom: References to existing protocols or definitions (list of strings).\n- description: Natural language description of the questionnaire (string).\n- effectivePeriod: Expected usage timeframe for the questionnaire (Period type).\n- experimental: Indicator for testing purposes (boolean).\n- identifier: Additional identifiers for the questionnaire (list of Identifier items).\n- item: Questions and sections within the questionnaire (list of QuestionnaireItem items).\n- jurisdiction: Intended jurisdiction (list of CodeableConcept items).\n- lastReviewDate: Date when the questionnaire was last reviewed (FHIRDate type).\n- name: Computer-friendly name for the questionnaire (string).\n- publisher: Name of the publisher (string).\n- purpose: Purpose of the questionnaire (string).\n- status: Current status (string from a predefined set of values).\n- subjectType: Resource types applicable to QuestionnaireResponse (list of strings).\n- title: Human-friendly name for the questionnaire (string).\n- url: Canonical URI identifier for the questionnaire (string).\n- useContext: Context intended to support the questionnaire (list of UsageContext items).\n- version: Business version of the questionnaire (string).\n\nThe method relies on attributes defined in the FHIR standard for health information exchange and any related classes (e.g., FHIRDate, Coding) to be correctly implemented for proper functioning.\"\"\"\n        ' Initialize all valid properties.\\n        \\n        :raises: FHIRValidationError on validation errors, unless strict is False\\n        :param dict jsondict: A JSON dictionary to use for initialization\\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\\n        '\n        self.approvalDate = None\n        ' When the questionnaire was approved by publisher.\\n        Type `FHIRDate` (represented as `str` in JSON). '\n        self.code = None\n        ' Concept that represents the overall questionnaire.\\n        List of `Coding` items (represented as `dict` in JSON). '\n        self.contact = None\n        ' Contact details for the publisher.\\n        List of `ContactDetail` items (represented as `dict` in JSON). '\n        self.copyright = None\n        ' Use and/or publishing restrictions.\\n        Type `str`. '\n        self.date = None\n        ' Date last changed.\\n        Type `FHIRDateTime` (represented as `str` in JSON). '\n        self.derivedFrom = None\n        ' Instantiates protocol or definition.\\n        List of `str` items. '\n        self.description = None\n        ' Natural language description of the questionnaire.\\n        Type `str`. '\n        self.effectivePeriod = None\n        ' When the questionnaire is expected to be used.\\n        Type `Period` (represented as `dict` in JSON). '\n        self.experimental = None\n        ' For testing purposes, not real usage.\\n        Type `bool`. '\n        self.identifier = None\n        ' Additional identifier for the questionnaire.\\n        List of `Identifier` items (represented as `dict` in JSON). '\n        self.item = None\n        ' Questions and sections within the Questionnaire.\\n        List of `QuestionnaireItem` items (represented as `dict` in JSON). '\n        self.jurisdiction = None\n        ' Intended jurisdiction for questionnaire (if applicable).\\n        List of `CodeableConcept` items (represented as `dict` in JSON). '\n        self.lastReviewDate = None\n        ' When the questionnaire was last reviewed.\\n        Type `FHIRDate` (represented as `str` in JSON). '\n        self.name = None\n        ' Name for this questionnaire (computer friendly).\\n        Type `str`. '\n        self.publisher = None\n        ' Name of the publisher (organization or individual).\\n        Type `str`. '\n        self.purpose = None\n        ' Why this questionnaire is defined.\\n        Type `str`. '\n        self.status = None\n        ' draft | active | retired | unknown.\\n        Type `str`. '\n        self.subjectType = None\n        ' Resource that can be subject of QuestionnaireResponse.\\n        List of `str` items. '\n        self.title = None\n        ' Name for this questionnaire (human friendly).\\n        Type `str`. '\n        self.url = None\n        ' Canonical identifier for this questionnaire, represented as a URI\\n        (globally unique).\\n        Type `str`. '\n        self.useContext = None\n        ' The context that the content is intended to support.\\n        List of `UsageContext` items (represented as `dict` in JSON). '\n        self.version = None\n        ' Business version of the questionnaire.\\n        Type `str`. '\n        super(Questionnaire, self).__init__(jsondict=jsondict, strict=strict)",
        "docstring": "Initialize a Questionnaire instance.\n\nThis constructor initializes a Questionnaire object that represents a structured set of questions designed to guide data collection from users. The attributes of the Questionnaire class, which correlate with the properties defined in the FHIR Questionnaire specification, are set to None or to values provided in the optional jsondict argument. This allows instantiation with specific data if available.\n\nParameters:\n- jsondict (dict, optional): A dictionary containing data to initialize the Questionnaire attributes. If provided, the values will be parsed and assigned to the corresponding class attributes.\n- strict (bool, optional): If True (default), the constructor raises a TypeError on encountering invalid variables during initialization; if False, it silently ignores them.\n\nAttributes:\n- approvalDate: Date when the questionnaire was approved (FHIRDate type).\n- code: Concept representing the overall questionnaire (list of Coding items).\n- contact: Publisher's contact details (list of ContactDetail items).\n- copyright: Publishing restrictions (string).\n- date: Last modified date (FHIRDateTime type).\n- derivedFrom: References to existing protocols or definitions (list of strings).\n- description: Natural language description of the questionnaire (string).\n- effectivePeriod: Expected usage timeframe for the questionnaire (Period type).\n- experimental: Indicator for testing purposes (boolean).\n- identifier: Additional identifiers for the questionnaire (list of Identifier items).\n- item: Questions and sections within the questionnaire (list of QuestionnaireItem items).\n- jurisdiction: Intended jurisdiction (list of CodeableConcept items).\n- lastReviewDate: Date when the questionnaire was last reviewed (FHIRDate type).\n- name: Computer-friendly name for the questionnaire (string).\n- publisher: Name of the publisher (string).\n- purpose: Purpose of the questionnaire (string).\n- status: Current status (string from a predefined set of values).\n- subjectType: Resource types applicable to QuestionnaireResponse (list of strings).\n- title: Human-friendly name for the questionnaire (string).\n- url: Canonical URI identifier for the questionnaire (string).\n- useContext: Context intended to support the questionnaire (list of UsageContext items).\n- version: Business version of the questionnaire (string).\n\nThe method relies on attributes defined in the FHIR standard for health information exchange and any related classes (e.g., FHIRDate, Coding) to be correctly implemented for proper functioning.",
        "signature": "def __init__(self, jsondict=None, strict=True):",
        "type": "Method",
        "class_signature": "class Questionnaire(domainresource.DomainResource):"
      }
    },
    "fhirclient/models/fhirabstractresource.py": {
      "FHIRAbstractResource.origin_server": {
        "code": "    def origin_server(self, server):\n        \"\"\"Sets the server associated with this FHIR resource instance.\n\n:param server: An instance of a FHIR server, which will be stored in the private attribute `_server`. This server is used to facilitate communication and interactions with the FHIR API.\n:returns: None. \nThis setter method updates the `_server` attribute, allowing the instance to track which server it operates with, thereby enabling functions such as reading, creating, updating, or deleting resources on the specified server.\"\"\"\n        ' Sets the server on an element. '\n        self._server = server",
        "docstring": "Sets the server associated with this FHIR resource instance.\n\n:param server: An instance of a FHIR server, which will be stored in the private attribute `_server`. This server is used to facilitate communication and interactions with the FHIR API.\n:returns: None. \nThis setter method updates the `_server` attribute, allowing the instance to track which server it operates with, thereby enabling functions such as reading, creating, updating, or deleting resources on the specified server.",
        "signature": "def origin_server(self, server):",
        "type": "Method",
        "class_signature": "class FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):"
      },
      "FHIRAbstractResource.read_from": {
        "code": "    def read_from(cls, path, server):\n        \"\"\"Requests data from a given REST path on a FHIR server and creates an instance of the calling class based on the retrieved data.\n\n:param str path: The REST path to request data from, which must represent the specific resource type with its identifier.\n:param FHIRServer server: An instance of a FHIR server or a compatible class that facilitates the request.\n\n:raises Exception: Raises an exception if the `path` is not provided or if the `server` instance is `None`. \n\n:returns: An instance of the calling class initialized with the retrieved JSON data, with the server reference set to `origin_server`.\n\nThe method interacts with the `request_json` method of the `FHIRServer` class to retrieve data from the server. The `jsondict` passed to the class constructor is derived from the response received from the server.\"\"\"\n        ' Requests data from the given REST path on the server and creates\\n        an instance of the receiving class.\\n        \\n        :param str path: The REST path to read from\\n        :param FHIRServer server: An instance of a FHIR server or compatible class\\n        :returns: An instance of the receiving class\\n        '\n        if not path:\n            raise Exception('Cannot read resource without REST path')\n        if server is None:\n            raise Exception('Cannot read resource without server instance')\n        ret = server.request_json(path)\n        instance = cls(jsondict=ret)\n        instance.origin_server = server\n        return instance",
        "docstring": "Requests data from a given REST path on a FHIR server and creates an instance of the calling class based on the retrieved data.\n\n:param str path: The REST path to request data from, which must represent the specific resource type with its identifier.\n:param FHIRServer server: An instance of a FHIR server or a compatible class that facilitates the request.\n\n:raises Exception: Raises an exception if the `path` is not provided or if the `server` instance is `None`. \n\n:returns: An instance of the calling class initialized with the retrieved JSON data, with the server reference set to `origin_server`.\n\nThe method interacts with the `request_json` method of the `FHIRServer` class to retrieve data from the server. The `jsondict` passed to the class constructor is derived from the response received from the server.",
        "signature": "def read_from(cls, path, server):",
        "type": "Method",
        "class_signature": "class FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):"
      }
    },
    "fhirclient/models/fhirreference.py": {
      "FHIRReference.resolved": {
        "code": "    def resolved(self, klass):\n        \"\"\"Resolves a FHIR reference to the corresponding resource instance and caches the result, allowing for efficient lookups on subsequent calls.\n\nParameters:\n- klass: The expected class of the resource that the reference should resolve to. This is critical for type checking against the resolved resource.\n\nReturns:\n- An instance of the resolved reference if dereferencing is successful and the resource matches the expected class; returns `None` otherwise.\n\nRaises:\n- Exception if the owning resource is not found or if `klass` is not provided.\n- Logs warnings if no reference is set, if a cached resolution does not match the expected class, if a contained resource does not match, or if resolving from a bundle fails.\n\nInteractions:\n- Utilizes `owningResource()`, `processedReferenceIdentifier()`, and `resolvedReference(refid)` methods to access resource context and manage reference identifying.\n- Involves iteration over contained resources and entries in a bundle if the reference has not been previously resolved.\n- Fetches resources via a server when referencing remote resources, using `klass.read_from()` for retrieval of the resource by reference.\"\"\"\n        ' Resolves the reference and caches the result, returning instance(s)\\n        of the referenced classes.\\n        \\n        :param klass: The expected class of the resource\\n        :returns: An instance (or list thereof) of the resolved reference if\\n            dereferencing was successful, `None` otherwise\\n        '\n        owning_resource = self.owningResource()\n        if owning_resource is None:\n            raise Exception('Cannot resolve reference without having an owner (which must be a `DomainResource`)')\n        if klass is None:\n            raise Exception('Cannot resolve reference without knowing the class')\n        refid = self.processedReferenceIdentifier()\n        if not refid:\n            logger.warning('No `reference` set, cannot resolve')\n            return None\n        resolved = owning_resource.resolvedReference(refid)\n        if resolved is not None:\n            if isinstance(resolved, klass):\n                return resolved\n            logger.warning('Referenced resource {} is not a {} but a {}'.format(refid, klass, resolved.__class__))\n            return None\n        if owning_resource.contained is not None:\n            for contained in owning_resource.contained:\n                if contained.id == refid:\n                    owning_resource.didResolveReference(refid, contained)\n                    if isinstance(contained, klass):\n                        return contained\n                    logger.warning('Contained resource {} is not a {} but a {}'.format(refid, klass, contained.__class__))\n                    return None\n        ref_is_relative = '://' not in self.reference and 'urn:' != self.reference[:4]\n        bundle = self.owningBundle()\n        while bundle is not None:\n            if bundle.entry is not None:\n                fullUrl = self.reference\n                if ref_is_relative:\n                    base = bundle.origin_server.base_uri if bundle.origin_server else ''\n                    fullUrl = base + self.reference\n                for entry in bundle.entry:\n                    if entry.fullUrl == fullUrl:\n                        found = entry.resource\n                        if isinstance(found, klass):\n                            return found\n                        logger.warning('Bundled resource {} is not a {} but a {}'.format(refid, klass, found.__class__))\n                        return None\n            bundle = bundle.owningBundle()\n        server = None\n        if ref_is_relative:\n            server = owning_resource.origin_server if owning_resource else None\n        if server is None:\n            logger.warning('Not implemented: resolving absolute reference to resource {}'.format(self.reference))\n            return None\n        relative = klass.read_from(self.reference, server)\n        owning_resource.didResolveReference(refid, relative)\n        return relative",
        "docstring": "Resolves a FHIR reference to the corresponding resource instance and caches the result, allowing for efficient lookups on subsequent calls.\n\nParameters:\n- klass: The expected class of the resource that the reference should resolve to. This is critical for type checking against the resolved resource.\n\nReturns:\n- An instance of the resolved reference if dereferencing is successful and the resource matches the expected class; returns `None` otherwise.\n\nRaises:\n- Exception if the owning resource is not found or if `klass` is not provided.\n- Logs warnings if no reference is set, if a cached resolution does not match the expected class, if a contained resource does not match, or if resolving from a bundle fails.\n\nInteractions:\n- Utilizes `owningResource()`, `processedReferenceIdentifier()`, and `resolvedReference(refid)` methods to access resource context and manage reference identifying.\n- Involves iteration over contained resources and entries in a bundle if the reference has not been previously resolved.\n- Fetches resources via a server when referencing remote resources, using `klass.read_from()` for retrieval of the resource by reference.",
        "signature": "def resolved(self, klass):",
        "type": "Method",
        "class_signature": "class FHIRReference(reference.Reference):"
      },
      "FHIRReference.processedReferenceIdentifier": {
        "code": "    def processedReferenceIdentifier(self):\n        \"\"\"Normalizes the reference identifier by removing the leading '#' character if present. This method is used to prepare the reference for further processing within the `FHIRReference` class, specifically in scenarios where the reference may represent an internal fragment within a resource.\n\n    Returns:\n        str: The processed reference identifier, which can be either the original reference or the normalized version without the leading '#'.\n\n    Dependencies:\n        - `self.reference`: An attribute of the `FHIRReference` class that holds the raw reference string used for normalization.\"\"\"\n        ' Normalizes the reference-id.\\n        '\n        if self.reference and '#' == self.reference[0]:\n            return self.reference[1:]\n        return self.reference",
        "docstring": "Normalizes the reference identifier by removing the leading '#' character if present. This method is used to prepare the reference for further processing within the `FHIRReference` class, specifically in scenarios where the reference may represent an internal fragment within a resource.\n\nReturns:\n    str: The processed reference identifier, which can be either the original reference or the normalized version without the leading '#'.\n\nDependencies:\n    - `self.reference`: An attribute of the `FHIRReference` class that holds the raw reference string used for normalization.",
        "signature": "def processedReferenceIdentifier(self):",
        "type": "Method",
        "class_signature": "class FHIRReference(reference.Reference):"
      }
    },
    "fhirclient/server.py": {
      "FHIRServer.__init__": {
        "code": "    def __init__(self, client, base_uri=None, state=None):\n        \"\"\"Initializes a new instance of the FHIRServer class, which is responsible for communicating with a FHIR (Fast Healthcare Interoperability Resources) server.\n\nParameters:\n- client: An instance of a client that contains authentication and configuration details.\n- base_uri (str, optional): The base URI for the FHIR server. If provided and valid, this will be used to construct request URLs.\n- state (dict, optional): A state dictionary that can initialize the server's attributes, particularly the base URI and authentication details.\n\nRaises:\n- Exception: If neither the base_uri nor a valid state containing the base URI is provided.\n\nAttributes:\n- client: Holds the client instance for managing requests and authentication.\n- auth: Will eventually hold an instance of FHIRAuth, initialized based on the server's capability statement.\n- base_uri: A properly formatted URI for the FHIR server, ensured to end with a '/'.\n- aud: Holds the base URI for use in authentication.\n- session: A requests.Session object used to maintain connection settings and parameters across requests.\n- _capability: Stores the server's CapabilityStatement after it is retrieved.\n\nConstants:\n- None directly within the __init__ method, but indirectly relies on other constants and classes (e.g., FHIRAuth) from the context for functionality.\"\"\"\n        self.client = client\n        self.auth = None\n        self.base_uri = None\n        self.aud = None\n        self.session = requests.Session()\n        if base_uri is not None and len(base_uri) > 10:\n            self.base_uri = base_uri if '/' == base_uri[-1] else base_uri + '/'\n            self.aud = base_uri\n        self._capability = None\n        if state is not None:\n            self.from_state(state)\n        if not self.base_uri or len(self.base_uri) <= 10:\n            raise Exception('FHIRServer must be initialized with `base_uri` or `state` containing the base-URI, but neither happened')",
        "docstring": "Initializes a new instance of the FHIRServer class, which is responsible for communicating with a FHIR (Fast Healthcare Interoperability Resources) server.\n\nParameters:\n- client: An instance of a client that contains authentication and configuration details.\n- base_uri (str, optional): The base URI for the FHIR server. If provided and valid, this will be used to construct request URLs.\n- state (dict, optional): A state dictionary that can initialize the server's attributes, particularly the base URI and authentication details.\n\nRaises:\n- Exception: If neither the base_uri nor a valid state containing the base URI is provided.\n\nAttributes:\n- client: Holds the client instance for managing requests and authentication.\n- auth: Will eventually hold an instance of FHIRAuth, initialized based on the server's capability statement.\n- base_uri: A properly formatted URI for the FHIR server, ensured to end with a '/'.\n- aud: Holds the base URI for use in authentication.\n- session: A requests.Session object used to maintain connection settings and parameters across requests.\n- _capability: Stores the server's CapabilityStatement after it is retrieved.\n\nConstants:\n- None directly within the __init__ method, but indirectly relies on other constants and classes (e.g., FHIRAuth) from the context for functionality.",
        "signature": "def __init__(self, client, base_uri=None, state=None):",
        "type": "Method",
        "class_signature": "class FHIRServer(object):"
      }
    },
    "fhirclient/models/domainresource.py": {
      "DomainResource.__init__": {
        "code": "    def __init__(self, jsondict=None, strict=True):\n        \"\"\"Initialize a DomainResource, which is a type of FHIR resource that includes narrative content, extensions, and contained resources.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary to initialize the resource's properties. If provided, it populates the attributes defined in the resource.\n- strict (bool, optional): If True (default), invalid properties in jsondict will raise a FHIRValidationError. If False, such validation errors will be ignored.\n\nAttributes:\n- contained (list): A list of contained resources (of type Resource) represented as dictionaries in JSON.\n- extension (list): A list of additional content elements defined by implementations (of type Extension) represented as dictionaries in JSON.\n- modifierExtension (list): A list of extensions that are critical and cannot be ignored (of type Extension) represented as dictionaries in JSON.\n- text (Narrative, optional): A summary text of the resource intended for human interpretation.\n\nThis class inherits from `resource.Resource`, and its initialization includes invoking the parent class's constructor for setting up any inherited properties.\"\"\"\n        ' Initialize all valid properties.\\n        \\n        :raises: FHIRValidationError on validation errors, unless strict is False\\n        :param dict jsondict: A JSON dictionary to use for initialization\\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\\n        '\n        self.contained = None\n        ' Contained, inline Resources.\\n        List of `Resource` items (represented as `dict` in JSON). '\n        self.extension = None\n        ' Additional content defined by implementations.\\n        List of `Extension` items (represented as `dict` in JSON). '\n        self.modifierExtension = None\n        ' Extensions that cannot be ignored.\\n        List of `Extension` items (represented as `dict` in JSON). '\n        self.text = None\n        ' Text summary of the resource, for human interpretation.\\n        Type `Narrative` (represented as `dict` in JSON). '\n        super(DomainResource, self).__init__(jsondict=jsondict, strict=strict)",
        "docstring": "Initialize a DomainResource, which is a type of FHIR resource that includes narrative content, extensions, and contained resources.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary to initialize the resource's properties. If provided, it populates the attributes defined in the resource.\n- strict (bool, optional): If True (default), invalid properties in jsondict will raise a FHIRValidationError. If False, such validation errors will be ignored.\n\nAttributes:\n- contained (list): A list of contained resources (of type Resource) represented as dictionaries in JSON.\n- extension (list): A list of additional content elements defined by implementations (of type Extension) represented as dictionaries in JSON.\n- modifierExtension (list): A list of extensions that are critical and cannot be ignored (of type Extension) represented as dictionaries in JSON.\n- text (Narrative, optional): A summary text of the resource intended for human interpretation.\n\nThis class inherits from `resource.Resource`, and its initialization includes invoking the parent class's constructor for setting up any inherited properties.",
        "signature": "def __init__(self, jsondict=None, strict=True):",
        "type": "Method",
        "class_signature": "class DomainResource(resource.Resource):"
      }
    },
    "fhirclient/models/resource.py": {
      "Resource.__init__": {
        "code": "    def __init__(self, jsondict=None, strict=True):\n        \"\"\"Initialize a Resource object, which serves as the base type for all FHIR resources. The constructor sets up valid properties including `id`, `implicitRules`, `language`, and `meta`, initializing them to None. \n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing properties of the resource.\n- strict (bool, optional): If True (default), invalid variables will raise a TypeError, ensuring strict adherence to FHIR specifications.\n\nThis method also calls the initializer of the parent class, FHIRAbstractResource, allowing it to handle any additional initialization or validation processes.\n\nAttributes:\n- `id` (str): A logical identifier for the resource.\n- `implicitRules` (str): A set of rules that govern how the content was created.\n- `language` (str): The language in which the resource content is written.\n- `meta` (Meta): Metadata associated with the resource.\n\nDependencies:\n- Imports `fhirabstractresource` for base functionality and `meta` for the Meta type used in initialization.\"\"\"\n        ' Initialize all valid properties.\\n        \\n        :raises: FHIRValidationError on validation errors, unless strict is False\\n        :param dict jsondict: A JSON dictionary to use for initialization\\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\\n        '\n        self.id = None\n        ' Logical id of this artifact.\\n        Type `str`. '\n        self.implicitRules = None\n        ' A set of rules under which this content was created.\\n        Type `str`. '\n        self.language = None\n        ' Language of the resource content.\\n        Type `str`. '\n        self.meta = None\n        ' Metadata about the resource.\\n        Type `Meta` (represented as `dict` in JSON). '\n        super(Resource, self).__init__(jsondict=jsondict, strict=strict)",
        "docstring": "Initialize a Resource object, which serves as the base type for all FHIR resources. The constructor sets up valid properties including `id`, `implicitRules`, `language`, and `meta`, initializing them to None. \n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing properties of the resource.\n- strict (bool, optional): If True (default), invalid variables will raise a TypeError, ensuring strict adherence to FHIR specifications.\n\nThis method also calls the initializer of the parent class, FHIRAbstractResource, allowing it to handle any additional initialization or validation processes.\n\nAttributes:\n- `id` (str): A logical identifier for the resource.\n- `implicitRules` (str): A set of rules that govern how the content was created.\n- `language` (str): The language in which the resource content is written.\n- `meta` (Meta): Metadata associated with the resource.\n\nDependencies:\n- Imports `fhirabstractresource` for base functionality and `meta` for the Meta type used in initialization.",
        "signature": "def __init__(self, jsondict=None, strict=True):",
        "type": "Method",
        "class_signature": "class Resource(fhirabstractresource.FHIRAbstractResource):"
      }
    }
  },
  "dependency_dict": {
    "fhirclient/models/bundle.py:Bundle:__init__": {},
    "fhirclient/models/resource.py:Resource:__init__": {
      "fhirclient/models/fhirabstractresource.py": {
        "FHIRAbstractResource.__init__": {
          "code": "    def __init__(self, jsondict=None, strict=True):\n        self._server = None\n        ' The server the instance was read from. '\n        if jsondict is not None and 'resourceType' in jsondict and (jsondict['resourceType'] != self.resource_type):\n            raise Exception('Attempting to instantiate {} with resource data that defines a resourceType of \"{}\"'.format(self.__class__, jsondict['resourceType']))\n        super(FHIRAbstractResource, self).__init__(jsondict=jsondict, strict=strict)",
          "docstring": "",
          "signature": "def __init__(self, jsondict=None, strict=True):",
          "type": "Method",
          "class_signature": "class FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):"
        }
      }
    },
    "fhirclient/models/fhirreference.py:FHIRReference:resolved": {},
    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningResource": {},
    "fhirclient/models/fhirreference.py:FHIRReference:processedReferenceIdentifier": {},
    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:resolvedReference": {},
    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningBundle": {},
    "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:origin_server": {},
    "fhirclient/models/questionnaire.py:Questionnaire:__init__": {},
    "fhirclient/models/domainresource.py:DomainResource:__init__": {},
    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:didResolveReference": {},
    "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:read_from": {
      "fhirclient/models/valueset.py": {
        "ValueSet.__init__": {
          "code": "    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        \n        self.compose = None\n        \"\"\" Content logical definition of the value set (CLD).\n        Type `ValueSetCompose` (represented as `dict` in JSON). \"\"\"\n        \n        self.contact = None\n        \"\"\" Contact details for the publisher.\n        List of `ContactDetail` items (represented as `dict` in JSON). \"\"\"\n        \n        self.copyright = None\n        \"\"\" Use and/or publishing restrictions.\n        Type `str`. \"\"\"\n        \n        self.date = None\n        \"\"\" Date last changed.\n        Type `FHIRDateTime` (represented as `str` in JSON). \"\"\"\n        \n        self.description = None\n        \"\"\" Natural language description of the value set.\n        Type `str`. \"\"\"\n        \n        self.expansion = None\n        \"\"\" Used when the value set is \"expanded\".\n        Type `ValueSetExpansion` (represented as `dict` in JSON). \"\"\"\n        \n        self.experimental = None\n        \"\"\" For testing purposes, not real usage.\n        Type `bool`. \"\"\"\n        \n        self.identifier = None\n        \"\"\" Additional identifier for the value set (business identifier).\n        List of `Identifier` items (represented as `dict` in JSON). \"\"\"\n        \n        self.immutable = None\n        \"\"\" Indicates whether or not any change to the content logical\n        definition may occur.\n        Type `bool`. \"\"\"\n        \n        self.jurisdiction = None\n        \"\"\" Intended jurisdiction for value set (if applicable).\n        List of `CodeableConcept` items (represented as `dict` in JSON). \"\"\"\n        \n        self.name = None\n        \"\"\" Name for this value set (computer friendly).\n        Type `str`. \"\"\"\n        \n        self.publisher = None\n        \"\"\" Name of the publisher (organization or individual).\n        Type `str`. \"\"\"\n        \n        self.purpose = None\n        \"\"\" Why this value set is defined.\n        Type `str`. \"\"\"\n        \n        self.status = None\n        \"\"\" draft | active | retired | unknown.\n        Type `str`. \"\"\"\n        \n        self.title = None\n        \"\"\" Name for this value set (human friendly).\n        Type `str`. \"\"\"\n        \n        self.url = None\n        \"\"\" Canonical identifier for this value set, represented as a URI\n        (globally unique).\n        Type `str`. \"\"\"\n        \n        self.useContext = None\n        \"\"\" The context that the content is intended to support.\n        List of `UsageContext` items (represented as `dict` in JSON). \"\"\"\n        \n        self.version = None\n        \"\"\" Business version of the value set.\n        Type `str`. \"\"\"\n        \n        super(ValueSet, self).__init__(jsondict=jsondict, strict=strict)",
          "docstring": "Initialize all valid properties.\n\n:raises: FHIRValidationError on validation errors, unless strict is False\n:param dict jsondict: A JSON dictionary to use for initialization\n:param bool strict: If True (the default), invalid variables will raise a TypeError",
          "signature": "def __init__(self, jsondict=None, strict=True):",
          "type": "Method",
          "class_signature": "class ValueSet(domainresource.DomainResource):"
        }
      },
      "tests/fhirreference_test.py": {
        "MockServer.request_json": {
          "code": "    def request_json(self, path, nosign=False):\n        assert path\n        datadir = os.path.join(os.path.dirname(__file__), 'data')\n        parts = os.path.split(path)\n        filename = os.path.join(datadir, '_'.join(parts) + '.json')\n        with io.open(filename, 'r', encoding='utf-8') as handle:\n            return json.load(handle)",
          "docstring": "",
          "signature": "def request_json(self, path, nosign=False):",
          "type": "Method",
          "class_signature": "class MockServer(server.FHIRServer):"
        }
      }
    }
  },
  "call_tree": {
    "tests/fhirreference_test.py:TestResourceReference:testBundleReferences": {
      "tests/fhirreference_test.py:TestResourceReference:get_testfile": {},
      "fhirclient/models/bundle.py:Bundle:__init__": {
        "fhirclient/models/resource.py:Resource:__init__": {
          "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:__init__": {
            "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:__init__": {
              "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:update_with_json": {
                "fhirclient/models/fhirabstractbase.py:FHIRValidationError:FHIRValidationError": {},
                "fhirclient/models/bundle.py:Bundle:elementProperties": {
                  "fhirclient/models/resource.py:Resource:elementProperties": {
                    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:elementProperties": {}
                  }
                },
                "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json_and_owner": {
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json": {
                    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_with_json_dict": {
                      "fhirclient/models/bundle.py:BundleEntry:__init__": {}
                    }
                  }
                },
                "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_matches_type": {}
              }
            }
          }
        }
      },
      "fhirclient/models/fhirreference.py:FHIRReference:resolved": {
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningResource": {},
        "fhirclient/models/fhirreference.py:FHIRReference:processedReferenceIdentifier": {},
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:resolvedReference": {
          "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:resolvedReference": {
            "[ignored_or_cut_off]": "..."
          }
        },
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningBundle": {},
        "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:origin_server": {}
      },
      "tests/fhirreference_test.py:MockServer:__init__": {
        "fhirclient/server.py:FHIRServer:__init__": {}
      }
    },
    "tests/fhirreference_test.py:TestResourceReference:testContainedResourceDetection": {
      "tests/fhirreference_test.py:TestResourceReference:get_testfile": {},
      "fhirclient/models/questionnaire.py:Questionnaire:__init__": {
        "fhirclient/models/domainresource.py:DomainResource:__init__": {
          "fhirclient/models/resource.py:Resource:__init__": {
            "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:__init__": {
              "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:__init__": {
                "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:update_with_json": {
                  "fhirclient/models/questionnaire.py:Questionnaire:elementProperties": {
                    "fhirclient/models/domainresource.py:DomainResource:elementProperties": {
                      "fhirclient/models/resource.py:Resource:elementProperties": {}
                    }
                  },
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_matches_type": {},
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json_and_owner": {
                    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json": {
                      "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:_with_json_dict": {},
                      "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_with_json_dict": {}
                    }
                  },
                  "fhirclient/models/fhirdate.py:FHIRDate:with_json_and_owner": {
                    "fhirclient/models/fhirdate.py:FHIRDate:with_json": {
                      "fhirclient/models/fhirdatetime.py:FHIRDateTime:__init__": {}
                    }
                  }
                }
              }
            }
          }
        }
      },
      "fhirclient/models/fhirreference.py:FHIRReference:resolved": {
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningResource": {},
        "fhirclient/models/fhirreference.py:FHIRReference:processedReferenceIdentifier": {},
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:resolvedReference": {},
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:didResolveReference": {}
      }
    },
    "tests/fhirreference_test.py:TestResourceReference:testRelativeReference": {
      "tests/fhirreference_test.py:TestResourceReference:get_testfile": {},
      "fhirclient/models/questionnaire.py:Questionnaire:__init__": {
        "fhirclient/models/domainresource.py:DomainResource:__init__": {
          "fhirclient/models/resource.py:Resource:__init__": {
            "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:__init__": {
              "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:__init__": {
                "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:update_with_json": {
                  "fhirclient/models/questionnaire.py:Questionnaire:elementProperties": {
                    "fhirclient/models/domainresource.py:DomainResource:elementProperties": {
                      "fhirclient/models/resource.py:Resource:elementProperties": {}
                    }
                  },
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_matches_type": {},
                  "fhirclient/models/fhirdate.py:FHIRDate:with_json_and_owner": {
                    "fhirclient/models/fhirdate.py:FHIRDate:with_json": {
                      "fhirclient/models/fhirdatetime.py:FHIRDateTime:__init__": {}
                    }
                  },
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json_and_owner": {
                    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json": {
                      "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_with_json_dict": {}
                    }
                  }
                }
              }
            }
          }
        }
      },
      "tests/fhirreference_test.py:MockServer:__init__": {
        "fhirclient/server.py:FHIRServer:__init__": {}
      },
      "fhirclient/models/fhirreference.py:FHIRReference:resolved": {
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningResource": {},
        "fhirclient/models/fhirreference.py:FHIRReference:processedReferenceIdentifier": {},
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:resolvedReference": {},
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:owningBundle": {},
        "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:origin_server": {},
        "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:read_from": {
          "tests/fhirreference_test.py:MockServer:request_json": {},
          "fhirclient/models/valueset.py:ValueSet:__init__": {
            "fhirclient/models/domainresource.py:DomainResource:__init__": {
              "fhirclient/models/resource.py:Resource:__init__": {
                "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:__init__": {
                  "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:__init__": {
                    "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:update_with_json": {
                      "fhirclient/models/valueset.py:ValueSet:elementProperties": {},
                      "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:_matches_type": {},
                      "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:with_json_and_owner": {}
                    }
                  }
                }
              }
            }
          },
          "fhirclient/models/fhirabstractresource.py:FHIRAbstractResource:origin_server": {}
        },
        "fhirclient/models/fhirabstractbase.py:FHIRAbstractBase:didResolveReference": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: fhirclient-fhirreference_test\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 fhirclient/\n    \u251c\u2500\u2500 models/\n    \u2502   \u251c\u2500\u2500 bundle.py\n    \u2502   \u2502   \u2514\u2500\u2500 Bundle.__init__\n    \u2502   \u251c\u2500\u2500 domainresource.py\n    \u2502   \u2502   \u2514\u2500\u2500 DomainResource.__init__\n    \u2502   \u251c\u2500\u2500 fhirabstractbase.py\n    \u2502   \u2502   \u251c\u2500\u2500 FHIRAbstractBase.didResolveReference\n    \u2502   \u2502   \u251c\u2500\u2500 FHIRAbstractBase.owningBundle\n    \u2502   \u2502   \u251c\u2500\u2500 FHIRAbstractBase.owningResource\n    \u2502   \u2502   \u2514\u2500\u2500 FHIRAbstractBase.resolvedReference\n    \u2502   \u251c\u2500\u2500 fhirabstractresource.py\n    \u2502   \u2502   \u251c\u2500\u2500 FHIRAbstractResource.origin_server\n    \u2502   \u2502   \u2514\u2500\u2500 FHIRAbstractResource.read_from\n    \u2502   \u251c\u2500\u2500 fhirreference.py\n    \u2502   \u2502   \u251c\u2500\u2500 FHIRReference.processedReferenceIdentifier\n    \u2502   \u2502   \u2514\u2500\u2500 FHIRReference.resolved\n    \u2502   \u251c\u2500\u2500 questionnaire.py\n    \u2502   \u2502   \u2514\u2500\u2500 Questionnaire.__init__\n    \u2502   \u2514\u2500\u2500 resource.py\n    \u2502       \u2514\u2500\u2500 Resource.__init__\n    \u2514\u2500\u2500 server.py\n        \u2514\u2500\u2500 FHIRServer.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the resolution and validation of references within FHIR (Fast Healthcare Interoperability Resources) data structures, ensuring accurate linking and retrieval of contained, relative, and external resources. It provides functionality for handling complex FHIR resource types such as Questionnaires, ValueSets, Bundles, Medications, and Patients by resolving references to their associated resources, either from contained data or through a server interface. By supporting validation of resource types and caching resolved references, the module streamlines the process of managing relationships between interconnected FHIR resources. This improves data integrity and simplifies the handling of large, reference-laden FHIR data sets for developers working with healthcare interoperability solutions.\n\n## FILE 1: fhirclient/models/fhirabstractbase.py\n\n- CLASS METHOD: FHIRAbstractBase.didResolveReference\n  - CLASS SIGNATURE: class FHIRAbstractBase(object):\n  - SIGNATURE: def didResolveReference(self, refid, resolved):\n  - DOCSTRING: \n```python\n\"\"\"\nStores a resolved reference into the `_resolved` dictionary for later retrieval. This method is called when a reference (identified by `refid`) to a resource is successfully resolved to an actual resource (`resolved`).\n\nParameters:\n- refid (str): The identifier of the resource that has been resolved.\n- resolved (Resource): The actual resource instance that corresponds to the given `refid`, ready to be cached for future reference.\n\nThis method modifies the `_resolved` attribute, which is a dictionary that maps reference IDs to their resolved resource instances. If `_resolved` is `None`, it is initialized as a new dictionary. The `_resolved` attribute plays a crucial role in managing and retrieving resolved references in the context of FHIR resources, streamlining access to linked resources across the FHIR data model.\n\"\"\"\n```\n\n- CLASS METHOD: FHIRAbstractBase.owningResource\n  - CLASS SIGNATURE: class FHIRAbstractBase(object):\n  - SIGNATURE: def owningResource(self):\n  - DOCSTRING: \n```python\n\"\"\"\nWalks up the owner hierarchy starting from the current instance and returns the next parent that is an instance of `DomainResource`. This method utilizes the `_owner` attribute, which holds a reference to the parent resource. If the owner is not found or does not exist, it returns None. The presence of the `contained` attribute is used to identify `DomainResource` instances in the hierarchy, as parent resources typically have this attribute defined. \n\nReturns:\n    DomainResource or None: The first encountered parent that is a `DomainResource` instance, or None if no such parent exists.\n\"\"\"\n```\n\n- CLASS METHOD: FHIRAbstractBase.owningBundle\n  - CLASS SIGNATURE: class FHIRAbstractBase(object):\n  - SIGNATURE: def owningBundle(self):\n  - DOCSTRING: \n```python\n\"\"\"\nWalks the owner hierarchy of the current FHIR element instance and retrieves the nearest parent that is an instance of `Bundle`. \n\nThis method checks the `_owner` attribute, which points to the parent resource in the hierarchy. It iterates upwards through the owner chain until it finds a parent with a `resource_type` equal to 'Bundle' or until there are no more owners to check. \n\nReturns:\n    The nearest parent `Bundle` instance found. If no such parent exists, it returns `None`.\n\nDependencies:\n    - `self._owner`: A reference to the parent resource of the current instance.\n    - `owner.resource_type`: A property that denotes the type of the resource.\n\nThis method is crucial for contexts where resolving references or relationships to `Bundle` resources is necessary, such as in FHIR data processing.\n\"\"\"\n```\n\n- CLASS METHOD: FHIRAbstractBase.resolvedReference\n  - CLASS SIGNATURE: class FHIRAbstractBase(object):\n  - SIGNATURE: def resolvedReference(self, refid):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves a resolved reference resource by its identifier. If the reference has previously been resolved and stored in the `_resolved` dictionary, it is returned directly. If not, the method checks if the instance has an owner (the parent resource) and forwards the resolution request to the owner's `resolvedReference` method.\n\nParameters:\n- refid (str): The identifier of the resource to resolve.\n\nReturns:\n- An instance of `Resource` if found, or `None` if the reference is not resolved and there is no owner to forward the request to.\n\nSide Effects:\n- Relies on the `_resolved` dictionary, which is utilized to cache resolved references, enabling efficient lookups. If the instance does not have the reference cached, it checks its owner for the resolution.\n\"\"\"\n```\n\n## FILE 2: fhirclient/models/bundle.py\n\n- CLASS METHOD: Bundle.__init__\n  - CLASS SIGNATURE: class Bundle(resource.Resource):\n  - SIGNATURE: def __init__(self, jsondict=None, strict=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Bundle resource, which serves as a container for a collection of resources. This constructor sets up the necessary attributes for organizing entries, linking resources, and maintaining metadata about the bundle.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing the bundle's properties. If provided, it is parsed to populate the bundle's attributes.\n- strict (bool, default=True): When True, invalid variables will raise a TypeError, ensuring strict validation of the bundle's properties.\n\nAttributes:\n- entry (list): A list of entries in the bundle, each represented as `BundleEntry` items which may contain resources or associated information.\n- identifier (Identifier, optional): A persistent identifier for the bundle, represented as an `Identifier` object.\n- link (list): A list of `BundleLink` items, which provide links related to this bundle for navigation or context.\n- signature (Signature, optional): A digital signature for the bundle, represented as a `Signature` object to ensure integrity.\n- timestamp (FHIRInstant, optional): A timestamp indicating when the bundle was assembled, represented as a string in FHIR Instant format.\n- total (int, optional): The total number of matches if the bundle is the result of a search operation.\n- type (str, optional): A string indicating the type of the bundle, which can include 'document', 'message', 'transaction', and others as defined in the FHIR specification.\n\nThis constructor interacts with the parent class `Resource` to initialize any common resource properties and validates the bundle configuration based on the passed parameters.\n\"\"\"\n```\n\n## FILE 3: fhirclient/models/questionnaire.py\n\n- CLASS METHOD: Questionnaire.__init__\n  - CLASS SIGNATURE: class Questionnaire(domainresource.DomainResource):\n  - SIGNATURE: def __init__(self, jsondict=None, strict=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Questionnaire instance.\n\nThis constructor initializes a Questionnaire object that represents a structured set of questions designed to guide data collection from users. The attributes of the Questionnaire class, which correlate with the properties defined in the FHIR Questionnaire specification, are set to None or to values provided in the optional jsondict argument. This allows instantiation with specific data if available.\n\nParameters:\n- jsondict (dict, optional): A dictionary containing data to initialize the Questionnaire attributes. If provided, the values will be parsed and assigned to the corresponding class attributes.\n- strict (bool, optional): If True (default), the constructor raises a TypeError on encountering invalid variables during initialization; if False, it silently ignores them.\n\nAttributes:\n- approvalDate: Date when the questionnaire was approved (FHIRDate type).\n- code: Concept representing the overall questionnaire (list of Coding items).\n- contact: Publisher's contact details (list of ContactDetail items).\n- copyright: Publishing restrictions (string).\n- date: Last modified date (FHIRDateTime type).\n- derivedFrom: References to existing protocols or definitions (list of strings).\n- description: Natural language description of the questionnaire (string).\n- effectivePeriod: Expected usage timeframe for the questionnaire (Period type).\n- experimental: Indicator for testing purposes (boolean).\n- identifier: Additional identifiers for the questionnaire (list of Identifier items).\n- item: Questions and sections within the questionnaire (list of QuestionnaireItem items).\n- jurisdiction: Intended jurisdiction (list of CodeableConcept items).\n- lastReviewDate: Date when the questionnaire was last reviewed (FHIRDate type).\n- name: Computer-friendly name for the questionnaire (string).\n- publisher: Name of the publisher (string).\n- purpose: Purpose of the questionnaire (string).\n- status: Current status (string from a predefined set of values).\n- subjectType: Resource types applicable to QuestionnaireResponse (list of strings).\n- title: Human-friendly name for the questionnaire (string).\n- url: Canonical URI identifier for the questionnaire (string).\n- useContext: Context intended to support the questionnaire (list of UsageContext items).\n- version: Business version of the questionnaire (string).\n\nThe method relies on attributes defined in the FHIR standard for health information exchange and any related classes (e.g., FHIRDate, Coding) to be correctly implemented for proper functioning.\n\"\"\"\n```\n\n## FILE 4: fhirclient/models/fhirabstractresource.py\n\n- CLASS METHOD: FHIRAbstractResource.read_from\n  - CLASS SIGNATURE: class FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):\n  - SIGNATURE: def read_from(cls, path, server):\n  - DOCSTRING: \n```python\n\"\"\"\nRequests data from a given REST path on a FHIR server and creates an instance of the calling class based on the retrieved data.\n\n:param str path: The REST path to request data from, which must represent the specific resource type with its identifier.\n:param FHIRServer server: An instance of a FHIR server or a compatible class that facilitates the request.\n\n:raises Exception: Raises an exception if the `path` is not provided or if the `server` instance is `None`. \n\n:returns: An instance of the calling class initialized with the retrieved JSON data, with the server reference set to `origin_server`.\n\nThe method interacts with the `request_json` method of the `FHIRServer` class to retrieve data from the server. The `jsondict` passed to the class constructor is derived from the response received from the server.\n\"\"\"\n```\n\n- CLASS METHOD: FHIRAbstractResource.origin_server\n  - CLASS SIGNATURE: class FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):\n  - SIGNATURE: def origin_server(self, server):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the server associated with this FHIR resource instance.\n\n:param server: An instance of a FHIR server, which will be stored in the private attribute `_server`. This server is used to facilitate communication and interactions with the FHIR API.\n:returns: None. \nThis setter method updates the `_server` attribute, allowing the instance to track which server it operates with, thereby enabling functions such as reading, creating, updating, or deleting resources on the specified server.\n\"\"\"\n```\n\n## FILE 5: fhirclient/models/fhirreference.py\n\n- CLASS METHOD: FHIRReference.processedReferenceIdentifier\n  - CLASS SIGNATURE: class FHIRReference(reference.Reference):\n  - SIGNATURE: def processedReferenceIdentifier(self):\n  - DOCSTRING: \n```python\n\"\"\"\nNormalizes the reference identifier by removing the leading '#' character if present. This method is used to prepare the reference for further processing within the `FHIRReference` class, specifically in scenarios where the reference may represent an internal fragment within a resource.\n\nReturns:\n    str: The processed reference identifier, which can be either the original reference or the normalized version without the leading '#'.\n\nDependencies:\n    - `self.reference`: An attribute of the `FHIRReference` class that holds the raw reference string used for normalization.\n\"\"\"\n```\n\n- CLASS METHOD: FHIRReference.resolved\n  - CLASS SIGNATURE: class FHIRReference(reference.Reference):\n  - SIGNATURE: def resolved(self, klass):\n  - DOCSTRING: \n```python\n\"\"\"\nResolves a FHIR reference to the corresponding resource instance and caches the result, allowing for efficient lookups on subsequent calls.\n\nParameters:\n- klass: The expected class of the resource that the reference should resolve to. This is critical for type checking against the resolved resource.\n\nReturns:\n- An instance of the resolved reference if dereferencing is successful and the resource matches the expected class; returns `None` otherwise.\n\nRaises:\n- Exception if the owning resource is not found or if `klass` is not provided.\n- Logs warnings if no reference is set, if a cached resolution does not match the expected class, if a contained resource does not match, or if resolving from a bundle fails.\n\nInteractions:\n- Utilizes `owningResource()`, `processedReferenceIdentifier()`, and `resolvedReference(refid)` methods to access resource context and manage reference identifying.\n- Involves iteration over contained resources and entries in a bundle if the reference has not been previously resolved.\n- Fetches resources via a server when referencing remote resources, using `klass.read_from()` for retrieval of the resource by reference.\n\"\"\"\n```\n\n## FILE 6: fhirclient/server.py\n\n- CLASS METHOD: FHIRServer.__init__\n  - CLASS SIGNATURE: class FHIRServer(object):\n  - SIGNATURE: def __init__(self, client, base_uri=None, state=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the FHIRServer class, which is responsible for communicating with a FHIR (Fast Healthcare Interoperability Resources) server.\n\nParameters:\n- client: An instance of a client that contains authentication and configuration details.\n- base_uri (str, optional): The base URI for the FHIR server. If provided and valid, this will be used to construct request URLs.\n- state (dict, optional): A state dictionary that can initialize the server's attributes, particularly the base URI and authentication details.\n\nRaises:\n- Exception: If neither the base_uri nor a valid state containing the base URI is provided.\n\nAttributes:\n- client: Holds the client instance for managing requests and authentication.\n- auth: Will eventually hold an instance of FHIRAuth, initialized based on the server's capability statement.\n- base_uri: A properly formatted URI for the FHIR server, ensured to end with a '/'.\n- aud: Holds the base URI for use in authentication.\n- session: A requests.Session object used to maintain connection settings and parameters across requests.\n- _capability: Stores the server's CapabilityStatement after it is retrieved.\n\nConstants:\n- None directly within the __init__ method, but indirectly relies on other constants and classes (e.g., FHIRAuth) from the context for functionality.\n\"\"\"\n```\n\n## FILE 7: fhirclient/models/domainresource.py\n\n- CLASS METHOD: DomainResource.__init__\n  - CLASS SIGNATURE: class DomainResource(resource.Resource):\n  - SIGNATURE: def __init__(self, jsondict=None, strict=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a DomainResource, which is a type of FHIR resource that includes narrative content, extensions, and contained resources.\n\nParameters:\n- jsondict (dict, optional): A JSON dictionary to initialize the resource's properties. If provided, it populates the attributes defined in the resource.\n- strict (bool, optional): If True (default), invalid properties in jsondict will raise a FHIRValidationError. If False, such validation errors will be ignored.\n\nAttributes:\n- contained (list): A list of contained resources (of type Resource) represented as dictionaries in JSON.\n- extension (list): A list of additional content elements defined by implementations (of type Extension) represented as dictionaries in JSON.\n- modifierExtension (list): A list of extensions that are critical and cannot be ignored (of type Extension) represented as dictionaries in JSON.\n- text (Narrative, optional): A summary text of the resource intended for human interpretation.\n\nThis class inherits from `resource.Resource`, and its initialization includes invoking the parent class's constructor for setting up any inherited properties.\n\"\"\"\n```\n\n## FILE 8: fhirclient/models/resource.py\n\n- CLASS METHOD: Resource.__init__\n  - CLASS SIGNATURE: class Resource(fhirabstractresource.FHIRAbstractResource):\n  - SIGNATURE: def __init__(self, jsondict=None, strict=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Resource object, which serves as the base type for all FHIR resources. The constructor sets up valid properties including `id`, `implicitRules`, `language`, and `meta`, initializing them to None. \n\nParameters:\n- jsondict (dict, optional): A JSON dictionary used for initializing properties of the resource.\n- strict (bool, optional): If True (default), invalid variables will raise a TypeError, ensuring strict adherence to FHIR specifications.\n\nThis method also calls the initializer of the parent class, FHIRAbstractResource, allowing it to handle any additional initialization or validation processes.\n\nAttributes:\n- `id` (str): A logical identifier for the resource.\n- `implicitRules` (str): A set of rules that govern how the content was created.\n- `language` (str): The language in which the resource content is written.\n- `meta` (Meta): Metadata associated with the resource.\n\nDependencies:\n- Imports `fhirabstractresource` for base functionality and `meta` for the Meta type used in initialization.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "fhirclient/models/fhirabstractbase.py": "import sys\nimport logging\nlogger = logging.getLogger(__name__)\n\nclass FHIRValidationError(Exception):\n    \"\"\" Exception raised when one or more errors occurred during model\n    validation.\n    \"\"\"\n\n    def __init__(self, errors, path=None):\n        \"\"\" Initializer.\n        \n        :param errors: List of Exception instances. Also accepts a string,\n            which is converted to a TypeError.\n        :param str path: The property path on the object where errors occurred\n        \"\"\"\n        if not isinstance(errors, list):\n            errors = [TypeError(errors)]\n        msgs = '\\n  '.join([str(e).replace('\\n', '\\n  ') for e in errors])\n        message = '{}:\\n  {}'.format(path or '{root}', msgs)\n        super(FHIRValidationError, self).__init__(message)\n        self.errors = errors\n        ' A list of validation errors encountered. Typically contains\\n        TypeError, KeyError, possibly AttributeError and others. '\n        self.path = path\n        ' The path on the object where the errors occurred. '\n\n    def prefixed(self, path_prefix):\n        \"\"\" Creates a new instance of the receiver, with the given path prefix\n        applied. \"\"\"\n        path = '{}.{}'.format(path_prefix, self.path) if self.path is not None else path_prefix\n        return self.__class__(self.errors, path)\n\nclass FHIRAbstractBase(object):\n    \"\"\" Abstract base class for all FHIR elements.\n    \"\"\"\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initializer. If strict is true, raises on errors, otherwise uses\n        `logger.warning()`.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self._resolved = None\n        ' Dictionary of resolved resources. '\n        self._owner = None\n        ' Points to the parent resource, if there is one. '\n        if jsondict is not None:\n            if strict:\n                self.update_with_json(jsondict)\n            else:\n                try:\n                    self.update_with_json(jsondict)\n                except FHIRValidationError as e:\n                    for err in e.errors:\n                        logger.warning(err)\n\n    @classmethod\n    def with_json(cls, jsonobj):\n        \"\"\" Initialize an element from a JSON dictionary or array.\n        \n        If the JSON dictionary has a \"resourceType\" entry and the specified\n        resource type is not the receiving classes type, uses\n        `FHIRElementFactory` to return a correct class instance.\n        \n        :raises: TypeError on anything but dict or list of dicts\n        :raises: FHIRValidationError if instantiation fails\n        :param jsonobj: A dict or list of dicts to instantiate from\n        :returns: An instance or a list of instances created from JSON data\n        \"\"\"\n        if isinstance(jsonobj, dict):\n            return cls._with_json_dict(jsonobj)\n        if isinstance(jsonobj, list):\n            arr = []\n            for jsondict in jsonobj:\n                try:\n                    arr.append(cls._with_json_dict(jsondict))\n                except FHIRValidationError as e:\n                    raise e.prefixed(str(len(arr)))\n            return arr\n        raise TypeError('`with_json()` on {} only takes dict or list of dict, but you provided {}'.format(cls, type(jsonobj)))\n\n    @classmethod\n    def _with_json_dict(cls, jsondict):\n        \"\"\" Internal method to instantiate from JSON dictionary.\n        \n        :raises: TypeError on anything but dict\n        :raises: FHIRValidationError if instantiation fails\n        :returns: An instance created from dictionary data\n        \"\"\"\n        if not isinstance(jsondict, dict):\n            raise TypeError('Can only use `_with_json_dict()` on {} with a dictionary, got {}'.format(type(self), type(jsondict)))\n        return cls(jsondict)\n\n    @classmethod\n    def with_json_and_owner(cls, jsonobj, owner):\n        \"\"\" Instantiates by forwarding to `with_json()`, then remembers the\n        \"owner\" of the instantiated elements. The \"owner\" is the resource\n        containing the receiver and is used to resolve contained resources.\n        \n        :raises: TypeError on anything but dict or list of dicts\n        :raises: FHIRValidationError if instantiation fails\n        :param dict jsonobj: Decoded JSON dictionary (or list thereof)\n        :param FHIRElement owner: The owning parent\n        :returns: An instance or a list of instances created from JSON data\n        \"\"\"\n        instance = cls.with_json(jsonobj)\n        if isinstance(instance, list):\n            for inst in instance:\n                inst._owner = owner\n        else:\n            instance._owner = owner\n        return instance\n\n    def elementProperties(self):\n        \"\"\" Returns a list of tuples, one tuple for each property that should\n        be serialized, as: (\"name\", \"json_name\", type, is_list, \"of_many\", not_optional)\n        \"\"\"\n        return []\n\n    def update_with_json(self, jsondict):\n        \"\"\" Update the receiver with data in a JSON dictionary.\n        \n        :raises: FHIRValidationError on validation errors\n        :param dict jsondict: The JSON dictionary to use to update the receiver\n        :returns: None on success, a list of errors if there were errors\n        \"\"\"\n        if jsondict is None:\n            return\n        if not isinstance(jsondict, dict):\n            raise FHIRValidationError('Non-dict type {} fed to `update_with_json` on {}'.format(type(jsondict), type(self)))\n        errs = []\n        valid = set(['resourceType'])\n        found = set()\n        nonoptionals = set()\n        for name, jsname, typ, is_list, of_many, not_optional in self.elementProperties():\n            valid.add(jsname)\n            if of_many is not None:\n                valid.add(of_many)\n            err = None\n            value = jsondict.get(jsname)\n            if value is not None and hasattr(typ, 'with_json_and_owner'):\n                try:\n                    value = typ.with_json_and_owner(value, self)\n                except Exception as e:\n                    value = None\n                    err = e\n            if value is not None:\n                testval = value\n                if is_list:\n                    if not isinstance(value, list):\n                        err = TypeError('Wrong type {} for list property \"{}\" on {}, expecting a list of {}'.format(type(value), name, type(self), typ))\n                        testval = None\n                    else:\n                        testval = value[0] if value and len(value) > 0 else None\n                if testval is not None and (not self._matches_type(testval, typ)):\n                    err = TypeError('Wrong type {} for property \"{}\" on {}, expecting {}'.format(type(testval), name, type(self), typ))\n                else:\n                    setattr(self, name, value)\n                found.add(jsname)\n                if of_many is not None:\n                    found.add(of_many)\n            elif not_optional:\n                nonoptionals.add(of_many or jsname)\n            _jsname = '_' + jsname\n            _value = jsondict.get(_jsname)\n            if _value is not None:\n                valid.add(_jsname)\n                found.add(_jsname)\n            if err is not None:\n                errs.append(err.prefixed(name) if isinstance(err, FHIRValidationError) else FHIRValidationError([err], name))\n        if len(nonoptionals) > 0:\n            for miss in nonoptionals - found:\n                errs.append(KeyError('Non-optional property \"{}\" on {} is missing'.format(miss, self)))\n        if len(set(jsondict.keys()) - valid) > 0:\n            for supflu in set(jsondict.keys()) - valid:\n                errs.append(AttributeError('Superfluous entry \"{}\" in data for {}'.format(supflu, self)))\n        if len(errs) > 0:\n            raise FHIRValidationError(errs)\n\n    def as_json(self):\n        \"\"\" Serializes to JSON by inspecting `elementProperties()` and creating\n        a JSON dictionary of all registered properties. Checks:\n        \n        - whether required properties are not None (and lists not empty)\n        - whether not-None properties are of the correct type\n        \n        :raises: FHIRValidationError if properties have the wrong type or if\n            required properties are empty\n        :returns: A validated dict object that can be JSON serialized\n        \"\"\"\n        js = {}\n        errs = []\n        found = set()\n        nonoptionals = set()\n        for name, jsname, typ, is_list, of_many, not_optional in self.elementProperties():\n            if not_optional:\n                nonoptionals.add(of_many or jsname)\n            err = None\n            value = getattr(self, name)\n            if value is None:\n                continue\n            if is_list:\n                if not isinstance(value, list):\n                    err = TypeError('Expecting property \"{}\" on {} to be list, but is {}'.format(name, type(self), type(value)))\n                elif len(value) > 0:\n                    if not self._matches_type(value[0], typ):\n                        err = TypeError('Expecting property \"{}\" on {} to be {}, but is {}'.format(name, type(self), typ, type(value[0])))\n                    else:\n                        lst = []\n                        for v in value:\n                            try:\n                                lst.append(v.as_json() if hasattr(v, 'as_json') else v)\n                            except FHIRValidationError as e:\n                                err = e.prefixed(str(len(lst))).prefixed(name)\n                        found.add(of_many or jsname)\n                        js[jsname] = lst\n            elif not self._matches_type(value, typ):\n                err = TypeError('Expecting property \"{}\" on {} to be {}, but is {}'.format(name, type(self), typ, type(value)))\n            else:\n                try:\n                    found.add(of_many or jsname)\n                    js[jsname] = value.as_json() if hasattr(value, 'as_json') else value\n                except FHIRValidationError as e:\n                    err = e.prefixed(name)\n            if err is not None:\n                errs.append(err if isinstance(err, FHIRValidationError) else FHIRValidationError([err], name))\n        if len(nonoptionals - found) > 0:\n            for nonop in nonoptionals - found:\n                errs.append(KeyError('Property \"{}\" on {} is not optional, you must provide a value for it'.format(nonop, self)))\n        if len(errs) > 0:\n            raise FHIRValidationError(errs)\n        return js\n\n    def _matches_type(self, value, typ):\n        if value is None:\n            return True\n        if isinstance(value, typ):\n            return True\n        if int == typ or float == typ:\n            return isinstance(value, int) or isinstance(value, float)\n        if sys.version_info < (3, 0) and (str == typ or unicode == typ):\n            return isinstance(value, str) or isinstance(value, unicode)\n        return False",
    "fhirclient/models/bundle.py": "from . import resource\n\nclass Bundle(resource.Resource):\n    \"\"\" Contains a collection of resources.\n    \n    A container for a collection of resources.\n    \"\"\"\n    resource_type = 'Bundle'\n\n    def elementProperties(self):\n        js = super(Bundle, self).elementProperties()\n        js.extend([('entry', 'entry', BundleEntry, True, None, False), ('identifier', 'identifier', identifier.Identifier, False, None, False), ('link', 'link', BundleLink, True, None, False), ('signature', 'signature', signature.Signature, False, None, False), ('timestamp', 'timestamp', fhirinstant.FHIRInstant, False, None, False), ('total', 'total', int, False, None, False), ('type', 'type', str, False, None, True)])\n        return js\nfrom . import backboneelement\n\nclass BundleEntry(backboneelement.BackboneElement):\n    \"\"\" Entry in the bundle - will have a resource or information.\n    \n    An entry in a bundle resource - will either contain a resource or\n    information about a resource (transactions and history only).\n    \"\"\"\n    resource_type = 'BundleEntry'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.fullUrl = None\n        ' URI for resource (Absolute URL server address or URI for UUID/OID).\\n        Type `str`. '\n        self.link = None\n        ' Links related to this entry.\\n        List of `BundleLink` items (represented as `dict` in JSON). '\n        self.request = None\n        ' Additional execution information (transaction/batch/history).\\n        Type `BundleEntryRequest` (represented as `dict` in JSON). '\n        self.resource = None\n        ' A resource in the bundle.\\n        Type `Resource` (represented as `dict` in JSON). '\n        self.response = None\n        ' Results of execution (transaction/batch/history).\\n        Type `BundleEntryResponse` (represented as `dict` in JSON). '\n        self.search = None\n        ' Search related information.\\n        Type `BundleEntrySearch` (represented as `dict` in JSON). '\n        super(BundleEntry, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(BundleEntry, self).elementProperties()\n        js.extend([('fullUrl', 'fullUrl', str, False, None, False), ('link', 'link', BundleLink, True, None, False), ('request', 'request', BundleEntryRequest, False, None, False), ('resource', 'resource', resource.Resource, False, None, False), ('response', 'response', BundleEntryResponse, False, None, False), ('search', 'search', BundleEntrySearch, False, None, False)])\n        return js\n\nclass BundleEntryRequest(backboneelement.BackboneElement):\n    \"\"\" Additional execution information (transaction/batch/history).\n    \n    Additional information about how this entry should be processed as part of\n    a transaction or batch.  For history, it shows how the entry was processed\n    to create the version contained in the entry.\n    \"\"\"\n    resource_type = 'BundleEntryRequest'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.ifMatch = None\n        ' For managing update contention.\\n        Type `str`. '\n        self.ifModifiedSince = None\n        ' For managing cache currency.\\n        Type `FHIRInstant` (represented as `str` in JSON). '\n        self.ifNoneExist = None\n        ' For conditional creates.\\n        Type `str`. '\n        self.ifNoneMatch = None\n        ' For managing cache currency.\\n        Type `str`. '\n        self.method = None\n        ' GET | HEAD | POST | PUT | DELETE | PATCH.\\n        Type `str`. '\n        self.url = None\n        ' URL for HTTP equivalent of this entry.\\n        Type `str`. '\n        super(BundleEntryRequest, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(BundleEntryRequest, self).elementProperties()\n        js.extend([('ifMatch', 'ifMatch', str, False, None, False), ('ifModifiedSince', 'ifModifiedSince', fhirinstant.FHIRInstant, False, None, False), ('ifNoneExist', 'ifNoneExist', str, False, None, False), ('ifNoneMatch', 'ifNoneMatch', str, False, None, False), ('method', 'method', str, False, None, True), ('url', 'url', str, False, None, True)])\n        return js\n\nclass BundleEntryResponse(backboneelement.BackboneElement):\n    \"\"\" Results of execution (transaction/batch/history).\n    \n    Indicates the results of processing the corresponding 'request' entry in\n    the batch or transaction being responded to or what the results of an\n    operation where when returning history.\n    \"\"\"\n    resource_type = 'BundleEntryResponse'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.etag = None\n        ' The Etag for the resource (if relevant).\\n        Type `str`. '\n        self.lastModified = None\n        \" Server's date time modified.\\n        Type `FHIRInstant` (represented as `str` in JSON). \"\n        self.location = None\n        ' The location (if the operation returns a location).\\n        Type `str`. '\n        self.outcome = None\n        ' OperationOutcome with hints and warnings (for batch/transaction).\\n        Type `Resource` (represented as `dict` in JSON). '\n        self.status = None\n        ' Status response code (text optional).\\n        Type `str`. '\n        super(BundleEntryResponse, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(BundleEntryResponse, self).elementProperties()\n        js.extend([('etag', 'etag', str, False, None, False), ('lastModified', 'lastModified', fhirinstant.FHIRInstant, False, None, False), ('location', 'location', str, False, None, False), ('outcome', 'outcome', resource.Resource, False, None, False), ('status', 'status', str, False, None, True)])\n        return js\n\nclass BundleEntrySearch(backboneelement.BackboneElement):\n    \"\"\" Search related information.\n    \n    Information about the search process that lead to the creation of this\n    entry.\n    \"\"\"\n    resource_type = 'BundleEntrySearch'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.mode = None\n        ' match | include | outcome - why this is in the result set.\\n        Type `str`. '\n        self.score = None\n        ' Search ranking (between 0 and 1).\\n        Type `float`. '\n        super(BundleEntrySearch, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(BundleEntrySearch, self).elementProperties()\n        js.extend([('mode', 'mode', str, False, None, False), ('score', 'score', float, False, None, False)])\n        return js\n\nclass BundleLink(backboneelement.BackboneElement):\n    \"\"\" Links related to this Bundle.\n    \n    A series of links that provide context to this bundle.\n    \"\"\"\n    resource_type = 'BundleLink'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.relation = None\n        ' See http://www.iana.org/assignments/link-relations/link-\\n        relations.xhtml#link-relations-1.\\n        Type `str`. '\n        self.url = None\n        ' Reference details for the link.\\n        Type `str`. '\n        super(BundleLink, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(BundleLink, self).elementProperties()\n        js.extend([('relation', 'relation', str, False, None, True), ('url', 'url', str, False, None, True)])\n        return js\nfrom . import fhirinstant\nfrom . import identifier\nfrom . import signature",
    "fhirclient/models/questionnaire.py": "from . import domainresource\n\nclass Questionnaire(domainresource.DomainResource):\n    \"\"\" A structured set of questions.\n    \n    A structured set of questions intended to guide the collection of answers\n    from end-users. Questionnaires provide detailed control over order,\n    presentation, phraseology and grouping to allow coherent, consistent data\n    collection.\n    \"\"\"\n    resource_type = 'Questionnaire'\n\n    def elementProperties(self):\n        js = super(Questionnaire, self).elementProperties()\n        js.extend([('approvalDate', 'approvalDate', fhirdate.FHIRDate, False, None, False), ('code', 'code', coding.Coding, True, None, False), ('contact', 'contact', contactdetail.ContactDetail, True, None, False), ('copyright', 'copyright', str, False, None, False), ('date', 'date', fhirdatetime.FHIRDateTime, False, None, False), ('derivedFrom', 'derivedFrom', str, True, None, False), ('description', 'description', str, False, None, False), ('effectivePeriod', 'effectivePeriod', period.Period, False, None, False), ('experimental', 'experimental', bool, False, None, False), ('identifier', 'identifier', identifier.Identifier, True, None, False), ('item', 'item', QuestionnaireItem, True, None, False), ('jurisdiction', 'jurisdiction', codeableconcept.CodeableConcept, True, None, False), ('lastReviewDate', 'lastReviewDate', fhirdate.FHIRDate, False, None, False), ('name', 'name', str, False, None, False), ('publisher', 'publisher', str, False, None, False), ('purpose', 'purpose', str, False, None, False), ('status', 'status', str, False, None, True), ('subjectType', 'subjectType', str, True, None, False), ('title', 'title', str, False, None, False), ('url', 'url', str, False, None, False), ('useContext', 'useContext', usagecontext.UsageContext, True, None, False), ('version', 'version', str, False, None, False)])\n        return js\nfrom . import backboneelement\n\nclass QuestionnaireItem(backboneelement.BackboneElement):\n    \"\"\" Questions and sections within the Questionnaire.\n    \n    A particular question, question grouping or display text that is part of\n    the questionnaire.\n    \"\"\"\n    resource_type = 'QuestionnaireItem'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.answerOption = None\n        ' Permitted answer.\\n        List of `QuestionnaireItemAnswerOption` items (represented as `dict` in JSON). '\n        self.answerValueSet = None\n        ' Valueset containing permitted answers.\\n        Type `str`. '\n        self.code = None\n        ' Corresponding concept for this item in a terminology.\\n        List of `Coding` items (represented as `dict` in JSON). '\n        self.definition = None\n        ' ElementDefinition - details for the item.\\n        Type `str`. '\n        self.enableBehavior = None\n        ' all | any.\\n        Type `str`. '\n        self.enableWhen = None\n        ' Only allow data when.\\n        List of `QuestionnaireItemEnableWhen` items (represented as `dict` in JSON). '\n        self.initial = None\n        ' Initial value(s) when item is first rendered.\\n        List of `QuestionnaireItemInitial` items (represented as `dict` in JSON). '\n        self.item = None\n        ' Nested questionnaire items.\\n        List of `QuestionnaireItem` items (represented as `dict` in JSON). '\n        self.linkId = None\n        ' Unique id for item in questionnaire.\\n        Type `str`. '\n        self.maxLength = None\n        ' No more than this many characters.\\n        Type `int`. '\n        self.prefix = None\n        ' E.g. \"1(a)\", \"2.5.3\".\\n        Type `str`. '\n        self.readOnly = None\n        \" Don't allow human editing.\\n        Type `bool`. \"\n        self.repeats = None\n        ' Whether the item may repeat.\\n        Type `bool`. '\n        self.required = None\n        ' Whether the item must be included in data results.\\n        Type `bool`. '\n        self.text = None\n        ' Primary text for the item.\\n        Type `str`. '\n        self.type = None\n        ' group | display | boolean | decimal | integer | date | dateTime +.\\n        Type `str`. '\n        super(QuestionnaireItem, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(QuestionnaireItem, self).elementProperties()\n        js.extend([('answerOption', 'answerOption', QuestionnaireItemAnswerOption, True, None, False), ('answerValueSet', 'answerValueSet', str, False, None, False), ('code', 'code', coding.Coding, True, None, False), ('definition', 'definition', str, False, None, False), ('enableBehavior', 'enableBehavior', str, False, None, False), ('enableWhen', 'enableWhen', QuestionnaireItemEnableWhen, True, None, False), ('initial', 'initial', QuestionnaireItemInitial, True, None, False), ('item', 'item', QuestionnaireItem, True, None, False), ('linkId', 'linkId', str, False, None, True), ('maxLength', 'maxLength', int, False, None, False), ('prefix', 'prefix', str, False, None, False), ('readOnly', 'readOnly', bool, False, None, False), ('repeats', 'repeats', bool, False, None, False), ('required', 'required', bool, False, None, False), ('text', 'text', str, False, None, False), ('type', 'type', str, False, None, True)])\n        return js\n\nclass QuestionnaireItemAnswerOption(backboneelement.BackboneElement):\n    \"\"\" Permitted answer.\n    \n    One of the permitted answers for a \"choice\" or \"open-choice\" question.\n    \"\"\"\n    resource_type = 'QuestionnaireItemAnswerOption'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.initialSelected = None\n        ' Whether option is selected by default.\\n        Type `bool`. '\n        self.valueCoding = None\n        ' Answer value.\\n        Type `Coding` (represented as `dict` in JSON). '\n        self.valueDate = None\n        ' Answer value.\\n        Type `FHIRDate` (represented as `str` in JSON). '\n        self.valueInteger = None\n        ' Answer value.\\n        Type `int`. '\n        self.valueReference = None\n        ' Answer value.\\n        Type `FHIRReference` (represented as `dict` in JSON). '\n        self.valueString = None\n        ' Answer value.\\n        Type `str`. '\n        self.valueTime = None\n        ' Answer value.\\n        Type `FHIRTime` (represented as `str` in JSON). '\n        super(QuestionnaireItemAnswerOption, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(QuestionnaireItemAnswerOption, self).elementProperties()\n        js.extend([('initialSelected', 'initialSelected', bool, False, None, False), ('valueCoding', 'valueCoding', coding.Coding, False, 'value', True), ('valueDate', 'valueDate', fhirdate.FHIRDate, False, 'value', True), ('valueInteger', 'valueInteger', int, False, 'value', True), ('valueReference', 'valueReference', fhirreference.FHIRReference, False, 'value', True), ('valueString', 'valueString', str, False, 'value', True), ('valueTime', 'valueTime', fhirtime.FHIRTime, False, 'value', True)])\n        return js\n\nclass QuestionnaireItemEnableWhen(backboneelement.BackboneElement):\n    \"\"\" Only allow data when.\n    \n    A constraint indicating that this item should only be enabled\n    (displayed/allow answers to be captured) when the specified condition is\n    true.\n    \"\"\"\n    resource_type = 'QuestionnaireItemEnableWhen'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.answerBoolean = None\n        ' Value for question comparison based on operator.\\n        Type `bool`. '\n        self.answerCoding = None\n        ' Value for question comparison based on operator.\\n        Type `Coding` (represented as `dict` in JSON). '\n        self.answerDate = None\n        ' Value for question comparison based on operator.\\n        Type `FHIRDate` (represented as `str` in JSON). '\n        self.answerDateTime = None\n        ' Value for question comparison based on operator.\\n        Type `FHIRDateTime` (represented as `str` in JSON). '\n        self.answerDecimal = None\n        ' Value for question comparison based on operator.\\n        Type `float`. '\n        self.answerInteger = None\n        ' Value for question comparison based on operator.\\n        Type `int`. '\n        self.answerQuantity = None\n        ' Value for question comparison based on operator.\\n        Type `Quantity` (represented as `dict` in JSON). '\n        self.answerReference = None\n        ' Value for question comparison based on operator.\\n        Type `FHIRReference` (represented as `dict` in JSON). '\n        self.answerString = None\n        ' Value for question comparison based on operator.\\n        Type `str`. '\n        self.answerTime = None\n        ' Value for question comparison based on operator.\\n        Type `FHIRTime` (represented as `str` in JSON). '\n        self.operator = None\n        ' exists | = | != | > | < | >= | <=.\\n        Type `str`. '\n        self.question = None\n        ' Question that determines whether item is enabled.\\n        Type `str`. '\n        super(QuestionnaireItemEnableWhen, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(QuestionnaireItemEnableWhen, self).elementProperties()\n        js.extend([('answerBoolean', 'answerBoolean', bool, False, 'answer', True), ('answerCoding', 'answerCoding', coding.Coding, False, 'answer', True), ('answerDate', 'answerDate', fhirdate.FHIRDate, False, 'answer', True), ('answerDateTime', 'answerDateTime', fhirdatetime.FHIRDateTime, False, 'answer', True), ('answerDecimal', 'answerDecimal', float, False, 'answer', True), ('answerInteger', 'answerInteger', int, False, 'answer', True), ('answerQuantity', 'answerQuantity', quantity.Quantity, False, 'answer', True), ('answerReference', 'answerReference', fhirreference.FHIRReference, False, 'answer', True), ('answerString', 'answerString', str, False, 'answer', True), ('answerTime', 'answerTime', fhirtime.FHIRTime, False, 'answer', True), ('operator', 'operator', str, False, None, True), ('question', 'question', str, False, None, True)])\n        return js\n\nclass QuestionnaireItemInitial(backboneelement.BackboneElement):\n    \"\"\" Initial value(s) when item is first rendered.\n    \n    One or more values that should be pre-populated in the answer when\n    initially rendering the questionnaire for user input.\n    \"\"\"\n    resource_type = 'QuestionnaireItemInitial'\n\n    def __init__(self, jsondict=None, strict=True):\n        \"\"\" Initialize all valid properties.\n        \n        :raises: FHIRValidationError on validation errors, unless strict is False\n        :param dict jsondict: A JSON dictionary to use for initialization\n        :param bool strict: If True (the default), invalid variables will raise a TypeError\n        \"\"\"\n        self.valueAttachment = None\n        ' Actual value for initializing the question.\\n        Type `Attachment` (represented as `dict` in JSON). '\n        self.valueBoolean = None\n        ' Actual value for initializing the question.\\n        Type `bool`. '\n        self.valueCoding = None\n        ' Actual value for initializing the question.\\n        Type `Coding` (represented as `dict` in JSON). '\n        self.valueDate = None\n        ' Actual value for initializing the question.\\n        Type `FHIRDate` (represented as `str` in JSON). '\n        self.valueDateTime = None\n        ' Actual value for initializing the question.\\n        Type `FHIRDateTime` (represented as `str` in JSON). '\n        self.valueDecimal = None\n        ' Actual value for initializing the question.\\n        Type `float`. '\n        self.valueInteger = None\n        ' Actual value for initializing the question.\\n        Type `int`. '\n        self.valueQuantity = None\n        ' Actual value for initializing the question.\\n        Type `Quantity` (represented as `dict` in JSON). '\n        self.valueReference = None\n        ' Actual value for initializing the question.\\n        Type `FHIRReference` (represented as `dict` in JSON). '\n        self.valueString = None\n        ' Actual value for initializing the question.\\n        Type `str`. '\n        self.valueTime = None\n        ' Actual value for initializing the question.\\n        Type `FHIRTime` (represented as `str` in JSON). '\n        self.valueUri = None\n        ' Actual value for initializing the question.\\n        Type `str`. '\n        super(QuestionnaireItemInitial, self).__init__(jsondict=jsondict, strict=strict)\n\n    def elementProperties(self):\n        js = super(QuestionnaireItemInitial, self).elementProperties()\n        js.extend([('valueAttachment', 'valueAttachment', attachment.Attachment, False, 'value', True), ('valueBoolean', 'valueBoolean', bool, False, 'value', True), ('valueCoding', 'valueCoding', coding.Coding, False, 'value', True), ('valueDate', 'valueDate', fhirdate.FHIRDate, False, 'value', True), ('valueDateTime', 'valueDateTime', fhirdatetime.FHIRDateTime, False, 'value', True), ('valueDecimal', 'valueDecimal', float, False, 'value', True), ('valueInteger', 'valueInteger', int, False, 'value', True), ('valueQuantity', 'valueQuantity', quantity.Quantity, False, 'value', True), ('valueReference', 'valueReference', fhirreference.FHIRReference, False, 'value', True), ('valueString', 'valueString', str, False, 'value', True), ('valueTime', 'valueTime', fhirtime.FHIRTime, False, 'value', True), ('valueUri', 'valueUri', str, False, 'value', True)])\n        return js\nfrom . import attachment\nfrom . import codeableconcept\nfrom . import coding\nfrom . import contactdetail\nfrom . import fhirdate\nfrom . import fhirdatetime\nfrom . import fhirreference\nfrom . import fhirtime\nfrom . import identifier\nfrom . import period\nfrom . import quantity\nfrom . import usagecontext",
    "fhirclient/models/fhirabstractresource.py": "from . import fhirabstractbase\n\nclass FHIRAbstractResource(fhirabstractbase.FHIRAbstractBase):\n    \"\"\" Extends the FHIRAbstractBase with server talking capabilities.\n    \"\"\"\n    resource_type = 'FHIRAbstractResource'\n\n    def __init__(self, jsondict=None, strict=True):\n        self._server = None\n        ' The server the instance was read from. '\n        if jsondict is not None and 'resourceType' in jsondict and (jsondict['resourceType'] != self.resource_type):\n            raise Exception('Attempting to instantiate {} with resource data that defines a resourceType of \"{}\"'.format(self.__class__, jsondict['resourceType']))\n        super(FHIRAbstractResource, self).__init__(jsondict=jsondict, strict=strict)\n\n    @classmethod\n    def _with_json_dict(cls, jsondict):\n        \"\"\" Overridden to use a factory if called when \"resourceType\" is\n        defined in the JSON but does not match the receiver's resource_type.\n        \"\"\"\n        if not isinstance(jsondict, dict):\n            raise Exception('Cannot use this method with anything but a JSON dictionary, got {}'.format(jsondict))\n        res_type = jsondict.get('resourceType')\n        if res_type and res_type != cls.resource_type:\n            return fhirelementfactory.FHIRElementFactory.instantiate(res_type, jsondict)\n        return super(FHIRAbstractResource, cls)._with_json_dict(jsondict)\n\n    def as_json(self):\n        js = super(FHIRAbstractResource, self).as_json()\n        js['resourceType'] = self.resource_type\n        return js\n\n    def relativeBase(self):\n        return self.__class__.resource_type\n\n    def relativePath(self):\n        if self.id is None:\n            return self.relativeBase()\n        return '{}/{}'.format(self.relativeBase(), self.id)\n\n    @classmethod\n    def read(cls, rem_id, server):\n        \"\"\" Read the resource with the given id from the given server. The\n        passed-in server instance must support a `request_json()` method call,\n        taking a relative path as first (and only mandatory) argument.\n        \n        :param str rem_id: The id of the resource on the remote server\n        :param FHIRServer server: An instance of a FHIR server or compatible class\n        :returns: An instance of the receiving class\n        \"\"\"\n        if not rem_id:\n            raise Exception('Cannot read resource without remote id')\n        path = '{}/{}'.format(cls.resource_type, rem_id)\n        instance = cls.read_from(path, server)\n        instance._local_id = rem_id\n        return instance\n\n    def createPath(self):\n        \"\"\" Get the endpoint on the server for creating the resource.\n\n        :returns: The resource endpoint or None for the root endpoint\n        \"\"\"\n        root_post_types = ('batch', 'transaction')\n        if self.resource_type == 'Bundle' and self.type in root_post_types:\n            return None\n        return self.relativeBase()\n\n    def create(self, server):\n        \"\"\" Attempt to create the receiver on the given server, using a POST\n        command.\n        \n        :param FHIRServer server: The server to create the receiver on\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception('Cannot create a resource without a server')\n        if self.id:\n            raise Exception('This resource already has an id, cannot create')\n        ret = srv.post_json(self.createPath(), self.as_json())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n\n    def update(self, server=None):\n        \"\"\" Update the receiver's representation on the given server, issuing\n        a PUT command.\n        \n        :param FHIRServer server: The server to update the receiver on;\n            optional, will use the instance's `server` if needed.\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception('Cannot update a resource that does not have a server')\n        if not self.id:\n            raise Exception('Cannot update a resource that does not have an id')\n        ret = srv.put_json(self.relativePath(), self.as_json())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n\n    def delete(self, server=None):\n        \"\"\" Delete the receiver from the given server with a DELETE command.\n        \n        :param FHIRServer server: The server to update the receiver on;\n            optional, will use the instance's `server` if needed.\n        :returns: None or the response JSON on success\n        \"\"\"\n        srv = server or self.origin_server\n        if srv is None:\n            raise Exception('Cannot delete a resource that does not have a server')\n        if not self.id:\n            raise Exception('Cannot delete a resource that does not have an id')\n        ret = srv.delete_json(self.relativePath())\n        if len(ret.text) > 0:\n            return ret.json()\n        return None\n\n    def search(self, struct=None):\n        \"\"\" Search can be started via a dictionary containing a search\n        construct.\n        \n        Calling this method with a search struct will return a `FHIRSearch`\n        object representing the search struct, with \"$type\" and \"id\" added.\n        \n        :param dict struct: An optional search structure\n        :returns: A FHIRSearch instance\n        \"\"\"\n        if struct is None:\n            struct = {'$type': self.__class__.resource_type}\n        if self._local_id is not None or self.id is not None:\n            struct['id'] = self._local_id or self.id\n        return self.__class__.where(struct)\n\n    @classmethod\n    def where(cls, struct):\n        \"\"\" Search can be started via a dictionary containing a search\n        construct.\n        \n        Calling this method with a search struct will return a `FHIRSearch`\n        object representing the search struct\n        \n        :param dict struct: A search structure\n        :returns: A FHIRSearch instance\n        \"\"\"\n        return fhirsearch.FHIRSearch(cls, struct)\nfrom . import fhirsearch\nfrom . import fhirelementfactory",
    "fhirclient/models/fhirreference.py": "import logging\nfrom . import reference\nlogger = logging.getLogger(__name__)\n\nclass FHIRReference(reference.Reference):\n    \"\"\" Subclassing FHIR's `Reference` resource to add resolving capabilities.\n    \"\"\"",
    "fhirclient/server.py": "import json\nimport requests\nimport logging\nimport urllib.parse as urlparse\nfrom .auth import FHIRAuth\nFHIRJSONMimeType = 'application/fhir+json'\nlogger = logging.getLogger(__name__)\n\nclass FHIRUnauthorizedException(Exception):\n    \"\"\" Indicating a 401 response.\n    \"\"\"\n\n    def __init__(self, response):\n        self.response = response\n\nclass FHIRPermissionDeniedException(Exception):\n    \"\"\" Indicating a 403 response.\n    \"\"\"\n\n    def __init__(self, response):\n        self.response = response\n\nclass FHIRNotFoundException(Exception):\n    \"\"\" Indicating a 404 response.\n    \"\"\"\n\n    def __init__(self, response):\n        self.response = response\n\nclass FHIRServer(object):\n    \"\"\" Handles talking to a FHIR server.\n    \"\"\"\n\n    def should_save_state(self):\n        if self.client is not None:\n            self.client.save_state()\n\n    @property\n    def capabilityStatement(self):\n        self.get_capability()\n        return self._capability\n\n    def get_capability(self, force=False):\n        \"\"\" Returns the server's CapabilityStatement, retrieving it if needed\n        or forced.\n        \"\"\"\n        if self._capability is None or force:\n            logger.info('Fetching CapabilityStatement from {0}'.format(self.base_uri))\n            from .models import capabilitystatement\n            conf = capabilitystatement.CapabilityStatement.read_from('metadata', self)\n            self._capability = conf\n            security = None\n            try:\n                security = conf.rest[0].security\n            except Exception as e:\n                logger.info('No REST security statement found in server capability statement')\n            settings = {'aud': self.aud, 'app_id': self.client.app_id if self.client is not None else None, 'app_secret': self.client.app_secret if self.client is not None else None, 'redirect_uri': self.client.redirect if self.client is not None else None, 'jwt_token': self.client.jwt_token if self.client is not None else None}\n            self.auth = FHIRAuth.from_capability_security(security, settings)\n            self.should_save_state()\n\n    @property\n    def desired_scope(self):\n        return self.client.desired_scope if self.client is not None else None\n\n    @property\n    def launch_token(self):\n        return self.client.launch_token if self.client is not None else None\n\n    @property\n    def authorize_uri(self):\n        if self.auth is None:\n            self.get_capability()\n        return self.auth.authorize_uri(self)\n\n    def handle_callback(self, url):\n        if self.auth is None:\n            raise Exception('Not ready to handle callback, I do not have an auth instance')\n        return self.auth.handle_callback(url, self)\n\n    def authorize(self):\n        if self.auth is None:\n            raise Exception('Not ready to authorize, I do not have an auth instance')\n        return self.auth.authorize(self) if self.auth is not None else None\n\n    def reauthorize(self):\n        if self.auth is None:\n            raise Exception('Not ready to reauthorize, I do not have an auth instance')\n        return self.auth.reauthorize(self) if self.auth is not None else None\n\n    @property\n    def ready(self):\n        \"\"\" Check whether the server is ready to make calls, i.e. is has\n        fetched its capability statement and its `auth` instance is ready.\n        \n        :returns: True if the server can make authenticated calls\n        \"\"\"\n        return self.auth.ready if self.auth is not None else False\n\n    def prepare(self):\n        \"\"\" Check whether the server is ready to make calls, i.e. is has\n        fetched its capability statement and its `auth` instance is ready.\n        This method will fetch the capability statement if it hasn't already\n        been fetched.\n        \n        :returns: True if the server can make authenticated calls\n        \"\"\"\n        if self.auth is None:\n            self.get_capability()\n        return self.auth.ready if self.auth is not None else False\n\n    def request_json(self, path, nosign=False):\n        \"\"\" Perform a request for JSON data against the server's base with the\n        given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: Decoded JSON response\n        \"\"\"\n        headers = {'Accept': 'application/json'}\n        res = self._get(path, headers, nosign)\n        return res.json()\n\n    def request_data(self, path, headers={}, nosign=False):\n        \"\"\" Perform a data request data against the server's base with the\n        given relative path.\n        \"\"\"\n        res = self._get(path, headers, nosign)\n        return res.content\n\n    def _get(self, path, headers={}, nosign=False):\n        \"\"\" Issues a GET request.\n        \n        :returns: The response object\n        \"\"\"\n        assert self.base_uri and path\n        url = urlparse.urljoin(self.base_uri, path)\n        header_defaults = {'Accept': FHIRJSONMimeType, 'Accept-Charset': 'UTF-8'}\n        header_defaults.update(headers)\n        headers = header_defaults\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        res = self.session.get(url, headers=headers)\n        self.raise_for_status(res)\n        return res\n\n    def put_json(self, path, resource_json, nosign=False):\n        \"\"\" Performs a PUT request of the given JSON, which should represent a\n        resource, to the given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param dict resource_json: The JSON representing the resource\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {'Content-type': FHIRJSONMimeType, 'Accept': FHIRJSONMimeType, 'Accept-Charset': 'UTF-8'}\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        res = self.session.put(url, headers=headers, data=json.dumps(resource_json))\n        self.raise_for_status(res)\n        return res\n\n    def post_json(self, path, resource_json, nosign=False):\n        \"\"\" Performs a POST of the given JSON, which should represent a\n        resource, to the given relative path.\n        \n        :param str path: The path to append to `base_uri`\n        :param dict resource_json: The JSON representing the resource\n        :param bool nosign: If set to True, the request will not be signed\n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {'Content-type': FHIRJSONMimeType, 'Accept': FHIRJSONMimeType, 'Accept-Charset': 'UTF-8'}\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        res = self.session.post(url, headers=headers, data=json.dumps(resource_json))\n        self.raise_for_status(res)\n        return res\n\n    def post_as_form(self, url, formdata, auth=None):\n        \"\"\" Performs a POST request with form-data, expecting to receive JSON.\n        This method is used in the OAuth2 token exchange and thus doesn't\n        request fhir+json.\n        \n        :throws: Exception on HTTP status >= 400\n        :returns: The response object\n        \"\"\"\n        headers = {'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8', 'Accept': 'application/json'}\n        res = self.session.post(url, data=formdata, auth=auth)\n        self.raise_for_status(res)\n        return res\n\n    def delete_json(self, path, nosign=False):\n        \"\"\" Issues a DELETE command against the given relative path, accepting\n        a JSON response.\n        \n        :param str path: The relative URL path to issue a DELETE against\n        :param bool nosign: If set to True, the request will not be signed\n        :returns: The response object\n        \"\"\"\n        url = urlparse.urljoin(self.base_uri, path)\n        headers = {'Accept': FHIRJSONMimeType, 'Accept-Charset': 'UTF-8'}\n        if not nosign and self.auth is not None and self.auth.can_sign_headers():\n            headers = self.auth.signed_headers(headers)\n        res = self.session.delete(url)\n        self.raise_for_status(res)\n        return res\n\n    def raise_for_status(self, response):\n        if response.status_code < 400:\n            return\n        if 401 == response.status_code:\n            raise FHIRUnauthorizedException(response)\n        elif 403 == response.status_code:\n            raise FHIRPermissionDeniedException(response)\n        elif 404 == response.status_code:\n            raise FHIRNotFoundException(response)\n        else:\n            response.raise_for_status()\n\n    @property\n    def state(self):\n        \"\"\" Return current state.\n        \"\"\"\n        return {'base_uri': self.base_uri, 'auth_type': self.auth.auth_type if self.auth is not None else 'none', 'auth': self.auth.state if self.auth is not None else None}\n\n    def from_state(self, state):\n        \"\"\" Update ivars from given state information.\n        \"\"\"\n        assert state\n        self.base_uri = state.get('base_uri') or self.base_uri\n        self.auth = FHIRAuth.create(state.get('auth_type'), state=state.get('auth'))",
    "fhirclient/models/domainresource.py": "from . import resource\n\nclass DomainResource(resource.Resource):\n    \"\"\" A resource with narrative, extensions, and contained resources.\n    \n    A resource that includes narrative, extensions, and contained resources.\n    \"\"\"\n    resource_type = 'DomainResource'\n\n    def elementProperties(self):\n        js = super(DomainResource, self).elementProperties()\n        js.extend([('contained', 'contained', resource.Resource, True, None, False), ('extension', 'extension', extension.Extension, True, None, False), ('modifierExtension', 'modifierExtension', extension.Extension, True, None, False), ('text', 'text', narrative.Narrative, False, None, False)])\n        return js\nfrom . import extension\nfrom . import narrative",
    "fhirclient/models/resource.py": "from . import fhirabstractresource\n\nclass Resource(fhirabstractresource.FHIRAbstractResource):\n    \"\"\" Base Resource.\n    \n    This is the base resource type for everything.\n    \"\"\"\n    resource_type = 'Resource'\n\n    def elementProperties(self):\n        js = super(Resource, self).elementProperties()\n        js.extend([('id', 'id', str, False, None, False), ('implicitRules', 'implicitRules', str, False, None, False), ('language', 'language', str, False, None, False), ('meta', 'meta', meta.Meta, False, None, False)])\n        return js\nfrom . import meta"
  }
}