{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_method",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_method.py",
  "test_code": "from mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass TestMethod:\n    method: Method\n\n    def setup_method(self) -> None:\n        self.method = Method(\n            name=\"name\",\n            arguments=[\n                Argument.self(),\n                Argument(\"my_str\", Type.str, TypeConstant(\"test\")),\n                Argument(\"lst\", Type.ListAny),\n            ],\n            decorators=[Type.Any],\n            return_type=Type.none,\n            body_lines=[\"line1\", \"line2\"],\n            docstring=\"docstring\\n\\nlong\",\n            boto3_doc_link=\"boto3://doc.link\",\n        )\n\n    def test_set_boto3_doc_link(self) -> None:\n        self.method.set_boto3_doc_link(\"new\")\n        assert self.method.boto3_doc_link == \"new\"\n\n    def test_is_kw_only(self) -> None:\n        assert self.method.is_kw_only() is False\n\n        self.method.arguments = [\n            Argument.self(),\n            Argument.kwflag(),\n            Argument(\"lst\", Type.ListAny),\n        ]\n        assert self.method.is_kw_only() is True\n\n        self.method.arguments = [\n            Argument.self(),\n            Argument(\"lst\", Type.ListAny),\n            Argument.kwflag(),\n            Argument(\"lst2\", Type.ListAny),\n        ]\n        assert self.method.is_kw_only() is False\n\n    def test_iterate_call_arguments(self) -> None:\n        assert len(list(self.method.iterate_call_arguments())) == 2\n\n        self.method.arguments = [\n            Argument(\"lst\", Type.ListAny),\n            Argument.kwflag(),\n            Argument(\"lst2\", Type.ListAny),\n        ]\n        assert len(list(self.method.iterate_call_arguments())) == 3\n\n    def test_iterate_packed_arguments(self) -> None:\n        assert len(list(self.method.iterate_packed_arguments())) == 3\n\n        self.method.arguments = [\n            Argument.self(),\n            Argument.kwflag(),\n            Argument(\"lst2\", Type.ListAny),\n        ]\n        assert len(list(self.method.iterate_packed_arguments())) == 3\n        self.method.create_request_type_annotation(\"RequestType\")\n        assert len(list(self.method.iterate_packed_arguments())) == 2\n\n    def test_has_arguments(self) -> None:\n        assert self.method.has_arguments() is True\n\n        self.method.arguments = [Argument.self()]\n        assert self.method.has_arguments() is False\n\n        self.method.arguments = [Argument(\"other\", Type.str)]\n        assert self.method.has_arguments() is True\n",
  "GT_file_code": {
    "mypy_boto3_builder/structures/method.py": "\"\"\"\nClass method.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterator\n\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.function import Function\n\n\nclass Method(Function):\n    \"\"\"\n    Class method.\n    \"\"\"\n\n    def get_self_argument(self) -> Argument | None:\n        \"\"\"\n        Get `self` or `cls` argument.\n        \"\"\"\n        if not self.arguments:\n            return None\n        first_argument = self.arguments[0]\n        if first_argument.name in Argument.FIRST_NAMES:\n            return first_argument\n\n        return None\n\n    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in method call.\n        \"\"\"\n        self_argument = self.get_self_argument()\n        for argument in super().iterate_call_arguments():\n            if argument == self_argument:\n                continue\n            yield argument\n\n    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only methods.\n        \"\"\"\n        packed_arguments = super().iterate_packed_arguments()\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from packed_arguments\n            return\n\n        self_argument = self.get_self_argument()\n        if self_argument:\n            yield self_argument\n\n        yield from packed_arguments\n\n    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether method has arguments.\n        \"\"\"\n        self_argument = self.get_self_argument()\n        if not self_argument:\n            return super().has_arguments()\n\n        return len(self.arguments) > 1\n",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n\n    SELF_NAME: Final = \"self\"\n    CLS_NAME: Final = \"cls\"\n    KW_NAME: Final = \"*\"\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def __init__(\n        self,\n        name: str,\n        type_annotation: FakeAnnotation | None,\n        default: TypeConstant | None = None,\n        prefix: Literal[\"*\", \"**\", \"\"] = \"\",\n    ) -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal[\"*\", \"**\", \"\"] = prefix\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f\" = {self.default.render()}\" if self.default is not None else \"\"\n        if not self.type_annotation:\n            return f\"{self.name}{default_suffix}\"\n\n        return f\"{self.name}: {self.type_annotation.render()}{default_suffix}\"\n\n    @classmethod\n    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)\n\n    @classmethod\n    def kwflag(cls) -> Self:\n        \"\"\"\n        Create `*` keywords separator.\n        \"\"\"\n        return cls(name=cls.KW_NAME, type_annotation=None)\n\n    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == \"*\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(\n            name=self.name,\n            type_annotation=self.type_annotation.copy() if self.type_annotation else None,\n            default=self.default.copy() if self.default else None,\n            prefix=self.prefix,\n        )\n",
    "mypy_boto3_builder/structures/function.py": "\"\"\"\nModule-level function.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\n\n\nclass Function:\n    \"\"\"\n    Module-level function.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        if not self._boto3_doc_link:\n            raise BuildInternalError(f\"{self.name} has no boto3_doc_link\")\n        return self._boto3_doc_link\n\n    def set_boto3_doc_link(self, link: str) -> None:\n        \"\"\"\n        Set link to boto3 docs.\n        \"\"\"\n        self._boto3_doc_link = link\n\n    def has_boto3_doc_link(self) -> bool:\n        \"\"\"\n        Whether boto3_doc_link is set.\n        \"\"\"\n        return bool(self._boto3_doc_link)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Represent as a valid Python function signature.\n        \"\"\"\n        return (\n            f\"{'async ' if self.is_async else ''}def\"\n            f\" {self.name}({', '.join(argument.render() for argument in self.arguments)}) ->\"\n            f\" {self.return_type.render()}\"\n        )\n\n    @property\n    def short_docstring(self) -> str:\n        \"\"\"\n        Docstring without documentation links.\n        \"\"\"\n        if not self.docstring:\n            return self.docstring\n\n        short_docstring = self.docstring.strip().split(\"\\n\\n\")[0]\n        if short_docstring.startswith(\"[\"):\n            return \"\"\n        return short_docstring\n\n    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"\n        Create and set `request_type_annotation` TypedDict based on function arguments.\n        \"\"\"\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(\n                argument.name,\n                argument.type_annotation,\n                required=argument.required,\n            )\n\n        if not result.children:\n            return\n        self.request_type_annotation = result\n\n    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only functions.\n        \"\"\"\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from self.arguments\n            return\n\n        yield Argument(\n            name=\"kwargs\",\n            type_annotation=Type.unpack(self.request_type_annotation),\n            prefix=\"**\",\n        )\n\n    @property\n    def body(self) -> str:\n        \"\"\"\n        Function body as a string.\n        \"\"\"\n        return \"\\n\".join(self.body_lines)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over required type annotations.\n        \"\"\"\n        yield from self.return_type.iterate_types()\n        for argument in self.iterate_packed_arguments():\n            yield from argument.iterate_types()\n        for decorator in self.decorators:\n            yield from decorator.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract required import records.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n\n        return result\n\n    @property\n    def returns_none(self) -> bool:\n        \"\"\"\n        Whether return type is None.\n        \"\"\"\n        return self.return_type == Type.none\n\n    def is_kw_only(self) -> bool:\n        \"\"\"\n        Whether method arguments can be passed only as kwargs.\n        \"\"\"\n        if not self.has_arguments():\n            return False\n\n        first_argument = next(self.iterate_call_arguments())\n        return first_argument.is_kwflag()\n\n    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in function call.\n        \"\"\"\n        yield from self.arguments\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        result.extend(\n            argument.type_annotation\n            for argument in self.arguments\n            if argument.type_annotation and argument.type_annotation.get_local_types()\n        )\n        if self.return_type and self.return_type.get_local_types():\n            result.append(self.return_type)\n        return result\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return self.__class__(\n            name=self.name,\n            arguments=[i.copy() for i in self.arguments],\n            return_type=self.return_type.copy(),\n            docstring=self.docstring,\n            decorators=[i.copy() for i in self.decorators],\n            body_lines=list(self.body_lines),\n            type_ignore=self.type_ignore,\n            is_async=self.is_async,\n        )\n\n    def remove_argument(self, *names: str) -> Self:\n        \"\"\"\n        Remove argument by name or names.\n        \"\"\"\n        remove = [arg for arg in self.arguments if arg.name in names]\n\n        for argument in remove:\n            self.arguments.remove(argument)\n\n        return self\n\n    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether function has arguments.\n        \"\"\"\n        return bool(self.arguments)\n",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\n\n\nValueType = str | int | float | EllipsisType | None\n\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n\n    Ellipsis: Final[EllipsisType] = EllipsisType()\n\n    def __init__(self, value: ValueType) -> None:\n        self.value: ValueType = value\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.value is self.Ellipsis:\n            return \"...\"\n\n        return repr(self.value)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.value)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/structures/method.py": {
      "Method.iterate_call_arguments": {
        "code": "    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"Iterate over arguments that are used in method calls, excluding the `self` or `cls` argument. \n\nThis method retrieves the `self` or `cls` argument using the `get_self_argument()` method and then yields the remaining arguments by iterating over the arguments obtained from the superclass's `iterate_call_arguments()` method. If the `self` or `cls` argument is found among the arguments, it is skipped.\n\nReturns:\n    An iterator of `Argument` instances representing the method's call arguments, excluding the self/cls argument.\n\nDependencies:\n- `self.get_self_argument()` retrieves the first argument to determine if it is `self` or `cls`.\n- `super().iterate_call_arguments()` is called to access the base implementation for iterating over all arguments.\"\"\"\n        '\\n        Iterate over arguments that are used in method call.\\n        '\n        self_argument = self.get_self_argument()\n        for argument in super().iterate_call_arguments():\n            if argument == self_argument:\n                continue\n            yield argument",
        "docstring": "Iterate over arguments that are used in method calls, excluding the `self` or `cls` argument. \n\nThis method retrieves the `self` or `cls` argument using the `get_self_argument()` method and then yields the remaining arguments by iterating over the arguments obtained from the superclass's `iterate_call_arguments()` method. If the `self` or `cls` argument is found among the arguments, it is skipped.\n\nReturns:\n    An iterator of `Argument` instances representing the method's call arguments, excluding the self/cls argument.\n\nDependencies:\n- `self.get_self_argument()` retrieves the first argument to determine if it is `self` or `cls`.\n- `super().iterate_call_arguments()` is called to access the base implementation for iterating over all arguments.",
        "signature": "def iterate_call_arguments(self) -> Iterator[Argument]:",
        "type": "Method",
        "class_signature": "class Method(Function):"
      },
      "Method.iterate_packed_arguments": {
        "code": "    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"Iterate over packed arguments for keyword-only methods.\n\nThis method yields packed arguments when the method is keyword-only and accompanied by a request type annotation. It first checks whether the method is keyword-only (`is_kw_only()`) and if a request type annotation is present. If either condition is not met, it yields the packed arguments directly from the superclass's method. If the method has a 'self' or 'cls' argument (obtained from `get_self_argument()`), it yields that first before the packed arguments.\n\nReturns:\n    Iterator[Argument]: An iterator over the packed arguments, including the 'self' or 'cls' argument if applicable.\n\nDependencies:\n- `super().iterate_packed_arguments()`: Invoked to retrieve packed arguments from the parent `Function` class.\n- `is_kw_only()`: Checks if the method is defined with keyword-only arguments.\n- `request_type_annotation`: A property that determines if a type annotation is present.\n- `get_self_argument()`: A method that retrieves the first argument (if it is 'self' or 'cls').\"\"\"\n        '\\n        Iterate over packed arguments for KW-only methods.\\n        '\n        packed_arguments = super().iterate_packed_arguments()\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from packed_arguments\n            return\n        self_argument = self.get_self_argument()\n        if self_argument:\n            yield self_argument\n        yield from packed_arguments",
        "docstring": "Iterate over packed arguments for keyword-only methods.\n\nThis method yields packed arguments when the method is keyword-only and accompanied by a request type annotation. It first checks whether the method is keyword-only (`is_kw_only()`) and if a request type annotation is present. If either condition is not met, it yields the packed arguments directly from the superclass's method. If the method has a 'self' or 'cls' argument (obtained from `get_self_argument()`), it yields that first before the packed arguments.\n\nReturns:\n    Iterator[Argument]: An iterator over the packed arguments, including the 'self' or 'cls' argument if applicable.\n\nDependencies:\n- `super().iterate_packed_arguments()`: Invoked to retrieve packed arguments from the parent `Function` class.\n- `is_kw_only()`: Checks if the method is defined with keyword-only arguments.\n- `request_type_annotation`: A property that determines if a type annotation is present.\n- `get_self_argument()`: A method that retrieves the first argument (if it is 'self' or 'cls').",
        "signature": "def iterate_packed_arguments(self) -> Iterator[Argument]:",
        "type": "Method",
        "class_signature": "class Method(Function):"
      },
      "Method.has_arguments": {
        "code": "    def has_arguments(self) -> bool:\n        \"\"\"Determines whether the method has any arguments.\n\nThis method checks if the current method instance has arguments by inspecting its arguments list. It first attempts to retrieve the 'self' or 'cls' argument using the `get_self_argument` method. If no such argument is found, it delegates the check to the superclass method by calling `super().has_arguments()`. If a 'self' or 'cls' argument is present, it checks if there is more than one argument beyond that. \n\nReturns:\n    bool: True if the method has arguments, otherwise False.\n\nDependencies:\n- `self.get_self_argument()`: Retrieves the first argument (if any) to determine if it's a method that includes a 'self' or 'cls' parameter.\n- `super().has_arguments()`: This is called if no 'self' or 'cls' argument is found, leveraging the behavior defined in the superclass (`Function`).\n- `self.arguments`: An attribute inherited from the `Function` class, which is a list of argument instances, crucial for determining the number of arguments present.\"\"\"\n        '\\n        Whether method has arguments.\\n        '\n        self_argument = self.get_self_argument()\n        if not self_argument:\n            return super().has_arguments()\n        return len(self.arguments) > 1",
        "docstring": "Determines whether the method has any arguments.\n\nThis method checks if the current method instance has arguments by inspecting its arguments list. It first attempts to retrieve the 'self' or 'cls' argument using the `get_self_argument` method. If no such argument is found, it delegates the check to the superclass method by calling `super().has_arguments()`. If a 'self' or 'cls' argument is present, it checks if there is more than one argument beyond that. \n\nReturns:\n    bool: True if the method has arguments, otherwise False.\n\nDependencies:\n- `self.get_self_argument()`: Retrieves the first argument (if any) to determine if it's a method that includes a 'self' or 'cls' parameter.\n- `super().has_arguments()`: This is called if no 'self' or 'cls' argument is found, leveraging the behavior defined in the superclass (`Function`).\n- `self.arguments`: An attribute inherited from the `Function` class, which is a list of argument instances, crucial for determining the number of arguments present.",
        "signature": "def has_arguments(self) -> bool:",
        "type": "Method",
        "class_signature": "class Method(Function):"
      }
    },
    "mypy_boto3_builder/structures/argument.py": {
      "Argument.__init__": {
        "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n        \"\"\"Initialize an Argument instance representing a method or function parameter.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): An optional type annotation for the argument; it can be a `FakeAnnotation` or `None`.\n- default (TypeConstant | None): An optional default value for the argument, which can be a `TypeConstant` or `None`.\n- prefix (Literal[\"*\", \"**\", \"\"]): A string indicating if the argument is a positional (*), keyword (**), or regular argument; defaults to an empty string.\n\nThis constructor sets the `name`, `type_annotation`, `default`, and `prefix` attributes of the `Argument` instance. The constants `SELF_NAME`, `CLS_NAME`, and `KW_NAME` defined in the `Argument` class can be used to create standard argument types like `self`, `cls`, and keyword separators. The prefixes help differentiate between various argument types in a function signature.\"\"\"\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal['*', '**', ''] = prefix",
        "docstring": "Initialize an Argument instance representing a method or function parameter.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): An optional type annotation for the argument; it can be a `FakeAnnotation` or `None`.\n- default (TypeConstant | None): An optional default value for the argument, which can be a `TypeConstant` or `None`.\n- prefix (Literal[\"*\", \"**\", \"\"]): A string indicating if the argument is a positional (*), keyword (**), or regular argument; defaults to an empty string.\n\nThis constructor sets the `name`, `type_annotation`, `default`, and `prefix` attributes of the `Argument` instance. The constants `SELF_NAME`, `CLS_NAME`, and `KW_NAME` defined in the `Argument` class can be used to create standard argument types like `self`, `cls`, and keyword separators. The prefixes help differentiate between various argument types in a function signature.",
        "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:",
        "type": "Method",
        "class_signature": "class Argument:"
      },
      "Argument.self": {
        "code": "    def self(cls) -> Self:\n        \"\"\"Create a `self` argument for use in method definitions.\n\nReturns:\n    An instance of the `Argument` class initialized with:\n        - `name` set to the constant `SELF_NAME`, which is defined as 'self' in the class.\n        - `type_annotation` set to `None`, indicating no type annotation is provided.\n\nThis method utilizes the `SELF_NAME` constant (defined as a class-level constant) to establish the standard representation of the `self` parameter in class methods, ensuring consistency across instances of the `Argument` class.\"\"\"\n        '\\n        Create `self` argument.\\n        '\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
        "docstring": "Create a `self` argument for use in method definitions.\n\nReturns:\n    An instance of the `Argument` class initialized with:\n        - `name` set to the constant `SELF_NAME`, which is defined as 'self' in the class.\n        - `type_annotation` set to `None`, indicating no type annotation is provided.\n\nThis method utilizes the `SELF_NAME` constant (defined as a class-level constant) to establish the standard representation of the `self` parameter in class methods, ensuring consistency across instances of the `Argument` class.",
        "signature": "def self(cls) -> Self:",
        "type": "Method",
        "class_signature": "class Argument:"
      },
      "Argument.kwflag": {
        "code": "    def kwflag(cls) -> Self:\n        \"\"\"Create a representation of the `*` keyword argument separator for method signatures.\n\nThis class method constructs an `Argument` instance with the name set to `*`, serving as a special marker in Python function definitions to indicate that any following parameters must be passed as keyword arguments. It does not accept any type annotation, as it is used solely for handling variable keyword arguments.\n\nReturns:\n    An instance of `Argument` configured as a keyword separator.\n\nConstants:\n    - `KW_NAME`: A class-level constant that holds the string \"*\" to represent the keyword argument separator. It is defined in the `Argument` class.\"\"\"\n        '\\n        Create `*` keywords separator.\\n        '\n        return cls(name=cls.KW_NAME, type_annotation=None)",
        "docstring": "Create a representation of the `*` keyword argument separator for method signatures.\n\nThis class method constructs an `Argument` instance with the name set to `*`, serving as a special marker in Python function definitions to indicate that any following parameters must be passed as keyword arguments. It does not accept any type annotation, as it is used solely for handling variable keyword arguments.\n\nReturns:\n    An instance of `Argument` configured as a keyword separator.\n\nConstants:\n    - `KW_NAME`: A class-level constant that holds the string \"*\" to represent the keyword argument separator. It is defined in the `Argument` class.",
        "signature": "def kwflag(cls) -> Self:",
        "type": "Method",
        "class_signature": "class Argument:"
      }
    },
    "mypy_boto3_builder/structures/function.py": {
      "Function.__init__": {
        "code": "    def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:\n        \"\"\"Initialize a new Function instance.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument instances representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): A descriptive string for the function's documentation. Defaults to an empty string.\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators to be applied to the function. Defaults to an empty tuple.\n- body_lines (Iterable[str], optional): A collection of strings representing the body of the function. Defaults to an empty tuple.\n- type_ignore (bool, optional): A flag indicating whether to ignore type checking for this function. Defaults to False.\n- is_async (bool, optional): A flag indicating whether the function is asynchronous. Defaults to False.\n- boto3_doc_link (str, optional): A link to the boto3 documentation relevant to this function. Defaults to an empty string.\n\nAttributes:\n- self.request_type_annotation (TypeTypedDict | None): A TypedDict representing the request type annotation, initialized as None and later created based on function arguments.\n- self._boto3_doc_link (str): Stores the link to the boto3 documentation, must be set to use boto3_doc_link property.\n\nThis constructor sets up a Function instance with all necessary attributes for representing a Python function, including its signature and associated metadata for type handling and documentation.\"\"\"\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
        "docstring": "Initialize a new Function instance.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument instances representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): A descriptive string for the function's documentation. Defaults to an empty string.\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators to be applied to the function. Defaults to an empty tuple.\n- body_lines (Iterable[str], optional): A collection of strings representing the body of the function. Defaults to an empty tuple.\n- type_ignore (bool, optional): A flag indicating whether to ignore type checking for this function. Defaults to False.\n- is_async (bool, optional): A flag indicating whether the function is asynchronous. Defaults to False.\n- boto3_doc_link (str, optional): A link to the boto3 documentation relevant to this function. Defaults to an empty string.\n\nAttributes:\n- self.request_type_annotation (TypeTypedDict | None): A TypedDict representing the request type annotation, initialized as None and later created based on function arguments.\n- self._boto3_doc_link (str): Stores the link to the boto3 documentation, must be set to use boto3_doc_link property.\n\nThis constructor sets up a Function instance with all necessary attributes for representing a Python function, including its signature and associated metadata for type handling and documentation.",
        "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
        "type": "Method",
        "class_signature": "class Function:"
      },
      "Function.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Return the link to the Boto3 documentation for this function.\n\nRaises a BuildInternalError if the documentation link has not been set, indicating that the function lacks an associated Boto3 documentation link. The documentation link is stored in the private attribute `_boto3_doc_link`, which must be set using the `set_boto3_doc_link` method before accessing this property.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        if not self._boto3_doc_link:\n            raise BuildInternalError(f'{self.name} has no boto3_doc_link')\n        return self._boto3_doc_link",
        "docstring": "Return the link to the Boto3 documentation for this function.\n\nRaises a BuildInternalError if the documentation link has not been set, indicating that the function lacks an associated Boto3 documentation link. The documentation link is stored in the private attribute `_boto3_doc_link`, which must be set using the `set_boto3_doc_link` method before accessing this property.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class Function:"
      },
      "Function.set_boto3_doc_link": {
        "code": "    def set_boto3_doc_link(self, link: str) -> None:\n        \"\"\"Set the link to the boto3 documentation for this function.\n\nParameters:\n    link (str): A string representing the URL to the boto3 documentation associated with the function.\n\nReturns:\n    None: This method does not return a value.\n\nThe method updates the private attribute `_boto3_doc_link`, which stores the link to the boto3 documentation. If this link is not set, other methods like `boto3_doc_link` may raise a `BuildInternalError` when attempting to access it.\"\"\"\n        '\\n        Set link to boto3 docs.\\n        '\n        self._boto3_doc_link = link",
        "docstring": "Set the link to the boto3 documentation for this function.\n\nParameters:\n    link (str): A string representing the URL to the boto3 documentation associated with the function.\n\nReturns:\n    None: This method does not return a value.\n\nThe method updates the private attribute `_boto3_doc_link`, which stores the link to the boto3 documentation. If this link is not set, other methods like `boto3_doc_link` may raise a `BuildInternalError` when attempting to access it.",
        "signature": "def set_boto3_doc_link(self, link: str) -> None:",
        "type": "Method",
        "class_signature": "class Function:"
      },
      "Function.create_request_type_annotation": {
        "code": "    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"Create and set the `request_type_annotation` as a TypedDict derived from the function's arguments. This method iterates through the function's `arguments`, skipping any that are keyword flags or lack type annotations. For each valid argument, it adds an attribute to the resulting TypedDict, marking it as required based on the argument's `required` attribute. If no attributes are added to the TypedDict, the request type annotation is not set. The `name` parameter serves as the identifier for the TypedDict, which is expected to be a string. This method directly interacts with the `TypeTypedDict` class, which is responsible for creating and managing the TypedDict structure used in the process.\"\"\"\n        '\\n        Create and set `request_type_annotation` TypedDict based on function arguments.\\n        '\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(argument.name, argument.type_annotation, required=argument.required)\n        if not result.children:\n            return\n        self.request_type_annotation = result",
        "docstring": "Create and set the `request_type_annotation` as a TypedDict derived from the function's arguments. This method iterates through the function's `arguments`, skipping any that are keyword flags or lack type annotations. For each valid argument, it adds an attribute to the resulting TypedDict, marking it as required based on the argument's `required` attribute. If no attributes are added to the TypedDict, the request type annotation is not set. The `name` parameter serves as the identifier for the TypedDict, which is expected to be a string. This method directly interacts with the `TypeTypedDict` class, which is responsible for creating and managing the TypedDict structure used in the process.",
        "signature": "def create_request_type_annotation(self, name: str) -> None:",
        "type": "Method",
        "class_signature": "class Function:"
      },
      "Function.is_kw_only": {
        "code": "    def is_kw_only(self) -> bool:\n        \"\"\"Determine if the function's arguments can be specified only as keyword arguments (kwargs). \nThis method checks if the function has any arguments and retrieves the first argument \nto verify if it is a keyword-only argument using the `is_kwflag` method. If the function \nhas no arguments, it returns False.\n\nReturns:\n    bool: True if all arguments can only be passed as kwargs, otherwise False.\"\"\"\n        '\\n        Whether method arguments can be passed only as kwargs.\\n        '\n        if not self.has_arguments():\n            return False\n        first_argument = next(self.iterate_call_arguments())\n        return first_argument.is_kwflag()",
        "docstring": "Determine if the function's arguments can be specified only as keyword arguments (kwargs). \nThis method checks if the function has any arguments and retrieves the first argument \nto verify if it is a keyword-only argument using the `is_kwflag` method. If the function \nhas no arguments, it returns False.\n\nReturns:\n    bool: True if all arguments can only be passed as kwargs, otherwise False.",
        "signature": "def is_kw_only(self) -> bool:",
        "type": "Method",
        "class_signature": "class Function:"
      }
    },
    "mypy_boto3_builder/type_annotations/type_constant.py": {
      "TypeConstant.__init__": {
        "code": "    def __init__(self, value: ValueType) -> None:\n        \"\"\"Initialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None.\n\nAttributes:\n    self.value (ValueType): Stores the provided constant value.\n\nThe class interacts with the `Ellipsis` constant defined in the class scope, which is an instance of `EllipsisType` used to handle the specific case of the `...` placeholder in type annotations.\"\"\"\n        self.value: ValueType = value",
        "docstring": "Initialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None.\n\nAttributes:\n    self.value (ValueType): Stores the provided constant value.\n\nThe class interacts with the `Ellipsis` constant defined in the class scope, which is an instance of `EllipsisType` used to handle the specific case of the `...` placeholder in type annotations.",
        "signature": "def __init__(self, value: ValueType) -> None:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/structures/argument.py:Argument:self": {},
    "mypy_boto3_builder/structures/function.py:Function:is_kw_only": {
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.is_kwflag": {
          "code": "    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == '*'",
          "docstring": "Whether argument is a `*` keywords separator.",
          "signature": "def is_kwflag(self) -> bool:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      }
    },
    "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {},
    "mypy_boto3_builder/structures/method.py:Method:iterate_call_arguments": {
      "mypy_boto3_builder/structures/method.py": {
        "Method.get_self_argument": {
          "code": "    def get_self_argument(self) -> Argument | None:\n        \"\"\"\n        Get `self` or `cls` argument.\n        \"\"\"\n        if not self.arguments:\n            return None\n        first_argument = self.arguments[0]\n        if first_argument.name in Argument.FIRST_NAMES:\n            return first_argument\n        return None",
          "docstring": "Get `self` or `cls` argument.",
          "signature": "def get_self_argument(self) -> Argument | None:",
          "type": "Method",
          "class_signature": "class Method(Function):"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.iterate_call_arguments": {
          "code": "    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in function call.\n        \"\"\"\n        yield from self.arguments",
          "docstring": "Iterate over arguments that are used in function call.",
          "signature": "def iterate_call_arguments(self) -> Iterator[Argument]:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      }
    },
    "mypy_boto3_builder/structures/method.py:Method:iterate_packed_arguments": {
      "mypy_boto3_builder/structures/function.py": {
        "Function.iterate_packed_arguments": {
          "code": "    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only functions.\n        \"\"\"\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from self.arguments\n            return\n        yield Argument(name='kwargs', type_annotation=Type.unpack(self.request_type_annotation), prefix='**')",
          "docstring": "Iterate over packed arguments for KW-only functions.",
          "signature": "def iterate_packed_arguments(self) -> Iterator[Argument]:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/structures/method.py": {
        "Method.get_self_argument": {
          "code": "    def get_self_argument(self) -> Argument | None:\n        \"\"\"\n        Get `self` or `cls` argument.\n        \"\"\"\n        if not self.arguments:\n            return None\n        first_argument = self.arguments[0]\n        if first_argument.name in Argument.FIRST_NAMES:\n            return first_argument\n        return None",
          "docstring": "Get `self` or `cls` argument.",
          "signature": "def get_self_argument(self) -> Argument | None:",
          "type": "Method",
          "class_signature": "class Method(Function):"
        }
      }
    },
    "mypy_boto3_builder/structures/function.py:Function:create_request_type_annotation": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypeTypedDict.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        children: Iterable[TypedDictAttribute] = (),\n        docstring: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True",
          "docstring": "",
          "signature": "def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        },
        "TypeTypedDict.add_attribute": {
          "code": "    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))",
          "docstring": "Add new attribute to a dictionary.\n\nArguments:\n    name -- Argument name.\n    type_annotation -- Argument type annotation.\n    required -- Whether argument has to be set.",
          "signature": "def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.is_kwflag": {
          "code": "    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == '*'",
          "docstring": "Whether argument is a `*` keywords separator.",
          "signature": "def is_kwflag(self) -> bool:",
          "type": "Method",
          "class_signature": "class Argument:"
        },
        "Argument.required": {
          "code": "    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None",
          "docstring": "Whether argument does not have a default value and is required.",
          "signature": "def required(self) -> bool:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      }
    },
    "mypy_boto3_builder/structures/method.py:Method:has_arguments": {
      "mypy_boto3_builder/structures/function.py": {
        "Function.has_arguments": {
          "code": "    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether function has arguments.\n        \"\"\"\n        return bool(self.arguments)",
          "docstring": "Whether function has arguments.",
          "signature": "def has_arguments(self) -> bool:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/structures/method.py": {
        "Method.get_self_argument": {
          "code": "    def get_self_argument(self) -> Argument | None:\n        \"\"\"\n        Get `self` or `cls` argument.\n        \"\"\"\n        if not self.arguments:\n            return None\n        first_argument = self.arguments[0]\n        if first_argument.name in Argument.FIRST_NAMES:\n            return first_argument\n        return None",
          "docstring": "Get `self` or `cls` argument.",
          "signature": "def get_self_argument(self) -> Argument | None:",
          "type": "Method",
          "class_signature": "class Method(Function):"
        }
      }
    }
  },
  "call_tree": {
    "tests/structures/test_method.py:TestMethod:setup_method": {
      "mypy_boto3_builder/structures/argument.py:Argument:self": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {},
      "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
      "mypy_boto3_builder/structures/function.py:Function:__init__": {}
    },
    "tests/structures/test_method.py:TestMethod:test_set_boto3_doc_link": {
      "mypy_boto3_builder/structures/function.py:Function:set_boto3_doc_link": {},
      "mypy_boto3_builder/structures/function.py:Function:boto3_doc_link": {}
    },
    "tests/structures/test_method.py:TestMethod:test_is_kw_only": {
      "mypy_boto3_builder/structures/function.py:Function:is_kw_only": {
        "mypy_boto3_builder/structures/method.py:Method:has_arguments": {
          "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {}
        },
        "mypy_boto3_builder/structures/method.py:Method:iterate_call_arguments": {
          "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {},
          "mypy_boto3_builder/structures/function.py:Function:iterate_call_arguments": {}
        },
        "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:self": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
    },
    "tests/structures/test_method.py:TestMethod:test_iterate_call_arguments": {
      "mypy_boto3_builder/structures/method.py:Method:iterate_call_arguments": {
        "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {},
        "mypy_boto3_builder/structures/function.py:Function:iterate_call_arguments": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
      "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      }
    },
    "tests/structures/test_method.py:TestMethod:test_iterate_packed_arguments": {
      "mypy_boto3_builder/structures/method.py:Method:iterate_packed_arguments": {
        "mypy_boto3_builder/structures/function.py:Function:is_kw_only": {
          "mypy_boto3_builder/structures/method.py:Method:has_arguments": {
            "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {}
          },
          "mypy_boto3_builder/structures/method.py:Method:iterate_call_arguments": {
            "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {},
            "mypy_boto3_builder/structures/function.py:Function:iterate_call_arguments": {}
          },
          "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
        },
        "mypy_boto3_builder/structures/function.py:Function:iterate_packed_arguments": {
          "mypy_boto3_builder/structures/function.py:Function:is_kw_only": {
            "mypy_boto3_builder/structures/method.py:Method:has_arguments": {
              "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {}
            },
            "mypy_boto3_builder/structures/method.py:Method:iterate_call_arguments": {
              "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {},
              "mypy_boto3_builder/structures/function.py:Function:iterate_call_arguments": {}
            },
            "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
          },
          "mypy_boto3_builder/type_annotations/type.py:Type:unpack": {
            "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {}
          },
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:self": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
      "mypy_boto3_builder/structures/function.py:Function:create_request_type_annotation": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
        "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {},
        "mypy_boto3_builder/structures/argument.py:Argument:required": {},
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
        }
      }
    },
    "tests/structures/test_method.py:TestMethod:test_has_arguments": {
      "mypy_boto3_builder/structures/method.py:Method:has_arguments": {
        "mypy_boto3_builder/structures/method.py:Method:get_self_argument": {},
        "mypy_boto3_builder/structures/function.py:Function:has_arguments": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:self": {
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
      },
      "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_method\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 structures/\n    \u2502   \u251c\u2500\u2500 argument.py\n    \u2502   \u2502   \u251c\u2500\u2500 Argument.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 Argument.kwflag\n    \u2502   \u2502   \u2514\u2500\u2500 Argument.self\n    \u2502   \u251c\u2500\u2500 function.py\n    \u2502   \u2502   \u251c\u2500\u2500 Function.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 Function.boto3_doc_link\n    \u2502   \u2502   \u251c\u2500\u2500 Function.create_request_type_annotation\n    \u2502   \u2502   \u251c\u2500\u2500 Function.is_kw_only\n    \u2502   \u2502   \u2514\u2500\u2500 Function.set_boto3_doc_link\n    \u2502   \u2514\u2500\u2500 method.py\n    \u2502       \u251c\u2500\u2500 Method.has_arguments\n    \u2502       \u251c\u2500\u2500 Method.iterate_call_arguments\n    \u2502       \u2514\u2500\u2500 Method.iterate_packed_arguments\n    \u2514\u2500\u2500 type_annotations/\n        \u2514\u2500\u2500 type_constant.py\n            \u2514\u2500\u2500 TypeConstant.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates dynamic creation, manipulation, and validation of method objects for use in Python-based code generation, particularly in the context of boto3 type annotations. It provides core capabilities such as defining method structures with arguments, decorators, return types, body content, and documentation links. Additionally, it supports functionality for evaluating method arguments, including keyword-only flags, call argument iteration, and packed argument grouping. By enabling flexible and programmatic handling of method metadata, the module streamlines the generation of strongly-typed Python code and resolves challenges in automating method documentation and validation for APIs or SDKs.\n\n## FILE 1: mypy_boto3_builder/structures/method.py\n\n- CLASS METHOD: Method.iterate_call_arguments\n  - CLASS SIGNATURE: class Method(Function):\n  - SIGNATURE: def iterate_call_arguments(self) -> Iterator[Argument]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over arguments that are used in method calls, excluding the `self` or `cls` argument. \n\nThis method retrieves the `self` or `cls` argument using the `get_self_argument()` method and then yields the remaining arguments by iterating over the arguments obtained from the superclass's `iterate_call_arguments()` method. If the `self` or `cls` argument is found among the arguments, it is skipped.\n\nReturns:\n    An iterator of `Argument` instances representing the method's call arguments, excluding the self/cls argument.\n\nDependencies:\n- `self.get_self_argument()` retrieves the first argument to determine if it is `self` or `cls`.\n- `super().iterate_call_arguments()` is called to access the base implementation for iterating over all arguments.\n\"\"\"\n```\n\n- CLASS METHOD: Method.iterate_packed_arguments\n  - CLASS SIGNATURE: class Method(Function):\n  - SIGNATURE: def iterate_packed_arguments(self) -> Iterator[Argument]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over packed arguments for keyword-only methods.\n\nThis method yields packed arguments when the method is keyword-only and accompanied by a request type annotation. It first checks whether the method is keyword-only (`is_kw_only()`) and if a request type annotation is present. If either condition is not met, it yields the packed arguments directly from the superclass's method. If the method has a 'self' or 'cls' argument (obtained from `get_self_argument()`), it yields that first before the packed arguments.\n\nReturns:\n    Iterator[Argument]: An iterator over the packed arguments, including the 'self' or 'cls' argument if applicable.\n\nDependencies:\n- `super().iterate_packed_arguments()`: Invoked to retrieve packed arguments from the parent `Function` class.\n- `is_kw_only()`: Checks if the method is defined with keyword-only arguments.\n- `request_type_annotation`: A property that determines if a type annotation is present.\n- `get_self_argument()`: A method that retrieves the first argument (if it is 'self' or 'cls').\n\"\"\"\n```\n\n- CLASS METHOD: Method.has_arguments\n  - CLASS SIGNATURE: class Method(Function):\n  - SIGNATURE: def has_arguments(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the method has any arguments.\n\nThis method checks if the current method instance has arguments by inspecting its arguments list. It first attempts to retrieve the 'self' or 'cls' argument using the `get_self_argument` method. If no such argument is found, it delegates the check to the superclass method by calling `super().has_arguments()`. If a 'self' or 'cls' argument is present, it checks if there is more than one argument beyond that. \n\nReturns:\n    bool: True if the method has arguments, otherwise False.\n\nDependencies:\n- `self.get_self_argument()`: Retrieves the first argument (if any) to determine if it's a method that includes a 'self' or 'cls' parameter.\n- `super().has_arguments()`: This is called if no 'self' or 'cls' argument is found, leveraging the behavior defined in the superclass (`Function`).\n- `self.arguments`: An attribute inherited from the `Function` class, which is a list of argument instances, crucial for determining the number of arguments present.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/structures/argument.py\n\n- CLASS METHOD: Argument.__init__\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an Argument instance representing a method or function parameter.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): An optional type annotation for the argument; it can be a `FakeAnnotation` or `None`.\n- default (TypeConstant | None): An optional default value for the argument, which can be a `TypeConstant` or `None`.\n- prefix (Literal[\"*\", \"**\", \"\"]): A string indicating if the argument is a positional (*), keyword (**), or regular argument; defaults to an empty string.\n\nThis constructor sets the `name`, `type_annotation`, `default`, and `prefix` attributes of the `Argument` instance. The constants `SELF_NAME`, `CLS_NAME`, and `KW_NAME` defined in the `Argument` class can be used to create standard argument types like `self`, `cls`, and keyword separators. The prefixes help differentiate between various argument types in a function signature.\n\"\"\"\n```\n\n- CLASS METHOD: Argument.kwflag\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def kwflag(cls) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a representation of the `*` keyword argument separator for method signatures.\n\nThis class method constructs an `Argument` instance with the name set to `*`, serving as a special marker in Python function definitions to indicate that any following parameters must be passed as keyword arguments. It does not accept any type annotation, as it is used solely for handling variable keyword arguments.\n\nReturns:\n    An instance of `Argument` configured as a keyword separator.\n\nConstants:\n    - `KW_NAME`: A class-level constant that holds the string \"*\" to represent the keyword argument separator. It is defined in the `Argument` class.\n\"\"\"\n```\n\n- CLASS METHOD: Argument.self\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def self(cls) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a `self` argument for use in method definitions.\n\nReturns:\n    An instance of the `Argument` class initialized with:\n        - `name` set to the constant `SELF_NAME`, which is defined as 'self' in the class.\n        - `type_annotation` set to `None`, indicating no type annotation is provided.\n\nThis method utilizes the `SELF_NAME` constant (defined as a class-level constant) to establish the standard representation of the `self` parameter in class methods, ensuring consistency across instances of the `Argument` class.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/structures/function.py\n\n- CLASS METHOD: Function.boto3_doc_link\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the link to the Boto3 documentation for this function.\n\nRaises a BuildInternalError if the documentation link has not been set, indicating that the function lacks an associated Boto3 documentation link. The documentation link is stored in the private attribute `_boto3_doc_link`, which must be set using the `set_boto3_doc_link` method before accessing this property.\n\"\"\"\n```\n\n- CLASS METHOD: Function.__init__\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new Function instance.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument instances representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): A descriptive string for the function's documentation. Defaults to an empty string.\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators to be applied to the function. Defaults to an empty tuple.\n- body_lines (Iterable[str], optional): A collection of strings representing the body of the function. Defaults to an empty tuple.\n- type_ignore (bool, optional): A flag indicating whether to ignore type checking for this function. Defaults to False.\n- is_async (bool, optional): A flag indicating whether the function is asynchronous. Defaults to False.\n- boto3_doc_link (str, optional): A link to the boto3 documentation relevant to this function. Defaults to an empty string.\n\nAttributes:\n- self.request_type_annotation (TypeTypedDict | None): A TypedDict representing the request type annotation, initialized as None and later created based on function arguments.\n- self._boto3_doc_link (str): Stores the link to the boto3 documentation, must be set to use boto3_doc_link property.\n\nThis constructor sets up a Function instance with all necessary attributes for representing a Python function, including its signature and associated metadata for type handling and documentation.\n\"\"\"\n```\n\n- CLASS METHOD: Function.set_boto3_doc_link\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def set_boto3_doc_link(self, link: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nSet the link to the boto3 documentation for this function.\n\nParameters:\n    link (str): A string representing the URL to the boto3 documentation associated with the function.\n\nReturns:\n    None: This method does not return a value.\n\nThe method updates the private attribute `_boto3_doc_link`, which stores the link to the boto3 documentation. If this link is not set, other methods like `boto3_doc_link` may raise a `BuildInternalError` when attempting to access it.\n\"\"\"\n```\n\n- CLASS METHOD: Function.is_kw_only\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def is_kw_only(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the function's arguments can be specified only as keyword arguments (kwargs). \nThis method checks if the function has any arguments and retrieves the first argument \nto verify if it is a keyword-only argument using the `is_kwflag` method. If the function \nhas no arguments, it returns False.\n\nReturns:\n    bool: True if all arguments can only be passed as kwargs, otherwise False.\n\"\"\"\n```\n\n- CLASS METHOD: Function.create_request_type_annotation\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def create_request_type_annotation(self, name: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate and set the `request_type_annotation` as a TypedDict derived from the function's arguments. This method iterates through the function's `arguments`, skipping any that are keyword flags or lack type annotations. For each valid argument, it adds an attribute to the resulting TypedDict, marking it as required based on the argument's `required` attribute. If no attributes are added to the TypedDict, the request type annotation is not set. The `name` parameter serves as the identifier for the TypedDict, which is expected to be a string. This method directly interacts with the `TypeTypedDict` class, which is responsible for creating and managing the TypedDict structure used in the process.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/type_annotations/type_constant.py\n\n- CLASS METHOD: TypeConstant.__init__\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def __init__(self, value: ValueType) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None.\n\nAttributes:\n    self.value (ValueType): Stores the provided constant value.\n\nThe class interacts with the `Ellipsis` constant defined in the class scope, which is an instance of `EllipsisType` used to handle the specific case of the `...` placeholder in type annotations.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/structures/method.py": "\"\"\"\nClass method.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterator\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.function import Function\n\nclass Method(Function):\n    \"\"\"\n    Class method.\n    \"\"\"\n\n    def get_self_argument(self) -> Argument | None:\n        \"\"\"\n        Get `self` or `cls` argument.\n        \"\"\"\n        if not self.arguments:\n            return None\n        first_argument = self.arguments[0]\n        if first_argument.name in Argument.FIRST_NAMES:\n            return first_argument\n        return None",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n    SELF_NAME: Final = 'self'\n    CLS_NAME: Final = 'cls'\n    KW_NAME: Final = '*'\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f' = {self.default.render()}' if self.default is not None else ''\n        if not self.type_annotation:\n            return f'{self.name}{default_suffix}'\n        return f'{self.name}: {self.type_annotation.render()}{default_suffix}'\n\n    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == '*'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(name=self.name, type_annotation=self.type_annotation.copy() if self.type_annotation else None, default=self.default.copy() if self.default else None, prefix=self.prefix)",
    "mypy_boto3_builder/structures/function.py": "\"\"\"\nModule-level function.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\n\nclass Function:\n    \"\"\"\n    Module-level function.\n    \"\"\"\n\n    def has_boto3_doc_link(self) -> bool:\n        \"\"\"\n        Whether boto3_doc_link is set.\n        \"\"\"\n        return bool(self._boto3_doc_link)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Represent as a valid Python function signature.\n        \"\"\"\n        return f'{('async ' if self.is_async else '')}def {self.name}({', '.join((argument.render() for argument in self.arguments))}) -> {self.return_type.render()}'\n\n    @property\n    def short_docstring(self) -> str:\n        \"\"\"\n        Docstring without documentation links.\n        \"\"\"\n        if not self.docstring:\n            return self.docstring\n        short_docstring = self.docstring.strip().split('\\n\\n')[0]\n        if short_docstring.startswith('['):\n            return ''\n        return short_docstring\n\n    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only functions.\n        \"\"\"\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from self.arguments\n            return\n        yield Argument(name='kwargs', type_annotation=Type.unpack(self.request_type_annotation), prefix='**')\n\n    @property\n    def body(self) -> str:\n        \"\"\"\n        Function body as a string.\n        \"\"\"\n        return '\\n'.join(self.body_lines)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over required type annotations.\n        \"\"\"\n        yield from self.return_type.iterate_types()\n        for argument in self.iterate_packed_arguments():\n            yield from argument.iterate_types()\n        for decorator in self.decorators:\n            yield from decorator.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract required import records.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n        return result\n\n    @property\n    def returns_none(self) -> bool:\n        \"\"\"\n        Whether return type is None.\n        \"\"\"\n        return self.return_type == Type.none\n\n    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in function call.\n        \"\"\"\n        yield from self.arguments\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        result.extend((argument.type_annotation for argument in self.arguments if argument.type_annotation and argument.type_annotation.get_local_types()))\n        if self.return_type and self.return_type.get_local_types():\n            result.append(self.return_type)\n        return result\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return self.__class__(name=self.name, arguments=[i.copy() for i in self.arguments], return_type=self.return_type.copy(), docstring=self.docstring, decorators=[i.copy() for i in self.decorators], body_lines=list(self.body_lines), type_ignore=self.type_ignore, is_async=self.is_async)\n\n    def remove_argument(self, *names: str) -> Self:\n        \"\"\"\n        Remove argument by name or names.\n        \"\"\"\n        remove = [arg for arg in self.arguments if arg.name in names]\n        for argument in remove:\n            self.arguments.remove(argument)\n        return self\n\n    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether function has arguments.\n        \"\"\"\n        return bool(self.arguments)",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import Final, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\nValueType = str | int | float | EllipsisType | None\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n    Ellipsis: Final[EllipsisType] = EllipsisType()\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.value is self.Ellipsis:\n            return '...'\n        return repr(self.value)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.value)"
  }
}