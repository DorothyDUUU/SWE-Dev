{
  "dir_path": "/app/amazon_textract_textractor",
  "package_name": "amazon_textract_textractor",
  "sample_name": "amazon_textract_textractor-test_page",
  "src_dir": "textractor/",
  "test_dir": "tests/",
  "test_file": "tests/test_page.py",
  "test_code": "import json\nimport os\nimport unittest\nimport PIL\nfrom tests.utils import get_fixture_path\nfrom textractor import Textractor\nfrom textractor.entities.document import Document\nfrom textractor.entities.word import Word\nfrom textractor.entities.line import Line\nfrom textractor.entities.page import Page\nfrom textractor.entities.table import Table\nfrom textractor.entities.value import Value\nfrom textractor.data.constants import TableFormat\nfrom textractor.entities.key_value import KeyValue\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.exceptions import InvalidProfileNameError\nfrom textractor.entities.selection_element import SelectionElement\nfrom textractor.data.constants import TextTypes, SimilarityMetric, TextractFeatures, Direction, DirectionalFinderType\n\nfrom .utils import save_document_to_fixture_path\n\ntry:\n    import sentence_transformers\n    SENTENCE_TRANSFORMERS_AVAILABLE = True\nexcept:\n    SENTENCE_TRANSFORMERS_AVAILABLE = False \n\nclass TestPage(unittest.TestCase):\n    def test_page(self):\n        profile_name = \"default\"\n        current_directory = os.path.abspath(os.path.dirname(__file__))\n\n        if profile_name is None:\n            raise InvalidProfileNameError(\n                \"Textractor could not be initialized. Populate profile_name with a valid input in tests/test_table.py.\"\n            )\n\n        if os.environ.get(\"CALL_TEXTRACT\"):\n            extractor = Textractor(profile_name=profile_name, kms_key_id=\"\")\n            document = extractor.analyze_document(\n                file_source=os.path.join(current_directory, \"fixtures/single-page-1.png\"),\n                features=[TextractFeatures.TABLES, TextractFeatures.FORMS],\n            )\n            with open(get_fixture_path(), \"w\") as f:\n                json.dump(document.response, f)\n        else:\n            document = Document.open(get_fixture_path())\n\n        page = document.page(0)\n\n        self.assertIsInstance(page.words, EntityList)\n        self.assertIsInstance(page.words[0], Word)\n        self.assertEqual(len(page.words), 51)\n\n        self.assertIsInstance(page.lines, EntityList)\n        self.assertIsInstance(page.lines[0], Line)\n        self.assertEqual(len(page.lines), 24)\n\n        self.assertIsInstance(page.key_values, EntityList)\n        self.assertIsInstance(page.key_values[0], KeyValue)\n        self.assertIsInstance(page.key_values[0].value, Value)\n        self.assertEqual(len(page.key_values), 3)\n        self.assertIsInstance(page.key_values.pretty_print(), str)\n        self.assertGreater(len(page.tables.pretty_print(table_format=TableFormat.CSV)), 100)\n\n\n        self.assertIsInstance(page.checkboxes, EntityList)\n        self.assertIsInstance(page.checkboxes[0], KeyValue)\n        self.assertIsInstance(page.checkboxes[0].value, Value)\n        self.assertEqual(page.checkboxes[0].value.words, [])\n        self.assertIsInstance(page.checkboxes[0].value.children[0], SelectionElement)\n        self.assertEqual(len(page.checkboxes), 2)\n\n        self.assertIsInstance(page.tables, EntityList)\n        self.assertEqual(len(page.tables), 1)\n        self.assertIsInstance(page.tables.pretty_print(), str)\n        self.assertGreater(len(page.tables.pretty_print()), 100)\n\n        self.assertEqual(\n            page.__repr__(),\n            \"This Page (1) holds the following data:\\nWords - 51\\nLines - 24\\nKey-values - 3\\nCheckboxes - 2\\nTables - 1\\nQueries - 0\\nSignatures - 0\\nExpense documents - 0\\nLayout elements - 11\"\n        )\n\n        self.assertEqual(len(page.keys(include_checkboxes=True)), 5)\n        self.assertEqual(len(page.keys(include_checkboxes=False)), 3)\n\n        self.assertEqual(len(page.filter_checkboxes(selected=True, not_selected=True)), 2)\n        self.assertEqual(len(page.filter_checkboxes(selected=True, not_selected=False)), 1)\n        self.assertEqual(len(page.filter_checkboxes(selected=False, not_selected=True)), 1)\n        self.assertEqual(len(page.filter_checkboxes(selected=False, not_selected=False)), 0)\n\n        self.assertIsInstance(page.get_words_by_type(), EntityList)\n        self.assertIsInstance(page.get_words_by_type()[0], Word)\n        self.assertEqual(len(page.get_words_by_type(TextTypes.PRINTED)), 51)\n        self.assertEqual(len(page.get_words_by_type(TextTypes.HANDWRITING)), 0)\n\n        if SENTENCE_TRANSFORMERS_AVAILABLE:\n            self.assertIsInstance(\n                page.search_words(\n                    keyword=\"Table\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                ),\n                EntityList,\n            )\n            self.assertIsInstance(\n                page.search_words(\n                    keyword=\"Table\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                )[0],\n                Word,\n            )\n            self.assertIsInstance(\n                page.search_words(\n                    keyword=\"Table\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.EUCLIDEAN,\n                    similarity_threshold=0.6,\n                )[0],\n                Word,\n            )\n            self.assertEqual(\n                len(\n                    page.search_words(\n                        keyword=\"Table\",\n                        top_k=5,\n                        similarity_metric=SimilarityMetric.COSINE,\n                        similarity_threshold=0.6,\n                    )\n                ),\n                1\n            )\n\n            self.assertIsInstance(\n                page.search_lines(\n                    keyword=\"Textractor\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                ),\n                EntityList,\n            )\n            self.assertIsInstance(\n                page.search_lines(\n                    keyword=\"Textractor\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                )[0],\n                Line,\n            )\n            self.assertIsInstance(\n                page.search_lines(\n                    keyword=\"Textractor\",\n                    top_k=5,\n                    similarity_metric=SimilarityMetric.EUCLIDEAN,\n                    similarity_threshold=0.6,\n                )[0],\n                Line,\n            )\n            self.assertEqual(\n                len(\n                    page.search_lines(\n                        keyword=\"Textractor\",\n                        top_k=5,\n                        similarity_metric=SimilarityMetric.COSINE,\n                        similarity_threshold=0.6,\n                    )\n                ),\n                2\n            )\n\n            self.assertIsInstance(\n                page.get(\n                    key=\"date\",\n                    top_k_matches=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                ),\n                EntityList,\n            )\n            self.assertIsInstance(\n                page.get(\n                    key=\"date\",\n                    top_k_matches=5,\n                    similarity_metric=SimilarityMetric.COSINE,\n                    similarity_threshold=0.6,\n                )[0],\n                KeyValue,\n            )\n            self.assertIsInstance(\n                page.get(\n                    key=\"date\",\n                    top_k_matches=5,\n                    similarity_metric=SimilarityMetric.EUCLIDEAN,\n                    similarity_threshold=0.6,\n                )[0],\n                KeyValue,\n            )\n            self.assertEqual(\n                len(\n                    page.get(\n                        key=\"date\",\n                        top_k_matches=5,\n                        similarity_metric=SimilarityMetric.COSINE,\n                        similarity_threshold=0.6,\n                    )\n                ),\n                1\n            )\n            self.assertEqual(\n                len(page.directional_finder(\n                    word_1 = \"key-values\",\n                    word_2 = \"table 1\",\n                    prefix = \"\",\n                    direction=Direction.BELOW,\n                    entities=[DirectionalFinderType.KEY_VALUE_SET, DirectionalFinderType.SELECTION_ELEMENT],\n                )),\n                3\n            )\n\n            self.assertEqual(len(page.directional_finder(\n                    word_1 = \"key-values\",\n                    word_2 = \"\",\n                    prefix = \"\",\n                    direction=Direction.LEFT,\n                    entities=[DirectionalFinderType.KEY_VALUE_SET, DirectionalFinderType.SELECTION_ELEMENT],\n                )), 0)\n\n            self.assertEqual(len(page.directional_finder(\n                    word_1 = \"key-values\",\n                    word_2 = \"\",\n                    prefix = \"\",\n                    direction=Direction.RIGHT,\n                    entities=[DirectionalFinderType.KEY_VALUE_SET, DirectionalFinderType.SELECTION_ELEMENT],\n                )), 3)\n\n            self.assertEqual(len(page.directional_finder(\n                    word_1 = \"key-values\",\n                    word_2 = \"\",\n                    prefix = \"\",\n                    direction=Direction.ABOVE,\n                    entities=[DirectionalFinderType.KEY_VALUE_SET, DirectionalFinderType.SELECTION_ELEMENT],\n                )), 0)\n\n        self.assertIsInstance(\n            page.search_words(\n                keyword=\"Table\",\n                top_k=5,\n                similarity_metric=SimilarityMetric.LEVENSHTEIN,\n                similarity_threshold=5,\n            )[0],\n            Word,\n        )\n        self.assertIsInstance(\n            page.get(\n                key=\"date\",\n                top_k_matches=5,\n                similarity_metric=SimilarityMetric.LEVENSHTEIN,\n                similarity_threshold=5,\n            )[0],\n            KeyValue,\n        )\n        self.assertIsInstance(\n            page.search_lines(\n                keyword=\"Textractor\",\n                top_k=5,\n                similarity_metric=SimilarityMetric.LEVENSHTEIN,\n                similarity_threshold=5,\n            )[0],\n            Line,\n        )\n\n        save_file_path = os.path.join(current_directory, \"Key-Values.csv\")\n        page.export_kv_to_csv(include_kv=True, include_checkboxes=True, filepath=save_file_path)\n        self.assertIn(\"Key-Values.csv\", os.listdir(current_directory))\n        os.remove(save_file_path)\n\n        save_file_path = os.path.join(current_directory, \"Key-Values.txt\")\n        page.export_kv_to_txt(include_kv=True, include_checkboxes=True, filepath=save_file_path)\n        self.assertIn(\"Key-Values.txt\", os.listdir(current_directory))\n        os.remove(save_file_path)\n\n        save_file_path = os.path.join(current_directory, \"Tables.xlsx\")\n        page.export_tables_to_excel(filepath=save_file_path)\n        self.assertIn(\"Tables.xlsx\", os.listdir(current_directory))\n        os.remove(save_file_path)\n\n        self.assertEqual(len(page.independent_words()), 10)\n        self.assertIsInstance(page.independent_words()[0], Word)\n\n        self.assertIsInstance(page.independent_words(), EntityList)\n        self.assertIsInstance(page.independent_words()[0], Word)\n\n        self.assertIsInstance(page.return_duplicates(), list)\n        self.assertIsInstance(page.return_duplicates()[0], EntityList)\n",
  "GT_file_code": {
    "textractor/entities/document_entity.py": "\"\"\":class:`DocumentEntity` is the class that all Document entities such as :class:`Word`, :class:`Line`, :class:`Table` etc. inherit from. This class provides methods \nuseful to all such entities.\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Tuple\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.data.markdown_linearization_config import MarkdownLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\nclass DocumentEntity(Linearizable, ABC):\n    \"\"\"\n    An interface for all document entities within the document body, composing the\n    hierarchy of the document object model.\n    The purpose of this class is to define properties common to all document entities\n    i.e. unique id and bounding box.\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\n        child entities within a document entity.\n\n        :param entity_id: Unique identifier of the document entity.\n        :param bbox: Bounding box of the entity\n        \"\"\"\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}  # Holds optional information about the entity\n        self._children = []\n        self._children_type = None\n        self._raw_object = None\n\n    def add_children(self, children):\n        \"\"\"\n        Adds children to all entities that have parent-child relationships.\n\n        :param children: List of child entities.\n        :type children: list\n        \"\"\"\n        self._children.extend(children)\n\n    @property\n    def raw_object(self) -> Dict:\n        \"\"\"\n        :return: Returns the raw dictionary object that was used to create this Python object\n        :rtype: Dict\n        \"\"\"\n        return self._raw_object\n\n    @raw_object.setter\n    def raw_object(self, raw_object: Dict):\n        \"\"\"\n        Sets the raw object that was used to create this Python object\n        :param raw_object: raw object dictionary from the response\n        :type raw_object: Dict\n        \"\"\"\n        self._raw_object = raw_object\n\n    @property\n    def x(self) -> float:\n        \"\"\"\n        :return: Returns x coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.x\n\n    @x.setter\n    def x(self, x: float):\n        \"\"\"\n        Sets x coordinate for bounding box\n\n        :param x: x coordinate of the bounding box\n        :type x: float\n        \"\"\"\n        self._bbox.x = x\n\n    @property\n    def y(self) -> float:\n        \"\"\"\n        :return: Returns y coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.y\n\n    @y.setter\n    def y(self, y: float):\n        \"\"\"\n        Sets y coordinate for bounding box.\n\n        :param y: y coordinate of the bounding box\n        :type y: float\n        \"\"\"\n        self._bbox.y = y\n\n    @property\n    def width(self) -> float:\n        \"\"\"\n        :return: Returns width for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.width\n\n    @width.setter\n    def width(self, width: float):\n        \"\"\"\n        Sets width for bounding box.\n\n        :param width: width of the bounding box\n        :type width: float\n        \"\"\"\n        self._bbox.width = width\n\n    @property\n    def height(self) -> float:\n        \"\"\"\n        :return: Returns height for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.height\n\n    @height.setter\n    def height(self, height: float):\n        \"\"\"\n        Sets height for bounding box.\n\n        :param height: height of the bounding box\n        :type height: float\n        \"\"\"\n        self._bbox.height = height\n\n    @property\n    def bbox(self) -> BoundingBox:\n        \"\"\"\n        :return: Returns entire bounding box of entity\n        :rtype: BoundingBox\n        \"\"\"\n        return self._bbox\n\n    @bbox.setter\n    def bbox(self, bbox: BoundingBox):\n        self._bbox = bbox\n\n    @property\n    def children(self):\n        \"\"\"\n        :return: Returns children of entity\n        :rtype: list\n        \"\"\"\n        return self._children\n\n    @property\n    def confidence(self) -> float:\n        \"\"\"\n        Returns the object confidence as predicted by Textract. If the confidence is not available, returns None\n\n        :return: Prediction confidence for a document entity, between 0 and 1\n        :rtype: float\n        \"\"\"\n        \n        # Needed for backward compatibility\n        if hasattr(self, \"_confidence\"):\n            return self._confidence\n    \n        # Uses the raw response\n        if not hasattr(self, \"raw_object\"):\n            return None\n        confidence = self.raw_object.get(\"Confidence\")\n        if confidence is None:\n            return None            \n        return confidence / 100\n\n    def remove(self, entity):\n        \"\"\"\n        Recursively removes an entity from the child tree of a document entity and update its bounding box\n\n        :param entity: Entity\n        :type entity: DocumentEntity\n        \"\"\"\n\n        for c in self._children:\n            if entity == c:\n                # Element was found in children\n                break\n            if not c.__class__.__name__ == \"Word\" and c.remove(entity):\n                # Element was found and removed in grand-children\n                if not c.children:\n                    self._children.remove(c)\n                return True\n        else:\n            # Element was not found\n            return False\n        self._children.remove(c)\n        if self._children:\n            self.bbox = BoundingBox.enclosing_bbox(self._children)\n        return True\n\n    def visit(self, word_set):\n        for c in list(self._children):\n            if c.__class__.__name__ == \"Word\":\n                if c.id in word_set:\n                    self._children.remove(c)\n                else:\n                    word_set.add(c.id)\n            else:\n                c.visit(word_set)\n\n    def visualize(self, *args, **kwargs) -> EntityList:\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)\n",
    "textractor/entities/page.py": "\"\"\"\nRepresents a single :class:`Document` page, as it would appear in the Textract API output.\nThe :class:`Page` object also contains the metadata such as the physical dimensions of the page (width, height, in pixels), child_ids etc.\n\"\"\"\n\nimport os\nimport string\nimport logging\nimport xlsxwriter\nfrom typing import List, Tuple\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom textractor.entities.expense_document import ExpenseDocument\n\nfrom textractor.entities.word import Word\nfrom textractor.entities.line import Line\nfrom textractor.entities.table import Table\nfrom textractor.entities.signature import Signature\nfrom textractor.entities.layout import Layout\nfrom textractor.entities.page_layout import PageLayout\nfrom textractor.exceptions import InputError\nfrom textractor.entities.key_value import KeyValue\nfrom textractor.entities.query import Query\nfrom textractor.entities.identity_document import IdentityDocument\nfrom textractor.entities.bbox import SpatialObject\nfrom textractor.data.constants import SelectionStatus, Direction, DirectionalFinderType\nfrom textractor.data.constants import TextTypes, SimilarityMetric\nfrom textractor.data.constants import (\n    LAYOUT_TEXT,\n    LAYOUT_TITLE,\n    LAYOUT_HEADER,\n    LAYOUT_FOOTER,\n    LAYOUT_SECTION_HEADER,\n    LAYOUT_PAGE_NUMBER,\n    LAYOUT_LIST,\n    LAYOUT_FIGURE,\n    LAYOUT_TABLE,\n    LAYOUT_KEY_VALUE,\n)\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.selection_element import SelectionElement\nfrom textractor.utils.geometry_util import sort_by_position\nfrom textractor.utils.search_utils import SearchUtils, jaccard_similarity\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.entities.linearizable import Linearizable\n\n\nclass Page(SpatialObject, Linearizable):\n    \"\"\"\n    Creates a new document, ideally representing a single item in the dataset.\n\n    :param id: Unique id of the Page\n    :type id: str\n    :param width: Width of page, in pixels\n    :type width: float\n    :param height: Height of page, in pixels\n    :type height: float\n    :param page_num: Page number in the document linked to this Page object\n    :type page_num: int\n    :param child_ids: IDs of child entities in the Page as determined by Textract\n    :type child_ids: List\n    \"\"\"\n\n    def __init__(\n        self, id: str, width: int, height: int, page_num: int = -1, child_ids=None\n    ):\n        super().__init__(width=width, height=height)\n        self.id = id\n        self._words: EntityList[Word] = EntityList([])\n        self._lines: EntityList[Line] = EntityList([])\n        self._key_values: EntityList[KeyValue] = EntityList([])\n        self._checkboxes: EntityList[KeyValue] = EntityList([])\n        self._tables: EntityList[Table] = EntityList([])\n        self._queries: EntityList[Query] = EntityList([])\n        self._expense_documents: EntityList[ExpenseDocument] = EntityList([])\n        self._leaf_layouts: EntityList[Layout] = EntityList([])\n        self._container_layouts: EntityList[Layout] = EntityList([])\n        self.kv_cache = defaultdict(list)\n        self.metadata = {}\n        self.page_num = page_num\n        self.child_ids: List[str] = child_ids\n        self.image = None\n\n    # functions to add entities to the Page object\n    @property\n    def words(self) -> EntityList[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the Page.\n\n        :return: List of Word objects, each representing a word within the Page.\n        :rtype: EntityList[Word]\n        \"\"\"\n        return self._words\n\n    @words.setter\n    def words(self, words: List[Word]):\n        \"\"\"\n        Add Word objects to the Page.\n\n        :param words: List of Word objects, each representing a word within the page. No specific ordering is assumed.\n        :type words: List[Word]\n        \"\"\"\n        self._words = words\n        self._words = EntityList(sort_by_position(list(set(self._words))))\n\n    @property\n    def lines(self) -> EntityList[Line]:\n        \"\"\"\n        Returns all the :class:`Line` objects present in the Page.\n\n        :return: List of Line objects, each representing a line within the Page.\n        :rtype: EntityList[Line]\n        \"\"\"\n        return self._lines\n\n    @lines.setter\n    def lines(self, lines: List[Line]):\n        \"\"\"\n        Add Line objects to the Document.\n\n        :param lines: List of Line objects, each representing a line within the Page.\n        :type lines: List[Line]\n        \"\"\"\n        self._lines = EntityList(sort_by_position(lines))\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        Returns the page text\n\n        :return: Linearized page text\n        :rtype: str\n        \"\"\"\n        return self.get_text()\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ) -> Tuple[str, List[Word]]:\n        \"\"\"\n        Returns the page text and words sorted in reading order\n\n        :param config: Text linearization configuration object, defaults to TextLinearizationConfig()\n        :type config: TextLinearizationConfig, optional\n        :return: Tuple of page text and words\n        :rtype: Tuple[str, List[Word]]\n        \"\"\"\n        unsorted_layouts = [l for l in self.layouts if l.reading_order < 0]\n        sorted_layouts = [l for l in self.layouts if l.reading_order >= 0]\n        if unsorted_layouts:\n            for unsorted_layout in sorted(\n                unsorted_layouts, key=lambda x: (x.bbox.y, x.bbox.x)\n            ):\n                closest_layout = None\n                closest_reading_order_distance = None\n                for layout in sorted(sorted_layouts, key=lambda x: x.reading_order):\n                    dist = layout.bbox.get_distance(unsorted_layout)\n                    if (\n                        closest_reading_order_distance is None\n                        or dist < closest_reading_order_distance\n                    ):\n                        closest_layout = layout\n                if closest_layout:\n                    sorted_layouts.insert(\n                        sorted_layouts.index(closest_layout) + 1, unsorted_layout\n                    )\n                else:\n                    sorted_layouts.append(unsorted_layout)\n\n        page_texts_and_words = [l.get_text_and_words(config) for l in sorted_layouts]\n\n        if not page_texts_and_words:\n            return \"\", []\n\n        text, words = zip(*page_texts_and_words)\n        combined_words = []\n        for w in words:\n            combined_words += w\n        return config.layout_element_separator.join(text), combined_words\n\n    @property\n    def page_layout(self) -> PageLayout:\n        return PageLayout(\n            titles=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_TITLE]\n            ),\n            headers=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_HEADER]\n            ),\n            footers=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_FOOTER]\n            ),\n            section_headers=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_SECTION_HEADER]\n            ),\n            page_numbers=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_PAGE_NUMBER]\n            ),\n            lists=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_LIST]),\n            figures=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_FIGURE]\n            ),\n            tables=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_TABLE]\n            ),\n            key_values=EntityList(\n                [l for l in self.layouts if l.layout_type == LAYOUT_KEY_VALUE]\n            ),\n        )\n\n    @property\n    def key_values(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects present in the Page.\n\n        :return: List of KeyValue objects, each representing a key-value pair within the Page.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return self._key_values\n\n    @key_values.setter\n    def key_values(self, kv: List[KeyValue]):\n        \"\"\"\n        Add KeyValue objects to the Page.\n\n        :param kv: List of KeyValue objects, each representing a KV area within the document page.\n        :type kv: List[KeyValue]\n        \"\"\"\n        self._key_values = EntityList(sort_by_position(kv))\n\n    @property\n    def checkboxes(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects with :class:`SelectionElement` present in the Page.\n\n        :return: List of KeyValue objects, each representing a checkbox within the Page.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return self._checkboxes\n\n    @checkboxes.setter\n    def checkboxes(self, checkbox: List[KeyValue]):\n        \"\"\"\n        Add KeyValue objects containing SelectionElement children to the Page.\n\n        :param checkbox: List of KeyValue objects, each representing a checkbox area within the document page.\n        :type checkbox: List[KeyValue]\n        \"\"\"\n        self._checkboxes = EntityList(sort_by_position(checkbox))\n\n    @property\n    def tables(self) -> EntityList[Table]:\n        \"\"\"\n        Returns all the :class:`Table` objects present in the Page.\n\n        :return: List of Table objects, each representing a table within the Page.\n        :rtype: EntityList\n        \"\"\"\n        return self._tables\n\n    @tables.setter\n    def tables(self, tables: List[Table]):\n        \"\"\"\n        Add Table objects to the Page.\n\n        :param tables: List of Table objects, each representing a Table area within the document page.\n        :type tables: list\n        \"\"\"\n        self._tables = EntityList(tables)\n\n    @property\n    def queries(self) -> EntityList[Query]:\n        \"\"\"\n        Returns all the :class:`Query` objects present in the Page.\n\n        :return: List of Query objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._queries\n\n    @queries.setter\n    def queries(self, queries: List[Query]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._queries = EntityList(queries)\n\n    @property\n    def signatures(self) -> EntityList[Signature]:\n        \"\"\"\n        Returns all the :class:`Signature` objects present in the Page.\n\n        :return: List of Signature objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._signatures\n\n    @signatures.setter\n    def signatures(self, signatures: List[Signature]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._signatures = EntityList(signatures)\n\n    @property\n    def layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(\n            sorted(\n                self._leaf_layouts + self._container_layouts,\n                key=lambda c: c.reading_order,\n            )\n        )\n\n    @property\n    def leaf_layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the leaf :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._leaf_layouts\n\n    @leaf_layouts.setter\n    def leaf_layouts(self, leaf_layouts: List[Layout]):\n        \"\"\"\n        Add leaf layout objects to the Page.\n\n        :param layouts: List of Layout objects.\n        :type layouts: list\n        \"\"\"\n        self._leaf_layouts = EntityList(leaf_layouts)\n\n    @property\n    def container_layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the container :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._container_layouts\n\n    @container_layouts.setter\n    def container_layouts(self, container_layouts: List[Layout]):\n        \"\"\"\n        Add Layout objects to the Page.\n\n        :param layouts: List of Layout objects.\n        :type layouts: list\n        \"\"\"\n        self._container_layouts = EntityList(container_layouts)\n\n    @property\n    def expense_documents(self) -> EntityList[ExpenseDocument]:\n        \"\"\"\n        Returns all the :class:`ExpenseDocument` objects present in the Page.\n\n        :return: List of ExpenseDocument objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._expense_documents\n\n    @expense_documents.setter\n    def expense_documents(self, expense_documents: List[ExpenseDocument]):\n        \"\"\"\n        Add ExpenseDocument objects to the Page.\n\n        :param tables: List of ExpenseDocument objects.\n        :type expense_documents: list\n        \"\"\"\n        self._expense_documents = EntityList(expense_documents)\n\n    def __repr__(self):\n        return os.linesep.join(\n            [\n                f\"This Page ({self.page_num}) holds the following data:\",\n                f\"Words - {len(self.words)}\",\n                f\"Lines - {len(self.lines)}\",\n                f\"Key-values - {len(self.key_values)}\",\n                f\"Checkboxes - {len(self.checkboxes)}\",\n                f\"Tables - {len(self.tables)}\",\n                f\"Queries - {len(self.queries)}\",\n                f\"Signatures - {len(self.signatures)}\",\n                f\"Expense documents - {len(self.expense_documents)}\",\n                f\"Layout elements - {len(self.layouts)}\",\n            ]\n        )\n\n    def __getitem__(self, key):\n        output = self.get(key)\n        if output:\n            return output\n        raise KeyError(f\"{key} was not found in Document\")\n\n    def keys(self, include_checkboxes: bool = True) -> List[str]:\n        \"\"\"\n        Prints all keys for key-value pairs and checkboxes if the page contains them.\n\n        :param include_checkboxes: True/False. Set False if checkboxes need to be excluded.\n        :type include_checkboxes: bool\n\n        :return: List of strings containing key names in the Page\n        :rtype: List[str]\n        \"\"\"\n        keys = []\n        keys = [keyvalue.key for keyvalue in self.key_values]\n        if include_checkboxes:\n            keys += [keyvalue.key for keyvalue in self.checkboxes]\n        return keys\n\n    def filter_checkboxes(\n        self, selected: bool = True, not_selected: bool = True\n    ) -> EntityList[KeyValue]:\n        \"\"\"\n        Return a list of :class:`KeyValue` objects containing checkboxes if the page contains them.\n\n        :param selected: True/False Return SELECTED checkboxes\n        :type selected: bool\n        :param not_selected: True/False Return NOT_SELECTED checkboxes\n        :type not_selected: bool\n\n        :return: Returns checkboxes that match the conditions set by the flags.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        if not self.checkboxes:\n            logging.warning(f\"This document does not contain checkboxes\")\n            return []\n        else:\n            if selected and not_selected:\n                checkboxes = self.checkboxes\n                return EntityList(checkboxes)\n\n            checkboxes = []\n            if selected:\n                checkboxes = [\n                    kv\n                    for kv in self.checkboxes\n                    if kv.selection_status == SelectionStatus.SELECTED\n                ]\n            if not_selected:\n                checkboxes = [\n                    kv\n                    for kv in self.checkboxes\n                    if kv.selection_status == SelectionStatus.NOT_SELECTED\n                ]\n\n            return EntityList(checkboxes)\n\n    def get_words_by_type(\n        self, text_type: TextTypes = TextTypes.PRINTED\n    ) -> EntityList[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError(\n                \"text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants\"\n            )\n\n        if not self.words:\n            logging.warn(\"Document contains no word entities.\")\n            return []\n\n        filtered_words = [word for word in self.words if word.text_type == text_type]\n        return EntityList(filtered_words)\n\n    def _search_words_with_similarity(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ) -> List[Tuple[Word, float]]:\n        \"\"\"\n        Returns a list of top_k words with their similarity to the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str, required\n        :param top_k: Number of closest word objects to be returned. default=1\n        :type top_k: int, optional\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples containing similarity and Word.\n        :rtype: List[Tuple(float, Word)]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError(\n                \"similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants\"\n            )\n        top_n_words = []\n        similarity_threshold = (\n            similarity_threshold\n            if similarity_metric == SimilarityMetric.COSINE\n            else -(similarity_threshold)\n        )\n        lowest_similarity = similarity_threshold\n\n        for word in self.words:\n            similarity = SearchUtils.get_word_similarity(\n                keyword, word.text, similarity_metric\n            )\n            similarity = (\n                similarity\n                if similarity_metric == SimilarityMetric.COSINE\n                else -(similarity)\n            )\n\n            if len(top_n_words) < top_k and similarity > similarity_threshold:\n                top_n_words.append((similarity, word))\n            elif similarity > lowest_similarity:\n                top_n_words[-1] = (similarity, word)\n            else:\n                continue\n            top_n_words = sorted(top_n_words, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_words[-1][0]\n\n        return top_n_words\n\n    def search_words(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ) -> EntityList[Word]:\n        \"\"\"\n        Return a list of top_k words that match the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str, required\n        :param top_k: Number of closest word objects to be returned. default=1\n        :type top_k: int, optional\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of words that match the queried key sorted from highest to lowest similarity.\n        :rtype: EntityList[Word]\n        \"\"\"\n\n        top_n_words = EntityList(\n            [\n                ent[1]\n                for ent in self._search_words_with_similarity(\n                    keyword=keyword,\n                    top_k=top_k,\n                    similarity_metric=similarity_metric,\n                    similarity_threshold=similarity_threshold,\n                )\n            ]\n        )\n\n        return top_n_words\n\n    def _search_lines_with_similarity(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: int = 0.6,\n    ) -> List[Tuple[Line, float]]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the page.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples of lines and their similarity to the keyword that contain the queried key sorted\n                 from highest to lowest similarity.\n        :rtype: List[Tuple[Line, float]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError(\n                \"similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants\"\n            )\n\n        top_n_lines = []\n        similarity_threshold = (\n            similarity_threshold\n            if similarity_metric == SimilarityMetric.COSINE\n            else -(similarity_threshold)\n        )\n        lowest_similarity = similarity_threshold\n\n        for line in self.lines:\n            similarity = [\n                SearchUtils.get_word_similarity(keyword, word, similarity_metric)\n                for word in line.__repr__().split(\" \")\n            ]\n            similarity.append(\n                SearchUtils.get_word_similarity(\n                    keyword, line.__repr__(), similarity_metric\n                )\n            )\n            similarity = (\n                max(similarity)\n                if similarity_metric == SimilarityMetric.COSINE\n                else -min(similarity)\n            )\n\n            if len(top_n_lines) < top_k and similarity > similarity_threshold:\n                top_n_lines.append((similarity, line))\n            elif similarity > lowest_similarity:\n                top_n_lines[-1] = (similarity, line)\n            else:\n                continue\n            top_n_lines = sorted(top_n_lines, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_lines[-1][0]\n\n        return top_n_lines\n\n    def search_lines(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: int = 0.6,\n    ) -> EntityList[Line]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the page.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of lines that contain the queried key sorted\n                 from highest to lowest similarity.\n        :rtype: EntityList[Line]\n        \"\"\"\n\n        top_n_lines = EntityList(\n            [\n                ent[1]\n                for ent in self._search_lines_with_similarity(\n                    keyword=keyword,\n                    top_k=top_k,\n                    similarity_metric=similarity_metric,\n                    similarity_threshold=similarity_threshold,\n                )\n            ]\n        )\n\n        return top_n_lines\n\n    # KeyValue entity related functions\n    def get(\n        self,\n        key: str,\n        top_k_matches: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ) -> EntityList[KeyValue]:\n        \"\"\"\n        Return upto top_k_matches of key-value pairs for the key that is queried from the page.\n\n        :param key: Query key to match\n        :type key: str\n        :param top_k_matches: Maximum number of matches to return\n        :type top_k_matches: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of key-value pairs that match the queried key sorted from highest\n                 to lowest similarity.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError(\n                \"similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants\"\n            )\n\n        top_n = []\n        similarity_threshold = (\n            similarity_threshold\n            if similarity_metric == SimilarityMetric.COSINE\n            else -(similarity_threshold)\n        )\n        lowest_similarity = similarity_threshold\n\n        for kv in self.key_values + self.checkboxes:\n            try:\n                edited_document_key = \"\".join(\n                    [\n                        char\n                        for char in kv.key.__repr__()\n                        if char not in string.punctuation\n                    ]\n                )\n            except:\n                pass\n            key = \"\".join([char for char in key if char not in string.punctuation])\n\n            similarity = [\n                SearchUtils.get_word_similarity(key, word, similarity_metric)\n                for word in edited_document_key.split(\" \")\n            ]\n            similarity.append(\n                SearchUtils.get_word_similarity(\n                    key, edited_document_key, similarity_metric\n                )\n            )\n\n            similarity = (\n                max(similarity)\n                if similarity_metric == SimilarityMetric.COSINE\n                else -min(similarity)\n            )\n\n            if similarity > similarity_threshold:\n                if len(top_n) < top_k_matches:\n                    top_n.append((kv, similarity))\n                elif similarity > lowest_similarity:\n                    top_n[-1] = (kv, similarity)\n                top_n = sorted(top_n, key=lambda x: x[1], reverse=True)\n                lowest_similarity = top_n[-1][1]\n\n        if not top_n:\n            logging.warning(\n                f\"Query key does not match any existing keys in the document.{os.linesep}{self.keys()}\"\n            )\n\n        logging.info(f\"Query key matched {len(top_n)} key-values in the document.\")\n\n        return EntityList([value[0] for value in top_n])\n\n    # Export document entities into supported formats\n    def export_kv_to_csv(\n        self,\n        include_kv: bool = True,\n        include_checkboxes: bool = True,\n        filepath: str = \"Key-Values.csv\",\n    ):\n        \"\"\"\n        Export key-value entities and checkboxes in csv format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        \"\"\"\n        keys = []\n        values = []\n        if include_kv and not self.key_values:\n            logging.warning(\"Document does not contain key-values.\")\n        elif include_kv:\n            for kv in self.key_values:\n                keys.append(kv.key.__repr__())\n                values.append(kv.value.__repr__())\n\n        if include_checkboxes and not self.checkboxes:\n            logging.warning(\"Document does not contain checkbox elements.\")\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                keys.append(kv.key.__repr__())\n                values.append(kv.value.children[0].status.name)\n\n        with open(filepath, \"w\") as f:\n            f.write(f\"Key,Value{os.linesep}\")\n            for k, v in zip(keys, values):\n                f.write(f\"{k},{v}{os.linesep}\")\n\n        logging.info(\n            f\"csv file stored at location {os.path.join(os.getcwd(), filepath)}\"\n        )\n\n    def export_kv_to_txt(\n        self,\n        include_kv: bool = True,\n        include_checkboxes: bool = True,\n        filepath: str = \"Key-Values.txt\",\n    ):\n        \"\"\"\n        Export key-value entities and checkboxes in txt format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        \"\"\"\n        export_str = []\n        index = 1\n        if include_kv and not self.key_values:\n            logging.warning(\"Document does not contain key-values.\")\n        elif include_kv:\n            for kv in self.key_values:\n                export_str.append(\n                    f\"{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}\"\n                )\n                index += 1\n\n        if include_checkboxes and not self.checkboxes:\n            logging.warning(\"Document does not contain checkbox elements.\")\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                export_str.append(\n                    f\"{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}\"\n                )\n                index += 1\n\n        with open(filepath, \"w\") as text_file:\n            text_file.write(\"\".join(export_str))\n        logging.info(\n            f\"txt file stored at location {os.path.join(os.getcwd(),filepath)}\"\n        )\n\n    def independent_words(self) -> EntityList[Word]:\n        \"\"\"\n        :return: Return all words in the document, outside of tables, checkboxes, key-values.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.words:\n            logging.warning(\"Words have not been assigned to this Document object.\")\n            return []\n\n        else:\n            table_words = sum([table.words for table in self.tables], [])\n            kv_words = sum([kv.words for kv in self.key_values], [])\n            checkbox_words = sum([kv.words for kv in self.checkboxes], [])\n            dependent_words = table_words + checkbox_words + kv_words\n            dependent_word_ids = set([word.id for word in dependent_words])\n            independent_words = [\n                word for word in self.words if word.id not in dependent_word_ids\n            ]\n            return EntityList(independent_words)\n\n    def export_tables_to_excel(self, filepath):\n        \"\"\"\n        Creates an excel file and writes each table on a separate worksheet within the workbook.\n        This is stored on the filepath passed by the user.\n\n        :param filepath: Path to store the exported Excel file.\n        :type filepath: str, required\n        \"\"\"\n        if not filepath:\n            logging.error(\"Filepath required to store excel file.\")\n        workbook = xlsxwriter.Workbook(filepath)\n        for table in self.tables:\n            workbook = table.to_excel(\n                filepath=None, workbook=workbook, save_workbook=False\n            )\n        workbook.close()\n\n    def _update_entity_page_num(self):\n        \"\"\"Updates page number if Textractor API call was given a list of images.\"\"\"\n        entities = (\n            self.words + self.lines + self.key_values + self.checkboxes + self.tables\n        )\n        for entity in entities:\n            entity.page = self.page_num\n\n    def return_duplicates(self):\n        \"\"\"\n        Returns a list containing :class:`EntityList` objects.\n        Each :class:`EntityList` instance contains the key-values and the last item is the table which contains duplicate information.\n        This function is intended to let the Textract user know of duplicate objects extracted by the various Textract models.\n\n        :return: List of EntityList objects each containing the intersection of KeyValue and Table entities on the page.\n        :rtype: List[EntityList]\n        \"\"\"\n        tables = self.tables\n        key_values = self.key_values\n\n        document_duplicates = []\n\n        for table in tables:\n            table_duplicates = EntityList([])\n            table_x1, table_x2, table_y1, table_y2 = (\n                table.bbox.x,\n                table.bbox.x + table.bbox.width,\n                table.bbox.y,\n                table.bbox.y + table.bbox.height,\n            )\n            for kv in key_values:\n                if (\n                    kv.bbox.x >= table_x1\n                    and kv.bbox.x <= table_x2\n                    and kv.bbox.y >= table_y1\n                    and kv.bbox.y <= table_y2\n                ):\n                    table_duplicates.append(kv)\n\n            if table_duplicates:\n                table_duplicates.append(table)\n\n            document_duplicates.append(table_duplicates)\n\n        return document_duplicates\n\n    def directional_finder(\n        self,\n        word_1: str = \"\",\n        word_2: str = \"\",\n        prefix: str = \"\",\n        direction=Direction.BELOW,\n        entities=[],\n    ):\n        \"\"\"\n        The function returns entity types present in entities by prepending the prefix provided by te user. This helps in cases of repeating\n        key-values and checkboxes. The user can manipulate original data or produce a copy. The main advantage of this function is to be able to define direction.\n\n        :param word_1: The reference word from where x1, y1 coordinates are derived\n        :type word_1: str, required\n        :param word_2: The second word preferably in the direction indicated by the parameter direction. When it isn't given the end of page coordinates are used in the given direction.\n        :type word_2: str, optional\n        :param prefix: User provided prefix to prepend to the key . Without prefix, the method acts as a search by geometry function\n        :type prefix: str, optional\n        :param entities: List of DirectionalFinderType inputs.\n        :type entities: List[DirectionalFinderType]\n\n        :return: Returns the EntityList of modified key-value and/or checkboxes\n        :rtype: EntityList\n        \"\"\"\n\n        if not word_1:\n            return EntityList([])\n\n        x1, x2, y1, y2 = self._get_coords(word_1, word_2, direction)\n\n        if x1 == -1:\n            return EntityList([])\n\n        entity_dict = {\n            DirectionalFinderType.KEY_VALUE_SET: self.key_values,\n            DirectionalFinderType.SELECTION_ELEMENT: self.checkboxes,\n        }\n\n        entitylist = []\n        for entity_type in entities:\n            entitylist.extend(list(entity_dict[entity_type]))\n\n        new_key_values = self._get_kv_with_direction(\n            direction, entitylist, (x1, x2, y1, y2)\n        )\n\n        final_kv = []\n        for kv in new_key_values:\n            if kv.key:\n                key_words = [deepcopy(word) for word in kv.key]\n                key_words[0].text = prefix + key_words[0].text\n                new_kv = deepcopy(kv)\n                new_kv.key = key_words\n                final_kv.append(new_kv)\n            else:\n                final_kv.append(kv)\n\n        return EntityList(final_kv)\n\n    def _get_kv_with_direction(self, direction, entitylist, coords):\n        \"\"\"Return key-values and checkboxes in entitiylist present in the direction given with respect to the coordinates.\"\"\"\n        if direction == Direction.ABOVE:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.y <= coords[2] and kv.bbox.y >= coords[-1]\n            ]\n\n        elif direction == Direction.BELOW:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.y >= coords[2] and kv.bbox.y <= coords[-1]\n            ]\n\n        elif direction == Direction.RIGHT:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.x >= coords[0] and kv.bbox.x <= coords[1]\n            ]\n            new_key_values = [\n                kv\n                for kv in new_key_values\n                if kv.bbox.y >= coords[2] - kv.bbox.height\n                and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height\n            ]\n\n        elif direction == Direction.LEFT:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.x <= coords[0] and kv.bbox.x >= coords[1]\n            ]\n            new_key_values = [\n                kv\n                for kv in new_key_values\n                if kv.bbox.y >= coords[2] - kv.bbox.height\n                and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height\n            ]\n\n        return new_key_values\n\n    def _get_coords(self, word_1, word_2, direction):\n        \"\"\"\n        Returns coordinates for the area within which to search for key-values with the directional_finder by retrieving coordinates of word_1 \\\n        and word_2 if it exists else end of page.\n        \"\"\"\n        word_1_objects = self.search_lines(\n            keyword=word_1,\n            top_k=5,\n            similarity_metric=SimilarityMetric.COSINE,\n            similarity_threshold=0.5,\n        )\n\n        if not word_1_objects:\n            logging.warning(f\"{word_1} not found in page\")\n            return -1, -1, -1, -1\n        else:\n            word_1_obj = word_1_objects[0]\n            x1, y1 = word_1_obj.bbox.x, word_1_obj.bbox.y\n\n        if word_2:\n            word_2_objects = self.search_lines(\n                keyword=word_2,\n                top_k=5,\n                similarity_metric=SimilarityMetric.COSINE,\n                similarity_threshold=0.5,\n            )\n\n            if not word_2_objects:\n                logging.warning(f\"{word_2} not found in page\")\n                return -1, -1, -1, -1\n            else:\n                word_2_obj = word_2_objects[0]\n                x2, y2 = word_2_obj.bbox.x, word_2_obj.bbox.y\n        else:\n            x2, y2 = 1, 1\n\n        if direction == Direction.ABOVE:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 < y1 else (x1, 0, y1, 0)\n\n        elif direction == Direction.BELOW:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 > y1 else (x1, 1, y1, 1)\n\n        elif direction == Direction.RIGHT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 > x1 else (x1, 1, y1, y1)\n\n        elif direction == Direction.LEFT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 < x1 else (x1, 0, y1, y1)\n\n        else:\n            return -1, -1, -1, -1\n\n        return x1, x2, y1, y2\n\n    def visualize(self, *args, **kwargs):\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)\n",
    "textractor/entities/key_value.py": "\"\"\"\nThe :class:`KeyValue` entity is a document entity representing the Forms output. The key in :class:`KeyValue` are typically words \nand the :class:`Value` could be :class:`Word` elements or :class:`SelectionElement` in case of checkboxes.\n\nThis class contains the associated metadata with the :class:`KeyValue` entity including the entity ID, \nbounding box information, value, existence of checkbox, page number, Page ID and confidence of detection.\n\"\"\"\n\nimport logging\nfrom typing import List\nimport uuid\n\nfrom textractor.entities.word import Word\nfrom textractor.entities.value import Value\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\n\nclass KeyValue(DocumentEntity):\n    \"\"\"\n    To create a new :class:`KeyValue` object we require the following:\n\n    :param entity_id: Unique identifier of the KeyValue entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the KeyValue entity.\n    :type bbox: BoundingBox\n    :param contains_checkbox: True/False to indicate if the value is a checkbox.\n    :type contains_checkbox: bool\n    :param value: Value object that maps to the KeyValue entity.\n    :type value: Value\n    :param confidence: confidence with which the entity was detected.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(\n        self,\n        entity_id: str,\n        bbox: BoundingBox,\n        contains_checkbox: bool = False,\n        value: Value = None,\n        confidence: float = 0,\n    ):\n        super().__init__(entity_id, bbox)\n\n        self._words: EntityList[Word] = []\n        self.contains_checkbox = contains_checkbox\n        self._confidence = confidence / 100\n        self._value: Value = value\n        self.selection_status = False\n        self._page = None\n        self._page_id = None\n\n    @property\n    def ocr_confidence(self):\n        \"\"\"\n        Return the average OCR confidence\n        :return:\n        \"\"\"\n        key_confidences = [w.confidence for w in self.key]\n        value_confidences = (\n            [w.confidence for w in self.value.words] if self.value else []\n        )\n\n        key_confidence = (\n            sum(key_confidences) / len(key_confidences) if key_confidences else None\n        )\n        value_confidence = (\n            sum(value_confidences) / len(value_confidences)\n            if value_confidences\n            else None\n        )\n        return {\n            \"key_average\": key_confidence,\n            \"key_min\": min(key_confidences) if key_confidences else None,\n            \"value_average\": value_confidence,\n            \"value_min\": min(value_confidences) if value_confidences else None,\n        }\n\n    @property\n    def words(self) -> List[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the key and value of the :class:`KeyValue` object.\n\n        :return words: List of Word objects, each representing a word within the KeyValue entity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        value_words = self.value.words if self.value is not None and not self.contains_checkbox else []\n        return EntityList(\n            sorted(self._words + value_words, key=lambda x: x.bbox.x + x.bbox.y)\n        )\n\n    @property\n    def key(self):\n        \"\"\"\n        :return: Returns :class:`EntityList[Word]` object (a list of words) associated with the key.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self._words:\n            logging.info(\"Key contains no words objects.\")\n            return []\n        return self._words\n\n    @key.setter\n    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)\n\n    @property\n    def value(self) -> Value:\n        \"\"\"\n        :return: Returns the :class:`Value` mapped to the key if it has been assigned.\n        :rtype: Value\n        \"\"\"\n        if self._value is None:\n            logging.warning(\n                \"Asked for a value but it was never attributed \"\n                \"-> make sure to assign value to key with the `kv.value = <Value Object>` property setter\"\n            )\n            return None\n        else:\n            return self._value\n\n    @value.setter\n    def value(self, value: Value):\n        \"\"\"\n        Add :class:`Value` object to the :class:`KeyValue`.\n\n        :param value: Value object, representing a single value associated with the key.\n        :type value: Value\n        \"\"\"\n        self._value = value\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the :class:`Table` entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Table` entity.\n\n        :param page_num: Page number where the Table entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Table` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: str = TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError(\n                \"text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants\"\n            )\n\n        if not self.words:\n            logging.info(\"Document contains no word entities.\")\n            return []\n        else:\n            return EntityList(\n                [word for word in self.words if word.text_type == text_type]\n            )\n\n    def is_selected(self) -> bool:\n        \"\"\"\n        For KeyValues containing a selection item, returns its `is_selected` status\n\n        :return: Selection status of a selection item key value pair\n        :rtype: bool\n        \"\"\"\n        if self.contains_checkbox:\n            if len(self.value.children) == 1:\n                return self.value.children[0].is_selected()\n            else:\n                logging.info(\n                    \"is_checked() was called on a KeyValue that contains more than one checkbox. Returning first checkbox\"\n                )\n                return self.value.children[0].is_selected()\n        else:\n            logging.info(\n                \"is_checked() was called on a KeyValue that does not contain checkboxes. Returning False\"\n            )\n            return False\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ):\n        key_text, key_words = \" \".join([w.text for w in self.key]), self.key\n        value_text, value_words = self.value.get_text_and_words(config) if self.value else (\"\", \"\")\n        words = []\n        if not len(key_text) and not len(value_text):\n            return \"\", []\n        s = config.key_suffix.strip()\n        key_suffix = (\n            config.key_suffix\n            if not (len(key_text) > len(s) and key_text[-len(s) :] == s)\n            else \" \"\n        )\n        if config.add_prefixes_and_suffixes_in_text:\n            text = f\"{add_id_to_html_tag(config.key_value_prefix, self.id, config)}{config.key_prefix}{key_text}{key_suffix}{value_text}{config.key_value_suffix}\"\n        else:\n            text = f\"{key_text}{config.same_paragraph_separator}{value_text}\"\n\n        if config.add_prefixes_and_suffixes_as_words:\n            words += [Word(str(uuid.uuid4()), self.bbox, add_id_to_html_tag(config.key_value_prefix, self.id, config), is_structure=True)] if config.key_value_prefix else []\n            if key_words:\n                words += (\n                    ([Word(str(uuid.uuid4()), BoundingBox.enclosing_bbox(self.key), config.key_prefix, is_structure=True)] if config.key_prefix else []) +\n                    key_words +\n                    ([Word(str(uuid.uuid4()), BoundingBox.enclosing_bbox(self.key), config.key_suffix, is_structure=True)] if config.key_suffix else [])\n                )\n            if value_words: \n                words += value_words\n            words += ([Word(str(uuid.uuid4()), self.bbox, config.key_value_suffix, is_structure=True)] if config.key_value_suffix else [])\n        else:\n            words += key_words + value_words\n\n        for w in words:\n            w.kv_id = str(self.id)\n            w.kv_bbox = self.bbox\n\n        return text, words\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: Returns KeyValue object as a formatted string.\n        :rtype: str\n        \"\"\"\n        repr_string = \" \".join([word.text for word in self._words])\n\n        if self.contains_checkbox:\n            repr_string = self.value.__repr__() + \" \" + repr_string\n        else:\n            repr_string = repr_string\n            repr_string += \" : \"\n            repr_string += self.value.__repr__()\n        return repr_string\n",
    "textractor/entities/document.py": "\"\"\"The Document class is defined to host all the various DocumentEntity objects within it. :class:`DocumentEntity` objects can be \naccessed, searched and exported the functions given below.\"\"\"\n\nimport boto3\nimport json\nimport os\nimport string\nimport logging\nimport xlsxwriter\nimport io\nfrom pathlib import Path\nfrom typing import List, IO, Union, AnyStr, Tuple\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom PIL import Image\n\nfrom textractor.entities.expense_document import ExpenseDocument\nfrom textractor.entities.identity_document import IdentityDocument\nfrom textractor.entities.word import Word\nfrom textractor.entities.line import Line\nfrom textractor.entities.page import Page\nfrom textractor.entities.table import Table\nfrom textractor.entities.query import Query\nfrom textractor.entities.signature import Signature\nfrom textractor.entities.layout import Layout\nfrom textractor.exceptions import InputError\nfrom textractor.entities.key_value import KeyValue\nfrom textractor.entities.bbox import SpatialObject\nfrom textractor.utils.s3_utils import download_from_s3\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.constants import (\n    TextTypes,\n    SimilarityMetric,\n    Direction,\n    DirectionalFinderType,\n)\nfrom textractor.utils.search_utils import SearchUtils\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\n\nclass Document(SpatialObject, Linearizable):\n    \"\"\"\n    Represents the description of a single document, as it would appear in the input to the Textract API.\n    Document serves as the root node of the object model hierarchy,\n    which should be used as an intermediate form for most analytic purposes.\n    The Document node also contains the metadata of the document.\n    \"\"\"\n\n    @classmethod\n    def open(cls, fp: Union[dict, str, Path, IO[AnyStr]]):\n        \"\"\"Create a Document object from a JSON file path, file handle or response dictionary\n\n        :param fp: _description_\n        :type fp: Union[dict, str, Path, IO[AnyStr]]\n        :raises InputError: Raised on input not being of type Union[dict, str, Path, IO[AnyStr]]\n        :return: Document object\n        :rtype: Document\n        \"\"\"\n        from textractor.parsers import response_parser\n\n        if isinstance(fp, dict):\n            return response_parser.parse(fp)\n        elif isinstance(fp, str):\n            if fp.startswith(\"s3://\"):\n                # FIXME: Opening s3 clients for everything should be avoided\n                client = boto3.client(\"s3\")\n                return response_parser.parse(json.load(download_from_s3(client, fp)))\n            with open(fp, \"r\") as f:\n                return response_parser.parse(json.load(f))\n        elif isinstance(fp, Path):\n            with open(fp, \"r\") as f:\n                return response_parser.parse(json.load(f))\n        elif isinstance(fp, io.IOBase):\n            return response_parser.parse(json.load(fp))\n        else:\n            raise InputError(\n                f\"Document.open() input must be of type dict, str, Path or a file handle, not {type(fp)}\"\n            )\n\n    def __init__(self, num_pages: int = 1):\n        \"\"\"\n        Creates a new document, ideally containing entity objects pertaining to each page.\n\n        :param num_pages: Number of pages in the input Document.\n        \"\"\"\n        super().__init__(width=0, height=0)\n        self.num_pages: int = num_pages\n        self._pages: List[Page] = []\n        self._identity_documents: List[IdentityDocument] = []\n        self._trp2_document = None\n        self.response = None\n\n    @property\n    def words(self) -> EntityList[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the Document.\n\n        :return: List of Word objects, each representing a word within the Document.\n        :rtype: EntityList[Word]\n        \"\"\"\n        return EntityList(sum([page.words for page in self.pages], []))\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the document text as one string\n\n        :return: Page text seperated by line return\n        :rtype: str\n        \"\"\"\n        return os.linesep.join([page.text for page in self.pages])\n\n    @property\n    def identity_documents(self) -> EntityList[IdentityDocument]:\n        \"\"\"\n        Returns all the :class:`IdentityDocument` objects present in the Document.\n\n        :return: List of IdentityDocument objects, each representing an identity document within the Document.\n        :rtype: EntityList[IdentityDocument]\n        \"\"\"\n        return EntityList(self._identity_documents)\n\n    @identity_documents.setter\n    def identity_documents(self, identity_documents: List[IdentityDocument]):\n        \"\"\"\n        Set all the identity documents detected inside the Document\n        \"\"\"\n        self._identity_documents = identity_documents\n\n    @property\n    def expense_documents(self) -> EntityList[ExpenseDocument]:\n        \"\"\"\n        Returns all the :class:`ExpenseDocument` objects present in the Document.\n\n        :return: List of ExpenseDocument objects, each representing an expense document within the Document.\n        :rtype: EntityList[ExpenseDocument]\n        \"\"\"\n        return EntityList(sum([page.expense_documents for page in self.pages], []))\n\n    @property\n    def lines(self) -> EntityList[Line]:\n        \"\"\"\n        Returns all the :class:`Line` objects present in the Document.\n\n        :return: List of Line objects, each representing a line within the Document.\n        :rtype: EntityList[Line]\n        \"\"\"\n        return EntityList(sum([page.lines for page in self.pages], []))\n\n    @property\n    def key_values(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects present in the Document.\n\n        :return: List of KeyValue objects, each representing a key-value pair within the Document.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return EntityList(sum([page.key_values for page in self.pages], []))\n\n    @property\n    def checkboxes(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects with SelectionElements present in the Document.\n\n        :return: List of KeyValue objects, each representing a checkbox within the Document.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return EntityList(sum([page.checkboxes for page in self.pages], []))\n\n    @property\n    def tables(self) -> EntityList[Table]:\n        \"\"\"\n        Returns all the :class:`Table` objects present in the Document.\n\n        :return: List of Table objects, each representing a table within the Document.\n        :rtype: EntityList[Table]\n        \"\"\"\n        return EntityList(sum([page.tables for page in self.pages], []))\n\n    @property\n    def queries(self) -> EntityList[Query]:\n        \"\"\"\n        Returns all the :class:`Query` objects present in the Document.\n\n        :return: List of Query objects.\n        :rtype: EntityList[Query]\n        \"\"\"\n        return EntityList(sum([page.queries for page in self.pages], []))\n\n    @property\n    def signatures(self) -> EntityList[Signature]:\n        \"\"\"\n        Returns all the :class:`Signature` objects present in the Document.\n\n        :return: List of Signature objects.\n        :rtype: EntityList[Signature]\n        \"\"\"\n        return EntityList(sum([page.signatures for page in self.pages], []))\n\n    @property\n    def layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the :class:`Layout` objects present in the Document\n\n        :return: List of Layout objects\n        :rtype: EntityList[Layout]\n        \"\"\"\n        return EntityList(sum([page.layouts for page in self.pages], []))\n\n    @property\n    def identity_document(self) -> EntityList[IdentityDocument]:\n        \"\"\"\n        Returns all the :class:`IdentityDocument` objects present in the Page.\n\n        :return: List of IdentityDocument objects.\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self._identity_documents)\n\n    @identity_document.setter\n    def identity_document(self, identity_documents: List[IdentityDocument]):\n        \"\"\"\n        Add IdentityDocument objects to the Page.\n\n        :param tables: List of IdentityDocument objects.\n        :type identity_documents: list\n        \"\"\"\n        self._identity_document = identity_documents\n\n    @property\n    def images(self) -> List[Image.Image]:\n        \"\"\"\n        Returns all the page images in the Document.\n\n        :return: List of PIL Image objects.\n        :rtype: PIL.Image\n        \"\"\"\n        return [page.image for page in self._pages]\n\n    @property\n    def pages(self) -> List[Page]:\n        \"\"\"\n        Returns all the :class:`Page` objects present in the Document.\n\n        :return: List of Page objects, each representing a Page within the Document.\n        :rtype: List\n        \"\"\"\n        return self._pages\n\n    @pages.setter\n    def pages(self, pages: List[Page]):\n        \"\"\"\n        Add Page objects to the Document.\n\n        :param pages: List of Page objects, each representing a page within the document.\n        No specific ordering is assumed with input.\n        :type pages: List[Page]\n        \"\"\"\n        self._pages = sorted(pages, key=lambda x: x.page_num)\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ) -> Tuple[str, List]:\n        text, words_lists = zip(*[p.get_text_and_words(config) for p in self.pages])\n        flattened_words = []\n        for words in words_lists:\n            flattened_words.extend(words)\n        return config.layout_element_separator.join(text), flattened_words\n\n    def page(self, page_no: int = 0):\n        \"\"\"\n        Returns :class:`Page` object/s depending on the input page_no. Follows zero-indexing.\n\n        :param page_no: if int, returns single Page Object, else if list, it returns a list of\n                        Page objects.\n        :type page_no: int if single page, list of int if multiple pages\n\n        :return: Filters and returns Page objects depending on the input page_no\n        :rtype: Page or List[Page]\n        \"\"\"\n        if isinstance(page_no, int):\n            return self.pages[page_no]\n        elif isinstance(page_no, list):\n            return [self.pages[num] for num in page_no]\n        else:\n            raise InputError(\"page_no parameter doesn't match required data type.\")\n\n    def to_html(self, config: HTMLLinearizationConfig = HTMLLinearizationConfig()):\n        \"\"\"\n        Returns the HTML representation of the document, effectively calls Linearizable.to_html()\n        but add <html><body></body></html> around the result and put each page in a <div>. \n\n        :return: HTML text of the entity\n        :rtype: str\n        \"\"\"\n        \n        html = \"<html><body>\"\n        for page in self.pages:\n            html += f\"<div>{page.to_html(config=config)}</div>\"\n        html += \"</body></html>\"\n        \n        return html\n\n    def __repr__(self):\n        return os.linesep.join(\n            [\n                \"This document holds the following data:\",\n                f\"Pages - {len(self.pages)}\",\n                f\"Words - {len(self.words)}\",\n                f\"Lines - {len(self.lines)}\",\n                f\"Key-values - {len(self.key_values)}\",\n                f\"Checkboxes - {len(self.checkboxes)}\",\n                f\"Tables - {len(self.tables)}\",\n                f\"Queries - {len(self.queries)}\",\n                f\"Signatures - {len(self.signatures)}\",\n                f\"Identity Documents - {len(self.identity_documents)}\",\n                f\"Expense Documents - {len(self.expense_documents)}\",\n            ]\n        )\n\n    def to_trp2(self):\n        \"\"\"\n        Parses the response to the trp2 format for backward compatibility\n\n        :return: TDocument object that can be used with the older Textractor libraries\n        :rtype: TDocument\n        \"\"\"\n        from trp.trp2 import TDocument, TDocumentSchema\n        \n        if not self._trp2_document:\n            self._trp2_document = TDocumentSchema().load(self.response)\n        return self._trp2_document\n\n    def visualize(self, *args, **kwargs):\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self.pages).visualize(*args, **kwargs)\n\n    def keys(self, include_checkboxes: bool = True) -> List[str]:\n        \"\"\"\n        Prints all keys for key-value pairs and checkboxes if the document contains them.\n\n        :param include_checkboxes: True/False. Set False if checkboxes need to be excluded.\n        :type include_checkboxes: bool\n\n        :return: List of strings containing key names in the Document\n        :rtype: List[str]\n        \"\"\"\n        keys = []\n        keys = [keyvalue.key for keyvalue in self.key_values]\n        if include_checkboxes:\n            keys += [keyvalue.key for keyvalue in self.checkboxes]\n        return keys\n\n    def filter_checkboxes(\n        self, selected: bool = True, not_selected: bool = True\n    ) -> List[KeyValue]:\n        \"\"\"\n        Return a list of :class:`KeyValue` objects containing checkboxes if the document contains them.\n\n        :param selected: True/False Return SELECTED checkboxes\n        :type selected: bool\n        :param not_selected: True/False Return NOT_SELECTED checkboxes\n        :type not_selected: bool\n\n        :return: Returns checkboxes that match the conditions set by the flags.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n\n        checkboxes = EntityList([])\n        for page in self.pages:\n            checkboxes.extend(\n                page.filter_checkboxes(selected=selected, not_selected=not_selected)\n            )\n        return checkboxes\n\n    def get_words_by_type(self, text_type: TextTypes = TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.words:\n            logging.warn(\"Document contains no word entities.\")\n            return []\n\n        filtered_words = EntityList()\n        for page in self.pages:\n            filtered_words.extend(page.get_words_by_type(text_type=text_type))\n        return filtered_words\n\n    def search_words(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ) -> List[Word]:\n        \"\"\"\n        Return a list of top_k words that match the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str\n        :param top_k: Number of closest word objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of words that match the queried key sorted from highest\n                 to lowest similarity.\n        :rtype: EntityList[Word]\n        \"\"\"\n\n        top_n_words = []\n        for page in self.pages:\n            top_n_words.extend(\n                page._search_words_with_similarity(\n                    keyword=keyword,\n                    top_k=top_k,\n                    similarity_metric=similarity_metric,\n                    similarity_threshold=similarity_threshold,\n                )\n            )\n\n        top_n_words = sorted(top_n_words, key=lambda x: x[0], reverse=True)[:top_k]\n        top_n_words = EntityList([ent[1] for ent in top_n_words])\n\n        return top_n_words\n\n    def search_lines(\n        self,\n        keyword: str,\n        top_k: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ) -> List[Line]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of lines that contain the queried key sorted from highest\n                 to lowest similarity.\n        :rtype: EntityList[Line]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError(\n                \"similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants\"\n            )\n\n        top_n_lines = []\n        for page in self.pages:\n            top_n_lines.extend(\n                page._search_lines_with_similarity(\n                    keyword=keyword,\n                    top_k=top_k,\n                    similarity_metric=similarity_metric,\n                    similarity_threshold=similarity_threshold,\n                )\n            )\n\n        top_n_lines = EntityList([ent[1] for ent in top_n_lines][:top_k])\n\n        return top_n_lines\n\n    # KeyValue entity related functions\n    def get(\n        self,\n        key: str,\n        top_k_matches: int = 1,\n        similarity_metric: SimilarityMetric = SimilarityMetric.LEVENSHTEIN,\n        similarity_threshold: float = 0.6,\n    ):\n        \"\"\"\n        Return upto top_k_matches of key-value pairs for the key that is queried from the document.\n\n        :param key: Query key to match\n        :type key: str\n        :param top_k_matches: Maximum number of matches to return\n        :type top_k_matches: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of key-value pairs that match the queried key sorted from highest to lowest similarity.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError(\n                \"similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants\"\n            )\n\n        top_n = []\n        similarity_threshold = (\n            -similarity_threshold\n            if similarity_metric == SimilarityMetric.EUCLIDEAN\n            else similarity_threshold\n        )\n        lowest_similarity = similarity_threshold\n\n        for kv in self.key_values + self.checkboxes:\n            try:\n                edited_document_key = \"\".join(\n                    [\n                        char\n                        for char in kv.key.__repr__()\n                        if char not in string.punctuation\n                    ]\n                )\n            except:\n                pass\n            key = \"\".join([char for char in key if char not in string.punctuation])\n\n            similarity = [\n                SearchUtils.get_word_similarity(key, word, similarity_metric)\n                for word in edited_document_key.split(\" \")\n            ]\n            similarity.append(\n                SearchUtils.get_word_similarity(\n                    key, edited_document_key, similarity_metric\n                )\n            )\n\n            similarity = (\n                min(similarity)\n                if similarity_metric == SimilarityMetric.EUCLIDEAN\n                else max(similarity)\n            )\n\n            if similarity > similarity_threshold:\n                if len(top_n) < top_k_matches:\n                    top_n.append((kv, similarity))\n                elif similarity > lowest_similarity:\n                    top_n[-1] = (kv, similarity)\n                top_n = sorted(top_n, key=lambda x: x[1], reverse=True)\n                lowest_similarity = top_n[-1][1]\n\n        if not top_n:\n            logging.warning(\n                f\"Query key does not match any existing keys in the document.{os.linesep}{self.keys()}\"\n            )\n            return EntityList([])\n\n        logging.info(f\"Query key matched {len(top_n)} key-values in the document.\")\n\n        return EntityList([value[0] for value in top_n])\n\n    # Export document entities into supported formats\n    def export_kv_to_csv(\n        self,\n        include_kv: bool = True,\n        include_checkboxes: bool = True,\n        filepath: str = \"Key-Values.csv\",\n        sep: str = \";\",\n    ):\n        \"\"\"\n        Export key-value entities and checkboxes in csv format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        :param sep: Separator to be used in the csv file.\n        :type sep: str\n        \"\"\"\n        keys = []\n        values = []\n        if include_kv and not self.key_values:\n            logging.warning(\"Document does not contain key-values.\")\n        elif include_kv:\n            for kv in self.key_values:\n                keys.append(\" \".join([w.text for w in kv.key]))\n                values.append(kv.value.get_text())\n\n        if include_checkboxes and not self.checkboxes:\n            logging.warning(\"Document does not contain checkbox elements.\")\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                keys.append(\" \".join([w.text for w in kv.key]))\n                values.append(kv.value.children[0].status.name)\n\n        with open(filepath, \"w\") as f:\n            f.write(f\"Key{sep}Value{os.linesep}\")\n            for k, v in zip(keys, values):\n                f.write(f\"{k}{sep}{v}{os.linesep}\")\n\n        logging.info(\n            f\"csv file stored at location {os.path.join(os.getcwd(),filepath)}\"\n        )\n\n    def export_kv_to_txt(\n        self,\n        include_kv: bool = True,\n        include_checkboxes: bool = True,\n        filepath: str = \"Key-Values.txt\",\n    ):\n        \"\"\"\n        Export key-value entities and checkboxes in txt format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        \"\"\"\n        export_str = \"\"\n        index = 1\n        if include_kv and not self.key_values:\n            logging.warning(\"Document does not contain key-values.\")\n        elif include_kv:\n            for kv in self.key_values:\n                export_str += (\n                    f\"{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}\"\n                )\n                index += 1\n\n        if include_checkboxes and not self.checkboxes:\n            logging.warning(\"Document does not contain checkbox elements.\")\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                export_str += f\"{index}. {kv.key.__repr__()} : {kv.value.children[0].status.name}{os.linesep}\"\n                index += 1\n\n        with open(filepath, \"w\") as text_file:\n            text_file.write(export_str)\n        logging.info(\n            f\"txt file stored at location {os.path.join(os.getcwd(),filepath)}\"\n        )\n\n    def export_tables_to_excel(self, filepath):\n        \"\"\"\n        Creates an excel file and writes each table on a separate worksheet within the workbook.\n        This is stored on the filepath passed by the user.\n\n        :param filepath: Path to store the exported Excel file.\n        :type filepath: str, required\n        \"\"\"\n        if not filepath:\n            logging.error(\"Filepath required to store excel file.\")\n        workbook = xlsxwriter.Workbook(filepath)\n        for table in self.tables:\n            workbook = table.to_excel(\n                filepath=None, workbook=workbook, save_workbook=False\n            )\n        workbook.close()\n\n    def independent_words(self):\n        \"\"\"\n        :return: Return all words in the document, outside of tables, checkboxes, key-values.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.words:\n            logging.warning(\"Words have not been assigned to this Document object.\")\n            return []\n\n        else:\n            table_words = sum([table.words for table in self.tables], [])\n            kv_words = sum([kv.words for kv in self.key_values], [])\n            checkbox_words = sum([kv.words for kv in self.checkboxes], [])\n            dependent_words = table_words + checkbox_words + kv_words\n            dependent_word_ids = set([word.id for word in dependent_words])\n            independent_words = [\n                word for word in self.words if word.id not in dependent_word_ids\n            ]\n            return EntityList(independent_words)\n\n    def return_duplicates(self):\n        \"\"\"\n        Returns a dictionary containing page numbers as keys and list of :class:`EntityList` objects as values.\n        Each :class:`EntityList` instance contains the key-values and the last item is the table which contains duplicate information.\n        This function is intended to let the Textract user know of duplicate objects extracted by the various Textract models.\n\n        :return: Dictionary containing page numbers as keys and list of EntityList objects as values.\n        :rtype: Dict[page_num, List[EntityList[DocumentEntity]]]\n        \"\"\"\n        document_duplicates = defaultdict(list)\n\n        for page in self.pages:\n            document_duplicates[page.page_num].extend(page.return_duplicates())\n\n        return document_duplicates\n\n    def directional_finder(\n        self,\n        word_1: str = \"\",\n        word_2: str = \"\",\n        page: int = -1,\n        prefix: str = \"\",\n        direction=Direction.BELOW,\n        entities=[],\n    ):\n        \"\"\"\n        The function returns entity types present in entities by prepending the prefix provided by te user. This helps in cases of repeating\n        key-values and checkboxes. The user can manipulate original data or produce a copy. The main advantage of this function is to be able to define direction.\n\n        :param word_1: The reference word from where x1, y1 coordinates are derived\n        :type word_1: str, required\n        :param word_2: The second word preferably in the direction indicated by the parameter direction. When it isn't given the end of page coordinates are used in the given direction.\n        :type word_2: str, optional\n        :param page: page number of the page in the document to search the entities in.\n        :type page: int, required\n        :param prefix: User provided prefix to prepend to the key . Without prefix, the method acts as a search by geometry function\n        :type prefix: str, optional\n        :param entities: List of DirectionalFinderType inputs.\n        :type entities: List[DirectionalFinderType]\n\n        :return: Returns the EntityList of modified key-value and/or checkboxes\n        :rtype: EntityList\n        \"\"\"\n\n        if not word_1 or page == -1:\n            return EntityList([])\n\n        x1, x2, y1, y2 = self._get_coords(word_1, word_2, direction, page)\n\n        if x1 == -1:\n            return EntityList([])\n\n        page_obj = self.pages[page - 1]\n        entity_dict = {\n            DirectionalFinderType.KEY_VALUE_SET: self.key_values,\n            DirectionalFinderType.SELECTION_ELEMENT: self.checkboxes,\n        }\n\n        entitylist = []\n        for entity_type in entities:\n            entitylist.extend(list(entity_dict[entity_type]))\n\n        new_key_values = self._get_kv_with_direction(\n            direction, entitylist, (x1, x2, y1, y2)\n        )\n\n        final_kv = []\n        for kv in new_key_values:\n            if kv.key:\n                key_words = [deepcopy(word) for word in kv.key]\n                key_words[0].text = prefix + key_words[0].text\n                new_kv = deepcopy(kv)\n                new_kv.key = key_words\n                final_kv.append(new_kv)\n            else:\n                final_kv.append(kv)\n\n        return EntityList(final_kv)\n\n    def _get_kv_with_direction(self, direction, entitylist, coords):\n        \"\"\"Return key-values and checkboxes in entitylist present in the direction given with respect to the coordinates.\"\"\"\n        if direction == Direction.ABOVE:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.y <= coords[2] and kv.bbox.y >= coords[-1]\n            ]\n\n        elif direction == Direction.BELOW:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.y >= coords[2] and kv.bbox.y <= coords[-1]\n            ]\n\n        elif direction == Direction.RIGHT:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.x >= coords[0] and kv.bbox.x <= coords[1]\n            ]\n            new_key_values = [\n                kv\n                for kv in new_key_values\n                if kv.bbox.y >= coords[2] - kv.bbox.height\n                and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height\n            ]\n\n        elif direction == Direction.LEFT:\n            new_key_values = [\n                kv\n                for kv in entitylist\n                if kv.bbox.x <= coords[0] and kv.bbox.x >= coords[1]\n            ]\n            new_key_values = [\n                kv\n                for kv in new_key_values\n                if kv.bbox.y >= coords[2] - kv.bbox.height\n                and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height\n            ]\n\n        return new_key_values\n\n    def _get_coords(self, word_1, word_2, direction, page):\n        \"\"\"\n        Returns coordinates for the area within which to search for key-values with the directional_finder by retrieving coordinates of word_1 \\\n        and word_2 if it exists else end of page.\n        \"\"\"\n        word_1_objects = self.search_lines(\n            keyword=word_1,\n            top_k=5,\n            similarity_metric=SimilarityMetric.COSINE,\n            similarity_threshold=0.5,\n        )\n        word_1_objects = (\n            [word for word in word_1_objects if word.page == page] if page != -1 else []\n        )\n\n        if not word_1_objects:\n            logging.warning(f\"{word_1} not found in page {page}\")\n            return -1, -1, -1, -1\n        else:\n            word_1_obj = word_1_objects[0]\n            x1, y1 = word_1_obj.bbox.x, word_1_obj.bbox.y\n\n        if word_2:\n            word_2_objects = self.search_lines(\n                keyword=word_2,\n                top_k=5,\n                similarity_metric=SimilarityMetric.COSINE,\n                similarity_threshold=0.5,\n            )\n            word_2_objects = [word for word in word_2_objects if word.page == page]\n            if not word_2_objects:\n                logging.warning(f\"{word_2} not found in page {page}\")\n                return -1, -1, -1, -1\n            else:\n                word_2_obj = word_2_objects[0]\n                x2, y2 = word_2_obj.bbox.x, word_2_obj.bbox.y\n        else:\n            x2, y2 = x1, y1\n\n        if direction == Direction.ABOVE:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 < y1 else (x1, 0, y1, 0)\n\n        elif direction == Direction.BELOW:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 > y1 else (x1, 1, y1, 1)\n\n        elif direction == Direction.RIGHT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 > x1 else (x1, 1, y1, y1)\n\n        elif direction == Direction.LEFT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 < x1 else (x1, 0, y1, y1)\n\n        else:\n            return -1, -1, -1, -1\n\n        return x1, x2, y1, y2\n",
    "textractor/entities/value.py": "\"\"\"\nRepresents a single :class:`Value` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as KEY_VALUE_SET BlockTypes. These may be of KEY\nor VALUE type which is indicated by the EntityType attribute in the JSON response. \n\nThis class contains the associated metadata with the :class:`Value` entity including the entity ID, \nbounding box information, child words, associated key ID, page number, Page ID, confidence of detection\nand if it's a checkbox.\n\"\"\"\n\nfrom typing import List\nimport uuid\n\nfrom textractor.entities.word import Word\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import PRINTED, HANDWRITING, TextTypes\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.utils.text_utils import linearize_children\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\n\nclass Value(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Value` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float = 0):\n        super().__init__(entity_id, bbox)\n        self._words: List[Word] = []\n        self._key_id = None\n        self._contains_checkbox = False\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None\n\n    @property\n    def words(self) -> List[Word]:\n        \"\"\"\n        :return: Returns a list of all words in the entity if it exists else returns the\n                 checkbox status of the Value entity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.contains_checkbox:\n            return EntityList(self._words)\n        else:\n            return self.children[0].words\n\n    @words.setter\n    def words(self, words: List[Word]):\n        \"\"\"\n        Add Word objects to the Value.\n\n        :param words: List of Word objects, each representing a word within the Value field.\n        No specific ordering is assumed as is it is ordered internally.\n        :type words: list\n        \"\"\"\n        self._words = sorted(words, key=lambda x: x.bbox.x + x.bbox.y)\n\n    @property\n    def key_id(self) -> str:\n        \"\"\"\n        Returns the associated Key ID for the :class:`Value` entity.\n\n        :return: Returns the associated KeyValue object ID.\n        :rtype: str\n        \"\"\"\n        return self._key_id\n\n    @key_id.setter\n    def key_id(self, key_id: str):\n        \"\"\"\n        Sets the :class:`KeyValue` ID to which this Value object is associated.\n\n        :param key_id: Unique identifier for the KeyValue entity to which this Value is associated.\n        :type key_id: str\n        \"\"\"\n        self._key_id = key_id\n\n    @property\n    def contains_checkbox(self) -> bool:\n        \"\"\"\n        Returns True if the value associated is a :class:`SelectionElement`.\n\n        :return: Returns True if the value associated is a checkbox/SelectionElement.\n        :rtype: bool\n        \"\"\"\n        return self._contains_checkbox\n\n    @contains_checkbox.setter\n    def contains_checkbox(self, checkbox_present: bool):\n        \"\"\"\n        Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\n\n        :param checkbox_present: True or False depending on checkbox presence.\n        :type checkbox_present: bool\n        \"\"\"\n        self._contains_checkbox = checkbox_present\n\n    @property\n    def page(self):\n        \"\"\"\n        :return: Returns the page number of the page the Value entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the Value entity.\n\n        :param page_num: Page number where the Value entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Value` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: str = TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError(\n                \"text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants\"\n            )\n\n        return EntityList([word for word in self.words if word.text_type == text_type])\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ):\n        # We will need to handle the case where the Value contains a checkbox.\n        if self.contains_checkbox:\n            text, words = self.children[0].get_text_and_words(config)\n        else:\n            text, words = linearize_children(\n                self.words,\n                config=config,\n                no_new_lines=config.remove_new_lines_in_leaf_elements,\n            )\n        if config.add_prefixes_and_suffixes_in_text:\n            text = add_id_to_html_tag(config.value_prefix, self.id, config) + text + config.value_suffix\n        if config.add_prefixes_and_suffixes_as_words:\n            words = (\n                (\n                    [\n                        Word(\n                            str(uuid.uuid4()),\n                            self.bbox,\n                            add_id_to_html_tag(config.value_prefix, self.id, config),\n                            is_structure=True,\n                            is_clickable=(\n                                bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected]\n                            )\n                        )\n                    ]\n                    if config.value_prefix else\n                    []\n                ) +\n                words +\n                (\n                    [\n                        Word(\n                            str(uuid.uuid4()),\n                            self.bbox,\n                            config.value_suffix,\n                            is_structure=True,\n                            is_clickable=(\n                                bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected]\n                            )\n                        )\n                    ]\n                    if config.value_suffix else\n                    []\n                )\n            )\n        for w in words:\n            w.value_id = str(self.id)\n            w.value_bbox = self.bbox\n        return text, words\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Value entity.\n        :rtype: str\n        \"\"\"\n        repr_string = \"\"\n        if self.contains_checkbox:\n            repr_string += f\"{self.children[0].__repr__()}\"\n        else:\n            words = \" \".join([word.text for word in self.words])\n            repr_string += f\"{words}\"\n        return repr_string\n",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities \\\nin a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\n\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\n\nfrom textractor.data.constants import (\n    TextractType,\n    TableFormat,\n    AnalyzeExpenseLineItemFields,\n    AnalyzeExpenseFields,\n)\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\n\nlogger = logging.getLogger(__name__)\n\npresent_path = os.path.abspath(os.path.dirname(__file__))\n\nT = TypeVar(\"T\")\n\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def __init__(self, objs=None):\n        super().__init__()\n\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n\n        self.extend(objs)\n\n    def visualize(\n        self,\n        with_text: bool = True,\n        with_words: bool = True,\n        with_confidence: bool = False,\n        font_size_ratio: float = 0.5,\n    ) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        # FIXME: This is inelegant\n        if len(self) > 0 and any(\n            [ent.__class__.__name__ == \"Document\" for ent in self]\n        ):\n            return EntityList(self[0].pages).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and any([ent.__class__.__name__ == \"Page\" for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (\n                    entity.__class__.__name__ == \"Word\"\n                    or entity.__class__.__name__ == \"Line\"\n                ):\n                    continue\n                if entity.__class__.__name__ == \"Page\":\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(\n                            new_entity_list, expense_document\n                        )\n                elif entity.__class__.__name__ == \"ExpenseDocument\":\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException(\n                \"Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.\"\n            )\n\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            # FIXME: There should be a way to recurse through all entities\n            except AttributeError:\n                pass\n\n        for page in list(entities_pagewise.keys()):\n            # Deduplication\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(\n                entities_pagewise[page],\n                with_text,\n                with_confidence,\n                font_size_ratio,\n            )\n\n        images = [image.convert(\"RGB\") for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if (\n                        expense.type.text\n                        != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name\n                    ):\n                        entity_list.append(expense)\n        return entity_list\n\n    def pretty_print(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        with_page_number: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for each of the entities in the list according to its entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.WORDS,\n        )\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.LINES,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.KEY_VALUE_SET,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.SELECTION_ELEMENT,\n        )\n        result_value += self._get_tables_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n        )\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value\n\n    def _get_text_string(\n        self,\n        with_page_number=False,\n        with_confidence=False,\n        trim=False,\n        textract_type=TextractType.WORDS,\n    ):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n\n        if textract_type == TextractType.WORDS:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Word\"],\n                key=lambda x: x.page,\n            )\n        else:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Line\"],\n                key=lambda x: x.page,\n            )\n\n        current_page = -1\n\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f\"--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}\"\n                current_page = word.page\n            if trim:\n                result_value += f\"{word.text.strip()}\"\n            else:\n                result_value += f\"{word.text}\"\n\n            if with_confidence:\n                result_value += f\", {word.confidence}\"\n            result_value += os.linesep\n\n        return result_value\n\n    def _get_forms_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n        textract_type=TextractType.KEY_VALUE_SET,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n        result_value = \"\"\n\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and not obj.contains_checkbox\n            ]\n        else:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and obj.contains_checkbox\n            ]\n\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                result_value += (\n                    tabulate(forms_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            csv_output = StringIO()\n            csv_writer = csv.writer(\n                csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n            )\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == \"Table\":\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == \"TableCell\":\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n\n        result_value = \"\"\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                result_value += (\n                    tabulate(table_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n                csv_output = StringIO()\n                csv_writer = csv.writer(\n                    csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = \"\"\n        queries = [obj for obj in self if obj.__class__.__name__ == \"Query\"]\n\n        for query in queries:\n            if query.result is not None:\n                result_value += f\"{query.query} => {query.result.answer}{os.linesep}\"\n            else:\n                result_value += f\"{query.query} => {os.linesep}\"\n\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = \"\"\n        expense_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"ExpenseDocument\"\n        ]\n\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f\"Expense Document {i+1}:{os.linesep}\"\n            result_value += f\"### Summary Fields:{os.linesep}\"\n            result_value += f\"{expense_document.summary_fields}{os.linesep}\"\n            result_value += f\"### Line Item Groups: {os.linesep}\"\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f\"{line_item_group}{os.linesep}\"\n\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = \"\"\n        id_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"IdentityDocument\"\n        ]\n\n        for id_document in id_documents:\n            result_value += f\"{id_document}{os.linesep}\"\n\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig = TextLinearizationConfig()):\n        texts, words = [], []\n        separator = (\n            config.same_paragraph_separator\n            if all([entity.__class__.__name__ == \"Word\" for entity in self]) else\n            config.layout_element_separator\n        )\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return separator.join(texts), words\n\ndef _convert_form_to_list(\n    form_objects,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.KEY_VALUE_SET,\n) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n\n    rows_list = list()\n    rows_list.append([\"Key\", \"Value\"])\n    for field in form_objects:\n        t_key = \"\"\n        t_value = \"\"\n        if field.key:\n            text = \" \".join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + field.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({field.key.confidence:.1f})\"\n        if field.value:\n            text = (\n                field.value.words\n                if textract_type == TextractType.SELECTION_ELEMENT\n                else \" \".join([word.text for word in field.value.words])\n            )\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += \" {\" + field.value.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_value += f\" ({field.value.confidence:.1f})\"\n        rows_list.append([t_key, t_value])\n    return rows_list\n\n\ndef _convert_table_to_list(\n    table_object,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.TABLES,\n) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split(\">\")[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + cell.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({cell.confidence:.1f})\"\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\n\ndef _draw_bbox(\n    entities: List[Any],\n    with_text: bool = False,\n    with_confidence: bool = False,\n    font_size_ratio: float = 0.5,\n):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception(\"Could not find an entity with an associated image!\")\n    image = image.convert(\"RGBA\")\n    overlay = Image.new(\"RGBA\", image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, \"RGBA\")\n\n    text_locations = {}\n\n    # First drawing tables\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == \"Table\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.title:\n                drw.rectangle(\n                    (\n                        int(entity.title.bbox.x * width),\n                        int(entity.title.bbox.y * height),\n                        int((entity.title.bbox.x + entity.title.bbox.width) * width),\n                        int((entity.title.bbox.y + entity.title.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"red\") + (120,),\n                    width=2,\n                )\n\n            for footer in entity.footers:\n                drw.rectangle(\n                    (\n                        int(footer.bbox.x * width),\n                        int(footer.bbox.y * height),\n                        int((footer.bbox.x + footer.bbox.width) * width),\n                        int((footer.bbox.y + footer.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"cyan\") + (120,),\n                    width=2,\n                )\n\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(\n                        zip(\n                            *[\n                                (\n                                    c.bbox.x,\n                                    c.bbox.y,\n                                    c.bbox.x + c.bbox.width,\n                                    c.bbox.y + c.bbox.height,\n                                )\n                                for c in cell.siblings + [cell]\n                            ]\n                        )\n                    )\n                    min_x, min_y, max_x, max_y = (\n                        min(min_x),\n                        min(min_y),\n                        max(max_x),\n                        max(max_y),\n                    )\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (\n                        cell.bbox.x,\n                        cell.bbox.y,\n                        cell.bbox.x + cell.bbox.width,\n                        cell.bbox.y + cell.bbox.height,\n                    )\n\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb(\"blue\") + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb(\"red\") + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb(\"cyan\") + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb(\"yellow\") + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb(\"green\") + (120,)\n\n                drw.rectangle(\n                    (\n                        int(min_x * width),\n                        int(min_y * height),\n                        int(max_x * width),\n                        int(max_y * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=fill_color,\n                    width=2,\n                )\n                for checkbox in cell.checkboxes:\n                    drw.rectangle(\n                        (\n                            int(checkbox.bbox.x * width),\n                            int(checkbox.bbox.y * height),\n                            int((checkbox.bbox.x + checkbox.bbox.width) * width),\n                            int((checkbox.bbox.y + checkbox.bbox.height) * height),\n                        ),\n                        outline=ImageColor.getrgb(\"lightgreen\")\n                        if checkbox.is_selected()\n                        else ImageColor.getrgb(\"indianred\"),\n                    )\n    # Second drawing bounding boxes\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == \"Query\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableTitle\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableFooter\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"ExpenseField\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords_value\"],\n                outline=overlayer_data[\"color_value\"],\n                width=2,\n            )\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(\n                    xy=overlayer_data[\"coords_key\"],\n                    outline=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n                drw.line(\n                    [\n                        (\n                            (b1.x + b1.width / 2) * width,\n                            (b1.y + b1.height / 2) * height,\n                        ),\n                        (\n                            (b2.x + b2.width / 2) * width,\n                            (b2.y + b2.height / 2) * height,\n                        ),\n                    ],\n                    fill=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n        elif entity.__class__.__name__ == \"ExpenseDocument\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            for coord, text in zip(\n                overlayer_data[\"coords_list\"], overlayer_data[\"coords_list\"]\n            ):\n                drw.rectangle(\n                    xy=coord, outline=overlayer_data[\"color_expense_group\"], width=2\n                )\n        elif entity.__class__.__name__.startswith(\"Layout\"):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=4\n            )\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.__class__.__name__ == \"KeyValue\":\n                drw.rectangle(\n                    xy=overlayer_data[\"value_bbox\"],\n                    outline=overlayer_data[\"color_value\"],\n                    width=2,\n                )\n                b1 = overlayer_data[\"value_bbox\"]\n                b2 = overlayer_data[\"coords\"]\n                drw.line(\n                    [\n                        ((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2),\n                        ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2),\n                    ],\n                    fill=overlayer_data[\"color_value\"],\n                    width=1,\n                )\n\n    # Second drawing, text\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == \"Word\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__ == \"KeyValue\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                # Key Text\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(\n                    int(0.03 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color\"],\n                )\n\n                # Value Text\n                final_txt = overlayer_data[\"value_text\"]\n\n                bbox_height = (\n                    overlayer_data[\"value_bbox\"][3] - overlayer_data[\"value_bbox\"][1]\n                )\n                text_height = min(\n                    int(0.01 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"value_conf\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"value_bbox\"][0],\n                        overlayer_data[\"value_bbox\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color_value\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseField\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = overlayer_data[\"text\"]\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                if entity.key is not None:\n                    x = overlayer_data[\"coords_key\"][0] + 0.3 * (\n                        overlayer_data[\"coords_key\"][2]\n                        - overlayer_data[\"coords_key\"][0]\n                    )\n                    y = overlayer_data[\"coords_key\"][1] - text_height - 1\n                else:\n                    x = int(\n                        overlayer_data[\"coords\"][0]\n                        + 0.3\n                        * (overlayer_data[\"coords\"][2] - overlayer_data[\"coords\"][0])\n                    )\n                    y = overlayer_data[\"coords\"][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[(x, y)] != final_txt:\n                    y = y - text_height - 1\n                text_locations[(x, y)] = final_txt\n                drw.text(\n                    (x, y),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseDocument\":\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(\n                    overlayer_data[\"coords_list\"], overlayer_data[\"text_list\"]\n                ):\n                    drw.text(\n                        (coord[0], coord[3]),\n                        text,\n                        font=fnt,\n                        fill=overlayer_data[\"color_expense_group\"],\n                    )\n\n            elif entity.__class__.__name__ == \"Query\":\n                if entity.result is None:\n                    continue\n\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n\n                final_txt = entity.query + \" \" + overlayer_data[\"text\"]\n\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(entity.result.confidence)[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__.startswith(\"Layout\"):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (\n        bbox.x * width,\n        bbox.y * height,\n        bbox.width * width,\n        bbox.height * height,\n    )\n    data[\"coords\"] = [x, y, x + w, y + h]\n    data[\"confidence\"] = (\n        entity.confidence\n        if entity.__class__.__name__\n        not in [\n            \"Table\",\n            \"ExpenseField\",\n            \"ExpenseDocument\",\n            \"LineItemRow\",\n            \"LineItemGroup\",\n        ]\n        else \"\"\n    )\n    data[\"color\"] = (0, 0, 0)\n    data[\"text_color\"] = (0, 0, 0)\n\n    if entity.__class__.__name__ == \"Word\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"blue\")\n\n    elif entity.__class__.__name__ == \"Line\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"lightgrey\")\n        data[\"coords\"] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == \"KeyValue\":\n        data[\"text\"] = entity.key.__repr__()\n        data[\"color\"] = ImageColor.getrgb(\"brown\")\n        data[\"value_text\"] = entity.value.__repr__()\n        data[\"coords\"] = [x - 2, y - 2, x + w + 2, y + h + 2]\n\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data[\"value_conf\"] = entity.children[0].confidence\n\n        else:\n            value_bbox = entity.value.bbox\n            data[\"value_conf\"] = entity.value.confidence\n\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        x, y, w, h = (\n            value_bbox.x * width - 2,\n            value_bbox.y * height - 2,\n            value_bbox.width * width + 2,\n            value_bbox.height * height + 2,\n        )\n        data[\"value_bbox\"] = [x, y, x + w, y + h]\n\n    elif entity.__class__.__name__ == \"Table\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableTitle\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableFooter\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n\n    elif entity.__class__.__name__ == \"TableCell\":\n        data[\"color\"] = ImageColor.getrgb(\"skyblue\")\n        data[\"text\"] = entity.__repr__().split(\">\")[-1][1:]\n\n    elif entity.__class__.__name__ == \"QueryResult\":\n        data[\"color\"] = ImageColor.getrgb(\"mediumturquoise\")\n        data[\"text\"] = entity.answer\n    elif entity.__class__.__name__ == \"Signature\":\n        data[\"color\"] = ImageColor.getrgb(\"coral\")\n    elif entity.__class__.__name__ == \"ExpenseField\":\n        data[\"text\"] = entity.type.text\n        data[\"text_color\"] = ImageColor.getrgb(\"brown\")\n        data[\"coords\"] = [x - 5, y - 5, x + w + 5, y + h + 5]\n\n        if entity.key:\n            data[\"color_key\"] = ImageColor.getrgb(\"brown\")\n            data[\"coords_key\"] = (\n                entity.key.bbox.x * width - 3,\n                entity.key.bbox.y * height - 3,\n                (entity.key.bbox.x + entity.key.bbox.width) * width + 3,\n                ((entity.key.bbox.y + entity.key.bbox.height)) * height + 3,\n            )\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        data[\"coords_value\"] = (\n            entity.value.bbox.x * width - 3,\n            entity.value.bbox.y * height - 3,\n            (entity.value.bbox.x + entity.value.bbox.width) * width + 3,\n            ((entity.value.bbox.y + entity.value.bbox.height)) * height + 3,\n        )\n    elif entity.__class__.__name__ == \"Expense\":\n        data[\"text\"] = entity.text\n        data[\"coords\"] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == \"ExpenseDocument\":\n        data[\"color\"] = ImageColor.getrgb(\"beige\")\n        data[\"coords_list\"] = []\n        data[\"text_list\"] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data[\"coords_list\"].append(\n                    (\n                        bbox.x * width - 5,\n                        bbox.y * height - 5,\n                        (bbox.x + bbox.width) * width + 3,\n                        (bbox.y + bbox.height) * height + 3,\n                    )\n                )\n                data[\"text_list\"].append(group)\n        data[\"color_expense_group\"] = ImageColor.getrgb(\"coral\")\n\n    elif entity.__class__.__name__ == \"LineItemGroup\":\n        data[\"color\"] = ImageColor.getrgb(\"lightblue\")\n        data[\"coords\"] = [x - 10, y - 10, x + w + 10, y + h + 10]\n\n    elif entity.__class__.__name__ == \"LineItemRow\":\n        data[\"color\"] = ImageColor.getrgb(\"lightyellow\")\n        data[\"coords\"] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith(\"Layout\"):\n        data[\"color\"] = ImageColor.getrgb(\"teal\")\n        data[\"text\"] = f\"{entity.layout_type} - {entity.reading_order}\"\n    else:\n        pass\n    return data\n"
  },
  "GT_src_dict": {
    "textractor/entities/document_entity.py": {
      "DocumentEntity.children": {
        "code": "    def children(self):\n        \"\"\"Returns the list of child entities associated with this DocumentEntity. This method provides access to the hierarchical structure of document entities, allowing users to traverse or manipulate child entities that are part of this DocumentEntity. The returned list contains instances of child entities, which could be further processed or analyzed, depending on the context of the document's structure. This method interacts with the internal attribute `_children`, which is initialized as an empty list in the constructor of the DocumentEntity class to store child entities added via the `add_children` method.\"\"\"\n        '\\n        :return: Returns children of entity\\n        :rtype: list\\n        '\n        return self._children",
        "docstring": "Returns the list of child entities associated with this DocumentEntity. This method provides access to the hierarchical structure of document entities, allowing users to traverse or manipulate child entities that are part of this DocumentEntity. The returned list contains instances of child entities, which could be further processed or analyzed, depending on the context of the document's structure. This method interacts with the internal attribute `_children`, which is initialized as an empty list in the constructor of the DocumentEntity class to store child entities added via the `add_children` method.",
        "signature": "def children(self):",
        "type": "Method",
        "class_signature": "class DocumentEntity(Linearizable, ABC):"
      }
    },
    "textractor/entities/page.py": {
      "Page.words": {
        "code": "    def words(self, words: List[Word]):\n        \"\"\"Sets the list of Word objects associated with the Page.\n\n:param words: A list of Word objects representing the individual words contained within the page. This method does not assume any specific order of the input words.\n:type words: List[Word]\n\nThis method updates the `_words` attribute of the Page instance with the provided list of Word objects. It also removes duplicates by converting the list to a set and then sorts the words by their position on the page using the `sort_by_position` utility function, ensuring a structured order for later processing. The EntityList class from `textractor.entities` is used to encapsulate the sorted words.\"\"\"\n        '\\n        Add Word objects to the Page.\\n\\n        :param words: List of Word objects, each representing a word within the page. No specific ordering is assumed.\\n        :type words: List[Word]\\n        '\n        self._words = words\n        self._words = EntityList(sort_by_position(list(set(self._words))))",
        "docstring": "Sets the list of Word objects associated with the Page.\n\n:param words: A list of Word objects representing the individual words contained within the page. This method does not assume any specific order of the input words.\n:type words: List[Word]\n\nThis method updates the `_words` attribute of the Page instance with the provided list of Word objects. It also removes duplicates by converting the list to a set and then sorts the words by their position on the page using the `sort_by_position` utility function, ensuring a structured order for later processing. The EntityList class from `textractor.entities` is used to encapsulate the sorted words.",
        "signature": "def words(self, words: List[Word]):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.lines": {
        "code": "    def lines(self, lines: List[Line]):\n        \"\"\"Adds Line objects to the Page instance, representing the text lines detected within the page's document.\n\n:param lines: A list of Line objects that correspond to the detected lines within the page.\n:type lines: List[Line]\n\nThis method stores the provided Line objects in an internal EntityList after sorting them by their position on the page using the `sort_by_position` utility function. The sorted list ensures that lines are organized in the reading order, providing a coherent structure for further processing and interaction with other text elements on the page.\"\"\"\n        '\\n        Add Line objects to the Document.\\n\\n        :param lines: List of Line objects, each representing a line within the Page.\\n        :type lines: List[Line]\\n        '\n        self._lines = EntityList(sort_by_position(lines))",
        "docstring": "Adds Line objects to the Page instance, representing the text lines detected within the page's document.\n\n:param lines: A list of Line objects that correspond to the detected lines within the page.\n:type lines: List[Line]\n\nThis method stores the provided Line objects in an internal EntityList after sorting them by their position on the page using the `sort_by_position` utility function. The sorted list ensures that lines are organized in the reading order, providing a coherent structure for further processing and interaction with other text elements on the page.",
        "signature": "def lines(self, lines: List[Line]):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.key_values": {
        "code": "    def key_values(self, kv: List[KeyValue]):\n        \"\"\"Sets the key-value pairs for the Page instance.\n\n:param kv: A list of KeyValue objects, each representing a key-value area within the document page.\n:type kv: List[KeyValue]\n\nThe key_values setter updates the _key_values attribute of the Page object, which is an instance of EntityList. The EntityList is populated with KeyValue objects sorted by their position on the page, using the sort_by_position utility function. This ensures that key-value pairs are organized in a logical order as they appear in the document. This method directly affects how key-value pairs are retrieved and utilized by other methods within the Page class, influencing the output in key-value searches and exports.\"\"\"\n        '\\n        Add KeyValue objects to the Page.\\n\\n        :param kv: List of KeyValue objects, each representing a KV area within the document page.\\n        :type kv: List[KeyValue]\\n        '\n        self._key_values = EntityList(sort_by_position(kv))",
        "docstring": "Sets the key-value pairs for the Page instance.\n\n:param kv: A list of KeyValue objects, each representing a key-value area within the document page.\n:type kv: List[KeyValue]\n\nThe key_values setter updates the _key_values attribute of the Page object, which is an instance of EntityList. The EntityList is populated with KeyValue objects sorted by their position on the page, using the sort_by_position utility function. This ensures that key-value pairs are organized in a logical order as they appear in the document. This method directly affects how key-value pairs are retrieved and utilized by other methods within the Page class, influencing the output in key-value searches and exports.",
        "signature": "def key_values(self, kv: List[KeyValue]):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.checkboxes": {
        "code": "    def checkboxes(self, checkbox: List[KeyValue]):\n        \"\"\"Sets the list of checkbox KeyValue objects for the Page, representing checkbox areas extracted from the document.\n\n:param checkbox: A list of KeyValue objects, each representing a checkbox area within the document page. These objects may contain children of type SelectionElement that indicate their selection status.\n:type checkbox: List[KeyValue]\n\nThis setter method updates the internal `_checkboxes` attribute, which is an instance of EntityList, with a sorted list of the provided KeyValue objects based on their positions as determined by the `sort_by_position` utility function. This ensures the checkboxes are organized in a coherent manner corresponding to their layout on the page.\"\"\"\n        '\\n        Add KeyValue objects containing SelectionElement children to the Page.\\n\\n        :param checkbox: List of KeyValue objects, each representing a checkbox area within the document page.\\n        :type checkbox: List[KeyValue]\\n        '\n        self._checkboxes = EntityList(sort_by_position(checkbox))",
        "docstring": "Sets the list of checkbox KeyValue objects for the Page, representing checkbox areas extracted from the document.\n\n:param checkbox: A list of KeyValue objects, each representing a checkbox area within the document page. These objects may contain children of type SelectionElement that indicate their selection status.\n:type checkbox: List[KeyValue]\n\nThis setter method updates the internal `_checkboxes` attribute, which is an instance of EntityList, with a sorted list of the provided KeyValue objects based on their positions as determined by the `sort_by_position` utility function. This ensures the checkboxes are organized in a coherent manner corresponding to their layout on the page.",
        "signature": "def checkboxes(self, checkbox: List[KeyValue]):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.tables": {
        "code": "    def tables(self, tables: List[Table]):\n        \"\"\"Sets the table objects for the Page instance.\n\n:param tables: A list of `Table` objects that represent structured data areas (tables) within the document page. These objects are defined in the `textractor.entities.table` module.\n:type tables: List[Table]\n\nThis method updates the internal `_tables` attribute to hold an `EntityList` containing the provided `Table` instances, allowing for structured data extraction and manipulation from the document. The `EntityList` class is utilized here to maintain a collection of entities, facilitating easy management of the included table objects. The method does not return any value.\"\"\"\n        '\\n        Add Table objects to the Page.\\n\\n        :param tables: List of Table objects, each representing a Table area within the document page.\\n        :type tables: list\\n        '\n        self._tables = EntityList(tables)",
        "docstring": "Sets the table objects for the Page instance.\n\n:param tables: A list of `Table` objects that represent structured data areas (tables) within the document page. These objects are defined in the `textractor.entities.table` module.\n:type tables: List[Table]\n\nThis method updates the internal `_tables` attribute to hold an `EntityList` containing the provided `Table` instances, allowing for structured data extraction and manipulation from the document. The `EntityList` class is utilized here to maintain a collection of entities, facilitating easy management of the included table objects. The method does not return any value.",
        "signature": "def tables(self, tables: List[Table]):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the `Page` object, summarizing its contents and structure. This includes the page number and the counts of various entities stored within the page, such as words, lines, key-values, checkboxes, tables, queries, signatures, and expense documents. \n\nThe method does not take any parameters and outputs a formatted string, which is particularly useful for logging or debugging purposes to provide insights into the current state of the page's data. It utilizes the properties like `self.words`, `self.lines`, `self.key_values`, etc., to gather the counts needed for the summary. Each property is expected to return an `EntityList` containing corresponding entities, ensuring that the counts are accurate.\n\nThis method helps in quickly assessing the amount and type of data present on a single page, which is particularly significant for applications that manage documents and may need to perform actions based on the presence of these entities.\"\"\"\n        return os.linesep.join([f'This Page ({self.page_num}) holds the following data:', f'Words - {len(self.words)}', f'Lines - {len(self.lines)}', f'Key-values - {len(self.key_values)}', f'Checkboxes - {len(self.checkboxes)}', f'Tables - {len(self.tables)}', f'Queries - {len(self.queries)}', f'Signatures - {len(self.signatures)}', f'Expense documents - {len(self.expense_documents)}', f'Layout elements - {len(self.layouts)}'])",
        "docstring": "Returns a string representation of the `Page` object, summarizing its contents and structure. This includes the page number and the counts of various entities stored within the page, such as words, lines, key-values, checkboxes, tables, queries, signatures, and expense documents. \n\nThe method does not take any parameters and outputs a formatted string, which is particularly useful for logging or debugging purposes to provide insights into the current state of the page's data. It utilizes the properties like `self.words`, `self.lines`, `self.key_values`, etc., to gather the counts needed for the summary. Each property is expected to return an `EntityList` containing corresponding entities, ensuring that the counts are accurate.\n\nThis method helps in quickly assessing the amount and type of data present on a single page, which is particularly significant for applications that manage documents and may need to perform actions based on the presence of these entities.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.keys": {
        "code": "    def keys(self, include_checkboxes: bool=True) -> List[str]:\n        \"\"\"Returns a list of all key names present in the Page's key-value pairs and optionally includes those from checkboxes.\n\n:param include_checkboxes: A boolean flag indicating whether to include the keys of checkboxes in the returned list. Defaults to True.\n:type include_checkboxes: bool\n\n:return: A list of strings representing the keys of key-value pairs and, if specified, the keys from checkboxes present in the Page.\n:rtype: List[str]\n\nThis method interacts with the `key_values` and `checkboxes` attributes, which are instances of `EntityList` containing `KeyValue` objects. The method retrieves the `key` from each `KeyValue` object and returns them. It is part of the `Page` class, which represents a document page and its associated entities, including words, lines, tables, and more.\"\"\"\n        '\\n        Prints all keys for key-value pairs and checkboxes if the page contains them.\\n\\n        :param include_checkboxes: True/False. Set False if checkboxes need to be excluded.\\n        :type include_checkboxes: bool\\n\\n        :return: List of strings containing key names in the Page\\n        :rtype: List[str]\\n        '\n        keys = []\n        keys = [keyvalue.key for keyvalue in self.key_values]\n        if include_checkboxes:\n            keys += [keyvalue.key for keyvalue in self.checkboxes]\n        return keys",
        "docstring": "Returns a list of all key names present in the Page's key-value pairs and optionally includes those from checkboxes.\n\n:param include_checkboxes: A boolean flag indicating whether to include the keys of checkboxes in the returned list. Defaults to True.\n:type include_checkboxes: bool\n\n:return: A list of strings representing the keys of key-value pairs and, if specified, the keys from checkboxes present in the Page.\n:rtype: List[str]\n\nThis method interacts with the `key_values` and `checkboxes` attributes, which are instances of `EntityList` containing `KeyValue` objects. The method retrieves the `key` from each `KeyValue` object and returns them. It is part of the `Page` class, which represents a document page and its associated entities, including words, lines, tables, and more.",
        "signature": "def keys(self, include_checkboxes: bool=True) -> List[str]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.filter_checkboxes": {
        "code": "    def filter_checkboxes(self, selected: bool=True, not_selected: bool=True) -> EntityList[KeyValue]:\n        \"\"\"Filters and returns a list of checkboxes present on the page based on their selection status.\n\n:param selected: A boolean indicating whether to return selected checkboxes. Defaults to True.\n:type selected: bool\n:param not_selected: A boolean indicating whether to return not selected checkboxes. Defaults to True.\n\n:return: An `EntityList` containing `KeyValue` objects that match the selection status criteria specified by the `selected` and `not_selected` parameters. Returns an empty list if no checkboxes are present.\n:rtype: EntityList[KeyValue]\n\nThis method interacts with the `_checkboxes` attribute, which stores `KeyValue` objects that represent checkbox elements detected on the page. The method uses the `SelectionStatus` constant defined in `textractor.data.constants` to determine if each checkbox is selected or not. If the page does not contain any checkboxes, a warning is logged indicating their absence.\"\"\"\n        '\\n        Return a list of :class:`KeyValue` objects containing checkboxes if the page contains them.\\n\\n        :param selected: True/False Return SELECTED checkboxes\\n        :type selected: bool\\n        :param not_selected: True/False Return NOT_SELECTED checkboxes\\n        :type not_selected: bool\\n\\n        :return: Returns checkboxes that match the conditions set by the flags.\\n        :rtype: EntityList[KeyValue]\\n        '\n        if not self.checkboxes:\n            logging.warning(f'This document does not contain checkboxes')\n            return []\n        else:\n            if selected and not_selected:\n                checkboxes = self.checkboxes\n                return EntityList(checkboxes)\n            checkboxes = []\n            if selected:\n                checkboxes = [kv for kv in self.checkboxes if kv.selection_status == SelectionStatus.SELECTED]\n            if not_selected:\n                checkboxes = [kv for kv in self.checkboxes if kv.selection_status == SelectionStatus.NOT_SELECTED]\n            return EntityList(checkboxes)",
        "docstring": "Filters and returns a list of checkboxes present on the page based on their selection status.\n\n:param selected: A boolean indicating whether to return selected checkboxes. Defaults to True.\n:type selected: bool\n:param not_selected: A boolean indicating whether to return not selected checkboxes. Defaults to True.\n\n:return: An `EntityList` containing `KeyValue` objects that match the selection status criteria specified by the `selected` and `not_selected` parameters. Returns an empty list if no checkboxes are present.\n:rtype: EntityList[KeyValue]\n\nThis method interacts with the `_checkboxes` attribute, which stores `KeyValue` objects that represent checkbox elements detected on the page. The method uses the `SelectionStatus` constant defined in `textractor.data.constants` to determine if each checkbox is selected or not. If the page does not contain any checkboxes, a warning is logged indicating their absence.",
        "signature": "def filter_checkboxes(self, selected: bool=True, not_selected: bool=True) -> EntityList[KeyValue]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.get_words_by_type": {
        "code": "    def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> EntityList[Word]:\n        \"\"\"Returns a filtered list of `Word` entities from the `Page` based on the specified text type.\n\n:param text_type: The type of text to filter words by, which can be either `TextTypes.PRINTED` (for printed text) or `TextTypes.HANDWRITING` (for handwritten text). Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n\n:return: An `EntityList` containing `Word` entities that match the specified text type. If there are no words or if the `text_type` is not an instance of `TextTypes`, appropriate warnings are logged and an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not of type `TextTypes`, indicating an invalid input.\n\nThe function interacts with the `EntityList` class to manage collections of `Word` objects and requires the `textractor.data.constants` module for the `TextTypes` enum to ensure valid text type inputs.\"\"\"\n        '\\n        Returns list of :class:`Word` entities that match the input text type.\\n\\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\\n        :type text_type: TextTypes\\n\\n        :return: Returns list of Word entities that match the input text type.\\n        :rtype: EntityList[Word]\\n        '\n        if not isinstance(text_type, TextTypes):\n            raise InputError('text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants')\n        if not self.words:\n            logging.warn('Document contains no word entities.')\n            return []\n        filtered_words = [word for word in self.words if word.text_type == text_type]\n        return EntityList(filtered_words)",
        "docstring": "Returns a filtered list of `Word` entities from the `Page` based on the specified text type.\n\n:param text_type: The type of text to filter words by, which can be either `TextTypes.PRINTED` (for printed text) or `TextTypes.HANDWRITING` (for handwritten text). Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n\n:return: An `EntityList` containing `Word` entities that match the specified text type. If there are no words or if the `text_type` is not an instance of `TextTypes`, appropriate warnings are logged and an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not of type `TextTypes`, indicating an invalid input.\n\nThe function interacts with the `EntityList` class to manage collections of `Word` objects and requires the `textractor.data.constants` module for the `TextTypes` enum to ensure valid text type inputs.",
        "signature": "def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> EntityList[Word]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.search_words": {
        "code": "    def search_words(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[Word]:\n        \"\"\"Returns a list of the top_k words that best match the specified keyword based on a similarity metric.\n\n:param keyword: The keyword used to query the words present in the page.\n:type keyword: str, required\n:param top_k: The maximum number of closest word objects to return, defaulting to 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used for assessing similarity, which can be one of three options: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN, or SimilarityMetric.LEVENSHTEIN (the default). These constants are defined in `textractor.data.constants`.\n:type similarity_metric: SimilarityMetric\n:param similarity_threshold: This threshold determines the minimum similarity required for a word to be included in the results, defaulting to 0.6.\n:type similarity_threshold: float\n\n:return: An EntityList of Word objects that match the queried keyword, sorted from highest to lowest similarity.\n:rtype: EntityList[Word]\n\nThe function relies on the _search_words_with_similarity method to compute the similarity scores based on the provided parameters. The words returned are filtered based on their similarity to the input keyword.\"\"\"\n        '\\n        Return a list of top_k words that match the keyword.\\n\\n        :param keyword: Keyword that is used to query the document.\\n        :type keyword: str, required\\n        :param top_k: Number of closest word objects to be returned. default=1\\n        :type top_k: int, optional\\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\\n        :type similarity_metric: SimilarityMetric\\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\\n        :type similarity_threshold: float\\n\\n        :return: Returns a list of words that match the queried key sorted from highest to lowest similarity.\\n        :rtype: EntityList[Word]\\n        '\n        top_n_words = EntityList([ent[1] for ent in self._search_words_with_similarity(keyword=keyword, top_k=top_k, similarity_metric=similarity_metric, similarity_threshold=similarity_threshold)])\n        return top_n_words",
        "docstring": "Returns a list of the top_k words that best match the specified keyword based on a similarity metric.\n\n:param keyword: The keyword used to query the words present in the page.\n:type keyword: str, required\n:param top_k: The maximum number of closest word objects to return, defaulting to 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used for assessing similarity, which can be one of three options: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN, or SimilarityMetric.LEVENSHTEIN (the default). These constants are defined in `textractor.data.constants`.\n:type similarity_metric: SimilarityMetric\n:param similarity_threshold: This threshold determines the minimum similarity required for a word to be included in the results, defaulting to 0.6.\n:type similarity_threshold: float\n\n:return: An EntityList of Word objects that match the queried keyword, sorted from highest to lowest similarity.\n:rtype: EntityList[Word]\n\nThe function relies on the _search_words_with_similarity method to compute the similarity scores based on the provided parameters. The words returned are filtered based on their similarity to the input keyword.",
        "signature": "def search_words(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[Word]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.search_lines": {
        "code": "    def search_lines(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> EntityList[Line]:\n        \"\"\"Returns a list of `Line` objects from the page that contain the specified keyword, ordered by similarity to the keyword.\n\n:param keyword: The word or phrase to search for within the lines of the page.\n:type keyword: str\n:param top_k: The maximum number of closest line objects to return, default is 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used to measure similarity between the keyword and the lines. Options include `SimilarityMetric.COSINE`, `SimilarityMetric.EUCLIDEAN`, or `SimilarityMetric.LEVENSHTEIN`, with `SimilarityMetric.LEVENSHTEIN` as the default.\n:type similarity_metric: SimilarityMetric, optional\n:param similarity_threshold: The threshold for similarity to determine matches, default is 0.6.\n:type similarity_threshold: float, optional\n\n:return: An `EntityList` containing the top_k `Line` objects that match the keyword, sorted by similarity from highest to lowest.\n:rtype: EntityList[Line]\n\nThis method depends on the `_search_lines_with_similarity` helper, which performs the similarity calculations. It utilizes constants defined in the `SimilarityMetric` class from `textractor.data.constants`, which standardizes the types of similarity measurements available for querying lines.\"\"\"\n        '\\n        Return a list of top_k lines that contain the queried keyword.\\n\\n        :param keyword: Keyword that is used to query the page.\\n        :type keyword: str\\n        :param top_k: Number of closest line objects to be returned\\n        :type top_k: int\\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\\n        :type similarity_metric: SimilarityMetric\\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\\n        :type similarity_threshold: float\\n\\n        :return: Returns a list of lines that contain the queried key sorted\\n                 from highest to lowest similarity.\\n        :rtype: EntityList[Line]\\n        '\n        top_n_lines = EntityList([ent[1] for ent in self._search_lines_with_similarity(keyword=keyword, top_k=top_k, similarity_metric=similarity_metric, similarity_threshold=similarity_threshold)])\n        return top_n_lines",
        "docstring": "Returns a list of `Line` objects from the page that contain the specified keyword, ordered by similarity to the keyword.\n\n:param keyword: The word or phrase to search for within the lines of the page.\n:type keyword: str\n:param top_k: The maximum number of closest line objects to return, default is 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used to measure similarity between the keyword and the lines. Options include `SimilarityMetric.COSINE`, `SimilarityMetric.EUCLIDEAN`, or `SimilarityMetric.LEVENSHTEIN`, with `SimilarityMetric.LEVENSHTEIN` as the default.\n:type similarity_metric: SimilarityMetric, optional\n:param similarity_threshold: The threshold for similarity to determine matches, default is 0.6.\n:type similarity_threshold: float, optional\n\n:return: An `EntityList` containing the top_k `Line` objects that match the keyword, sorted by similarity from highest to lowest.\n:rtype: EntityList[Line]\n\nThis method depends on the `_search_lines_with_similarity` helper, which performs the similarity calculations. It utilizes constants defined in the `SimilarityMetric` class from `textractor.data.constants`, which standardizes the types of similarity measurements available for querying lines.",
        "signature": "def search_lines(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> EntityList[Line]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.get": {
        "code": "    def get(self, key: str, top_k_matches: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[KeyValue]:\n        \"\"\"Returns a list of up to `top_k_matches` key-value pairs from the Page that match a specified `key`, based on similarity metrics. The function utilizes the `SimilarityMetric` constants, which define various methods (COSINE, EUCLIDEAN, LEVENSHTEIN) to calculate similarity between strings.\n\nParameters:\n- `key` (str): The query key to match against existing key-value pairs in the Page.\n- `top_k_matches` (int, optional): Maximum number of matches to return; default is 1.\n- `similarity_metric` (SimilarityMetric, optional): The metric used for similarity comparison; defaults to `SimilarityMetric.LEVENSHTEIN`.\n- `similarity_threshold` (float, optional): The threshold for similarity; defaults to 0.6.\n\nReturns:\n- EntityList[KeyValue]: A sorted list of matching key-value pairs, ordered by the highest to lowest similarity.\n\nThe function logs a warning if no matches are found and an informative message regarding the number of matches. It modifies the `similarity_threshold` before comparison, depending on the chosen metric and handles punctuation in the `key` and the keys of the key-value pairs for a more accurate comparison.\"\"\"\n        '\\n        Return upto top_k_matches of key-value pairs for the key that is queried from the page.\\n\\n        :param key: Query key to match\\n        :type key: str\\n        :param top_k_matches: Maximum number of matches to return\\n        :type top_k_matches: int\\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\\n        :type similarity_metric: SimilarityMetric\\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\\n        :type similarity_threshold: float\\n\\n        :return: Returns a list of key-value pairs that match the queried key sorted from highest\\n                 to lowest similarity.\\n        :rtype: EntityList[KeyValue]\\n        '\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n = []\n        similarity_threshold = similarity_threshold if similarity_metric == SimilarityMetric.COSINE else -similarity_threshold\n        lowest_similarity = similarity_threshold\n        for kv in self.key_values + self.checkboxes:\n            try:\n                edited_document_key = ''.join([char for char in kv.key.__repr__() if char not in string.punctuation])\n            except:\n                pass\n            key = ''.join([char for char in key if char not in string.punctuation])\n            similarity = [SearchUtils.get_word_similarity(key, word, similarity_metric) for word in edited_document_key.split(' ')]\n            similarity.append(SearchUtils.get_word_similarity(key, edited_document_key, similarity_metric))\n            similarity = max(similarity) if similarity_metric == SimilarityMetric.COSINE else -min(similarity)\n            if similarity > similarity_threshold:\n                if len(top_n) < top_k_matches:\n                    top_n.append((kv, similarity))\n                elif similarity > lowest_similarity:\n                    top_n[-1] = (kv, similarity)\n                top_n = sorted(top_n, key=lambda x: x[1], reverse=True)\n                lowest_similarity = top_n[-1][1]\n        if not top_n:\n            logging.warning(f'Query key does not match any existing keys in the document.{os.linesep}{self.keys()}')\n        logging.info(f'Query key matched {len(top_n)} key-values in the document.')\n        return EntityList([value[0] for value in top_n])",
        "docstring": "Returns a list of up to `top_k_matches` key-value pairs from the Page that match a specified `key`, based on similarity metrics. The function utilizes the `SimilarityMetric` constants, which define various methods (COSINE, EUCLIDEAN, LEVENSHTEIN) to calculate similarity between strings.\n\nParameters:\n- `key` (str): The query key to match against existing key-value pairs in the Page.\n- `top_k_matches` (int, optional): Maximum number of matches to return; default is 1.\n- `similarity_metric` (SimilarityMetric, optional): The metric used for similarity comparison; defaults to `SimilarityMetric.LEVENSHTEIN`.\n- `similarity_threshold` (float, optional): The threshold for similarity; defaults to 0.6.\n\nReturns:\n- EntityList[KeyValue]: A sorted list of matching key-value pairs, ordered by the highest to lowest similarity.\n\nThe function logs a warning if no matches are found and an informative message regarding the number of matches. It modifies the `similarity_threshold` before comparison, depending on the chosen metric and handles punctuation in the `key` and the keys of the key-value pairs for a more accurate comparison.",
        "signature": "def get(self, key: str, top_k_matches: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[KeyValue]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.export_kv_to_csv": {
        "code": "    def export_kv_to_csv(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.csv'):\n        \"\"\"Exports key-value pairs and checkbox statuses from the Page object to a CSV file.\n\n:param include_kv: Specify whether to include key-value pairs in the export. Defaults to True.\n:type include_kv: bool\n:param include_checkboxes: Specify whether to include checkbox status in the export. Defaults to True.\n:type include_checkboxes: bool\n:param filepath: The file path where the CSV file will be stored, defaulting to \"Key-Values.csv\".\n:type filepath: str\n\nThis method retrieves key-values from the Page object, which are stored in the `_key_values` attribute, and checkboxes stored in the `_checkboxes` attribute. Both properties return EntityList objects which contain the respective entities. If the specified entities are not present, a warning is logged. The exported CSV will have a header line with \"Key,Value\" followed by the respective pairs. After execution, an informational log records the location of the saved CSV file, combining the current working directory with the specified filepath.\"\"\"\n        '\\n        Export key-value entities and checkboxes in csv format.\\n\\n        :param include_kv: True if KVs are to be exported. Else False.\\n        :type include_kv: bool\\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\\n        :type include_checkboxes: bool\\n        :param filepath: Path to where file is to be stored.\\n        :type filepath: str\\n        '\n        keys = []\n        values = []\n        if include_kv and (not self.key_values):\n            logging.warning('Document does not contain key-values.')\n        elif include_kv:\n            for kv in self.key_values:\n                keys.append(kv.key.__repr__())\n                values.append(kv.value.__repr__())\n        if include_checkboxes and (not self.checkboxes):\n            logging.warning('Document does not contain checkbox elements.')\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                keys.append(kv.key.__repr__())\n                values.append(kv.value.children[0].status.name)\n        with open(filepath, 'w') as f:\n            f.write(f'Key,Value{os.linesep}')\n            for k, v in zip(keys, values):\n                f.write(f'{k},{v}{os.linesep}')\n        logging.info(f'csv file stored at location {os.path.join(os.getcwd(), filepath)}')",
        "docstring": "Exports key-value pairs and checkbox statuses from the Page object to a CSV file.\n\n:param include_kv: Specify whether to include key-value pairs in the export. Defaults to True.\n:type include_kv: bool\n:param include_checkboxes: Specify whether to include checkbox status in the export. Defaults to True.\n:type include_checkboxes: bool\n:param filepath: The file path where the CSV file will be stored, defaulting to \"Key-Values.csv\".\n:type filepath: str\n\nThis method retrieves key-values from the Page object, which are stored in the `_key_values` attribute, and checkboxes stored in the `_checkboxes` attribute. Both properties return EntityList objects which contain the respective entities. If the specified entities are not present, a warning is logged. The exported CSV will have a header line with \"Key,Value\" followed by the respective pairs. After execution, an informational log records the location of the saved CSV file, combining the current working directory with the specified filepath.",
        "signature": "def export_kv_to_csv(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.csv'):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.export_kv_to_txt": {
        "code": "    def export_kv_to_txt(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.txt'):\n        \"\"\"Exports key-value pairs and checkbox entities from the Page object to a specified text file in a formatted manner. The method generates a sequential list of key-value pairs, where each pair is represented as \"index. key : value\". The parameters `include_kv` and `include_checkboxes` allow for conditional inclusion of these entities based on availability. If the document does not contain any key-values or checkboxes, a warning is logged.\n\nParameters:\n- include_kv (bool): If True, include key-value pairs in the export. Defaults to True.\n- include_checkboxes (bool): If True, include checkbox elements in the export. Defaults to True.\n- filepath (str): The path where the text file will be stored. Defaults to \"Key-Values.txt\".\n\nOutput:\n- Side effects: Writes the formatted key-value and checkbox data to the specified text file. Logs warnings if data is missing.\n\nDependencies:\n- Requires `key_values` and `checkboxes` attributes of the Page class, which hold the relevant entities extracted from the document.\n- Uses the `os` module for file path handling and logging for any warnings.\"\"\"\n        '\\n        Export key-value entities and checkboxes in txt format.\\n\\n        :param include_kv: True if KVs are to be exported. Else False.\\n        :type include_kv: bool\\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\\n        :type include_checkboxes: bool\\n        :param filepath: Path to where file is to be stored.\\n        :type filepath: str\\n        '\n        export_str = []\n        index = 1\n        if include_kv and (not self.key_values):\n            logging.warning('Document does not contain key-values.')\n        elif include_kv:\n            for kv in self.key_values:\n                export_str.append(f'{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}')\n                index += 1\n        if include_checkboxes and (not self.checkboxes):\n            logging.warning('Document does not contain checkbox elements.')\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                export_str.append(f'{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}')\n                index += 1\n        with open(filepath, 'w') as text_file:\n            text_file.write(''.join(export_str))\n        logging.info(f'txt file stored at location {os.path.join(os.getcwd(), filepath)}')",
        "docstring": "Exports key-value pairs and checkbox entities from the Page object to a specified text file in a formatted manner. The method generates a sequential list of key-value pairs, where each pair is represented as \"index. key : value\". The parameters `include_kv` and `include_checkboxes` allow for conditional inclusion of these entities based on availability. If the document does not contain any key-values or checkboxes, a warning is logged.\n\nParameters:\n- include_kv (bool): If True, include key-value pairs in the export. Defaults to True.\n- include_checkboxes (bool): If True, include checkbox elements in the export. Defaults to True.\n- filepath (str): The path where the text file will be stored. Defaults to \"Key-Values.txt\".\n\nOutput:\n- Side effects: Writes the formatted key-value and checkbox data to the specified text file. Logs warnings if data is missing.\n\nDependencies:\n- Requires `key_values` and `checkboxes` attributes of the Page class, which hold the relevant entities extracted from the document.\n- Uses the `os` module for file path handling and logging for any warnings.",
        "signature": "def export_kv_to_txt(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.txt'):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.independent_words": {
        "code": "    def independent_words(self) -> EntityList[Word]:\n        \"\"\"Returns all words in the Page that are independent, meaning they are not contained within tables, checkboxes, or key-value pairs. \n\nIf the Page has no assigned words, a warning is logged, and an empty list is returned. The method first aggregates words from all tables, key-values, and checkboxes present on the Page. It then constructs a set of IDs for these dependent words. Finally, it filters the main list of words to return only those whose IDs are not found in the set of dependent words, encapsulating the result in an EntityList for consistency with other methods in the class.\n\nReturns:\n    EntityList[Word]: A list of independent Word objects that are not associated with any tables, checkboxes, or key-value pairs within the Page.\n\nSide Effects:\n    Logs a warning if no words have been assigned to the Document object.\"\"\"\n        '\\n        :return: Return all words in the document, outside of tables, checkboxes, key-values.\\n        :rtype: EntityList[Word]\\n        '\n        if not self.words:\n            logging.warning('Words have not been assigned to this Document object.')\n            return []\n        else:\n            table_words = sum([table.words for table in self.tables], [])\n            kv_words = sum([kv.words for kv in self.key_values], [])\n            checkbox_words = sum([kv.words for kv in self.checkboxes], [])\n            dependent_words = table_words + checkbox_words + kv_words\n            dependent_word_ids = set([word.id for word in dependent_words])\n            independent_words = [word for word in self.words if word.id not in dependent_word_ids]\n            return EntityList(independent_words)",
        "docstring": "Returns all words in the Page that are independent, meaning they are not contained within tables, checkboxes, or key-value pairs. \n\nIf the Page has no assigned words, a warning is logged, and an empty list is returned. The method first aggregates words from all tables, key-values, and checkboxes present on the Page. It then constructs a set of IDs for these dependent words. Finally, it filters the main list of words to return only those whose IDs are not found in the set of dependent words, encapsulating the result in an EntityList for consistency with other methods in the class.\n\nReturns:\n    EntityList[Word]: A list of independent Word objects that are not associated with any tables, checkboxes, or key-value pairs within the Page.\n\nSide Effects:\n    Logs a warning if no words have been assigned to the Document object.",
        "signature": "def independent_words(self) -> EntityList[Word]:",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.export_tables_to_excel": {
        "code": "    def export_tables_to_excel(self, filepath):\n        \"\"\"Creates an Excel file containing tables from the document, with each table written to a separate worksheet. The file is stored at the specified path provided by the user.\n\n:param filepath: The path where the Excel file will be saved. Must be a valid string representing the file location.\n:type filepath: str, required\n\n:raises ValueError: If the `filepath` is not provided or invalid.\n:raises Exception: Any errors that occur during the creation or writing of the Excel file may propagate from the `xlsxwriter` library.\n\nThis method interacts with the `Table` objects in the `self.tables` attribute, which is an `EntityList[Table]` containing all tables present on the page. Each `Table` should have a `to_excel` method that handles the writing of the table's content to the workbook.\"\"\"\n        '\\n        Creates an excel file and writes each table on a separate worksheet within the workbook.\\n        This is stored on the filepath passed by the user.\\n\\n        :param filepath: Path to store the exported Excel file.\\n        :type filepath: str, required\\n        '\n        if not filepath:\n            logging.error('Filepath required to store excel file.')\n        workbook = xlsxwriter.Workbook(filepath)\n        for table in self.tables:\n            workbook = table.to_excel(filepath=None, workbook=workbook, save_workbook=False)\n        workbook.close()",
        "docstring": "Creates an Excel file containing tables from the document, with each table written to a separate worksheet. The file is stored at the specified path provided by the user.\n\n:param filepath: The path where the Excel file will be saved. Must be a valid string representing the file location.\n:type filepath: str, required\n\n:raises ValueError: If the `filepath` is not provided or invalid.\n:raises Exception: Any errors that occur during the creation or writing of the Excel file may propagate from the `xlsxwriter` library.\n\nThis method interacts with the `Table` objects in the `self.tables` attribute, which is an `EntityList[Table]` containing all tables present on the page. Each `Table` should have a `to_excel` method that handles the writing of the table's content to the workbook.",
        "signature": "def export_tables_to_excel(self, filepath):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      },
      "Page.return_duplicates": {
        "code": "    def return_duplicates(self):\n        \"\"\"Returns a list of `EntityList` objects, where each `EntityList` contains key-value pairs that intersect with the bounding box of each table on the page. This method allows users to identify duplicate key-value entries extracted from documents processed by Textract, facilitating error detection and data validation.\n\nThe function iterates through all tables and key-values on the page, leveraging the bounding box (bbox) properties of each table to determine if any key-values fall within the spatial dimensions of the tables. A key-value is considered a duplicate if its coordinates are within the bounding box of a table.\n\nReturns:\n    - List[EntityList]: A list containing `EntityList` instances. Each instance holds key-value pairs found within the respective table's area, with the last item being the table itself.\n\nDependencies:\n    - `tables`: A property that retrieves all table entities from the `Page` object.\n    - `key_values`: A property that retrieves all key-value entities from the `Page` object.\n    - Each `table` has bounding box attributes (`x`, `y`, `width`, and `height`) used to determine its spatial dimensions.\"\"\"\n        '\\n        Returns a list containing :class:`EntityList` objects.\\n        Each :class:`EntityList` instance contains the key-values and the last item is the table which contains duplicate information.\\n        This function is intended to let the Textract user know of duplicate objects extracted by the various Textract models.\\n\\n        :return: List of EntityList objects each containing the intersection of KeyValue and Table entities on the page.\\n        :rtype: List[EntityList]\\n        '\n        tables = self.tables\n        key_values = self.key_values\n        document_duplicates = []\n        for table in tables:\n            table_duplicates = EntityList([])\n            table_x1, table_x2, table_y1, table_y2 = (table.bbox.x, table.bbox.x + table.bbox.width, table.bbox.y, table.bbox.y + table.bbox.height)\n            for kv in key_values:\n                if kv.bbox.x >= table_x1 and kv.bbox.x <= table_x2 and (kv.bbox.y >= table_y1) and (kv.bbox.y <= table_y2):\n                    table_duplicates.append(kv)\n            if table_duplicates:\n                table_duplicates.append(table)\n            document_duplicates.append(table_duplicates)\n        return document_duplicates",
        "docstring": "Returns a list of `EntityList` objects, where each `EntityList` contains key-value pairs that intersect with the bounding box of each table on the page. This method allows users to identify duplicate key-value entries extracted from documents processed by Textract, facilitating error detection and data validation.\n\nThe function iterates through all tables and key-values on the page, leveraging the bounding box (bbox) properties of each table to determine if any key-values fall within the spatial dimensions of the tables. A key-value is considered a duplicate if its coordinates are within the bounding box of a table.\n\nReturns:\n    - List[EntityList]: A list containing `EntityList` instances. Each instance holds key-value pairs found within the respective table's area, with the last item being the table itself.\n\nDependencies:\n    - `tables`: A property that retrieves all table entities from the `Page` object.\n    - `key_values`: A property that retrieves all key-value entities from the `Page` object.\n    - Each `table` has bounding box attributes (`x`, `y`, `width`, and `height`) used to determine its spatial dimensions.",
        "signature": "def return_duplicates(self):",
        "type": "Method",
        "class_signature": "class Page(SpatialObject, Linearizable):"
      }
    },
    "textractor/entities/key_value.py": {
      "KeyValue.value": {
        "code": "    def value(self, value: Value):\n        \"\"\"Add a :class:`Value` object to the :class:`KeyValue` entity, representing the value associated with the key.\n\n:param value: A `Value` object that holds the information corresponding to the key. This object is an instance of the `Value` class defined in the `textractor.entities.value` module.\n:type value: Value\n\nThis method sets the internal attribute `_value` to the provided `Value` object, which can later be accessed via the `value` property of the `KeyValue` class. The `value` is crucial for establishing the association between the key and its corresponding value in a key-value pair representation.\"\"\"\n        '\\n        Add :class:`Value` object to the :class:`KeyValue`.\\n\\n        :param value: Value object, representing a single value associated with the key.\\n        :type value: Value\\n        '\n        self._value = value",
        "docstring": "Add a :class:`Value` object to the :class:`KeyValue` entity, representing the value associated with the key.\n\n:param value: A `Value` object that holds the information corresponding to the key. This object is an instance of the `Value` class defined in the `textractor.entities.value` module.\n:type value: Value\n\nThis method sets the internal attribute `_value` to the provided `Value` object, which can later be accessed via the `value` property of the `KeyValue` class. The `value` is crucial for establishing the association between the key and its corresponding value in a key-value pair representation.",
        "signature": "def value(self, value: Value):",
        "type": "Method",
        "class_signature": "class KeyValue(DocumentEntity):"
      }
    },
    "textractor/entities/document.py": {
      "Document.open": {
        "code": "    def open(cls, fp: Union[dict, str, Path, IO[AnyStr]]):\n        \"\"\"Create a Document object from various input formats including a JSON file path, file handle, or a response dictionary. This method checks the type of the input parameter `fp`, which can be a dictionary, string, Path object, or a file-like object. Depending on the type, it either parses the provided content directly or downloads a JSON response from an S3 bucket using the `boto3` library.\n\nParameters:\n- fp (Union[dict, str, Path, IO[AnyStr]]): The input source to create a Document. It can be a dictionary for direct parsing, a string or Path object for file paths, or a file handle.\n  \nReturns:\n- Document: An instance of the Document class, populated with data from the provided input.\n\nRaises:\n- InputError: If the input does not match any accepted types (dict, str, Path, or file handle).\n\nDependencies:\n- The method interacts with `response_parser` to handle the parsing process, which\u2014if not provided as input\u2014is hoped to handle different input sources effectively. It also utilizes the `boto3` library to fetch data from AWS S3 if the input is a string starting with \"s3://\".\"\"\"\n        'Create a Document object from a JSON file path, file handle or response dictionary\\n\\n        :param fp: _description_\\n        :type fp: Union[dict, str, Path, IO[AnyStr]]\\n        :raises InputError: Raised on input not being of type Union[dict, str, Path, IO[AnyStr]]\\n        :return: Document object\\n        :rtype: Document\\n        '\n        from textractor.parsers import response_parser\n        if isinstance(fp, dict):\n            return response_parser.parse(fp)\n        elif isinstance(fp, str):\n            if fp.startswith('s3://'):\n                client = boto3.client('s3')\n                return response_parser.parse(json.load(download_from_s3(client, fp)))\n            with open(fp, 'r') as f:\n                return response_parser.parse(json.load(f))\n        elif isinstance(fp, Path):\n            with open(fp, 'r') as f:\n                return response_parser.parse(json.load(f))\n        elif isinstance(fp, io.IOBase):\n            return response_parser.parse(json.load(fp))\n        else:\n            raise InputError(f'Document.open() input must be of type dict, str, Path or a file handle, not {type(fp)}')",
        "docstring": "Create a Document object from various input formats including a JSON file path, file handle, or a response dictionary. This method checks the type of the input parameter `fp`, which can be a dictionary, string, Path object, or a file-like object. Depending on the type, it either parses the provided content directly or downloads a JSON response from an S3 bucket using the `boto3` library.\n\nParameters:\n- fp (Union[dict, str, Path, IO[AnyStr]]): The input source to create a Document. It can be a dictionary for direct parsing, a string or Path object for file paths, or a file handle.\n  \nReturns:\n- Document: An instance of the Document class, populated with data from the provided input.\n\nRaises:\n- InputError: If the input does not match any accepted types (dict, str, Path, or file handle).\n\nDependencies:\n- The method interacts with `response_parser` to handle the parsing process, which\u2014if not provided as input\u2014is hoped to handle different input sources effectively. It also utilizes the `boto3` library to fetch data from AWS S3 if the input is a string starting with \"s3://\".",
        "signature": "def open(cls, fp: Union[dict, str, Path, IO[AnyStr]]):",
        "type": "Method",
        "class_signature": "class Document(SpatialObject, Linearizable):"
      },
      "Document.page": {
        "code": "    def page(self, page_no: int=0):\n        \"\"\"Returns the :class:`Page` object(s) corresponding to the specified page number(s) within the Document. The method supports zero-indexing, allowing users to access a single page or multiple pages based on the input type.\n\n:param page_no: The page number to retrieve. If an integer is provided, a single `Page` object is returned. If a list of integers is supplied, a list of corresponding `Page` objects is returned.\n:type page_no: int | list[int]\n\n:return: A single `Page` object if an integer is given; otherwise, returns a list of `Page` objects.\n:rtype: Page | List[Page]\n\n:raises InputError: If the `page_no` parameter is neither an integer nor a list of integers.\n\nThis method interacts with the `self.pages` attribute, which is a list of `Page` objects representing the pages of the document. The `InputError` is defined in the `textractor.exceptions` module and is used to validate input types for robustness.\"\"\"\n        '\\n        Returns :class:`Page` object/s depending on the input page_no. Follows zero-indexing.\\n\\n        :param page_no: if int, returns single Page Object, else if list, it returns a list of\\n                        Page objects.\\n        :type page_no: int if single page, list of int if multiple pages\\n\\n        :return: Filters and returns Page objects depending on the input page_no\\n        :rtype: Page or List[Page]\\n        '\n        if isinstance(page_no, int):\n            return self.pages[page_no]\n        elif isinstance(page_no, list):\n            return [self.pages[num] for num in page_no]\n        else:\n            raise InputError(\"page_no parameter doesn't match required data type.\")",
        "docstring": "Returns the :class:`Page` object(s) corresponding to the specified page number(s) within the Document. The method supports zero-indexing, allowing users to access a single page or multiple pages based on the input type.\n\n:param page_no: The page number to retrieve. If an integer is provided, a single `Page` object is returned. If a list of integers is supplied, a list of corresponding `Page` objects is returned.\n:type page_no: int | list[int]\n\n:return: A single `Page` object if an integer is given; otherwise, returns a list of `Page` objects.\n:rtype: Page | List[Page]\n\n:raises InputError: If the `page_no` parameter is neither an integer nor a list of integers.\n\nThis method interacts with the `self.pages` attribute, which is a list of `Page` objects representing the pages of the document. The `InputError` is defined in the `textractor.exceptions` module and is used to validate input types for robustness.",
        "signature": "def page(self, page_no: int=0):",
        "type": "Method",
        "class_signature": "class Document(SpatialObject, Linearizable):"
      }
    },
    "textractor/entities/value.py": {
      "Value.words": {
        "code": "    def words(self, words: List[Word]):\n        \"\"\"Sets the list of Word objects that represent the words within the Value field. The words are stored in a private attribute and are internally sorted based on their bounding box coordinates (x + y), ensuring that their order reflects their position in the document.\n\n:param words: A list of Word objects, each representing a word associated with the Value entity. No specific ordering is assumed before passing, as the function handles the ordering internally.\n:type words: List[Word]\n\nThis method interacts with the private `_words` attribute of the Value class, which is used to manage the words associated with the Value instance. Sorting ensures that the words are processed sequentially based on their spatial layout, which is critical for accurate representation and further processing in tasks such as text extraction and HTML rendering.\"\"\"\n        '\\n        Add Word objects to the Value.\\n\\n        :param words: List of Word objects, each representing a word within the Value field.\\n        No specific ordering is assumed as is it is ordered internally.\\n        :type words: list\\n        '\n        self._words = sorted(words, key=lambda x: x.bbox.x + x.bbox.y)",
        "docstring": "Sets the list of Word objects that represent the words within the Value field. The words are stored in a private attribute and are internally sorted based on their bounding box coordinates (x + y), ensuring that their order reflects their position in the document.\n\n:param words: A list of Word objects, each representing a word associated with the Value entity. No specific ordering is assumed before passing, as the function handles the ordering internally.\n:type words: List[Word]\n\nThis method interacts with the private `_words` attribute of the Value class, which is used to manage the words associated with the Value instance. Sorting ensures that the words are processed sequentially based on their spatial layout, which is critical for accurate representation and further processing in tasks such as text extraction and HTML rendering.",
        "signature": "def words(self, words: List[Word]):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      }
    },
    "textractor/visualizers/entitylist.py": {
      "EntityList.pretty_print": {
        "code": "    def pretty_print(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, with_page_number: bool=False, trim: bool=False) -> str:\n        \"\"\"Generates a formatted string representation of entities within the EntityList, categorized by their types.\nThe output includes words, lines, key-value pairs, tables, queries, expense documents, and identity documents, each formatted according to specified options.\n\nParameters:\n- table_format (TableFormat): Specifies the formatting style for tables; defaults to GITHUB format. This is an enumerated type defined in textractor.data.constants.\n- with_confidence (bool): If True, includes the confidence score of predictions in the output; defaults to False.\n- with_geo (bool): If True, includes bounding box information in the output; defaults to False.\n- with_page_number (bool): If True, adds the corresponding page number to each entity's output; defaults to False.\n- trim (bool): If True, trims the text in the output; defaults to False.\n\nReturns:\n- str: A concatenated string of all formatted entities based on the specified parameters.\n\nThe method interacts with several helper functions, such as _get_text_string, _get_forms_string, and _get_tables_string, which specifically handle formatting for different entity types. It also leverages the TextractType enum to identify entity types when formatting.\"\"\"\n        '\\n        Returns a formatted string output for each of the entities in the list according to its entity type.\\n\\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\\n        :type table_format: TableFormat\\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\\n        :type with_confidence: bool\\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\\n        :type with_geo: bool\\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\\n        :type with_page_number: bool\\n        :param trim: Flag to trim text in the entity string. default= False.\\n        :type trim: bool\\n\\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\\n        :rtype: str\\n        '\n        result_value = ''\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.WORDS)\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.LINES)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.KEY_VALUE_SET)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.SELECTION_ELEMENT)\n        result_value += self._get_tables_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim)\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value",
        "docstring": "Generates a formatted string representation of entities within the EntityList, categorized by their types.\nThe output includes words, lines, key-value pairs, tables, queries, expense documents, and identity documents, each formatted according to specified options.\n\nParameters:\n- table_format (TableFormat): Specifies the formatting style for tables; defaults to GITHUB format. This is an enumerated type defined in textractor.data.constants.\n- with_confidence (bool): If True, includes the confidence score of predictions in the output; defaults to False.\n- with_geo (bool): If True, includes bounding box information in the output; defaults to False.\n- with_page_number (bool): If True, adds the corresponding page number to each entity's output; defaults to False.\n- trim (bool): If True, trims the text in the output; defaults to False.\n\nReturns:\n- str: A concatenated string of all formatted entities based on the specified parameters.\n\nThe method interacts with several helper functions, such as _get_text_string, _get_forms_string, and _get_tables_string, which specifically handle formatting for different entity types. It also leverages the TextractType enum to identify entity types when formatting.",
        "signature": "def pretty_print(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, with_page_number: bool=False, trim: bool=False) -> str:",
        "type": "Method",
        "class_signature": "class EntityList(list, Generic[T], Linearizable):"
      }
    }
  },
  "dependency_dict": {
    "textractor/entities/document.py:Document:open": {
      "textractor/parsers/response_parser.py": {
        "parse": {
          "code": "def parse(response: dict) -> Document:\n    \"\"\"\n    Ingests response data and API Call Mode and calls the appropriate function for it.\n    Presently supports only SYNC and ASYNC API calls. Will be extended to Analyze ID and Expense in the future.\n\n    :param response: JSON response data in a format readable by the ResponseParser.\n    :type response: dict\n\n    :return: Document object returned after making respective parse function calls.\n    :rtype: Document\n    \"\"\"\n    if \"IdentityDocuments\" in response:\n        return parse_analyze_id_response(response)\n    if \"ExpenseDocuments\" in response:\n        return parser_analyze_expense_response(response)\n    else:\n        return parse_document_api_response(converter(response))",
          "docstring": "Ingests response data and API Call Mode and calls the appropriate function for it.\nPresently supports only SYNC and ASYNC API calls. Will be extended to Analyze ID and Expense in the future.\n\n:param response: JSON response data in a format readable by the ResponseParser.\n:type response: dict\n\n:return: Document object returned after making respective parse function calls.\n:rtype: Document",
          "signature": "def parse(response: dict) -> Document:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "textractor/entities/document.py:Document:page": {
      "textractor/entities/document.py": {
        "Document.pages": {
          "code": "    def pages(self, pages: List[Page]):\n        \"\"\"\n        Add Page objects to the Document.\n\n        :param pages: List of Page objects, each representing a page within the document.\n        No specific ordering is assumed with input.\n        :type pages: List[Page]\n        \"\"\"\n        self._pages = sorted(pages, key=lambda x: x.page_num)",
          "docstring": "Add Page objects to the Document.\n\n:param pages: List of Page objects, each representing a page within the document.\nNo specific ordering is assumed with input.\n:type pages: List[Page]",
          "signature": "def pages(self, pages: List[Page]):",
          "type": "Method",
          "class_signature": "class Document(SpatialObject, Linearizable):"
        }
      }
    },
    "textractor/visualizers/entitylist.py:EntityList:pretty_print": {
      "textractor/visualizers/entitylist.py": {
        "EntityList._get_text_string": {
          "code": "    def _get_text_string(self, with_page_number=False, with_confidence=False, trim=False, textract_type=TextractType.WORDS):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        if textract_type == TextractType.WORDS:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Word'], key=lambda x: x.page)\n        else:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Line'], key=lambda x: x.page)\n        current_page = -1\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f'--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}'\n                current_page = word.page\n            if trim:\n                result_value += f'{word.text.strip()}'\n            else:\n                result_value += f'{word.text}'\n            if with_confidence:\n                result_value += f', {word.confidence}'\n            result_value += os.linesep\n        return result_value",
          "docstring": "Returns a formatted string output for the entity type stated in the textract_type param. This function is\nspecific to TextractType.WORDS and TextractType.LINES.\n\n:param with_page_number: Flag to add the page number to the entity string. default= False.\n:type with_page_number: bool\n:param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n:type with_confidence: bool\n:param trim: Flag to trim text in the entity string. default= False.\n:type trim: bool\n:param textract_type: TextractType.WORDS / TextractType.LINES\n:type textract_type: TextractType\n\n:return: Returns a formatted string output for the entity type stated in the textract_type param.\n:rtype: str",
          "signature": "def _get_text_string(self, with_page_number=False, with_confidence=False, trim=False, textract_type=TextractType.WORDS):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList._get_forms_string": {
          "code": "    def _get_forms_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        result_value = ''\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and (not obj.contains_checkbox)]\n        else:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and obj.contains_checkbox]\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                result_value += tabulate(forms_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            csv_output = StringIO()\n            csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value",
          "docstring": "Returns a formatted string output for the entity type stated in the textract_type param. This function is\nspecific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n:param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                     This is a predefined set of choices by the PyPI tabulate package.\n:type table_format: TableFormat\n:param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n:type with_confidence: bool\n:param with_geo: Flag to add the bounding box information to the entity string. default= False.\n:type with_geo: bool\n:param trim: Flag to trim text in the entity string. default= False.\n:type trim: bool\n:param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n:type textract_type: TextractType\n\n:return: Returns a formatted string output for the entity type stated in the textract_type param.\n:rtype: str",
          "signature": "def _get_forms_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> str:",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList._get_tables_string": {
          "code": "    def _get_tables_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == 'Table':\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == 'TableCell':\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n        result_value = ''\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                result_value += tabulate(table_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                csv_output = StringIO()\n                csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value",
          "docstring": "Returns a formatted string output for the Table entity type.\n\n:param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                     This is a predefined set of choices by the PyPI tabulate package.\n:type table_format: TableFormat\n:param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n:type with_confidence: bool\n:param with_geo: Flag to add the bounding box information to the entity string. default= False.\n:type with_geo: bool\n:param trim: Flag to trim text in the entity string. default= False.\n:type trim: bool\n\n:return: Returns a formatted string output for the Table entity type.\n:rtype: str",
          "signature": "def _get_tables_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False) -> str:",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList._get_queries_string": {
          "code": "    def _get_queries_string(self):\n        result_value = ''\n        queries = [obj for obj in self if obj.__class__.__name__ == 'Query']\n        for query in queries:\n            if query.result is not None:\n                result_value += f'{query.query} => {query.result.answer}{os.linesep}'\n            else:\n                result_value += f'{query.query} => {os.linesep}'\n        return result_value",
          "docstring": "",
          "signature": "def _get_queries_string(self):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList._get_expense_documents_string": {
          "code": "    def _get_expense_documents_string(self):\n        result_value = ''\n        expense_documents = [obj for obj in self if obj.__class__.__name__ == 'ExpenseDocument']\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f'Expense Document {i + 1}:{os.linesep}'\n            result_value += f'### Summary Fields:{os.linesep}'\n            result_value += f'{expense_document.summary_fields}{os.linesep}'\n            result_value += f'### Line Item Groups: {os.linesep}'\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f'{line_item_group}{os.linesep}'\n        return result_value",
          "docstring": "",
          "signature": "def _get_expense_documents_string(self):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList._get_id_documents_string": {
          "code": "    def _get_id_documents_string(self):\n        result_value = ''\n        id_documents = [obj for obj in self if obj.__class__.__name__ == 'IdentityDocument']\n        for id_document in id_documents:\n            result_value += f'{id_document}{os.linesep}'\n        return result_value",
          "docstring": "",
          "signature": "def _get_id_documents_string(self):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    },
    "textractor/entities/value.py:Value:words": {
      "textractor/entities/selection_element.py": {
        "SelectionElement.words": {
          "code": "    def words(self) -> List[Word]:\n        \"\"\"\n        :return: Empty Word list as SelectionElement do not have words\n        :rtype: EntityList[Word]\n        \"\"\"\n        return []",
          "docstring": ":return: Empty Word list as SelectionElement do not have words\n:rtype: EntityList[Word]",
          "signature": "def words(self) -> List[Word]:",
          "type": "Method",
          "class_signature": "class SelectionElement(DocumentEntity):"
        }
      },
      "textractor/entities/value.py": {
        "Value.contains_checkbox": {
          "code": "    def contains_checkbox(self, checkbox_present: bool):\n        \"\"\"\n        Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\n\n        :param checkbox_present: True or False depending on checkbox presence.\n        :type checkbox_present: bool\n        \"\"\"\n        self._contains_checkbox = checkbox_present",
          "docstring": "Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\n\n:param checkbox_present: True or False depending on checkbox presence.\n:type checkbox_present: bool",
          "signature": "def contains_checkbox(self, checkbox_present: bool):",
          "type": "Method",
          "class_signature": "class Value(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:__repr__": {
      "textractor/entities/page.py": {
        "Page.queries": {
          "code": "    def queries(self, queries: List[Query]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._queries = EntityList(queries)",
          "docstring": "Add Signature objects to the Page.\n\n:param signatures: List of Signature objects.\n:type signatures: list",
          "signature": "def queries(self, queries: List[Query]):",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        },
        "Page.signatures": {
          "code": "    def signatures(self, signatures: List[Signature]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._signatures = EntityList(signatures)",
          "docstring": "Add Signature objects to the Page.\n\n:param signatures: List of Signature objects.\n:type signatures: list",
          "signature": "def signatures(self, signatures: List[Signature]):",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        },
        "Page.layouts": {
          "code": "    def layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(sorted(self._leaf_layouts + self._container_layouts, key=lambda c: c.reading_order))",
          "docstring": "Returns all the :class:`Layout` objects present in the Page.\n\n:return: List of Layout objects.\n:rtype: EntityList",
          "signature": "def layouts(self) -> EntityList[Layout]:",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        },
        "Page.expense_documents": {
          "code": "    def expense_documents(self, expense_documents: List[ExpenseDocument]):\n        \"\"\"\n        Add ExpenseDocument objects to the Page.\n\n        :param tables: List of ExpenseDocument objects.\n        :type expense_documents: list\n        \"\"\"\n        self._expense_documents = EntityList(expense_documents)",
          "docstring": "Add ExpenseDocument objects to the Page.\n\n:param tables: List of ExpenseDocument objects.\n:type expense_documents: list",
          "signature": "def expense_documents(self, expense_documents: List[ExpenseDocument]):",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        }
      }
    },
    "textractor/entities/page.py:Page:keys": {
      "textractor/entities/key_value.py": {
        "KeyValue.key": {
          "code": "    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)",
          "docstring": "Add :class:`Word` objects to the Key.\n\n:param words: List of Word objects, each representing a word within the Key.\nNo specific ordering is assumed.\n:type words: list",
          "signature": "def key(self, words: List[Word]):",
          "type": "Method",
          "class_signature": "class KeyValue(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:filter_checkboxes": {
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    },
    "textractor/entities/page.py:Page:get_words_by_type": {
      "textractor/entities/word.py": {
        "Word.text_type": {
          "code": "    def text_type(self, text_type: TextTypes):\n        \"\"\"\n        Sets the text type of the :class:`Word` entity.\n\n        :param text_type: Constant containing the type of text\n        \"\"\"\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type",
          "docstring": "Sets the text type of the :class:`Word` entity.\n\n:param text_type: Constant containing the type of text",
          "signature": "def text_type(self, text_type: TextTypes):",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    },
    "textractor/entities/page.py:Page:search_words": {
      "textractor/entities/page.py": {
        "Page._search_words_with_similarity": {
          "code": "    def _search_words_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> List[Tuple[Word, float]]:\n        \"\"\"\n        Returns a list of top_k words with their similarity to the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str, required\n        :param top_k: Number of closest word objects to be returned. default=1\n        :type top_k: int, optional\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples containing similarity and Word.\n        :rtype: List[Tuple(float, Word)]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n_words = []\n        similarity_threshold = similarity_threshold if similarity_metric == SimilarityMetric.COSINE else -similarity_threshold\n        lowest_similarity = similarity_threshold\n        for word in self.words:\n            similarity = SearchUtils.get_word_similarity(keyword, word.text, similarity_metric)\n            similarity = similarity if similarity_metric == SimilarityMetric.COSINE else -similarity\n            if len(top_n_words) < top_k and similarity > similarity_threshold:\n                top_n_words.append((similarity, word))\n            elif similarity > lowest_similarity:\n                top_n_words[-1] = (similarity, word)\n            else:\n                continue\n            top_n_words = sorted(top_n_words, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_words[-1][0]\n        return top_n_words",
          "docstring": "Returns a list of top_k words with their similarity to the keyword.\n\n:param keyword: Keyword that is used to query the document.\n:type keyword: str, required\n:param top_k: Number of closest word objects to be returned. default=1\n:type top_k: int, optional\n:param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n:type similarity_metric: SimilarityMetric\n:param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n:type similarity_threshold: float\n\n:return: Returns a list of tuples containing similarity and Word.\n:rtype: List[Tuple(float, Word)]]",
          "signature": "def _search_words_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> List[Tuple[Word, float]]:",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        }
      },
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    },
    "textractor/entities/page.py:Page:get": {
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        },
        "EntityList.__add__": {
          "code": "    def __add__(self, list2):\n        return EntityList([*self, *list2])",
          "docstring": "",
          "signature": "def __add__(self, list2):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      },
      "textractor/utils/search_utils.py": {
        "SearchUtils.get_word_similarity": {
          "code": "    def get_word_similarity(\n        cls, word_1: str, word_2: str, similarity_metric: SimilarityMetric\n    ) -> float:\n        \"\"\"\n        Returns the extent of similarity between the input words using the similarity_metric input by the user.\n\n        :param word_1: First word to check for similarity\n        :type word_1: str\n        :param word_2: Second word to check for similarity\n        :type word_2: str\n        :param similarity_metric: The function supports one of 3 metrics \\\n                                * Levenshtein distance/ edit distance \\\n                                * Euclidean distance \\\n                                * Cosine distance\n        :type similarity_metric: str\n\n        :return: Returns the similarity measure calculated based on the metric for the 2 input words.\n        :rtype: float\n        \"\"\"\n        if cls.model is None and similarity_metric != SimilarityMetric.LEVENSHTEIN:\n            try:\n                from sentence_transformers import SentenceTransformer, util\n            except ImportError:\n                raise MissingDependencyException(\n                    \"sentence_transformers is not installed. Use SimilarityMetric.LEVENSHTEIN.\"\n                )\n            cls.model = SentenceTransformer(cls.model_string)\n            cls.util = util\n\n        if similarity_metric == SimilarityMetric.LEVENSHTEIN:\n            return normalized_edit_distance(word_1.lower(), word_2.lower())\n        elif similarity_metric == SimilarityMetric.EUCLIDEAN:\n            ref_word_emb = cls.model.encode([word_1])\n            word_emb = cls.model.encode([word_2])\n            dist = np.linalg.norm(ref_word_emb - word_emb)\n            return dist\n        else:\n            ref_word_emb = cls.model.encode([word_1])\n            word_emb = cls.model.encode([word_2])\n            similarity = cls.util.cos_sim(ref_word_emb, word_emb)\n            return similarity.item()",
          "docstring": "Returns the extent of similarity between the input words using the similarity_metric input by the user.\n\n:param word_1: First word to check for similarity\n:type word_1: str\n:param word_2: Second word to check for similarity\n:type word_2: str\n:param similarity_metric: The function supports one of 3 metrics                                 * Levenshtein distance/ edit distance                                 * Euclidean distance                                 * Cosine distance\n:type similarity_metric: str\n\n:return: Returns the similarity measure calculated based on the metric for the 2 input words.\n:rtype: float",
          "signature": "def get_word_similarity(cls, word_1: str, word_2: str, similarity_metric: SimilarityMetric) -> float:",
          "type": "Method",
          "class_signature": "class SearchUtils:"
        }
      },
      "textractor/entities/word.py": {
        "Word.__repr__": {
          "code": "    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f\"{self.text}\"",
          "docstring": ":return: String representation of the Word entity.\n:rtype: str",
          "signature": "def __repr__(self) -> str:",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/entities/key_value.py": {
        "KeyValue.key": {
          "code": "    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)",
          "docstring": "Add :class:`Word` objects to the Key.\n\n:param words: List of Word objects, each representing a word within the Key.\nNo specific ordering is assumed.\n:type words: list",
          "signature": "def key(self, words: List[Word]):",
          "type": "Method",
          "class_signature": "class KeyValue(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:search_lines": {
      "textractor/entities/page.py": {
        "Page._search_lines_with_similarity": {
          "code": "    def _search_lines_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> List[Tuple[Line, float]]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the page.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples of lines and their similarity to the keyword that contain the queried key sorted\n                 from highest to lowest similarity.\n        :rtype: List[Tuple[Line, float]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n_lines = []\n        similarity_threshold = similarity_threshold if similarity_metric == SimilarityMetric.COSINE else -similarity_threshold\n        lowest_similarity = similarity_threshold\n        for line in self.lines:\n            similarity = [SearchUtils.get_word_similarity(keyword, word, similarity_metric) for word in line.__repr__().split(' ')]\n            similarity.append(SearchUtils.get_word_similarity(keyword, line.__repr__(), similarity_metric))\n            similarity = max(similarity) if similarity_metric == SimilarityMetric.COSINE else -min(similarity)\n            if len(top_n_lines) < top_k and similarity > similarity_threshold:\n                top_n_lines.append((similarity, line))\n            elif similarity > lowest_similarity:\n                top_n_lines[-1] = (similarity, line)\n            else:\n                continue\n            top_n_lines = sorted(top_n_lines, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_lines[-1][0]\n        return top_n_lines",
          "docstring": "Return a list of top_k lines that contain the queried keyword.\n\n:param keyword: Keyword that is used to query the page.\n:type keyword: str\n:param top_k: Number of closest line objects to be returned\n:type top_k: int\n:param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n:type similarity_metric: SimilarityMetric\n:param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n:type similarity_threshold: float\n\n:return: Returns a list of tuples of lines and their similarity to the keyword that contain the queried key sorted\n         from highest to lowest similarity.\n:rtype: List[Tuple[Line, float]]",
          "signature": "def _search_lines_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> List[Tuple[Line, float]]:",
          "type": "Method",
          "class_signature": "class Page(SpatialObject, Linearizable):"
        }
      },
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    },
    "textractor/entities/page.py:Page:export_kv_to_csv": {
      "textractor/entities/value.py": {
        "Value.__repr__": {
          "code": "    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Value entity.\n        :rtype: str\n        \"\"\"\n        repr_string = ''\n        if self.contains_checkbox:\n            repr_string += f'{self.children[0].__repr__()}'\n        else:\n            words = ' '.join([word.text for word in self.words])\n            repr_string += f'{words}'\n        return repr_string",
          "docstring": ":return: String representation of the Value entity.\n:rtype: str",
          "signature": "def __repr__(self) -> str:",
          "type": "Method",
          "class_signature": "class Value(DocumentEntity):"
        }
      },
      "textractor/entities/word.py": {
        "Word.__repr__": {
          "code": "    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f\"{self.text}\"",
          "docstring": ":return: String representation of the Word entity.\n:rtype: str",
          "signature": "def __repr__(self) -> str:",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/entities/key_value.py": {
        "KeyValue.key": {
          "code": "    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)",
          "docstring": "Add :class:`Word` objects to the Key.\n\n:param words: List of Word objects, each representing a word within the Key.\nNo specific ordering is assumed.\n:type words: list",
          "signature": "def key(self, words: List[Word]):",
          "type": "Method",
          "class_signature": "class KeyValue(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:export_kv_to_txt": {
      "textractor/entities/value.py": {
        "Value.__repr__": {
          "code": "    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Value entity.\n        :rtype: str\n        \"\"\"\n        repr_string = ''\n        if self.contains_checkbox:\n            repr_string += f'{self.children[0].__repr__()}'\n        else:\n            words = ' '.join([word.text for word in self.words])\n            repr_string += f'{words}'\n        return repr_string",
          "docstring": ":return: String representation of the Value entity.\n:rtype: str",
          "signature": "def __repr__(self) -> str:",
          "type": "Method",
          "class_signature": "class Value(DocumentEntity):"
        }
      },
      "textractor/entities/word.py": {
        "Word.__repr__": {
          "code": "    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f\"{self.text}\"",
          "docstring": ":return: String representation of the Word entity.\n:rtype: str",
          "signature": "def __repr__(self) -> str:",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/entities/key_value.py": {
        "KeyValue.key": {
          "code": "    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)",
          "docstring": "Add :class:`Word` objects to the Key.\n\n:param words: List of Word objects, each representing a word within the Key.\nNo specific ordering is assumed.\n:type words: list",
          "signature": "def key(self, words: List[Word]):",
          "type": "Method",
          "class_signature": "class KeyValue(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:export_tables_to_excel": {
      "textractor/entities/table.py": {
        "Table.to_excel": {
          "code": "    def to_excel(self, filepath=None, workbook=None, save_workbook=True):\n        \"\"\"\n        Export the Table Entity as an excel document. Advantage of excel over csv is that it can accommodate merged cells that we see so often with Textract documents.\n\n        :param filepath: Path to store the exported Excel file\n        :type filepath: str\n        :param workbook: if xlsxwriter workbook is passed to the function, the table is appended to the last sheet of that workbook.\n        :type workbook: xlsxwriter.Workbook\n        :param save_workbook: Flag to save_notebook. If False, it is returned by the function.\n        :type save_workbook: bool\n\n        :return: Returns a workbook if save_workbook is False. Else, saves the .xlsx file in the filepath if was initialized with.\n        :rtype: xlsxwriter.Workbook\n        \"\"\"\n        if workbook is None:\n            if filepath is not None:\n                workbook = xlsxwriter.Workbook(filepath)\n            else:\n                logging.error(\"You need to provide a filepath or a workbook\")\n\n        worksheet = workbook.add_worksheet()\n\n        merged_cells = set()\n        for cell in self.table_cells:\n            cell_content = cell.__repr__().split(\">\")[1][1:]\n            if cell.metadata[IS_MERGED_CELL]:\n                first_row, first_col, last_row, last_col = cell._get_merged_cell_range()\n                if (first_row, first_col, last_row, last_col) in merged_cells:\n                    continue\n                else:\n                    merged_cells.add((first_row, first_col, last_row, last_col))\n                worksheet.merge_range(\n                    first_row - 1,\n                    first_col - 1,\n                    last_row - 1,\n                    last_col - 1,\n                    cell_content,\n                )\n            else:\n                worksheet.write_string(\n                    cell.row_index - 1, cell.col_index - 1, cell_content\n                )\n\n        if save_workbook:\n            workbook.close()\n\n        else:\n            return workbook",
          "docstring": "Export the Table Entity as an excel document. Advantage of excel over csv is that it can accommodate merged cells that we see so often with Textract documents.\n\n:param filepath: Path to store the exported Excel file\n:type filepath: str\n:param workbook: if xlsxwriter workbook is passed to the function, the table is appended to the last sheet of that workbook.\n:type workbook: xlsxwriter.Workbook\n:param save_workbook: Flag to save_notebook. If False, it is returned by the function.\n:type save_workbook: bool\n\n:return: Returns a workbook if save_workbook is False. Else, saves the .xlsx file in the filepath if was initialized with.\n:rtype: xlsxwriter.Workbook",
          "signature": "def to_excel(self, filepath=None, workbook=None, save_workbook=True):",
          "type": "Method",
          "class_signature": "class Table(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:independent_words": {
      "textractor/entities/key_value.py": {
        "KeyValue.words": {
          "code": "    def words(self) -> List[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the key and value of the :class:`KeyValue` object.\n\n        :return words: List of Word objects, each representing a word within the KeyValue entity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        value_words = self.value.words if self.value is not None and (not self.contains_checkbox) else []\n        return EntityList(sorted(self._words + value_words, key=lambda x: x.bbox.x + x.bbox.y))",
          "docstring": "Returns all the :class:`Word` objects present in the key and value of the :class:`KeyValue` object.\n\n:return words: List of Word objects, each representing a word within the KeyValue entity.\n:rtype: EntityList[Word]",
          "signature": "def words(self) -> List[Word]:",
          "type": "Method",
          "class_signature": "class KeyValue(DocumentEntity):"
        }
      },
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      },
      "textractor/entities/table.py": {
        "Table.words": {
          "code": "    def words(self):\n        \"\"\"\n        Returns all the :class:`Word` objects present in the :class:`Table`.\n\n        :return words: List of Word objects, each representing a word within the Table.\n        :rtype: EntityList[Word]\n        \"\"\"\n\n        all_words = sum([cell.words for cell in self.table_cells], [])\n\n        if not all_words:\n            logging.info(\"Table contains no word entities.\")\n\n        return EntityList(all_words)",
          "docstring": "Returns all the :class:`Word` objects present in the :class:`Table`.\n\n:return words: List of Word objects, each representing a word within the Table.\n:rtype: EntityList[Word]",
          "signature": "def words(self):",
          "type": "Method",
          "class_signature": "class Table(DocumentEntity):"
        }
      }
    },
    "textractor/entities/page.py:Page:return_duplicates": {
      "textractor/entities/document_entity.py": {
        "DocumentEntity.bbox": {
          "code": "    def bbox(self, bbox: BoundingBox):\n        self._bbox = bbox",
          "docstring": "",
          "signature": "def bbox(self, bbox: BoundingBox):",
          "type": "Method",
          "class_signature": "class DocumentEntity(Linearizable, ABC):"
        }
      },
      "textractor/visualizers/entitylist.py": {
        "EntityList.__init__": {
          "code": "    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
          "docstring": "",
          "signature": "def __init__(self, objs=None):",
          "type": "Method",
          "class_signature": "class EntityList(list, Generic[T], Linearizable):"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_page.py:TestPage:test_page": {
      "tests/utils.py:get_fixture_path": {},
      "textractor/entities/document.py:Document:open": {
        "textractor/parsers/response_parser.py:parse": {
          "textractor/utils/legacy_utils.py:converter": {},
          "textractor/parsers/response_parser.py:parse_document_api_response": {
            "textractor/parsers/response_parser.py:_create_document_object": {
              "textractor/entities/document.py:Document:__init__": {
                "textractor/entities/bbox.py:SpatialObject:__init__": {}
              }
            },
            "textractor/parsers/response_parser.py:_create_page_objects": {
              "textractor/parsers/response_parser.py:_filter_block_type": {},
              "textractor/parsers/response_parser.py:_get_relationship_ids": {},
              "textractor/entities/page.py:Page:__init__": {
                "textractor/entities/bbox.py:SpatialObject:__init__": {},
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              }
            },
            "textractor/parsers/response_parser.py:_create_line_objects": {
              "textractor/parsers/response_parser.py:_get_relationship_ids": {},
              "textractor/parsers/response_parser.py:_create_word_objects": {
                "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                  "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                    "textractor/entities/bbox.py:BoundingBox:__init__": {
                      "textractor/entities/bbox.py:SpatialObject:__init__": {}
                    }
                  }
                },
                "textractor/entities/word.py:Word:__init__": {
                  "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                },
                "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
                "textractor/entities/word.py:Word:page": {},
                "textractor/entities/word.py:Word:page_id": {}
              },
              "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                  "textractor/entities/bbox.py:BoundingBox:__init__": {
                    "textractor/entities/bbox.py:SpatialObject:__init__": {}
                  }
                }
              },
              "textractor/entities/line.py:Line:__init__": {
                "textractor/entities/document_entity.py:DocumentEntity:__init__": {},
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
              "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
              "textractor/entities/line.py:Line:page": {},
              "textractor/entities/line.py:Line:page_id": {}
            },
            "textractor/entities/page.py:Page:lines": {
              "textractor/utils/geometry_util.py:sort_by_position": {
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/parsers/response_parser.py:_create_layout_objects": {},
            "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
            "textractor/entities/layout.py:Layout:__init__": {
              "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
            },
            "textractor/entities/layout.py:Layout:page": {},
            "textractor/entities/layout.py:Layout:page_id": {},
            "textractor/parsers/response_parser.py:_create_keyvalue_objects": {
              "textractor/parsers/response_parser.py:_filter_by_entity": {},
              "textractor/parsers/response_parser.py:_get_relationship_ids": {},
              "textractor/parsers/response_parser.py:_create_value_objects": {
                "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                  "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                    "textractor/entities/bbox.py:BoundingBox:__init__": {
                      "textractor/entities/bbox.py:SpatialObject:__init__": {}
                    }
                  }
                },
                "textractor/entities/value.py:Value:__init__": {
                  "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                },
                "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
                "textractor/parsers/response_parser.py:_create_selection_objects": {
                  "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                    "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                      "textractor/entities/bbox.py:BoundingBox:__init__": {}
                    }
                  },
                  "textractor/entities/selection_element.py:SelectionElement:__init__": {
                    "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                  },
                  "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
                  "textractor/entities/selection_element.py:SelectionElement:page": {},
                  "textractor/entities/selection_element.py:SelectionElement:page_id": {}
                },
                "textractor/parsers/response_parser.py:_get_relationship_ids": {},
                "textractor/entities/document_entity.py:DocumentEntity:add_children": {},
                "textractor/entities/value.py:Value:contains_checkbox": {},
                "textractor/entities/value.py:Value:page": {},
                "textractor/entities/value.py:Value:page_id": {},
                "textractor/parsers/response_parser.py:_create_word_objects": {
                  "textractor/entities/word.py:Word:page": {},
                  "textractor/entities/word.py:Word:page_id": {}
                },
                "textractor/entities/value.py:Value:words": {
                  "textractor/entities/value.py:Value:contains_checkbox": {},
                  "textractor/visualizers/entitylist.py:EntityList:__init__": {},
                  "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
                }
              },
              "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                  "textractor/entities/bbox.py:BoundingBox:__init__": {
                    "textractor/entities/bbox.py:SpatialObject:__init__": {}
                  }
                }
              },
              "textractor/entities/value.py:Value:contains_checkbox": {},
              "textractor/entities/key_value.py:KeyValue:__init__": {
                "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
              "textractor/entities/key_value.py:KeyValue:value": {},
              "textractor/entities/value.py:Value:key_id": {},
              "textractor/entities/document_entity.py:DocumentEntity:children": {},
              "textractor/parsers/response_parser.py:_create_word_objects": {
                "textractor/entities/word.py:Word:page": {},
                "textractor/entities/word.py:Word:page_id": {}
              },
              "textractor/entities/key_value.py:KeyValue:key": {
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:add_children": {},
              "textractor/entities/value.py:Value:words": {
                "textractor/entities/value.py:Value:contains_checkbox": {},
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
              "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {
                "textractor/entities/bbox.py:BoundingBox:__init__": {
                  "textractor/entities/bbox.py:SpatialObject:__init__": {}
                }
              },
              "textractor/entities/key_value.py:KeyValue:page": {},
              "textractor/entities/key_value.py:KeyValue:page_id": {}
            },
            "textractor/entities/page.py:Page:key_values": {
              "textractor/utils/geometry_util.py:sort_by_position": {
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/page.py:Page:checkboxes": {
              "textractor/utils/geometry_util.py:sort_by_position": {
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/parsers/response_parser.py:_create_table_objects": {
              "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                  "textractor/entities/bbox.py:BoundingBox:__init__": {
                    "textractor/entities/bbox.py:SpatialObject:__init__": {}
                  }
                }
              },
              "textractor/entities/table.py:Table:__init__": {
                "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
              },
              "textractor/entities/table.py:Table:table_type": {},
              "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
              "textractor/parsers/response_parser.py:_create_table_cell_objects": {
                "textractor/parsers/response_parser.py:_get_relationship_ids": {},
                "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
                  "textractor/entities/bbox.py:BoundingBox:_from_dict": {
                    "textractor/entities/bbox.py:BoundingBox:__init__": {
                      "textractor/entities/bbox.py:SpatialObject:__init__": {}
                    }
                  }
                },
                "textractor/entities/table_cell.py:TableCell:__init__": {
                  "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                },
                "textractor/entities/document_entity.py:DocumentEntity:raw_object": {},
                "textractor/entities/table_cell.py:TableCell:page": {},
                "textractor/entities/table_cell.py:TableCell:page_id": {}
              },
              "textractor/parsers/response_parser.py:_get_relationship_ids": {},
              "textractor/parsers/response_parser.py:_create_word_objects": {
                "textractor/entities/word.py:Word:page": {},
                "textractor/entities/word.py:Word:page_id": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
              "textractor/entities/table_cell.py:TableCell:row_span": {},
              "textractor/entities/table_cell.py:TableCell:col_span": {},
              "textractor/entities/table_cell.py:TableCell:row_index": {},
              "textractor/entities/table_cell.py:TableCell:col_index": {},
              "textractor/entities/document_entity.py:DocumentEntity:add_children": {},
              "textractor/entities/table_cell.py:TableCell:_update_response_metadata": {},
              "textractor/entities/key_value.py:KeyValue:words": {
                "textractor/entities/key_value.py:KeyValue:value": {},
                "textractor/visualizers/entitylist.py:EntityList:__add__": {
                  "textractor/visualizers/entitylist.py:EntityList:__init__": {}
                },
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                "textractor/visualizers/entitylist.py:EntityList:__init__": {},
                "textractor/entities/value.py:Value:words": {
                  "textractor/entities/value.py:Value:contains_checkbox": {},
                  "textractor/visualizers/entitylist.py:EntityList:__init__": {}
                }
              },
              "textractor/entities/table_cell.py:TableCell:is_title": {},
              "textractor/entities/table_cell.py:TableCell:words": {
                "textractor/entities/table_cell.py:TableCell:get_text_and_words": {
                  "textractor/entities/document_entity.py:DocumentEntity:children": {},
                  "textractor/utils/text_utils.py:linearize_children": {
                    "textractor/entities/word.py:Word:Word": {},
                    "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                    "textractor/entities/line.py:Line:__init__": {
                      "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                    },
                    "textractor/utils/text_utils.py:group_elements_horizontally": {},
                    "textractor/entities/line.py:Line:get_text_and_words": {
                      "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                      "textractor/entities/line.py:Line:words": {},
                      "textractor/entities/line.py:Line:text": {},
                      "textractor/utils/html_utils.py:escape_text": {
                        "textractor/data/html_linearization_config.py:HTMLLinearizationConfig": {}
                      }
                    },
                    "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {
                      "textractor/entities/bbox.py:BoundingBox:__init__": {}
                    }
                  }
                },
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/table.py:Table:footers": {},
              "textractor/entities/table.py:Table:add_cells": {
                "textractor/entities/table_cell.py:TableCell:table_id": {},
                "textractor/entities/table_cell.py:TableCell:row_index": {},
                "textractor/entities/table_cell.py:TableCell:col_index": {}
              },
              "textractor/entities/page.py:Page:leaf_layouts": {},
              "textractor/entities/layout.py:Layout:__init__": {
                "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:children": {},
              "textractor/entities/layout.py:Layout:page": {},
              "textractor/entities/layout.py:Layout:page_id": {},
              "textractor/entities/bbox.py:BoundingBox:get_intersection": {
                "textractor/entities/bbox.py:BoundingBox": {},
                "textractor/entities/bbox.py:BoundingBox:from_denormalized_corners": {
                  "textractor/entities/bbox.py:BoundingBox:__init__": {
                    "textractor/entities/bbox.py:SpatialObject:__init__": {}
                  }
                }
              },
              "textractor/entities/bbox.py:BoundingBox:area": {},
              "textractor/entities/table.py:Table:words": {
                "textractor/entities/table_cell.py:TableCell:words": {
                  "textractor/entities/table_cell.py:TableCell:get_text_and_words": {
                    "textractor/entities/document_entity.py:DocumentEntity:children": {},
                    "textractor/utils/text_utils.py:linearize_children": {
                      "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                      "textractor/entities/line.py:Line:__init__": {},
                      "textractor/utils/text_utils.py:group_elements_horizontally": {},
                      "textractor/entities/line.py:Line:get_text_and_words": {},
                      "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {}
                    }
                  },
                  "textractor/visualizers/entitylist.py:EntityList:__init__": {}
                },
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:remove": {
                "textractor/entities/document_entity.py:DocumentEntity:remove": {
                  "[ignored_or_cut_off]": "..."
                },
                "textractor/entities/document_entity.py:DocumentEntity:children": {}
              },
              "textractor/entities/table.py:Table:page": {},
              "textractor/entities/table.py:Table:page_id": {}
            },
            "textractor/entities/page.py:Page:tables": {
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/page.py:Page:leaf_layouts": {
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/bbox.py:BoundingBox:get_intersection": {
              "textractor/entities/bbox.py:BoundingBox:from_denormalized_corners": {
                "textractor/entities/bbox.py:BoundingBox:__init__": {
                  "textractor/entities/bbox.py:SpatialObject:__init__": {}
                }
              }
            },
            "textractor/entities/bbox.py:BoundingBox:area": {},
            "textractor/entities/document_entity.py:DocumentEntity:children": {},
            "textractor/entities/key_value.py:KeyValue:words": {
              "textractor/entities/key_value.py:KeyValue:value": {},
              "textractor/entities/value.py:Value:words": {
                "textractor/entities/value.py:Value:contains_checkbox": {},
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__add__": {
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/document_entity.py:DocumentEntity:remove": {
              "textractor/entities/document_entity.py:DocumentEntity:remove": {
                "[ignored_or_cut_off]": "..."
              },
              "textractor/entities/document_entity.py:DocumentEntity:children": {}
            },
            "textractor/entities/page.py:Page:words": {
              "textractor/utils/geometry_util.py:sort_by_position": {
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/parsers/response_parser.py:_create_query_objects": {
              "textractor/parsers/response_parser.py:_create_query_result_objects": {}
            },
            "textractor/entities/page.py:Page:queries": {
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/parsers/response_parser.py:_create_signature_objects": {
              "textractor/entities/page.py:Page:leaf_layouts": {},
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
            },
            "textractor/entities/page.py:Page:signatures": {
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/page.py:Page:layouts": {
              "textractor/visualizers/entitylist.py:EntityList:__add__": {
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/document_entity.py:DocumentEntity:visit": {
              "textractor/entities/document_entity.py:DocumentEntity:visit": {
                "[ignored_or_cut_off]": "..."
              }
            },
            "textractor/entities/document.py:Document:pages": {}
          }
        }
      },
      "textractor/entities/document.py:Document:page": {
        "textractor/entities/document.py:Document:pages": {}
      },
      "textractor/entities/page.py:Page:words": {},
      "textractor/entities/page.py:Page:lines": {},
      "textractor/entities/page.py:Page:key_values": {},
      "textractor/entities/key_value.py:KeyValue:value": {},
      "textractor/visualizers/entitylist.py:EntityList:pretty_print": {
        "textractor/visualizers/entitylist.py:EntityList:_get_text_string": {},
        "textractor/visualizers/entitylist.py:EntityList:_get_forms_string": {
          "textractor/entities/key_value.py:KeyValue:page": {},
          "textractor/visualizers/entitylist.py:_convert_form_to_list": {
            "textractor/entities/key_value.py:KeyValue:key": {},
            "textractor/entities/word.py:Word:text": {},
            "textractor/entities/key_value.py:KeyValue:value": {},
            "textractor/entities/value.py:Value:words": {
              "textractor/entities/value.py:Value:contains_checkbox": {},
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            }
          }
        },
        "textractor/visualizers/entitylist.py:EntityList:_get_tables_string": {
          "textractor/visualizers/entitylist.py:_convert_table_to_list": {
            "textractor/entities/table.py:Table:_get_table_cells": {
              "textractor/entities/table_cell.py:TableCell:row_index": {},
              "textractor/entities/table_cell.py:TableCell:col_index": {}
            },
            "textractor/entities/table_cell.py:TableCell:__repr__": {
              "textractor/entities/table_cell.py:TableCell:words": {
                "textractor/entities/table_cell.py:TableCell:get_text_and_words": {
                  "textractor/entities/document_entity.py:DocumentEntity:children": {},
                  "textractor/utils/text_utils.py:linearize_children": {
                    "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                    "textractor/entities/line.py:Line:__init__": {
                      "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
                    },
                    "textractor/utils/text_utils.py:group_elements_horizontally": {},
                    "textractor/entities/line.py:Line:get_text_and_words": {
                      "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                      "textractor/entities/line.py:Line:words": {},
                      "textractor/entities/line.py:Line:text": {},
                      "textractor/utils/html_utils.py:escape_text": {}
                    },
                    "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {
                      "textractor/entities/bbox.py:BoundingBox:__init__": {}
                    }
                  }
                },
                "textractor/visualizers/entitylist.py:EntityList:__init__": {}
              },
              "textractor/entities/word.py:Word:__repr__": {
                "textractor/entities/word.py:Word:text": {}
              },
              "textractor/entities/table_cell.py:TableCell:row_index": {},
              "textractor/entities/table_cell.py:TableCell:col_index": {},
              "textractor/entities/table_cell.py:TableCell:row_span": {},
              "textractor/entities/table_cell.py:TableCell:col_span": {},
              "textractor/entities/table_cell.py:TableCell:is_column_header": {},
              "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
            }
          }
        },
        "textractor/visualizers/entitylist.py:EntityList:_get_queries_string": {},
        "textractor/visualizers/entitylist.py:EntityList:_get_expense_documents_string": {},
        "textractor/visualizers/entitylist.py:EntityList:_get_id_documents_string": {}
      },
      "textractor/entities/page.py:Page:tables": {},
      "textractor/entities/page.py:Page:checkboxes": {},
      "textractor/entities/value.py:Value:words": {
        "textractor/entities/value.py:Value:contains_checkbox": {},
        "textractor/entities/document_entity.py:DocumentEntity:children": {},
        "textractor/entities/selection_element.py:SelectionElement:words": {}
      },
      "textractor/entities/document_entity.py:DocumentEntity:children": {},
      "textractor/entities/page.py:Page:__repr__": {
        "textractor/entities/page.py:Page:words": {},
        "textractor/entities/page.py:Page:lines": {},
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/page.py:Page:checkboxes": {},
        "textractor/entities/page.py:Page:tables": {},
        "textractor/entities/page.py:Page:queries": {},
        "textractor/entities/page.py:Page:signatures": {},
        "textractor/entities/page.py:Page:expense_documents": {},
        "textractor/entities/page.py:Page:layouts": {
          "textractor/visualizers/entitylist.py:EntityList:__add__": {
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        }
      },
      "textractor/entities/page.py:Page:keys": {
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/key_value.py:KeyValue:key": {},
        "textractor/entities/page.py:Page:checkboxes": {}
      },
      "textractor/entities/page.py:Page:filter_checkboxes": {
        "textractor/entities/page.py:Page:checkboxes": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:get_words_by_type": {
        "textractor/data/constants.py:TextTypes:TextTypes": {},
        "textractor/entities/page.py:Page:words": {},
        "textractor/entities/word.py:Word:text_type": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:search_words": {
        "textractor/entities/page.py:Page:_search_words_with_similarity": {
          "textractor/data/constants.py:SimilarityMetric:SimilarityMetric": {},
          "textractor/entities/page.py:Page:words": {},
          "textractor/entities/word.py:Word:text": {},
          "textractor/utils/search_utils.py:SearchUtils:get_word_similarity": {
            "textractor/utils/search_utils.py:normalized_edit_distance": {}
          }
        },
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:get": {
        "textractor/data/constants.py:SimilarityMetric:SimilarityMetric": {},
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/page.py:Page:checkboxes": {},
        "textractor/visualizers/entitylist.py:EntityList:__add__": {
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        },
        "textractor/entities/key_value.py:KeyValue:key": {},
        "textractor/entities/word.py:Word:__repr__": {
          "textractor/entities/word.py:Word:text": {}
        },
        "textractor/utils/search_utils.py:SearchUtils:get_word_similarity": {
          "textractor/utils/search_utils.py:normalized_edit_distance": {}
        },
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:search_lines": {
        "textractor/entities/page.py:Page:_search_lines_with_similarity": {
          "textractor/data/constants.py:SimilarityMetric:SimilarityMetric": {},
          "textractor/entities/page.py:Page:lines": {},
          "textractor/entities/line.py:Line:__repr__": {
            "textractor/entities/line.py:Line:words": {},
            "textractor/entities/word.py:Word:text": {}
          },
          "textractor/utils/search_utils.py:SearchUtils:get_word_similarity": {
            "textractor/utils/search_utils.py:normalized_edit_distance": {}
          }
        },
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:export_kv_to_csv": {
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/key_value.py:KeyValue:key": {},
        "textractor/entities/word.py:Word:__repr__": {
          "textractor/entities/word.py:Word:text": {}
        },
        "textractor/entities/key_value.py:KeyValue:value": {},
        "textractor/entities/value.py:Value:__repr__": {
          "textractor/entities/value.py:Value:contains_checkbox": {},
          "textractor/entities/value.py:Value:words": {
            "textractor/entities/value.py:Value:contains_checkbox": {},
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/entities/word.py:Word:text": {}
        },
        "textractor/entities/page.py:Page:checkboxes": {},
        "textractor/entities/document_entity.py:DocumentEntity:children": {}
      },
      "textractor/entities/page.py:Page:export_kv_to_txt": {
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/key_value.py:KeyValue:key": {},
        "textractor/entities/word.py:Word:__repr__": {
          "textractor/entities/word.py:Word:text": {}
        },
        "textractor/entities/key_value.py:KeyValue:value": {},
        "textractor/entities/value.py:Value:__repr__": {
          "textractor/entities/value.py:Value:contains_checkbox": {},
          "textractor/entities/value.py:Value:words": {
            "textractor/entities/value.py:Value:contains_checkbox": {},
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/entities/word.py:Word:text": {},
          "textractor/entities/document_entity.py:DocumentEntity:children": {},
          "textractor/entities/selection_element.py:SelectionElement:__repr__": {}
        },
        "textractor/entities/page.py:Page:checkboxes": {}
      },
      "textractor/entities/page.py:Page:export_tables_to_excel": {
        "textractor/entities/page.py:Page:tables": {},
        "textractor/entities/table.py:Table:to_excel": {
          "textractor/entities/table_cell.py:TableCell:__repr__": {
            "textractor/entities/table_cell.py:TableCell:words": {
              "textractor/entities/table_cell.py:TableCell:get_text_and_words": {
                "textractor/entities/document_entity.py:DocumentEntity:children": {},
                "textractor/utils/text_utils.py:linearize_children": {
                  "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                  "textractor/entities/line.py:Line:__init__": {
                    "textractor/entities/document_entity.py:DocumentEntity:__init__": {},
                    "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
                  },
                  "textractor/utils/text_utils.py:group_elements_horizontally": {},
                  "textractor/entities/line.py:Line:get_text_and_words": {
                    "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                    "textractor/entities/line.py:Line:words": {},
                    "textractor/entities/line.py:Line:text": {
                      "textractor/entities/line.py:Line:words": {},
                      "textractor/entities/word.py:Word:text": {}
                    },
                    "textractor/utils/html_utils.py:escape_text": {}
                  },
                  "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {
                    "textractor/entities/bbox.py:BoundingBox:__init__": {
                      "textractor/entities/bbox.py:SpatialObject:__init__": {}
                    }
                  }
                }
              },
              "textractor/visualizers/entitylist.py:EntityList:__init__": {}
            },
            "textractor/entities/word.py:Word:__repr__": {
              "textractor/entities/word.py:Word:text": {}
            },
            "textractor/entities/table_cell.py:TableCell:row_index": {},
            "textractor/entities/table_cell.py:TableCell:col_index": {},
            "textractor/entities/table_cell.py:TableCell:row_span": {},
            "textractor/entities/table_cell.py:TableCell:col_span": {},
            "textractor/entities/table_cell.py:TableCell:is_column_header": {},
            "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
          },
          "textractor/entities/table_cell.py:TableCell:row_index": {},
          "textractor/entities/table_cell.py:TableCell:col_index": {},
          "textractor/entities/table_cell.py:TableCell:_get_merged_cell_range": {
            "textractor/entities/table_cell.py:TableCell:row_index": {},
            "textractor/entities/table_cell.py:TableCell:col_index": {}
          }
        }
      },
      "textractor/entities/page.py:Page:independent_words": {
        "textractor/entities/page.py:Page:words": {},
        "textractor/entities/page.py:Page:tables": {},
        "textractor/entities/table.py:Table:words": {
          "textractor/entities/table_cell.py:TableCell:words": {
            "textractor/entities/table_cell.py:TableCell:get_text_and_words": {
              "textractor/entities/document_entity.py:DocumentEntity:children": {},
              "textractor/utils/text_utils.py:linearize_children": {
                "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                "textractor/entities/line.py:Line:__init__": {
                  "textractor/entities/document_entity.py:DocumentEntity:__init__": {},
                  "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
                },
                "textractor/utils/text_utils.py:group_elements_horizontally": {},
                "textractor/entities/line.py:Line:get_text_and_words": {
                  "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
                  "textractor/entities/line.py:Line:words": {},
                  "textractor/entities/line.py:Line:text": {
                    "textractor/entities/line.py:Line:words": {},
                    "textractor/entities/word.py:Word:text": {}
                  },
                  "textractor/utils/html_utils.py:escape_text": {}
                },
                "textractor/entities/bbox.py:BoundingBox:enclosing_bbox": {
                  "textractor/entities/bbox.py:BoundingBox:__init__": {
                    "textractor/entities/bbox.py:SpatialObject:__init__": {}
                  }
                }
              }
            },
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        },
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/entities/key_value.py:KeyValue:words": {
          "textractor/entities/key_value.py:KeyValue:value": {},
          "textractor/entities/value.py:Value:words": {
            "textractor/entities/value.py:Value:contains_checkbox": {},
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/visualizers/entitylist.py:EntityList:__add__": {
            "textractor/visualizers/entitylist.py:EntityList:__init__": {}
          },
          "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        },
        "textractor/entities/page.py:Page:checkboxes": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/entities/page.py:Page:return_duplicates": {
        "textractor/entities/page.py:Page:tables": {},
        "textractor/entities/page.py:Page:key_values": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {},
        "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: amazon_textract_textractor-test_page\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 textractor/\n    \u251c\u2500\u2500 entities/\n    \u2502   \u251c\u2500\u2500 document.py\n    \u2502   \u2502   \u251c\u2500\u2500 Document.open\n    \u2502   \u2502   \u2514\u2500\u2500 Document.page\n    \u2502   \u251c\u2500\u2500 document_entity.py\n    \u2502   \u2502   \u2514\u2500\u2500 DocumentEntity.children\n    \u2502   \u251c\u2500\u2500 key_value.py\n    \u2502   \u2502   \u2514\u2500\u2500 KeyValue.value\n    \u2502   \u251c\u2500\u2500 page.py\n    \u2502   \u2502   \u251c\u2500\u2500 Page.__repr__\n    \u2502   \u2502   \u251c\u2500\u2500 Page.checkboxes\n    \u2502   \u2502   \u251c\u2500\u2500 Page.export_kv_to_csv\n    \u2502   \u2502   \u251c\u2500\u2500 Page.export_kv_to_txt\n    \u2502   \u2502   \u251c\u2500\u2500 Page.export_tables_to_excel\n    \u2502   \u2502   \u251c\u2500\u2500 Page.filter_checkboxes\n    \u2502   \u2502   \u251c\u2500\u2500 Page.get\n    \u2502   \u2502   \u251c\u2500\u2500 Page.get_words_by_type\n    \u2502   \u2502   \u251c\u2500\u2500 Page.independent_words\n    \u2502   \u2502   \u251c\u2500\u2500 Page.key_values\n    \u2502   \u2502   \u251c\u2500\u2500 Page.keys\n    \u2502   \u2502   \u251c\u2500\u2500 Page.lines\n    \u2502   \u2502   \u251c\u2500\u2500 Page.return_duplicates\n    \u2502   \u2502   \u251c\u2500\u2500 Page.search_lines\n    \u2502   \u2502   \u251c\u2500\u2500 Page.search_words\n    \u2502   \u2502   \u251c\u2500\u2500 Page.tables\n    \u2502   \u2502   \u2514\u2500\u2500 Page.words\n    \u2502   \u2514\u2500\u2500 value.py\n    \u2502       \u2514\u2500\u2500 Value.words\n    \u2514\u2500\u2500 visualizers/\n        \u2514\u2500\u2500 entitylist.py\n            \u2514\u2500\u2500 EntityList.pretty_print\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for processing, analyzing, and extracting structured information from document images or textual data, leveraging advanced features such as OCR (Optical Character Recognition) and entity detection. It facilitates the identification and extraction of key-value pairs, tables, words, lines, checkboxes, and other document elements, enabling detailed data parsing and representation. Additionally, the module offers sophisticated search and filtering capabilities, including similarity-based searches and directional algorithms to locate spatially related entities within a document. It supports exporting extracted data into various formats such as CSV, TXT, and Excel, making it highly useful for automating document digitization workflows and enabling developers to efficiently extract, query, and organize data from unstructured content. This solves the problem of manually parsing and organizing content from scanned documents, enhancing accuracy, consistency, and efficiency for tasks involving document processing and data extraction.\n\n## FILE 1: textractor/entities/document_entity.py\n\n- CLASS METHOD: DocumentEntity.children\n  - CLASS SIGNATURE: class DocumentEntity(Linearizable, ABC):\n  - SIGNATURE: def children(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the list of child entities associated with this DocumentEntity. This method provides access to the hierarchical structure of document entities, allowing users to traverse or manipulate child entities that are part of this DocumentEntity. The returned list contains instances of child entities, which could be further processed or analyzed, depending on the context of the document's structure. This method interacts with the internal attribute `_children`, which is initialized as an empty list in the constructor of the DocumentEntity class to store child entities added via the `add_children` method.\n\"\"\"\n```\n\n## FILE 2: textractor/entities/page.py\n\n- CLASS METHOD: Page.keys\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def keys(self, include_checkboxes: bool=True) -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of all key names present in the Page's key-value pairs and optionally includes those from checkboxes.\n\n:param include_checkboxes: A boolean flag indicating whether to include the keys of checkboxes in the returned list. Defaults to True.\n:type include_checkboxes: bool\n\n:return: A list of strings representing the keys of key-value pairs and, if specified, the keys from checkboxes present in the Page.\n:rtype: List[str]\n\nThis method interacts with the `key_values` and `checkboxes` attributes, which are instances of `EntityList` containing `KeyValue` objects. The method retrieves the `key` from each `KeyValue` object and returns them. It is part of the `Page` class, which represents a document page and its associated entities, including words, lines, tables, and more.\n\"\"\"\n```\n\n- CLASS METHOD: Page.search_words\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def search_words(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[Word]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of the top_k words that best match the specified keyword based on a similarity metric.\n\n:param keyword: The keyword used to query the words present in the page.\n:type keyword: str, required\n:param top_k: The maximum number of closest word objects to return, defaulting to 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used for assessing similarity, which can be one of three options: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN, or SimilarityMetric.LEVENSHTEIN (the default). These constants are defined in `textractor.data.constants`.\n:type similarity_metric: SimilarityMetric\n:param similarity_threshold: This threshold determines the minimum similarity required for a word to be included in the results, defaulting to 0.6.\n:type similarity_threshold: float\n\n:return: An EntityList of Word objects that match the queried keyword, sorted from highest to lowest similarity.\n:rtype: EntityList[Word]\n\nThe function relies on the _search_words_with_similarity method to compute the similarity scores based on the provided parameters. The words returned are filtered based on their similarity to the input keyword.\n\"\"\"\n```\n\n- CLASS METHOD: Page.search_lines\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def search_lines(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> EntityList[Line]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of `Line` objects from the page that contain the specified keyword, ordered by similarity to the keyword.\n\n:param keyword: The word or phrase to search for within the lines of the page.\n:type keyword: str\n:param top_k: The maximum number of closest line objects to return, default is 1.\n:type top_k: int, optional\n:param similarity_metric: The metric used to measure similarity between the keyword and the lines. Options include `SimilarityMetric.COSINE`, `SimilarityMetric.EUCLIDEAN`, or `SimilarityMetric.LEVENSHTEIN`, with `SimilarityMetric.LEVENSHTEIN` as the default.\n:type similarity_metric: SimilarityMetric, optional\n:param similarity_threshold: The threshold for similarity to determine matches, default is 0.6.\n:type similarity_threshold: float, optional\n\n:return: An `EntityList` containing the top_k `Line` objects that match the keyword, sorted by similarity from highest to lowest.\n:rtype: EntityList[Line]\n\nThis method depends on the `_search_lines_with_similarity` helper, which performs the similarity calculations. It utilizes constants defined in the `SimilarityMetric` class from `textractor.data.constants`, which standardizes the types of similarity measurements available for querying lines.\n\"\"\"\n```\n\n- CLASS METHOD: Page.get\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def get(self, key: str, top_k_matches: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> EntityList[KeyValue]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of up to `top_k_matches` key-value pairs from the Page that match a specified `key`, based on similarity metrics. The function utilizes the `SimilarityMetric` constants, which define various methods (COSINE, EUCLIDEAN, LEVENSHTEIN) to calculate similarity between strings.\n\nParameters:\n- `key` (str): The query key to match against existing key-value pairs in the Page.\n- `top_k_matches` (int, optional): Maximum number of matches to return; default is 1.\n- `similarity_metric` (SimilarityMetric, optional): The metric used for similarity comparison; defaults to `SimilarityMetric.LEVENSHTEIN`.\n- `similarity_threshold` (float, optional): The threshold for similarity; defaults to 0.6.\n\nReturns:\n- EntityList[KeyValue]: A sorted list of matching key-value pairs, ordered by the highest to lowest similarity.\n\nThe function logs a warning if no matches are found and an informative message regarding the number of matches. It modifies the `similarity_threshold` before comparison, depending on the chosen metric and handles punctuation in the `key` and the keys of the key-value pairs for a more accurate comparison.\n\"\"\"\n```\n\n- CLASS METHOD: Page.key_values\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def key_values(self, kv: List[KeyValue]):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the key-value pairs for the Page instance.\n\n:param kv: A list of KeyValue objects, each representing a key-value area within the document page.\n:type kv: List[KeyValue]\n\nThe key_values setter updates the _key_values attribute of the Page object, which is an instance of EntityList. The EntityList is populated with KeyValue objects sorted by their position on the page, using the sort_by_position utility function. This ensures that key-value pairs are organized in a logical order as they appear in the document. This method directly affects how key-value pairs are retrieved and utilized by other methods within the Page class, influencing the output in key-value searches and exports.\n\"\"\"\n```\n\n- CLASS METHOD: Page.filter_checkboxes\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def filter_checkboxes(self, selected: bool=True, not_selected: bool=True) -> EntityList[KeyValue]:\n  - DOCSTRING: \n```python\n\"\"\"\nFilters and returns a list of checkboxes present on the page based on their selection status.\n\n:param selected: A boolean indicating whether to return selected checkboxes. Defaults to True.\n:type selected: bool\n:param not_selected: A boolean indicating whether to return not selected checkboxes. Defaults to True.\n\n:return: An `EntityList` containing `KeyValue` objects that match the selection status criteria specified by the `selected` and `not_selected` parameters. Returns an empty list if no checkboxes are present.\n:rtype: EntityList[KeyValue]\n\nThis method interacts with the `_checkboxes` attribute, which stores `KeyValue` objects that represent checkbox elements detected on the page. The method uses the `SelectionStatus` constant defined in `textractor.data.constants` to determine if each checkbox is selected or not. If the page does not contain any checkboxes, a warning is logged indicating their absence.\n\"\"\"\n```\n\n- CLASS METHOD: Page.export_tables_to_excel\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def export_tables_to_excel(self, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates an Excel file containing tables from the document, with each table written to a separate worksheet. The file is stored at the specified path provided by the user.\n\n:param filepath: The path where the Excel file will be saved. Must be a valid string representing the file location.\n:type filepath: str, required\n\n:raises ValueError: If the `filepath` is not provided or invalid.\n:raises Exception: Any errors that occur during the creation or writing of the Excel file may propagate from the `xlsxwriter` library.\n\nThis method interacts with the `Table` objects in the `self.tables` attribute, which is an `EntityList[Table]` containing all tables present on the page. Each `Table` should have a `to_excel` method that handles the writing of the table's content to the workbook.\n\"\"\"\n```\n\n- CLASS METHOD: Page.__repr__\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the `Page` object, summarizing its contents and structure. This includes the page number and the counts of various entities stored within the page, such as words, lines, key-values, checkboxes, tables, queries, signatures, and expense documents. \n\nThe method does not take any parameters and outputs a formatted string, which is particularly useful for logging or debugging purposes to provide insights into the current state of the page's data. It utilizes the properties like `self.words`, `self.lines`, `self.key_values`, etc., to gather the counts needed for the summary. Each property is expected to return an `EntityList` containing corresponding entities, ensuring that the counts are accurate.\n\nThis method helps in quickly assessing the amount and type of data present on a single page, which is particularly significant for applications that manage documents and may need to perform actions based on the presence of these entities.\n\"\"\"\n```\n\n- CLASS METHOD: Page.return_duplicates\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def return_duplicates(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of `EntityList` objects, where each `EntityList` contains key-value pairs that intersect with the bounding box of each table on the page. This method allows users to identify duplicate key-value entries extracted from documents processed by Textract, facilitating error detection and data validation.\n\nThe function iterates through all tables and key-values on the page, leveraging the bounding box (bbox) properties of each table to determine if any key-values fall within the spatial dimensions of the tables. A key-value is considered a duplicate if its coordinates are within the bounding box of a table.\n\nReturns:\n    - List[EntityList]: A list containing `EntityList` instances. Each instance holds key-value pairs found within the respective table's area, with the last item being the table itself.\n\nDependencies:\n    - `tables`: A property that retrieves all table entities from the `Page` object.\n    - `key_values`: A property that retrieves all key-value entities from the `Page` object.\n    - Each `table` has bounding box attributes (`x`, `y`, `width`, and `height`) used to determine its spatial dimensions.\n\"\"\"\n```\n\n- CLASS METHOD: Page.checkboxes\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def checkboxes(self, checkbox: List[KeyValue]):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the list of checkbox KeyValue objects for the Page, representing checkbox areas extracted from the document.\n\n:param checkbox: A list of KeyValue objects, each representing a checkbox area within the document page. These objects may contain children of type SelectionElement that indicate their selection status.\n:type checkbox: List[KeyValue]\n\nThis setter method updates the internal `_checkboxes` attribute, which is an instance of EntityList, with a sorted list of the provided KeyValue objects based on their positions as determined by the `sort_by_position` utility function. This ensures the checkboxes are organized in a coherent manner corresponding to their layout on the page.\n\"\"\"\n```\n\n- CLASS METHOD: Page.words\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def words(self, words: List[Word]):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the list of Word objects associated with the Page.\n\n:param words: A list of Word objects representing the individual words contained within the page. This method does not assume any specific order of the input words.\n:type words: List[Word]\n\nThis method updates the `_words` attribute of the Page instance with the provided list of Word objects. It also removes duplicates by converting the list to a set and then sorts the words by their position on the page using the `sort_by_position` utility function, ensuring a structured order for later processing. The EntityList class from `textractor.entities` is used to encapsulate the sorted words.\n\"\"\"\n```\n\n- CLASS METHOD: Page.independent_words\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def independent_words(self) -> EntityList[Word]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns all words in the Page that are independent, meaning they are not contained within tables, checkboxes, or key-value pairs. \n\nIf the Page has no assigned words, a warning is logged, and an empty list is returned. The method first aggregates words from all tables, key-values, and checkboxes present on the Page. It then constructs a set of IDs for these dependent words. Finally, it filters the main list of words to return only those whose IDs are not found in the set of dependent words, encapsulating the result in an EntityList for consistency with other methods in the class.\n\nReturns:\n    EntityList[Word]: A list of independent Word objects that are not associated with any tables, checkboxes, or key-value pairs within the Page.\n\nSide Effects:\n    Logs a warning if no words have been assigned to the Document object.\n\"\"\"\n```\n\n- CLASS METHOD: Page.get_words_by_type\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> EntityList[Word]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a filtered list of `Word` entities from the `Page` based on the specified text type.\n\n:param text_type: The type of text to filter words by, which can be either `TextTypes.PRINTED` (for printed text) or `TextTypes.HANDWRITING` (for handwritten text). Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n\n:return: An `EntityList` containing `Word` entities that match the specified text type. If there are no words or if the `text_type` is not an instance of `TextTypes`, appropriate warnings are logged and an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not of type `TextTypes`, indicating an invalid input.\n\nThe function interacts with the `EntityList` class to manage collections of `Word` objects and requires the `textractor.data.constants` module for the `TextTypes` enum to ensure valid text type inputs.\n\"\"\"\n```\n\n- CLASS METHOD: Page.tables\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def tables(self, tables: List[Table]):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the table objects for the Page instance.\n\n:param tables: A list of `Table` objects that represent structured data areas (tables) within the document page. These objects are defined in the `textractor.entities.table` module.\n:type tables: List[Table]\n\nThis method updates the internal `_tables` attribute to hold an `EntityList` containing the provided `Table` instances, allowing for structured data extraction and manipulation from the document. The `EntityList` class is utilized here to maintain a collection of entities, facilitating easy management of the included table objects. The method does not return any value.\n\"\"\"\n```\n\n- CLASS METHOD: Page.lines\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def lines(self, lines: List[Line]):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds Line objects to the Page instance, representing the text lines detected within the page's document.\n\n:param lines: A list of Line objects that correspond to the detected lines within the page.\n:type lines: List[Line]\n\nThis method stores the provided Line objects in an internal EntityList after sorting them by their position on the page using the `sort_by_position` utility function. The sorted list ensures that lines are organized in the reading order, providing a coherent structure for further processing and interaction with other text elements on the page.\n\"\"\"\n```\n\n- CLASS METHOD: Page.export_kv_to_txt\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def export_kv_to_txt(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.txt'):\n  - DOCSTRING: \n```python\n\"\"\"\nExports key-value pairs and checkbox entities from the Page object to a specified text file in a formatted manner. The method generates a sequential list of key-value pairs, where each pair is represented as \"index. key : value\". The parameters `include_kv` and `include_checkboxes` allow for conditional inclusion of these entities based on availability. If the document does not contain any key-values or checkboxes, a warning is logged.\n\nParameters:\n- include_kv (bool): If True, include key-value pairs in the export. Defaults to True.\n- include_checkboxes (bool): If True, include checkbox elements in the export. Defaults to True.\n- filepath (str): The path where the text file will be stored. Defaults to \"Key-Values.txt\".\n\nOutput:\n- Side effects: Writes the formatted key-value and checkbox data to the specified text file. Logs warnings if data is missing.\n\nDependencies:\n- Requires `key_values` and `checkboxes` attributes of the Page class, which hold the relevant entities extracted from the document.\n- Uses the `os` module for file path handling and logging for any warnings.\n\"\"\"\n```\n\n- CLASS METHOD: Page.export_kv_to_csv\n  - CLASS SIGNATURE: class Page(SpatialObject, Linearizable):\n  - SIGNATURE: def export_kv_to_csv(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.csv'):\n  - DOCSTRING: \n```python\n\"\"\"\nExports key-value pairs and checkbox statuses from the Page object to a CSV file.\n\n:param include_kv: Specify whether to include key-value pairs in the export. Defaults to True.\n:type include_kv: bool\n:param include_checkboxes: Specify whether to include checkbox status in the export. Defaults to True.\n:type include_checkboxes: bool\n:param filepath: The file path where the CSV file will be stored, defaulting to \"Key-Values.csv\".\n:type filepath: str\n\nThis method retrieves key-values from the Page object, which are stored in the `_key_values` attribute, and checkboxes stored in the `_checkboxes` attribute. Both properties return EntityList objects which contain the respective entities. If the specified entities are not present, a warning is logged. The exported CSV will have a header line with \"Key,Value\" followed by the respective pairs. After execution, an informational log records the location of the saved CSV file, combining the current working directory with the specified filepath.\n\"\"\"\n```\n\n## FILE 3: textractor/entities/key_value.py\n\n- CLASS METHOD: KeyValue.value\n  - CLASS SIGNATURE: class KeyValue(DocumentEntity):\n  - SIGNATURE: def value(self, value: Value):\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a :class:`Value` object to the :class:`KeyValue` entity, representing the value associated with the key.\n\n:param value: A `Value` object that holds the information corresponding to the key. This object is an instance of the `Value` class defined in the `textractor.entities.value` module.\n:type value: Value\n\nThis method sets the internal attribute `_value` to the provided `Value` object, which can later be accessed via the `value` property of the `KeyValue` class. The `value` is crucial for establishing the association between the key and its corresponding value in a key-value pair representation.\n\"\"\"\n```\n\n## FILE 4: textractor/entities/document.py\n\n- CLASS METHOD: Document.open\n  - CLASS SIGNATURE: class Document(SpatialObject, Linearizable):\n  - SIGNATURE: def open(cls, fp: Union[dict, str, Path, IO[AnyStr]]):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a Document object from various input formats including a JSON file path, file handle, or a response dictionary. This method checks the type of the input parameter `fp`, which can be a dictionary, string, Path object, or a file-like object. Depending on the type, it either parses the provided content directly or downloads a JSON response from an S3 bucket using the `boto3` library.\n\nParameters:\n- fp (Union[dict, str, Path, IO[AnyStr]]): The input source to create a Document. It can be a dictionary for direct parsing, a string or Path object for file paths, or a file handle.\n  \nReturns:\n- Document: An instance of the Document class, populated with data from the provided input.\n\nRaises:\n- InputError: If the input does not match any accepted types (dict, str, Path, or file handle).\n\nDependencies:\n- The method interacts with `response_parser` to handle the parsing process, which\u2014if not provided as input\u2014is hoped to handle different input sources effectively. It also utilizes the `boto3` library to fetch data from AWS S3 if the input is a string starting with \"s3://\".\n\"\"\"\n```\n\n- CLASS METHOD: Document.page\n  - CLASS SIGNATURE: class Document(SpatialObject, Linearizable):\n  - SIGNATURE: def page(self, page_no: int=0):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the :class:`Page` object(s) corresponding to the specified page number(s) within the Document. The method supports zero-indexing, allowing users to access a single page or multiple pages based on the input type.\n\n:param page_no: The page number to retrieve. If an integer is provided, a single `Page` object is returned. If a list of integers is supplied, a list of corresponding `Page` objects is returned.\n:type page_no: int | list[int]\n\n:return: A single `Page` object if an integer is given; otherwise, returns a list of `Page` objects.\n:rtype: Page | List[Page]\n\n:raises InputError: If the `page_no` parameter is neither an integer nor a list of integers.\n\nThis method interacts with the `self.pages` attribute, which is a list of `Page` objects representing the pages of the document. The `InputError` is defined in the `textractor.exceptions` module and is used to validate input types for robustness.\n\"\"\"\n```\n\n## FILE 5: textractor/entities/value.py\n\n- CLASS METHOD: Value.words\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def words(self, words: List[Word]):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the list of Word objects that represent the words within the Value field. The words are stored in a private attribute and are internally sorted based on their bounding box coordinates (x + y), ensuring that their order reflects their position in the document.\n\n:param words: A list of Word objects, each representing a word associated with the Value entity. No specific ordering is assumed before passing, as the function handles the ordering internally.\n:type words: List[Word]\n\nThis method interacts with the private `_words` attribute of the Value class, which is used to manage the words associated with the Value instance. Sorting ensures that the words are processed sequentially based on their spatial layout, which is critical for accurate representation and further processing in tasks such as text extraction and HTML rendering.\n\"\"\"\n```\n\n## FILE 6: textractor/visualizers/entitylist.py\n\n- CLASS METHOD: EntityList.pretty_print\n  - CLASS SIGNATURE: class EntityList(list, Generic[T], Linearizable):\n  - SIGNATURE: def pretty_print(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, with_page_number: bool=False, trim: bool=False) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a formatted string representation of entities within the EntityList, categorized by their types.\nThe output includes words, lines, key-value pairs, tables, queries, expense documents, and identity documents, each formatted according to specified options.\n\nParameters:\n- table_format (TableFormat): Specifies the formatting style for tables; defaults to GITHUB format. This is an enumerated type defined in textractor.data.constants.\n- with_confidence (bool): If True, includes the confidence score of predictions in the output; defaults to False.\n- with_geo (bool): If True, includes bounding box information in the output; defaults to False.\n- with_page_number (bool): If True, adds the corresponding page number to each entity's output; defaults to False.\n- trim (bool): If True, trims the text in the output; defaults to False.\n\nReturns:\n- str: A concatenated string of all formatted entities based on the specified parameters.\n\nThe method interacts with several helper functions, such as _get_text_string, _get_forms_string, and _get_tables_string, which specifically handle formatting for different entity types. It also leverages the TextractType enum to identify entity types when formatting.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "textractor/entities/document_entity.py": "\"\"\":class:`DocumentEntity` is the class that all Document entities such as :class:`Word`, :class:`Line`, :class:`Table` etc. inherit from. This class provides methods \nuseful to all such entities.\"\"\"\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Tuple\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.data.markdown_linearization_config import MarkdownLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\nclass DocumentEntity(Linearizable, ABC):\n    \"\"\"\n    An interface for all document entities within the document body, composing the\n    hierarchy of the document object model.\n    The purpose of this class is to define properties common to all document entities\n    i.e. unique id and bounding box.\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\n        child entities within a document entity.\n\n        :param entity_id: Unique identifier of the document entity.\n        :param bbox: Bounding box of the entity\n        \"\"\"\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}\n        self._children = []\n        self._children_type = None\n        self._raw_object = None\n\n    def add_children(self, children):\n        \"\"\"\n        Adds children to all entities that have parent-child relationships.\n\n        :param children: List of child entities.\n        :type children: list\n        \"\"\"\n        self._children.extend(children)\n\n    @property\n    def raw_object(self) -> Dict:\n        \"\"\"\n        :return: Returns the raw dictionary object that was used to create this Python object\n        :rtype: Dict\n        \"\"\"\n        return self._raw_object\n\n    @raw_object.setter\n    def raw_object(self, raw_object: Dict):\n        \"\"\"\n        Sets the raw object that was used to create this Python object\n        :param raw_object: raw object dictionary from the response\n        :type raw_object: Dict\n        \"\"\"\n        self._raw_object = raw_object\n\n    @property\n    def x(self) -> float:\n        \"\"\"\n        :return: Returns x coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.x\n\n    @x.setter\n    def x(self, x: float):\n        \"\"\"\n        Sets x coordinate for bounding box\n\n        :param x: x coordinate of the bounding box\n        :type x: float\n        \"\"\"\n        self._bbox.x = x\n\n    @property\n    def y(self) -> float:\n        \"\"\"\n        :return: Returns y coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.y\n\n    @y.setter\n    def y(self, y: float):\n        \"\"\"\n        Sets y coordinate for bounding box.\n\n        :param y: y coordinate of the bounding box\n        :type y: float\n        \"\"\"\n        self._bbox.y = y\n\n    @property\n    def width(self) -> float:\n        \"\"\"\n        :return: Returns width for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.width\n\n    @width.setter\n    def width(self, width: float):\n        \"\"\"\n        Sets width for bounding box.\n\n        :param width: width of the bounding box\n        :type width: float\n        \"\"\"\n        self._bbox.width = width\n\n    @property\n    def height(self) -> float:\n        \"\"\"\n        :return: Returns height for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.height\n\n    @height.setter\n    def height(self, height: float):\n        \"\"\"\n        Sets height for bounding box.\n\n        :param height: height of the bounding box\n        :type height: float\n        \"\"\"\n        self._bbox.height = height\n\n    @property\n    def bbox(self) -> BoundingBox:\n        \"\"\"\n        :return: Returns entire bounding box of entity\n        :rtype: BoundingBox\n        \"\"\"\n        return self._bbox\n\n    @bbox.setter\n    def bbox(self, bbox: BoundingBox):\n        self._bbox = bbox\n\n    @property\n    def confidence(self) -> float:\n        \"\"\"\n        Returns the object confidence as predicted by Textract. If the confidence is not available, returns None\n\n        :return: Prediction confidence for a document entity, between 0 and 1\n        :rtype: float\n        \"\"\"\n        if hasattr(self, '_confidence'):\n            return self._confidence\n        if not hasattr(self, 'raw_object'):\n            return None\n        confidence = self.raw_object.get('Confidence')\n        if confidence is None:\n            return None\n        return confidence / 100\n\n    def remove(self, entity):\n        \"\"\"\n        Recursively removes an entity from the child tree of a document entity and update its bounding box\n\n        :param entity: Entity\n        :type entity: DocumentEntity\n        \"\"\"\n        for c in self._children:\n            if entity == c:\n                break\n            if not c.__class__.__name__ == 'Word' and c.remove(entity):\n                if not c.children:\n                    self._children.remove(c)\n                return True\n        else:\n            return False\n        self._children.remove(c)\n        if self._children:\n            self.bbox = BoundingBox.enclosing_bbox(self._children)\n        return True\n\n    def visit(self, word_set):\n        for c in list(self._children):\n            if c.__class__.__name__ == 'Word':\n                if c.id in word_set:\n                    self._children.remove(c)\n                else:\n                    word_set.add(c.id)\n            else:\n                c.visit(word_set)\n\n    def visualize(self, *args, **kwargs) -> EntityList:\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)",
    "textractor/entities/page.py": "\"\"\"\nRepresents a single :class:`Document` page, as it would appear in the Textract API output.\nThe :class:`Page` object also contains the metadata such as the physical dimensions of the page (width, height, in pixels), child_ids etc.\n\"\"\"\nimport os\nimport string\nimport logging\nimport xlsxwriter\nfrom typing import List, Tuple\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom textractor.entities.expense_document import ExpenseDocument\nfrom textractor.entities.word import Word\nfrom textractor.entities.line import Line\nfrom textractor.entities.table import Table\nfrom textractor.entities.signature import Signature\nfrom textractor.entities.layout import Layout\nfrom textractor.entities.page_layout import PageLayout\nfrom textractor.exceptions import InputError\nfrom textractor.entities.key_value import KeyValue\nfrom textractor.entities.query import Query\nfrom textractor.entities.identity_document import IdentityDocument\nfrom textractor.entities.bbox import SpatialObject\nfrom textractor.data.constants import SelectionStatus, Direction, DirectionalFinderType\nfrom textractor.data.constants import TextTypes, SimilarityMetric\nfrom textractor.data.constants import LAYOUT_TEXT, LAYOUT_TITLE, LAYOUT_HEADER, LAYOUT_FOOTER, LAYOUT_SECTION_HEADER, LAYOUT_PAGE_NUMBER, LAYOUT_LIST, LAYOUT_FIGURE, LAYOUT_TABLE, LAYOUT_KEY_VALUE\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.selection_element import SelectionElement\nfrom textractor.utils.geometry_util import sort_by_position\nfrom textractor.utils.search_utils import SearchUtils, jaccard_similarity\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.entities.linearizable import Linearizable\n\nclass Page(SpatialObject, Linearizable):\n    \"\"\"\n    Creates a new document, ideally representing a single item in the dataset.\n\n    :param id: Unique id of the Page\n    :type id: str\n    :param width: Width of page, in pixels\n    :type width: float\n    :param height: Height of page, in pixels\n    :type height: float\n    :param page_num: Page number in the document linked to this Page object\n    :type page_num: int\n    :param child_ids: IDs of child entities in the Page as determined by Textract\n    :type child_ids: List\n    \"\"\"\n\n    def __init__(self, id: str, width: int, height: int, page_num: int=-1, child_ids=None):\n        super().__init__(width=width, height=height)\n        self.id = id\n        self._words: EntityList[Word] = EntityList([])\n        self._lines: EntityList[Line] = EntityList([])\n        self._key_values: EntityList[KeyValue] = EntityList([])\n        self._checkboxes: EntityList[KeyValue] = EntityList([])\n        self._tables: EntityList[Table] = EntityList([])\n        self._queries: EntityList[Query] = EntityList([])\n        self._expense_documents: EntityList[ExpenseDocument] = EntityList([])\n        self._leaf_layouts: EntityList[Layout] = EntityList([])\n        self._container_layouts: EntityList[Layout] = EntityList([])\n        self.kv_cache = defaultdict(list)\n        self.metadata = {}\n        self.page_num = page_num\n        self.child_ids: List[str] = child_ids\n        self.image = None\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        Returns the page text\n\n        :return: Linearized page text\n        :rtype: str\n        \"\"\"\n        return self.get_text()\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()) -> Tuple[str, List[Word]]:\n        \"\"\"\n        Returns the page text and words sorted in reading order\n\n        :param config: Text linearization configuration object, defaults to TextLinearizationConfig()\n        :type config: TextLinearizationConfig, optional\n        :return: Tuple of page text and words\n        :rtype: Tuple[str, List[Word]]\n        \"\"\"\n        unsorted_layouts = [l for l in self.layouts if l.reading_order < 0]\n        sorted_layouts = [l for l in self.layouts if l.reading_order >= 0]\n        if unsorted_layouts:\n            for unsorted_layout in sorted(unsorted_layouts, key=lambda x: (x.bbox.y, x.bbox.x)):\n                closest_layout = None\n                closest_reading_order_distance = None\n                for layout in sorted(sorted_layouts, key=lambda x: x.reading_order):\n                    dist = layout.bbox.get_distance(unsorted_layout)\n                    if closest_reading_order_distance is None or dist < closest_reading_order_distance:\n                        closest_layout = layout\n                if closest_layout:\n                    sorted_layouts.insert(sorted_layouts.index(closest_layout) + 1, unsorted_layout)\n                else:\n                    sorted_layouts.append(unsorted_layout)\n        page_texts_and_words = [l.get_text_and_words(config) for l in sorted_layouts]\n        if not page_texts_and_words:\n            return ('', [])\n        text, words = zip(*page_texts_and_words)\n        combined_words = []\n        for w in words:\n            combined_words += w\n        return (config.layout_element_separator.join(text), combined_words)\n\n    @property\n    def page_layout(self) -> PageLayout:\n        return PageLayout(titles=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_TITLE]), headers=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_HEADER]), footers=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_FOOTER]), section_headers=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_SECTION_HEADER]), page_numbers=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_PAGE_NUMBER]), lists=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_LIST]), figures=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_FIGURE]), tables=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_TABLE]), key_values=EntityList([l for l in self.layouts if l.layout_type == LAYOUT_KEY_VALUE]))\n\n    @property\n    def queries(self) -> EntityList[Query]:\n        \"\"\"\n        Returns all the :class:`Query` objects present in the Page.\n\n        :return: List of Query objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._queries\n\n    @queries.setter\n    def queries(self, queries: List[Query]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._queries = EntityList(queries)\n\n    @property\n    def signatures(self) -> EntityList[Signature]:\n        \"\"\"\n        Returns all the :class:`Signature` objects present in the Page.\n\n        :return: List of Signature objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._signatures\n\n    @signatures.setter\n    def signatures(self, signatures: List[Signature]):\n        \"\"\"\n        Add Signature objects to the Page.\n\n        :param signatures: List of Signature objects.\n        :type signatures: list\n        \"\"\"\n        self._signatures = EntityList(signatures)\n\n    @property\n    def layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(sorted(self._leaf_layouts + self._container_layouts, key=lambda c: c.reading_order))\n\n    @property\n    def leaf_layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the leaf :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._leaf_layouts\n\n    @leaf_layouts.setter\n    def leaf_layouts(self, leaf_layouts: List[Layout]):\n        \"\"\"\n        Add leaf layout objects to the Page.\n\n        :param layouts: List of Layout objects.\n        :type layouts: list\n        \"\"\"\n        self._leaf_layouts = EntityList(leaf_layouts)\n\n    @property\n    def container_layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the container :class:`Layout` objects present in the Page.\n\n        :return: List of Layout objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._container_layouts\n\n    @container_layouts.setter\n    def container_layouts(self, container_layouts: List[Layout]):\n        \"\"\"\n        Add Layout objects to the Page.\n\n        :param layouts: List of Layout objects.\n        :type layouts: list\n        \"\"\"\n        self._container_layouts = EntityList(container_layouts)\n\n    @property\n    def expense_documents(self) -> EntityList[ExpenseDocument]:\n        \"\"\"\n        Returns all the :class:`ExpenseDocument` objects present in the Page.\n\n        :return: List of ExpenseDocument objects.\n        :rtype: EntityList\n        \"\"\"\n        return self._expense_documents\n\n    @expense_documents.setter\n    def expense_documents(self, expense_documents: List[ExpenseDocument]):\n        \"\"\"\n        Add ExpenseDocument objects to the Page.\n\n        :param tables: List of ExpenseDocument objects.\n        :type expense_documents: list\n        \"\"\"\n        self._expense_documents = EntityList(expense_documents)\n\n    def __getitem__(self, key):\n        output = self.get(key)\n        if output:\n            return output\n        raise KeyError(f'{key} was not found in Document')\n\n    def _search_words_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> List[Tuple[Word, float]]:\n        \"\"\"\n        Returns a list of top_k words with their similarity to the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str, required\n        :param top_k: Number of closest word objects to be returned. default=1\n        :type top_k: int, optional\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples containing similarity and Word.\n        :rtype: List[Tuple(float, Word)]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n_words = []\n        similarity_threshold = similarity_threshold if similarity_metric == SimilarityMetric.COSINE else -similarity_threshold\n        lowest_similarity = similarity_threshold\n        for word in self.words:\n            similarity = SearchUtils.get_word_similarity(keyword, word.text, similarity_metric)\n            similarity = similarity if similarity_metric == SimilarityMetric.COSINE else -similarity\n            if len(top_n_words) < top_k and similarity > similarity_threshold:\n                top_n_words.append((similarity, word))\n            elif similarity > lowest_similarity:\n                top_n_words[-1] = (similarity, word)\n            else:\n                continue\n            top_n_words = sorted(top_n_words, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_words[-1][0]\n        return top_n_words\n\n    def _search_lines_with_similarity(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: int=0.6) -> List[Tuple[Line, float]]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the page.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar page key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of tuples of lines and their similarity to the keyword that contain the queried key sorted\n                 from highest to lowest similarity.\n        :rtype: List[Tuple[Line, float]]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n_lines = []\n        similarity_threshold = similarity_threshold if similarity_metric == SimilarityMetric.COSINE else -similarity_threshold\n        lowest_similarity = similarity_threshold\n        for line in self.lines:\n            similarity = [SearchUtils.get_word_similarity(keyword, word, similarity_metric) for word in line.__repr__().split(' ')]\n            similarity.append(SearchUtils.get_word_similarity(keyword, line.__repr__(), similarity_metric))\n            similarity = max(similarity) if similarity_metric == SimilarityMetric.COSINE else -min(similarity)\n            if len(top_n_lines) < top_k and similarity > similarity_threshold:\n                top_n_lines.append((similarity, line))\n            elif similarity > lowest_similarity:\n                top_n_lines[-1] = (similarity, line)\n            else:\n                continue\n            top_n_lines = sorted(top_n_lines, key=lambda x: x[0], reverse=True)\n            lowest_similarity = top_n_lines[-1][0]\n        return top_n_lines\n\n    def _update_entity_page_num(self):\n        \"\"\"Updates page number if Textractor API call was given a list of images.\"\"\"\n        entities = self.words + self.lines + self.key_values + self.checkboxes + self.tables\n        for entity in entities:\n            entity.page = self.page_num\n\n    def directional_finder(self, word_1: str='', word_2: str='', prefix: str='', direction=Direction.BELOW, entities=[]):\n        \"\"\"\n        The function returns entity types present in entities by prepending the prefix provided by te user. This helps in cases of repeating\n        key-values and checkboxes. The user can manipulate original data or produce a copy. The main advantage of this function is to be able to define direction.\n\n        :param word_1: The reference word from where x1, y1 coordinates are derived\n        :type word_1: str, required\n        :param word_2: The second word preferably in the direction indicated by the parameter direction. When it isn't given the end of page coordinates are used in the given direction.\n        :type word_2: str, optional\n        :param prefix: User provided prefix to prepend to the key . Without prefix, the method acts as a search by geometry function\n        :type prefix: str, optional\n        :param entities: List of DirectionalFinderType inputs.\n        :type entities: List[DirectionalFinderType]\n\n        :return: Returns the EntityList of modified key-value and/or checkboxes\n        :rtype: EntityList\n        \"\"\"\n        if not word_1:\n            return EntityList([])\n        x1, x2, y1, y2 = self._get_coords(word_1, word_2, direction)\n        if x1 == -1:\n            return EntityList([])\n        entity_dict = {DirectionalFinderType.KEY_VALUE_SET: self.key_values, DirectionalFinderType.SELECTION_ELEMENT: self.checkboxes}\n        entitylist = []\n        for entity_type in entities:\n            entitylist.extend(list(entity_dict[entity_type]))\n        new_key_values = self._get_kv_with_direction(direction, entitylist, (x1, x2, y1, y2))\n        final_kv = []\n        for kv in new_key_values:\n            if kv.key:\n                key_words = [deepcopy(word) for word in kv.key]\n                key_words[0].text = prefix + key_words[0].text\n                new_kv = deepcopy(kv)\n                new_kv.key = key_words\n                final_kv.append(new_kv)\n            else:\n                final_kv.append(kv)\n        return EntityList(final_kv)\n\n    def _get_kv_with_direction(self, direction, entitylist, coords):\n        \"\"\"Return key-values and checkboxes in entitiylist present in the direction given with respect to the coordinates.\"\"\"\n        if direction == Direction.ABOVE:\n            new_key_values = [kv for kv in entitylist if kv.bbox.y <= coords[2] and kv.bbox.y >= coords[-1]]\n        elif direction == Direction.BELOW:\n            new_key_values = [kv for kv in entitylist if kv.bbox.y >= coords[2] and kv.bbox.y <= coords[-1]]\n        elif direction == Direction.RIGHT:\n            new_key_values = [kv for kv in entitylist if kv.bbox.x >= coords[0] and kv.bbox.x <= coords[1]]\n            new_key_values = [kv for kv in new_key_values if kv.bbox.y >= coords[2] - kv.bbox.height and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height]\n        elif direction == Direction.LEFT:\n            new_key_values = [kv for kv in entitylist if kv.bbox.x <= coords[0] and kv.bbox.x >= coords[1]]\n            new_key_values = [kv for kv in new_key_values if kv.bbox.y >= coords[2] - kv.bbox.height and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height]\n        return new_key_values\n\n    def _get_coords(self, word_1, word_2, direction):\n        \"\"\"\n        Returns coordinates for the area within which to search for key-values with the directional_finder by retrieving coordinates of word_1         and word_2 if it exists else end of page.\n        \"\"\"\n        word_1_objects = self.search_lines(keyword=word_1, top_k=5, similarity_metric=SimilarityMetric.COSINE, similarity_threshold=0.5)\n        if not word_1_objects:\n            logging.warning(f'{word_1} not found in page')\n            return (-1, -1, -1, -1)\n        else:\n            word_1_obj = word_1_objects[0]\n            x1, y1 = (word_1_obj.bbox.x, word_1_obj.bbox.y)\n        if word_2:\n            word_2_objects = self.search_lines(keyword=word_2, top_k=5, similarity_metric=SimilarityMetric.COSINE, similarity_threshold=0.5)\n            if not word_2_objects:\n                logging.warning(f'{word_2} not found in page')\n                return (-1, -1, -1, -1)\n            else:\n                word_2_obj = word_2_objects[0]\n                x2, y2 = (word_2_obj.bbox.x, word_2_obj.bbox.y)\n        else:\n            x2, y2 = (1, 1)\n        if direction == Direction.ABOVE:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 < y1 else (x1, 0, y1, 0)\n        elif direction == Direction.BELOW:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 > y1 else (x1, 1, y1, 1)\n        elif direction == Direction.RIGHT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 > x1 else (x1, 1, y1, y1)\n        elif direction == Direction.LEFT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 < x1 else (x1, 0, y1, y1)\n        else:\n            return (-1, -1, -1, -1)\n        return (x1, x2, y1, y2)\n\n    def visualize(self, *args, **kwargs):\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)",
    "textractor/entities/key_value.py": "\"\"\"\nThe :class:`KeyValue` entity is a document entity representing the Forms output. The key in :class:`KeyValue` are typically words \nand the :class:`Value` could be :class:`Word` elements or :class:`SelectionElement` in case of checkboxes.\n\nThis class contains the associated metadata with the :class:`KeyValue` entity including the entity ID, \nbounding box information, value, existence of checkbox, page number, Page ID and confidence of detection.\n\"\"\"\nimport logging\nfrom typing import List\nimport uuid\nfrom textractor.entities.word import Word\nfrom textractor.entities.value import Value\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\nclass KeyValue(DocumentEntity):\n    \"\"\"\n    To create a new :class:`KeyValue` object we require the following:\n\n    :param entity_id: Unique identifier of the KeyValue entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the KeyValue entity.\n    :type bbox: BoundingBox\n    :param contains_checkbox: True/False to indicate if the value is a checkbox.\n    :type contains_checkbox: bool\n    :param value: Value object that maps to the KeyValue entity.\n    :type value: Value\n    :param confidence: confidence with which the entity was detected.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox, contains_checkbox: bool=False, value: Value=None, confidence: float=0):\n        super().__init__(entity_id, bbox)\n        self._words: EntityList[Word] = []\n        self.contains_checkbox = contains_checkbox\n        self._confidence = confidence / 100\n        self._value: Value = value\n        self.selection_status = False\n        self._page = None\n        self._page_id = None\n\n    @property\n    def ocr_confidence(self):\n        \"\"\"\n        Return the average OCR confidence\n        :return:\n        \"\"\"\n        key_confidences = [w.confidence for w in self.key]\n        value_confidences = [w.confidence for w in self.value.words] if self.value else []\n        key_confidence = sum(key_confidences) / len(key_confidences) if key_confidences else None\n        value_confidence = sum(value_confidences) / len(value_confidences) if value_confidences else None\n        return {'key_average': key_confidence, 'key_min': min(key_confidences) if key_confidences else None, 'value_average': value_confidence, 'value_min': min(value_confidences) if value_confidences else None}\n\n    @property\n    def words(self) -> List[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the key and value of the :class:`KeyValue` object.\n\n        :return words: List of Word objects, each representing a word within the KeyValue entity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        value_words = self.value.words if self.value is not None and (not self.contains_checkbox) else []\n        return EntityList(sorted(self._words + value_words, key=lambda x: x.bbox.x + x.bbox.y))\n\n    @property\n    def key(self):\n        \"\"\"\n        :return: Returns :class:`EntityList[Word]` object (a list of words) associated with the key.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self._words:\n            logging.info('Key contains no words objects.')\n            return []\n        return self._words\n\n    @key.setter\n    def key(self, words: List[Word]):\n        \"\"\"\n        Add :class:`Word` objects to the Key.\n\n        :param words: List of Word objects, each representing a word within the Key.\n        No specific ordering is assumed.\n        :type words: list\n        \"\"\"\n        self._words = EntityList(words)\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the :class:`Table` entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Table` entity.\n\n        :param page_num: Page number where the Table entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Table` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: str=TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError('text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants')\n        if not self.words:\n            logging.info('Document contains no word entities.')\n            return []\n        else:\n            return EntityList([word for word in self.words if word.text_type == text_type])\n\n    def is_selected(self) -> bool:\n        \"\"\"\n        For KeyValues containing a selection item, returns its `is_selected` status\n\n        :return: Selection status of a selection item key value pair\n        :rtype: bool\n        \"\"\"\n        if self.contains_checkbox:\n            if len(self.value.children) == 1:\n                return self.value.children[0].is_selected()\n            else:\n                logging.info('is_checked() was called on a KeyValue that contains more than one checkbox. Returning first checkbox')\n                return self.value.children[0].is_selected()\n        else:\n            logging.info('is_checked() was called on a KeyValue that does not contain checkboxes. Returning False')\n            return False\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        key_text, key_words = (' '.join([w.text for w in self.key]), self.key)\n        value_text, value_words = self.value.get_text_and_words(config) if self.value else ('', '')\n        words = []\n        if not len(key_text) and (not len(value_text)):\n            return ('', [])\n        s = config.key_suffix.strip()\n        key_suffix = config.key_suffix if not (len(key_text) > len(s) and key_text[-len(s):] == s) else ' '\n        if config.add_prefixes_and_suffixes_in_text:\n            text = f'{add_id_to_html_tag(config.key_value_prefix, self.id, config)}{config.key_prefix}{key_text}{key_suffix}{value_text}{config.key_value_suffix}'\n        else:\n            text = f'{key_text}{config.same_paragraph_separator}{value_text}'\n        if config.add_prefixes_and_suffixes_as_words:\n            words += [Word(str(uuid.uuid4()), self.bbox, add_id_to_html_tag(config.key_value_prefix, self.id, config), is_structure=True)] if config.key_value_prefix else []\n            if key_words:\n                words += ([Word(str(uuid.uuid4()), BoundingBox.enclosing_bbox(self.key), config.key_prefix, is_structure=True)] if config.key_prefix else []) + key_words + ([Word(str(uuid.uuid4()), BoundingBox.enclosing_bbox(self.key), config.key_suffix, is_structure=True)] if config.key_suffix else [])\n            if value_words:\n                words += value_words\n            words += [Word(str(uuid.uuid4()), self.bbox, config.key_value_suffix, is_structure=True)] if config.key_value_suffix else []\n        else:\n            words += key_words + value_words\n        for w in words:\n            w.kv_id = str(self.id)\n            w.kv_bbox = self.bbox\n        return (text, words)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: Returns KeyValue object as a formatted string.\n        :rtype: str\n        \"\"\"\n        repr_string = ' '.join([word.text for word in self._words])\n        if self.contains_checkbox:\n            repr_string = self.value.__repr__() + ' ' + repr_string\n        else:\n            repr_string = repr_string\n            repr_string += ' : '\n            repr_string += self.value.__repr__()\n        return repr_string",
    "textractor/entities/document.py": "\"\"\"The Document class is defined to host all the various DocumentEntity objects within it. :class:`DocumentEntity` objects can be \naccessed, searched and exported the functions given below.\"\"\"\nimport boto3\nimport json\nimport os\nimport string\nimport logging\nimport xlsxwriter\nimport io\nfrom pathlib import Path\nfrom typing import List, IO, Union, AnyStr, Tuple\nfrom copy import deepcopy\nfrom collections import defaultdict\nfrom PIL import Image\nfrom textractor.entities.expense_document import ExpenseDocument\nfrom textractor.entities.identity_document import IdentityDocument\nfrom textractor.entities.word import Word\nfrom textractor.entities.line import Line\nfrom textractor.entities.page import Page\nfrom textractor.entities.table import Table\nfrom textractor.entities.query import Query\nfrom textractor.entities.signature import Signature\nfrom textractor.entities.layout import Layout\nfrom textractor.exceptions import InputError\nfrom textractor.entities.key_value import KeyValue\nfrom textractor.entities.bbox import SpatialObject\nfrom textractor.utils.s3_utils import download_from_s3\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.constants import TextTypes, SimilarityMetric, Direction, DirectionalFinderType\nfrom textractor.utils.search_utils import SearchUtils\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\nclass Document(SpatialObject, Linearizable):\n    \"\"\"\n    Represents the description of a single document, as it would appear in the input to the Textract API.\n    Document serves as the root node of the object model hierarchy,\n    which should be used as an intermediate form for most analytic purposes.\n    The Document node also contains the metadata of the document.\n    \"\"\"\n\n    def __init__(self, num_pages: int=1):\n        \"\"\"\n        Creates a new document, ideally containing entity objects pertaining to each page.\n\n        :param num_pages: Number of pages in the input Document.\n        \"\"\"\n        super().__init__(width=0, height=0)\n        self.num_pages: int = num_pages\n        self._pages: List[Page] = []\n        self._identity_documents: List[IdentityDocument] = []\n        self._trp2_document = None\n        self.response = None\n\n    @property\n    def words(self) -> EntityList[Word]:\n        \"\"\"\n        Returns all the :class:`Word` objects present in the Document.\n\n        :return: List of Word objects, each representing a word within the Document.\n        :rtype: EntityList[Word]\n        \"\"\"\n        return EntityList(sum([page.words for page in self.pages], []))\n\n    @property\n    def text(self) -> str:\n        \"\"\"Returns the document text as one string\n\n        :return: Page text seperated by line return\n        :rtype: str\n        \"\"\"\n        return os.linesep.join([page.text for page in self.pages])\n\n    @property\n    def identity_documents(self) -> EntityList[IdentityDocument]:\n        \"\"\"\n        Returns all the :class:`IdentityDocument` objects present in the Document.\n\n        :return: List of IdentityDocument objects, each representing an identity document within the Document.\n        :rtype: EntityList[IdentityDocument]\n        \"\"\"\n        return EntityList(self._identity_documents)\n\n    @identity_documents.setter\n    def identity_documents(self, identity_documents: List[IdentityDocument]):\n        \"\"\"\n        Set all the identity documents detected inside the Document\n        \"\"\"\n        self._identity_documents = identity_documents\n\n    @property\n    def expense_documents(self) -> EntityList[ExpenseDocument]:\n        \"\"\"\n        Returns all the :class:`ExpenseDocument` objects present in the Document.\n\n        :return: List of ExpenseDocument objects, each representing an expense document within the Document.\n        :rtype: EntityList[ExpenseDocument]\n        \"\"\"\n        return EntityList(sum([page.expense_documents for page in self.pages], []))\n\n    @property\n    def lines(self) -> EntityList[Line]:\n        \"\"\"\n        Returns all the :class:`Line` objects present in the Document.\n\n        :return: List of Line objects, each representing a line within the Document.\n        :rtype: EntityList[Line]\n        \"\"\"\n        return EntityList(sum([page.lines for page in self.pages], []))\n\n    @property\n    def key_values(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects present in the Document.\n\n        :return: List of KeyValue objects, each representing a key-value pair within the Document.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return EntityList(sum([page.key_values for page in self.pages], []))\n\n    @property\n    def checkboxes(self) -> EntityList[KeyValue]:\n        \"\"\"\n        Returns all the :class:`KeyValue` objects with SelectionElements present in the Document.\n\n        :return: List of KeyValue objects, each representing a checkbox within the Document.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        return EntityList(sum([page.checkboxes for page in self.pages], []))\n\n    @property\n    def tables(self) -> EntityList[Table]:\n        \"\"\"\n        Returns all the :class:`Table` objects present in the Document.\n\n        :return: List of Table objects, each representing a table within the Document.\n        :rtype: EntityList[Table]\n        \"\"\"\n        return EntityList(sum([page.tables for page in self.pages], []))\n\n    @property\n    def queries(self) -> EntityList[Query]:\n        \"\"\"\n        Returns all the :class:`Query` objects present in the Document.\n\n        :return: List of Query objects.\n        :rtype: EntityList[Query]\n        \"\"\"\n        return EntityList(sum([page.queries for page in self.pages], []))\n\n    @property\n    def signatures(self) -> EntityList[Signature]:\n        \"\"\"\n        Returns all the :class:`Signature` objects present in the Document.\n\n        :return: List of Signature objects.\n        :rtype: EntityList[Signature]\n        \"\"\"\n        return EntityList(sum([page.signatures for page in self.pages], []))\n\n    @property\n    def layouts(self) -> EntityList[Layout]:\n        \"\"\"\n        Returns all the :class:`Layout` objects present in the Document\n\n        :return: List of Layout objects\n        :rtype: EntityList[Layout]\n        \"\"\"\n        return EntityList(sum([page.layouts for page in self.pages], []))\n\n    @property\n    def identity_document(self) -> EntityList[IdentityDocument]:\n        \"\"\"\n        Returns all the :class:`IdentityDocument` objects present in the Page.\n\n        :return: List of IdentityDocument objects.\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self._identity_documents)\n\n    @identity_document.setter\n    def identity_document(self, identity_documents: List[IdentityDocument]):\n        \"\"\"\n        Add IdentityDocument objects to the Page.\n\n        :param tables: List of IdentityDocument objects.\n        :type identity_documents: list\n        \"\"\"\n        self._identity_document = identity_documents\n\n    @property\n    def images(self) -> List[Image.Image]:\n        \"\"\"\n        Returns all the page images in the Document.\n\n        :return: List of PIL Image objects.\n        :rtype: PIL.Image\n        \"\"\"\n        return [page.image for page in self._pages]\n\n    @property\n    def pages(self) -> List[Page]:\n        \"\"\"\n        Returns all the :class:`Page` objects present in the Document.\n\n        :return: List of Page objects, each representing a Page within the Document.\n        :rtype: List\n        \"\"\"\n        return self._pages\n\n    @pages.setter\n    def pages(self, pages: List[Page]):\n        \"\"\"\n        Add Page objects to the Document.\n\n        :param pages: List of Page objects, each representing a page within the document.\n        No specific ordering is assumed with input.\n        :type pages: List[Page]\n        \"\"\"\n        self._pages = sorted(pages, key=lambda x: x.page_num)\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()) -> Tuple[str, List]:\n        text, words_lists = zip(*[p.get_text_and_words(config) for p in self.pages])\n        flattened_words = []\n        for words in words_lists:\n            flattened_words.extend(words)\n        return (config.layout_element_separator.join(text), flattened_words)\n\n    def to_html(self, config: HTMLLinearizationConfig=HTMLLinearizationConfig()):\n        \"\"\"\n        Returns the HTML representation of the document, effectively calls Linearizable.to_html()\n        but add <html><body></body></html> around the result and put each page in a <div>. \n\n        :return: HTML text of the entity\n        :rtype: str\n        \"\"\"\n        html = '<html><body>'\n        for page in self.pages:\n            html += f'<div>{page.to_html(config=config)}</div>'\n        html += '</body></html>'\n        return html\n\n    def __repr__(self):\n        return os.linesep.join(['This document holds the following data:', f'Pages - {len(self.pages)}', f'Words - {len(self.words)}', f'Lines - {len(self.lines)}', f'Key-values - {len(self.key_values)}', f'Checkboxes - {len(self.checkboxes)}', f'Tables - {len(self.tables)}', f'Queries - {len(self.queries)}', f'Signatures - {len(self.signatures)}', f'Identity Documents - {len(self.identity_documents)}', f'Expense Documents - {len(self.expense_documents)}'])\n\n    def to_trp2(self):\n        \"\"\"\n        Parses the response to the trp2 format for backward compatibility\n\n        :return: TDocument object that can be used with the older Textractor libraries\n        :rtype: TDocument\n        \"\"\"\n        from trp.trp2 import TDocument, TDocumentSchema\n        if not self._trp2_document:\n            self._trp2_document = TDocumentSchema().load(self.response)\n        return self._trp2_document\n\n    def visualize(self, *args, **kwargs):\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self.pages).visualize(*args, **kwargs)\n\n    def keys(self, include_checkboxes: bool=True) -> List[str]:\n        \"\"\"\n        Prints all keys for key-value pairs and checkboxes if the document contains them.\n\n        :param include_checkboxes: True/False. Set False if checkboxes need to be excluded.\n        :type include_checkboxes: bool\n\n        :return: List of strings containing key names in the Document\n        :rtype: List[str]\n        \"\"\"\n        keys = []\n        keys = [keyvalue.key for keyvalue in self.key_values]\n        if include_checkboxes:\n            keys += [keyvalue.key for keyvalue in self.checkboxes]\n        return keys\n\n    def filter_checkboxes(self, selected: bool=True, not_selected: bool=True) -> List[KeyValue]:\n        \"\"\"\n        Return a list of :class:`KeyValue` objects containing checkboxes if the document contains them.\n\n        :param selected: True/False Return SELECTED checkboxes\n        :type selected: bool\n        :param not_selected: True/False Return NOT_SELECTED checkboxes\n        :type not_selected: bool\n\n        :return: Returns checkboxes that match the conditions set by the flags.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        checkboxes = EntityList([])\n        for page in self.pages:\n            checkboxes.extend(page.filter_checkboxes(selected=selected, not_selected=not_selected))\n        return checkboxes\n\n    def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.words:\n            logging.warn('Document contains no word entities.')\n            return []\n        filtered_words = EntityList()\n        for page in self.pages:\n            filtered_words.extend(page.get_words_by_type(text_type=text_type))\n        return filtered_words\n\n    def search_words(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> List[Word]:\n        \"\"\"\n        Return a list of top_k words that match the keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str\n        :param top_k: Number of closest word objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of words that match the queried key sorted from highest\n                 to lowest similarity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        top_n_words = []\n        for page in self.pages:\n            top_n_words.extend(page._search_words_with_similarity(keyword=keyword, top_k=top_k, similarity_metric=similarity_metric, similarity_threshold=similarity_threshold))\n        top_n_words = sorted(top_n_words, key=lambda x: x[0], reverse=True)[:top_k]\n        top_n_words = EntityList([ent[1] for ent in top_n_words])\n        return top_n_words\n\n    def search_lines(self, keyword: str, top_k: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6) -> List[Line]:\n        \"\"\"\n        Return a list of top_k lines that contain the queried keyword.\n\n        :param keyword: Keyword that is used to query the document.\n        :type keyword: str\n        :param top_k: Number of closest line objects to be returned\n        :type top_k: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of lines that contain the queried key sorted from highest\n                 to lowest similarity.\n        :rtype: EntityList[Line]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n_lines = []\n        for page in self.pages:\n            top_n_lines.extend(page._search_lines_with_similarity(keyword=keyword, top_k=top_k, similarity_metric=similarity_metric, similarity_threshold=similarity_threshold))\n        top_n_lines = EntityList([ent[1] for ent in top_n_lines][:top_k])\n        return top_n_lines\n\n    def get(self, key: str, top_k_matches: int=1, similarity_metric: SimilarityMetric=SimilarityMetric.LEVENSHTEIN, similarity_threshold: float=0.6):\n        \"\"\"\n        Return upto top_k_matches of key-value pairs for the key that is queried from the document.\n\n        :param key: Query key to match\n        :type key: str\n        :param top_k_matches: Maximum number of matches to return\n        :type top_k_matches: int\n        :param similarity_metric: SimilarityMetric.COSINE, SimilarityMetric.EUCLIDEAN or SimilarityMetric.LEVENSHTEIN. SimilarityMetric.COSINE is chosen as default.\n        :type similarity_metric: SimilarityMetric\n        :param similarity_threshold: Measure of how similar document key is to queried key. default=0.6\n        :type similarity_threshold: float\n\n        :return: Returns a list of key-value pairs that match the queried key sorted from highest to lowest similarity.\n        :rtype: EntityList[KeyValue]\n        \"\"\"\n        if not isinstance(similarity_metric, SimilarityMetric):\n            raise InputError('similarity_metric parameter should be of SimilarityMetric type. Find input choices from textractor.data.constants')\n        top_n = []\n        similarity_threshold = -similarity_threshold if similarity_metric == SimilarityMetric.EUCLIDEAN else similarity_threshold\n        lowest_similarity = similarity_threshold\n        for kv in self.key_values + self.checkboxes:\n            try:\n                edited_document_key = ''.join([char for char in kv.key.__repr__() if char not in string.punctuation])\n            except:\n                pass\n            key = ''.join([char for char in key if char not in string.punctuation])\n            similarity = [SearchUtils.get_word_similarity(key, word, similarity_metric) for word in edited_document_key.split(' ')]\n            similarity.append(SearchUtils.get_word_similarity(key, edited_document_key, similarity_metric))\n            similarity = min(similarity) if similarity_metric == SimilarityMetric.EUCLIDEAN else max(similarity)\n            if similarity > similarity_threshold:\n                if len(top_n) < top_k_matches:\n                    top_n.append((kv, similarity))\n                elif similarity > lowest_similarity:\n                    top_n[-1] = (kv, similarity)\n                top_n = sorted(top_n, key=lambda x: x[1], reverse=True)\n                lowest_similarity = top_n[-1][1]\n        if not top_n:\n            logging.warning(f'Query key does not match any existing keys in the document.{os.linesep}{self.keys()}')\n            return EntityList([])\n        logging.info(f'Query key matched {len(top_n)} key-values in the document.')\n        return EntityList([value[0] for value in top_n])\n\n    def export_kv_to_csv(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.csv', sep: str=';'):\n        \"\"\"\n        Export key-value entities and checkboxes in csv format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        :param sep: Separator to be used in the csv file.\n        :type sep: str\n        \"\"\"\n        keys = []\n        values = []\n        if include_kv and (not self.key_values):\n            logging.warning('Document does not contain key-values.')\n        elif include_kv:\n            for kv in self.key_values:\n                keys.append(' '.join([w.text for w in kv.key]))\n                values.append(kv.value.get_text())\n        if include_checkboxes and (not self.checkboxes):\n            logging.warning('Document does not contain checkbox elements.')\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                keys.append(' '.join([w.text for w in kv.key]))\n                values.append(kv.value.children[0].status.name)\n        with open(filepath, 'w') as f:\n            f.write(f'Key{sep}Value{os.linesep}')\n            for k, v in zip(keys, values):\n                f.write(f'{k}{sep}{v}{os.linesep}')\n        logging.info(f'csv file stored at location {os.path.join(os.getcwd(), filepath)}')\n\n    def export_kv_to_txt(self, include_kv: bool=True, include_checkboxes: bool=True, filepath: str='Key-Values.txt'):\n        \"\"\"\n        Export key-value entities and checkboxes in txt format.\n\n        :param include_kv: True if KVs are to be exported. Else False.\n        :type include_kv: bool\n        :param include_checkboxes: True if checkboxes are to be exported. Else False.\n        :type include_checkboxes: bool\n        :param filepath: Path to where file is to be stored.\n        :type filepath: str\n        \"\"\"\n        export_str = ''\n        index = 1\n        if include_kv and (not self.key_values):\n            logging.warning('Document does not contain key-values.')\n        elif include_kv:\n            for kv in self.key_values:\n                export_str += f'{index}. {kv.key.__repr__()} : {kv.value.__repr__()}{os.linesep}'\n                index += 1\n        if include_checkboxes and (not self.checkboxes):\n            logging.warning('Document does not contain checkbox elements.')\n        elif include_checkboxes:\n            for kv in self.checkboxes:\n                export_str += f'{index}. {kv.key.__repr__()} : {kv.value.children[0].status.name}{os.linesep}'\n                index += 1\n        with open(filepath, 'w') as text_file:\n            text_file.write(export_str)\n        logging.info(f'txt file stored at location {os.path.join(os.getcwd(), filepath)}')\n\n    def export_tables_to_excel(self, filepath):\n        \"\"\"\n        Creates an excel file and writes each table on a separate worksheet within the workbook.\n        This is stored on the filepath passed by the user.\n\n        :param filepath: Path to store the exported Excel file.\n        :type filepath: str, required\n        \"\"\"\n        if not filepath:\n            logging.error('Filepath required to store excel file.')\n        workbook = xlsxwriter.Workbook(filepath)\n        for table in self.tables:\n            workbook = table.to_excel(filepath=None, workbook=workbook, save_workbook=False)\n        workbook.close()\n\n    def independent_words(self):\n        \"\"\"\n        :return: Return all words in the document, outside of tables, checkboxes, key-values.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.words:\n            logging.warning('Words have not been assigned to this Document object.')\n            return []\n        else:\n            table_words = sum([table.words for table in self.tables], [])\n            kv_words = sum([kv.words for kv in self.key_values], [])\n            checkbox_words = sum([kv.words for kv in self.checkboxes], [])\n            dependent_words = table_words + checkbox_words + kv_words\n            dependent_word_ids = set([word.id for word in dependent_words])\n            independent_words = [word for word in self.words if word.id not in dependent_word_ids]\n            return EntityList(independent_words)\n\n    def return_duplicates(self):\n        \"\"\"\n        Returns a dictionary containing page numbers as keys and list of :class:`EntityList` objects as values.\n        Each :class:`EntityList` instance contains the key-values and the last item is the table which contains duplicate information.\n        This function is intended to let the Textract user know of duplicate objects extracted by the various Textract models.\n\n        :return: Dictionary containing page numbers as keys and list of EntityList objects as values.\n        :rtype: Dict[page_num, List[EntityList[DocumentEntity]]]\n        \"\"\"\n        document_duplicates = defaultdict(list)\n        for page in self.pages:\n            document_duplicates[page.page_num].extend(page.return_duplicates())\n        return document_duplicates\n\n    def directional_finder(self, word_1: str='', word_2: str='', page: int=-1, prefix: str='', direction=Direction.BELOW, entities=[]):\n        \"\"\"\n        The function returns entity types present in entities by prepending the prefix provided by te user. This helps in cases of repeating\n        key-values and checkboxes. The user can manipulate original data or produce a copy. The main advantage of this function is to be able to define direction.\n\n        :param word_1: The reference word from where x1, y1 coordinates are derived\n        :type word_1: str, required\n        :param word_2: The second word preferably in the direction indicated by the parameter direction. When it isn't given the end of page coordinates are used in the given direction.\n        :type word_2: str, optional\n        :param page: page number of the page in the document to search the entities in.\n        :type page: int, required\n        :param prefix: User provided prefix to prepend to the key . Without prefix, the method acts as a search by geometry function\n        :type prefix: str, optional\n        :param entities: List of DirectionalFinderType inputs.\n        :type entities: List[DirectionalFinderType]\n\n        :return: Returns the EntityList of modified key-value and/or checkboxes\n        :rtype: EntityList\n        \"\"\"\n        if not word_1 or page == -1:\n            return EntityList([])\n        x1, x2, y1, y2 = self._get_coords(word_1, word_2, direction, page)\n        if x1 == -1:\n            return EntityList([])\n        page_obj = self.pages[page - 1]\n        entity_dict = {DirectionalFinderType.KEY_VALUE_SET: self.key_values, DirectionalFinderType.SELECTION_ELEMENT: self.checkboxes}\n        entitylist = []\n        for entity_type in entities:\n            entitylist.extend(list(entity_dict[entity_type]))\n        new_key_values = self._get_kv_with_direction(direction, entitylist, (x1, x2, y1, y2))\n        final_kv = []\n        for kv in new_key_values:\n            if kv.key:\n                key_words = [deepcopy(word) for word in kv.key]\n                key_words[0].text = prefix + key_words[0].text\n                new_kv = deepcopy(kv)\n                new_kv.key = key_words\n                final_kv.append(new_kv)\n            else:\n                final_kv.append(kv)\n        return EntityList(final_kv)\n\n    def _get_kv_with_direction(self, direction, entitylist, coords):\n        \"\"\"Return key-values and checkboxes in entitylist present in the direction given with respect to the coordinates.\"\"\"\n        if direction == Direction.ABOVE:\n            new_key_values = [kv for kv in entitylist if kv.bbox.y <= coords[2] and kv.bbox.y >= coords[-1]]\n        elif direction == Direction.BELOW:\n            new_key_values = [kv for kv in entitylist if kv.bbox.y >= coords[2] and kv.bbox.y <= coords[-1]]\n        elif direction == Direction.RIGHT:\n            new_key_values = [kv for kv in entitylist if kv.bbox.x >= coords[0] and kv.bbox.x <= coords[1]]\n            new_key_values = [kv for kv in new_key_values if kv.bbox.y >= coords[2] - kv.bbox.height and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height]\n        elif direction == Direction.LEFT:\n            new_key_values = [kv for kv in entitylist if kv.bbox.x <= coords[0] and kv.bbox.x >= coords[1]]\n            new_key_values = [kv for kv in new_key_values if kv.bbox.y >= coords[2] - kv.bbox.height and kv.bbox.y <= coords[-1] + 3 * kv.bbox.height]\n        return new_key_values\n\n    def _get_coords(self, word_1, word_2, direction, page):\n        \"\"\"\n        Returns coordinates for the area within which to search for key-values with the directional_finder by retrieving coordinates of word_1         and word_2 if it exists else end of page.\n        \"\"\"\n        word_1_objects = self.search_lines(keyword=word_1, top_k=5, similarity_metric=SimilarityMetric.COSINE, similarity_threshold=0.5)\n        word_1_objects = [word for word in word_1_objects if word.page == page] if page != -1 else []\n        if not word_1_objects:\n            logging.warning(f'{word_1} not found in page {page}')\n            return (-1, -1, -1, -1)\n        else:\n            word_1_obj = word_1_objects[0]\n            x1, y1 = (word_1_obj.bbox.x, word_1_obj.bbox.y)\n        if word_2:\n            word_2_objects = self.search_lines(keyword=word_2, top_k=5, similarity_metric=SimilarityMetric.COSINE, similarity_threshold=0.5)\n            word_2_objects = [word for word in word_2_objects if word.page == page]\n            if not word_2_objects:\n                logging.warning(f'{word_2} not found in page {page}')\n                return (-1, -1, -1, -1)\n            else:\n                word_2_obj = word_2_objects[0]\n                x2, y2 = (word_2_obj.bbox.x, word_2_obj.bbox.y)\n        else:\n            x2, y2 = (x1, y1)\n        if direction == Direction.ABOVE:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 < y1 else (x1, 0, y1, 0)\n        elif direction == Direction.BELOW:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if y2 > y1 else (x1, 1, y1, 1)\n        elif direction == Direction.RIGHT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 > x1 else (x1, 1, y1, y1)\n        elif direction == Direction.LEFT:\n            x1, x2, y1, y2 = (x1, x2, y1, y2) if x2 < x1 else (x1, 0, y1, y1)\n        else:\n            return (-1, -1, -1, -1)\n        return (x1, x2, y1, y2)",
    "textractor/entities/value.py": "\"\"\"\nRepresents a single :class:`Value` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as KEY_VALUE_SET BlockTypes. These may be of KEY\nor VALUE type which is indicated by the EntityType attribute in the JSON response. \n\nThis class contains the associated metadata with the :class:`Value` entity including the entity ID, \nbounding box information, child words, associated key ID, page number, Page ID, confidence of detection\nand if it's a checkbox.\n\"\"\"\nfrom typing import List\nimport uuid\nfrom textractor.entities.word import Word\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import PRINTED, HANDWRITING, TextTypes\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.utils.text_utils import linearize_children\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\nclass Value(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Value` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float=0):\n        super().__init__(entity_id, bbox)\n        self._words: List[Word] = []\n        self._key_id = None\n        self._contains_checkbox = False\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None\n\n    @property\n    def key_id(self) -> str:\n        \"\"\"\n        Returns the associated Key ID for the :class:`Value` entity.\n\n        :return: Returns the associated KeyValue object ID.\n        :rtype: str\n        \"\"\"\n        return self._key_id\n\n    @key_id.setter\n    def key_id(self, key_id: str):\n        \"\"\"\n        Sets the :class:`KeyValue` ID to which this Value object is associated.\n\n        :param key_id: Unique identifier for the KeyValue entity to which this Value is associated.\n        :type key_id: str\n        \"\"\"\n        self._key_id = key_id\n\n    @property\n    def contains_checkbox(self) -> bool:\n        \"\"\"\n        Returns True if the value associated is a :class:`SelectionElement`.\n\n        :return: Returns True if the value associated is a checkbox/SelectionElement.\n        :rtype: bool\n        \"\"\"\n        return self._contains_checkbox\n\n    @contains_checkbox.setter\n    def contains_checkbox(self, checkbox_present: bool):\n        \"\"\"\n        Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\n\n        :param checkbox_present: True or False depending on checkbox presence.\n        :type checkbox_present: bool\n        \"\"\"\n        self._contains_checkbox = checkbox_present\n\n    @property\n    def page(self):\n        \"\"\"\n        :return: Returns the page number of the page the Value entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the Value entity.\n\n        :param page_num: Page number where the Value entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Value` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: str=TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError('text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants')\n        return EntityList([word for word in self.words if word.text_type == text_type])\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        if self.contains_checkbox:\n            text, words = self.children[0].get_text_and_words(config)\n        else:\n            text, words = linearize_children(self.words, config=config, no_new_lines=config.remove_new_lines_in_leaf_elements)\n        if config.add_prefixes_and_suffixes_in_text:\n            text = add_id_to_html_tag(config.value_prefix, self.id, config) + text + config.value_suffix\n        if config.add_prefixes_and_suffixes_as_words:\n            words = ([Word(str(uuid.uuid4()), self.bbox, add_id_to_html_tag(config.value_prefix, self.id, config), is_structure=True, is_clickable=bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected])] if config.value_prefix else []) + words + ([Word(str(uuid.uuid4()), self.bbox, config.value_suffix, is_structure=True, is_clickable=bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected])] if config.value_suffix else [])\n        for w in words:\n            w.value_id = str(self.id)\n            w.value_bbox = self.bbox\n        return (text, words)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Value entity.\n        :rtype: str\n        \"\"\"\n        repr_string = ''\n        if self.contains_checkbox:\n            repr_string += f'{self.children[0].__repr__()}'\n        else:\n            words = ' '.join([word.text for word in self.words])\n            repr_string += f'{words}'\n        return repr_string",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities in a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\nfrom textractor.data.constants import TextractType, TableFormat, AnalyzeExpenseLineItemFields, AnalyzeExpenseFields\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nlogger = logging.getLogger(__name__)\npresent_path = os.path.abspath(os.path.dirname(__file__))\nT = TypeVar('T')\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def __init__(self, objs=None):\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)\n\n    def visualize(self, with_text: bool=True, with_words: bool=True, with_confidence: bool=False, font_size_ratio: float=0.5) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        if len(self) > 0 and any([ent.__class__.__name__ == 'Document' for ent in self]):\n            return EntityList(self[0].pages).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and any([ent.__class__.__name__ == 'Page' for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (entity.__class__.__name__ == 'Word' or entity.__class__.__name__ == 'Line'):\n                    continue\n                if entity.__class__.__name__ == 'Page':\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(new_entity_list, expense_document)\n                elif entity.__class__.__name__ == 'ExpenseDocument':\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException('Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.')\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            except AttributeError:\n                pass\n        for page in list(entities_pagewise.keys()):\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(entities_pagewise[page], with_text, with_confidence, font_size_ratio)\n        images = [image.convert('RGB') for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if expense.type.text != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name:\n                        entity_list.append(expense)\n        return entity_list\n\n    def _get_text_string(self, with_page_number=False, with_confidence=False, trim=False, textract_type=TextractType.WORDS):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        if textract_type == TextractType.WORDS:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Word'], key=lambda x: x.page)\n        else:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Line'], key=lambda x: x.page)\n        current_page = -1\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f'--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}'\n                current_page = word.page\n            if trim:\n                result_value += f'{word.text.strip()}'\n            else:\n                result_value += f'{word.text}'\n            if with_confidence:\n                result_value += f', {word.confidence}'\n            result_value += os.linesep\n        return result_value\n\n    def _get_forms_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        result_value = ''\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and (not obj.contains_checkbox)]\n        else:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and obj.contains_checkbox]\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                result_value += tabulate(forms_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            csv_output = StringIO()\n            csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == 'Table':\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == 'TableCell':\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n        result_value = ''\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                result_value += tabulate(table_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                csv_output = StringIO()\n                csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = ''\n        queries = [obj for obj in self if obj.__class__.__name__ == 'Query']\n        for query in queries:\n            if query.result is not None:\n                result_value += f'{query.query} => {query.result.answer}{os.linesep}'\n            else:\n                result_value += f'{query.query} => {os.linesep}'\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = ''\n        expense_documents = [obj for obj in self if obj.__class__.__name__ == 'ExpenseDocument']\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f'Expense Document {i + 1}:{os.linesep}'\n            result_value += f'### Summary Fields:{os.linesep}'\n            result_value += f'{expense_document.summary_fields}{os.linesep}'\n            result_value += f'### Line Item Groups: {os.linesep}'\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f'{line_item_group}{os.linesep}'\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = ''\n        id_documents = [obj for obj in self if obj.__class__.__name__ == 'IdentityDocument']\n        for id_document in id_documents:\n            result_value += f'{id_document}{os.linesep}'\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        texts, words = ([], [])\n        separator = config.same_paragraph_separator if all([entity.__class__.__name__ == 'Word' for entity in self]) else config.layout_element_separator\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return (separator.join(texts), words)\n\ndef _convert_form_to_list(form_objects, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n    rows_list = list()\n    rows_list.append(['Key', 'Value'])\n    for field in form_objects:\n        t_key = ''\n        t_value = ''\n        if field.key:\n            text = ' '.join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + field.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({field.key.confidence:.1f})'\n        if field.value:\n            text = field.value.words if textract_type == TextractType.SELECTION_ELEMENT else ' '.join([word.text for word in field.value.words])\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += ' {' + field.value.bbox.__repr__() + '} '\n            if with_confidence:\n                t_value += f' ({field.value.confidence:.1f})'\n        rows_list.append([t_key, t_value])\n    return rows_list\n\ndef _convert_table_to_list(table_object, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.TABLES) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split('>')[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + cell.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({cell.confidence:.1f})'\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\ndef _draw_bbox(entities: List[Any], with_text: bool=False, with_confidence: bool=False, font_size_ratio: float=0.5):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception('Could not find an entity with an associated image!')\n    image = image.convert('RGBA')\n    overlay = Image.new('RGBA', image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, 'RGBA')\n    text_locations = {}\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == 'Table':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.title:\n                drw.rectangle((int(entity.title.bbox.x * width), int(entity.title.bbox.y * height), int((entity.title.bbox.x + entity.title.bbox.width) * width), int((entity.title.bbox.y + entity.title.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('red') + (120,), width=2)\n            for footer in entity.footers:\n                drw.rectangle((int(footer.bbox.x * width), int(footer.bbox.y * height), int((footer.bbox.x + footer.bbox.width) * width), int((footer.bbox.y + footer.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('cyan') + (120,), width=2)\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(zip(*[(c.bbox.x, c.bbox.y, c.bbox.x + c.bbox.width, c.bbox.y + c.bbox.height) for c in cell.siblings + [cell]]))\n                    min_x, min_y, max_x, max_y = (min(min_x), min(min_y), max(max_x), max(max_y))\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (cell.bbox.x, cell.bbox.y, cell.bbox.x + cell.bbox.width, cell.bbox.y + cell.bbox.height)\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb('blue') + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb('red') + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb('cyan') + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb('yellow') + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb('green') + (120,)\n                drw.rectangle((int(min_x * width), int(min_y * height), int(max_x * width), int(max_y * height)), outline=overlayer_data['color'], fill=fill_color, width=2)\n                for checkbox in cell.checkboxes:\n                    drw.rectangle((int(checkbox.bbox.x * width), int(checkbox.bbox.y * height), int((checkbox.bbox.x + checkbox.bbox.width) * width), int((checkbox.bbox.y + checkbox.bbox.height) * height)), outline=ImageColor.getrgb('lightgreen') if checkbox.is_selected() else ImageColor.getrgb('indianred'))\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == 'Query':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableTitle':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableFooter':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseField':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords_value'], outline=overlayer_data['color_value'], width=2)\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(xy=overlayer_data['coords_key'], outline=overlayer_data['color_key'], width=2)\n                drw.line([((b1.x + b1.width / 2) * width, (b1.y + b1.height / 2) * height), ((b2.x + b2.width / 2) * width, (b2.y + b2.height / 2) * height)], fill=overlayer_data['color_key'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseDocument':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            for coord, text in zip(overlayer_data['coords_list'], overlayer_data['coords_list']):\n                drw.rectangle(xy=coord, outline=overlayer_data['color_expense_group'], width=2)\n        elif entity.__class__.__name__.startswith('Layout'):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=4)\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.__class__.__name__ == 'KeyValue':\n                drw.rectangle(xy=overlayer_data['value_bbox'], outline=overlayer_data['color_value'], width=2)\n                b1 = overlayer_data['value_bbox']\n                b2 = overlayer_data['coords']\n                drw.line([((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2), ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2)], fill=overlayer_data['color_value'], width=1)\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == 'Word':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'KeyValue':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(int(0.03 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color'])\n                final_txt = overlayer_data['value_text']\n                bbox_height = overlayer_data['value_bbox'][3] - overlayer_data['value_bbox'][1]\n                text_height = min(int(0.01 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['value_conf'])[:4] + ')'\n                drw.text((overlayer_data['value_bbox'][0], overlayer_data['value_bbox'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color_value'])\n            elif entity.__class__.__name__ == 'ExpenseField':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = overlayer_data['text']\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if entity.key is not None:\n                    x = overlayer_data['coords_key'][0] + 0.3 * (overlayer_data['coords_key'][2] - overlayer_data['coords_key'][0])\n                    y = overlayer_data['coords_key'][1] - text_height - 1\n                else:\n                    x = int(overlayer_data['coords'][0] + 0.3 * (overlayer_data['coords'][2] - overlayer_data['coords'][0]))\n                    y = overlayer_data['coords'][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[x, y] != final_txt:\n                    y = y - text_height - 1\n                text_locations[x, y] = final_txt\n                drw.text((x, y), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'ExpenseDocument':\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(overlayer_data['coords_list'], overlayer_data['text_list']):\n                    drw.text((coord[0], coord[3]), text, font=fnt, fill=overlayer_data['color_expense_group'])\n            elif entity.__class__.__name__ == 'Query':\n                if entity.result is None:\n                    continue\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n                final_txt = entity.query + ' ' + overlayer_data['text']\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(entity.result.confidence)[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__.startswith('Layout'):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (bbox.x * width, bbox.y * height, bbox.width * width, bbox.height * height)\n    data['coords'] = [x, y, x + w, y + h]\n    data['confidence'] = entity.confidence if entity.__class__.__name__ not in ['Table', 'ExpenseField', 'ExpenseDocument', 'LineItemRow', 'LineItemGroup'] else ''\n    data['color'] = (0, 0, 0)\n    data['text_color'] = (0, 0, 0)\n    if entity.__class__.__name__ == 'Word':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('blue')\n    elif entity.__class__.__name__ == 'Line':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('lightgrey')\n        data['coords'] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == 'KeyValue':\n        data['text'] = entity.key.__repr__()\n        data['color'] = ImageColor.getrgb('brown')\n        data['value_text'] = entity.value.__repr__()\n        data['coords'] = [x - 2, y - 2, x + w + 2, y + h + 2]\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data['value_conf'] = entity.children[0].confidence\n        else:\n            value_bbox = entity.value.bbox\n            data['value_conf'] = entity.value.confidence\n        data['color_value'] = ImageColor.getrgb('orange')\n        x, y, w, h = (value_bbox.x * width - 2, value_bbox.y * height - 2, value_bbox.width * width + 2, value_bbox.height * height + 2)\n        data['value_bbox'] = [x, y, x + w, y + h]\n    elif entity.__class__.__name__ == 'Table':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableTitle':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableFooter':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableCell':\n        data['color'] = ImageColor.getrgb('skyblue')\n        data['text'] = entity.__repr__().split('>')[-1][1:]\n    elif entity.__class__.__name__ == 'QueryResult':\n        data['color'] = ImageColor.getrgb('mediumturquoise')\n        data['text'] = entity.answer\n    elif entity.__class__.__name__ == 'Signature':\n        data['color'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'ExpenseField':\n        data['text'] = entity.type.text\n        data['text_color'] = ImageColor.getrgb('brown')\n        data['coords'] = [x - 5, y - 5, x + w + 5, y + h + 5]\n        if entity.key:\n            data['color_key'] = ImageColor.getrgb('brown')\n            data['coords_key'] = (entity.key.bbox.x * width - 3, entity.key.bbox.y * height - 3, (entity.key.bbox.x + entity.key.bbox.width) * width + 3, (entity.key.bbox.y + entity.key.bbox.height) * height + 3)\n        data['color_value'] = ImageColor.getrgb('orange')\n        data['coords_value'] = (entity.value.bbox.x * width - 3, entity.value.bbox.y * height - 3, (entity.value.bbox.x + entity.value.bbox.width) * width + 3, (entity.value.bbox.y + entity.value.bbox.height) * height + 3)\n    elif entity.__class__.__name__ == 'Expense':\n        data['text'] = entity.text\n        data['coords'] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == 'ExpenseDocument':\n        data['color'] = ImageColor.getrgb('beige')\n        data['coords_list'] = []\n        data['text_list'] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data['coords_list'].append((bbox.x * width - 5, bbox.y * height - 5, (bbox.x + bbox.width) * width + 3, (bbox.y + bbox.height) * height + 3))\n                data['text_list'].append(group)\n        data['color_expense_group'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'LineItemGroup':\n        data['color'] = ImageColor.getrgb('lightblue')\n        data['coords'] = [x - 10, y - 10, x + w + 10, y + h + 10]\n    elif entity.__class__.__name__ == 'LineItemRow':\n        data['color'] = ImageColor.getrgb('lightyellow')\n        data['coords'] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith('Layout'):\n        data['color'] = ImageColor.getrgb('teal')\n        data['text'] = f'{entity.layout_type} - {entity.reading_order}'\n    else:\n        pass\n    return data"
  }
}