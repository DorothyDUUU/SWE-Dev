{
  "dir_path": "/app/pytube",
  "package_name": "pytube",
  "sample_name": "pytube-test_helpers",
  "src_dir": "pytube/",
  "test_dir": "tests/",
  "test_file": "tests/test_helpers.py",
  "test_code": "import gzip\nimport io\nimport json\nimport os\nimport pytest\nfrom unittest import mock\n\nfrom pytube import helpers\nfrom pytube.exceptions import RegexMatchError\nfrom pytube.helpers import cache, create_mock_html_json, deprecated, setup_logger\nfrom pytube.helpers import target_directory, uniqueify\n\n\ndef test_regex_search_no_match():\n    with pytest.raises(RegexMatchError):\n        helpers.regex_search(\"^a$\", \"\", group=0)\n\n\ndef test_regex_search():\n    assert helpers.regex_search(\"^a$\", \"a\", group=0) == \"a\"\n\n\ndef test_safe_filename():\n    \"\"\"Unsafe characters get stripped from generated filename\"\"\"\n    assert helpers.safe_filename(\"abc1245$$\") == \"abc1245\"\n    assert helpers.safe_filename(\"abc##\") == \"abc\"\n\n\n@mock.patch(\"warnings.warn\")\ndef test_deprecated(warn):\n    @deprecated(\"oh no\")\n    def deprecated_function():\n        return None\n\n    deprecated_function()\n    warn.assert_called_with(\n        \"Call to deprecated function deprecated_function (oh no).\",\n        category=DeprecationWarning,\n        stacklevel=2,\n    )\n\n\ndef test_cache():\n    call_count = 0\n\n    @cache\n    def cached_func(stuff):\n        nonlocal call_count\n        call_count += 1\n        return stuff\n\n    cached_func(\"hi\")\n    cached_func(\"hi\")\n    cached_func(\"bye\")\n    cached_func(\"bye\")\n\n    assert call_count == 2\n\n\n@mock.patch(\"os.path.isabs\", return_value=False)\n@mock.patch(\"os.getcwd\", return_value=\"/cwd\")\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_relative_path(_, __, makedirs):  # noqa: PT019\n    assert target_directory(\"test\") == os.path.join(\"/cwd\", \"test\")\n    makedirs.assert_called()\n\n\n@mock.patch(\"os.path.isabs\", return_value=True)\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_absolute_path(_, makedirs):  # noqa: PT019\n    assert target_directory(\"/test\") == \"/test\"\n    makedirs.assert_called()\n\n\n@mock.patch(\"os.getcwd\", return_value=\"/cwd\")\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_no_path(_, makedirs):  # noqa: PT019\n    assert target_directory() == \"/cwd\"\n    makedirs.assert_called()\n\n\n@mock.patch(\"pytube.helpers.logging\")\ndef test_setup_logger(logging):\n    # Given\n    logger = logging.getLogger.return_value\n    # When\n    setup_logger(20)\n    # Then\n    logging.getLogger.assert_called_with(\"pytube\")\n    logger.addHandler.assert_called()\n    logger.setLevel.assert_called_with(20)\n\n\n@mock.patch('builtins.open', new_callable=mock.mock_open)\n@mock.patch('pytube.request.urlopen')\ndef test_create_mock_html_json(mock_url_open, mock_open):\n    video_id = '2lAe1cqCOXo'\n    gzip_html_filename = 'yt-video-%s-html.json.gz' % video_id\n\n    # Get the pytube directory in order to navigate to /tests/mocks\n    pytube_dir_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            os.path.pardir\n        )\n    )\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_html_filepath = os.path.join(pytube_mocks_path, gzip_html_filename)\n\n    # Mock the responses to YouTube\n    mock_url_open_object = mock.Mock()\n\n    # Order is:\n    # 1. watch_html -- must have jsurl match\n    # 2. embed html\n    # 3. watch html\n    # 4. raw vid info\n    mock_url_open_object.read.side_effect = [\n        (b'yt.setConfig({\"PLAYER_CONFIG\":{\"args\":[]}});ytInitialData = {};ytInitialPlayerResponse = {};'  # noqa: E501\n         b'\"jsUrl\":\"/s/player/13371337/player_ias.vflset/en_US/base.js\"'),\n        b'embed_html',\n        b'watch_html',\n        b'{\\\"responseContext\\\":{}}',\n    ]\n    mock_url_open.return_value = mock_url_open_object\n\n    # Generate a json with sample html json\n    result_data = create_mock_html_json(video_id)\n\n    # Assert that a write was only made once\n    mock_open.assert_called_once_with(gzip_html_filepath, 'wb')\n\n    # The result data should look like this:\n    gzip_file = io.BytesIO()\n    with gzip.GzipFile(\n        filename=gzip_html_filename,\n        fileobj=gzip_file,\n        mode='wb'\n    ) as f:\n        f.write(json.dumps(result_data).encode('utf-8'))\n    gzip_data = gzip_file.getvalue()\n\n    file_handle = mock_open.return_value.__enter__.return_value\n\n    # For some reason, write gets called multiple times, so we have to\n    #  concatenate all the write calls to get the full data before we compare\n    #  it to the BytesIO object value.\n    full_content = b''\n    for call in file_handle.write.call_args_list:\n        args, kwargs = call\n        full_content += b''.join(args)\n\n    # The file header includes time metadata, so *occasionally* a single\n    #  byte will be off at the very beginning. In theory, this difference\n    #  should only affect bytes 5-8 (or [4:8] because of zero-indexing),\n    #  but I've excluded the 10-byte metadata header altogether from the\n    #  check, just to be safe.\n    # Source: https://en.wikipedia.org/wiki/Gzip#File_format\n    assert gzip_data[10:] == full_content[10:]\n\n\ndef test_uniqueify():\n    non_unique_list = [1, 2, 3, 3, 4, 5]\n    expected = [1, 2, 3, 4, 5]\n    result = uniqueify(non_unique_list)\n    assert result == expected\n",
  "GT_file_code": {
    "pytube/helpers.py": "\"\"\"Various helper functions implemented by pytube.\"\"\"\nimport functools\nimport gzip\nimport json\nimport logging\nimport os\nimport re\nimport warnings\nfrom typing import Any, Callable, Dict, List, Optional, TypeVar\nfrom urllib import request\n\nfrom pytube.exceptions import RegexMatchError\n\nlogger = logging.getLogger(__name__)\n\n\nclass DeferredGeneratorList:\n    \"\"\"A wrapper class for deferring list generation.\n\n    Pytube has some continuation generators that create web calls, which means\n    that any time a full list is requested, all of those web calls must be\n    made at once, which could lead to slowdowns. This will allow individual\n    elements to be queried, so that slowdowns only happen as necessary. For\n    example, you can iterate over elements in the list without accessing them\n    all simultaneously. This should allow for speed improvements for playlist\n    and channel interactions.\n    \"\"\"\n    def __init__(self, generator):\n        \"\"\"Construct a :class:`DeferredGeneratorList <DeferredGeneratorList>`.\n\n        :param generator generator:\n            The deferrable generator to create a wrapper for.\n        :param func func:\n            (Optional) A function to call on the generator items to produce the list.\n        \"\"\"\n        self.gen = generator\n        self._elements = []\n\n    def __eq__(self, other):\n        \"\"\"We want to mimic list behavior for comparison.\"\"\"\n        return list(self) == other\n\n    def __getitem__(self, key) -> Any:\n        \"\"\"Only generate items as they're asked for.\"\"\"\n        # We only allow querying with indexes.\n        if not isinstance(key, (int, slice)):\n            raise TypeError('Key must be either a slice or int.')\n\n        # Convert int keys to slice\n        key_slice = key\n        if isinstance(key, int):\n            key_slice = slice(key, key + 1, 1)\n\n        # Generate all elements up to the final item\n        while len(self._elements) < key_slice.stop:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                # If we can't find enough elements for the slice, raise an IndexError\n                raise IndexError\n            else:\n                self._elements.append(next_item)\n\n        return self._elements[key]\n\n    def __iter__(self):\n        \"\"\"Custom iterator for dynamically generated list.\"\"\"\n        iter_index = 0\n        while True:\n            try:\n                curr_item = self[iter_index]\n            except IndexError:\n                return\n            else:\n                yield curr_item\n                iter_index += 1\n\n    def __next__(self) -> Any:\n        \"\"\"Fetch next element in iterator.\"\"\"\n        try:\n            curr_element = self[self.iter_index]\n        except IndexError:\n            raise StopIteration\n        self.iter_index += 1\n        return curr_element  # noqa:R504\n\n    def __len__(self) -> int:\n        \"\"\"Return length of list of all items.\"\"\"\n        self.generate_all()\n        return len(self._elements)\n\n    def __repr__(self) -> str:\n        \"\"\"String representation of all items.\"\"\"\n        self.generate_all()\n        return str(self._elements)\n\n    def __reversed__(self):\n        self.generate_all()\n        return self._elements[::-1]\n\n    def generate_all(self):\n        \"\"\"Generate all items.\"\"\"\n        while True:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                break\n            else:\n                self._elements.append(next_item)\n\n\ndef regex_search(pattern: str, string: str, group: int) -> str:\n    \"\"\"Shortcut method to search a string for a given pattern.\n\n    :param str pattern:\n        A regular expression pattern.\n    :param str string:\n        A target string to search.\n    :param int group:\n        Index of group to return.\n    :rtype:\n        str or tuple\n    :returns:\n        Substring pattern matches.\n    \"\"\"\n    regex = re.compile(pattern)\n    results = regex.search(string)\n    if not results:\n        raise RegexMatchError(caller=\"regex_search\", pattern=pattern)\n\n    logger.debug(\"matched regex search: %s\", pattern)\n\n    return results.group(group)\n\n\ndef safe_filename(s: str, max_length: int = 255) -> str:\n    \"\"\"Sanitize a string making it safe to use as a filename.\n\n    This function was based off the limitations outlined here:\n    https://en.wikipedia.org/wiki/Filename.\n\n    :param str s:\n        A string to make safe for use as a file name.\n    :param int max_length:\n        The maximum filename character length.\n    :rtype: str\n    :returns:\n        A sanitized string.\n    \"\"\"\n    # Characters in range 0-31 (0x00-0x1F) are not allowed in ntfs filenames.\n    ntfs_characters = [chr(i) for i in range(0, 31)]\n    characters = [\n        r'\"',\n        r\"\\#\",\n        r\"\\$\",\n        r\"\\%\",\n        r\"'\",\n        r\"\\*\",\n        r\"\\,\",\n        r\"\\.\",\n        r\"\\/\",\n        r\"\\:\",\n        r'\"',\n        r\"\\;\",\n        r\"\\<\",\n        r\"\\>\",\n        r\"\\?\",\n        r\"\\\\\",\n        r\"\\^\",\n        r\"\\|\",\n        r\"\\~\",\n        r\"\\\\\\\\\",\n    ]\n    pattern = \"|\".join(ntfs_characters + characters)\n    regex = re.compile(pattern, re.UNICODE)\n    filename = regex.sub(\"\", s)\n    return filename[:max_length].rsplit(\" \", 0)[0]\n\n\ndef setup_logger(level: int = logging.ERROR, log_filename: Optional[str] = None) -> None:\n    \"\"\"Create a configured instance of logger.\n\n    :param int level:\n        Describe the severity level of the logs to handle.\n    \"\"\"\n    fmt = \"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\"\n    date_fmt = \"%H:%M:%S\"\n    formatter = logging.Formatter(fmt, datefmt=date_fmt)\n\n    # https://github.com/pytube/pytube/issues/163\n    logger = logging.getLogger(\"pytube\")\n    logger.setLevel(level)\n\n    stream_handler = logging.StreamHandler()\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n\n    if log_filename is not None:\n        file_handler = logging.FileHandler(log_filename)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n\nGenericType = TypeVar(\"GenericType\")\n\n\ndef cache(func: Callable[..., GenericType]) -> GenericType:\n    \"\"\" mypy compatible annotation wrapper for lru_cache\"\"\"\n    return functools.lru_cache()(func)  # type: ignore\n\n\ndef deprecated(reason: str) -> Callable:\n    \"\"\"\n    This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n    \"\"\"\n\n    def decorator(func1):\n        message = \"Call to deprecated function {name} ({reason}).\"\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            warnings.warn(\n                message.format(name=func1.__name__, reason=reason),\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            warnings.simplefilter(\"default\", DeprecationWarning)\n            return func1(*args, **kwargs)\n\n        return new_func1\n\n    return decorator\n\n\ndef target_directory(output_path: Optional[str] = None) -> str:\n    \"\"\"\n    Function for determining target directory of a download.\n    Returns an absolute path (if relative one given) or the current\n    path (if none given). Makes directory if it does not exist.\n\n    :type output_path: str\n        :rtype: str\n    :returns:\n        An absolute directory path as a string.\n    \"\"\"\n    if output_path:\n        if not os.path.isabs(output_path):\n            output_path = os.path.join(os.getcwd(), output_path)\n    else:\n        output_path = os.getcwd()\n    os.makedirs(output_path, exist_ok=True)\n    return output_path\n\n\ndef install_proxy(proxy_handler: Dict[str, str]) -> None:\n    proxy_support = request.ProxyHandler(proxy_handler)\n    opener = request.build_opener(proxy_support)\n    request.install_opener(opener)\n\n\ndef uniqueify(duped_list: List) -> List:\n    \"\"\"Remove duplicate items from a list, while maintaining list order.\n\n    :param List duped_list\n        List to remove duplicates from\n\n    :return List result\n        De-duplicated list\n    \"\"\"\n    seen: Dict[Any, bool] = {}\n    result = []\n    for item in duped_list:\n        if item in seen:\n            continue\n        seen[item] = True\n        result.append(item)\n    return result\n\n\ndef generate_all_html_json_mocks():\n    \"\"\"Regenerate the video mock json files for all current test videos.\n\n    This should automatically output to the test/mocks directory.\n    \"\"\"\n    test_vid_ids = [\n        '2lAe1cqCOXo',\n        '5YceQ8YqYMc',\n        'irauhITDrsE',\n        'm8uHb5jIGN8',\n        'QRS8MkLhQmM',\n        'WXxV9g7lsFE'\n    ]\n    for vid_id in test_vid_ids:\n        create_mock_html_json(vid_id)\n\n\ndef create_mock_html_json(vid_id) -> Dict[str, Any]:\n    \"\"\"Generate a json.gz file with sample html responses.\n\n    :param str vid_id\n        YouTube video id\n\n    :return dict data\n        Dict used to generate the json.gz file\n    \"\"\"\n    from pytube import YouTube\n    gzip_filename = 'yt-video-%s-html.json.gz' % vid_id\n\n    # Get the pytube directory in order to navigate to /tests/mocks\n    pytube_dir_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            os.path.pardir\n        )\n    )\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_filepath = os.path.join(pytube_mocks_path, gzip_filename)\n\n    yt = YouTube(f'https://www.youtube.com/watch?v={vid_id}')\n    html_data = {\n        'url': yt.watch_url,\n        'js': yt.js,\n        'embed_html': yt.embed_html,\n        'watch_html': yt.watch_html,\n        'vid_info': yt.vid_info\n    }\n\n    logger.info(f'Outputing json.gz file to {gzip_filepath}')\n    with gzip.open(gzip_filepath, 'wb') as f:\n        f.write(json.dumps(html_data).encode('utf-8'))\n\n    return html_data\n",
    "pytube/__main__.py": "\"\"\"\nThis module implements the core developer interface for pytube.\n\nThe problem domain of the :class:`YouTube <YouTube> class focuses almost\nexclusively on the developer interface. Pytube offloads the heavy lifting to\nsmaller peripheral modules and functions.\n\n\"\"\"\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional\n\nimport pytube\nimport pytube.exceptions as exceptions\nfrom pytube import extract, request\nfrom pytube import Stream, StreamQuery\nfrom pytube.helpers import install_proxy\nfrom pytube.innertube import InnerTube\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.monostate import Monostate\n\nlogger = logging.getLogger(__name__)\n\n\nclass YouTube:\n    \"\"\"Core developer interface for pytube.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        on_progress_callback: Optional[Callable[[Any, bytes, int], None]] = None,\n        on_complete_callback: Optional[Callable[[Any, Optional[str]], None]] = None,\n        proxies: Dict[str, str] = None,\n        use_oauth: bool = False,\n        allow_oauth_cache: bool = True\n    ):\n        \"\"\"Construct a :class:`YouTube <YouTube>`.\n\n        :param str url:\n            A valid YouTube watch URL.\n        :param func on_progress_callback:\n            (Optional) User defined callback function for stream download\n            progress events.\n        :param func on_complete_callback:\n            (Optional) User defined callback function for stream download\n            complete events.\n        :param dict proxies:\n            (Optional) A dict mapping protocol to proxy address which will be used by pytube.\n        :param bool use_oauth:\n            (Optional) Prompt the user to authenticate to YouTube.\n            If allow_oauth_cache is set to True, the user should only be prompted once.\n        :param bool allow_oauth_cache:\n            (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\n            These tokens are only generated if use_oauth is set to True as well.\n        \"\"\"\n        self._js: Optional[str] = None  # js fetched by js_url\n        self._js_url: Optional[str] = None  # the url to the js, parsed from watch html\n\n        self._vid_info: Optional[Dict] = None  # content fetched from innertube/player\n\n        self._watch_html: Optional[str] = None  # the html of /watch?v=<video_id>\n        self._embed_html: Optional[str] = None\n        self._player_config_args: Optional[Dict] = None  # inline js in the html containing\n        self._age_restricted: Optional[bool] = None\n\n        self._fmt_streams: Optional[List[Stream]] = None\n\n        self._initial_data = None\n        self._metadata: Optional[YouTubeMetadata] = None\n\n        # video_id part of /watch?v=<video_id>\n        self.video_id = extract.video_id(url)\n\n        self.watch_url = f\"https://youtube.com/watch?v={self.video_id}\"\n        self.embed_url = f\"https://www.youtube.com/embed/{self.video_id}\"\n\n        # Shared between all instances of `Stream` (Borg pattern).\n        self.stream_monostate = Monostate(\n            on_progress=on_progress_callback, on_complete=on_complete_callback\n        )\n\n        if proxies:\n            install_proxy(proxies)\n\n        self._author = None\n        self._title = None\n        self._publish_date = None\n\n        self.use_oauth = use_oauth\n        self.allow_oauth_cache = allow_oauth_cache\n\n    def __repr__(self):\n        return f'<pytube.__main__.YouTube object: videoId={self.video_id}>'\n\n    def __eq__(self, o: object) -> bool:\n        # Compare types and urls, if they're same return true, else return false.\n        return type(o) == type(self) and o.watch_url == self.watch_url\n\n    @property\n    def watch_html(self):\n        if self._watch_html:\n            return self._watch_html\n        self._watch_html = request.get(url=self.watch_url)\n        return self._watch_html\n\n    @property\n    def embed_html(self):\n        if self._embed_html:\n            return self._embed_html\n        self._embed_html = request.get(url=self.embed_url)\n        return self._embed_html\n\n    @property\n    def age_restricted(self):\n        if self._age_restricted:\n            return self._age_restricted\n        self._age_restricted = extract.is_age_restricted(self.watch_html)\n        return self._age_restricted\n\n    @property\n    def js_url(self):\n        if self._js_url:\n            return self._js_url\n\n        if self.age_restricted:\n            self._js_url = extract.js_url(self.embed_html)\n        else:\n            self._js_url = extract.js_url(self.watch_html)\n\n        return self._js_url\n\n    @property\n    def js(self):\n        if self._js:\n            return self._js\n\n        # If the js_url doesn't match the cached url, fetch the new js and update\n        #  the cache; otherwise, load the cache.\n        if pytube.__js_url__ != self.js_url:\n            self._js = request.get(self.js_url)\n            pytube.__js__ = self._js\n            pytube.__js_url__ = self.js_url\n        else:\n            self._js = pytube.__js__\n\n        return self._js\n\n    @property\n    def initial_data(self):\n        if self._initial_data:\n            return self._initial_data\n        self._initial_data = extract.initial_data(self.watch_html)\n        return self._initial_data\n\n    @property\n    def streaming_data(self):\n        \"\"\"Return streamingData from video info.\"\"\"\n        if 'streamingData' in self.vid_info:\n            return self.vid_info['streamingData']\n        else:\n            self.bypass_age_gate()\n            return self.vid_info['streamingData']\n\n    @property\n    def fmt_streams(self):\n        \"\"\"Returns a list of streams if they have been initialized.\n\n        If the streams have not been initialized, finds all relevant\n        streams and initializes them.\n        \"\"\"\n        self.check_availability()\n        if self._fmt_streams:\n            return self._fmt_streams\n\n        self._fmt_streams = []\n\n        stream_manifest = extract.apply_descrambler(self.streaming_data)\n\n        # If the cached js doesn't work, try fetching a new js file\n        # https://github.com/pytube/pytube/issues/1054\n        try:\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        except exceptions.ExtractError:\n            # To force an update to the js file, we clear the cache and retry\n            self._js = None\n            self._js_url = None\n            pytube.__js__ = None\n            pytube.__js_url__ = None\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n\n        # build instances of :class:`Stream <Stream>`\n        # Initialize stream objects\n        for stream in stream_manifest:\n            video = Stream(\n                stream=stream,\n                monostate=self.stream_monostate,\n            )\n            self._fmt_streams.append(video)\n\n        self.stream_monostate.title = self.title\n        self.stream_monostate.duration = self.length\n\n        return self._fmt_streams\n\n    def check_availability(self):\n        \"\"\"Check whether the video is available.\n\n        Raises different exceptions based on why the video is unavailable,\n        otherwise does nothing.\n        \"\"\"\n        status, messages = extract.playability_status(self.watch_html)\n\n        for reason in messages:\n            if status == 'UNPLAYABLE':\n                if reason == (\n                    'Join this channel to get access to members-only content '\n                    'like this video, and other exclusive perks.'\n                ):\n                    raise exceptions.MembersOnly(video_id=self.video_id)\n                elif reason == 'This live stream recording is not available.':\n                    raise exceptions.RecordingUnavailable(video_id=self.video_id)\n                else:\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LOGIN_REQUIRED':\n                if reason == (\n                    'This is a private video. '\n                    'Please sign in to verify that you may see it.'\n                ):\n                    raise exceptions.VideoPrivate(video_id=self.video_id)\n            elif status == 'ERROR':\n                if reason == 'Video unavailable':\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LIVE_STREAM':\n                raise exceptions.LiveStreamError(video_id=self.video_id)\n\n    @property\n    def vid_info(self):\n        \"\"\"Parse the raw vid info and return the parsed result.\n\n        :rtype: Dict[Any, Any]\n        \"\"\"\n        if self._vid_info:\n            return self._vid_info\n\n        innertube = InnerTube(use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n\n        innertube_response = innertube.player(self.video_id)\n        self._vid_info = innertube_response\n        return self._vid_info\n\n    def bypass_age_gate(self):\n        \"\"\"Attempt to update the vid_info by bypassing the age gate.\"\"\"\n        innertube = InnerTube(\n            client='ANDROID_EMBED',\n            use_oauth=self.use_oauth,\n            allow_cache=self.allow_oauth_cache\n        )\n        innertube_response = innertube.player(self.video_id)\n\n        playability_status = innertube_response['playabilityStatus'].get('status', None)\n\n        # If we still can't access the video, raise an exception\n        # (tier 3 age restriction)\n        if playability_status == 'UNPLAYABLE':\n            raise exceptions.AgeRestrictedError(self.video_id)\n\n        self._vid_info = innertube_response\n\n    @property\n    def caption_tracks(self) -> List[pytube.Caption]:\n        \"\"\"Get a list of :class:`Caption <Caption>`.\n\n        :rtype: List[Caption]\n        \"\"\"\n        raw_tracks = (\n            self.vid_info.get(\"captions\", {})\n            .get(\"playerCaptionsTracklistRenderer\", {})\n            .get(\"captionTracks\", [])\n        )\n        return [pytube.Caption(track) for track in raw_tracks]\n\n    @property\n    def captions(self) -> pytube.CaptionQuery:\n        \"\"\"Interface to query caption tracks.\n\n        :rtype: :class:`CaptionQuery <CaptionQuery>`.\n        \"\"\"\n        return pytube.CaptionQuery(self.caption_tracks)\n\n    @property\n    def streams(self) -> StreamQuery:\n        \"\"\"Interface to query both adaptive (DASH) and progressive streams.\n\n        :rtype: :class:`StreamQuery <StreamQuery>`.\n        \"\"\"\n        self.check_availability()\n        return StreamQuery(self.fmt_streams)\n\n    @property\n    def thumbnail_url(self) -> str:\n        \"\"\"Get the thumbnail url image.\n\n        :rtype: str\n        \"\"\"\n        thumbnail_details = (\n            self.vid_info.get(\"videoDetails\", {})\n            .get(\"thumbnail\", {})\n            .get(\"thumbnails\")\n        )\n        if thumbnail_details:\n            thumbnail_details = thumbnail_details[-1]  # last item has max size\n            return thumbnail_details[\"url\"]\n\n        return f\"https://img.youtube.com/vi/{self.video_id}/maxresdefault.jpg\"\n\n    @property\n    def publish_date(self):\n        \"\"\"Get the publish date.\n\n        :rtype: datetime\n        \"\"\"\n        if self._publish_date:\n            return self._publish_date\n        self._publish_date = extract.publish_date(self.watch_html)\n        return self._publish_date\n\n    @publish_date.setter\n    def publish_date(self, value):\n        \"\"\"Sets the publish date.\"\"\"\n        self._publish_date = value\n\n    @property\n    def title(self) -> str:\n        \"\"\"Get the video title.\n\n        :rtype: str\n        \"\"\"\n        if self._title:\n            return self._title\n\n        try:\n            self._title = self.vid_info['videoDetails']['title']\n        except KeyError:\n            # Check_availability will raise the correct exception in most cases\n            #  if it doesn't, ask for a report.\n            self.check_availability()\n            raise exceptions.PytubeError(\n                (\n                    f'Exception while accessing title of {self.watch_url}. '\n                    'Please file a bug report at https://github.com/pytube/pytube'\n                )\n            )\n\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Sets the title value.\"\"\"\n        self._title = value\n\n    @property\n    def description(self) -> str:\n        \"\"\"Get the video description.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get(\"videoDetails\", {}).get(\"shortDescription\")\n\n    @property\n    def rating(self) -> float:\n        \"\"\"Get the video average rating.\n\n        :rtype: float\n\n        \"\"\"\n        return self.vid_info.get(\"videoDetails\", {}).get(\"averageRating\")\n\n    @property\n    def length(self) -> int:\n        \"\"\"Get the video length in seconds.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('lengthSeconds'))\n\n    @property\n    def views(self) -> int:\n        \"\"\"Get the number of the times the video has been viewed.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get(\"videoDetails\", {}).get(\"viewCount\"))\n\n    @property\n    def author(self) -> str:\n        \"\"\"Get the video author.\n        :rtype: str\n        \"\"\"\n        if self._author:\n            return self._author\n        self._author = self.vid_info.get(\"videoDetails\", {}).get(\n            \"author\", \"unknown\"\n        )\n        return self._author\n\n    @author.setter\n    def author(self, value):\n        \"\"\"Set the video author.\"\"\"\n        self._author = value\n\n    @property\n    def keywords(self) -> List[str]:\n        \"\"\"Get the video keywords.\n\n        :rtype: List[str]\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('keywords', [])\n\n    @property\n    def channel_id(self) -> str:\n        \"\"\"Get the video poster's channel id.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('channelId', None)\n\n    @property\n    def channel_url(self) -> str:\n        \"\"\"Construct the channel url for the video's poster from the channel id.\n\n        :rtype: str\n        \"\"\"\n        return f'https://www.youtube.com/channel/{self.channel_id}'\n\n    @property\n    def metadata(self) -> Optional[YouTubeMetadata]:\n        \"\"\"Get the metadata for the video.\n\n        :rtype: YouTubeMetadata\n        \"\"\"\n        if self._metadata:\n            return self._metadata\n        else:\n            self._metadata = extract.metadata(self.initial_data)\n            return self._metadata\n\n    def register_on_progress_callback(self, func: Callable[[Any, bytes, int], None]):\n        \"\"\"Register a download progress callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream``, ``chunk``,\n             and ``bytes_remaining`` as parameters.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_progress = func\n\n    def register_on_complete_callback(self, func: Callable[[Any, Optional[str]], None]):\n        \"\"\"Register a download complete callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream`` and  ``file_path``.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_complete = func\n\n    @staticmethod\n    def from_id(video_id: str) -> \"YouTube\":\n        \"\"\"Construct a :class:`YouTube <YouTube>` object from a video id.\n\n        :param str video_id:\n            The video id of the YouTube video.\n\n        :rtype: :class:`YouTube <YouTube>`\n        \n        \"\"\"\n        return YouTube(f\"https://www.youtube.com/watch?v={video_id}\")\n",
    "pytube/exceptions.py": "\"\"\"Library specific exception definitions.\"\"\"\nfrom typing import Pattern, Union\n\n\nclass PytubeError(Exception):\n    \"\"\"Base pytube exception that all others inherit.\n\n    This is done to not pollute the built-in exceptions, which *could* result\n    in unintended errors being unexpectedly and incorrectly handled within\n    implementers code.\n    \"\"\"\n\n\nclass MaxRetriesExceeded(PytubeError):\n    \"\"\"Maximum number of retries exceeded.\"\"\"\n\n\nclass HTMLParseError(PytubeError):\n    \"\"\"HTML could not be parsed\"\"\"\n\n\nclass ExtractError(PytubeError):\n    \"\"\"Data extraction based exception.\"\"\"\n\n\nclass RegexMatchError(ExtractError):\n    \"\"\"Regex pattern did not return any matches.\"\"\"\n\n    def __init__(self, caller: str, pattern: Union[str, Pattern]):\n        \"\"\"\n        :param str caller:\n            Calling function\n        :param str pattern:\n            Pattern that failed to match\n        \"\"\"\n        super().__init__(f\"{caller}: could not find match for {pattern}\")\n        self.caller = caller\n        self.pattern = pattern\n\n\nclass VideoUnavailable(PytubeError):\n    \"\"\"Base video unavailable error.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.error_string)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is unavailable'\n\n\nclass AgeRestrictedError(VideoUnavailable):\n    \"\"\"Video is age restricted, and cannot be accessed without OAuth.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f\"{self.video_id} is age restricted, and can't be accessed without logging in.\"\n\n\nclass LiveStreamError(VideoUnavailable):\n    \"\"\"Video is a live stream.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is streaming live and cannot be loaded'\n\n\nclass VideoPrivate(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a private video'\n\n\nclass RecordingUnavailable(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} does not have a live stream recording available'\n\n\nclass MembersOnly(VideoUnavailable):\n    \"\"\"Video is members-only.\n\n    YouTube has special videos that are only viewable to users who have\n    subscribed to a content creator.\n    ref: https://support.google.com/youtube/answer/7544492?hl=en\n    \"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a members-only video'\n\n\nclass VideoRegionBlocked(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is not available in your region'\n"
  },
  "GT_src_dict": {
    "pytube/helpers.py": {
      "regex_search": {
        "code": "def regex_search(pattern: str, string: str, group: int) -> str:\n    \"\"\"Shortcut method to search a string for a regular expression pattern and return a specific group match.\n\n:param str pattern: A regular expression pattern used to search the target string.\n:param str string: The target string where the regex search will be performed.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex results.\n\nRaises a RegexMatchError if no match is found, indicating that the pattern did not match the string. This function depends on the `re` module for compiling and searching the regex pattern, and it utilizes a logger to output debug information about successful matches. The `RegexMatchError` is defined in the `pytube.exceptions` module, providing a way to handle regex-related errors within the Pytube package's operations.\"\"\"\n    'Shortcut method to search a string for a given pattern.\\n\\n    :param str pattern:\\n        A regular expression pattern.\\n    :param str string:\\n        A target string to search.\\n    :param int group:\\n        Index of group to return.\\n    :rtype:\\n        str or tuple\\n    :returns:\\n        Substring pattern matches.\\n    '\n    regex = re.compile(pattern)\n    results = regex.search(string)\n    if not results:\n        raise RegexMatchError(caller='regex_search', pattern=pattern)\n    logger.debug('matched regex search: %s', pattern)\n    return results.group(group)",
        "docstring": "Shortcut method to search a string for a regular expression pattern and return a specific group match.\n\n:param str pattern: A regular expression pattern used to search the target string.\n:param str string: The target string where the regex search will be performed.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex results.\n\nRaises a RegexMatchError if no match is found, indicating that the pattern did not match the string. This function depends on the `re` module for compiling and searching the regex pattern, and it utilizes a logger to output debug information about successful matches. The `RegexMatchError` is defined in the `pytube.exceptions` module, providing a way to handle regex-related errors within the Pytube package's operations.",
        "signature": "def regex_search(pattern: str, string: str, group: int) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "safe_filename": {
        "code": "def safe_filename(s: str, max_length: int=255) -> str:\n    \"\"\"Sanitize a string to make it safe for use as a filename by removing invalid characters based on NTFS limitations.\n\nParameters:\n- s (str): The input string to sanitize for filename use.\n- max_length (int, optional): The maximum allowable length of the sanitized filename (default is 255 characters).\n\nReturns:\n- str: A sanitized filename, truncated to `max_length`, ensuring no invalid characters are included.\n\nDependencies:\nThis function utilizes the `re` module for regular expression operations. It defines a list of `ntfs_characters` representing invalid bytes for NTFS filenames (0-31) and a list of additional invalid filename characters. The constructed regex pattern identifies these characters, which are then removed from the input string `s`.\n\nImportant Side Effects:\nNone. The function purely returns a modified version of the input string without modifying the input itself.\"\"\"\n    'Sanitize a string making it safe to use as a filename.\\n\\n    This function was based off the limitations outlined here:\\n    https://en.wikipedia.org/wiki/Filename.\\n\\n    :param str s:\\n        A string to make safe for use as a file name.\\n    :param int max_length:\\n        The maximum filename character length.\\n    :rtype: str\\n    :returns:\\n        A sanitized string.\\n    '\n    ntfs_characters = [chr(i) for i in range(0, 31)]\n    characters = ['\"', '\\\\#', '\\\\$', '\\\\%', \"'\", '\\\\*', '\\\\,', '\\\\.', '\\\\/', '\\\\:', '\"', '\\\\;', '\\\\<', '\\\\>', '\\\\?', '\\\\\\\\', '\\\\^', '\\\\|', '\\\\~', '\\\\\\\\\\\\\\\\']\n    pattern = '|'.join(ntfs_characters + characters)\n    regex = re.compile(pattern, re.UNICODE)\n    filename = regex.sub('', s)\n    return filename[:max_length].rsplit(' ', 0)[0]",
        "docstring": "Sanitize a string to make it safe for use as a filename by removing invalid characters based on NTFS limitations.\n\nParameters:\n- s (str): The input string to sanitize for filename use.\n- max_length (int, optional): The maximum allowable length of the sanitized filename (default is 255 characters).\n\nReturns:\n- str: A sanitized filename, truncated to `max_length`, ensuring no invalid characters are included.\n\nDependencies:\nThis function utilizes the `re` module for regular expression operations. It defines a list of `ntfs_characters` representing invalid bytes for NTFS filenames (0-31) and a list of additional invalid filename characters. The constructed regex pattern identifies these characters, which are then removed from the input string `s`.\n\nImportant Side Effects:\nNone. The function purely returns a modified version of the input string without modifying the input itself.",
        "signature": "def safe_filename(s: str, max_length: int=255) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "setup_logger": {
        "code": "def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:\n    \"\"\"Create and configure a logger instance for the pytube module.\n\nThis function initializes a logger instance with specified logging severity and an optional log file. It formats log messages to include timestamps, log levels, and module names for better traceability. The default log level is set to ERROR, and if a log filename is provided, it additionally writes logs to that file.\n\nParameters:\n- level (int): The logging severity level (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL), controlling which log messages are recorded. Default is logging.ERROR.\n- log_filename (Optional[str]): An optional parameter for specifying a file to which logs should be written. If provided, a file handler is added to the logger.\n\nReturns:\n- None: This function does not return a value, but it configures the logger for use throughout the module.\n\nDependencies:\n- Uses `logging` from the Python standard library to handle logging functionalities.\n- The `logger` variable, created via `logging.getLogger(\"pytube\")`, is specific to the pytube module, allowing for targeted logging.\"\"\"\n    'Create a configured instance of logger.\\n\\n    :param int level:\\n        Describe the severity level of the logs to handle.\\n    '\n    fmt = '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n    date_fmt = '%H:%M:%S'\n    formatter = logging.Formatter(fmt, datefmt=date_fmt)\n    logger = logging.getLogger('pytube')\n    logger.setLevel(level)\n    stream_handler = logging.StreamHandler()\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n    if log_filename is not None:\n        file_handler = logging.FileHandler(log_filename)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)",
        "docstring": "Create and configure a logger instance for the pytube module.\n\nThis function initializes a logger instance with specified logging severity and an optional log file. It formats log messages to include timestamps, log levels, and module names for better traceability. The default log level is set to ERROR, and if a log filename is provided, it additionally writes logs to that file.\n\nParameters:\n- level (int): The logging severity level (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL), controlling which log messages are recorded. Default is logging.ERROR.\n- log_filename (Optional[str]): An optional parameter for specifying a file to which logs should be written. If provided, a file handler is added to the logger.\n\nReturns:\n- None: This function does not return a value, but it configures the logger for use throughout the module.\n\nDependencies:\n- Uses `logging` from the Python standard library to handle logging functionalities.\n- The `logger` variable, created via `logging.getLogger(\"pytube\")`, is specific to the pytube module, allowing for targeted logging.",
        "signature": "def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "cache": {
        "code": "def cache(func: Callable[..., GenericType]) -> GenericType:\n    \"\"\"This decorator applies Python's `functools.lru_cache` to the decorated function, enabling caching of its results for improved performance on subsequent calls with the same arguments. \n\n:param func: A callable function for which the cache will be applied.\n:returns: The cached version of the input function.\n:note: This function utilizes `functools` from the standard library, which needs to be imported for caching functionality. The cached results are stored based on the function's input arguments, which means that calling the function with the same arguments will not recompute the result but will instead return the cached result, improving performance.\"\"\"\n    ' mypy compatible annotation wrapper for lru_cache'\n    return functools.lru_cache()(func)",
        "docstring": "This decorator applies Python's `functools.lru_cache` to the decorated function, enabling caching of its results for improved performance on subsequent calls with the same arguments. \n\n:param func: A callable function for which the cache will be applied.\n:returns: The cached version of the input function.\n:note: This function utilizes `functools` from the standard library, which needs to be imported for caching functionality. The cached results are stored based on the function's input arguments, which means that calling the function with the same arguments will not recompute the result but will instead return the cached result, improving performance.",
        "signature": "def cache(func: Callable[..., GenericType]) -> GenericType:",
        "type": "Function",
        "class_signature": null
      },
      "deprecated": {
        "code": "def deprecated(reason: str) -> Callable:\n    \"\"\"A decorator to mark functions as deprecated, emitting a warning upon usage.\n\nParameters:\n- reason (str): The reason for the deprecation, which is included in the warning message.\n\nReturns:\n- Callable: A wrapper function that invokes the original deprecated function while issuing a DeprecationWarning.\n\nSide Effects:\n- Emits a DeprecationWarning when the decorated function is called, indicating that it should no longer be used. The warning includes the function name and the provided reason for its deprecation.\n\nThe decorator uses `warnings.simplefilter` to control the emission of the warning, ensuring it's always shown when the deprecated function is called.\"\"\"\n    '\\n    This is a decorator which can be used to mark functions\\n    as deprecated. It will result in a warning being emitted\\n    when the function is used.\\n    '\n\n    def decorator(func1):\n        \"\"\"This decorator marks a function as deprecated, issuing a warning when the function is called to indicate that it should no longer be used.\n\nParameters:\n- reason (str): A message explaining why the function is deprecated.\n\nReturns:\n- Callable: A wrapper function that, when called, triggers a DeprecationWarning and proceeds to execute the original function.\n\nSide Effects:\n- Emits a DeprecationWarning, informing the user of the function's deprecated status every time the decorated function is called. The warning message includes the name of the function and the reason provided.\n\nConstants:\n- message (str): A formatting string used to construct the warning message, indicating the function's name and its reason for deprecation.\"\"\"\n        message = 'Call to deprecated function {name} ({reason}).'\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            \"\"\"Wrapper function for a deprecated function to issue a warning upon invocation.\n\nThis function accepts arbitrary positional and keyword arguments, and when called, it raises a `DeprecationWarning` with a message indicating that the wrapped function is deprecated. The warning message includes the name of the function and the reason for its deprecation, which is formatted using the `message` string defined in the outer decorator. It restores the warning filter to its default state after issuing the warning. The function then proceeds to call the original wrapped function (`func1`) with the provided arguments and return its result.\n\nParameters:\n- *args: Positional arguments to pass to the original function.\n- **kwargs: Keyword arguments to pass to the original function.\n\nReturns:\n- The result of the original function call.\n\nSide Effects:\n- Emits a `DeprecationWarning` when the wrapped function is called.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)\n        return new_func1\n    return decorator",
        "docstring": "A decorator to mark functions as deprecated, emitting a warning upon usage.\n\nParameters:\n- reason (str): The reason for the deprecation, which is included in the warning message.\n\nReturns:\n- Callable: A wrapper function that invokes the original deprecated function while issuing a DeprecationWarning.\n\nSide Effects:\n- Emits a DeprecationWarning when the decorated function is called, indicating that it should no longer be used. The warning includes the function name and the provided reason for its deprecation.\n\nThe decorator uses `warnings.simplefilter` to control the emission of the warning, ensuring it's always shown when the deprecated function is called.",
        "signature": "def deprecated(reason: str) -> Callable:",
        "type": "Function",
        "class_signature": null
      },
      "target_directory": {
        "code": "def target_directory(output_path: Optional[str]=None) -> str:\n    \"\"\"Determines the target directory for downloads, returning an absolute path.\n\nThe function takes an optional `output_path` parameter. If provided, it checks if the path is absolute; if not, it converts it to an absolute path based on the current working directory. If no `output_path` is given, it defaults to the current working directory. The function ensures that the specified directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): The desired target directory for downloads. If None, the current working directory is used.\n\nReturns:\n- str: An absolute path to the target directory as a string.\n\nSide Effects:\n- Creates the specified directory if it does not exist using `os.makedirs`.\n- Relies on `os` module functions like `os.path.isabs` and `os.path.join` to manipulate file paths and ensure directory creation.\"\"\"\n    '\\n    Function for determining target directory of a download.\\n    Returns an absolute path (if relative one given) or the current\\n    path (if none given). Makes directory if it does not exist.\\n\\n    :type output_path: str\\n        :rtype: str\\n    :returns:\\n        An absolute directory path as a string.\\n    '\n    if output_path:\n        if not os.path.isabs(output_path):\n            output_path = os.path.join(os.getcwd(), output_path)\n    else:\n        output_path = os.getcwd()\n    os.makedirs(output_path, exist_ok=True)\n    return output_path",
        "docstring": "Determines the target directory for downloads, returning an absolute path.\n\nThe function takes an optional `output_path` parameter. If provided, it checks if the path is absolute; if not, it converts it to an absolute path based on the current working directory. If no `output_path` is given, it defaults to the current working directory. The function ensures that the specified directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): The desired target directory for downloads. If None, the current working directory is used.\n\nReturns:\n- str: An absolute path to the target directory as a string.\n\nSide Effects:\n- Creates the specified directory if it does not exist using `os.makedirs`.\n- Relies on `os` module functions like `os.path.isabs` and `os.path.join` to manipulate file paths and ensure directory creation.",
        "signature": "def target_directory(output_path: Optional[str]=None) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "uniqueify": {
        "code": "def uniqueify(duped_list: List) -> List:\n    \"\"\"Remove duplicate items from a list while preserving the original order of elements.\n\n:param List duped_list: A list that may contain duplicate items, which will be filtered to remove any duplicates.\n:rtype: List: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to track items that have already been encountered, ensuring that each item is appended to the result list only once. The function is designed to maintain the order of the original list while efficiently eliminating duplicates. It does not modify the input list but returns a new list containing unique elements.\"\"\"\n    'Remove duplicate items from a list, while maintaining list order.\\n\\n    :param List duped_list\\n        List to remove duplicates from\\n\\n    :return List result\\n        De-duplicated list\\n    '\n    seen: Dict[Any, bool] = {}\n    result = []\n    for item in duped_list:\n        if item in seen:\n            continue\n        seen[item] = True\n        result.append(item)\n    return result",
        "docstring": "Remove duplicate items from a list while preserving the original order of elements.\n\n:param List duped_list: A list that may contain duplicate items, which will be filtered to remove any duplicates.\n:rtype: List: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to track items that have already been encountered, ensuring that each item is appended to the result list only once. The function is designed to maintain the order of the original list while efficiently eliminating duplicates. It does not modify the input list but returns a new list containing unique elements.",
        "signature": "def uniqueify(duped_list: List) -> List:",
        "type": "Function",
        "class_signature": null
      },
      "create_mock_html_json": {
        "code": "def create_mock_html_json(vid_id) -> Dict[str, Any]:\n    \"\"\"Generate a compressed JSON file containing sample HTML responses for a given YouTube video ID.\n\n:param str vid_id: The YouTube video ID for which to generate the mock data.\n:return dict data: A dictionary containing the video's watch URL, JavaScript, embed HTML, watch HTML, and video information.\n\nThis function depends on the `YouTube` class from the `pytube` library to fetch video data. It constructs the file path for the output by navigating to the tests/mocks directory. The generated JSON file is saved with the name `yt-video-{vid_id}-html.json.gz`, where `{vid_id}` is replaced by the provided video ID. The function logs the output file path using the `logger` set up in the module.\"\"\"\n    'Generate a json.gz file with sample html responses.\\n\\n    :param str vid_id\\n        YouTube video id\\n\\n    :return dict data\\n        Dict used to generate the json.gz file\\n    '\n    from pytube import YouTube\n    gzip_filename = 'yt-video-%s-html.json.gz' % vid_id\n    pytube_dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_filepath = os.path.join(pytube_mocks_path, gzip_filename)\n    yt = YouTube(f'https://www.youtube.com/watch?v={vid_id}')\n    html_data = {'url': yt.watch_url, 'js': yt.js, 'embed_html': yt.embed_html, 'watch_html': yt.watch_html, 'vid_info': yt.vid_info}\n    logger.info(f'Outputing json.gz file to {gzip_filepath}')\n    with gzip.open(gzip_filepath, 'wb') as f:\n        f.write(json.dumps(html_data).encode('utf-8'))\n    return html_data",
        "docstring": "Generate a compressed JSON file containing sample HTML responses for a given YouTube video ID.\n\n:param str vid_id: The YouTube video ID for which to generate the mock data.\n:return dict data: A dictionary containing the video's watch URL, JavaScript, embed HTML, watch HTML, and video information.\n\nThis function depends on the `YouTube` class from the `pytube` library to fetch video data. It constructs the file path for the output by navigating to the tests/mocks directory. The generated JSON file is saved with the name `yt-video-{vid_id}-html.json.gz`, where `{vid_id}` is replaced by the provided video ID. The function logs the output file path using the `logger` set up in the module.",
        "signature": "def create_mock_html_json(vid_id) -> Dict[str, Any]:",
        "type": "Function",
        "class_signature": null
      },
      "decorator": {
        "code": "    def decorator(func1):\n        \"\"\"This decorator marks a function as deprecated, issuing a warning when the function is called to indicate that it should no longer be used.\n\nParameters:\n- reason (str): A message explaining why the function is deprecated.\n\nReturns:\n- Callable: A wrapper function that, when called, triggers a DeprecationWarning and proceeds to execute the original function.\n\nSide Effects:\n- Emits a DeprecationWarning, informing the user of the function's deprecated status every time the decorated function is called. The warning message includes the name of the function and the reason provided.\n\nConstants:\n- message (str): A formatting string used to construct the warning message, indicating the function's name and its reason for deprecation.\"\"\"\n        message = 'Call to deprecated function {name} ({reason}).'\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            \"\"\"Wrapper function for a deprecated function to issue a warning upon invocation.\n\nThis function accepts arbitrary positional and keyword arguments, and when called, it raises a `DeprecationWarning` with a message indicating that the wrapped function is deprecated. The warning message includes the name of the function and the reason for its deprecation, which is formatted using the `message` string defined in the outer decorator. It restores the warning filter to its default state after issuing the warning. The function then proceeds to call the original wrapped function (`func1`) with the provided arguments and return its result.\n\nParameters:\n- *args: Positional arguments to pass to the original function.\n- **kwargs: Keyword arguments to pass to the original function.\n\nReturns:\n- The result of the original function call.\n\nSide Effects:\n- Emits a `DeprecationWarning` when the wrapped function is called.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)\n        return new_func1",
        "docstring": "This decorator marks a function as deprecated, issuing a warning when the function is called to indicate that it should no longer be used.\n\nParameters:\n- reason (str): A message explaining why the function is deprecated.\n\nReturns:\n- Callable: A wrapper function that, when called, triggers a DeprecationWarning and proceeds to execute the original function.\n\nSide Effects:\n- Emits a DeprecationWarning, informing the user of the function's deprecated status every time the decorated function is called. The warning message includes the name of the function and the reason provided.\n\nConstants:\n- message (str): A formatting string used to construct the warning message, indicating the function's name and its reason for deprecation.",
        "signature": "def decorator(func1):",
        "type": "Function",
        "class_signature": null
      },
      "new_func1": {
        "code": "        def new_func1(*args, **kwargs):\n            \"\"\"Wrapper function for a deprecated function to issue a warning upon invocation.\n\nThis function accepts arbitrary positional and keyword arguments, and when called, it raises a `DeprecationWarning` with a message indicating that the wrapped function is deprecated. The warning message includes the name of the function and the reason for its deprecation, which is formatted using the `message` string defined in the outer decorator. It restores the warning filter to its default state after issuing the warning. The function then proceeds to call the original wrapped function (`func1`) with the provided arguments and return its result.\n\nParameters:\n- *args: Positional arguments to pass to the original function.\n- **kwargs: Keyword arguments to pass to the original function.\n\nReturns:\n- The result of the original function call.\n\nSide Effects:\n- Emits a `DeprecationWarning` when the wrapped function is called.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)",
        "docstring": "Wrapper function for a deprecated function to issue a warning upon invocation.\n\nThis function accepts arbitrary positional and keyword arguments, and when called, it raises a `DeprecationWarning` with a message indicating that the wrapped function is deprecated. The warning message includes the name of the function and the reason for its deprecation, which is formatted using the `message` string defined in the outer decorator. It restores the warning filter to its default state after issuing the warning. The function then proceeds to call the original wrapped function (`func1`) with the provided arguments and return its result.\n\nParameters:\n- *args: Positional arguments to pass to the original function.\n- **kwargs: Keyword arguments to pass to the original function.\n\nReturns:\n- The result of the original function call.\n\nSide Effects:\n- Emits a `DeprecationWarning` when the wrapped function is called.",
        "signature": "def new_func1(*args, **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    },
    "pytube/__main__.py": {
      "YouTube.__init__": {
        "code": "    def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):\n        \"\"\"Initializes a YouTube object that provides an interface for accessing and interacting with a specific YouTube video.\n\n    Parameters:\n        url (str): A valid YouTube watch URL. This is essential to identify the video to be interacted with.\n        on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined callback function that gets triggered during the download progress of the stream. It accepts three parameters: the stream being downloaded, the chunk of data, and the remaining bytes.\n        on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined callback function that gets triggered when the downloading process is complete. It accepts the stream and the file path of the downloaded file as parameters.\n        proxies (Dict[str, str], optional): A dictionary mapping protocols to proxy addresses to be utilized in requests made by pytube. \n        use_oauth (bool, optional): If set to True, prompts the user to authenticate with YouTube. This is necessary for accessing certain private or restricted videos.\n        allow_oauth_cache (bool, optional): If set to True, allows caching of OAuth tokens locally, minimizing the number of authentication prompts. Defaults to True.\n\n    Attributes:\n        _js (Optional[str]): Stores JavaScript data fetched via the js_url for handling video streams.\n        _js_url (Optional[str]): The URL for fetching the JavaScript, parsed from the watch HTML.\n        _vid_info (Optional[Dict]): Contains metadata and information about the video fetched from the innertube/player.\n        watch_url (str): The full URL to the video's watch page, constructed using the video ID.\n        embed_url (str): The full URL for embedding the video, constructed using the video ID.\n        stream_monostate (Monostate): A shared state for progress and completion callbacks between Stream instances, following the Borg pattern.\n\n    The initializer interacts with the `extract` and `request` modules to retrieve necessary video data and manage proxy settings if provided. It also sets up various attributes that facilitate the retrieval of video metadata and streaming capabilities throughout the YouTube class.\"\"\"\n        'Construct a :class:`YouTube <YouTube>`.\\n\\n        :param str url:\\n            A valid YouTube watch URL.\\n        :param func on_progress_callback:\\n            (Optional) User defined callback function for stream download\\n            progress events.\\n        :param func on_complete_callback:\\n            (Optional) User defined callback function for stream download\\n            complete events.\\n        :param dict proxies:\\n            (Optional) A dict mapping protocol to proxy address which will be used by pytube.\\n        :param bool use_oauth:\\n            (Optional) Prompt the user to authenticate to YouTube.\\n            If allow_oauth_cache is set to True, the user should only be prompted once.\\n        :param bool allow_oauth_cache:\\n            (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\\n            These tokens are only generated if use_oauth is set to True as well.\\n        '\n        self._js: Optional[str] = None\n        self._js_url: Optional[str] = None\n        self._vid_info: Optional[Dict] = None\n        self._watch_html: Optional[str] = None\n        self._embed_html: Optional[str] = None\n        self._player_config_args: Optional[Dict] = None\n        self._age_restricted: Optional[bool] = None\n        self._fmt_streams: Optional[List[Stream]] = None\n        self._initial_data = None\n        self._metadata: Optional[YouTubeMetadata] = None\n        self.video_id = extract.video_id(url)\n        self.watch_url = f'https://youtube.com/watch?v={self.video_id}'\n        self.embed_url = f'https://www.youtube.com/embed/{self.video_id}'\n        self.stream_monostate = Monostate(on_progress=on_progress_callback, on_complete=on_complete_callback)\n        if proxies:\n            install_proxy(proxies)\n        self._author = None\n        self._title = None\n        self._publish_date = None\n        self.use_oauth = use_oauth\n        self.allow_oauth_cache = allow_oauth_cache",
        "docstring": "Initializes a YouTube object that provides an interface for accessing and interacting with a specific YouTube video.\n\nParameters:\n    url (str): A valid YouTube watch URL. This is essential to identify the video to be interacted with.\n    on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined callback function that gets triggered during the download progress of the stream. It accepts three parameters: the stream being downloaded, the chunk of data, and the remaining bytes.\n    on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined callback function that gets triggered when the downloading process is complete. It accepts the stream and the file path of the downloaded file as parameters.\n    proxies (Dict[str, str], optional): A dictionary mapping protocols to proxy addresses to be utilized in requests made by pytube. \n    use_oauth (bool, optional): If set to True, prompts the user to authenticate with YouTube. This is necessary for accessing certain private or restricted videos.\n    allow_oauth_cache (bool, optional): If set to True, allows caching of OAuth tokens locally, minimizing the number of authentication prompts. Defaults to True.\n\nAttributes:\n    _js (Optional[str]): Stores JavaScript data fetched via the js_url for handling video streams.\n    _js_url (Optional[str]): The URL for fetching the JavaScript, parsed from the watch HTML.\n    _vid_info (Optional[Dict]): Contains metadata and information about the video fetched from the innertube/player.\n    watch_url (str): The full URL to the video's watch page, constructed using the video ID.\n    embed_url (str): The full URL for embedding the video, constructed using the video ID.\n    stream_monostate (Monostate): A shared state for progress and completion callbacks between Stream instances, following the Borg pattern.\n\nThe initializer interacts with the `extract` and `request` modules to retrieve necessary video data and manage proxy settings if provided. It also sets up various attributes that facilitate the retrieval of video metadata and streaming capabilities throughout the YouTube class.",
        "signature": "def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):",
        "type": "Method",
        "class_signature": "class YouTube:"
      },
      "YouTube.watch_html": {
        "code": "    def watch_html(self):\n        \"\"\"Retrieve the HTML content of the YouTube watch page for the video.\n\nThis property fetches the watch page HTML using the `request.get()` method for the URL constructed from the `watch_url` attribute. The result is cached to avoid repeated network calls in subsequent accesses. If the HTML has already been cached, it will return the cached value instead of making a new request.\n\nDependencies:\n- `self.watch_url`: A constructed URL for the YouTube video, based on the `video_id`, parsed from the provided YouTube URL during the object's initialization.\n- `request`: A module responsible for making network requests to fetch the HTML content.\n\nReturns:\n- str: The HTML content of the YouTube watch page for the specified video.\n\nSide Effects:\n- Caches the HTML content of the watch page upon the first request to optimize further access to this property.\"\"\"\n        if self._watch_html:\n            return self._watch_html\n        self._watch_html = request.get(url=self.watch_url)\n        return self._watch_html",
        "docstring": "Retrieve the HTML content of the YouTube watch page for the video.\n\nThis property fetches the watch page HTML using the `request.get()` method for the URL constructed from the `watch_url` attribute. The result is cached to avoid repeated network calls in subsequent accesses. If the HTML has already been cached, it will return the cached value instead of making a new request.\n\nDependencies:\n- `self.watch_url`: A constructed URL for the YouTube video, based on the `video_id`, parsed from the provided YouTube URL during the object's initialization.\n- `request`: A module responsible for making network requests to fetch the HTML content.\n\nReturns:\n- str: The HTML content of the YouTube watch page for the specified video.\n\nSide Effects:\n- Caches the HTML content of the watch page upon the first request to optimize further access to this property.",
        "signature": "def watch_html(self):",
        "type": "Method",
        "class_signature": "class YouTube:"
      },
      "YouTube.embed_html": {
        "code": "    def embed_html(self):\n        \"\"\"Retrieve the HTML embed code for the YouTube video.\n\nThis property fetches the HTML content associated with the embed URL of the video, which is constructed using the video's `video_id`. It checks if the embed HTML has already been fetched and stored; if so, it returns the cached version. If not, it performs an HTTP GET request to the embed URL to retrieve the latest HTML content.\n\nReturns:\n    str: The HTML embed code for the YouTube video.\n\nDependencies:\n    - `request`: A module that handles HTTP requests, specifically used to fetch the embed HTML.\n    - `embed_url`: A property defined in the `YouTube` class that constructs the URL for embedding the video using the `video_id`.\"\"\"\n        if self._embed_html:\n            return self._embed_html\n        self._embed_html = request.get(url=self.embed_url)\n        return self._embed_html",
        "docstring": "Retrieve the HTML embed code for the YouTube video.\n\nThis property fetches the HTML content associated with the embed URL of the video, which is constructed using the video's `video_id`. It checks if the embed HTML has already been fetched and stored; if so, it returns the cached version. If not, it performs an HTTP GET request to the embed URL to retrieve the latest HTML content.\n\nReturns:\n    str: The HTML embed code for the YouTube video.\n\nDependencies:\n    - `request`: A module that handles HTTP requests, specifically used to fetch the embed HTML.\n    - `embed_url`: A property defined in the `YouTube` class that constructs the URL for embedding the video using the `video_id`.",
        "signature": "def embed_html(self):",
        "type": "Method",
        "class_signature": "class YouTube:"
      },
      "YouTube.js": {
        "code": "    def js(self):\n        \"\"\"Fetches and returns the JavaScript code used to extract video information from YouTube, caching the result to enhance performance on subsequent calls.\n\nReturns:\n    str: The fetched JavaScript code as a string.\n\nSide Effects:\n    - If the URL of the JavaScript source has changed since the last fetch, the method will perform a network request to obtain the latest version, updating the internal cache and the global cache defined in the pytube module (`pytube.__js__` and `pytube.__js_url__`).\n    - If the cached JavaScript is valid and satisfies the current request's URL, it will return the cached version directly.\n\nDependencies:\n    - `request.get`: Utilized to fetch the JavaScript from the specified URL.\n    - `pytube.__js__` and `pytube.__js_url__`: Global cache entries that store the current JavaScript code and the corresponding URL, respectively.\"\"\"\n        if self._js:\n            return self._js\n        if pytube.__js_url__ != self.js_url:\n            self._js = request.get(self.js_url)\n            pytube.__js__ = self._js\n            pytube.__js_url__ = self.js_url\n        else:\n            self._js = pytube.__js__\n        return self._js",
        "docstring": "Fetches and returns the JavaScript code used to extract video information from YouTube, caching the result to enhance performance on subsequent calls.\n\nReturns:\n    str: The fetched JavaScript code as a string.\n\nSide Effects:\n    - If the URL of the JavaScript source has changed since the last fetch, the method will perform a network request to obtain the latest version, updating the internal cache and the global cache defined in the pytube module (`pytube.__js__` and `pytube.__js_url__`).\n    - If the cached JavaScript is valid and satisfies the current request's URL, it will return the cached version directly.\n\nDependencies:\n    - `request.get`: Utilized to fetch the JavaScript from the specified URL.\n    - `pytube.__js__` and `pytube.__js_url__`: Global cache entries that store the current JavaScript code and the corresponding URL, respectively.",
        "signature": "def js(self):",
        "type": "Method",
        "class_signature": "class YouTube:"
      },
      "YouTube.vid_info": {
        "code": "    def vid_info(self):\n        \"\"\"Parse and return the video information for the YouTube video associated with this instance.\n\nThe method retrieves the video information by instantiating an `InnerTube` object, which is configured with optional OAuth settings. It calls the `player` method of the `InnerTube` class, passing in the video ID derived from the instance's `video_id` attribute. If the video information (`_vid_info`) has already been fetched, it returns the cached value. Otherwise, it retrieves and stores the new response from `innertube`. \n\n:rtype: Dict[Any, Any]\n:returns: A dictionary containing video details such as title, description, and streaming data.\n:raises exceptions.PytubeError: May raise an exception if the video cannot be accessed.\"\"\"\n        'Parse the raw vid info and return the parsed result.\\n\\n        :rtype: Dict[Any, Any]\\n        '\n        if self._vid_info:\n            return self._vid_info\n        innertube = InnerTube(use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n        innertube_response = innertube.player(self.video_id)\n        self._vid_info = innertube_response\n        return self._vid_info",
        "docstring": "Parse and return the video information for the YouTube video associated with this instance.\n\nThe method retrieves the video information by instantiating an `InnerTube` object, which is configured with optional OAuth settings. It calls the `player` method of the `InnerTube` class, passing in the video ID derived from the instance's `video_id` attribute. If the video information (`_vid_info`) has already been fetched, it returns the cached value. Otherwise, it retrieves and stores the new response from `innertube`. \n\n:rtype: Dict[Any, Any]\n:returns: A dictionary containing video details such as title, description, and streaming data.\n:raises exceptions.PytubeError: May raise an exception if the video cannot be accessed.",
        "signature": "def vid_info(self):",
        "type": "Method",
        "class_signature": "class YouTube:"
      }
    },
    "pytube/exceptions.py": {
      "RegexMatchError.__init__": {
        "code": "    def __init__(self, caller: str, pattern: Union[str, Pattern]):\n        \"\"\"Initialize a RegexMatchError instance.\n\nThis error is raised when a regex pattern fails to find a match during data extraction processes. It provides context about the calling function and the pattern that resulted in the error.\n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that failed to yield a match. This can be either a string representation of the pattern or a compiled regex pattern object.\n\nAttributes:\n- caller (str): Stores the name of the calling function.\n- pattern (Union[str, Pattern]): Stores the regex pattern that caused the error.\n\nThis class extends the ExtractError, which is a subclass of the PytubeError, ensuring that regex-related match issues are categorized under extraction errors.\"\"\"\n        '\\n        :param str caller:\\n            Calling function\\n        :param str pattern:\\n            Pattern that failed to match\\n        '\n        super().__init__(f'{caller}: could not find match for {pattern}')\n        self.caller = caller\n        self.pattern = pattern",
        "docstring": "Initialize a RegexMatchError instance.\n\nThis error is raised when a regex pattern fails to find a match during data extraction processes. It provides context about the calling function and the pattern that resulted in the error.\n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that failed to yield a match. This can be either a string representation of the pattern or a compiled regex pattern object.\n\nAttributes:\n- caller (str): Stores the name of the calling function.\n- pattern (Union[str, Pattern]): Stores the regex pattern that caused the error.\n\nThis class extends the ExtractError, which is a subclass of the PytubeError, ensuring that regex-related match issues are categorized under extraction errors.",
        "signature": "def __init__(self, caller: str, pattern: Union[str, Pattern]):",
        "type": "Method",
        "class_signature": "class RegexMatchError(ExtractError):"
      }
    }
  },
  "dependency_dict": {
    "pytube/helpers.py:regex_search": {},
    "pytube/exceptions.py:RegexMatchError:__init__": {},
    "pytube/helpers.py:new_func1": {
      "tests/test_helpers.py": {
        "deprecated_function": {
          "code": "    def deprecated_function():\n        return None",
          "docstring": "",
          "signature": "def deprecated_function():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pytube/helpers.py:create_mock_html_json": {},
    "pytube/__main__.py:YouTube:__init__": {
      "pytube/extract.py": {
        "video_id": {
          "code": "def video_id(url: str) -> str:\n    \"\"\"Extract the ``video_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/watch?v={video_id}`\n    - :samp:`https://youtube.com/embed/{video_id}`\n    - :samp:`https://youtu.be/{video_id}`\n\n    :param str url:\n        A YouTube url containing a video id.\n    :rtype: str\n    :returns:\n        YouTube video id.\n    \"\"\"\n    return regex_search(r\"(?:v=|\\/)([0-9A-Za-z_-]{11}).*\", url, group=1)",
          "docstring": "Extract the ``video_id`` from a YouTube url.\n\nThis function supports the following patterns:\n\n- :samp:`https://youtube.com/watch?v={video_id}`\n- :samp:`https://youtube.com/embed/{video_id}`\n- :samp:`https://youtu.be/{video_id}`\n\n:param str url:\n    A YouTube url containing a video id.\n:rtype: str\n:returns:\n    YouTube video id.",
          "signature": "def video_id(url: str) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "pytube/monostate.py": {
        "Monostate.__init__": {
          "code": "    def __init__(\n        self,\n        on_progress: Optional[Callable[[Any, bytes, int], None]],\n        on_complete: Optional[Callable[[Any, Optional[str]], None]],\n        title: Optional[str] = None,\n        duration: Optional[int] = None,\n    ):\n        self.on_progress = on_progress\n        self.on_complete = on_complete\n        self.title = title\n        self.duration = duration",
          "docstring": "",
          "signature": "def __init__(self, on_progress: Optional[Callable[[Any, bytes, int], None]], on_complete: Optional[Callable[[Any, Optional[str]], None]], title: Optional[str]=None, duration: Optional[int]=None):",
          "type": "Method",
          "class_signature": "class Monostate:"
        }
      }
    },
    "pytube/__main__.py:YouTube:js": {
      "pytube/__main__.py": {
        "YouTube.js_url": {
          "code": "    def js_url(self):\n        if self._js_url:\n            return self._js_url\n        if self.age_restricted:\n            self._js_url = extract.js_url(self.embed_html)\n        else:\n            self._js_url = extract.js_url(self.watch_html)\n        return self._js_url",
          "docstring": "",
          "signature": "def js_url(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        }
      },
      "pytube/request.py": {
        "get": {
          "code": "def get(url, extra_headers=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n    \"\"\"Send an http GET request.\n\n    :param str url:\n        The URL to perform the GET request for.\n    :param dict extra_headers:\n        Extra headers to add to the request\n    :rtype: str\n    :returns:\n        UTF-8 encoded string of response\n    \"\"\"\n    if extra_headers is None:\n        extra_headers = {}\n    response = _execute_request(url, headers=extra_headers, timeout=timeout)\n    return response.read().decode(\"utf-8\")",
          "docstring": "Send an http GET request.\n\n:param str url:\n    The URL to perform the GET request for.\n:param dict extra_headers:\n    Extra headers to add to the request\n:rtype: str\n:returns:\n    UTF-8 encoded string of response",
          "signature": "def get(url, extra_headers=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pytube/__main__.py:YouTube:embed_html": {
      "pytube/request.py": {
        "get": {
          "code": "def get(url, extra_headers=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n    \"\"\"Send an http GET request.\n\n    :param str url:\n        The URL to perform the GET request for.\n    :param dict extra_headers:\n        Extra headers to add to the request\n    :rtype: str\n    :returns:\n        UTF-8 encoded string of response\n    \"\"\"\n    if extra_headers is None:\n        extra_headers = {}\n    response = _execute_request(url, headers=extra_headers, timeout=timeout)\n    return response.read().decode(\"utf-8\")",
          "docstring": "Send an http GET request.\n\n:param str url:\n    The URL to perform the GET request for.\n:param dict extra_headers:\n    Extra headers to add to the request\n:rtype: str\n:returns:\n    UTF-8 encoded string of response",
          "signature": "def get(url, extra_headers=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pytube/__main__.py:YouTube:watch_html": {},
    "pytube/__main__.py:YouTube:vid_info": {
      "pytube/innertube.py": {
        "InnerTube.__init__": {
          "code": "    def __init__(self, client='ANDROID_MUSIC', use_oauth=False, allow_cache=True):\n        \"\"\"Initialize an InnerTube object.\n\n        :param str client:\n            Client to use for the object.\n            Default to web because it returns the most playback types.\n        :param bool use_oauth:\n            Whether or not to authenticate to YouTube.\n        :param bool allow_cache:\n            Allows caching of oauth tokens on the machine.\n        \"\"\"\n        self.context = _default_clients[client]['context']\n        self.header = _default_clients[client]['header']\n        self.api_key = _default_clients[client]['api_key']\n        self.access_token = None\n        self.refresh_token = None\n        self.use_oauth = use_oauth\n        self.allow_cache = allow_cache\n\n        # Stored as epoch time\n        self.expires = None\n\n        # Try to load from file if specified\n        if self.use_oauth and self.allow_cache:\n            # Try to load from file if possible\n            if os.path.exists(_token_file):\n                with open(_token_file) as f:\n                    data = json.load(f)\n                    self.access_token = data['access_token']\n                    self.refresh_token = data['refresh_token']\n                    self.expires = data['expires']\n                    self.refresh_bearer_token()",
          "docstring": "Initialize an InnerTube object.\n\n:param str client:\n    Client to use for the object.\n    Default to web because it returns the most playback types.\n:param bool use_oauth:\n    Whether or not to authenticate to YouTube.\n:param bool allow_cache:\n    Allows caching of oauth tokens on the machine.",
          "signature": "def __init__(self, client='ANDROID_MUSIC', use_oauth=False, allow_cache=True):",
          "type": "Method",
          "class_signature": "class InnerTube:"
        },
        "InnerTube.player": {
          "code": "    def player(self, video_id):\n        \"\"\"Make a request to the player endpoint.\n\n        :param str video_id:\n            The video id to get player info for.\n        :rtype: dict\n        :returns:\n            Raw player info results.\n        \"\"\"\n        endpoint = f'{self.base_url}/player'\n        query = {\n            'videoId': video_id,\n        }\n        query.update(self.base_params)\n        return self._call_api(endpoint, query, self.base_data)",
          "docstring": "Make a request to the player endpoint.\n\n:param str video_id:\n    The video id to get player info for.\n:rtype: dict\n:returns:\n    Raw player info results.",
          "signature": "def player(self, video_id):",
          "type": "Method",
          "class_signature": "class InnerTube:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_helpers.py:test_regex_search_no_match": {
      "pytube/helpers.py:regex_search": {
        "pytube/exceptions.py:RegexMatchError:__init__": {}
      }
    },
    "tests/test_helpers.py:test_regex_search": {
      "pytube/helpers.py:regex_search": {}
    },
    "tests/test_helpers.py:test_safe_filename": {
      "pytube/helpers.py:safe_filename": {}
    },
    "tests/test_helpers.py:test_deprecated": {
      "pytube/helpers.py:deprecated": {},
      "pytube/helpers.py:decorator": {},
      "pytube/helpers.py:new_func1": {
        "tests/test_helpers.py:deprecated_function": {}
      }
    },
    "tests/test_helpers.py:test_cache": {
      "pytube/helpers.py:cache": {},
      "tests/test_helpers.py:cached_func": {}
    },
    "../app/pytube/tests/test_helpers.py:test_target_directory_with_relative_path": {
      "../app/pytube/pytube/helpers.py:target_directory": {}
    },
    "tests/test_helpers.py:test_target_directory_with_absolute_path": {
      "pytube/helpers.py:target_directory": {}
    },
    "../app/pytube/tests/test_helpers.py:test_target_directory_with_no_path": {
      "../app/pytube/pytube/helpers.py:target_directory": {}
    },
    "tests/test_helpers.py:test_setup_logger": {
      "pytube/helpers.py:setup_logger": {}
    },
    "tests/test_helpers.py:test_create_mock_html_json": {
      "pytube/helpers.py:create_mock_html_json": {
        "pytube/__main__.py:YouTube:__init__": {
          "pytube/extract.py:video_id": {
            "pytube/helpers.py:regex_search": {}
          },
          "pytube/monostate.py:Monostate:__init__": {}
        },
        "pytube/__main__.py:YouTube:js": {
          "pytube/__main__.py:YouTube:js_url": {
            "pytube/__main__.py:YouTube:age_restricted": {
              "pytube/__main__.py:YouTube:watch_html": {
                "pytube/request.py:get": {
                  "pytube/request.py:_execute_request": {}
                }
              },
              "pytube/extract.py:is_age_restricted": {
                "pytube/helpers.py:regex_search": {
                  "pytube/exceptions.py:RegexMatchError:__init__": {}
                }
              }
            },
            "pytube/__main__.py:YouTube:watch_html": {},
            "pytube/extract.py:js_url": {
              "pytube/extract.py:get_ytplayer_config": {
                "pytube/parser.py:parse_for_object": {
                  "pytube/parser.py:parse_for_object_from_startpoint": {
                    "pytube/parser.py:find_object_from_startpoint": {}
                  }
                }
              },
              "pytube/extract.py:get_ytplayer_js": {}
            }
          },
          "pytube/request.py:get": {
            "pytube/request.py:_execute_request": {}
          }
        },
        "pytube/__main__.py:YouTube:embed_html": {
          "pytube/request.py:get": {
            "pytube/request.py:_execute_request": {}
          }
        },
        "pytube/__main__.py:YouTube:watch_html": {},
        "pytube/__main__.py:YouTube:vid_info": {
          "pytube/innertube.py:InnerTube:__init__": {},
          "pytube/innertube.py:InnerTube:player": {
            "pytube/innertube.py:InnerTube:base_url": {},
            "pytube/innertube.py:InnerTube:base_params": {},
            "pytube/innertube.py:InnerTube:base_data": {},
            "pytube/innertube.py:InnerTube:_call_api": {
              "pytube/request.py:_execute_request": {}
            }
          }
        }
      }
    },
    "tests/test_helpers.py:test_uniqueify": {
      "pytube/helpers.py:uniqueify": {}
    }
  },
  "PRD": "# PROJECT NAME: pytube-test_helpers\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pytube/\n    \u251c\u2500\u2500 __main__.py\n    \u2502   \u251c\u2500\u2500 YouTube.__init__\n    \u2502   \u251c\u2500\u2500 YouTube.embed_html\n    \u2502   \u251c\u2500\u2500 YouTube.js\n    \u2502   \u251c\u2500\u2500 YouTube.vid_info\n    \u2502   \u2514\u2500\u2500 YouTube.watch_html\n    \u251c\u2500\u2500 exceptions.py\n    \u2502   \u2514\u2500\u2500 RegexMatchError.__init__\n    \u2514\u2500\u2500 helpers.py\n        \u251c\u2500\u2500 cache\n        \u251c\u2500\u2500 create_mock_html_json\n        \u251c\u2500\u2500 decorator\n        \u251c\u2500\u2500 deprecated\n        \u251c\u2500\u2500 new_func1\n        \u251c\u2500\u2500 regex_search\n        \u251c\u2500\u2500 safe_filename\n        \u251c\u2500\u2500 setup_logger\n        \u251c\u2500\u2500 target_directory\n        \u2514\u2500\u2500 uniqueify\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides utility functions and enhancements to streamline the development and testing of applications utilizing the PyTube library. Its primary purpose is to manage tasks such as ensuring safe filename generation, caching results to optimize performance, handling relative and absolute directory paths, setting up custom loggers, and creating mock YouTube HTML responses for testing. It also offers mechanisms for cleaning and deduplicating data sets while supporting deprecated functionality with appropriate warnings. These capabilities simplify common development challenges, facilitate robust testing practices, and enhance the overall reliability and maintainability of projects leveraging PyTube.\n\n## FILE 1: pytube/helpers.py\n\n- FUNCTION NAME: cache\n  - SIGNATURE: def cache(func: Callable[..., GenericType]) -> GenericType:\n  - DOCSTRING: \n```python\n\"\"\"\nThis decorator applies Python's `functools.lru_cache` to the decorated function, enabling caching of its results for improved performance on subsequent calls with the same arguments. \n\n:param func: A callable function for which the cache will be applied.\n:returns: The cached version of the input function.\n:note: This function utilizes `functools` from the standard library, which needs to be imported for caching functionality. The cached results are stored based on the function's input arguments, which means that calling the function with the same arguments will not recompute the result but will instead return the cached result, improving performance.\n\"\"\"\n```\n\n- FUNCTION NAME: create_mock_html_json\n  - SIGNATURE: def create_mock_html_json(vid_id) -> Dict[str, Any]:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a compressed JSON file containing sample HTML responses for a given YouTube video ID.\n\n:param str vid_id: The YouTube video ID for which to generate the mock data.\n:return dict data: A dictionary containing the video's watch URL, JavaScript, embed HTML, watch HTML, and video information.\n\nThis function depends on the `YouTube` class from the `pytube` library to fetch video data. It constructs the file path for the output by navigating to the tests/mocks directory. The generated JSON file is saved with the name `yt-video-{vid_id}-html.json.gz`, where `{vid_id}` is replaced by the provided video ID. The function logs the output file path using the `logger` set up in the module.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/__main__.py:YouTube:embed_html\n    - pytube/__main__.py:YouTube:watch_html\n    - pytube/__main__.py:YouTube:__init__\n    - pytube/__main__.py:YouTube:js\n    - pytube/__main__.py:YouTube:vid_info\n\n- FUNCTION NAME: target_directory\n  - SIGNATURE: def target_directory(output_path: Optional[str]=None) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines the target directory for downloads, returning an absolute path.\n\nThe function takes an optional `output_path` parameter. If provided, it checks if the path is absolute; if not, it converts it to an absolute path based on the current working directory. If no `output_path` is given, it defaults to the current working directory. The function ensures that the specified directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): The desired target directory for downloads. If None, the current working directory is used.\n\nReturns:\n- str: An absolute path to the target directory as a string.\n\nSide Effects:\n- Creates the specified directory if it does not exist using `os.makedirs`.\n- Relies on `os` module functions like `os.path.isabs` and `os.path.join` to manipulate file paths and ensure directory creation.\n\"\"\"\n```\n\n- FUNCTION NAME: setup_logger\n  - SIGNATURE: def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate and configure a logger instance for the pytube module.\n\nThis function initializes a logger instance with specified logging severity and an optional log file. It formats log messages to include timestamps, log levels, and module names for better traceability. The default log level is set to ERROR, and if a log filename is provided, it additionally writes logs to that file.\n\nParameters:\n- level (int): The logging severity level (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL), controlling which log messages are recorded. Default is logging.ERROR.\n- log_filename (Optional[str]): An optional parameter for specifying a file to which logs should be written. If provided, a file handler is added to the logger.\n\nReturns:\n- None: This function does not return a value, but it configures the logger for use throughout the module.\n\nDependencies:\n- Uses `logging` from the Python standard library to handle logging functionalities.\n- The `logger` variable, created via `logging.getLogger(\"pytube\")`, is specific to the pytube module, allowing for targeted logging.\n\"\"\"\n```\n\n- FUNCTION NAME: uniqueify\n  - SIGNATURE: def uniqueify(duped_list: List) -> List:\n  - DOCSTRING: \n```python\n\"\"\"\nRemove duplicate items from a list while preserving the original order of elements.\n\n:param List duped_list: A list that may contain duplicate items, which will be filtered to remove any duplicates.\n:rtype: List: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to track items that have already been encountered, ensuring that each item is appended to the result list only once. The function is designed to maintain the order of the original list while efficiently eliminating duplicates. It does not modify the input list but returns a new list containing unique elements.\n\"\"\"\n```\n\n- FUNCTION NAME: decorator\n  - SIGNATURE: def decorator(func1):\n  - DOCSTRING: \n```python\n\"\"\"\nThis decorator marks a function as deprecated, issuing a warning when the function is called to indicate that it should no longer be used.\n\nParameters:\n- reason (str): A message explaining why the function is deprecated.\n\nReturns:\n- Callable: A wrapper function that, when called, triggers a DeprecationWarning and proceeds to execute the original function.\n\nSide Effects:\n- Emits a DeprecationWarning, informing the user of the function's deprecated status every time the decorated function is called. The warning message includes the name of the function and the reason provided.\n\nConstants:\n- message (str): A formatting string used to construct the warning message, indicating the function's name and its reason for deprecation.\n\"\"\"\n```\n\n- FUNCTION NAME: new_func1\n  - SIGNATURE: def new_func1(*args, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nWrapper function for a deprecated function to issue a warning upon invocation.\n\nThis function accepts arbitrary positional and keyword arguments, and when called, it raises a `DeprecationWarning` with a message indicating that the wrapped function is deprecated. The warning message includes the name of the function and the reason for its deprecation, which is formatted using the `message` string defined in the outer decorator. It restores the warning filter to its default state after issuing the warning. The function then proceeds to call the original wrapped function (`func1`) with the provided arguments and return its result.\n\nParameters:\n- *args: Positional arguments to pass to the original function.\n- **kwargs: Keyword arguments to pass to the original function.\n\nReturns:\n- The result of the original function call.\n\nSide Effects:\n- Emits a `DeprecationWarning` when the wrapped function is called.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/test_helpers.py:deprecated_function\n\n- FUNCTION NAME: deprecated\n  - SIGNATURE: def deprecated(reason: str) -> Callable:\n  - DOCSTRING: \n```python\n\"\"\"\nA decorator to mark functions as deprecated, emitting a warning upon usage.\n\nParameters:\n- reason (str): The reason for the deprecation, which is included in the warning message.\n\nReturns:\n- Callable: A wrapper function that invokes the original deprecated function while issuing a DeprecationWarning.\n\nSide Effects:\n- Emits a DeprecationWarning when the decorated function is called, indicating that it should no longer be used. The warning includes the function name and the provided reason for its deprecation.\n\nThe decorator uses `warnings.simplefilter` to control the emission of the warning, ensuring it's always shown when the deprecated function is called.\n\"\"\"\n```\n\n- FUNCTION NAME: regex_search\n  - SIGNATURE: def regex_search(pattern: str, string: str, group: int) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nShortcut method to search a string for a regular expression pattern and return a specific group match.\n\n:param str pattern: A regular expression pattern used to search the target string.\n:param str string: The target string where the regex search will be performed.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex results.\n\nRaises a RegexMatchError if no match is found, indicating that the pattern did not match the string. This function depends on the `re` module for compiling and searching the regex pattern, and it utilizes a logger to output debug information about successful matches. The `RegexMatchError` is defined in the `pytube.exceptions` module, providing a way to handle regex-related errors within the Pytube package's operations.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/exceptions.py:RegexMatchError:__init__\n\n- FUNCTION NAME: safe_filename\n  - SIGNATURE: def safe_filename(s: str, max_length: int=255) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nSanitize a string to make it safe for use as a filename by removing invalid characters based on NTFS limitations.\n\nParameters:\n- s (str): The input string to sanitize for filename use.\n- max_length (int, optional): The maximum allowable length of the sanitized filename (default is 255 characters).\n\nReturns:\n- str: A sanitized filename, truncated to `max_length`, ensuring no invalid characters are included.\n\nDependencies:\nThis function utilizes the `re` module for regular expression operations. It defines a list of `ntfs_characters` representing invalid bytes for NTFS filenames (0-31) and a list of additional invalid filename characters. The constructed regex pattern identifies these characters, which are then removed from the input string `s`.\n\nImportant Side Effects:\nNone. The function purely returns a modified version of the input string without modifying the input itself.\n\"\"\"\n```\n\n## FILE 2: pytube/__main__.py\n\n- CLASS METHOD: YouTube.embed_html\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def embed_html(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the HTML embed code for the YouTube video.\n\nThis property fetches the HTML content associated with the embed URL of the video, which is constructed using the video's `video_id`. It checks if the embed HTML has already been fetched and stored; if so, it returns the cached version. If not, it performs an HTTP GET request to the embed URL to retrieve the latest HTML content.\n\nReturns:\n    str: The HTML embed code for the YouTube video.\n\nDependencies:\n    - `request`: A module that handles HTTP requests, specifically used to fetch the embed HTML.\n    - `embed_url`: A property defined in the `YouTube` class that constructs the URL for embedding the video using the `video_id`.\n\"\"\"\n```\n\n- CLASS METHOD: YouTube.watch_html\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def watch_html(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the HTML content of the YouTube watch page for the video.\n\nThis property fetches the watch page HTML using the `request.get()` method for the URL constructed from the `watch_url` attribute. The result is cached to avoid repeated network calls in subsequent accesses. If the HTML has already been cached, it will return the cached value instead of making a new request.\n\nDependencies:\n- `self.watch_url`: A constructed URL for the YouTube video, based on the `video_id`, parsed from the provided YouTube URL during the object's initialization.\n- `request`: A module responsible for making network requests to fetch the HTML content.\n\nReturns:\n- str: The HTML content of the YouTube watch page for the specified video.\n\nSide Effects:\n- Caches the HTML content of the watch page upon the first request to optimize further access to this property.\n\"\"\"\n```\n\n- CLASS METHOD: YouTube.__init__\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a YouTube object that provides an interface for accessing and interacting with a specific YouTube video.\n\nParameters:\n    url (str): A valid YouTube watch URL. This is essential to identify the video to be interacted with.\n    on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined callback function that gets triggered during the download progress of the stream. It accepts three parameters: the stream being downloaded, the chunk of data, and the remaining bytes.\n    on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined callback function that gets triggered when the downloading process is complete. It accepts the stream and the file path of the downloaded file as parameters.\n    proxies (Dict[str, str], optional): A dictionary mapping protocols to proxy addresses to be utilized in requests made by pytube. \n    use_oauth (bool, optional): If set to True, prompts the user to authenticate with YouTube. This is necessary for accessing certain private or restricted videos.\n    allow_oauth_cache (bool, optional): If set to True, allows caching of OAuth tokens locally, minimizing the number of authentication prompts. Defaults to True.\n\nAttributes:\n    _js (Optional[str]): Stores JavaScript data fetched via the js_url for handling video streams.\n    _js_url (Optional[str]): The URL for fetching the JavaScript, parsed from the watch HTML.\n    _vid_info (Optional[Dict]): Contains metadata and information about the video fetched from the innertube/player.\n    watch_url (str): The full URL to the video's watch page, constructed using the video ID.\n    embed_url (str): The full URL for embedding the video, constructed using the video ID.\n    stream_monostate (Monostate): A shared state for progress and completion callbacks between Stream instances, following the Borg pattern.\n\nThe initializer interacts with the `extract` and `request` modules to retrieve necessary video data and manage proxy settings if provided. It also sets up various attributes that facilitate the retrieval of video metadata and streaming capabilities throughout the YouTube class.\n\"\"\"\n```\n\n- CLASS METHOD: YouTube.js\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def js(self):\n  - DOCSTRING: \n```python\n\"\"\"\nFetches and returns the JavaScript code used to extract video information from YouTube, caching the result to enhance performance on subsequent calls.\n\nReturns:\n    str: The fetched JavaScript code as a string.\n\nSide Effects:\n    - If the URL of the JavaScript source has changed since the last fetch, the method will perform a network request to obtain the latest version, updating the internal cache and the global cache defined in the pytube module (`pytube.__js__` and `pytube.__js_url__`).\n    - If the cached JavaScript is valid and satisfies the current request's URL, it will return the cached version directly.\n\nDependencies:\n    - `request.get`: Utilized to fetch the JavaScript from the specified URL.\n    - `pytube.__js__` and `pytube.__js_url__`: Global cache entries that store the current JavaScript code and the corresponding URL, respectively.\n\"\"\"\n```\n\n- CLASS METHOD: YouTube.vid_info\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def vid_info(self):\n  - DOCSTRING: \n```python\n\"\"\"\nParse and return the video information for the YouTube video associated with this instance.\n\nThe method retrieves the video information by instantiating an `InnerTube` object, which is configured with optional OAuth settings. It calls the `player` method of the `InnerTube` class, passing in the video ID derived from the instance's `video_id` attribute. If the video information (`_vid_info`) has already been fetched, it returns the cached value. Otherwise, it retrieves and stores the new response from `innertube`. \n\n:rtype: Dict[Any, Any]\n:returns: A dictionary containing video details such as title, description, and streaming data.\n:raises exceptions.PytubeError: May raise an exception if the video cannot be accessed.\n\"\"\"\n```\n\n## FILE 3: pytube/exceptions.py\n\n- CLASS METHOD: RegexMatchError.__init__\n  - CLASS SIGNATURE: class RegexMatchError(ExtractError):\n  - SIGNATURE: def __init__(self, caller: str, pattern: Union[str, Pattern]):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a RegexMatchError instance.\n\nThis error is raised when a regex pattern fails to find a match during data extraction processes. It provides context about the calling function and the pattern that resulted in the error.\n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that failed to yield a match. This can be either a string representation of the pattern or a compiled regex pattern object.\n\nAttributes:\n- caller (str): Stores the name of the calling function.\n- pattern (Union[str, Pattern]): Stores the regex pattern that caused the error.\n\nThis class extends the ExtractError, which is a subclass of the PytubeError, ensuring that regex-related match issues are categorized under extraction errors.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pytube/helpers.py": "\"\"\"Various helper functions implemented by pytube.\"\"\"\nimport functools\nimport gzip\nimport json\nimport logging\nimport os\nimport re\nimport warnings\nfrom typing import Any, Callable, Dict, List, Optional, TypeVar\nfrom urllib import request\nfrom pytube.exceptions import RegexMatchError\nlogger = logging.getLogger(__name__)\n\nclass DeferredGeneratorList:\n    \"\"\"A wrapper class for deferring list generation.\n\n    Pytube has some continuation generators that create web calls, which means\n    that any time a full list is requested, all of those web calls must be\n    made at once, which could lead to slowdowns. This will allow individual\n    elements to be queried, so that slowdowns only happen as necessary. For\n    example, you can iterate over elements in the list without accessing them\n    all simultaneously. This should allow for speed improvements for playlist\n    and channel interactions.\n    \"\"\"\n\n    def __init__(self, generator):\n        \"\"\"Construct a :class:`DeferredGeneratorList <DeferredGeneratorList>`.\n\n        :param generator generator:\n            The deferrable generator to create a wrapper for.\n        :param func func:\n            (Optional) A function to call on the generator items to produce the list.\n        \"\"\"\n        self.gen = generator\n        self._elements = []\n\n    def __eq__(self, other):\n        \"\"\"We want to mimic list behavior for comparison.\"\"\"\n        return list(self) == other\n\n    def __getitem__(self, key) -> Any:\n        \"\"\"Only generate items as they're asked for.\"\"\"\n        if not isinstance(key, (int, slice)):\n            raise TypeError('Key must be either a slice or int.')\n        key_slice = key\n        if isinstance(key, int):\n            key_slice = slice(key, key + 1, 1)\n        while len(self._elements) < key_slice.stop:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                raise IndexError\n            else:\n                self._elements.append(next_item)\n        return self._elements[key]\n\n    def __iter__(self):\n        \"\"\"Custom iterator for dynamically generated list.\"\"\"\n        iter_index = 0\n        while True:\n            try:\n                curr_item = self[iter_index]\n            except IndexError:\n                return\n            else:\n                yield curr_item\n                iter_index += 1\n\n    def __next__(self) -> Any:\n        \"\"\"Fetch next element in iterator.\"\"\"\n        try:\n            curr_element = self[self.iter_index]\n        except IndexError:\n            raise StopIteration\n        self.iter_index += 1\n        return curr_element\n\n    def __len__(self) -> int:\n        \"\"\"Return length of list of all items.\"\"\"\n        self.generate_all()\n        return len(self._elements)\n\n    def __repr__(self) -> str:\n        \"\"\"String representation of all items.\"\"\"\n        self.generate_all()\n        return str(self._elements)\n\n    def __reversed__(self):\n        self.generate_all()\n        return self._elements[::-1]\n\n    def generate_all(self):\n        \"\"\"Generate all items.\"\"\"\n        while True:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                break\n            else:\n                self._elements.append(next_item)\nGenericType = TypeVar('GenericType')\n\ndef install_proxy(proxy_handler: Dict[str, str]) -> None:\n    proxy_support = request.ProxyHandler(proxy_handler)\n    opener = request.build_opener(proxy_support)\n    request.install_opener(opener)\n\ndef generate_all_html_json_mocks():\n    \"\"\"Regenerate the video mock json files for all current test videos.\n\n    This should automatically output to the test/mocks directory.\n    \"\"\"\n    test_vid_ids = ['2lAe1cqCOXo', '5YceQ8YqYMc', 'irauhITDrsE', 'm8uHb5jIGN8', 'QRS8MkLhQmM', 'WXxV9g7lsFE']\n    for vid_id in test_vid_ids:\n        create_mock_html_json(vid_id)",
    "pytube/__main__.py": "\"\"\"\nThis module implements the core developer interface for pytube.\n\nThe problem domain of the :class:`YouTube <YouTube> class focuses almost\nexclusively on the developer interface. Pytube offloads the heavy lifting to\nsmaller peripheral modules and functions.\n\n\"\"\"\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional\nimport pytube\nimport pytube.exceptions as exceptions\nfrom pytube import extract, request\nfrom pytube import Stream, StreamQuery\nfrom pytube.helpers import install_proxy\nfrom pytube.innertube import InnerTube\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.monostate import Monostate\nlogger = logging.getLogger(__name__)\n\nclass YouTube:\n    \"\"\"Core developer interface for pytube.\"\"\"\n\n    def __repr__(self):\n        return f'<pytube.__main__.YouTube object: videoId={self.video_id}>'\n\n    def __eq__(self, o: object) -> bool:\n        return type(o) == type(self) and o.watch_url == self.watch_url\n\n    @property\n    def age_restricted(self):\n        if self._age_restricted:\n            return self._age_restricted\n        self._age_restricted = extract.is_age_restricted(self.watch_html)\n        return self._age_restricted\n\n    @property\n    def js_url(self):\n        if self._js_url:\n            return self._js_url\n        if self.age_restricted:\n            self._js_url = extract.js_url(self.embed_html)\n        else:\n            self._js_url = extract.js_url(self.watch_html)\n        return self._js_url\n\n    @property\n    def initial_data(self):\n        if self._initial_data:\n            return self._initial_data\n        self._initial_data = extract.initial_data(self.watch_html)\n        return self._initial_data\n\n    @property\n    def streaming_data(self):\n        \"\"\"Return streamingData from video info.\"\"\"\n        if 'streamingData' in self.vid_info:\n            return self.vid_info['streamingData']\n        else:\n            self.bypass_age_gate()\n            return self.vid_info['streamingData']\n\n    @property\n    def fmt_streams(self):\n        \"\"\"Returns a list of streams if they have been initialized.\n\n        If the streams have not been initialized, finds all relevant\n        streams and initializes them.\n        \"\"\"\n        self.check_availability()\n        if self._fmt_streams:\n            return self._fmt_streams\n        self._fmt_streams = []\n        stream_manifest = extract.apply_descrambler(self.streaming_data)\n        try:\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        except exceptions.ExtractError:\n            self._js = None\n            self._js_url = None\n            pytube.__js__ = None\n            pytube.__js_url__ = None\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        for stream in stream_manifest:\n            video = Stream(stream=stream, monostate=self.stream_monostate)\n            self._fmt_streams.append(video)\n        self.stream_monostate.title = self.title\n        self.stream_monostate.duration = self.length\n        return self._fmt_streams\n\n    def check_availability(self):\n        \"\"\"Check whether the video is available.\n\n        Raises different exceptions based on why the video is unavailable,\n        otherwise does nothing.\n        \"\"\"\n        status, messages = extract.playability_status(self.watch_html)\n        for reason in messages:\n            if status == 'UNPLAYABLE':\n                if reason == 'Join this channel to get access to members-only content like this video, and other exclusive perks.':\n                    raise exceptions.MembersOnly(video_id=self.video_id)\n                elif reason == 'This live stream recording is not available.':\n                    raise exceptions.RecordingUnavailable(video_id=self.video_id)\n                else:\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LOGIN_REQUIRED':\n                if reason == 'This is a private video. Please sign in to verify that you may see it.':\n                    raise exceptions.VideoPrivate(video_id=self.video_id)\n            elif status == 'ERROR':\n                if reason == 'Video unavailable':\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LIVE_STREAM':\n                raise exceptions.LiveStreamError(video_id=self.video_id)\n\n    def bypass_age_gate(self):\n        \"\"\"Attempt to update the vid_info by bypassing the age gate.\"\"\"\n        innertube = InnerTube(client='ANDROID_EMBED', use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n        innertube_response = innertube.player(self.video_id)\n        playability_status = innertube_response['playabilityStatus'].get('status', None)\n        if playability_status == 'UNPLAYABLE':\n            raise exceptions.AgeRestrictedError(self.video_id)\n        self._vid_info = innertube_response\n\n    @property\n    def caption_tracks(self) -> List[pytube.Caption]:\n        \"\"\"Get a list of :class:`Caption <Caption>`.\n\n        :rtype: List[Caption]\n        \"\"\"\n        raw_tracks = self.vid_info.get('captions', {}).get('playerCaptionsTracklistRenderer', {}).get('captionTracks', [])\n        return [pytube.Caption(track) for track in raw_tracks]\n\n    @property\n    def captions(self) -> pytube.CaptionQuery:\n        \"\"\"Interface to query caption tracks.\n\n        :rtype: :class:`CaptionQuery <CaptionQuery>`.\n        \"\"\"\n        return pytube.CaptionQuery(self.caption_tracks)\n\n    @property\n    def streams(self) -> StreamQuery:\n        \"\"\"Interface to query both adaptive (DASH) and progressive streams.\n\n        :rtype: :class:`StreamQuery <StreamQuery>`.\n        \"\"\"\n        self.check_availability()\n        return StreamQuery(self.fmt_streams)\n\n    @property\n    def thumbnail_url(self) -> str:\n        \"\"\"Get the thumbnail url image.\n\n        :rtype: str\n        \"\"\"\n        thumbnail_details = self.vid_info.get('videoDetails', {}).get('thumbnail', {}).get('thumbnails')\n        if thumbnail_details:\n            thumbnail_details = thumbnail_details[-1]\n            return thumbnail_details['url']\n        return f'https://img.youtube.com/vi/{self.video_id}/maxresdefault.jpg'\n\n    @property\n    def publish_date(self):\n        \"\"\"Get the publish date.\n\n        :rtype: datetime\n        \"\"\"\n        if self._publish_date:\n            return self._publish_date\n        self._publish_date = extract.publish_date(self.watch_html)\n        return self._publish_date\n\n    @publish_date.setter\n    def publish_date(self, value):\n        \"\"\"Sets the publish date.\"\"\"\n        self._publish_date = value\n\n    @property\n    def title(self) -> str:\n        \"\"\"Get the video title.\n\n        :rtype: str\n        \"\"\"\n        if self._title:\n            return self._title\n        try:\n            self._title = self.vid_info['videoDetails']['title']\n        except KeyError:\n            self.check_availability()\n            raise exceptions.PytubeError(f'Exception while accessing title of {self.watch_url}. Please file a bug report at https://github.com/pytube/pytube')\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Sets the title value.\"\"\"\n        self._title = value\n\n    @property\n    def description(self) -> str:\n        \"\"\"Get the video description.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('shortDescription')\n\n    @property\n    def rating(self) -> float:\n        \"\"\"Get the video average rating.\n\n        :rtype: float\n\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('averageRating')\n\n    @property\n    def length(self) -> int:\n        \"\"\"Get the video length in seconds.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('lengthSeconds'))\n\n    @property\n    def views(self) -> int:\n        \"\"\"Get the number of the times the video has been viewed.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('viewCount'))\n\n    @property\n    def author(self) -> str:\n        \"\"\"Get the video author.\n        :rtype: str\n        \"\"\"\n        if self._author:\n            return self._author\n        self._author = self.vid_info.get('videoDetails', {}).get('author', 'unknown')\n        return self._author\n\n    @author.setter\n    def author(self, value):\n        \"\"\"Set the video author.\"\"\"\n        self._author = value\n\n    @property\n    def keywords(self) -> List[str]:\n        \"\"\"Get the video keywords.\n\n        :rtype: List[str]\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('keywords', [])\n\n    @property\n    def channel_id(self) -> str:\n        \"\"\"Get the video poster's channel id.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('channelId', None)\n\n    @property\n    def channel_url(self) -> str:\n        \"\"\"Construct the channel url for the video's poster from the channel id.\n\n        :rtype: str\n        \"\"\"\n        return f'https://www.youtube.com/channel/{self.channel_id}'\n\n    @property\n    def metadata(self) -> Optional[YouTubeMetadata]:\n        \"\"\"Get the metadata for the video.\n\n        :rtype: YouTubeMetadata\n        \"\"\"\n        if self._metadata:\n            return self._metadata\n        else:\n            self._metadata = extract.metadata(self.initial_data)\n            return self._metadata\n\n    def register_on_progress_callback(self, func: Callable[[Any, bytes, int], None]):\n        \"\"\"Register a download progress callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream``, ``chunk``,\n             and ``bytes_remaining`` as parameters.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_progress = func\n\n    def register_on_complete_callback(self, func: Callable[[Any, Optional[str]], None]):\n        \"\"\"Register a download complete callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream`` and  ``file_path``.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_complete = func\n\n    @staticmethod\n    def from_id(video_id: str) -> 'YouTube':\n        \"\"\"Construct a :class:`YouTube <YouTube>` object from a video id.\n\n        :param str video_id:\n            The video id of the YouTube video.\n\n        :rtype: :class:`YouTube <YouTube>`\n        \n        \"\"\"\n        return YouTube(f'https://www.youtube.com/watch?v={video_id}')",
    "pytube/exceptions.py": "\"\"\"Library specific exception definitions.\"\"\"\nfrom typing import Pattern, Union\n\nclass PytubeError(Exception):\n    \"\"\"Base pytube exception that all others inherit.\n\n    This is done to not pollute the built-in exceptions, which *could* result\n    in unintended errors being unexpectedly and incorrectly handled within\n    implementers code.\n    \"\"\"\n\nclass MaxRetriesExceeded(PytubeError):\n    \"\"\"Maximum number of retries exceeded.\"\"\"\n\nclass HTMLParseError(PytubeError):\n    \"\"\"HTML could not be parsed\"\"\"\n\nclass ExtractError(PytubeError):\n    \"\"\"Data extraction based exception.\"\"\"\n\nclass RegexMatchError(ExtractError):\n    \"\"\"Regex pattern did not return any matches.\"\"\"\n\nclass VideoUnavailable(PytubeError):\n    \"\"\"Base video unavailable error.\"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.error_string)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is unavailable'\n\nclass AgeRestrictedError(VideoUnavailable):\n    \"\"\"Video is age restricted, and cannot be accessed without OAuth.\"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f\"{self.video_id} is age restricted, and can't be accessed without logging in.\"\n\nclass LiveStreamError(VideoUnavailable):\n    \"\"\"Video is a live stream.\"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is streaming live and cannot be loaded'\n\nclass VideoPrivate(VideoUnavailable):\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a private video'\n\nclass RecordingUnavailable(VideoUnavailable):\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} does not have a live stream recording available'\n\nclass MembersOnly(VideoUnavailable):\n    \"\"\"Video is members-only.\n\n    YouTube has special videos that are only viewable to users who have\n    subscribed to a content creator.\n    ref: https://support.google.com/youtube/answer/7544492?hl=en\n    \"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a members-only video'\n\nclass VideoRegionBlocked(VideoUnavailable):\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is not available in your region'"
  }
}