{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_package",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_package.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData\nfrom mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.structures.package import Package\n\n\nclass TestPackage:\n    def test_init(self) -> None:\n        package = Package(Boto3StubsPackageData, [ServiceNameCatalog.s3], version=\"2.3.4\")\n        assert package.directory_name == \"boto3_stubs_package\"\n        assert package.min_library_version\n        assert package.max_library_version\n        assert package.get_local_doc_link() == \"https://youtype.github.io/boto3_stubs_docs/\"\n        assert (\n            package.get_local_doc_link(ServiceNameCatalog.s3)\n            == \"https://youtype.github.io/boto3_stubs_docs/mypy_boto3_s3/\"\n        )\n        assert package.get_module_name(ServiceNameCatalog.s3) == \"mypy_boto3_s3\"\n        assert package.get_service_pypi_name(ServiceNameCatalog.s3) == \"mypy-boto3-s3\"\n        assert package.min_python_version\n        package.library_version = \"1.2.3\"\n        assert str(package) == \"boto3-stubs 2.3.4 (boto3 1.2.3)\"\n\n    def test_service_name(self) -> None:\n        package = Package(Boto3StubsPackageData, [ServiceNameCatalog.s3])\n        assert package.service_name == ServiceNameCatalog.s3\n\n        package.service_names = (*package.service_names, ServiceNameCatalog.ec2)\n        with pytest.raises(StructureError):\n            _ = package.service_name\n\n    def test_get_classifiers(self) -> None:\n        package = Package(Boto3StubsPackageData, [ServiceNameCatalog.s3])\n        classifiers = package.get_classifiers()\n        assert \"Programming Language :: Python :: 3\" in classifiers\n        assert \"Programming Language :: Python :: 3.13\" in classifiers\n        assert \"Programming Language :: Python :: 3 :: Only\" in classifiers\n",
  "GT_file_code": {
    "mypy_boto3_builder/package_data.py": "\"\"\"\nPyPI package data constants.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport typing\nfrom typing import ClassVar\n\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.version_getters import (\n    get_aioboto3_version,\n    get_aiobotocore_version,\n    get_boto3_version,\n    get_botocore_version,\n)\n\n\nclass BasePackageData:\n    \"\"\"\n    Generic package data.\n    \"\"\"\n\n    NAME: ClassVar[str] = \"boto3-stubs\"\n    PYPI_NAME: ClassVar[str] = \"boto3-stubs\"\n    PYPI_STUBS_NAME: ClassVar[str] = \"\"\n    PYPI_LITE_NAME: ClassVar[str] = \"\"\n    PYPI_FULL_NAME: ClassVar[str] = \"\"\n    LIBRARY_NAME: ClassVar[str] = \"boto3\"\n    SERVICE_PREFIX: ClassVar[str] = \"mypy_boto3\"\n    SERVICE_PYPI_PREFIX: ClassVar[str] = \"mypy-boto3\"\n    LOCAL_DOC_LINK: ClassVar[str] = \"https://youtype.github.io/boto3_stubs_docs/\"\n    IS_VSCODE_SUPPORTED: ClassVar[bool] = False\n    IS_CONDA_FORGE_SUPPORTED: ClassVar[bool] = False\n\n    @classmethod\n    def get_service_package_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package name.\n        \"\"\"\n        return f\"{cls.SERVICE_PREFIX}_{service_name.underscore_name}\"\n\n    @classmethod\n    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package PyPI name.\n        \"\"\"\n        return f\"{cls.SERVICE_PYPI_PREFIX}-{service_name.name}\"\n\n    @staticmethod\n    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_boto3_version()\n\n    @staticmethod\n    def get_botocore_version() -> str:\n        \"\"\"\n        Get underlying botocore version.\n        \"\"\"\n        return get_botocore_version()\n\n    @classmethod\n    def has_pypi_lite_package(cls) -> bool:\n        \"\"\"\n        Check if package has lite version.\n        \"\"\"\n        return bool(cls.PYPI_LITE_NAME)\n\n\nclass TypesAioBotocorePackageData(BasePackageData):\n    \"\"\"\n    types-aiobotocore package data.\n    \"\"\"\n\n    NAME = \"aiobotocore-stubs\"\n    PYPI_NAME = \"types-aiobotocore\"\n    PYPI_STUBS_NAME = \"types-aiobotocore\"\n    PYPI_LITE_NAME = \"types-aiobotocore-lite\"\n    PYPI_FULL_NAME = \"types-aiobotocore-full\"\n    LIBRARY_NAME = \"aiobotocore\"\n    SERVICE_PREFIX = \"types_aiobotocore\"\n    SERVICE_PYPI_PREFIX = \"types-aiobotocore\"\n    LOCAL_DOC_LINK = \"https://youtype.github.io/types_aiobotocore_docs/\"\n\n    @staticmethod\n    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_aiobotocore_version()\n\n\nclass TypesAioBotocoreLitePackageData(TypesAioBotocorePackageData):\n    \"\"\"\n    types-aiobotocore-lite package data.\n    \"\"\"\n\n    PYPI_NAME = \"types-aiobotocore-lite\"\n    PYPI_LITE_NAME = \"\"\n\n\nclass TypesAioBotocoreFullPackageData(TypesAioBotocorePackageData):\n    \"\"\"\n    types-aiobotocore-full package data.\n    \"\"\"\n\n    NAME = \"\"\n    PYPI_NAME = \"types-aiobotocore-full\"\n    IS_CONDA_FORGE_SUPPORTED = False\n\n    @typing.override\n    @classmethod\n    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package PyPI name.\n        \"\"\"\n        return cls.PYPI_NAME\n\n\nclass Boto3StubsPackageData(BasePackageData):\n    \"\"\"\n    boto3-stubs package data.\n    \"\"\"\n\n    NAME = \"boto3-stubs\"\n    PYPI_NAME = \"boto3-stubs\"\n    PYPI_STUBS_NAME = \"boto3-stubs\"\n    PYPI_LITE_NAME = \"boto3-stubs-lite\"\n    PYPI_FULL_NAME = \"boto3-stubs-full\"\n    LIBRARY_NAME = \"boto3\"\n    LOCAL_DOC_LINK = \"https://youtype.github.io/boto3_stubs_docs/\"\n    IS_VSCODE_SUPPORTED = True\n    IS_CONDA_FORGE_SUPPORTED = True\n\n\nclass Boto3StubsLitePackageData(Boto3StubsPackageData):\n    \"\"\"\n    boto3-stubs-lite package data.\n    \"\"\"\n\n    PYPI_NAME = \"boto3-stubs-lite\"\n    PYPI_LITE_NAME = \"\"\n\n\nclass Boto3StubsFullPackageData(Boto3StubsPackageData):\n    \"\"\"\n    boto3-stubs-full package data.\n    \"\"\"\n\n    NAME = \"\"\n    PYPI_NAME = \"boto3-stubs-full\"\n    IS_CONDA_FORGE_SUPPORTED = False\n\n    @typing.override\n    @classmethod\n    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package PyPI name.\n        \"\"\"\n        return cls.PYPI_NAME\n\n\nclass MypyBoto3PackageData(BasePackageData):\n    \"\"\"\n    mypy-boto3 package data.\n    \"\"\"\n\n    NAME = \"mypy_boto3\"\n    PYPI_NAME = \"mypy-boto3\"\n    LIBRARY_NAME = \"boto3\"\n\n\nclass TypesAioBoto3PackageData(BasePackageData):\n    \"\"\"\n    types-aioboto3 package data.\n    \"\"\"\n\n    NAME = \"aioboto3-stubs\"\n    PYPI_NAME = \"types-aioboto3\"\n    PYPI_STUBS_NAME = \"types-aioboto3\"\n    PYPI_LITE_NAME = \"types-aioboto3-lite\"\n    PYPI_FULL_NAME = \"types-aiobotocore-full\"\n    LIBRARY_NAME = \"aioboto3\"\n    SERVICE_PREFIX = \"types_aiobotocore\"\n    SERVICE_PYPI_PREFIX = \"types-aiobotocore\"\n    AIOBOTOCORE_NAME = \"types-aiobotocore\"\n    LOCAL_DOC_LINK = \"https://youtype.github.io/types_aioboto3_docs/\"\n\n    @staticmethod\n    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_aioboto3_version()\n\n\nclass TypesAioBoto3LitePackageData(TypesAioBoto3PackageData):\n    \"\"\"\n    types-aioboto3-lite package data.\n    \"\"\"\n\n    PYPI_NAME = \"types-aioboto3-lite\"\n    PYPI_LITE_NAME = \"\"\n    AIOBOTOCORE_NAME = \"types-aiobotocore-lite\"\n",
    "mypy_boto3_builder/structures/package_url.py": "\"\"\"\nPackage links structure.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.utils.strings import get_pypi_link\n\n\nclass PackageURL:\n    \"\"\"\n    Package links structure.\n    \"\"\"\n\n    def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:\n        self.pypi_name = pypi_name\n        self.data = data\n\n    @property\n    def pypi_badge(self) -> str:\n        \"\"\"\n        Package name badge from shields.io.\n        \"\"\"\n        return f\"https://img.shields.io/pypi/v/{self.pypi_name}.svg?color=blue\"\n\n    @property\n    def pyversions_badge(self) -> str:\n        \"\"\"\n        Package Python version badge from shields.io.\n        \"\"\"\n        return f\"https://img.shields.io/pypi/pyversions/{self.pypi_name}.svg?color=blue\"\n\n    @property\n    def rtd_badge(self) -> str:\n        \"\"\"\n        ReadTheDocs badge from shields.io.\n        \"\"\"\n        return \"https://img.shields.io/readthedocs/boto3-stubs.svg?color=blue\"\n\n    @property\n    def pepy_badge(self) -> str:\n        \"\"\"\n        PePy total downloads badge.\n        \"\"\"\n        return f\"https://static.pepy.tech/badge/{self.pypi_name}\"\n\n    @property\n    def montly_downloads_badge(self) -> str:\n        \"\"\"\n        PyPi monthly downloads badge.\n        \"\"\"\n        return f\"https://img.shields.io/pypi/dm/{self.pypi_name}?color=blue\"\n\n    @property\n    def pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI.\n        \"\"\"\n        return get_pypi_link(self.pypi_name)\n\n    @property\n    def library_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI underlying library.\n        \"\"\"\n        return get_pypi_link(self.data.LIBRARY_NAME)\n\n    @property\n    def stubs_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI lite version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_STUBS_NAME)\n\n    @property\n    def stubs_lite_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI lite version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_LITE_NAME)\n\n    @property\n    def stubs_full_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI full version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_FULL_NAME)\n\n    @property\n    def pepy(self) -> str:\n        \"\"\"\n        PePy project link.\n        \"\"\"\n        return f\"https://pepy.tech/project/{self.pypi_name}\"\n\n    @property\n    def pypistats(self) -> str:\n        \"\"\"\n        PePy project link.\n        \"\"\"\n        return f\"https://pypistats.org/packages/{self.pypi_name}\"\n\n    @property\n    def docs(self) -> str:\n        \"\"\"\n        Documentation link.\n        \"\"\"\n        return self.data.LOCAL_DOC_LINK\n",
    "mypy_boto3_builder/structures/package.py": "\"\"\"\nParent class for all package structures.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\n\nfrom packaging.version import InvalidVersion, Version\n\nfrom mypy_boto3_builder.constants import SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.package_url import PackageURL\nfrom mypy_boto3_builder.utils.version import (\n    get_max_build_version,\n    get_min_build_version,\n)\n\n\nclass Package:\n    \"\"\"\n    Parent class for all package structures.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: type[BasePackageData],\n        service_names: Iterable[ServiceName] = (),\n        version: str = \"\",\n    ) -> None:\n        self.data = data\n        self._pypi_name = self.data.PYPI_NAME\n        self.library_version = data.get_library_version()\n        self.botocore_version = data.get_botocore_version()\n        self._version: str = \"\"\n        if version:\n            self.version = version\n        self.service_names = tuple(service_names)\n        self.logger = get_logger()\n        self.url = PackageURL(self.pypi_name, self.data)\n\n    @property\n    def pypi_name(self) -> str:\n        \"\"\"\n        PyPI package name.\n        \"\"\"\n        return self._pypi_name\n\n    @pypi_name.setter\n    def pypi_name(self, value: str) -> None:\n        self._pypi_name = value\n        self.url.pypi_name = value\n\n    @property\n    def version(self) -> str:\n        \"\"\"\n        Package version.\n        \"\"\"\n        if not self._version:\n            raise StructureError(f\"Version is not set for {self.pypi_name}\")\n        return self._version\n\n    @version.setter\n    def version(self, value: str) -> None:\n        try:\n            Version(value)\n        except InvalidVersion:\n            raise StructureError(f\"Invalid version: {value}\") from None\n        self._version = value\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Package name.\n        \"\"\"\n        if not self.data.NAME:\n            raise StructureError(f\"Package name is not set for {self.pypi_name}\")\n\n        return self.data.NAME\n\n    @property\n    def library_name(self) -> str:\n        \"\"\"\n        PyPI library package name.\n        \"\"\"\n        return self.data.LIBRARY_NAME\n\n    def has_main_package(self) -> bool:\n        \"\"\"\n        Check if package has main package.\n        \"\"\"\n        return bool(self.data.NAME)\n\n    @property\n    def service_name(self) -> ServiceName:\n        \"\"\"\n        Service name for the package.\n        \"\"\"\n        if len(self.service_names) != 1:\n            raise StructureError(f\"Package {self.name} has more than one service name\")\n        return self.service_names[0]\n\n    @property\n    def directory_name(self) -> str:\n        \"\"\"\n        Directory name to store generated package.\n        \"\"\"\n        underscore_package_name = self.pypi_name.replace(\"-\", \"_\")\n        return f\"{underscore_package_name}_package\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get string representation for debugging.\n        \"\"\"\n        return f\"{self.name} {self._version} ({self.library_name} {self.library_version})\"\n\n    def get_local_doc_link(self, service_name: ServiceName | None = None) -> str:\n        \"\"\"\n        Get link to local docs.\n        \"\"\"\n        url = self.data.LOCAL_DOC_LINK\n        if service_name:\n            url = f\"{url}{self.get_module_name(service_name)}/\"\n        return url\n\n    def get_module_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service module name.\n        \"\"\"\n        return self.data.get_service_package_name(service_name)\n\n    def get_service_pypi_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get PyPI package name for a service package.\n        \"\"\"\n        return self.data.get_service_pypi_name(service_name)\n\n    @property\n    def min_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_min_build_version(self.library_version)\n\n    @property\n    def max_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_max_build_version(self.library_version)\n\n    @property\n    def min_python_version(self) -> str:\n        \"\"\"\n        Minimum required python version.\n        \"\"\"\n        min_version = min(SUPPORTED_PY_VERSIONS)\n        return \".\".join(str(i) for i in min_version)\n\n    def get_classifiers(self) -> list[str]:\n        \"\"\"\n        Get classifiers for package.\n        \"\"\"\n        result = [\n            \"Development Status :: 5 - Production/Stable\",\n            \"Intended Audience :: Developers\",\n            \"Environment :: Console\",\n            \"License :: OSI Approved :: MIT License\",\n            \"Natural Language :: English\",\n            \"Operating System :: OS Independent\",\n        ]\n        major_versions = {version[0] for version in SUPPORTED_PY_VERSIONS}\n        for major in sorted(major_versions):\n            result.append(f\"Programming Language :: Python :: {major}\")\n            minor_versions = {\n                version[1]\n                for version in SUPPORTED_PY_VERSIONS\n                if version[0] == major and len(version) > 1\n            }\n            result.extend(\n                f\"Programming Language :: Python :: {major}.{minor}\"\n                for minor in sorted(minor_versions)\n            )\n        if len(major_versions) == 1:\n            major = next(iter(major_versions))\n            result.append(f\"Programming Language :: Python :: {major} :: Only\")\n        result.extend(\n            (\n                \"Programming Language :: Python :: Implementation :: CPython\",\n                \"Typing :: Stubs Only\",\n            ),\n        )\n        return result\n",
    "mypy_boto3_builder/utils/version.py": "\"\"\"\nVersion-related utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport contextlib\nimport importlib.metadata\nfrom collections.abc import Iterable\n\nfrom packaging.version import Version\n\nfrom mypy_boto3_builder.constants import PACKAGE_NAME\n\n\ndef get_builder_version() -> str:\n    \"\"\"\n    Get program version.\n    \"\"\"\n    with contextlib.suppress(importlib.metadata.PackageNotFoundError):\n        return importlib.metadata.version(PACKAGE_NAME)\n\n    return \"0.0.0\"\n\n\ndef get_min_build_version(version: str) -> str:\n    \"\"\"\n    Get min version build version by setting micro to 0.\n    \"\"\"\n    major, minor, _ = Version(version).release\n    return f\"{major}.{minor}.0\"\n\n\ndef get_release_version(version: str) -> str:\n    \"\"\"\n    Get release version by removing post.\n    \"\"\"\n    return Version(version).base_version\n\n\ndef get_max_build_version(version: str) -> str:\n    \"\"\"\n    Get min version build version by bumping minor.\n    \"\"\"\n    major, minor, _ = Version(version).release\n    return f\"{major}.{minor + 1}.0\"\n\n\ndef bump_postrelease(version: str) -> str:\n    \"\"\"\n    Bump postrelease version.\n    \"\"\"\n    v = Version(version)\n    major, minor, patch = v.release\n    post = (v.post + 1) if v.post else 1\n    return f\"{major}.{minor}.{patch}.post{post}\"\n\n\ndef sort_versions(version_list: Iterable[str]) -> list[str]:\n    \"\"\"\n    Sort version list.\n    \"\"\"\n    return sorted(version_list, key=Version)\n",
    "mypy_boto3_builder/utils/version_getters.py": "\"\"\"\nUtils for getting underlying package versions.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\n\nfrom mypy_boto3_builder.exceptions import BuildEnvError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.pypi_manager import PyPIManager\n\n\ndef get_botocore_version() -> str:\n    \"\"\"\n    Get botocore package version.\n    \"\"\"\n    try:\n        from botocore import __version__ as version  # noqa: PLC0415\n    except ImportError as e:\n        raise BuildEnvError(\"botocore is not installed\") from e\n    return f\"{version}\"\n\n\ndef get_boto3_version() -> str:\n    \"\"\"\n    Get boto3 package version.\n    \"\"\"\n    try:\n        from boto3 import __version__ as version  # noqa: PLC0415\n    except ImportError as e:\n        raise BuildEnvError(\"boto3 is not installed\") from e\n    return f\"{version}\"\n\n\n@functools.cache\ndef get_aiobotocore_version() -> str:\n    \"\"\"\n    Get aiobotocore package version.\n    \"\"\"\n    try:\n        from aiobotocore import __version__ as version  # type: ignore  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        return f\"{version}\"\n\n    logger = get_logger()\n    logger.warning(\"aiobotocore is not installed, using latest version from PyPI\")\n    pypi_manager = PyPIManager(\"aiobotocore\")\n    return pypi_manager.get_latest_stable_version()\n\n\n@functools.cache\ndef get_aioboto3_version() -> str:\n    \"\"\"\n    Get aioboto3 package version.\n    \"\"\"\n    try:\n        from aioboto3 import __version__ as version  # type: ignore  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        return f\"{version}\"\n\n    logger = get_logger()\n    logger.warning(\"aioboto3 is not installed, using latest version from PyPI\")\n    pypi_manager = PyPIManager(\"aioboto3\")\n    return pypi_manager.get_latest_stable_version()\n",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport logging\n\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n\n__all__ = (\"get_logger\",)\n\n\ndef get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/package_data.py": {
      "BasePackageData.get_service_package_name": {
        "code": "    def get_service_package_name(cls, service_name: ServiceName) -> str:\n        \"\"\"Generate the package name for a specific AWS service.\n\nParameters:\n- cls: Type[BasePackageData] - The class that calls this method. It typically represents a specific package of AWS service data that inherits from BasePackageData.\n- service_name: ServiceName - An instance of the ServiceName class, which contains information about the AWS service, including its underscored name.\n\nReturns:\n- str: A string that combines the class's SERVICE_PREFIX with the underscored name of the given service, formatted as '{SERVICE_PREFIX}_{service_name.underscore_name}'.\n\nThis method relies on the SERVICE_PREFIX constant defined in the BasePackageData class, which is a class variable intended to prefix the package names for different AWS services.\"\"\"\n        '\\n        Get service package name.\\n        '\n        return f'{cls.SERVICE_PREFIX}_{service_name.underscore_name}'",
        "docstring": "Generate the package name for a specific AWS service.\n\nParameters:\n- cls: Type[BasePackageData] - The class that calls this method. It typically represents a specific package of AWS service data that inherits from BasePackageData.\n- service_name: ServiceName - An instance of the ServiceName class, which contains information about the AWS service, including its underscored name.\n\nReturns:\n- str: A string that combines the class's SERVICE_PREFIX with the underscored name of the given service, formatted as '{SERVICE_PREFIX}_{service_name.underscore_name}'.\n\nThis method relies on the SERVICE_PREFIX constant defined in the BasePackageData class, which is a class variable intended to prefix the package names for different AWS services.",
        "signature": "def get_service_package_name(cls, service_name: ServiceName) -> str:",
        "type": "Method",
        "class_signature": "class BasePackageData:"
      },
      "BasePackageData.get_service_pypi_name": {
        "code": "    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"Get the service package PyPI name for a given AWS service.\n\nParameters:\n- cls: The class calling the method, which inherits from BasePackageData.\n- service_name (ServiceName): An instance of the ServiceName enum that provides the name of the AWS service, used to construct the PyPI package name.\n\nReturns:\n- str: The PyPI name of the service package, formatted as \"{cls.SERVICE_PYPI_PREFIX}-{service_name.name}\".\n\nDependencies:\n- This method relies on the constant cls.SERVICE_PYPI_PREFIX, which is defined in the BasePackageData class and serves as the prefix for the PyPI package names of the defined AWS services.\"\"\"\n        '\\n        Get service package PyPI name.\\n        '\n        return f'{cls.SERVICE_PYPI_PREFIX}-{service_name.name}'",
        "docstring": "Get the service package PyPI name for a given AWS service.\n\nParameters:\n- cls: The class calling the method, which inherits from BasePackageData.\n- service_name (ServiceName): An instance of the ServiceName enum that provides the name of the AWS service, used to construct the PyPI package name.\n\nReturns:\n- str: The PyPI name of the service package, formatted as \"{cls.SERVICE_PYPI_PREFIX}-{service_name.name}\".\n\nDependencies:\n- This method relies on the constant cls.SERVICE_PYPI_PREFIX, which is defined in the BasePackageData class and serves as the prefix for the PyPI package names of the defined AWS services.",
        "signature": "def get_service_pypi_name(cls, service_name: ServiceName) -> str:",
        "type": "Method",
        "class_signature": "class BasePackageData:"
      },
      "BasePackageData.get_library_version": {
        "code": "    def get_library_version() -> str:\n        \"\"\"Get the version of the underlying Boto3 library.\n\nThis static method retrieves the version string of the Boto3 library using the `get_boto3_version` utility function imported from the `mypy_boto3_builder.utils.version_getters` module. It does not take any parameters and returns a string representing the library version. This method is typically used by subclasses to provide versioning details for specific package data representations related to Boto3 and its stubs.\"\"\"\n        '\\n        Get underlying library version.\\n        '\n        return get_boto3_version()",
        "docstring": "Get the version of the underlying Boto3 library.\n\nThis static method retrieves the version string of the Boto3 library using the `get_boto3_version` utility function imported from the `mypy_boto3_builder.utils.version_getters` module. It does not take any parameters and returns a string representing the library version. This method is typically used by subclasses to provide versioning details for specific package data representations related to Boto3 and its stubs.",
        "signature": "def get_library_version() -> str:",
        "type": "Method",
        "class_signature": "class BasePackageData:"
      },
      "BasePackageData.get_botocore_version": {
        "code": "    def get_botocore_version() -> str:\n        \"\"\"Get the underlying version of the botocore library.\n\nThis static method serves to retrieve the current version of the botocore library, which is a key dependency for the AWS SDK for Python (Boto3). The function calls the helper method `get_botocore_version` imported from `mypy_boto3_builder.utils.version_getters`, which encapsulates the logic for determining the version.\n\nReturns:\n    str: The version of the botocore library as a string.\"\"\"\n        '\\n        Get underlying botocore version.\\n        '\n        return get_botocore_version()",
        "docstring": "Get the underlying version of the botocore library.\n\nThis static method serves to retrieve the current version of the botocore library, which is a key dependency for the AWS SDK for Python (Boto3). The function calls the helper method `get_botocore_version` imported from `mypy_boto3_builder.utils.version_getters`, which encapsulates the logic for determining the version.\n\nReturns:\n    str: The version of the botocore library as a string.",
        "signature": "def get_botocore_version() -> str:",
        "type": "Method",
        "class_signature": "class BasePackageData:"
      }
    },
    "mypy_boto3_builder/structures/package_url.py": {
      "PackageURL.__init__": {
        "code": "    def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:\n        \"\"\"Initialize a PackageURL instance.\n\nParameters:\n- pypi_name (str): The name of the package on PyPI, which will be used to generate various badge and link URLs.\n- data (type[BasePackageData]): A class that inherits from BasePackageData which provides metadata and constants related to the package, such as library names and documentation links.\n\nThis constructor sets the instance attributes `pypi_name` and `data`, enabling other methods and properties of the class to construct URLs for package badges, PyPI links, and download statistics based on the provided package name and associated data.\"\"\"\n        self.pypi_name = pypi_name\n        self.data = data",
        "docstring": "Initialize a PackageURL instance.\n\nParameters:\n- pypi_name (str): The name of the package on PyPI, which will be used to generate various badge and link URLs.\n- data (type[BasePackageData]): A class that inherits from BasePackageData which provides metadata and constants related to the package, such as library names and documentation links.\n\nThis constructor sets the instance attributes `pypi_name` and `data`, enabling other methods and properties of the class to construct URLs for package badges, PyPI links, and download statistics based on the provided package name and associated data.",
        "signature": "def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:",
        "type": "Method",
        "class_signature": "class PackageURL:"
      }
    },
    "mypy_boto3_builder/structures/package.py": {
      "Package.__init__": {
        "code": "    def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:\n        \"\"\"Initializes a Package instance, setting up properties related to the package structure based on provided data.\n\nParameters:\n- data (type[BasePackageData]): The package data class that contains essential information such as PyPI name and library versions.\n- service_names (Iterable[ServiceName], optional): A tuple of service names associated with the package (default is an empty tuple).\n- version (str, optional): The package version, which will be validated and assigned if provided (default is an empty string).\n\nAttributes initialized:\n- self.data: Holds the provided package data.\n- self._pypi_name: The name of the package on PyPI, retrieved from data.\n- self.library_version: The version of the library, obtained from the data instance method.\n- self.botocore_version: The version of botocore, also obtained from data.\n- self._version: A private attribute to store the package version, initialized to an empty string.\n- self.service_names: A tuple of service names, converted from the input iterable.\n- self.logger: Logger instance obtained from the get_logger() function for logging purposes.\n- self.url: A PackageURL instance initialized with the PyPI name and data for constructing package URLs.\n\nThis constructor validates the version input and raises a StructureError if the version is invalid, while providing structured representation and attributes for managing package-related data effectively.\"\"\"\n        self.data = data\n        self._pypi_name = self.data.PYPI_NAME\n        self.library_version = data.get_library_version()\n        self.botocore_version = data.get_botocore_version()\n        self._version: str = ''\n        if version:\n            self.version = version\n        self.service_names = tuple(service_names)\n        self.logger = get_logger()\n        self.url = PackageURL(self.pypi_name, self.data)",
        "docstring": "Initializes a Package instance, setting up properties related to the package structure based on provided data.\n\nParameters:\n- data (type[BasePackageData]): The package data class that contains essential information such as PyPI name and library versions.\n- service_names (Iterable[ServiceName], optional): A tuple of service names associated with the package (default is an empty tuple).\n- version (str, optional): The package version, which will be validated and assigned if provided (default is an empty string).\n\nAttributes initialized:\n- self.data: Holds the provided package data.\n- self._pypi_name: The name of the package on PyPI, retrieved from data.\n- self.library_version: The version of the library, obtained from the data instance method.\n- self.botocore_version: The version of botocore, also obtained from data.\n- self._version: A private attribute to store the package version, initialized to an empty string.\n- self.service_names: A tuple of service names, converted from the input iterable.\n- self.logger: Logger instance obtained from the get_logger() function for logging purposes.\n- self.url: A PackageURL instance initialized with the PyPI name and data for constructing package URLs.\n\nThis constructor validates the version input and raises a StructureError if the version is invalid, while providing structured representation and attributes for managing package-related data effectively.",
        "signature": "def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.pypi_name": {
        "code": "    def pypi_name(self, value: str) -> None:\n        \"\"\"Setter for the PyPI package name. This method sets the internal attribute _pypi_name and updates the associated PackageURL instance's pypi_name property.\n\nParameters:\n- value (str): The new name to set for the PyPI package.\n\nReturns:\n- None: This method does not return any value.\n\nSide Effects:\n- Updates the internal state of the Package instance by changing the _pypi_name attribute.\n- Modifies the pypi_name attribute of the PackageURL instance associated with the Package.\n\nThe _pypi_name is used as the unique identifier for the package in the Python Package Index (PyPI), which is essential for managing the package's distribution and installation.\"\"\"\n        self._pypi_name = value\n        self.url.pypi_name = value",
        "docstring": "Setter for the PyPI package name. This method sets the internal attribute _pypi_name and updates the associated PackageURL instance's pypi_name property.\n\nParameters:\n- value (str): The new name to set for the PyPI package.\n\nReturns:\n- None: This method does not return any value.\n\nSide Effects:\n- Updates the internal state of the Package instance by changing the _pypi_name attribute.\n- Modifies the pypi_name attribute of the PackageURL instance associated with the Package.\n\nThe _pypi_name is used as the unique identifier for the package in the Python Package Index (PyPI), which is essential for managing the package's distribution and installation.",
        "signature": "def pypi_name(self, value: str) -> None:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.version": {
        "code": "    def version(self, value: str) -> None:\n        \"\"\"Set the package version after validating it.\n\nParameters:\n- value (str): The version string to set for the package. This string must be a valid version as per the `packaging.version.Version` standards.\n\nRaises:\n- StructureError: If the provided version string is invalid, indicating that it does not conform to the expected version format.\n\nThis method interacts with the `Version` class from the `packaging.version` module to ensure that the version string is valid. If the version is valid, it is stored in a private attribute `_version` of the `Package` class.\"\"\"\n        try:\n            Version(value)\n        except InvalidVersion:\n            raise StructureError(f'Invalid version: {value}') from None\n        self._version = value",
        "docstring": "Set the package version after validating it.\n\nParameters:\n- value (str): The version string to set for the package. This string must be a valid version as per the `packaging.version.Version` standards.\n\nRaises:\n- StructureError: If the provided version string is invalid, indicating that it does not conform to the expected version format.\n\nThis method interacts with the `Version` class from the `packaging.version` module to ensure that the version string is valid. If the version is valid, it is stored in a private attribute `_version` of the `Package` class.",
        "signature": "def version(self, value: str) -> None:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.name": {
        "code": "    def name(self) -> str:\n        \"\"\"Returns the name of the package.\n\nThis property retrieves the package name from the `data` attribute, which is an instance of `BasePackageData`. If the package name is not set (i.e., `data.NAME` is falsy), it raises a `StructureError` indicating that the package name is not defined for the given PyPI name (`self.pypi_name`). The `pypi_name` is derived from the `data` attribute and represents the name used in the Python Package Index (PyPI).\n\nReturns:\n    str: The package name.\n\nRaises:\n    StructureError: If the package name is not set in `data.NAME`.\"\"\"\n        '\\n        Package name.\\n        '\n        if not self.data.NAME:\n            raise StructureError(f'Package name is not set for {self.pypi_name}')\n        return self.data.NAME",
        "docstring": "Returns the name of the package.\n\nThis property retrieves the package name from the `data` attribute, which is an instance of `BasePackageData`. If the package name is not set (i.e., `data.NAME` is falsy), it raises a `StructureError` indicating that the package name is not defined for the given PyPI name (`self.pypi_name`). The `pypi_name` is derived from the `data` attribute and represents the name used in the Python Package Index (PyPI).\n\nReturns:\n    str: The package name.\n\nRaises:\n    StructureError: If the package name is not set in `data.NAME`.",
        "signature": "def name(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.library_name": {
        "code": "    def library_name(self) -> str:\n        \"\"\"PyPI library package name.\n\nThis property returns the name of the library package as defined in the associated\ndata class, which is an instance of the BasePackageData type. The library name is\nessential for correctly identifying the package on PyPI and is expected to be\nprovided by the data class through the LIBRARY_NAME attribute.\n\nReturns:\n    str: The name of the library package.\n\nDependencies:\n    The property relies on the `data` attribute of the Package class, which is\n    an instance of BasePackageData. This attribute must have a LIBRARY_NAME\n    property defined to provide the library package name.\"\"\"\n        '\\n        PyPI library package name.\\n        '\n        return self.data.LIBRARY_NAME",
        "docstring": "PyPI library package name.\n\nThis property returns the name of the library package as defined in the associated\ndata class, which is an instance of the BasePackageData type. The library name is\nessential for correctly identifying the package on PyPI and is expected to be\nprovided by the data class through the LIBRARY_NAME attribute.\n\nReturns:\n    str: The name of the library package.\n\nDependencies:\n    The property relies on the `data` attribute of the Package class, which is\n    an instance of BasePackageData. This attribute must have a LIBRARY_NAME\n    property defined to provide the library package name.",
        "signature": "def library_name(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.service_name": {
        "code": "    def service_name(self) -> ServiceName:\n        \"\"\"Retrieve the service name associated with the package.\n\nThis property checks the length of the `service_names` tuple. If it contains exactly one service name, that name is returned. If there are multiple service names, a `StructureError` is raised, indicating an inconsistency in the package definition.\n\nReturns:\n    ServiceName: The single service name for the package.\n\nRaises:\n    StructureError: If the number of service names is not equal to one.\n\nDependencies:\n- This property interacts with the `service_names` attribute, which is initialized in the `__init__` method of the `Package` class.\n- It raises exceptions defined in the `mypy_boto3_builder.exceptions` module.\"\"\"\n        '\\n        Service name for the package.\\n        '\n        if len(self.service_names) != 1:\n            raise StructureError(f'Package {self.name} has more than one service name')\n        return self.service_names[0]",
        "docstring": "Retrieve the service name associated with the package.\n\nThis property checks the length of the `service_names` tuple. If it contains exactly one service name, that name is returned. If there are multiple service names, a `StructureError` is raised, indicating an inconsistency in the package definition.\n\nReturns:\n    ServiceName: The single service name for the package.\n\nRaises:\n    StructureError: If the number of service names is not equal to one.\n\nDependencies:\n- This property interacts with the `service_names` attribute, which is initialized in the `__init__` method of the `Package` class.\n- It raises exceptions defined in the `mypy_boto3_builder.exceptions` module.",
        "signature": "def service_name(self) -> ServiceName:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.directory_name": {
        "code": "    def directory_name(self) -> str:\n        \"\"\"Generate a directory name for storing the generated package by replacing hyphens in the PyPI package name with underscores and appending \"_package\". \n\nReturns:\n    str: The formatted directory name, ensuring compatibility with filesystem naming conventions.\n\nDependencies:\n    - self.pypi_name: Obtained from the property method, retrieves the PyPI package name, which is initialized in the constructor with `self.data.PYPI_NAME`.\"\"\"\n        '\\n        Directory name to store generated package.\\n        '\n        underscore_package_name = self.pypi_name.replace('-', '_')\n        return f'{underscore_package_name}_package'",
        "docstring": "Generate a directory name for storing the generated package by replacing hyphens in the PyPI package name with underscores and appending \"_package\". \n\nReturns:\n    str: The formatted directory name, ensuring compatibility with filesystem naming conventions.\n\nDependencies:\n    - self.pypi_name: Obtained from the property method, retrieves the PyPI package name, which is initialized in the constructor with `self.data.PYPI_NAME`.",
        "signature": "def directory_name(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Get the string representation of the Package instance for debugging purposes. \n\nThis method concatenates the package name, version, library name, and library version into a formatted string. It uses the `name` property to retrieve the package's name, the protected `_version` attribute for the version, and the `library_name` property along with the `library_version` retrieved from the `data` attribute. \n\nReturns:\n    str: A string representation formatted as \"<package_name> <version> (<library_name> <library_version>)\".\n\nNo input parameters are required for this method. It is primarily used for logging or debugging to provide a quick overview of the package's current state.\"\"\"\n        '\\n        Get string representation for debugging.\\n        '\n        return f'{self.name} {self._version} ({self.library_name} {self.library_version})'",
        "docstring": "Get the string representation of the Package instance for debugging purposes. \n\nThis method concatenates the package name, version, library name, and library version into a formatted string. It uses the `name` property to retrieve the package's name, the protected `_version` attribute for the version, and the `library_name` property along with the `library_version` retrieved from the `data` attribute. \n\nReturns:\n    str: A string representation formatted as \"<package_name> <version> (<library_name> <library_version>)\".\n\nNo input parameters are required for this method. It is primarily used for logging or debugging to provide a quick overview of the package's current state.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.get_local_doc_link": {
        "code": "    def get_local_doc_link(self, service_name: ServiceName | None=None) -> str:\n        \"\"\"Get the local documentation link for the package.\n\nParameters:\n    service_name (ServiceName | None): An optional service name. If provided, the function appends the service module name to the local documentation URL.\n\nReturns:\n    str: The URL to the local documentation. If a service name is specified, the returned URL includes the specific module path; otherwise, it returns a general documentation link.\n\nDependencies:\n    The function relies on `self.data.LOCAL_DOC_LINK`, which is expected to contain the base URL for the package's local documentation. The `get_module_name` method is used to fetch the specific module name associated with the provided service name, ensuring the constructed URL is accurate for that service.\"\"\"\n        '\\n        Get link to local docs.\\n        '\n        url = self.data.LOCAL_DOC_LINK\n        if service_name:\n            url = f'{url}{self.get_module_name(service_name)}/'\n        return url",
        "docstring": "Get the local documentation link for the package.\n\nParameters:\n    service_name (ServiceName | None): An optional service name. If provided, the function appends the service module name to the local documentation URL.\n\nReturns:\n    str: The URL to the local documentation. If a service name is specified, the returned URL includes the specific module path; otherwise, it returns a general documentation link.\n\nDependencies:\n    The function relies on `self.data.LOCAL_DOC_LINK`, which is expected to contain the base URL for the package's local documentation. The `get_module_name` method is used to fetch the specific module name associated with the provided service name, ensuring the constructed URL is accurate for that service.",
        "signature": "def get_local_doc_link(self, service_name: ServiceName | None=None) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.get_module_name": {
        "code": "    def get_module_name(self, service_name: ServiceName) -> str:\n        \"\"\"Get the module name associated with a specific service.\n\nParameters:\n- service_name (ServiceName): The service name for which the module name is to be retrieved. The ServiceName is an instance of the class responsible for managing service-related names, and is used to access service-specific information.\n\nReturns:\n- str: The name of the module corresponding to the provided service name, obtained by calling the `get_service_package_name` method of the `data` attribute, which is an instance of `BasePackageData`. This method encapsulates the logic for determining the correct module name based on the provided service name.\"\"\"\n        '\\n        Get service module name.\\n        '\n        return self.data.get_service_package_name(service_name)",
        "docstring": "Get the module name associated with a specific service.\n\nParameters:\n- service_name (ServiceName): The service name for which the module name is to be retrieved. The ServiceName is an instance of the class responsible for managing service-related names, and is used to access service-specific information.\n\nReturns:\n- str: The name of the module corresponding to the provided service name, obtained by calling the `get_service_package_name` method of the `data` attribute, which is an instance of `BasePackageData`. This method encapsulates the logic for determining the correct module name based on the provided service name.",
        "signature": "def get_module_name(self, service_name: ServiceName) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.get_service_pypi_name": {
        "code": "    def get_service_pypi_name(self, service_name: ServiceName) -> str:\n        \"\"\"Retrieve the PyPI package name associated with a specified service package.\n\nThis method leverages the `data` attribute of the `Package` class, which is an instance of the `BasePackageData` class, to look up and return the corresponding PyPI package name for the provided `service_name`. The `service_name` parameter should be an instance of the `ServiceName` class, which encapsulates the service-related information needed for the lookup. \n\nParameters:\n- service_name (ServiceName): An instance representing the service for which the PyPI name is to be retrieved.\n\nReturns:\n- str: The PyPI package name associated with the provided service name.\n\nThis function relies on the `get_service_pypi_name` method of the `BasePackageData` instance, which must correctly map service names to their respective PyPI package names.\"\"\"\n        '\\n        Get PyPI package name for a service package.\\n        '\n        return self.data.get_service_pypi_name(service_name)",
        "docstring": "Retrieve the PyPI package name associated with a specified service package.\n\nThis method leverages the `data` attribute of the `Package` class, which is an instance of the `BasePackageData` class, to look up and return the corresponding PyPI package name for the provided `service_name`. The `service_name` parameter should be an instance of the `ServiceName` class, which encapsulates the service-related information needed for the lookup. \n\nParameters:\n- service_name (ServiceName): An instance representing the service for which the PyPI name is to be retrieved.\n\nReturns:\n- str: The PyPI package name associated with the provided service name.\n\nThis function relies on the `get_service_pypi_name` method of the `BasePackageData` instance, which must correctly map service names to their respective PyPI package names.",
        "signature": "def get_service_pypi_name(self, service_name: ServiceName) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.min_library_version": {
        "code": "    def min_library_version(self) -> str:\n        \"\"\"Retrieve the minimum required library version for the package.\n\nThis property calculates the minimum library version based on the current library version of the package, which is obtained using the `library_version` attribute. The actual determination of the minimum version is done through the `get_min_build_version` utility function.\n\nReturns:\n    str: The minimum required library version.\n\nDependencies:\n- `get_min_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, responsible for computing the minimum build version from the current library version.\n- `library_version`: An attribute representing the current library version, defined in the `Package` class upon initialization.\"\"\"\n        '\\n        Minimum required library version.\\n        '\n        return get_min_build_version(self.library_version)",
        "docstring": "Retrieve the minimum required library version for the package.\n\nThis property calculates the minimum library version based on the current library version of the package, which is obtained using the `library_version` attribute. The actual determination of the minimum version is done through the `get_min_build_version` utility function.\n\nReturns:\n    str: The minimum required library version.\n\nDependencies:\n- `get_min_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, responsible for computing the minimum build version from the current library version.\n- `library_version`: An attribute representing the current library version, defined in the `Package` class upon initialization.",
        "signature": "def min_library_version(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.max_library_version": {
        "code": "    def max_library_version(self) -> str:\n        \"\"\"Get the maximum required library version based on the current library version.\n\nThis property uses the helper function `get_max_build_version`, which takes the `library_version` attribute as input. The returned string represents the maximum version compatible with the current library version.\n\nDependencies:\n- `get_max_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, which calculates the maximum build version based on a given library version.\n\nReturns:\n- str: The maximum required library version.\"\"\"\n        '\\n        Minimum required library version.\\n        '\n        return get_max_build_version(self.library_version)",
        "docstring": "Get the maximum required library version based on the current library version.\n\nThis property uses the helper function `get_max_build_version`, which takes the `library_version` attribute as input. The returned string represents the maximum version compatible with the current library version.\n\nDependencies:\n- `get_max_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, which calculates the maximum build version based on a given library version.\n\nReturns:\n- str: The maximum required library version.",
        "signature": "def max_library_version(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.min_python_version": {
        "code": "    def min_python_version(self) -> str:\n        \"\"\"@property\ndef min_python_version(self) -> str:\"\"\"\n        '\\n        Minimum required python version.\\n        '\n        min_version = min(SUPPORTED_PY_VERSIONS)\n        return '.'.join((str(i) for i in min_version))",
        "docstring": "@property\ndef min_python_version(self) -> str:",
        "signature": "def min_python_version(self) -> str:",
        "type": "Method",
        "class_signature": "class Package:"
      },
      "Package.get_classifiers": {
        "code": "    def get_classifiers(self) -> list[str]:\n        \"\"\"Generate a list of classifiers for the package, which are used in package metadata. The classifiers include the development status, intended audience, environment, license, natural language, operating system compatibility, and programming language details based on the supported Python versions.\n\nThe method constructs the classifiers by examining the `SUPPORTED_PY_VERSIONS` constant, which is expected to be a list of tuples representing the supported Python versions. The output is a list of strings formatted according to the Python Package Index (PyPI) standards.\n\nReturns:\n    list[str]: A list of classifiers that describe the package for PyPI.\n\nDependencies:\n    - SUPPORTED_PY_VERSIONS: A constant imported from `mypy_boto3_builder.constants`, which lists the Python versions that the package supports.\"\"\"\n        '\\n        Get classifiers for package.\\n        '\n        result = ['Development Status :: 5 - Production/Stable', 'Intended Audience :: Developers', 'Environment :: Console', 'License :: OSI Approved :: MIT License', 'Natural Language :: English', 'Operating System :: OS Independent']\n        major_versions = {version[0] for version in SUPPORTED_PY_VERSIONS}\n        for major in sorted(major_versions):\n            result.append(f'Programming Language :: Python :: {major}')\n            minor_versions = {version[1] for version in SUPPORTED_PY_VERSIONS if version[0] == major and len(version) > 1}\n            result.extend((f'Programming Language :: Python :: {major}.{minor}' for minor in sorted(minor_versions)))\n        if len(major_versions) == 1:\n            major = next(iter(major_versions))\n            result.append(f'Programming Language :: Python :: {major} :: Only')\n        result.extend(('Programming Language :: Python :: Implementation :: CPython', 'Typing :: Stubs Only'))\n        return result",
        "docstring": "Generate a list of classifiers for the package, which are used in package metadata. The classifiers include the development status, intended audience, environment, license, natural language, operating system compatibility, and programming language details based on the supported Python versions.\n\nThe method constructs the classifiers by examining the `SUPPORTED_PY_VERSIONS` constant, which is expected to be a list of tuples representing the supported Python versions. The output is a list of strings formatted according to the Python Package Index (PyPI) standards.\n\nReturns:\n    list[str]: A list of classifiers that describe the package for PyPI.\n\nDependencies:\n    - SUPPORTED_PY_VERSIONS: A constant imported from `mypy_boto3_builder.constants`, which lists the Python versions that the package supports.",
        "signature": "def get_classifiers(self) -> list[str]:",
        "type": "Method",
        "class_signature": "class Package:"
      }
    },
    "mypy_boto3_builder/utils/version.py": {
      "get_min_build_version": {
        "code": "def get_min_build_version(version: str) -> str:\n    \"\"\"Get the minimum build version by resetting the micro (patch) version to 0.\n\nParameters:\n- version (str): A string representing the version number, formatted according to semantic versioning (e.g., \"1.2.3\").\n\nReturns:\n- str: A string representing the minimum build version with the micro version set to 0 (e.g., \"1.2.0\").\n\nDependencies:\n- Utilizes the `Version` class from the `packaging.version` module to parse the input version string and retrieve the major and minor components.\"\"\"\n    '\\n    Get min version build version by setting micro to 0.\\n    '\n    major, minor, _ = Version(version).release\n    return f'{major}.{minor}.0'",
        "docstring": "Get the minimum build version by resetting the micro (patch) version to 0.\n\nParameters:\n- version (str): A string representing the version number, formatted according to semantic versioning (e.g., \"1.2.3\").\n\nReturns:\n- str: A string representing the minimum build version with the micro version set to 0 (e.g., \"1.2.0\").\n\nDependencies:\n- Utilizes the `Version` class from the `packaging.version` module to parse the input version string and retrieve the major and minor components.",
        "signature": "def get_min_build_version(version: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_max_build_version": {
        "code": "def get_max_build_version(version: str) -> str:\n    \"\"\"Get the maximum build version by incrementing the minor version of the provided version string.\n\nParameters:\n- version (str): A string representing the current version in the format 'major.minor.patch', where 'major', 'minor', and 'patch' are integer values.\n\nReturns:\n- str: A new version string formatted as 'major.(minor + 1).0', representing the maximum build version.\n\nThis function utilizes the `Version` class from the `packaging.version` module to parse the input version string, ensuring that version comparisons are handled correctly.\"\"\"\n    '\\n    Get min version build version by bumping minor.\\n    '\n    major, minor, _ = Version(version).release\n    return f'{major}.{minor + 1}.0'",
        "docstring": "Get the maximum build version by incrementing the minor version of the provided version string.\n\nParameters:\n- version (str): A string representing the current version in the format 'major.minor.patch', where 'major', 'minor', and 'patch' are integer values.\n\nReturns:\n- str: A new version string formatted as 'major.(minor + 1).0', representing the maximum build version.\n\nThis function utilizes the `Version` class from the `packaging.version` module to parse the input version string, ensuring that version comparisons are handled correctly.",
        "signature": "def get_max_build_version(version: str) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/utils/version_getters.py": {
      "get_botocore_version": {
        "code": "def get_botocore_version() -> str:\n    \"\"\"Retrieve the version of the botocore package.\n\nThis function attempts to import the botocore package and returns its version as a string. If botocore is not installed, it raises a BuildEnvError with an appropriate message. The function does not take any parameters and returns the version number of botocore.\n\nDependencies:\n- Requires the `botocore` package to be installed in the environment.\n- Raises BuildEnvError, which is defined in the `mypy_boto3_builder.exceptions` module, if the import fails.\"\"\"\n    '\\n    Get botocore package version.\\n    '\n    try:\n        from botocore import __version__ as version\n    except ImportError as e:\n        raise BuildEnvError('botocore is not installed') from e\n    return f'{version}'",
        "docstring": "Retrieve the version of the botocore package.\n\nThis function attempts to import the botocore package and returns its version as a string. If botocore is not installed, it raises a BuildEnvError with an appropriate message. The function does not take any parameters and returns the version number of botocore.\n\nDependencies:\n- Requires the `botocore` package to be installed in the environment.\n- Raises BuildEnvError, which is defined in the `mypy_boto3_builder.exceptions` module, if the import fails.",
        "signature": "def get_botocore_version() -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_boto3_version": {
        "code": "def get_boto3_version() -> str:\n    \"\"\"Retrieve the version of the boto3 package.\n\nThis function attempts to import the `__version__` attribute from the boto3 module, which reflects the current version of the package installed. If the import fails, a `BuildEnvError` is raised to indicate that boto3 is not installed. The function returns the version as a string.\n\nNo parameters are accepted, and the return value is a string representing the boto3 package version.\n\nDependencies:\n- Requires the `boto3` package to be installed in the environment.\n- Raises `BuildEnvError` from `mypy_boto3_builder.exceptions` if the package is not available.\"\"\"\n    '\\n    Get boto3 package version.\\n    '\n    try:\n        from boto3 import __version__ as version\n    except ImportError as e:\n        raise BuildEnvError('boto3 is not installed') from e\n    return f'{version}'",
        "docstring": "Retrieve the version of the boto3 package.\n\nThis function attempts to import the `__version__` attribute from the boto3 module, which reflects the current version of the package installed. If the import fails, a `BuildEnvError` is raised to indicate that boto3 is not installed. The function returns the version as a string.\n\nNo parameters are accepted, and the return value is a string representing the boto3 package version.\n\nDependencies:\n- Requires the `boto3` package to be installed in the environment.\n- Raises `BuildEnvError` from `mypy_boto3_builder.exceptions` if the package is not available.",
        "signature": "def get_boto3_version() -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/logger.py": {
      "get_logger": {
        "code": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n    \"\"\"Retrieve a configured logger instance.\n\nThis function creates and returns a logger with the specified name and log level. If the logger does not have any handlers, it sets up a StreamHandler with a defined log message format. The logger appears to be tailored for the module it resides in, utilizing a constant LOGGER_NAME for its default name defined in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- level (int | None): The logging level to set for the logger. If None, defaults to NOTSET.\n- name (str): The name for the logger, defaulting to LOGGER_NAME.\n\nReturns:\n- logging.Logger: An instance of the logging.Logger configured according to the provided parameters.\n\nSide Effects:\nSets the logging level for all handlers associated with the logger if the level is provided or modifies the logger by adding a new StreamHandler with a formatter if handlers are not already present.\"\"\"\n    '\\n    Get Logger instance.\\n\\n    Arguments:\\n        level -- Log level.\\n\\n    Returns:\\n        Overriden Logger.\\n    '\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s %(name)s: %(levelname)-7s %(message)s', datefmt='%H:%M:%S')\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n    return logger",
        "docstring": "Retrieve a configured logger instance.\n\nThis function creates and returns a logger with the specified name and log level. If the logger does not have any handlers, it sets up a StreamHandler with a defined log message format. The logger appears to be tailored for the module it resides in, utilizing a constant LOGGER_NAME for its default name defined in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- level (int | None): The logging level to set for the logger. If None, defaults to NOTSET.\n- name (str): The name for the logger, defaulting to LOGGER_NAME.\n\nReturns:\n- logging.Logger: An instance of the logging.Logger configured according to the provided parameters.\n\nSide Effects:\nSets the logging level for all handlers associated with the logger if the level is provided or modifies the logger by adding a new StreamHandler with a formatter if handlers are not already present.",
        "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.underscore_name": {
        "code": "    def underscore_name(self) -> str:\n        \"\"\"Returns the service name in a Python-friendly format by replacing hyphens (\"-\") with underscores (\"_\"). This transformation ensures that the service name can be used safely as an identifier in Python code.\n\nReturns:\n    str: The modified service name, suitable for use in Python.\n\nThis method uses the `self.name` attribute, which is a string representing the service name originally provided during the initialization of the `ServiceName` instance.\"\"\"\n        '\\n        Python-friendly service name.\\n        '\n        return self.name.replace('-', '_')",
        "docstring": "Returns the service name in a Python-friendly format by replacing hyphens (\"-\") with underscores (\"_\"). This transformation ensures that the service name can be used safely as an identifier in Python code.\n\nReturns:\n    str: The modified service name, suitable for use in Python.\n\nThis method uses the `self.name` attribute, which is a string representing the service name originally provided during the initialization of the `ServiceName` instance.",
        "signature": "def underscore_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "tests/structures/test_package.py:TestPackage:test_init": {
      "mypy_boto3_builder/structures/package.py:Package:__init__": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_library_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_boto3_version": {}
        },
        "mypy_boto3_builder/package_data.py:BasePackageData:get_botocore_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
        },
        "mypy_boto3_builder/structures/package.py:Package:version": {},
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/structures/package.py:Package:pypi_name": {},
        "mypy_boto3_builder/structures/package_url.py:PackageURL:__init__": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:directory_name": {
        "mypy_boto3_builder/structures/package.py:Package:pypi_name": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:min_library_version": {
        "mypy_boto3_builder/utils/version.py:get_min_build_version": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:max_library_version": {
        "mypy_boto3_builder/utils/version.py:get_max_build_version": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:get_local_doc_link": {
        "mypy_boto3_builder/structures/package.py:Package:get_module_name": {
          "mypy_boto3_builder/package_data.py:BasePackageData:get_service_package_name": {
            "mypy_boto3_builder/service_name.py:ServiceName:underscore_name": {}
          }
        }
      },
      "mypy_boto3_builder/structures/package.py:Package:get_module_name": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_service_package_name": {
          "mypy_boto3_builder/service_name.py:ServiceName:underscore_name": {}
        }
      },
      "mypy_boto3_builder/structures/package.py:Package:get_service_pypi_name": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_service_pypi_name": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:min_python_version": {},
      "mypy_boto3_builder/structures/package.py:Package:__str__": {
        "mypy_boto3_builder/structures/package.py:Package:name": {},
        "mypy_boto3_builder/structures/package.py:Package:library_name": {}
      }
    },
    "tests/structures/test_package.py:TestPackage:test_service_name": {
      "mypy_boto3_builder/structures/package.py:Package:__init__": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_library_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_boto3_version": {}
        },
        "mypy_boto3_builder/package_data.py:BasePackageData:get_botocore_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
        },
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/structures/package.py:Package:pypi_name": {},
        "mypy_boto3_builder/structures/package_url.py:PackageURL:__init__": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:service_name": {
        "mypy_boto3_builder/structures/package.py:Package:name": {}
      }
    },
    "tests/structures/test_package.py:TestPackage:test_get_classifiers": {
      "mypy_boto3_builder/structures/package.py:Package:__init__": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_library_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_boto3_version": {}
        },
        "mypy_boto3_builder/package_data.py:BasePackageData:get_botocore_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
        },
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/structures/package.py:Package:pypi_name": {},
        "mypy_boto3_builder/structures/package_url.py:PackageURL:__init__": {}
      },
      "mypy_boto3_builder/structures/package.py:Package:get_classifiers": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_package\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 logger.py\n    \u2502   \u2514\u2500\u2500 get_logger\n    \u251c\u2500\u2500 package_data.py\n    \u2502   \u251c\u2500\u2500 BasePackageData.get_botocore_version\n    \u2502   \u251c\u2500\u2500 BasePackageData.get_library_version\n    \u2502   \u251c\u2500\u2500 BasePackageData.get_service_package_name\n    \u2502   \u2514\u2500\u2500 BasePackageData.get_service_pypi_name\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u2514\u2500\u2500 ServiceName.underscore_name\n    \u251c\u2500\u2500 structures/\n    \u2502   \u251c\u2500\u2500 package.py\n    \u2502   \u2502   \u251c\u2500\u2500 Package.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 Package.__str__\n    \u2502   \u2502   \u251c\u2500\u2500 Package.directory_name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.get_classifiers\n    \u2502   \u2502   \u251c\u2500\u2500 Package.get_local_doc_link\n    \u2502   \u2502   \u251c\u2500\u2500 Package.get_module_name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.get_service_pypi_name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.library_name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.max_library_version\n    \u2502   \u2502   \u251c\u2500\u2500 Package.min_library_version\n    \u2502   \u2502   \u251c\u2500\u2500 Package.min_python_version\n    \u2502   \u2502   \u251c\u2500\u2500 Package.name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.pypi_name\n    \u2502   \u2502   \u251c\u2500\u2500 Package.service_name\n    \u2502   \u2502   \u2514\u2500\u2500 Package.version\n    \u2502   \u2514\u2500\u2500 package_url.py\n    \u2502       \u2514\u2500\u2500 PackageURL.__init__\n    \u2514\u2500\u2500 utils/\n        \u251c\u2500\u2500 version.py\n        \u2502   \u251c\u2500\u2500 get_max_build_version\n        \u2502   \u2514\u2500\u2500 get_min_build_version\n        \u2514\u2500\u2500 version_getters.py\n            \u251c\u2500\u2500 get_boto3_version\n            \u2514\u2500\u2500 get_botocore_version\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the generation, management, and validation of type stubs for AWS services in Python through the `boto3-stubs` library. Its primary purpose is to streamline the handling of type definitions, ensuring compatibility with specific AWS services such as S3 and EC2 while adhering to Python version requirements and library constraints. By providing utilities to retrieve documentation links, package naming conventions, and Python version classifiers, the module simplifies the creation of consistent and accurate type hints for developers leveraging AWS SDKs. This streamlines development workflows, improves type safety, and reduces potential runtime errors, enabling developers to write more reliable and maintainable code. It also provides safeguards to validate service compatibility and resolve structural inconsistencies within the stub definitions.\n\n## FILE 1: mypy_boto3_builder/package_data.py\n\n- CLASS METHOD: BasePackageData.get_botocore_version\n  - CLASS SIGNATURE: class BasePackageData:\n  - SIGNATURE: def get_botocore_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the underlying version of the botocore library.\n\nThis static method serves to retrieve the current version of the botocore library, which is a key dependency for the AWS SDK for Python (Boto3). The function calls the helper method `get_botocore_version` imported from `mypy_boto3_builder.utils.version_getters`, which encapsulates the logic for determining the version.\n\nReturns:\n    str: The version of the botocore library as a string.\n\"\"\"\n```\n\n- CLASS METHOD: BasePackageData.get_library_version\n  - CLASS SIGNATURE: class BasePackageData:\n  - SIGNATURE: def get_library_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the version of the underlying Boto3 library.\n\nThis static method retrieves the version string of the Boto3 library using the `get_boto3_version` utility function imported from the `mypy_boto3_builder.utils.version_getters` module. It does not take any parameters and returns a string representing the library version. This method is typically used by subclasses to provide versioning details for specific package data representations related to Boto3 and its stubs.\n\"\"\"\n```\n\n- CLASS METHOD: BasePackageData.get_service_pypi_name\n  - CLASS SIGNATURE: class BasePackageData:\n  - SIGNATURE: def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the service package PyPI name for a given AWS service.\n\nParameters:\n- cls: The class calling the method, which inherits from BasePackageData.\n- service_name (ServiceName): An instance of the ServiceName enum that provides the name of the AWS service, used to construct the PyPI package name.\n\nReturns:\n- str: The PyPI name of the service package, formatted as \"{cls.SERVICE_PYPI_PREFIX}-{service_name.name}\".\n\nDependencies:\n- This method relies on the constant cls.SERVICE_PYPI_PREFIX, which is defined in the BasePackageData class and serves as the prefix for the PyPI package names of the defined AWS services.\n\"\"\"\n```\n\n- CLASS METHOD: BasePackageData.get_service_package_name\n  - CLASS SIGNATURE: class BasePackageData:\n  - SIGNATURE: def get_service_package_name(cls, service_name: ServiceName) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate the package name for a specific AWS service.\n\nParameters:\n- cls: Type[BasePackageData] - The class that calls this method. It typically represents a specific package of AWS service data that inherits from BasePackageData.\n- service_name: ServiceName - An instance of the ServiceName class, which contains information about the AWS service, including its underscored name.\n\nReturns:\n- str: A string that combines the class's SERVICE_PREFIX with the underscored name of the given service, formatted as '{SERVICE_PREFIX}_{service_name.underscore_name}'.\n\nThis method relies on the SERVICE_PREFIX constant defined in the BasePackageData class, which is a class variable intended to prefix the package names for different AWS services.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/structures/package_url.py\n\n- CLASS METHOD: PackageURL.__init__\n  - CLASS SIGNATURE: class PackageURL:\n  - SIGNATURE: def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a PackageURL instance.\n\nParameters:\n- pypi_name (str): The name of the package on PyPI, which will be used to generate various badge and link URLs.\n- data (type[BasePackageData]): A class that inherits from BasePackageData which provides metadata and constants related to the package, such as library names and documentation links.\n\nThis constructor sets the instance attributes `pypi_name` and `data`, enabling other methods and properties of the class to construct URLs for package badges, PyPI links, and download statistics based on the provided package name and associated data.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/structures/package.py\n\n- CLASS METHOD: Package.min_library_version\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def min_library_version(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the minimum required library version for the package.\n\nThis property calculates the minimum library version based on the current library version of the package, which is obtained using the `library_version` attribute. The actual determination of the minimum version is done through the `get_min_build_version` utility function.\n\nReturns:\n    str: The minimum required library version.\n\nDependencies:\n- `get_min_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, responsible for computing the minimum build version from the current library version.\n- `library_version`: An attribute representing the current library version, defined in the `Package` class upon initialization.\n\"\"\"\n```\n\n- CLASS METHOD: Package.library_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def library_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nPyPI library package name.\n\nThis property returns the name of the library package as defined in the associated\ndata class, which is an instance of the BasePackageData type. The library name is\nessential for correctly identifying the package on PyPI and is expected to be\nprovided by the data class through the LIBRARY_NAME attribute.\n\nReturns:\n    str: The name of the library package.\n\nDependencies:\n    The property relies on the `data` attribute of the Package class, which is\n    an instance of BasePackageData. This attribute must have a LIBRARY_NAME\n    property defined to provide the library package name.\n\"\"\"\n```\n\n- CLASS METHOD: Package.service_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def service_name(self) -> ServiceName:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the service name associated with the package.\n\nThis property checks the length of the `service_names` tuple. If it contains exactly one service name, that name is returned. If there are multiple service names, a `StructureError` is raised, indicating an inconsistency in the package definition.\n\nReturns:\n    ServiceName: The single service name for the package.\n\nRaises:\n    StructureError: If the number of service names is not equal to one.\n\nDependencies:\n- This property interacts with the `service_names` attribute, which is initialized in the `__init__` method of the `Package` class.\n- It raises exceptions defined in the `mypy_boto3_builder.exceptions` module.\n\"\"\"\n```\n\n- CLASS METHOD: Package.directory_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def directory_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a directory name for storing the generated package by replacing hyphens in the PyPI package name with underscores and appending \"_package\". \n\nReturns:\n    str: The formatted directory name, ensuring compatibility with filesystem naming conventions.\n\nDependencies:\n    - self.pypi_name: Obtained from the property method, retrieves the PyPI package name, which is initialized in the constructor with `self.data.PYPI_NAME`.\n\"\"\"\n```\n\n- CLASS METHOD: Package.name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the name of the package.\n\nThis property retrieves the package name from the `data` attribute, which is an instance of `BasePackageData`. If the package name is not set (i.e., `data.NAME` is falsy), it raises a `StructureError` indicating that the package name is not defined for the given PyPI name (`self.pypi_name`). The `pypi_name` is derived from the `data` attribute and represents the name used in the Python Package Index (PyPI).\n\nReturns:\n    str: The package name.\n\nRaises:\n    StructureError: If the package name is not set in `data.NAME`.\n\"\"\"\n```\n\n- CLASS METHOD: Package.get_classifiers\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def get_classifiers(self) -> list[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a list of classifiers for the package, which are used in package metadata. The classifiers include the development status, intended audience, environment, license, natural language, operating system compatibility, and programming language details based on the supported Python versions.\n\nThe method constructs the classifiers by examining the `SUPPORTED_PY_VERSIONS` constant, which is expected to be a list of tuples representing the supported Python versions. The output is a list of strings formatted according to the Python Package Index (PyPI) standards.\n\nReturns:\n    list[str]: A list of classifiers that describe the package for PyPI.\n\nDependencies:\n    - SUPPORTED_PY_VERSIONS: A constant imported from `mypy_boto3_builder.constants`, which lists the Python versions that the package supports.\n\"\"\"\n```\n\n- CLASS METHOD: Package.max_library_version\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def max_library_version(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the maximum required library version based on the current library version.\n\nThis property uses the helper function `get_max_build_version`, which takes the `library_version` attribute as input. The returned string represents the maximum version compatible with the current library version.\n\nDependencies:\n- `get_max_build_version`: A utility function imported from the `mypy_boto3_builder.utils.version` module, which calculates the maximum build version based on a given library version.\n\nReturns:\n- str: The maximum required library version.\n\"\"\"\n```\n\n- CLASS METHOD: Package.version\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def version(self, value: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nSet the package version after validating it.\n\nParameters:\n- value (str): The version string to set for the package. This string must be a valid version as per the `packaging.version.Version` standards.\n\nRaises:\n- StructureError: If the provided version string is invalid, indicating that it does not conform to the expected version format.\n\nThis method interacts with the `Version` class from the `packaging.version` module to ensure that the version string is valid. If the version is valid, it is stored in a private attribute `_version` of the `Package` class.\n\"\"\"\n```\n\n- CLASS METHOD: Package.get_module_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def get_module_name(self, service_name: ServiceName) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the module name associated with a specific service.\n\nParameters:\n- service_name (ServiceName): The service name for which the module name is to be retrieved. The ServiceName is an instance of the class responsible for managing service-related names, and is used to access service-specific information.\n\nReturns:\n- str: The name of the module corresponding to the provided service name, obtained by calling the `get_service_package_name` method of the `data` attribute, which is an instance of `BasePackageData`. This method encapsulates the logic for determining the correct module name based on the provided service name.\n\"\"\"\n```\n\n- CLASS METHOD: Package.min_python_version\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def min_python_version(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef min_python_version(self) -> str:\n\"\"\"\n```\n\n- CLASS METHOD: Package.get_service_pypi_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def get_service_pypi_name(self, service_name: ServiceName) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the PyPI package name associated with a specified service package.\n\nThis method leverages the `data` attribute of the `Package` class, which is an instance of the `BasePackageData` class, to look up and return the corresponding PyPI package name for the provided `service_name`. The `service_name` parameter should be an instance of the `ServiceName` class, which encapsulates the service-related information needed for the lookup. \n\nParameters:\n- service_name (ServiceName): An instance representing the service for which the PyPI name is to be retrieved.\n\nReturns:\n- str: The PyPI package name associated with the provided service name.\n\nThis function relies on the `get_service_pypi_name` method of the `BasePackageData` instance, which must correctly map service names to their respective PyPI package names.\n\"\"\"\n```\n\n- CLASS METHOD: Package.__init__\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Package instance, setting up properties related to the package structure based on provided data.\n\nParameters:\n- data (type[BasePackageData]): The package data class that contains essential information such as PyPI name and library versions.\n- service_names (Iterable[ServiceName], optional): A tuple of service names associated with the package (default is an empty tuple).\n- version (str, optional): The package version, which will be validated and assigned if provided (default is an empty string).\n\nAttributes initialized:\n- self.data: Holds the provided package data.\n- self._pypi_name: The name of the package on PyPI, retrieved from data.\n- self.library_version: The version of the library, obtained from the data instance method.\n- self.botocore_version: The version of botocore, also obtained from data.\n- self._version: A private attribute to store the package version, initialized to an empty string.\n- self.service_names: A tuple of service names, converted from the input iterable.\n- self.logger: Logger instance obtained from the get_logger() function for logging purposes.\n- self.url: A PackageURL instance initialized with the PyPI name and data for constructing package URLs.\n\nThis constructor validates the version input and raises a StructureError if the version is invalid, while providing structured representation and attributes for managing package-related data effectively.\n\"\"\"\n```\n\n- CLASS METHOD: Package.__str__\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the string representation of the Package instance for debugging purposes. \n\nThis method concatenates the package name, version, library name, and library version into a formatted string. It uses the `name` property to retrieve the package's name, the protected `_version` attribute for the version, and the `library_name` property along with the `library_version` retrieved from the `data` attribute. \n\nReturns:\n    str: A string representation formatted as \"<package_name> <version> (<library_name> <library_version>)\".\n\nNo input parameters are required for this method. It is primarily used for logging or debugging to provide a quick overview of the package's current state.\n\"\"\"\n```\n\n- CLASS METHOD: Package.pypi_name\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def pypi_name(self, value: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nSetter for the PyPI package name. This method sets the internal attribute _pypi_name and updates the associated PackageURL instance's pypi_name property.\n\nParameters:\n- value (str): The new name to set for the PyPI package.\n\nReturns:\n- None: This method does not return any value.\n\nSide Effects:\n- Updates the internal state of the Package instance by changing the _pypi_name attribute.\n- Modifies the pypi_name attribute of the PackageURL instance associated with the Package.\n\nThe _pypi_name is used as the unique identifier for the package in the Python Package Index (PyPI), which is essential for managing the package's distribution and installation.\n\"\"\"\n```\n\n- CLASS METHOD: Package.get_local_doc_link\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def get_local_doc_link(self, service_name: ServiceName | None=None) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local documentation link for the package.\n\nParameters:\n    service_name (ServiceName | None): An optional service name. If provided, the function appends the service module name to the local documentation URL.\n\nReturns:\n    str: The URL to the local documentation. If a service name is specified, the returned URL includes the specific module path; otherwise, it returns a general documentation link.\n\nDependencies:\n    The function relies on `self.data.LOCAL_DOC_LINK`, which is expected to contain the base URL for the package's local documentation. The `get_module_name` method is used to fetch the specific module name associated with the provided service name, ensuring the constructed URL is accurate for that service.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/utils/version.py\n\n- FUNCTION NAME: get_max_build_version\n  - SIGNATURE: def get_max_build_version(version: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the maximum build version by incrementing the minor version of the provided version string.\n\nParameters:\n- version (str): A string representing the current version in the format 'major.minor.patch', where 'major', 'minor', and 'patch' are integer values.\n\nReturns:\n- str: A new version string formatted as 'major.(minor + 1).0', representing the maximum build version.\n\nThis function utilizes the `Version` class from the `packaging.version` module to parse the input version string, ensuring that version comparisons are handled correctly.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/structures/package.py:Package:max_library_version\n\n- FUNCTION NAME: get_min_build_version\n  - SIGNATURE: def get_min_build_version(version: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the minimum build version by resetting the micro (patch) version to 0.\n\nParameters:\n- version (str): A string representing the version number, formatted according to semantic versioning (e.g., \"1.2.3\").\n\nReturns:\n- str: A string representing the minimum build version with the micro version set to 0 (e.g., \"1.2.0\").\n\nDependencies:\n- Utilizes the `Version` class from the `packaging.version` module to parse the input version string and retrieve the major and minor components.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/structures/package.py:Package:min_library_version\n\n## FILE 5: mypy_boto3_builder/utils/version_getters.py\n\n- FUNCTION NAME: get_botocore_version\n  - SIGNATURE: def get_botocore_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the version of the botocore package.\n\nThis function attempts to import the botocore package and returns its version as a string. If botocore is not installed, it raises a BuildEnvError with an appropriate message. The function does not take any parameters and returns the version number of botocore.\n\nDependencies:\n- Requires the `botocore` package to be installed in the environment.\n- Raises BuildEnvError, which is defined in the `mypy_boto3_builder.exceptions` module, if the import fails.\n\"\"\"\n```\n\n- FUNCTION NAME: get_boto3_version\n  - SIGNATURE: def get_boto3_version() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the version of the boto3 package.\n\nThis function attempts to import the `__version__` attribute from the boto3 module, which reflects the current version of the package installed. If the import fails, a `BuildEnvError` is raised to indicate that boto3 is not installed. The function returns the version as a string.\n\nNo parameters are accepted, and the return value is a string representing the boto3 package version.\n\nDependencies:\n- Requires the `boto3` package to be installed in the environment.\n- Raises `BuildEnvError` from `mypy_boto3_builder.exceptions` if the package is not available.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/logger.py\n\n- FUNCTION NAME: get_logger\n  - SIGNATURE: def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a configured logger instance.\n\nThis function creates and returns a logger with the specified name and log level. If the logger does not have any handlers, it sets up a StreamHandler with a defined log message format. The logger appears to be tailored for the module it resides in, utilizing a constant LOGGER_NAME for its default name defined in the `mypy_boto3_builder.constants` module. \n\nParameters:\n- level (int | None): The logging level to set for the logger. If None, defaults to NOTSET.\n- name (str): The name for the logger, defaulting to LOGGER_NAME.\n\nReturns:\n- logging.Logger: An instance of the logging.Logger configured according to the provided parameters.\n\nSide Effects:\nSets the logging level for all handlers associated with the logger if the level is provided or modifies the logger by adding a new StreamHandler with a formatter if handlers are not already present.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/structures/package.py:Package:__init__\n\n## FILE 7: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.underscore_name\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def underscore_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the service name in a Python-friendly format by replacing hyphens (\"-\") with underscores (\"_\"). This transformation ensures that the service name can be used safely as an identifier in Python code.\n\nReturns:\n    str: The modified service name, suitable for use in Python.\n\nThis method uses the `self.name` attribute, which is a string representing the service name originally provided during the initialization of the `ServiceName` instance.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/package_data.py": "\"\"\"\nPyPI package data constants.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport typing\nfrom typing import ClassVar\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.version_getters import get_aioboto3_version, get_aiobotocore_version, get_boto3_version, get_botocore_version\n\nclass BasePackageData:\n    \"\"\"\n    Generic package data.\n    \"\"\"\n    NAME: ClassVar[str] = 'boto3-stubs'\n    PYPI_NAME: ClassVar[str] = 'boto3-stubs'\n    PYPI_STUBS_NAME: ClassVar[str] = ''\n    PYPI_LITE_NAME: ClassVar[str] = ''\n    PYPI_FULL_NAME: ClassVar[str] = ''\n    LIBRARY_NAME: ClassVar[str] = 'boto3'\n    SERVICE_PREFIX: ClassVar[str] = 'mypy_boto3'\n    SERVICE_PYPI_PREFIX: ClassVar[str] = 'mypy-boto3'\n    LOCAL_DOC_LINK: ClassVar[str] = 'https://youtype.github.io/boto3_stubs_docs/'\n    IS_VSCODE_SUPPORTED: ClassVar[bool] = False\n    IS_CONDA_FORGE_SUPPORTED: ClassVar[bool] = False\n\n    @classmethod\n    def has_pypi_lite_package(cls) -> bool:\n        \"\"\"\n        Check if package has lite version.\n        \"\"\"\n        return bool(cls.PYPI_LITE_NAME)\n\nclass TypesAioBotocorePackageData(BasePackageData):\n    \"\"\"\n    types-aiobotocore package data.\n    \"\"\"\n    NAME = 'aiobotocore-stubs'\n    PYPI_NAME = 'types-aiobotocore'\n    PYPI_STUBS_NAME = 'types-aiobotocore'\n    PYPI_LITE_NAME = 'types-aiobotocore-lite'\n    PYPI_FULL_NAME = 'types-aiobotocore-full'\n    LIBRARY_NAME = 'aiobotocore'\n    SERVICE_PREFIX = 'types_aiobotocore'\n    SERVICE_PYPI_PREFIX = 'types-aiobotocore'\n    LOCAL_DOC_LINK = 'https://youtype.github.io/types_aiobotocore_docs/'\n\n    @staticmethod\n    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_aiobotocore_version()\n\nclass TypesAioBotocoreLitePackageData(TypesAioBotocorePackageData):\n    \"\"\"\n    types-aiobotocore-lite package data.\n    \"\"\"\n    PYPI_NAME = 'types-aiobotocore-lite'\n    PYPI_LITE_NAME = ''\n\nclass TypesAioBotocoreFullPackageData(TypesAioBotocorePackageData):\n    \"\"\"\n    types-aiobotocore-full package data.\n    \"\"\"\n    NAME = ''\n    PYPI_NAME = 'types-aiobotocore-full'\n    IS_CONDA_FORGE_SUPPORTED = False\n\n    @typing.override\n    @classmethod\n    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package PyPI name.\n        \"\"\"\n        return cls.PYPI_NAME\n\nclass Boto3StubsPackageData(BasePackageData):\n    \"\"\"\n    boto3-stubs package data.\n    \"\"\"\n    NAME = 'boto3-stubs'\n    PYPI_NAME = 'boto3-stubs'\n    PYPI_STUBS_NAME = 'boto3-stubs'\n    PYPI_LITE_NAME = 'boto3-stubs-lite'\n    PYPI_FULL_NAME = 'boto3-stubs-full'\n    LIBRARY_NAME = 'boto3'\n    LOCAL_DOC_LINK = 'https://youtype.github.io/boto3_stubs_docs/'\n    IS_VSCODE_SUPPORTED = True\n    IS_CONDA_FORGE_SUPPORTED = True\n\nclass Boto3StubsLitePackageData(Boto3StubsPackageData):\n    \"\"\"\n    boto3-stubs-lite package data.\n    \"\"\"\n    PYPI_NAME = 'boto3-stubs-lite'\n    PYPI_LITE_NAME = ''\n\nclass Boto3StubsFullPackageData(Boto3StubsPackageData):\n    \"\"\"\n    boto3-stubs-full package data.\n    \"\"\"\n    NAME = ''\n    PYPI_NAME = 'boto3-stubs-full'\n    IS_CONDA_FORGE_SUPPORTED = False\n\n    @typing.override\n    @classmethod\n    def get_service_pypi_name(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service package PyPI name.\n        \"\"\"\n        return cls.PYPI_NAME\n\nclass MypyBoto3PackageData(BasePackageData):\n    \"\"\"\n    mypy-boto3 package data.\n    \"\"\"\n    NAME = 'mypy_boto3'\n    PYPI_NAME = 'mypy-boto3'\n    LIBRARY_NAME = 'boto3'\n\nclass TypesAioBoto3PackageData(BasePackageData):\n    \"\"\"\n    types-aioboto3 package data.\n    \"\"\"\n    NAME = 'aioboto3-stubs'\n    PYPI_NAME = 'types-aioboto3'\n    PYPI_STUBS_NAME = 'types-aioboto3'\n    PYPI_LITE_NAME = 'types-aioboto3-lite'\n    PYPI_FULL_NAME = 'types-aiobotocore-full'\n    LIBRARY_NAME = 'aioboto3'\n    SERVICE_PREFIX = 'types_aiobotocore'\n    SERVICE_PYPI_PREFIX = 'types-aiobotocore'\n    AIOBOTOCORE_NAME = 'types-aiobotocore'\n    LOCAL_DOC_LINK = 'https://youtype.github.io/types_aioboto3_docs/'\n\n    @staticmethod\n    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_aioboto3_version()\n\nclass TypesAioBoto3LitePackageData(TypesAioBoto3PackageData):\n    \"\"\"\n    types-aioboto3-lite package data.\n    \"\"\"\n    PYPI_NAME = 'types-aioboto3-lite'\n    PYPI_LITE_NAME = ''\n    AIOBOTOCORE_NAME = 'types-aiobotocore-lite'",
    "mypy_boto3_builder/structures/package_url.py": "\"\"\"\nPackage links structure.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.utils.strings import get_pypi_link\n\nclass PackageURL:\n    \"\"\"\n    Package links structure.\n    \"\"\"\n\n    @property\n    def pypi_badge(self) -> str:\n        \"\"\"\n        Package name badge from shields.io.\n        \"\"\"\n        return f'https://img.shields.io/pypi/v/{self.pypi_name}.svg?color=blue'\n\n    @property\n    def pyversions_badge(self) -> str:\n        \"\"\"\n        Package Python version badge from shields.io.\n        \"\"\"\n        return f'https://img.shields.io/pypi/pyversions/{self.pypi_name}.svg?color=blue'\n\n    @property\n    def rtd_badge(self) -> str:\n        \"\"\"\n        ReadTheDocs badge from shields.io.\n        \"\"\"\n        return 'https://img.shields.io/readthedocs/boto3-stubs.svg?color=blue'\n\n    @property\n    def pepy_badge(self) -> str:\n        \"\"\"\n        PePy total downloads badge.\n        \"\"\"\n        return f'https://static.pepy.tech/badge/{self.pypi_name}'\n\n    @property\n    def montly_downloads_badge(self) -> str:\n        \"\"\"\n        PyPi monthly downloads badge.\n        \"\"\"\n        return f'https://img.shields.io/pypi/dm/{self.pypi_name}?color=blue'\n\n    @property\n    def pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI.\n        \"\"\"\n        return get_pypi_link(self.pypi_name)\n\n    @property\n    def library_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI underlying library.\n        \"\"\"\n        return get_pypi_link(self.data.LIBRARY_NAME)\n\n    @property\n    def stubs_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI lite version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_STUBS_NAME)\n\n    @property\n    def stubs_lite_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI lite version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_LITE_NAME)\n\n    @property\n    def stubs_full_pypi(self) -> str:\n        \"\"\"\n        Get link to PyPI full version of stubs.\n        \"\"\"\n        return get_pypi_link(self.data.PYPI_FULL_NAME)\n\n    @property\n    def pepy(self) -> str:\n        \"\"\"\n        PePy project link.\n        \"\"\"\n        return f'https://pepy.tech/project/{self.pypi_name}'\n\n    @property\n    def pypistats(self) -> str:\n        \"\"\"\n        PePy project link.\n        \"\"\"\n        return f'https://pypistats.org/packages/{self.pypi_name}'\n\n    @property\n    def docs(self) -> str:\n        \"\"\"\n        Documentation link.\n        \"\"\"\n        return self.data.LOCAL_DOC_LINK",
    "mypy_boto3_builder/structures/package.py": "\"\"\"\nParent class for all package structures.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom packaging.version import InvalidVersion, Version\nfrom mypy_boto3_builder.constants import SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.package_url import PackageURL\nfrom mypy_boto3_builder.utils.version import get_max_build_version, get_min_build_version\n\nclass Package:\n    \"\"\"\n    Parent class for all package structures.\n    \"\"\"\n\n    def has_main_package(self) -> bool:\n        \"\"\"\n        Check if package has main package.\n        \"\"\"\n        return bool(self.data.NAME)",
    "mypy_boto3_builder/utils/version.py": "\"\"\"\nVersion-related utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport contextlib\nimport importlib.metadata\nfrom collections.abc import Iterable\nfrom packaging.version import Version\nfrom mypy_boto3_builder.constants import PACKAGE_NAME\n\ndef get_builder_version() -> str:\n    \"\"\"\n    Get program version.\n    \"\"\"\n    with contextlib.suppress(importlib.metadata.PackageNotFoundError):\n        return importlib.metadata.version(PACKAGE_NAME)\n    return '0.0.0'\n\ndef get_release_version(version: str) -> str:\n    \"\"\"\n    Get release version by removing post.\n    \"\"\"\n    return Version(version).base_version\n\ndef bump_postrelease(version: str) -> str:\n    \"\"\"\n    Bump postrelease version.\n    \"\"\"\n    v = Version(version)\n    major, minor, patch = v.release\n    post = v.post + 1 if v.post else 1\n    return f'{major}.{minor}.{patch}.post{post}'\n\ndef sort_versions(version_list: Iterable[str]) -> list[str]:\n    \"\"\"\n    Sort version list.\n    \"\"\"\n    return sorted(version_list, key=Version)",
    "mypy_boto3_builder/utils/version_getters.py": "\"\"\"\nUtils for getting underlying package versions.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom mypy_boto3_builder.exceptions import BuildEnvError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.pypi_manager import PyPIManager\n\n@functools.cache\ndef get_aiobotocore_version() -> str:\n    \"\"\"\n    Get aiobotocore package version.\n    \"\"\"\n    try:\n        from aiobotocore import __version__ as version\n    except ImportError:\n        pass\n    else:\n        return f'{version}'\n    logger = get_logger()\n    logger.warning('aiobotocore is not installed, using latest version from PyPI')\n    pypi_manager = PyPIManager('aiobotocore')\n    return pypi_manager.get_latest_stable_version()\n\n@functools.cache\ndef get_aioboto3_version() -> str:\n    \"\"\"\n    Get aioboto3 package version.\n    \"\"\"\n    try:\n        from aioboto3 import __version__ as version\n    except ImportError:\n        pass\n    else:\n        return f'{version}'\n    logger = get_logger()\n    logger.warning('aioboto3 is not installed, using latest version from PyPI')\n    pypi_manager = PyPIManager('aioboto3')\n    return pypi_manager.get_latest_stable_version()",
    "mypy_boto3_builder/logger.py": "\"\"\"\nLogging utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport logging\nfrom mypy_boto3_builder.constants import LOGGER_NAME\n__all__ = ('get_logger',)",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name"
  }
}