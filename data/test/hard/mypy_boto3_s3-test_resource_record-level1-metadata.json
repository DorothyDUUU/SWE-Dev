{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_resource_record",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_resource_record.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.structures.collection import Collection\nfrom mypy_boto3_builder.structures.resource_record import ResourceRecord\n\n\nclass TestResource:\n    resource: ResourceRecord\n\n    def setup_method(self) -> None:\n        self.resource = ResourceRecord(\n            name=\"Name\",\n            service_name=ServiceNameCatalog.s3,\n        )\n\n    def test_init(self) -> None:\n        assert self.resource.name == \"Name\"\n        assert self.resource.service_name == ServiceNameCatalog.s3\n\n    def test_boto3_doc_link(self) -> None:\n        assert self.resource.boto3_doc_link == (\n            \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference\"\n            \"/services/s3/name/index.html#S3.Name\"\n        )\n\n    def test_iterate_types(self) -> None:\n        assert set(self.resource.iterate_types()) == {self.resource.bases[0]}\n        collection = Collection(\n            name=\"Collection\",\n            attribute_name=\"name\",\n            parent_name=\"parent\",\n            service_name=ServiceNameCatalog.s3,\n            type_annotation=self.resource.bases[0],\n            object_class_name=\"Object\",\n        )\n        self.resource.collections.append(collection)\n        assert set(self.resource.iterate_types()) == {\n            self.resource.bases[0],\n            collection.bases[0],\n        }\n",
  "GT_file_code": {
    "mypy_boto3_builder/structures/resource_record.py": "\"\"\"\nBoto3 ServiceResource sub-Resource.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING\n\nfrom boto3.resources.base import ServiceResource as Boto3ServiceResource\n\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nif TYPE_CHECKING:\n    from mypy_boto3_builder.structures.collection import Collection\n\n\nclass ResourceRecord(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource sub-Resource.\n    \"\"\"\n\n    def __init__(self, name: str, service_name: ServiceName) -> None:\n        super().__init__(\n            name=name,\n            bases=[ExternalImport.from_class(Boto3ServiceResource)],\n            use_alias=True,\n        )\n        self.service_name: ServiceName = service_name\n        self.collections: list[Collection] = []\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}/{self.name.lower()}/index.html\"\n            f\"#{self.service_name.class_name}.{self.name}\"\n        )\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations from collections.\n        \"\"\"\n        yield from super().iterate_types()\n        for collection in self.collections:\n            yield from collection.iterate_types()\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterator\n\nfrom boto3.resources.collection import ResourceCollection\n\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        name: str,\n        attribute_name: str,\n        parent_name: str,\n        service_name: ServiceName,\n        type_annotation: FakeAnnotation,\n        object_class_name: str,\n    ) -> None:\n        super().__init__(\n            name=name,\n            use_alias=True,\n            bases=[ExternalImport.from_class(ResourceCollection)],\n        )\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = (\n            \"service-resource\" if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        )\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}\"\n            f\"/{parent_name_part}/{self.attribute_name}.html\"\n        )\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.boto3_doc_link_parent}\"\n            f\"#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}\"\n        )\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations.\n        \"\"\"\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/structures/resource_record.py": {
      "ResourceRecord.__init__": {
        "code": "    def __init__(self, name: str, service_name: ServiceName) -> None:\n        \"\"\"Initialize a ResourceRecord instance representing a Boto3 ServiceResource sub-Resource.\n\nParameters:\n- name (str): The name of the resource, used for identifying it within the service.\n- service_name (ServiceName): An instance representing the name of the service that this resource belongs to, which is used to generate documentation links and manage service characteristics.\n\nThis constructor calls the superclass initializer to establish inheritance from ClassRecord, setting up the base class as an external import of Boto3's ServiceResource. It initializes the service_name attribute to hold the service context and sets up an empty list for collections, which can hold related collections of resources. There are no return values, as this method initializes an object instance.\"\"\"\n        super().__init__(name=name, bases=[ExternalImport.from_class(Boto3ServiceResource)], use_alias=True)\n        self.service_name: ServiceName = service_name\n        self.collections: list[Collection] = []",
        "docstring": "Initialize a ResourceRecord instance representing a Boto3 ServiceResource sub-Resource.\n\nParameters:\n- name (str): The name of the resource, used for identifying it within the service.\n- service_name (ServiceName): An instance representing the name of the service that this resource belongs to, which is used to generate documentation links and manage service characteristics.\n\nThis constructor calls the superclass initializer to establish inheritance from ClassRecord, setting up the base class as an external import of Boto3's ServiceResource. It initializes the service_name attribute to hold the service context and sets up an empty list for collections, which can hold related collections of resources. There are no return values, as this method initializes an object instance.",
        "signature": "def __init__(self, name: str, service_name: ServiceName) -> None:",
        "type": "Method",
        "class_signature": "class ResourceRecord(ClassRecord):"
      },
      "ResourceRecord.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Returns a formatted link to the Boto3 documentation for the specific service resource. The URL is constructed using the `service_name` and the `name` of the resource, ensuring that it leads to the appropriate section in the documentation.\n\nThe method relies on two attributes:\n- `self.service_name`: An instance of `ServiceName`, which provides the parent link to the Boto3 documentation specific to the service.\n- `self.name`: A string representing the name of the resource, which is used in the URL to pinpoint the exact resource documentation.\n\nThe resulting link follows the format:\n`<boto3_doc_link_parent>/<resource_name>/index.html#<service_class_name>.<resource_name>`.\n\nReturns:\n    str: A string containing the complete URL to the Boto3 documentation for the resource.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'{self.service_name.boto3_doc_link_parent}/{self.name.lower()}/index.html#{self.service_name.class_name}.{self.name}'",
        "docstring": "Returns a formatted link to the Boto3 documentation for the specific service resource. The URL is constructed using the `service_name` and the `name` of the resource, ensuring that it leads to the appropriate section in the documentation.\n\nThe method relies on two attributes:\n- `self.service_name`: An instance of `ServiceName`, which provides the parent link to the Boto3 documentation specific to the service.\n- `self.name`: A string representing the name of the resource, which is used in the URL to pinpoint the exact resource documentation.\n\nThe resulting link follows the format:\n`<boto3_doc_link_parent>/<resource_name>/index.html#<service_class_name>.<resource_name>`.\n\nReturns:\n    str: A string containing the complete URL to the Boto3 documentation for the resource.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class ResourceRecord(ClassRecord):"
      },
      "ResourceRecord.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"Iterate over all type annotations from the resource's collections.\n\nThis method yields type annotations from the base class `ClassRecord` and all collections associated with the resource. It utilizes the `iterate_types` method from the superclass to first yield its own types, and then iterates over each `collection` in the `self.collections` list, yielding types from each collection's `iterate_types` method.\n\nYields:\n    FakeAnnotation: The type annotations yielded from the superclass and collections.\n\nDependencies:\n- The method relies on the `collections` attribute, which is a list of `Collection` instances, and the `iterate_types` method from both `ClassRecord` and `Collection`. The `Collection` class is imported but only used if `TYPE_CHECKING` is true, indicating its purpose is primarily for type hinting rather than runtime operations.\"\"\"\n        '\\n        Iterate over all type annotations from collections.\\n        '\n        yield from super().iterate_types()\n        for collection in self.collections:\n            yield from collection.iterate_types()",
        "docstring": "Iterate over all type annotations from the resource's collections.\n\nThis method yields type annotations from the base class `ClassRecord` and all collections associated with the resource. It utilizes the `iterate_types` method from the superclass to first yield its own types, and then iterates over each `collection` in the `self.collections` list, yielding types from each collection's `iterate_types` method.\n\nYields:\n    FakeAnnotation: The type annotations yielded from the superclass and collections.\n\nDependencies:\n- The method relies on the `collections` attribute, which is a list of `Collection` instances, and the `iterate_types` method from both `ClassRecord` and `Collection`. The `Collection` class is imported but only used if `TYPE_CHECKING` is true, indicating its purpose is primarily for type hinting rather than runtime operations.",
        "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
        "type": "Method",
        "class_signature": "class ResourceRecord(ClassRecord):"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ExternalImport instance based on its attributes.\n\nThe hash is computed using a tuple containing the `source`, `name`, `alias`, and `safe` attributes. This method allows instances of ExternalImport to be used as hashable objects in sets or as dictionary keys.\n\nReturns:\n    int: The hash value derived from the instance's relevant attributes.\n\nAttributes used:\n- `source`: An ImportString representing the origin of the type annotation.\n- `name`: A string representing the name of the import.\n- `alias`: A string used as a local name for the import.\n- `safe`: A boolean indicating whether the import is wrapped in a try-except block.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate a hash value for the ExternalImport instance based on its attributes.\n\nThe hash is computed using a tuple containing the `source`, `name`, `alias`, and `safe` attributes. This method allows instances of ExternalImport to be used as hashable objects in sets or as dictionary keys.\n\nReturns:\n    int: The hash value derived from the instance's relevant attributes.\n\nAttributes used:\n- `source`: An ImportString representing the origin of the type annotation.\n- `name`: A string representing the name of the import.\n- `alias`: A string used as a local name for the import.\n- `safe`: A boolean indicating whether the import is wrapped in a try-except block.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/structures/collection.py": {
      "Collection.__init__": {
        "code": "    def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n        \"\"\"Initialize a Collection instance for a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource of the collection.\n- service_name (ServiceName): The service name represented by the collection, which aids in forming the documentation link.\n- type_annotation (FakeAnnotation): An annotation object that provides type information about the collection's items.\n- object_class_name (str): The name of the class representing the objects in the collection.\n\nThis constructor initializes a Collection instance, calling its superclass with specific parameters and setting attributes necessary for documentation generation and type iteration. The constant SERVICE_RESOURCE is used to conditionally modify the documentation link based on whether the parent name pertains to a service resource. This class interacts with the Boto3 library through ResourceCollection, which serves as the base for resource collections.\"\"\"\n        super().__init__(name=name, use_alias=True, bases=[ExternalImport.from_class(ResourceCollection)])\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name",
        "docstring": "Initialize a Collection instance for a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource of the collection.\n- service_name (ServiceName): The service name represented by the collection, which aids in forming the documentation link.\n- type_annotation (FakeAnnotation): An annotation object that provides type information about the collection's items.\n- object_class_name (str): The name of the class representing the objects in the collection.\n\nThis constructor initializes a Collection instance, calling its superclass with specific parameters and setting attributes necessary for documentation generation and type iteration. The constant SERVICE_RESOURCE is used to conditionally modify the documentation link based on whether the parent name pertains to a service resource. This class interacts with the Boto3 library through ResourceCollection, which serves as the base for resource collections.",
        "signature": "def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:__init__": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.from_class": {
          "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
          "docstring": "Create an instance from an imported class.\n\nArguments:\n    value -- Any Class.\n    alias -- Local name.\n    safe -- Whether import is wrapped in try-except.",
          "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"",
          "docstring": "",
          "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      }
    },
    "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:boto3_doc_link": {
      "mypy_boto3_builder/service_name.py": {
        "ServiceName.boto3_doc_link_parent": {
          "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )",
          "docstring": "Link to boto3 docs parent directory.",
          "signature": "def boto3_doc_link_parent(self) -> str:",
          "type": "Method",
          "class_signature": "class ServiceName:"
        }
      }
    },
    "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:iterate_types": {
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.iterate_types": {
          "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over type annotations for methods, attributes and bases.\n        \"\"\"\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()",
          "docstring": "Iterate over type annotations for methods, attributes and bases.",
          "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      },
      "mypy_boto3_builder/structures/collection.py": {
        "Collection.iterate_types": {
          "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations.\n        \"\"\"\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()",
          "docstring": "Iterate over all type annotations.",
          "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
          "type": "Method",
          "class_signature": "class Collection(ClassRecord):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.from_class": {
          "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
          "docstring": "Create an instance from an imported class.\n\nArguments:\n    value -- Any Class.\n    alias -- Local name.\n    safe -- Whether import is wrapped in try-except.",
          "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"",
          "docstring": "",
          "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_resource_record\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 structures/\n    \u2502   \u251c\u2500\u2500 collection.py\n    \u2502   \u2502   \u2514\u2500\u2500 Collection.__init__\n    \u2502   \u2514\u2500\u2500 resource_record.py\n    \u2502       \u251c\u2500\u2500 ResourceRecord.__init__\n    \u2502       \u251c\u2500\u2500 ResourceRecord.boto3_doc_link\n    \u2502       \u2514\u2500\u2500 ResourceRecord.iterate_types\n    \u2514\u2500\u2500 type_annotations/\n        \u2514\u2500\u2500 external_import.py\n            \u2514\u2500\u2500 ExternalImport.__hash__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and manage resource representations within the context of AWS services, leveraging static typing and structured metadata for improved reliability and documentation. It provides functionality to initialize, organize, and iterate over resource types, along with generating precise documentation links for Boto3 resources. By linking service-specific resources to structured collections, it facilitates seamless integration and extendability for developers working with AWS SDKs, ensuring accurate type annotations and clear traceability. This module addresses the need for consistent and type-safe handling of resources in AWS service implementations, reducing potential errors and enhancing developer productivity.\n\n## FILE 1: mypy_boto3_builder/structures/resource_record.py\n\n- CLASS METHOD: ResourceRecord.__init__\n  - CLASS SIGNATURE: class ResourceRecord(ClassRecord):\n  - SIGNATURE: def __init__(self, name: str, service_name: ServiceName) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ResourceRecord instance representing a Boto3 ServiceResource sub-Resource.\n\nParameters:\n- name (str): The name of the resource, used for identifying it within the service.\n- service_name (ServiceName): An instance representing the name of the service that this resource belongs to, which is used to generate documentation links and manage service characteristics.\n\nThis constructor calls the superclass initializer to establish inheritance from ClassRecord, setting up the base class as an external import of Boto3's ServiceResource. It initializes the service_name attribute to hold the service context and sets up an empty list for collections, which can hold related collections of resources. There are no return values, as this method initializes an object instance.\n\"\"\"\n```\n\n- CLASS METHOD: ResourceRecord.boto3_doc_link\n  - CLASS SIGNATURE: class ResourceRecord(ClassRecord):\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a formatted link to the Boto3 documentation for the specific service resource. The URL is constructed using the `service_name` and the `name` of the resource, ensuring that it leads to the appropriate section in the documentation.\n\nThe method relies on two attributes:\n- `self.service_name`: An instance of `ServiceName`, which provides the parent link to the Boto3 documentation specific to the service.\n- `self.name`: A string representing the name of the resource, which is used in the URL to pinpoint the exact resource documentation.\n\nThe resulting link follows the format:\n`<boto3_doc_link_parent>/<resource_name>/index.html#<service_class_name>.<resource_name>`.\n\nReturns:\n    str: A string containing the complete URL to the Boto3 documentation for the resource.\n\"\"\"\n```\n\n- CLASS METHOD: ResourceRecord.iterate_types\n  - CLASS SIGNATURE: class ResourceRecord(ClassRecord):\n  - SIGNATURE: def iterate_types(self) -> Iterator[FakeAnnotation]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over all type annotations from the resource's collections.\n\nThis method yields type annotations from the base class `ClassRecord` and all collections associated with the resource. It utilizes the `iterate_types` method from the superclass to first yield its own types, and then iterates over each `collection` in the `self.collections` list, yielding types from each collection's `iterate_types` method.\n\nYields:\n    FakeAnnotation: The type annotations yielded from the superclass and collections.\n\nDependencies:\n- The method relies on the `collections` attribute, which is a list of `Collection` instances, and the `iterate_types` method from both `ClassRecord` and `Collection`. The `Collection` class is imported but only used if `TYPE_CHECKING` is true, indicating its purpose is primarily for type hinting rather than runtime operations.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ExternalImport instance based on its attributes.\n\nThe hash is computed using a tuple containing the `source`, `name`, `alias`, and `safe` attributes. This method allows instances of ExternalImport to be used as hashable objects in sets or as dictionary keys.\n\nReturns:\n    int: The hash value derived from the instance's relevant attributes.\n\nAttributes used:\n- `source`: An ImportString representing the origin of the type annotation.\n- `name`: A string representing the name of the import.\n- `alias`: A string used as a local name for the import.\n- `safe`: A boolean indicating whether the import is wrapped in a try-except block.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/structures/collection.py\n\n- CLASS METHOD: Collection.__init__\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Collection instance for a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource of the collection.\n- service_name (ServiceName): The service name represented by the collection, which aids in forming the documentation link.\n- type_annotation (FakeAnnotation): An annotation object that provides type information about the collection's items.\n- object_class_name (str): The name of the class representing the objects in the collection.\n\nThis constructor initializes a Collection instance, calling its superclass with specific parameters and setting attributes necessary for documentation generation and type iteration. The constant SERVICE_RESOURCE is used to conditionally modify the documentation link based on whether the parent name pertains to a service resource. This class interacts with the Boto3 library through ResourceCollection, which serves as the base for resource collections.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/structures/resource_record.py": "\"\"\"\nBoto3 ServiceResource sub-Resource.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterator\nfrom typing import TYPE_CHECKING\nfrom boto3.resources.base import ServiceResource as Boto3ServiceResource\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nif TYPE_CHECKING:\n    from mypy_boto3_builder.structures.collection import Collection\n\nclass ResourceRecord(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource sub-Resource.\n    \"\"\"",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterator\nfrom boto3.resources.collection import ResourceCollection\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = 'service-resource' if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        return f'{self.service_name.boto3_doc_link_parent}/{parent_name_part}/{self.attribute_name}.html'\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'{self.boto3_doc_link_parent}#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations.\n        \"\"\"\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()"
  },
  "call_tree": {
    "tests/structures/test_resource_record.py:TestResource:setup_method": {
      "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:__init__": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
      }
    },
    "tests/structures/test_resource_record.py:TestResource:test_boto3_doc_link": {
      "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:boto3_doc_link": {
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
          "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
        }
      }
    },
    "tests/structures/test_resource_record.py:TestResource:test_iterate_types": {
      "mypy_boto3_builder/structures/resource_record.py:ResourceRecord:iterate_types": {
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:iterate_types": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
        },
        "mypy_boto3_builder/structures/collection.py:Collection:iterate_types": {
          "mypy_boto3_builder/structures/class_record.py:ClassRecord:iterate_types": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
          },
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
        }
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      },
      "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
      }
    }
  }
}