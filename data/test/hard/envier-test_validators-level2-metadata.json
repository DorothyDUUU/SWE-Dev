{
  "dir_path": "/app/envier",
  "package_name": "envier",
  "sample_name": "envier-test_validators",
  "src_dir": "envier/",
  "test_dir": "tests/",
  "test_file": "tests/test_validators.py",
  "test_code": "import typing as t\n\nimport pytest\n\nfrom envier import En\nfrom envier import validators as v\n\n\nclass Config(En):\n    foo = En.v(str, \"CHOICE\", validator=v.choice([\"a\", \"b\", \"c\"]))\n    bar = En.v(\n        t.Optional[str], \"OPT_CHOICE\", default=None, validator=v.choice([\"a\", \"b\", \"c\"])\n    )\n    n = En.v(int, \"SIZE\", default=0, validator=v.range(0, 100))\n\n\ndef test_choice(monkeypatch):\n    with pytest.raises(KeyError):\n        Config()\n\n    monkeypatch.setenv(\"CHOICE\", \"a\")\n    assert Config().foo == \"a\"\n\n    monkeypatch.setenv(\"CHOICE\", \"d\")\n    with pytest.raises(ValueError) as excinfo:\n        Config()\n\n    assert (\n        excinfo.value.args[0]\n        == \"Invalid value for environment variable CHOICE: value must be one of ['a', 'b', 'c']\"\n    )\n\n\ndef test_optional_choice(monkeypatch):\n    monkeypatch.setenv(\"CHOICE\", \"a\")\n\n    assert Config().bar is None\n\n    monkeypatch.setenv(\"OPT_CHOICE\", \"a\")\n    assert Config().bar == \"a\"\n\n    monkeypatch.setenv(\"OPT_CHOICE\", \"d\")\n    with pytest.raises(ValueError) as excinfo:\n        Config()\n\n    assert (\n        excinfo.value.args[0]\n        == \"Invalid value for environment variable OPT_CHOICE: value must be one of ['a', 'b', 'c']\"\n    )\n\n\ndef test_range(monkeypatch):\n    monkeypatch.setenv(\"CHOICE\", \"a\")\n\n    assert Config().n == 0\n\n    monkeypatch.setenv(\"SIZE\", \"-10\")\n    with pytest.raises(ValueError) as excinfo:\n        Config()\n\n    assert (\n        excinfo.value.args[0]\n        == \"Invalid value for environment variable SIZE: value must be in range [0, 100]\"\n    )\n",
  "GT_file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\n\nclass NoDefaultType(object):\n    def __str__(self):\n        return \"\"\n\n\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\n\n\nT = t.TypeVar(\"T\")\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple(\"HelpInfo\", (\"name\", \"type\", \"default\", \"help\"))\n\n\ndef _normalized(name: str) -> str:\n    return name.upper().replace(\".\", \"_\").rstrip(\"_\")\n\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, \"__origin__\"):\n        return isinstance(value, _type.__args__)  # type: ignore[attr-defined,union-attr]\n\n    return isinstance(value, _type)  # type: ignore[arg-type]\n\n\nclass EnvVariable(t.Generic[T]):\n    def __init__(\n        self,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> None:\n        if hasattr(type, \"__origin__\") and type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            if not isinstance(default, type.__args__):  # type: ignore[attr-defined,union-attr]\n                raise TypeError(\n                    \"default must be either of these types {}\".format(type.__args__)  # type: ignore[attr-defined,union-attr]\n                )\n        elif default is not NoDefault and not isinstance(default, type):  # type: ignore[arg-type]\n            raise TypeError(\"default must be of type {}\".format(type))\n\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n\n        self._full_name = _normalized(name)  # Will be set by the EnvMeta metaclass\n\n    @property\n    def full_name(self) -> str:\n        return f\"_{self._full_name}\" if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: \"Env\") -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(\n                T,\n                _type(  # type: ignore[operator]\n                    collection if self.map is None else map(self.map, collection)  # type: ignore[arg-type]\n                ),\n            )\n        elif _type is dict:\n            d = dict(\n                _.split(env.__value_separator__, 1)\n                for _ in raw.split(env.__item_separator__)\n            )\n            if self.map is not None:\n                d = dict(self.map(*_) for _ in d.items())\n            return t.cast(T, d)\n\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f\"cannot cast {raw} to {self.type}\"\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: \"Env\", prefix: str) -> T:\n        source = env.source\n\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f\"_{full_deprecated_name}\"\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = (\n                        \" in version %s\" % deprecated_when\n                        if deprecated_when is not None\n                        else \"\"\n                    )\n                    removed_when_message = (\n                        \" and will be removed in version %s\" % removed_when\n                        if removed_when is not None\n                        else \"\"\n                    )\n                    warnings.warn(\n                        \"%s has been deprecated%s%s. Use %s instead\"\n                        % (\n                            full_deprecated_name,\n                            deprecated_when_message,\n                            removed_when_message,\n                            full_name,\n                        ),\n                        DeprecationWarning,\n                    )\n                    break\n\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n\n            raise KeyError(\n                \"Mandatory environment variable {} is not set\".format(full_name)\n            )\n\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError(\n                    \"parser returned type {} instead of {}\".format(\n                        type(parsed), self.type\n                    )\n                )\n            return parsed\n\n        if hasattr(self.type, \"__origin__\") and self.type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            for ot in self.type.__args__:  # type: ignore[attr-defined,union-attr]\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: \"Env\", prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f\"Invalid value for environment variable {self.full_name}: {e}\"\n                raise ValueError(msg)\n\n        return value\n\n\nclass DerivedVariable(t.Generic[T]):\n    def __init__(self, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: \"Env\") -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError(\n                \"derivation returned type {} instead of {}\".format(\n                    type(value), self.type\n                )\n            )\n        return value\n\n\nclass EnvMeta(type):\n    def __new__(\n        cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]\n    ) -> t.Any:\n        env = t.cast(\"Env\", super().__new__(cls, name, bases, ns))\n\n        prefix = ns.get(\"__prefix__\")\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f\"{_normalized(prefix)}_{v._full_name}\".upper()\n\n        return env\n\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n\n    __truthy__ = frozenset({\"1\", \"true\", \"yes\", \"on\"})\n    __prefix__ = \"\"\n    __item__: t.Optional[str] = None\n    __item_separator__ = \",\"\n    __value_separator__ = \":\"\n\n    def __init__(\n        self,\n        source: t.Optional[t.Dict[str, str]] = None,\n        parent: t.Optional[\"Env\"] = None,\n        dynamic: t.Optional[t.Dict[str, str]] = None,\n    ) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = (\n            {k.upper(): v.upper() for k, v in dynamic.items()}\n            if dynamic is not None\n            else {}\n        )\n\n        self._full_prefix: str = (\n            parent._full_prefix if parent is not None else \"\"\n        ) + _normalized(self.__prefix__)\n        if self._full_prefix and not self._full_prefix.endswith(\"_\"):\n            self._full_prefix += \"_\"\n\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    # Move the subclass to the __item__ attribute\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def var(\n        cls,\n        type: t.Type[T],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def v(\n        cls,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def der(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type[\"Env\"]]] = deque()\n        path: t.Tuple[str] = tuple()  # type: ignore[assignment]\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield (\n                        \".\".join((*path, k)),\n                        t.cast(t.Union[EnvVariable, DerivedVariable], v),\n                    )\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, \"__item__\", k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))  # type: ignore[arg-type]\n\n    @classmethod\n    def keys(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(\n        cls,\n        env_spec: t.Type[\"Env\"],\n        namespace: t.Optional[str] = None,\n        overwrite: bool = False,\n    ) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        # Pick only the attributes that define variables.\n        to_include = {\n            k: v\n            for k, v in env_spec.__dict__.items()\n            if isinstance(v, (EnvVariable, DerivedVariable))\n            or isinstance(v, type)\n            and issubclass(v, Env)\n        }\n\n        own_prefix = _normalized(getattr(cls, \"__prefix__\", \"\"))\n\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError(\"Namespace already in use: {}\".format(namespace))\n\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n            return None\n\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError(\"Configuration clashes detected: {}\".format(overlap))\n\n        other_prefix = getattr(env_spec, \"__prefix__\", \"\")\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1 :]  # noqa\n                    if own_prefix:\n                        v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n    @classmethod\n    def help_info(\n        cls, recursive: bool = False, include_private: bool = False\n    ) -> t.List[HelpInfo]:\n        \"\"\"Extract the help information from the class.\n\n        Returns a list of all the environment variables declared by the class.\n        The format of each entry is a t.Tuple consisting of the variable name (in\n        double backtics quotes), the type, the default value, and the help text.\n\n        Set ``recursive`` to ``True`` to include variables from nested Env\n        classes.\n\n        Set ``include_private`` to ``True`` to include variables that are\n        marked as private (i.e. their name starts with an underscore).\n        \"\"\"\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted(\n                (_ for _ in config.values() if isinstance(_, EnvVariable)),\n                key=lambda v: v.name,\n            )\n\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n\n                # Add a period at the end if necessary.\n                help_message = v.help.strip() if v.help is not None else \"\"\n                if help_message and not help_message.endswith(\".\"):\n                    help_message += \".\"\n\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__  # type: ignore[attr-defined]\n                    except AttributeError:\n                        # typing.t.Union[<type>, NoneType]\n                        help_type = v.type.__args__[0].__name__  # type: ignore[attr-defined]\n\n                private_prefix = \"_\" if v.private else \"\"\n\n                entries.append(\n                    HelpInfo(\n                        f\"{private_prefix}{full_prefix}{_normalized(v.name)}\",\n                        help_type,  # type: ignore[attr-defined]\n                        (\n                            v.help_default\n                            if v.help_default is not None\n                            else str(v.default)\n                        ),\n                        help_message,\n                    )\n                )\n\n        configs = [(\"\", cls)]\n\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and not new_prefix.endswith(\"_\"):\n                new_prefix += \"_\"\n            add_entries(new_prefix, config)\n\n            if not recursive:\n                break\n\n            subconfigs = sorted(\n                (\n                    (new_prefix, v)\n                    for k, v in config.__dict__.items()\n                    if isinstance(v, type) and issubclass(v, Env) and k != \"parent\"\n                ),\n                key=lambda _: _[1].__prefix__,\n            )\n\n            configs[0:0] = subconfigs  # DFS\n\n        return entries\n",
    "envier/validators.py": "import typing as t\n\n\nT = t.TypeVar(\"T\")\n\n\ndef choice(choices: t.Iterable) -> t.Callable[[T], None]:\n    \"\"\"\n    A validator that checks if the value is one of the choices.\n    \"\"\"\n\n    def validate(value):\n        # type (T) -> None\n        if value is not None and value not in choices:\n            raise ValueError(\"value must be one of %r\" % sorted(choices))\n\n    return validate\n\n\ndef range(min_value: int, max_value: int) -> t.Callable[[T], None]:\n    \"\"\"\n    A validator that checks if the value is in the range.\n    \"\"\"\n\n    def validate(value):\n        # type (T) -> None\n        if value is not None and not (min_value <= value <= max_value):\n            raise ValueError(\"value must be in range [%r, %r]\" % (min_value, max_value))\n\n    return validate\n"
  },
  "GT_src_dict": {
    "envier/env.py": {
      "_normalized": {
        "code": "def _normalized(name: str) -> str:\n    \"\"\"Normalize a given string by transforming it to uppercase, replacing any dots (`.`) with underscores (`_`), and trimming any trailing underscores from the end.\n\nParameters:\n- name (str): The string to be normalized.\n\nReturns:\n- str: The normalized string in uppercase with dots replaced by underscores and trailing underscores removed.\n\nThis function is used within the context of environment variable handling, specifically in the `EnvVariable` class, to ensure consistent naming conventions when accessing environment variables. It helps in standardizing variable names before they are used to form keys for environment sources, thereby facilitating easier management and retrieval of configuration settings.\"\"\"\n    return name.upper().replace('.', '_').rstrip('_')",
        "docstring": "Normalize a given string by transforming it to uppercase, replacing any dots (`.`) with underscores (`_`), and trimming any trailing underscores from the end.\n\nParameters:\n- name (str): The string to be normalized.\n\nReturns:\n- str: The normalized string in uppercase with dots replaced by underscores and trailing underscores removed.\n\nThis function is used within the context of environment variable handling, specifically in the `EnvVariable` class, to ensure consistent naming conventions when accessing environment variables. It helps in standardizing variable names before they are used to form keys for environment sources, thereby facilitating easier management and retrieval of configuration settings.",
        "signature": "def _normalized(name: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "EnvVariable.__init__": {
        "code": "    def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n        \"\"\"Initialize an instance of the EnvVariable class, which represents an environment variable mapping in the Env configuration system.\n\nParameters:\n- type (Union[object, Type[T]]): The expected type of the environment variable's value.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): A function to parse the raw string value from the environment.\n- validator (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- map (Optional[MapType]): A function or callable used to transform the parsed values.\n- default (Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): A flag indicating if the variable should be treated as private. Default is False.\n- help (Optional[str]): A help string describing the environment variable.\n- help_type (Optional[str]): A description of the variable's type for documentation purposes.\n- help_default (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- TypeError: If the default value does not match the expected type.\n- KeyError: If a mandatory environment variable is not set and no default is provided.\n\nThe method uses the _normalized function to convert the variable name into a consistent format. It also checks for the expected type against a possible Union type and initializes several instance attributes to manage parsing, validation, and help documentation for the environment variable, enhancing the interaction with the broader Env class for managing configuration.\"\"\"\n        if hasattr(type, '__origin__') and type.__origin__ is t.Union:\n            if not isinstance(default, type.__args__):\n                raise TypeError('default must be either of these types {}'.format(type.__args__))\n        elif default is not NoDefault and (not isinstance(default, type)):\n            raise TypeError('default must be of type {}'.format(type))\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n        self._full_name = _normalized(name)",
        "docstring": "Initialize an instance of the EnvVariable class, which represents an environment variable mapping in the Env configuration system.\n\nParameters:\n- type (Union[object, Type[T]]): The expected type of the environment variable's value.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): A function to parse the raw string value from the environment.\n- validator (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- map (Optional[MapType]): A function or callable used to transform the parsed values.\n- default (Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): A flag indicating if the variable should be treated as private. Default is False.\n- help (Optional[str]): A help string describing the environment variable.\n- help_type (Optional[str]): A description of the variable's type for documentation purposes.\n- help_default (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- TypeError: If the default value does not match the expected type.\n- KeyError: If a mandatory environment variable is not set and no default is provided.\n\nThe method uses the _normalized function to convert the variable name into a consistent format. It also checks for the expected type against a possible Union type and initializes several instance attributes to manage parsing, validation, and help documentation for the environment variable, enhancing the interaction with the broader Env class for managing configuration.",
        "signature": "def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:",
        "type": "Method",
        "class_signature": "class EnvVariable(t.Generic[T]):"
      },
      "EnvVariable.__call__": {
        "code": "    def __call__(self, env: 'Env', prefix: str) -> T:\n        \"\"\"Calls the `EnvVariable` instance to retrieve its value from the specified environment (`env`) using the given prefix for name resolution. It first invokes the `_retrieve` method to get the raw value associated with the environment variable. If a validator function is provided, it checks the validity of the retrieved value, raising a `ValueError` if the value is deemed invalid. This method ultimately returns the parsed and possibly validated value of the environment variable.\n\nParameters:\n- env (Env): An instance of the `Env` class from which to fetch the variable value.\n- prefix (str): A namespace prefix used to construct the full name of the environment variable.\n\nReturns:\n- T: The value of the environment variable, potentially transformed by a parser or validator.\n\nThe method interacts with the `_retrieve` method of the `EnvVariable` class to handle the process of fetching and validating the environment variable's value. The `full_name` property is used to construct the formatted name for retrieving the variable from the environment. Should validator raise a `ValueError`, it is wrapped with additional context about the environment variable in the raised exception.\"\"\"\n        value = self._retrieve(env, prefix)\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f'Invalid value for environment variable {self.full_name}: {e}'\n                raise ValueError(msg)\n        return value",
        "docstring": "Calls the `EnvVariable` instance to retrieve its value from the specified environment (`env`) using the given prefix for name resolution. It first invokes the `_retrieve` method to get the raw value associated with the environment variable. If a validator function is provided, it checks the validity of the retrieved value, raising a `ValueError` if the value is deemed invalid. This method ultimately returns the parsed and possibly validated value of the environment variable.\n\nParameters:\n- env (Env): An instance of the `Env` class from which to fetch the variable value.\n- prefix (str): A namespace prefix used to construct the full name of the environment variable.\n\nReturns:\n- T: The value of the environment variable, potentially transformed by a parser or validator.\n\nThe method interacts with the `_retrieve` method of the `EnvVariable` class to handle the process of fetching and validating the environment variable's value. The `full_name` property is used to construct the formatted name for retrieving the variable from the environment. Should validator raise a `ValueError`, it is wrapped with additional context about the environment variable in the raised exception.",
        "signature": "def __call__(self, env: 'Env', prefix: str) -> T:",
        "type": "Method",
        "class_signature": "class EnvVariable(t.Generic[T]):"
      },
      "Env.__init__": {
        "code": "    def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:\n        \"\"\"Initialize an environment variable configuration instance.\n\nThis constructor sets up the environment object by configuring the source of environment variables, hierarchical relationships with a parent environment, and dynamically adjustable key-value pairs. It normalizes variable names based on the class prefix and initializes all declared `EnvVariable` and `DerivedVariable` instances. \n\nParameters:\n- `source` (Optional[Dict[str, str]]): A dictionary providing the source of environment variables. If not provided, defaults to `os.environ`.\n- `parent` (Optional[Env]): An optional parent `Env` instance which can provide context and prefixed variable names.\n- `dynamic` (Optional[Dict[str, str]]): An optional dictionary of dynamic values, where keys are strings and values are strings, used for any variable name substitution.\n\nSide Effects:\n- Sets up the full prefixed naming convention for environment variables.\n- Instantiates any declared `EnvVariable` and `DerivedVariable` in the environment, ensuring they are configured correctly against the source and parent.\n\nConstants:\n- The `__prefix__` class attribute is used to create a normalized full prefix for variable names by replacing dots with underscores. The normalization process is handled by the `_normalized` function.\n- The `derived` list temporarily holds any derived variable definitions for later instantiation, ensuring that all variables are correctly initialized upon creation of the `Env` instance.\"\"\"\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = {k.upper(): v.upper() for k, v in dynamic.items()} if dynamic is not None else {}\n        self._full_prefix: str = (parent._full_prefix if parent is not None else '') + _normalized(self.__prefix__)\n        if self._full_prefix and (not self._full_prefix.endswith('_')):\n            self._full_prefix += '_'\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n        for n, d in derived:\n            setattr(self, n, d(self))",
        "docstring": "Initialize an environment variable configuration instance.\n\nThis constructor sets up the environment object by configuring the source of environment variables, hierarchical relationships with a parent environment, and dynamically adjustable key-value pairs. It normalizes variable names based on the class prefix and initializes all declared `EnvVariable` and `DerivedVariable` instances. \n\nParameters:\n- `source` (Optional[Dict[str, str]]): A dictionary providing the source of environment variables. If not provided, defaults to `os.environ`.\n- `parent` (Optional[Env]): An optional parent `Env` instance which can provide context and prefixed variable names.\n- `dynamic` (Optional[Dict[str, str]]): An optional dictionary of dynamic values, where keys are strings and values are strings, used for any variable name substitution.\n\nSide Effects:\n- Sets up the full prefixed naming convention for environment variables.\n- Instantiates any declared `EnvVariable` and `DerivedVariable` in the environment, ensuring they are configured correctly against the source and parent.\n\nConstants:\n- The `__prefix__` class attribute is used to create a normalized full prefix for variable names by replacing dots with underscores. The normalization process is handled by the `_normalized` function.\n- The `derived` list temporarily holds any derived variable definitions for later instantiation, ensuring that all variables are correctly initialized upon creation of the `Env` instance.",
        "signature": "def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.v": {
        "code": "    def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        \"\"\"Add an environment variable mapping to the Env class.\n\nThis method allows the declaration of an environment variable for the Env class, associating it with a specified type, name, and optional processing functions (parser, validator, and map). It also supports default values, deprecation notes, and help documentation, which can facilitate user understanding of the variable's purpose.\n\nParameters:\n- type (Union[object, Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): An optional function to parse the raw string value into the desired type.\n- validator (Optional[Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function to convert environment values.\n- default (Union[T, NoDefaultType]): A default value, which must match the specified type if provided.\n- deprecations (Optional[List[DeprecationInfo]]): An optional list of tuples containing deprecation info for this variable.\n- private (bool): A flag indicating if the environment variable should be considered private.\n- help (Optional[str]): A help message describing the variable.\n- help_type (Optional[str]): A string specifying the expected type for help purposes.\n- help_default (Optional[str]): A help string indicating the default value.\n\nReturns:\n- EnvVariable[T]: An instance of EnvVariable, encapsulating the defined environment variable.\n\nThis method interacts with the EnvVariable class, which is responsible for handling the specified configurations and retrieving values from the environment based on defined types and properties.\"\"\"\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)",
        "docstring": "Add an environment variable mapping to the Env class.\n\nThis method allows the declaration of an environment variable for the Env class, associating it with a specified type, name, and optional processing functions (parser, validator, and map). It also supports default values, deprecation notes, and help documentation, which can facilitate user understanding of the variable's purpose.\n\nParameters:\n- type (Union[object, Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): An optional function to parse the raw string value into the desired type.\n- validator (Optional[Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function to convert environment values.\n- default (Union[T, NoDefaultType]): A default value, which must match the specified type if provided.\n- deprecations (Optional[List[DeprecationInfo]]): An optional list of tuples containing deprecation info for this variable.\n- private (bool): A flag indicating if the environment variable should be considered private.\n- help (Optional[str]): A help message describing the variable.\n- help_type (Optional[str]): A string specifying the expected type for help purposes.\n- help_default (Optional[str]): A help string indicating the default value.\n\nReturns:\n- EnvVariable[T]: An instance of EnvVariable, encapsulating the defined environment variable.\n\nThis method interacts with the EnvVariable class, which is responsible for handling the specified configurations and retrieving values from the environment based on defined types and properties.",
        "signature": "def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      }
    },
    "envier/validators.py": {
      "choice": {
        "code": "def choice(choices: t.Iterable) -> t.Callable[[T], None]:\n    \"\"\"A validator function that checks if a given value is one of the specified choices. \n\nParameters:\n- choices (t.Iterable): An iterable collection of valid options that the value can be compared against.\n\nReturns:\n- A callable (validate function) that takes a single argument (value) and raises a ValueError if the value is not one of the choices or is None.\n\nThis function relies on the generic type variable T from the typing module, which allows the validation to be applicable to any type of value provided by the user.\"\"\"\n    '\\n    A validator that checks if the value is one of the choices.\\n    '\n\n    def validate(value):\n        if value is not None and value not in choices:\n            raise ValueError('value must be one of %r' % sorted(choices))\n    return validate",
        "docstring": "A validator function that checks if a given value is one of the specified choices. \n\nParameters:\n- choices (t.Iterable): An iterable collection of valid options that the value can be compared against.\n\nReturns:\n- A callable (validate function) that takes a single argument (value) and raises a ValueError if the value is not one of the choices or is None.\n\nThis function relies on the generic type variable T from the typing module, which allows the validation to be applicable to any type of value provided by the user.",
        "signature": "def choice(choices: t.Iterable) -> t.Callable[[T], None]:",
        "type": "Function",
        "class_signature": null
      },
      "range": {
        "code": "def range(min_value: int, max_value: int) -> t.Callable[[T], None]:\n    \"\"\"Validates that a given value lies within a specified range.\n\nParameters:\n- min_value (int): The minimum acceptable value (inclusive).\n- max_value (int): The maximum acceptable value (inclusive).\n\nReturns:\n- Callable[[T], None]: A validation function that checks if the input value is within the given range. If the value is outside the range or not an integer, a ValueError is raised with a descriptive message.\n\nNotes:\n- This function is intended to be used as a decorator or a validator for other functions that require input validation.\n- It handles `None` values gracefully; if the input value is `None`, no validation is performed.\"\"\"\n    '\\n    A validator that checks if the value is in the range.\\n    '\n\n    def validate(value):\n        if value is not None and (not min_value <= value <= max_value):\n            raise ValueError('value must be in range [%r, %r]' % (min_value, max_value))\n    return validate",
        "docstring": "Validates that a given value lies within a specified range.\n\nParameters:\n- min_value (int): The minimum acceptable value (inclusive).\n- max_value (int): The maximum acceptable value (inclusive).\n\nReturns:\n- Callable[[T], None]: A validation function that checks if the input value is within the given range. If the value is outside the range or not an integer, a ValueError is raised with a descriptive message.\n\nNotes:\n- This function is intended to be used as a decorator or a validator for other functions that require input validation.\n- It handles `None` values gracefully; if the input value is `None`, no validation is performed.",
        "signature": "def range(min_value: int, max_value: int) -> t.Callable[[T], None]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: envier-test_validators\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 envier/\n    \u251c\u2500\u2500 env.py\n    \u2502   \u251c\u2500\u2500 DerivedVariable.DerivedVariable\n    \u2502   \u251c\u2500\u2500 Env.__init__\n    \u2502   \u251c\u2500\u2500 Env.v\n    \u2502   \u251c\u2500\u2500 EnvVariable.EnvVariable\n    \u2502   \u251c\u2500\u2500 EnvVariable.__call__\n    \u2502   \u251c\u2500\u2500 EnvVariable.__init__\n    \u2502   \u2514\u2500\u2500 _normalized\n    \u2514\u2500\u2500 validators.py\n        \u251c\u2500\u2500 choice\n        \u2514\u2500\u2500 range\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a robust configuration management system that validates environment variables based on predefined rules and constraints, ensuring reliability and correctness in application settings. It enables developers to define required and optional environment variables with specific value constraints, such as allowable choices or numerical ranges. By enforcing these validations, the module prevents invalid configurations at runtime, reducing potential errors and improving application stability. This solution streamlines the handling of environment-specific configurations, allowing developers to enforce stricter controls and enhance the overall quality of their services.\n\n## FILE 1: envier/env.py\n\n- FUNCTION NAME: _normalized\n  - SIGNATURE: def _normalized(name: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nNormalize a given string by transforming it to uppercase, replacing any dots (`.`) with underscores (`_`), and trimming any trailing underscores from the end.\n\nParameters:\n- name (str): The string to be normalized.\n\nReturns:\n- str: The normalized string in uppercase with dots replaced by underscores and trailing underscores removed.\n\nThis function is used within the context of environment variable handling, specifically in the `EnvVariable` class, to ensure consistent naming conventions when accessing environment variables. It helps in standardizing variable names before they are used to form keys for environment sources, thereby facilitating easier management and retrieval of configuration settings.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - envier/env.py:Env:__init__\n\n- CLASS METHOD: EnvVariable.__call__\n  - CLASS SIGNATURE: class EnvVariable(t.Generic[T]):\n  - SIGNATURE: def __call__(self, env: 'Env', prefix: str) -> T:\n  - DOCSTRING: \n```python\n\"\"\"\nCalls the `EnvVariable` instance to retrieve its value from the specified environment (`env`) using the given prefix for name resolution. It first invokes the `_retrieve` method to get the raw value associated with the environment variable. If a validator function is provided, it checks the validity of the retrieved value, raising a `ValueError` if the value is deemed invalid. This method ultimately returns the parsed and possibly validated value of the environment variable.\n\nParameters:\n- env (Env): An instance of the `Env` class from which to fetch the variable value.\n- prefix (str): A namespace prefix used to construct the full name of the environment variable.\n\nReturns:\n- T: The value of the environment variable, potentially transformed by a parser or validator.\n\nThe method interacts with the `_retrieve` method of the `EnvVariable` class to handle the process of fetching and validating the environment variable's value. The `full_name` property is used to construct the formatted name for retrieving the variable from the environment. Should validator raise a `ValueError`, it is wrapped with additional context about the environment variable in the raised exception.\n\"\"\"\n```\n\n- CLASS METHOD: Env.v\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd an environment variable mapping to the Env class.\n\nThis method allows the declaration of an environment variable for the Env class, associating it with a specified type, name, and optional processing functions (parser, validator, and map). It also supports default values, deprecation notes, and help documentation, which can facilitate user understanding of the variable's purpose.\n\nParameters:\n- type (Union[object, Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): An optional function to parse the raw string value into the desired type.\n- validator (Optional[Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function to convert environment values.\n- default (Union[T, NoDefaultType]): A default value, which must match the specified type if provided.\n- deprecations (Optional[List[DeprecationInfo]]): An optional list of tuples containing deprecation info for this variable.\n- private (bool): A flag indicating if the environment variable should be considered private.\n- help (Optional[str]): A help message describing the variable.\n- help_type (Optional[str]): A string specifying the expected type for help purposes.\n- help_default (Optional[str]): A help string indicating the default value.\n\nReturns:\n- EnvVariable[T]: An instance of EnvVariable, encapsulating the defined environment variable.\n\nThis method interacts with the EnvVariable class, which is responsible for handling the specified configurations and retrieving values from the environment based on defined types and properties.\n\"\"\"\n```\n\n- CLASS METHOD: EnvVariable.__init__\n  - CLASS SIGNATURE: class EnvVariable(t.Generic[T]):\n  - SIGNATURE: def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the EnvVariable class, which represents an environment variable mapping in the Env configuration system.\n\nParameters:\n- type (Union[object, Type[T]]): The expected type of the environment variable's value.\n- name (str): The name of the environment variable.\n- parser (Optional[Callable[[str], T]]): A function to parse the raw string value from the environment.\n- validator (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- map (Optional[MapType]): A function or callable used to transform the parsed values.\n- default (Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): A flag indicating if the variable should be treated as private. Default is False.\n- help (Optional[str]): A help string describing the environment variable.\n- help_type (Optional[str]): A description of the variable's type for documentation purposes.\n- help_default (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- TypeError: If the default value does not match the expected type.\n- KeyError: If a mandatory environment variable is not set and no default is provided.\n\nThe method uses the _normalized function to convert the variable name into a consistent format. It also checks for the expected type against a possible Union type and initializes several instance attributes to manage parsing, validation, and help documentation for the environment variable, enhancing the interaction with the broader Env class for managing configuration.\n\"\"\"\n```\n\n- CLASS METHOD: Env.__init__\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an environment variable configuration instance.\n\nThis constructor sets up the environment object by configuring the source of environment variables, hierarchical relationships with a parent environment, and dynamically adjustable key-value pairs. It normalizes variable names based on the class prefix and initializes all declared `EnvVariable` and `DerivedVariable` instances. \n\nParameters:\n- `source` (Optional[Dict[str, str]]): A dictionary providing the source of environment variables. If not provided, defaults to `os.environ`.\n- `parent` (Optional[Env]): An optional parent `Env` instance which can provide context and prefixed variable names.\n- `dynamic` (Optional[Dict[str, str]]): An optional dictionary of dynamic values, where keys are strings and values are strings, used for any variable name substitution.\n\nSide Effects:\n- Sets up the full prefixed naming convention for environment variables.\n- Instantiates any declared `EnvVariable` and `DerivedVariable` in the environment, ensuring they are configured correctly against the source and parent.\n\nConstants:\n- The `__prefix__` class attribute is used to create a normalized full prefix for variable names by replacing dots with underscores. The normalization process is handled by the `_normalized` function.\n- The `derived` list temporarily holds any derived variable definitions for later instantiation, ensuring that all variables are correctly initialized upon creation of the `Env` instance.\n\"\"\"\n```\n\n## FILE 2: envier/validators.py\n\n- FUNCTION NAME: choice\n  - SIGNATURE: def choice(choices: t.Iterable) -> t.Callable[[T], None]:\n  - DOCSTRING: \n```python\n\"\"\"\nA validator function that checks if a given value is one of the specified choices. \n\nParameters:\n- choices (t.Iterable): An iterable collection of valid options that the value can be compared against.\n\nReturns:\n- A callable (validate function) that takes a single argument (value) and raises a ValueError if the value is not one of the choices or is None.\n\nThis function relies on the generic type variable T from the typing module, which allows the validation to be applicable to any type of value provided by the user.\n\"\"\"\n```\n\n- FUNCTION NAME: range\n  - SIGNATURE: def range(min_value: int, max_value: int) -> t.Callable[[T], None]:\n  - DOCSTRING: \n```python\n\"\"\"\nValidates that a given value lies within a specified range.\n\nParameters:\n- min_value (int): The minimum acceptable value (inclusive).\n- max_value (int): The maximum acceptable value (inclusive).\n\nReturns:\n- Callable[[T], None]: A validation function that checks if the input value is within the given range. If the value is outside the range or not an integer, a ValueError is raised with a descriptive message.\n\nNotes:\n- This function is intended to be used as a decorator or a validator for other functions that require input validation.\n- It handles `None` values gracefully; if the input value is `None`, no validation is performed.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\nclass NoDefaultType(object):\n\n    def __str__(self):\n        return ''\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\nT = t.TypeVar('T')\nK = t.TypeVar('K')\nV = t.TypeVar('V')\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple('HelpInfo', ('name', 'type', 'default', 'help'))\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, '__origin__'):\n        return isinstance(value, _type.__args__)\n    return isinstance(value, _type)\n\nclass EnvVariable(t.Generic[T]):\n\n    @property\n    def full_name(self) -> str:\n        return f'_{self._full_name}' if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: 'Env') -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(T, _type(collection if self.map is None else map(self.map, collection)))\n        elif _type is dict:\n            d = dict((_.split(env.__value_separator__, 1) for _ in raw.split(env.__item_separator__)))\n            if self.map is not None:\n                d = dict((self.map(*_) for _ in d.items()))\n            return t.cast(T, d)\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f'cannot cast {raw} to {self.type}'\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: 'Env', prefix: str) -> T:\n        source = env.source\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f'_{full_deprecated_name}'\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = ' in version %s' % deprecated_when if deprecated_when is not None else ''\n                    removed_when_message = ' and will be removed in version %s' % removed_when if removed_when is not None else ''\n                    warnings.warn('%s has been deprecated%s%s. Use %s instead' % (full_deprecated_name, deprecated_when_message, removed_when_message, full_name), DeprecationWarning)\n                    break\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n            raise KeyError('Mandatory environment variable {} is not set'.format(full_name))\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError('parser returned type {} instead of {}'.format(type(parsed), self.type))\n            return parsed\n        if hasattr(self.type, '__origin__') and self.type.__origin__ is t.Union:\n            for ot in self.type.__args__:\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n        return self._cast(self.type, raw, env)\n\nclass DerivedVariable(t.Generic[T]):\n\n    def __init__(self, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: 'Env') -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError('derivation returned type {} instead of {}'.format(type(value), self.type))\n        return value\n\nclass EnvMeta(type):\n\n    def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n        env = t.cast('Env', super().__new__(cls, name, bases, ns))\n        prefix = ns.get('__prefix__')\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f'{_normalized(prefix)}_{v._full_name}'.upper()\n        return env\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n    __truthy__ = frozenset({'1', 'true', 'yes', 'on'})\n    __prefix__ = ''\n    __item__: t.Optional[str] = None\n    __item_separator__ = ','\n    __value_separator__ = ':'\n\n    @classmethod\n    def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)\n\n    @classmethod\n    def der(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type['Env']]] = deque()\n        path: t.Tuple[str] = tuple()\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield ('.'.join((*path, k)), t.cast(t.Union[EnvVariable, DerivedVariable], v))\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, '__item__', k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))\n\n    @classmethod\n    def keys(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(cls, env_spec: t.Type['Env'], namespace: t.Optional[str]=None, overwrite: bool=False) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        to_include = {k: v for k, v in env_spec.__dict__.items() if isinstance(v, (EnvVariable, DerivedVariable)) or (isinstance(v, type) and issubclass(v, Env))}\n        own_prefix = _normalized(getattr(cls, '__prefix__', ''))\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError('Namespace already in use: {}'.format(namespace))\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f'{own_prefix}_{v._full_name}'\n            return None\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError('Configuration clashes detected: {}'.format(overlap))\n        other_prefix = getattr(env_spec, '__prefix__', '')\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1:]\n                    if own_prefix:\n                        v._full_name = f'{own_prefix}_{v._full_name}'\n\n    @classmethod\n    def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n        \"\"\"Extract the help information from the class.\n\n        Returns a list of all the environment variables declared by the class.\n        The format of each entry is a t.Tuple consisting of the variable name (in\n        double backtics quotes), the type, the default value, and the help text.\n\n        Set ``recursive`` to ``True`` to include variables from nested Env\n        classes.\n\n        Set ``include_private`` to ``True`` to include variables that are\n        marked as private (i.e. their name starts with an underscore).\n        \"\"\"\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted((_ for _ in config.values() if isinstance(_, EnvVariable)), key=lambda v: v.name)\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n                help_message = v.help.strip() if v.help is not None else ''\n                if help_message and (not help_message.endswith('.')):\n                    help_message += '.'\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__\n                    except AttributeError:\n                        help_type = v.type.__args__[0].__name__\n                private_prefix = '_' if v.private else ''\n                entries.append(HelpInfo(f'{private_prefix}{full_prefix}{_normalized(v.name)}', help_type, v.help_default if v.help_default is not None else str(v.default), help_message))\n        configs = [('', cls)]\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and (not new_prefix.endswith('_')):\n                new_prefix += '_'\n            add_entries(new_prefix, config)\n            if not recursive:\n                break\n            subconfigs = sorted(((new_prefix, v) for k, v in config.__dict__.items() if isinstance(v, type) and issubclass(v, Env) and (k != 'parent')), key=lambda _: _[1].__prefix__)\n            configs[0:0] = subconfigs\n        return entries",
    "envier/validators.py": "import typing as t\nT = t.TypeVar('T')"
  },
  "call_tree": {
    "tests/test_validators.py:Config:Config": {
      "envier/validators.py:choice": {},
      "envier/env.py:Env:v": {
        "envier/env.py:EnvVariable:__init__": {
          "envier/env.py:_normalized": {}
        }
      },
      "envier/validators.py:range": {}
    },
    "tests/test_validators.py:test_choice": {
      "envier/env.py:Env:__init__": {
        "envier/env.py:EnvVariable:EnvVariable": {},
        "envier/env.py:DerivedVariable:DerivedVariable": {},
        "envier/env.py:_normalized": {},
        "envier/env.py:EnvVariable:__call__": {
          "envier/env.py:EnvVariable:_retrieve": {
            "envier/env.py:NoDefaultType:NoDefaultType": {},
            "envier/env.py:EnvVariable:full_name": {},
            "envier/env.py:EnvVariable:_cast": {
              "envier/env.py:_check_type": {}
            }
          },
          "envier/validators.py:validate": {},
          "envier/env.py:EnvVariable:full_name": {}
        }
      }
    },
    "tests/test_validators.py:test_optional_choice": {
      "envier/env.py:Env:__init__": {
        "envier/env.py:_normalized": {},
        "envier/env.py:EnvVariable:__call__": {
          "envier/env.py:EnvVariable:_retrieve": {
            "envier/env.py:EnvVariable:full_name": {},
            "envier/env.py:EnvVariable:_cast": {
              "envier/env.py:_check_type": {}
            }
          },
          "envier/validators.py:validate": {},
          "envier/env.py:EnvVariable:full_name": {}
        }
      }
    },
    "tests/test_validators.py:test_range": {
      "envier/env.py:Env:__init__": {
        "envier/env.py:_normalized": {},
        "envier/env.py:EnvVariable:__call__": {
          "envier/env.py:EnvVariable:_retrieve": {
            "envier/env.py:EnvVariable:full_name": {},
            "envier/env.py:EnvVariable:_cast": {
              "envier/env.py:_check_type": {}
            }
          },
          "envier/validators.py:validate": {},
          "envier/env.py:EnvVariable:full_name": {}
        }
      }
    }
  }
}