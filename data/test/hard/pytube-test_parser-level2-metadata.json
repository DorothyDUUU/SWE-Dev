{
  "dir_path": "/app/pytube",
  "package_name": "pytube",
  "sample_name": "pytube-test_parser",
  "src_dir": "pytube/",
  "test_dir": "tests/",
  "test_file": "tests/test_parser.py",
  "test_code": "import json\nimport pytest\n\nfrom pytube.exceptions import HTMLParseError\nfrom pytube.parser import parse_for_object\n\n\ndef test_invalid_start():\n    with pytest.raises(HTMLParseError):\n        parse_for_object('test = {}', r'invalid_regex')\n\n\ndef test_parse_simple_empty_object():\n    result = parse_for_object('test = {}', r'test\\s*=\\s*')\n    assert result == {}\n\n\ndef test_parse_longer_empty_object():\n    test_html = \"\"\"test = {\n\n\n    }\"\"\"\n    result = parse_for_object(test_html, r'test\\s*=\\s*')\n    assert result == {}\n\n\ndef test_parse_empty_object_with_trailing_characters():\n    test_html = 'test = {};'\n    result = parse_for_object(test_html, r'test\\s*=\\s*')\n    assert result == {}\n\n\ndef test_parse_simple_object():\n    test_html = 'test = {\"foo\": [], \"bar\": {}};'\n    result = parse_for_object(test_html, r'test\\s*=\\s*')\n    assert result == {\n        'foo': [],\n        'bar': {}\n    }\n\n\ndef test_parse_context_closer_in_string_value():\n    test_html = 'test = {\"foo\": \"};\"};'\n    result = parse_for_object(test_html, r'test\\s*=\\s*')\n    assert result == {\n        'foo': '};'\n    }\n\n\ndef test_parse_object_requiring_ast():\n    invalid_json = '{\"foo\": \"bar\",}'\n    test_html = f'test = {invalid_json}'\n    with pytest.raises(json.decoder.JSONDecodeError):\n        json.loads(invalid_json)\n    result = parse_for_object(test_html, r'test\\s*=\\s*')\n    assert result == {\n        'foo': 'bar'\n    }\n",
  "GT_file_code": {
    "pytube/parser.py": "import ast\nimport json\nimport re\nfrom pytube.exceptions import HTMLParseError\n\n\ndef parse_for_all_objects(html, preceding_regex):\n    \"\"\"Parses input html to find all matches for the input starting point.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param str preceding_regex:\n        Regex to find the string preceding the object.\n    :rtype list:\n    :returns:\n        A list of dicts created from parsing the objects.\n    \"\"\"\n    result = []\n    regex = re.compile(preceding_regex)\n    match_iter = regex.finditer(html)\n    for match in match_iter:\n        if match:\n            start_index = match.end()\n            try:\n                obj = parse_for_object_from_startpoint(html, start_index)\n            except HTMLParseError:\n                # Some of the instances might fail because set is technically\n                # a method of the ytcfg object. We'll skip these since they\n                # don't seem relevant at the moment.\n                continue\n            else:\n                result.append(obj)\n\n    if len(result) == 0:\n        raise HTMLParseError(f'No matches for regex {preceding_regex}')\n\n    return result\n\n\ndef parse_for_object(html, preceding_regex):\n    \"\"\"Parses input html to find the end of a JavaScript object.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param str preceding_regex:\n        Regex to find the string preceding the object.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    regex = re.compile(preceding_regex)\n    result = regex.search(html)\n    if not result:\n        raise HTMLParseError(f'No matches for regex {preceding_regex}')\n\n    start_index = result.end()\n    return parse_for_object_from_startpoint(html, start_index)\n\n\ndef find_object_from_startpoint(html, start_point):\n    \"\"\"Parses input html to find the end of a JavaScript object.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param int start_point:\n        Index of where the object starts.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    html = html[start_point:]\n    if html[0] not in ['{','[']:\n        raise HTMLParseError(f'Invalid start point. Start of HTML:\\n{html[:20]}')\n\n    # First letter MUST be a open brace, so we put that in the stack,\n    # and skip the first character.\n    last_char = '{'\n    curr_char = None\n    stack = [html[0]]\n    i = 1\n\n    context_closers = {\n        '{': '}',\n        '[': ']',\n        '\"': '\"',\n        '/': '/' # javascript regex\n    }\n\n    while i < len(html):\n        if len(stack) == 0:\n            break\n        if curr_char not in [' ', '\\n']:\n            last_char = curr_char\n        curr_char = html[i]\n        curr_context = stack[-1]\n\n        # If we've reached a context closer, we can remove an element off the stack\n        if curr_char == context_closers[curr_context]:\n            stack.pop()\n            i += 1\n            continue\n\n        # Strings and regex expressions require special context handling because they can contain\n        #  context openers *and* closers\n        if curr_context in ['\"', '/']:\n            # If there's a backslash in a string or regex expression, we skip a character\n            if curr_char == '\\\\':\n                i += 2\n                continue\n        else:\n            # Non-string contexts are when we need to look for context openers.\n            if curr_char in context_closers.keys():\n                # Slash starts a regular expression depending on context\n                if not (curr_char == '/' and last_char not in ['(', ',', '=', ':', '[', '!', '&', '|', '?', '{', '}', ';']): \n                    stack.append(curr_char)\n\n        i += 1\n\n    full_obj = html[:i]\n    return full_obj  # noqa: R504\n\n\ndef parse_for_object_from_startpoint(html, start_point):\n    \"\"\"JSONifies an object parsed from HTML.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param int start_point:\n        Index of where the object starts.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    full_obj = find_object_from_startpoint(html, start_point)\n    try:\n        return json.loads(full_obj)\n    except json.decoder.JSONDecodeError:\n        try:\n            return ast.literal_eval(full_obj)\n        except (ValueError, SyntaxError):\n            raise HTMLParseError('Could not parse object.')\n\n\ndef throttling_array_split(js_array):\n    \"\"\"Parses the throttling array into a python list of strings.\n\n    Expects input to begin with `[` and close with `]`.\n\n    :param str js_array:\n        The javascript array, as a string.\n    :rtype: list:\n    :returns:\n        A list of strings representing splits on `,` in the throttling array.\n    \"\"\"\n    results = []\n    curr_substring = js_array[1:]\n\n    comma_regex = re.compile(r\",\")\n    func_regex = re.compile(r\"function\\([^)]*\\)\")\n\n    while len(curr_substring) > 0:\n        if curr_substring.startswith('function'):\n            # Handle functions separately. These can contain commas\n            match = func_regex.search(curr_substring)\n            match_start, match_end = match.span()\n\n            function_text = find_object_from_startpoint(curr_substring, match.span()[1])\n            full_function_def = curr_substring[:match_end + len(function_text)]\n            results.append(full_function_def)\n            curr_substring = curr_substring[len(full_function_def) + 1:]\n        else:\n            match = comma_regex.search(curr_substring)\n\n            # Try-catch to capture end of array\n            try:\n                match_start, match_end = match.span()\n            except AttributeError:\n                match_start = len(curr_substring) - 1\n                match_end = match_start + 1\n\n            curr_el = curr_substring[:match_start]\n            results.append(curr_el)\n            curr_substring = curr_substring[match_end:]\n\n    return results\n"
  },
  "GT_src_dict": {
    "pytube/parser.py": {
      "parse_for_object": {
        "code": "def parse_for_object(html, preceding_regex):\n    \"\"\"Parses the input HTML to locate and extract a JavaScript object following a specified preceding regex pattern.\n\n:param str html: The HTML content to be parsed for an object.\n:param str preceding_regex: A regex pattern that specifies where to search for the start of the object.\n:rtype dict: A dictionary representation of the extracted JavaScript object.\n:raises HTMLParseError: If the regex does not match any part of the HTML, or if parsing the object fails.\n \nThis function utilizes the `parse_for_object_from_startpoint` function to convert the JavaScript object found in the HTML into a Python dictionary. The regular expression compiled from `preceding_regex` is used to locate the start of the object, ensuring that the object format adheres to the expected structure.\"\"\"\n    'Parses input html to find the end of a JavaScript object.\\n\\n    :param str html:\\n        HTML to be parsed for an object.\\n    :param str preceding_regex:\\n        Regex to find the string preceding the object.\\n    :rtype dict:\\n    :returns:\\n        A dict created from parsing the object.\\n    '\n    regex = re.compile(preceding_regex)\n    result = regex.search(html)\n    if not result:\n        raise HTMLParseError(f'No matches for regex {preceding_regex}')\n    start_index = result.end()\n    return parse_for_object_from_startpoint(html, start_index)",
        "docstring": "Parses the input HTML to locate and extract a JavaScript object following a specified preceding regex pattern.\n\n:param str html: The HTML content to be parsed for an object.\n:param str preceding_regex: A regex pattern that specifies where to search for the start of the object.\n:rtype dict: A dictionary representation of the extracted JavaScript object.\n:raises HTMLParseError: If the regex does not match any part of the HTML, or if parsing the object fails.\n \nThis function utilizes the `parse_for_object_from_startpoint` function to convert the JavaScript object found in the HTML into a Python dictionary. The regular expression compiled from `preceding_regex` is used to locate the start of the object, ensuring that the object format adheres to the expected structure.",
        "signature": "def parse_for_object(html, preceding_regex):",
        "type": "Function",
        "class_signature": null
      },
      "parse_for_object_from_startpoint": {
        "code": "def parse_for_object_from_startpoint(html, start_point):\n    \"\"\"Parses a JavaScript object embedded in HTML, starting from a specified index, and converts it into a Python dictionary.\n\n:param str html: \n    The HTML content that contains the JavaScript object to be parsed.\n:param int start_point: \n    The index in the HTML string where the JavaScript object begins.\n:rtype: dict\n:returns: \n    A dictionary created from the parsed JavaScript object.\n\nThis function utilizes the `find_object_from_startpoint` function to extract the full object as a string. It first attempts to decode the extracted JSON using `json.loads()`. If that fails due to invalid JSON format, it will try to use `ast.literal_eval()` for parsing. If both methods fail, an `HTMLParseError` exception is raised, indicating that the object could not be parsed. The function relies on the `HTMLParseError` exception from the `pytube.exceptions` module to handle parsing errors effectively.\"\"\"\n    'JSONifies an object parsed from HTML.\\n\\n    :param str html:\\n        HTML to be parsed for an object.\\n    :param int start_point:\\n        Index of where the object starts.\\n    :rtype dict:\\n    :returns:\\n        A dict created from parsing the object.\\n    '\n    full_obj = find_object_from_startpoint(html, start_point)\n    try:\n        return json.loads(full_obj)\n    except json.decoder.JSONDecodeError:\n        try:\n            return ast.literal_eval(full_obj)\n        except (ValueError, SyntaxError):\n            raise HTMLParseError('Could not parse object.')",
        "docstring": "Parses a JavaScript object embedded in HTML, starting from a specified index, and converts it into a Python dictionary.\n\n:param str html: \n    The HTML content that contains the JavaScript object to be parsed.\n:param int start_point: \n    The index in the HTML string where the JavaScript object begins.\n:rtype: dict\n:returns: \n    A dictionary created from the parsed JavaScript object.\n\nThis function utilizes the `find_object_from_startpoint` function to extract the full object as a string. It first attempts to decode the extracted JSON using `json.loads()`. If that fails due to invalid JSON format, it will try to use `ast.literal_eval()` for parsing. If both methods fail, an `HTMLParseError` exception is raised, indicating that the object could not be parsed. The function relies on the `HTMLParseError` exception from the `pytube.exceptions` module to handle parsing errors effectively.",
        "signature": "def parse_for_object_from_startpoint(html, start_point):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "pytube/parser.py:parse_for_object": {},
    "pytube/parser.py:parse_for_object_from_startpoint": {
      "pytube/parser.py": {
        "find_object_from_startpoint": {
          "code": "def find_object_from_startpoint(html, start_point):\n    \"\"\"Parses input html to find the end of a JavaScript object.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param int start_point:\n        Index of where the object starts.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    html = html[start_point:]\n    if html[0] not in ['{', '[']:\n        raise HTMLParseError(f'Invalid start point. Start of HTML:\\n{html[:20]}')\n    last_char = '{'\n    curr_char = None\n    stack = [html[0]]\n    i = 1\n    context_closers = {'{': '}', '[': ']', '\"': '\"', '/': '/'}\n    while i < len(html):\n        if len(stack) == 0:\n            break\n        if curr_char not in [' ', '\\n']:\n            last_char = curr_char\n        curr_char = html[i]\n        curr_context = stack[-1]\n        if curr_char == context_closers[curr_context]:\n            stack.pop()\n            i += 1\n            continue\n        if curr_context in ['\"', '/']:\n            if curr_char == '\\\\':\n                i += 2\n                continue\n        elif curr_char in context_closers.keys():\n            if not (curr_char == '/' and last_char not in ['(', ',', '=', ':', '[', '!', '&', '|', '?', '{', '}', ';']):\n                stack.append(curr_char)\n        i += 1\n    full_obj = html[:i]\n    return full_obj",
          "docstring": "Parses input html to find the end of a JavaScript object.\n\n:param str html:\n    HTML to be parsed for an object.\n:param int start_point:\n    Index of where the object starts.\n:rtype dict:\n:returns:\n    A dict created from parsing the object.",
          "signature": "def find_object_from_startpoint(html, start_point):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pytube-test_parser\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pytube/\n    \u2514\u2500\u2500 parser.py\n        \u251c\u2500\u2500 parse_for_object\n        \u2514\u2500\u2500 parse_for_object_from_startpoint\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and extract structured JSON-like objects embedded in HTML content or strings. Its primary functionality is to accurately parse and return objects from text based on a provided regex pattern, even when the input contains irregularities such as trailing characters or unconventional formatting. It handles cases where parsing errors may occur, identifying and processing scenarios requiring additional adjustments for valid JSON decoding. By enabling reliable extraction of embedded object data, this module simplifies the process for developers working with dynamically generated or poorly formatted HTML content, ensuring the data can be utilized programmatically with minimal preprocessing.\n\n## FILE 1: pytube/parser.py\n\n- FUNCTION NAME: parse_for_object_from_startpoint\n  - SIGNATURE: def parse_for_object_from_startpoint(html, start_point):\n  - DOCSTRING: \n```python\n\"\"\"\nParses a JavaScript object embedded in HTML, starting from a specified index, and converts it into a Python dictionary.\n\n:param str html: \n    The HTML content that contains the JavaScript object to be parsed.\n:param int start_point: \n    The index in the HTML string where the JavaScript object begins.\n:rtype: dict\n:returns: \n    A dictionary created from the parsed JavaScript object.\n\nThis function utilizes the `find_object_from_startpoint` function to extract the full object as a string. It first attempts to decode the extracted JSON using `json.loads()`. If that fails due to invalid JSON format, it will try to use `ast.literal_eval()` for parsing. If both methods fail, an `HTMLParseError` exception is raised, indicating that the object could not be parsed. The function relies on the `HTMLParseError` exception from the `pytube.exceptions` module to handle parsing errors effectively.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/parser.py:find_object_from_startpoint\n    - pytube/parser.py:parse_for_object\n\n- FUNCTION NAME: parse_for_object\n  - SIGNATURE: def parse_for_object(html, preceding_regex):\n  - DOCSTRING: \n```python\n\"\"\"\nParses the input HTML to locate and extract a JavaScript object following a specified preceding regex pattern.\n\n:param str html: The HTML content to be parsed for an object.\n:param str preceding_regex: A regex pattern that specifies where to search for the start of the object.\n:rtype dict: A dictionary representation of the extracted JavaScript object.\n:raises HTMLParseError: If the regex does not match any part of the HTML, or if parsing the object fails.\n \nThis function utilizes the `parse_for_object_from_startpoint` function to convert the JavaScript object found in the HTML into a Python dictionary. The regular expression compiled from `preceding_regex` is used to locate the start of the object, ensuring that the object format adheres to the expected structure.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/parser.py:parse_for_object_from_startpoint\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pytube/parser.py": "import ast\nimport json\nimport re\nfrom pytube.exceptions import HTMLParseError\n\ndef parse_for_all_objects(html, preceding_regex):\n    \"\"\"Parses input html to find all matches for the input starting point.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param str preceding_regex:\n        Regex to find the string preceding the object.\n    :rtype list:\n    :returns:\n        A list of dicts created from parsing the objects.\n    \"\"\"\n    result = []\n    regex = re.compile(preceding_regex)\n    match_iter = regex.finditer(html)\n    for match in match_iter:\n        if match:\n            start_index = match.end()\n            try:\n                obj = parse_for_object_from_startpoint(html, start_index)\n            except HTMLParseError:\n                continue\n            else:\n                result.append(obj)\n    if len(result) == 0:\n        raise HTMLParseError(f'No matches for regex {preceding_regex}')\n    return result\n\ndef find_object_from_startpoint(html, start_point):\n    \"\"\"Parses input html to find the end of a JavaScript object.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param int start_point:\n        Index of where the object starts.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    html = html[start_point:]\n    if html[0] not in ['{', '[']:\n        raise HTMLParseError(f'Invalid start point. Start of HTML:\\n{html[:20]}')\n    last_char = '{'\n    curr_char = None\n    stack = [html[0]]\n    i = 1\n    context_closers = {'{': '}', '[': ']', '\"': '\"', '/': '/'}\n    while i < len(html):\n        if len(stack) == 0:\n            break\n        if curr_char not in [' ', '\\n']:\n            last_char = curr_char\n        curr_char = html[i]\n        curr_context = stack[-1]\n        if curr_char == context_closers[curr_context]:\n            stack.pop()\n            i += 1\n            continue\n        if curr_context in ['\"', '/']:\n            if curr_char == '\\\\':\n                i += 2\n                continue\n        elif curr_char in context_closers.keys():\n            if not (curr_char == '/' and last_char not in ['(', ',', '=', ':', '[', '!', '&', '|', '?', '{', '}', ';']):\n                stack.append(curr_char)\n        i += 1\n    full_obj = html[:i]\n    return full_obj\n\ndef throttling_array_split(js_array):\n    \"\"\"Parses the throttling array into a python list of strings.\n\n    Expects input to begin with `[` and close with `]`.\n\n    :param str js_array:\n        The javascript array, as a string.\n    :rtype: list:\n    :returns:\n        A list of strings representing splits on `,` in the throttling array.\n    \"\"\"\n    results = []\n    curr_substring = js_array[1:]\n    comma_regex = re.compile(',')\n    func_regex = re.compile('function\\\\([^)]*\\\\)')\n    while len(curr_substring) > 0:\n        if curr_substring.startswith('function'):\n            match = func_regex.search(curr_substring)\n            match_start, match_end = match.span()\n            function_text = find_object_from_startpoint(curr_substring, match.span()[1])\n            full_function_def = curr_substring[:match_end + len(function_text)]\n            results.append(full_function_def)\n            curr_substring = curr_substring[len(full_function_def) + 1:]\n        else:\n            match = comma_regex.search(curr_substring)\n            try:\n                match_start, match_end = match.span()\n            except AttributeError:\n                match_start = len(curr_substring) - 1\n                match_end = match_start + 1\n            curr_el = curr_substring[:match_start]\n            results.append(curr_el)\n            curr_substring = curr_substring[match_end:]\n    return results"
  },
  "call_tree": {
    "tests/test_parser.py:test_invalid_start": {
      "pytube/parser.py:parse_for_object": {}
    },
    "tests/test_parser.py:test_parse_simple_empty_object": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    },
    "tests/test_parser.py:test_parse_longer_empty_object": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    },
    "tests/test_parser.py:test_parse_empty_object_with_trailing_characters": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    },
    "tests/test_parser.py:test_parse_simple_object": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    },
    "tests/test_parser.py:test_parse_context_closer_in_string_value": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    },
    "tests/test_parser.py:test_parse_object_requiring_ast": {
      "pytube/parser.py:parse_for_object": {
        "pytube/parser.py:parse_for_object_from_startpoint": {
          "pytube/parser.py:find_object_from_startpoint": {}
        }
      }
    }
  }
}