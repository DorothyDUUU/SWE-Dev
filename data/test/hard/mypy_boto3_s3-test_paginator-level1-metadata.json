{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_paginator",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_paginator.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.structures.paginator import Paginator\n\n\nclass TestPaginator:\n    paginator: Paginator\n\n    def setup_method(self) -> None:\n        self.paginator = Paginator(\n            name=\"name\",\n            operation_name=\"my_operation_name\",\n            service_name=ServiceNameCatalog.s3,\n            paginator_name=\"paginator_name\",\n        )\n\n    def test_init(self) -> None:\n        assert self.paginator.name == \"name\"\n        assert self.paginator.operation_name == \"my_operation_name\"\n        assert self.paginator.service_name == ServiceNameCatalog.s3\n\n    def test_boto3_doc_link(self) -> None:\n        assert (\n            self.paginator.boto3_doc_link\n            == \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/paginator/paginator_name.html#S3.Paginator.paginator_name\"\n        )\n\n    def test_get_client_method(self) -> None:\n        result = self.paginator.get_client_method()\n        assert result.name == \"get_paginator\"\n        assert result.return_type.name == \"name\"  # type: ignore\n        assert result.arguments[1].type_annotation.children == {\"my_operation_name\"}  # type: ignore\n",
  "GT_file_code": {
    "mypy_boto3_builder/structures/paginator.py": "\"\"\"\nBoto3 client Paginator.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom botocore.paginate import Paginator as BotocorePaginator\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\n\n\n@functools.total_ordering\nclass Paginator(ClassRecord):\n    \"\"\"\n    Boto3 client Paginator.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        paginator_name: str,\n        operation_name: str,\n        service_name: ServiceName,\n    ) -> None:\n        super().__init__(\n            name=name,\n            bases=[ExternalImport.from_class(BotocorePaginator)],\n        )\n        self.operation_name = operation_name\n        self.paginator_name = paginator_name\n        self.service_name = service_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Hash paginators by name.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort paginators by name.\n        \"\"\"\n        return self.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, Paginator):\n            raise BuildInternalError(f\"{other} is not Paginator\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}\"\n            f\"/paginator/{self.paginator_name}.html\"\n            f\"#{self.service_name.class_name}.Paginator.{self.paginator_name}\"\n        )\n\n    def get_client_method(self) -> Method:\n        \"\"\"\n        Get `get_paginator` method for `Client`.\n        \"\"\"\n        return Method(\n            name=\"get_paginator\",\n            decorators=[Type.overload],\n            docstring=self.docstring,\n            arguments=[\n                Argument.self(),\n                Argument(\n                    \"operation_name\",\n                    TypeLiteral(f\"{self.name}Name\", [self.operation_name]),\n                ),\n            ],\n            return_type=ExternalImport(\n                source=ImportString(\"\", ServiceModuleName.paginator.value),\n                name=self.name,\n            ),\n        )\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/structures/paginator.py": {
      "Paginator.__init__": {
        "code": "    def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:\n        \"\"\"Initialize a Paginator instance for Boto3 client pagination.\n\nParameters:\n- name (str): The name of the paginator, used for identification and sorting.\n- paginator_name (str): The specific name of the paginator as defined in the Boto3 documentation.\n- operation_name (str): The name of the operation that this paginator will be associated with.\n- service_name (ServiceName): An instance of ServiceName that identifies the AWS service for which this paginator is created.\n\nThis constructor calls the parent class (ClassRecord) constructor with the provided name and sets the base class to Botocore's Paginator using ExternalImport. The service_name attribute stores the service's relevant link to Boto3 documentation, facilitating easy access to related resources.\"\"\"\n        super().__init__(name=name, bases=[ExternalImport.from_class(BotocorePaginator)])\n        self.operation_name = operation_name\n        self.paginator_name = paginator_name\n        self.service_name = service_name",
        "docstring": "Initialize a Paginator instance for Boto3 client pagination.\n\nParameters:\n- name (str): The name of the paginator, used for identification and sorting.\n- paginator_name (str): The specific name of the paginator as defined in the Boto3 documentation.\n- operation_name (str): The name of the operation that this paginator will be associated with.\n- service_name (ServiceName): An instance of ServiceName that identifies the AWS service for which this paginator is created.\n\nThis constructor calls the parent class (ClassRecord) constructor with the provided name and sets the base class to Botocore's Paginator using ExternalImport. The service_name attribute stores the service's relevant link to Boto3 documentation, facilitating easy access to related resources.",
        "signature": "def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      },
      "Paginator.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Generate a link to the Boto3 documentation for the paginator associated with the AWS service.\n\nReturns:\n    str: A formatted URL that points to the specific paginator documentation in Boto3, \n         constructed using the `service_name`, `paginator_name`, and relevant base URL from `boto3_doc_link_parent`.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: Refers to the base link for the service's documentation, defined as part of the `ServiceName` class.\n- `self.paginator_name`: Represents the specific paginator's name for generating the correct documentation link.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'{self.service_name.boto3_doc_link_parent}/paginator/{self.paginator_name}.html#{self.service_name.class_name}.Paginator.{self.paginator_name}'",
        "docstring": "Generate a link to the Boto3 documentation for the paginator associated with the AWS service.\n\nReturns:\n    str: A formatted URL that points to the specific paginator documentation in Boto3, \n         constructed using the `service_name`, `paginator_name`, and relevant base URL from `boto3_doc_link_parent`.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: Refers to the base link for the service's documentation, defined as part of the `ServiceName` class.\n- `self.paginator_name`: Represents the specific paginator's name for generating the correct documentation link.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      },
      "Paginator.get_client_method": {
        "code": "    def get_client_method(self) -> Method:\n        \"\"\"Retrieve the `get_paginator` method for a Boto3 client, which allows for pagination of AWS service operations. \n\nThis method constructs and returns a `Method` object that represents the `get_paginator` function. It includes the method name, decorators, documentation string, and the necessary arguments. The first argument is `self`, and the second is `operation_name`, which is typed as `TypeLiteral` based on the paginator's name and the corresponding operation name.\n\nThe return type is specified as `ExternalImport`, linking to the paginator class defined in the service module, allowing for proper integration with the Boto3 client.\n\nDependencies include:\n- `TypeLiteral`: to specify the type of `operation_name`.\n- `ExternalImport` and `ImportString`: to dynamically reference the paginator class in the appropriate service module.\n- `ServiceModuleName.paginator.value`: used to define the service module from which the paginator is imported.\n\nThis method is essential for providing type annotations and facilitating the use of paginators in the Boto3 client context.\"\"\"\n        '\\n        Get `get_paginator` method for `Client`.\\n        '\n        return Method(name='get_paginator', decorators=[Type.overload], docstring=self.docstring, arguments=[Argument.self(), Argument('operation_name', TypeLiteral(f'{self.name}Name', [self.operation_name]))], return_type=ExternalImport(source=ImportString('', ServiceModuleName.paginator.value), name=self.name))",
        "docstring": "Retrieve the `get_paginator` method for a Boto3 client, which allows for pagination of AWS service operations. \n\nThis method constructs and returns a `Method` object that represents the `get_paginator` function. It includes the method name, decorators, documentation string, and the necessary arguments. The first argument is `self`, and the second is `operation_name`, which is typed as `TypeLiteral` based on the paginator's name and the corresponding operation name.\n\nThe return type is specified as `ExternalImport`, linking to the paginator class defined in the service module, allowing for proper integration with the Boto3 client.\n\nDependencies include:\n- `TypeLiteral`: to specify the type of `operation_name`.\n- `ExternalImport` and `ImportString`: to dynamically reference the paginator class in the appropriate service module.\n- `ServiceModuleName.paginator.value`: used to define the service module from which the paginator is imported.\n\nThis method is essential for providing type annotations and facilitating the use of paginators in the Boto3 client context.",
        "signature": "def get_client_method(self) -> Method:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/structures/paginator.py:Paginator:__init__": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.from_class": {
          "code": "    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )",
          "docstring": "Create an instance from an imported class.\n\nArguments:\n    value -- Any Class.\n    alias -- Local name.\n    safe -- Whether import is wrapped in try-except.",
          "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"",
          "docstring": "",
          "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      }
    },
    "mypy_boto3_builder/structures/paginator.py:Paginator:boto3_doc_link": {
      "mypy_boto3_builder/service_name.py": {
        "ServiceName.boto3_doc_link_parent": {
          "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )",
          "docstring": "Link to boto3 docs parent directory.",
          "signature": "def boto3_doc_link_parent(self) -> str:",
          "type": "Method",
          "class_signature": "class ServiceName:"
        }
      }
    },
    "mypy_boto3_builder/structures/paginator.py:Paginator:get_client_method": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__init__": {
          "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
          "docstring": "",
          "signature": "def __init__(self, parent: str, *parts: str) -> None:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        type_annotation: FakeAnnotation | None,\n        default: TypeConstant | None = None,\n        prefix: Literal[\"*\", \"**\", \"\"] = \"\",\n    ) -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal[\"*\", \"**\", \"\"] = prefix",
          "docstring": "",
          "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:",
          "type": "Method",
          "class_signature": "class Argument:"
        },
        "Argument.self": {
          "code": "    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
          "docstring": "Create `self` argument.",
          "signature": "def self(cls) -> Self:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      },
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.__init__": {
          "code": "    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe",
          "docstring": "",
          "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/type_annotations/type_literal.py": {
        "TypeLiteral.__init__": {
          "code": "    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError(\"Literal should have children\")",
          "docstring": "",
          "signature": "def __init__(self, name: str, children: Iterable[str]) -> None:",
          "type": "Method",
          "class_signature": "class TypeLiteral(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
          "docstring": "",
          "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_paginator\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 structures/\n        \u2514\u2500\u2500 paginator.py\n            \u251c\u2500\u2500 Paginator.__init__\n            \u251c\u2500\u2500 Paginator.boto3_doc_link\n            \u2514\u2500\u2500 Paginator.get_client_method\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and test the functionality of a `Paginator` component in the context of AWS services using the `boto3` library. It ensures that the paginator is initialized correctly with key attributes, such as name, operation, associated service, and documentation link, enabling seamless interaction with AWS service paginators like those in S3. The module also verifies the paginator's ability to generate client methods for retrieving paginated data effectively. By providing robust validation and documentation integration, it addresses challenges developers face when managing and testing paginated service interactions, ensuring correctness and improving the development experience.\n\n## FILE 1: mypy_boto3_builder/structures/paginator.py\n\n- CLASS METHOD: Paginator.boto3_doc_link\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a link to the Boto3 documentation for the paginator associated with the AWS service.\n\nReturns:\n    str: A formatted URL that points to the specific paginator documentation in Boto3, \n         constructed using the `service_name`, `paginator_name`, and relevant base URL from `boto3_doc_link_parent`.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: Refers to the base link for the service's documentation, defined as part of the `ServiceName` class.\n- `self.paginator_name`: Represents the specific paginator's name for generating the correct documentation link.\n\"\"\"\n```\n\n- CLASS METHOD: Paginator.get_client_method\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def get_client_method(self) -> Method:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the `get_paginator` method for a Boto3 client, which allows for pagination of AWS service operations. \n\nThis method constructs and returns a `Method` object that represents the `get_paginator` function. It includes the method name, decorators, documentation string, and the necessary arguments. The first argument is `self`, and the second is `operation_name`, which is typed as `TypeLiteral` based on the paginator's name and the corresponding operation name.\n\nThe return type is specified as `ExternalImport`, linking to the paginator class defined in the service module, allowing for proper integration with the Boto3 client.\n\nDependencies include:\n- `TypeLiteral`: to specify the type of `operation_name`.\n- `ExternalImport` and `ImportString`: to dynamically reference the paginator class in the appropriate service module.\n- `ServiceModuleName.paginator.value`: used to define the service module from which the paginator is imported.\n\nThis method is essential for providing type annotations and facilitating the use of paginators in the Boto3 client context.\n\"\"\"\n```\n\n- CLASS METHOD: Paginator.__init__\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Paginator instance for Boto3 client pagination.\n\nParameters:\n- name (str): The name of the paginator, used for identification and sorting.\n- paginator_name (str): The specific name of the paginator as defined in the Boto3 documentation.\n- operation_name (str): The name of the operation that this paginator will be associated with.\n- service_name (ServiceName): An instance of ServiceName that identifies the AWS service for which this paginator is created.\n\nThis constructor calls the parent class (ClassRecord) constructor with the provided name and sets the base class to Botocore's Paginator using ExternalImport. The service_name attribute stores the service's relevant link to Boto3 documentation, facilitating easy access to related resources.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/structures/paginator.py": "\"\"\"\nBoto3 client Paginator.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom botocore.paginate import Paginator as BotocorePaginator\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\n\n@functools.total_ordering\nclass Paginator(ClassRecord):\n    \"\"\"\n    Boto3 client Paginator.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Hash paginators by name.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort paginators by name.\n        \"\"\"\n        return self.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, Paginator):\n            raise BuildInternalError(f'{other} is not Paginator')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()"
  },
  "call_tree": {
    "tests/structures/test_paginator.py:TestPaginator:setup_method": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:__init__": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
      }
    },
    "tests/structures/test_paginator.py:TestPaginator:test_boto3_doc_link": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:boto3_doc_link": {
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
          "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
        }
      }
    },
    "tests/structures/test_paginator.py:TestPaginator:test_get_client_method": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:get_client_method": {
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {},
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {},
        "mypy_boto3_builder/structures/function.py:Function:__init__": {}
      }
    }
  }
}