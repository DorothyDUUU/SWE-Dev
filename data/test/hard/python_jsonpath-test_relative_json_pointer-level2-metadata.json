{
  "dir_path": "/app/python_jsonpath",
  "package_name": "python_jsonpath",
  "sample_name": "python_jsonpath-test_relative_json_pointer",
  "src_dir": "jsonpath/",
  "test_dir": "tests/",
  "test_file": "tests/test_relative_json_pointer.py",
  "test_code": "\"\"\"Relative JSON Pointer test cases.\"\"\"\nimport pytest\n\nfrom jsonpath import JSONPointer\nfrom jsonpath import RelativeJSONPointer\nfrom jsonpath import RelativeJSONPointerIndexError\nfrom jsonpath import RelativeJSONPointerSyntaxError\n\n\ndef test_syntax_error() -> None:\n    with pytest.raises(RelativeJSONPointerSyntaxError):\n        RelativeJSONPointer(\"foo\")\n\n\ndef test_origin_leading_zero() -> None:\n    with pytest.raises(RelativeJSONPointerSyntaxError):\n        RelativeJSONPointer(\"01\")\n\n\ndef test_origin_beyond_pointer() -> None:\n    pointer = JSONPointer(\"/foo/bar/0\")\n    rel = RelativeJSONPointer(\"9/foo\")\n    with pytest.raises(RelativeJSONPointerIndexError):\n        rel.to(pointer)\n\n\ndef test_equality() -> None:\n    rel = RelativeJSONPointer(\"1/foo\")\n    assert rel == RelativeJSONPointer(\"1/foo\")\n\n\ndef test_zero_index_offset() -> None:\n    with pytest.raises(RelativeJSONPointerSyntaxError):\n        RelativeJSONPointer(\"1-0\")\n\n    with pytest.raises(RelativeJSONPointerSyntaxError):\n        RelativeJSONPointer(\"1+0\")\n\n\ndef test_negative_index_offset() -> None:\n    pointer = JSONPointer(\"/foo/1\")\n    rel = RelativeJSONPointer(\"0-2\")\n    with pytest.raises(RelativeJSONPointerIndexError):\n        rel.to(pointer)\n",
  "GT_file_code": {
    "jsonpath/filter.py": "\"\"\"Filter expression nodes.\"\"\"\n\nfrom __future__ import annotations\n\nimport copy\nimport json\nimport re\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Pattern\nfrom typing import Sequence\nfrom typing import TypeVar\n\nfrom jsonpath.function_extensions.filter_function import ExpressionType\n\nfrom .exceptions import JSONPathTypeError\nfrom .function_extensions import FilterFunction\nfrom .match import NodeList\nfrom .selectors import Filter as FilterSelector\nfrom .selectors import ListSelector\n\nif TYPE_CHECKING:\n    from .path import JSONPath\n    from .selectors import FilterContext\n\n# ruff: noqa: D102\n\n\nclass FilterExpression(ABC):\n    \"\"\"Base class for all filter expression nodes.\"\"\"\n\n    __slots__ = (\"volatile\",)\n\n    FORCE_CACHE = False\n\n    def __init__(self) -> None:\n        self.volatile: bool = any(child.volatile for child in self.children())\n\n    @abstractmethod\n    def evaluate(self, context: FilterContext) -> object:\n        \"\"\"Resolve the filter expression in the given _context_.\n\n        Arguments:\n            context: Contextual information the expression might choose\n                use during evaluation.\n\n        Returns:\n            The result of evaluating the expression.\n        \"\"\"\n\n    @abstractmethod\n    async def evaluate_async(self, context: FilterContext) -> object:\n        \"\"\"An async version of `evaluate`.\"\"\"\n\n    @abstractmethod\n    def children(self) -> List[FilterExpression]:\n        \"\"\"Return a list of direct child expressions.\"\"\"\n\n    @abstractmethod\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        \"\"\"Update this expression's child expressions.\n\n        _children_ is assumed to have the same number of items as is returned\n        by _self.children_, and in the same order.\n        \"\"\"\n\n\nclass Nil(FilterExpression):\n    \"\"\"The constant `nil`.\n\n    Also aliased as `null` and `None`, sometimes.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return other is None or isinstance(other, Nil)\n\n    def __repr__(self) -> str:  # pragma: no cover\n        return \"NIL()\"\n\n    def __str__(self) -> str:  # pragma: no cover\n        return \"nil\"\n\n    def evaluate(self, _: FilterContext) -> None:\n        return None\n\n    async def evaluate_async(self, _: FilterContext) -> None:\n        return None\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        return\n\n\nNIL = Nil()\n\n\nclass _Undefined:\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            other is UNDEFINED_LITERAL\n            or other is UNDEFINED\n            or (isinstance(other, NodeList) and other.empty())\n        )\n\n    def __str__(self) -> str:\n        return \"<UNDEFINED>\"\n\n    def __repr__(self) -> str:\n        return \"<UNDEFINED>\"\n\n\n# This is equivalent to the spec's special `Nothing` value.\nUNDEFINED = _Undefined()\n\n\nclass Undefined(FilterExpression):\n    \"\"\"The constant `undefined`.\"\"\"\n\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            isinstance(other, Undefined)\n            or other is UNDEFINED\n            or (isinstance(other, NodeList) and len(other) == 0)\n        )\n\n    def __str__(self) -> str:\n        return \"undefined\"\n\n    def evaluate(self, _: FilterContext) -> object:\n        return UNDEFINED\n\n    async def evaluate_async(self, _: FilterContext) -> object:\n        return UNDEFINED\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        return\n\n\nUNDEFINED_LITERAL = Undefined()\n\nLITERAL_EXPRESSION_T = TypeVar(\"LITERAL_EXPRESSION_T\")\n\n\nclass Literal(FilterExpression, Generic[LITERAL_EXPRESSION_T]):\n    \"\"\"Base class for filter expression literals.\"\"\"\n\n    __slots__ = (\"value\",)\n\n    def __init__(self, *, value: LITERAL_EXPRESSION_T) -> None:\n        self.value = value\n        super().__init__()\n\n    def __str__(self) -> str:\n        return repr(self.value).lower()\n\n    def __eq__(self, other: object) -> bool:\n        return self.value == other\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def evaluate(self, _: FilterContext) -> LITERAL_EXPRESSION_T:\n        return self.value\n\n    async def evaluate_async(self, _: FilterContext) -> LITERAL_EXPRESSION_T:\n        return self.value\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        return\n\n\nclass BooleanLiteral(Literal[bool]):\n    \"\"\"A Boolean `True` or `False`.\"\"\"\n\n    __slots__ = ()\n\n\nTRUE = BooleanLiteral(value=True)\n\n\nFALSE = BooleanLiteral(value=False)\n\n\nclass StringLiteral(Literal[str]):\n    \"\"\"A string literal.\"\"\"\n\n    __slots__ = ()\n\n    def __str__(self) -> str:\n        return json.dumps(self.value)\n\n\nclass IntegerLiteral(Literal[int]):\n    \"\"\"An integer literal.\"\"\"\n\n    __slots__ = ()\n\n\nclass FloatLiteral(Literal[float]):\n    \"\"\"A float literal.\"\"\"\n\n    __slots__ = ()\n\n\nclass RegexLiteral(Literal[Pattern[str]]):\n    \"\"\"A regex literal.\"\"\"\n\n    __slots__ = ()\n\n    RE_FLAG_MAP = {\n        re.A: \"a\",\n        re.I: \"i\",\n        re.M: \"m\",\n        re.S: \"s\",\n    }\n\n    RE_UNESCAPE = re.compile(r\"\\\\(.)\")\n\n    def __str__(self) -> str:\n        flags: List[str] = []\n        for flag, ch in self.RE_FLAG_MAP.items():\n            if self.value.flags & flag:\n                flags.append(ch)\n\n        pattern = re.sub(r\"\\\\(.)\", r\"\\1\", self.value.pattern)\n        return f\"/{pattern}/{''.join(flags)}\"\n\n\nclass ListLiteral(FilterExpression):\n    \"\"\"A list literal.\"\"\"\n\n    __slots__ = (\"items\",)\n\n    def __init__(self, items: List[FilterExpression]) -> None:\n        self.items = items\n        super().__init__()\n\n    def __str__(self) -> str:\n        items = \", \".join(str(item) for item in self.items)\n        return f\"[{items}]\"\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, ListLiteral) and self.items == other.items\n\n    def evaluate(self, context: FilterContext) -> object:\n        return [item.evaluate(context) for item in self.items]\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return [await item.evaluate_async(context) for item in self.items]\n\n    def children(self) -> List[FilterExpression]:\n        return self.items\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        self.items = children\n\n\nclass PrefixExpression(FilterExpression):\n    \"\"\"An expression composed of a prefix operator and another expression.\"\"\"\n\n    __slots__ = (\"operator\", \"right\")\n\n    def __init__(self, operator: str, right: FilterExpression):\n        self.operator = operator\n        self.right = right\n        super().__init__()\n\n    def __str__(self) -> str:\n        return f\"{self.operator}{self.right}\"\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            isinstance(other, PrefixExpression)\n            and self.operator == other.operator\n            and self.right == other.right\n        )\n\n    def _evaluate(self, context: FilterContext, right: object) -> object:\n        if self.operator == \"!\":\n            return not context.env.is_truthy(right)\n        raise JSONPathTypeError(f\"unknown operator {self.operator} {self.right}\")\n\n    def evaluate(self, context: FilterContext) -> object:\n        return self._evaluate(context, self.right.evaluate(context))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return self._evaluate(context, await self.right.evaluate_async(context))\n\n    def children(self) -> List[FilterExpression]:\n        return [self.right]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 1\n        self.right = children[0]\n\n\nclass InfixExpression(FilterExpression):\n    \"\"\"A pair of expressions and a comparison or logical operator.\"\"\"\n\n    __slots__ = (\"left\", \"operator\", \"right\", \"logical\")\n\n    def __init__(\n        self,\n        left: FilterExpression,\n        operator: str,\n        right: FilterExpression,\n    ):\n        self.left = left\n        self.operator = operator\n        self.right = right\n        self.logical = operator in (\"&&\", \"||\")\n        super().__init__()\n\n    def __str__(self) -> str:\n        if self.logical:\n            return f\"({self.left} {self.operator} {self.right})\"\n        return f\"{self.left} {self.operator} {self.right}\"\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            isinstance(other, InfixExpression)\n            and self.left == other.left\n            and self.operator == other.operator\n            and self.right == other.right\n        )\n\n    def evaluate(self, context: FilterContext) -> bool:\n        left = self.left.evaluate(context)\n        if not self.logical and isinstance(left, NodeList) and len(left) == 1:\n            left = left[0].obj\n\n        right = self.right.evaluate(context)\n        if not self.logical and isinstance(right, NodeList) and len(right) == 1:\n            right = right[0].obj\n\n        return context.env.compare(left, self.operator, right)\n\n    async def evaluate_async(self, context: FilterContext) -> bool:\n        left = await self.left.evaluate_async(context)\n        if not self.logical and isinstance(left, NodeList) and len(left) == 1:\n            left = left[0].obj\n\n        right = await self.right.evaluate_async(context)\n        if not self.logical and isinstance(right, NodeList) and len(right) == 1:\n            right = right[0].obj\n\n        return context.env.compare(left, self.operator, right)\n\n    def children(self) -> List[FilterExpression]:\n        return [self.left, self.right]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 2  # noqa: PLR2004\n        self.left = children[0]\n        self.right = children[1]\n\n\nclass BooleanExpression(FilterExpression):\n    \"\"\"An expression that always evaluates to `True` or `False`.\"\"\"\n\n    __slots__ = (\"expression\",)\n\n    def __init__(self, expression: FilterExpression):\n        self.expression = expression\n        super().__init__()\n\n    def cache_tree(self) -> BooleanExpression:\n        \"\"\"Return a copy of _self.expression_ augmented with caching nodes.\"\"\"\n\n        def _cache_tree(expr: FilterExpression) -> FilterExpression:\n            children = expr.children()\n            if expr.volatile:\n                _expr = copy.copy(expr)\n            elif not expr.FORCE_CACHE and len(children) == 0:\n                _expr = expr\n            else:\n                _expr = CachingFilterExpression(copy.copy(expr))\n            _expr.set_children([_cache_tree(child) for child in children])\n            return _expr\n\n        return BooleanExpression(_cache_tree(copy.copy(self.expression)))\n\n    def cacheable_nodes(self) -> bool:\n        \"\"\"Return `True` if there are any cacheable nodes in this expression tree.\"\"\"\n        return any(\n            isinstance(node, CachingFilterExpression)\n            for node in walk(self.cache_tree())\n        )\n\n    def __str__(self) -> str:\n        return str(self.expression)\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            isinstance(other, BooleanExpression) and self.expression == other.expression\n        )\n\n    def evaluate(self, context: FilterContext) -> bool:\n        return context.env.is_truthy(self.expression.evaluate(context))\n\n    async def evaluate_async(self, context: FilterContext) -> bool:\n        return context.env.is_truthy(await self.expression.evaluate_async(context))\n\n    def children(self) -> List[FilterExpression]:\n        return [self.expression]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 1\n        self.expression = children[0]\n\n\nclass CachingFilterExpression(FilterExpression):\n    \"\"\"A FilterExpression wrapper that caches the result.\"\"\"\n\n    __slots__ = (\n        \"_cached\",\n        \"_expr\",\n    )\n\n    _UNSET = object()\n\n    def __init__(self, expression: FilterExpression):\n        self.volatile = False\n        self._expr = expression\n        self._cached: object = self._UNSET\n\n    def evaluate(self, context: FilterContext) -> object:\n        if self._cached is self._UNSET:\n            self._cached = self._expr.evaluate(context)\n        return self._cached\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        if self._cached is self._UNSET:\n            self._cached = await self._expr.evaluate_async(context)\n        return self._cached\n\n    def children(self) -> List[FilterExpression]:\n        return self._expr.children()\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        self._expr.set_children(children)\n\n\nclass Path(FilterExpression, ABC):\n    \"\"\"Base expression for all _sub paths_ found in filter expressions.\"\"\"\n\n    __slots__ = (\"path\",)\n\n    def __init__(self, path: JSONPath) -> None:\n        self.path = path\n        super().__init__()\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, Path) and str(self) == str(other)\n\n    def children(self) -> List[FilterExpression]:\n        _children: List[FilterExpression] = []\n        for segment in self.path.selectors:\n            if isinstance(segment, ListSelector):\n                _children.extend(\n                    selector.expression\n                    for selector in segment.items\n                    if isinstance(selector, FilterSelector)\n                )\n        return _children\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        # self.path has its own cache\n        return\n\n\nclass SelfPath(Path):\n    \"\"\"A JSONPath starting at the current node.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = True\n\n    def __str__(self) -> str:\n        return \"@\" + str(self.path)[1:]\n\n    def evaluate(self, context: FilterContext) -> object:\n        if isinstance(context.current, str):  # TODO: refactor\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        if not isinstance(context.current, (Sequence, Mapping)):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n\n        return NodeList(self.path.finditer(context.current))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        if isinstance(context.current, str):  # TODO: refactor\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        if not isinstance(context.current, (Sequence, Mapping)):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n\n        return NodeList(\n            [match async for match in await self.path.finditer_async(context.current)]\n        )\n\n\nclass RootPath(Path):\n    \"\"\"A JSONPath starting at the root node.\"\"\"\n\n    __slots__ = ()\n\n    FORCE_CACHE = True\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = False\n\n    def __str__(self) -> str:\n        return str(self.path)\n\n    def evaluate(self, context: FilterContext) -> object:\n        return NodeList(self.path.finditer(context.root))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return NodeList(\n            [match async for match in await self.path.finditer_async(context.root)]\n        )\n\n\nclass FilterContextPath(Path):\n    \"\"\"A JSONPath starting at the root of any extra context data.\"\"\"\n\n    __slots__ = ()\n\n    FORCE_CACHE = True\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = False\n\n    def __str__(self) -> str:\n        path_repr = str(self.path)\n        return \"_\" + path_repr[1:]\n\n    def evaluate(self, context: FilterContext) -> object:\n        return NodeList(self.path.finditer(context.extra_context))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return NodeList(\n            [\n                match\n                async for match in await self.path.finditer_async(context.extra_context)\n            ]\n        )\n\n\nclass FunctionExtension(FilterExpression):\n    \"\"\"A filter function.\"\"\"\n\n    __slots__ = (\"name\", \"args\")\n\n    def __init__(self, name: str, args: Sequence[FilterExpression]) -> None:\n        self.name = name\n        self.args = args\n        super().__init__()\n\n    def __str__(self) -> str:\n        args = [str(arg) for arg in self.args]\n        return f\"{self.name}({', '.join(args)})\"\n\n    def __eq__(self, other: object) -> bool:\n        return (\n            isinstance(other, FunctionExtension)\n            and other.name == self.name\n            and other.args == self.args\n        )\n\n    def evaluate(self, context: FilterContext) -> object:\n        try:\n            func = context.env.function_extensions[self.name]\n        except KeyError:\n            return UNDEFINED  # TODO: should probably raise an exception\n        args = [arg.evaluate(context) for arg in self.args]\n        return func(*self._unpack_node_lists(func, args))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        try:\n            func = context.env.function_extensions[self.name]\n        except KeyError:\n            return UNDEFINED  # TODO: should probably raise an exception\n        args = [await arg.evaluate_async(context) for arg in self.args]\n        return func(*self._unpack_node_lists(func, args))\n\n    def _unpack_node_lists(\n        self, func: Callable[..., Any], args: List[object]\n    ) -> List[object]:\n        if isinstance(func, FilterFunction):\n            _args: List[object] = []\n            for idx, arg in enumerate(args):\n                if func.arg_types[idx] != ExpressionType.NODES and isinstance(\n                    arg, NodeList\n                ):\n                    if len(arg) == 0:\n                        # If the query results in an empty nodelist, the\n                        # argument is the special result Nothing.\n                        _args.append(UNDEFINED)\n                    elif len(arg) == 1:\n                        # If the query results in a nodelist consisting of a\n                        # single node, the argument is the value of the node\n                        _args.append(arg[0].obj)\n                    else:\n                        # This should not be possible as a non-singular query\n                        # would have been rejected when checking function\n                        # well-typedness.\n                        _args.append(arg)\n                else:\n                    _args.append(arg)\n            return _args\n\n        # Legacy way to indicate that a filter function wants node lists as arguments.\n        if getattr(func, \"with_node_lists\", False):\n            return args\n\n        return [\n            obj.values_or_singular() if isinstance(obj, NodeList) else obj\n            for obj in args\n        ]\n\n    def children(self) -> List[FilterExpression]:\n        return list(self.args)\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == len(self.args)\n        self.args = children\n\n\nclass CurrentKey(FilterExpression):\n    \"\"\"The key/property or index associated with the current object.\"\"\"\n\n    __slots__ = ()\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.volatile = True\n\n    def __str__(self) -> str:\n        return \"#\"\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, CurrentKey)\n\n    def evaluate(self, context: FilterContext) -> object:\n        if context.current_key is None:\n            return UNDEFINED\n        return context.current_key\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return self.evaluate(context)\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:  # noqa: ARG002\n        return\n\n\nCURRENT_KEY = CurrentKey()\n\n\ndef walk(expr: FilterExpression) -> Iterable[FilterExpression]:\n    \"\"\"Walk the filter expression tree starting at _expr_.\"\"\"\n    yield expr\n    for child in expr.children():\n        yield from walk(child)\n\n\nVALUE_TYPE_EXPRESSIONS = (\n    Nil,\n    Undefined,\n    Literal,\n    ListLiteral,\n    CurrentKey,\n)\n",
    "jsonpath/selectors.py": "\"\"\"JSONPath segments and selectors, as returned from `Parser.parse`.\"\"\"\nfrom __future__ import annotations\n\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import AsyncIterable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\nfrom .exceptions import JSONPathIndexError\nfrom .exceptions import JSONPathTypeError\n\nif TYPE_CHECKING:\n    from .env import JSONPathEnvironment\n    from .filter import BooleanExpression\n    from .match import JSONPathMatch\n    from .token import Token\n\n# ruff: noqa: D102\n\n\nclass JSONPathSelector(ABC):\n    \"\"\"Base class for all JSONPath segments and selectors.\"\"\"\n\n    __slots__ = (\"env\", \"token\")\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token) -> None:\n        self.env = env\n        self.token = token\n\n    @abstractmethod\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        \"\"\"Apply the segment/selector to each node in _matches_.\n\n        Arguments:\n            matches: Nodes matched by preceding segments/selectors. This is like\n                a lazy _NodeList_, as described in RFC 9535, but each match carries\n                more than the node's value and location.\n\n        Returns:\n            The `JSONPathMatch` instances created by applying this selector to each\n            preceding node.\n        \"\"\"\n\n    @abstractmethod\n    def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `resolve`.\"\"\"\n\n\nclass PropertySelector(JSONPathSelector):\n    \"\"\"A shorthand or bracketed property selector.\"\"\"\n\n    __slots__ = (\"name\", \"shorthand\")\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        token: Token,\n        name: str,\n        shorthand: bool,\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self.name = name\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return f\"['{self.name}']\" if self.shorthand else f\"'{self.name}'\"\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, PropertySelector)\n            and self.name == __value.name\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.name, self.token))\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if not isinstance(match.obj, Mapping):\n                continue\n\n            with suppress(KeyError):\n                _match = self.env.match_class(\n                    filter_context=match.filter_context(),\n                    obj=self.env.getitem(match.obj, self.name),\n                    parent=match,\n                    parts=match.parts + (self.name,),\n                    path=match.path + f\"['{self.name}']\",\n                    root=match.root,\n                )\n                match.add_child(_match)\n                yield _match\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if not isinstance(match.obj, Mapping):\n                continue\n\n            with suppress(KeyError):\n                _match = self.env.match_class(\n                    filter_context=match.filter_context(),\n                    obj=await self.env.getitem_async(match.obj, self.name),\n                    parent=match,\n                    parts=match.parts + (self.name,),\n                    path=match.path + f\"['{self.name}']\",\n                    root=match.root,\n                )\n                match.add_child(_match)\n                yield _match\n\n\nclass IndexSelector(JSONPathSelector):\n    \"\"\"Select an element from an array by index.\n\n    Considering we don't require mapping (JSON object) keys/properties to\n    be quoted, and that we support mappings with numeric keys, we also check\n    to see if the \"index\" is a mapping key, which is non-standard.\n    \"\"\"\n\n    __slots__ = (\"index\", \"_as_key\")\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        token: Token,\n        index: int,\n    ) -> None:\n        if index < env.min_int_index or index > env.max_int_index:\n            raise JSONPathIndexError(\"index out of range\", token=token)\n\n        super().__init__(env=env, token=token)\n        self.index = index\n        self._as_key = str(self.index)\n\n    def __str__(self) -> str:\n        return str(self.index)\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, IndexSelector)\n            and self.index == __value.index\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.index, self.token))\n\n    def _normalized_index(self, obj: Sequence[object]) -> int:\n        if self.index < 0 and len(obj) >= abs(self.index):\n            return len(obj) + self.index\n        return self.index\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if isinstance(match.obj, Mapping):\n                # Try the string representation of the index as a key.\n                with suppress(KeyError):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=self.env.getitem(match.obj, self._as_key),\n                        parent=match,\n                        parts=match.parts + (self._as_key,),\n                        path=f\"{match.path}['{self.index}']\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence) and not isinstance(match.obj, str):\n                norm_index = self._normalized_index(match.obj)\n                with suppress(IndexError):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=self.env.getitem(match.obj, self.index),\n                        parent=match,\n                        parts=match.parts + (norm_index,),\n                        path=match.path + f\"[{norm_index}]\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                # Try the string representation of the index as a key.\n                with suppress(KeyError):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=await self.env.getitem_async(match.obj, self._as_key),\n                        parent=match,\n                        parts=match.parts + (self._as_key,),\n                        path=f\"{match.path}['{self.index}']\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence) and not isinstance(match.obj, str):\n                norm_index = self._normalized_index(match.obj)\n                with suppress(IndexError):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=await self.env.getitem_async(match.obj, self.index),\n                        parent=match,\n                        parts=match.parts + (norm_index,),\n                        path=match.path + f\"[{norm_index}]\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n\n\nclass KeysSelector(JSONPathSelector):\n    \"\"\"Select mapping/object keys/properties.\n\n    NOTE: This is a non-standard selector.\n    \"\"\"\n\n    __slots__ = (\"shorthand\",)\n\n    def __init__(\n        self, *, env: JSONPathEnvironment, token: Token, shorthand: bool\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return (\n            f\"[{self.env.keys_selector_token}]\"\n            if self.shorthand\n            else self.env.keys_selector_token\n        )\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, KeysSelector) and self.token == __value.token\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def _keys(self, match: JSONPathMatch) -> Iterable[JSONPathMatch]:\n        if isinstance(match.obj, Mapping):\n            for i, key in enumerate(match.obj.keys()):\n                _match = self.env.match_class(\n                    filter_context=match.filter_context(),\n                    obj=key,\n                    parent=match,\n                    parts=match.parts + (f\"{self.env.keys_selector_token}{key}\",),\n                    path=f\"{match.path}[{self.env.keys_selector_token}][{i}]\",\n                    root=match.root,\n                )\n                match.add_child(_match)\n                yield _match\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            yield from self._keys(match)\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            for _match in self._keys(match):\n                yield _match\n\n\nclass SliceSelector(JSONPathSelector):\n    \"\"\"Sequence slicing selector.\"\"\"\n\n    __slots__ = (\"slice\",)\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        token: Token,\n        start: Optional[int] = None,\n        stop: Optional[int] = None,\n        step: Optional[int] = None,\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self._check_range(start, stop, step)\n        self.slice = slice(start, stop, step)\n\n    def __str__(self) -> str:\n        stop = self.slice.stop if self.slice.stop is not None else \"\"\n        start = self.slice.start if self.slice.start is not None else \"\"\n        step = self.slice.step if self.slice.step is not None else \"1\"\n        return f\"{start}:{stop}:{step}\"\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, SliceSelector)\n            and self.slice == __value.slice\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash((str(self), self.token))\n\n    def _check_range(self, *indices: Optional[int]) -> None:\n        for i in indices:\n            if i is not None and (\n                i < self.env.min_int_index or i > self.env.max_int_index\n            ):\n                raise JSONPathIndexError(\"index out of range\", token=self.token)\n\n    def _normalized_index(self, obj: Sequence[object], index: int) -> int:\n        if index < 0 and len(obj) >= abs(index):\n            return len(obj) + index\n        return index\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if not isinstance(match.obj, Sequence) or self.slice.step == 0:\n                continue\n\n            idx = self.slice.start or 0\n            step = self.slice.step or 1\n            for obj in self.env.getitem(match.obj, self.slice):\n                norm_index = self._normalized_index(match.obj, idx)\n                _match = self.env.match_class(\n                    filter_context=match.filter_context(),\n                    obj=obj,\n                    parent=match,\n                    parts=match.parts + (norm_index,),\n                    path=f\"{match.path}[{norm_index}]\",\n                    root=match.root,\n                )\n                match.add_child(_match)\n                yield _match\n                idx += step\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if not isinstance(match.obj, Sequence) or self.slice.step == 0:\n                continue\n\n            idx = self.slice.start or 0\n            step = self.slice.step or 1\n            for obj in await self.env.getitem_async(match.obj, self.slice):\n                norm_index = self._normalized_index(match.obj, idx)\n                _match = self.env.match_class(\n                    filter_context=match.filter_context(),\n                    obj=obj,\n                    parent=match,\n                    parts=match.parts + (norm_index,),\n                    path=f\"{match.path}[{norm_index}]\",\n                    root=match.root,\n                )\n                match.add_child(_match)\n                yield _match\n                idx += step\n\n\nclass WildSelector(JSONPathSelector):\n    \"\"\"Select all items from a sequence/array or values from a mapping/object.\"\"\"\n\n    __slots__ = (\"shorthand\",)\n\n    def __init__(\n        self, *, env: JSONPathEnvironment, token: Token, shorthand: bool\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return \"[*]\" if self.shorthand else \"*\"\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, WildSelector) and self.token == __value.token\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if isinstance(match.obj, str):\n                continue\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (key,),\n                        path=match.path + f\"['{key}']\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence):\n                for i, val in enumerate(match.obj):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (i,),\n                        path=f\"{match.path}[{i}]\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (key,),\n                        path=match.path + f\"['{key}']\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence):\n                for i, val in enumerate(match.obj):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (i,),\n                        path=f\"{match.path}[{i}]\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n\n\nclass RecursiveDescentSelector(JSONPathSelector):\n    \"\"\"A JSONPath selector that visits all nodes recursively.\n\n    NOTE: Strictly this is a \"segment\", not a \"selector\".\n    \"\"\"\n\n    def __str__(self) -> str:\n        return \"..\"\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, RecursiveDescentSelector)\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def _expand(self, match: JSONPathMatch) -> Iterable[JSONPathMatch]:\n        if isinstance(match.obj, Mapping):\n            for key, val in match.obj.items():\n                if isinstance(val, str):\n                    pass\n                elif isinstance(val, (Mapping, Sequence)):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (key,),\n                        path=match.path + f\"['{key}']\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n                    yield from self._expand(_match)\n        elif isinstance(match.obj, Sequence) and not isinstance(match.obj, str):\n            for i, val in enumerate(match.obj):\n                if isinstance(val, str):\n                    pass\n                elif isinstance(val, (Mapping, Sequence)):\n                    _match = self.env.match_class(\n                        filter_context=match.filter_context(),\n                        obj=val,\n                        parent=match,\n                        parts=match.parts + (i,),\n                        path=f\"{match.path}[{i}]\",\n                        root=match.root,\n                    )\n                    match.add_child(_match)\n                    yield _match\n                    yield from self._expand(_match)\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            yield match\n            yield from self._expand(match)\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            yield match\n            for _match in self._expand(match):\n                yield _match\n\n\nT = TypeVar(\"T\")\n\n\nasync def _alist(it: List[T]) -> AsyncIterable[T]:\n    for item in it:\n        yield item\n\n\nclass ListSelector(JSONPathSelector):\n    \"\"\"A bracketed list of selectors, the results of which are concatenated together.\n\n    NOTE: Strictly this is a \"segment\", not a \"selector\".\n    \"\"\"\n\n    __slots__ = (\"items\",)\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        token: Token,\n        items: List[\n            Union[\n                SliceSelector,\n                KeysSelector,\n                IndexSelector,\n                PropertySelector,\n                WildSelector,\n                Filter,\n            ]\n        ],\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self.items = tuple(items)\n\n    def __str__(self) -> str:\n        return f\"[{', '.join(str(itm) for itm in self.items)}]\"\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, ListSelector)\n            and self.items == __value.items\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.items, self.token))\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match_ in matches:\n            for item in self.items:\n                yield from item.resolve([match_])\n\n    async def resolve_async(\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        async for match_ in matches:\n            for item in self.items:\n                async for m in item.resolve_async(_alist([match_])):\n                    yield m\n\n\nclass Filter(JSONPathSelector):\n    \"\"\"Filter sequence/array items or mapping/object values with a filter expression.\"\"\"\n\n    __slots__ = (\"expression\", \"cacheable_nodes\")\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        token: Token,\n        expression: BooleanExpression,\n    ) -> None:\n        super().__init__(env=env, token=token)\n        self.expression = expression\n        # Compile-time check for cacheable nodes.\n        self.cacheable_nodes = self.expression.cacheable_nodes()\n\n    def __str__(self) -> str:\n        return f\"?{self.expression}\"\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, Filter)\n            and self.expression == __value.expression\n            and self.token == __value.token\n        )\n\n    def __hash__(self) -> int:\n        return hash((str(self.expression), self.token))\n\n    def resolve(  # noqa: PLR0912\n        self, matches: Iterable[JSONPathMatch]\n    ) -> Iterable[JSONPathMatch]:\n        if self.cacheable_nodes and self.env.filter_caching:\n            expr = self.expression.cache_tree()\n        else:\n            expr = self.expression\n\n        for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    context = FilterContext(\n                        env=self.env,\n                        current=val,\n                        root=match.root,\n                        extra_context=match.filter_context(),\n                        current_key=key,\n                    )\n                    try:\n                        if expr.evaluate(context):\n                            _match = self.env.match_class(\n                                filter_context=match.filter_context(),\n                                obj=val,\n                                parent=match,\n                                parts=match.parts + (key,),\n                                path=match.path + f\"['{key}']\",\n                                root=match.root,\n                            )\n                            match.add_child(_match)\n                            yield _match\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n\n            elif isinstance(match.obj, Sequence) and not isinstance(match.obj, str):\n                for i, obj in enumerate(match.obj):\n                    context = FilterContext(\n                        env=self.env,\n                        current=obj,\n                        root=match.root,\n                        extra_context=match.filter_context(),\n                        current_key=i,\n                    )\n                    try:\n                        if expr.evaluate(context):\n                            _match = self.env.match_class(\n                                filter_context=match.filter_context(),\n                                obj=obj,\n                                parent=match,\n                                parts=match.parts + (i,),\n                                path=f\"{match.path}[{i}]\",\n                                root=match.root,\n                            )\n                            match.add_child(_match)\n                            yield _match\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n\n    async def resolve_async(  # noqa: PLR0912\n        self, matches: AsyncIterable[JSONPathMatch]\n    ) -> AsyncIterable[JSONPathMatch]:\n        if self.cacheable_nodes and self.env.filter_caching:\n            expr = self.expression.cache_tree()\n        else:\n            expr = self.expression\n\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    context = FilterContext(\n                        env=self.env,\n                        current=val,\n                        root=match.root,\n                        extra_context=match.filter_context(),\n                        current_key=key,\n                    )\n\n                    try:\n                        result = await expr.evaluate_async(context)\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n\n                    if result:\n                        _match = self.env.match_class(\n                            filter_context=match.filter_context(),\n                            obj=val,\n                            parent=match,\n                            parts=match.parts + (key,),\n                            path=match.path + f\"['{key}']\",\n                            root=match.root,\n                        )\n                        match.add_child(_match)\n                        yield _match\n\n            elif isinstance(match.obj, Sequence) and not isinstance(match.obj, str):\n                for i, obj in enumerate(match.obj):\n                    context = FilterContext(\n                        env=self.env,\n                        current=obj,\n                        root=match.root,\n                        extra_context=match.filter_context(),\n                        current_key=i,\n                    )\n\n                    try:\n                        result = await expr.evaluate_async(context)\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n                    if result:\n                        _match = self.env.match_class(\n                            filter_context=match.filter_context(),\n                            obj=obj,\n                            parent=match,\n                            parts=match.parts + (i,),\n                            path=f\"{match.path}[{i}]\",\n                            root=match.root,\n                        )\n                        match.add_child(_match)\n                        yield _match\n\n\nclass FilterContext:\n    \"\"\"Contextual information and data for evaluating a filter expression.\"\"\"\n\n    __slots__ = (\n        \"current_key\",\n        \"current\",\n        \"env\",\n        \"extra_context\",\n        \"root\",\n    )\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        current: object,\n        root: Union[Sequence[Any], Mapping[str, Any]],\n        extra_context: Optional[Mapping[str, Any]] = None,\n        current_key: Union[str, int, None] = None,\n    ) -> None:\n        self.env = env\n        self.current = current\n        self.root = root\n        self.extra_context = extra_context or {}\n        self.current_key = current_key\n\n    def __str__(self) -> str:\n        return (\n            f\"FilterContext(current={self.current}, \"\n            f\"extra_context={self.extra_context!r})\"\n        )\n",
    "jsonpath/match.py": "\"\"\"The JSONPath match object, as returned from `JSONPath.finditer()`.\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nfrom .pointer import JSONPointer\n\nFilterContextVars = Mapping[str, Any]\nPathPart = Union[int, str]\n\n\nclass JSONPathMatch:\n    \"\"\"A matched object with a concrete path.\n\n    Attributes:\n        children: Matched child nodes. This will only be populated after\n            all children have been visited, usually by using `findall()`\n            or `list(finditer())`.\n        obj: The matched object.\n        parent: The immediate parent to this match in the JSON document.\n            If this is the root node, _parent_ will be `None`.\n        path: The canonical string representation of the path to this match.\n        parts: The keys, indices and/or slices that make up the path to this\n            match.\n        root: A reference to the root node in the JSON document.\n    \"\"\"\n\n    __slots__ = (\n        \"_filter_context\",\n        \"children\",\n        \"obj\",\n        \"parent\",\n        \"parts\",\n        \"path\",\n        \"root\",\n    )\n\n    pointer_class = JSONPointer\n\n    def __init__(\n        self,\n        *,\n        filter_context: FilterContextVars,\n        obj: object,\n        parent: Optional[JSONPathMatch],\n        path: str,\n        parts: Tuple[PathPart, ...],\n        root: Union[Sequence[Any], Mapping[str, Any]],\n    ) -> None:\n        self._filter_context = filter_context\n        self.children: List[JSONPathMatch] = []\n        self.obj: object = obj\n        self.parent: Optional[JSONPathMatch] = parent\n        self.parts: Tuple[PathPart, ...] = parts\n        self.path: str = path\n        self.root: Union[Sequence[Any], Mapping[str, Any]] = root\n\n    def __str__(self) -> str:\n        return f\"{_truncate(str(self.obj), 5)!r} @ {_truncate(self.path, 5)}\"\n\n    def add_child(self, *children: JSONPathMatch) -> None:\n        \"\"\"Append one or more children to this match.\"\"\"\n        self.children.extend(children)\n\n    def filter_context(self) -> FilterContextVars:\n        \"\"\"Return filter context data for this match.\"\"\"\n        return self._filter_context\n\n    def pointer(self) -> JSONPointer:\n        \"\"\"Return a `JSONPointer` pointing to this match's path.\"\"\"\n        return JSONPointer.from_match(self)\n\n    @property\n    def value(self) -> object:\n        \"\"\"Return the value associated with this match/node.\"\"\"\n        return self.obj\n\n\ndef _truncate(val: str, num: int, end: str = \"...\") -> str:\n    # Replaces consecutive whitespace with a single newline.\n    # Treats quoted whitespace the same as unquoted whitespace.\n    words = val.split()\n    if len(words) < num:\n        return \" \".join(words)\n    return \" \".join(words[:num]) + end\n\n\nclass NodeList(List[JSONPathMatch]):\n    \"\"\"List of JSONPathMatch objects, analogous to the spec's nodelist.\"\"\"\n\n    def values(self) -> List[object]:\n        \"\"\"Return the values from this node list.\"\"\"\n        return [match.obj for match in self]\n\n    def values_or_singular(self) -> object:\n        \"\"\"Return the values from this node list.\"\"\"\n        if len(self) == 1:\n            return self[0].obj\n        return [match.obj for match in self]\n\n    def empty(self) -> bool:\n        \"\"\"Return `True` if this node list is empty.\"\"\"\n        return not bool(self)\n\n    def __str__(self) -> str:\n        return f\"NodeList{super().__str__()}\"\n",
    "jsonpath/pointer.py": "\"\"\"JSON Pointer. See https://datatracker.ietf.org/doc/html/rfc6901.\"\"\"\n\nfrom __future__ import annotations\n\nimport codecs\nimport re\nfrom functools import reduce\nfrom operator import getitem\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nfrom urllib.parse import unquote\n\nfrom jsonpath._data import load_data\nfrom jsonpath.exceptions import JSONPointerError\nfrom jsonpath.exceptions import JSONPointerIndexError\nfrom jsonpath.exceptions import JSONPointerKeyError\nfrom jsonpath.exceptions import JSONPointerResolutionError\nfrom jsonpath.exceptions import JSONPointerTypeError\nfrom jsonpath.exceptions import RelativeJSONPointerIndexError\nfrom jsonpath.exceptions import RelativeJSONPointerSyntaxError\n\nif TYPE_CHECKING:\n    from io import IOBase\n\n    from .match import JSONPathMatch\n\n\nclass _Undefined:\n    def __str__(self) -> str:\n        return \"<jsonpath.pointer.UNDEFINED>\"\n\n\nUNDEFINED = _Undefined()\n\n\nclass JSONPointer:\n    \"\"\"Identify a single, specific value in JSON-like data, as per RFC 6901.\n\n    Args:\n        pointer: A string representation of a JSON Pointer.\n        parts: The keys, indices and/or slices that make up a JSON Pointer. If\n            given, it is assumed that the parts have already been parsed by the\n            JSONPath parser. `unicode_escape` and `uri_decode` are ignored if\n            _parts_ is given.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n\n    Attributes:\n        keys_selector (str): The non-standard token used to target a mapping\n            key or name.\n        max_int_index (int): The maximum integer allowed when resolving array\n            items by index. Defaults to `(2**53) - 1`.\n        min_int_index (int): The minimum integer allowed when resolving array\n            items by index. Defaults to `-(2**53) + 1`.\n    \"\"\"\n\n    __slots__ = (\"_s\", \"parts\")\n\n    keys_selector = \"~\"\n    max_int_index = (2**53) - 1\n    min_int_index = -(2**53) + 1\n\n    def __init__(\n        self,\n        pointer: str,\n        *,\n        parts: Tuple[Union[int, str], ...] = (),\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> None:\n        self.parts = parts or self._parse(\n            pointer,\n            unicode_escape=unicode_escape,\n            uri_decode=uri_decode,\n        )\n        self._s = self._encode(self.parts)\n\n    def __str__(self) -> str:\n        return self._s\n\n    def _parse(\n        self,\n        s: str,\n        *,\n        unicode_escape: bool,\n        uri_decode: bool,\n    ) -> Tuple[Union[int, str], ...]:\n        if uri_decode:\n            s = unquote(s)\n        if unicode_escape:\n            s = self._unicode_escape(s)\n\n        s = s.lstrip()\n        if s and not s.startswith(\"/\"):\n            raise JSONPointerError(\n                \"pointer must start with a slash or be the empty string\"\n            )\n\n        return tuple(\n            self._index(p.replace(\"~1\", \"/\").replace(\"~0\", \"~\")) for p in s.split(\"/\")\n        )[1:]\n\n    def _index(self, s: str) -> Union[str, int]:\n        # Reject non-zero ints that start with a zero.\n        if len(s) > 1 and s.startswith(\"0\"):\n            return s\n\n        try:\n            index = int(s)\n            if index < self.min_int_index or index > self.max_int_index:\n                raise JSONPointerIndexError(\"index out of range\")\n            return index\n        except ValueError:\n            return s\n\n    def _getitem(self, obj: Any, key: Any) -> Any:  # noqa: PLR0912\n        try:\n            return getitem(obj, key)\n        except KeyError as err:\n            # Try a string repr of the index-like item as a mapping key.\n            if isinstance(key, int):\n                try:\n                    return getitem(obj, str(key))\n                except KeyError:\n                    raise JSONPointerKeyError(key) from err\n            # Handle non-standard keys/property selector/pointer.\n            if (\n                isinstance(key, str)\n                and isinstance(obj, Mapping)\n                and key.startswith((self.keys_selector, \"#\"))\n                and key[1:] in obj\n            ):\n                return key[1:]\n            # Handle non-standard index/property pointer (`#`)\n            raise JSONPointerKeyError(key) from err\n        except TypeError as err:\n            if isinstance(obj, Sequence) and not isinstance(obj, str):\n                if key == \"-\":\n                    # \"-\" is a valid index when appending to a JSON array\n                    # with JSON Patch, but not when resolving a JSON Pointer.\n                    raise JSONPointerIndexError(\"index out of range\") from None\n                # Handle non-standard index pointer.\n                if isinstance(key, str) and key.startswith(\"#\"):\n                    _index = int(key[1:])\n                    if _index >= len(obj):\n                        raise JSONPointerIndexError(\n                            f\"index out of range: {_index}\"\n                        ) from err\n                    return _index\n                # Try int index. Reject non-zero ints that start with a zero.\n                if isinstance(key, str):\n                    index = self._index(key)\n                    if isinstance(index, int):\n                        try:\n                            return getitem(obj, int(key))\n                        except IndexError as index_err:\n                            raise JSONPointerIndexError(\n                                f\"index out of range: {key}\"\n                            ) from index_err\n            raise JSONPointerTypeError(f\"{key}: {err}\") from err\n        except IndexError as err:\n            raise JSONPointerIndexError(f\"index out of range: {key}\") from err\n\n    def resolve(\n        self,\n        data: Union[str, IOBase, Sequence[object], Mapping[str, object]],\n        *,\n        default: object = UNDEFINED,\n    ) -> object:\n        \"\"\"Resolve this pointer against _data_.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n            default: A default value to return if the pointer can't be resolved\n                against the given data.\n\n        Returns:\n            The object in _data_ pointed to by this pointer.\n\n        Raises:\n            JSONPointerIndexError: When attempting to access a sequence by\n                an out of range index, unless a default is given.\n            JSONPointerKeyError: If any mapping object along the path does not\n                contain a specified key, unless a default is given.\n            JSONPointerTypeError: When attempting to resolve a non-index string\n                path part against a sequence, unless a default is given.\n        \"\"\"\n        data = load_data(data)\n        try:\n            return reduce(self._getitem, self.parts, data)\n        except JSONPointerResolutionError:\n            if default is not UNDEFINED:\n                return default\n            raise\n\n    def resolve_parent(\n        self, data: Union[str, IOBase, Sequence[object], Mapping[str, object]]\n    ) -> Tuple[Union[Sequence[object], Mapping[str, object], None], object]:\n        \"\"\"Resolve this pointer against _data_, return the object and its parent.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n\n        Returns:\n            A `(parent, object)` tuple, where parent will be `None` if this\n                pointer points to the root node in the document. If the parent\n                exists but the last object does not, `(parent, UNDEFINED)` will\n                be returned.\n\n        Raises:\n            JSONPointerIndexError: When attempting to access a sequence by\n                an out of range index, unless using the special `-` index.\n            JSONPointerKeyError: If any mapping object along the path does not\n                contain a specified key, unless it is the last part of the\n                pointer.\n            JSONPointerTypeError: When attempting to resolve a non-index string\n                path part against a sequence.\n        \"\"\"\n        if not self.parts:\n            return (None, self.resolve(data))\n\n        _data = load_data(data)\n        parent = reduce(self._getitem, self.parts[:-1], _data)\n\n        try:\n            return (parent, self._getitem(parent, self.parts[-1]))\n        except (JSONPointerIndexError, JSONPointerKeyError):\n            return (parent, UNDEFINED)\n\n    @staticmethod\n    def _encode(parts: Iterable[Union[int, str]]) -> str:\n        if parts:\n            return \"/\" + \"/\".join(\n                str(p).replace(\"~\", \"~0\").replace(\"/\", \"~1\") for p in parts\n            )\n        return \"\"\n\n    def _unicode_escape(self, s: str) -> str:\n        # UTF-16 escape sequences - possibly surrogate pairs - inside UTF-8\n        # encoded strings. As per https://datatracker.ietf.org/doc/html/rfc4627\n        # section 2.5.\n        return (\n            codecs.decode(s.replace(\"\\\\/\", \"/\"), \"unicode-escape\")\n            .encode(\"utf-16\", \"surrogatepass\")\n            .decode(\"utf-16\")\n        )\n\n    @classmethod\n    def from_match(\n        cls,\n        match: JSONPathMatch,\n    ) -> JSONPointer:\n        \"\"\"Return a JSON Pointer for the path from a JSONPathMatch instance.\"\"\"\n        # An RFC 6901 string representation of match.parts.\n        if match.parts:\n            pointer = cls._encode(match.parts)\n        else:\n            # This should not happen, unless the JSONPathMatch has been tampered with.\n            pointer = \"\"\n\n        return cls(\n            pointer,\n            parts=match.parts,\n            unicode_escape=False,\n            uri_decode=False,\n        )\n\n    @classmethod\n    def from_parts(\n        cls,\n        parts: Iterable[Union[int, str]],\n        *,\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> JSONPointer:\n        \"\"\"Build a JSON Pointer from _parts_.\n\n        Args:\n            parts: The keys, indices and/or slices that make up a JSONPointer.\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n                before parsing the pointer.\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\n                before being parsed.\n\n        Returns:\n            A new `JSONPointer` built from _parts_.\n        \"\"\"\n        _parts = (str(p) for p in parts)\n        if uri_decode:\n            _parts = (unquote(p) for p in _parts)\n        if unicode_escape:\n            _parts = (\n                codecs.decode(p.replace(\"\\\\/\", \"/\"), \"unicode-escape\")\n                .encode(\"utf-16\", \"surrogatepass\")\n                .decode(\"utf-16\")\n                for p in _parts\n            )\n\n        __parts = tuple(_parts)\n\n        if __parts:\n            pointer = cls._encode(__parts)\n        else:\n            pointer = \"\"\n\n        return cls(\n            pointer,\n            parts=__parts,\n            unicode_escape=False,\n            uri_decode=False,\n        )\n\n    def is_relative_to(self, other: JSONPointer) -> bool:\n        \"\"\"Return _True_ if this pointer points to a child of _other_.\"\"\"\n        return (\n            len(other.parts) < len(self.parts)\n            and self.parts[: len(other.parts)] == other.parts\n        )\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, JSONPointer) and self.parts == other.parts\n\n    def __hash__(self) -> int:\n        return hash(self.parts)\n\n    def __repr__(self) -> str:\n        return f\"JSONPointer({self._s!r})\"\n\n    def exists(\n        self, data: Union[str, IOBase, Sequence[object], Mapping[str, object]]\n    ) -> bool:\n        \"\"\"Return _True_ if this pointer can be resolved against _data_.\n\n        Note that `JSONPointer.resolve()` can return legitimate falsy values\n        that form part of the target JSON document. This method will return\n        `True` if a falsy value is found.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n\n        Returns:\n            _True_ if this pointer can be resolved against _data_, or _False_\n                otherwise.\n\n        **_New in version 0.9.0_**\n        \"\"\"\n        try:\n            self.resolve(data)\n        except JSONPointerResolutionError:\n            return False\n        return True\n\n    def parent(self) -> JSONPointer:\n        \"\"\"Return this pointer's parent, as a new `JSONPointer`.\n\n        If this pointer points to the document root, _self_ is returned.\n\n        **_New in version 0.9.0_**\n        \"\"\"\n        if not self.parts:\n            return self\n        parent_parts = self.parts[:-1]\n        return JSONPointer(\n            self._encode(parent_parts),\n            parts=parent_parts,\n            unicode_escape=False,\n            uri_decode=False,\n        )\n\n    def __truediv__(self, other: object) -> JSONPointer:\n        \"\"\"Join this pointer with _other_.\n\n        _other_ is expected to be a JSON Pointer string, possibly without a\n        leading slash. If _other_ does have a leading slash, the previous\n        pointer is ignored and a new JSONPath is returned from _other_.\n\n        _other_ should not be a \"Relative JSON Pointer\".\n        \"\"\"\n        if not isinstance(other, str):\n            raise TypeError(\n                \"unsupported operand type for /: \"\n                f\"{self.__class__.__name__!r} and {other.__class__.__name__!r}\"\n            )\n\n        other = self._unicode_escape(other.lstrip())\n        if other.startswith(\"/\"):\n            return JSONPointer(other, unicode_escape=False, uri_decode=False)\n\n        parts = self.parts + tuple(\n            self._index(p.replace(\"~1\", \"/\").replace(\"~0\", \"~\"))\n            for p in other.split(\"/\")\n        )\n\n        return JSONPointer(\n            self._encode(parts), parts=parts, unicode_escape=False, uri_decode=False\n        )\n\n    def join(self, *parts: str) -> JSONPointer:\n        \"\"\"Join this pointer with _parts_.\n\n        Each part is expected to be a JSON Pointer string, possibly without a\n        leading slash. If a part does have a leading slash, the previous\n        pointer is ignored and a new `JSONPointer` is created, and processing of\n        remaining parts continues.\n        \"\"\"\n        pointer = self\n        for part in parts:\n            pointer = pointer / part\n        return pointer\n\n    def to(\n        self,\n        rel: Union[RelativeJSONPointer, str],\n        *,\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> JSONPointer:\n        \"\"\"Return a new pointer relative to this pointer.\n\n        Args:\n            rel: A `RelativeJSONPointer` or a string following \"Relative JSON\n                Pointer\" syntax.\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n                before parsing the pointer.\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\n                before being parsed.\n\n        See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html\n        \"\"\"\n        relative_pointer = (\n            RelativeJSONPointer(\n                rel, unicode_escape=unicode_escape, uri_decode=uri_decode\n            )\n            if isinstance(rel, str)\n            else rel\n        )\n\n        return relative_pointer.to(self)\n\n\nRE_RELATIVE_POINTER = re.compile(\n    r\"(?P<ORIGIN>\\d+)(?P<INDEX_G>(?P<SIGN>[+\\-])(?P<INDEX>\\d))?(?P<POINTER>.*)\",\n    re.DOTALL,\n)\n\n\nclass RelativeJSONPointer:\n    \"\"\"A Relative JSON Pointer.\n\n    See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html\n\n    Args:\n        rel: A string following Relative JSON Pointer syntax.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n    \"\"\"\n\n    __slots__ = (\"origin\", \"index\", \"pointer\")\n\n    def __init__(\n        self,\n        rel: str,\n        *,\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> None:\n        self.origin, self.index, self.pointer = self._parse(\n            rel, unicode_escape=unicode_escape, uri_decode=uri_decode\n        )\n\n    def __str__(self) -> str:\n        sign = \"+\" if self.index > 0 else \"\"\n        index = \"\" if self.index == 0 else f\"{sign}{self.index}\"\n        return f\"{self.origin}{index}{self.pointer}\"\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, RelativeJSONPointer) and str(self) == str(__value)\n\n    def _parse(\n        self,\n        rel: str,\n        *,\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> Tuple[int, int, Union[JSONPointer, str]]:\n        rel = rel.lstrip()\n        match = RE_RELATIVE_POINTER.match(rel)\n        if not match:\n            raise RelativeJSONPointerSyntaxError(\"\", rel)\n\n        # Steps to move\n        origin = self._zero_or_positive(match.group(\"ORIGIN\"), rel)\n\n        # Optional index manipulation\n        if match.group(\"INDEX_G\"):\n            index = self._zero_or_positive(match.group(\"INDEX\"), rel)\n            if index == 0:\n                raise RelativeJSONPointerSyntaxError(\"index offset can't be zero\", rel)\n            if match.group(\"SIGN\") == \"-\":\n                index = -index\n        else:\n            index = 0\n\n        # Pointer or '#'. Empty string is OK.\n        _pointer = match.group(\"POINTER\").strip()\n        pointer = (\n            JSONPointer(\n                _pointer,\n                unicode_escape=unicode_escape,\n                uri_decode=uri_decode,\n            )\n            if _pointer != \"#\"\n            else _pointer\n        )\n\n        return (origin, index, pointer)\n\n    def _zero_or_positive(self, s: str, rel: str) -> int:\n        # TODO: accept start and stop index for better error messages\n        if s.startswith(\"0\") and len(s) > 1:\n            raise RelativeJSONPointerSyntaxError(\"unexpected leading zero\", rel)\n        try:\n            return int(s)\n        except ValueError as err:\n            raise RelativeJSONPointerSyntaxError(\n                \"expected positive int or zero\", rel\n            ) from err\n\n    def _int_like(self, obj: Any) -> bool:\n        if isinstance(obj, int):\n            return True\n        try:\n            int(obj)\n        except ValueError:\n            return False\n        return True\n\n    def to(\n        self,\n        pointer: Union[JSONPointer, str],\n        *,\n        unicode_escape: bool = True,\n        uri_decode: bool = False,\n    ) -> JSONPointer:\n        \"\"\"Return a new JSONPointer relative to _pointer_.\n\n        Args:\n            pointer: A `JSONPointer` instance or a string following JSON\n                Pointer syntax.\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n                before parsing the pointer.\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\n                before being parsed.\n        \"\"\"\n        _pointer = (\n            JSONPointer(pointer, unicode_escape=unicode_escape, uri_decode=uri_decode)\n            if isinstance(pointer, str)\n            else pointer\n        )\n\n        # Move to origin\n        if self.origin > len(_pointer.parts):\n            raise RelativeJSONPointerIndexError(\n                f\"origin ({self.origin}) exceeds root ({len(_pointer.parts)})\"\n            )\n\n        if self.origin < 1:\n            parts = list(_pointer.parts)\n        else:\n            parts = list(_pointer.parts[: -self.origin])\n\n        # Array index offset\n        if self.index and parts and self._int_like(parts[-1]):\n            new_index = int(parts[-1]) + self.index\n            if new_index < 0:\n                raise RelativeJSONPointerIndexError(\n                    f\"index offset out of range {new_index}\"\n                )\n            parts[-1] = int(parts[-1]) + self.index\n\n        # Pointer or index/property\n        if isinstance(self.pointer, JSONPointer):\n            parts.extend(self.pointer.parts)\n        else:\n            assert self.pointer == \"#\"\n            parts[-1] = f\"#{parts[-1]}\"\n\n        return JSONPointer.from_parts(\n            parts, unicode_escape=unicode_escape, uri_decode=uri_decode\n        )\n\n\ndef resolve(\n    pointer: Union[str, Iterable[Union[str, int]]],\n    data: Union[str, IOBase, Sequence[object], Mapping[str, object]],\n    *,\n    default: object = UNDEFINED,\n    unicode_escape: bool = True,\n    uri_decode: bool = False,\n) -> object:\n    \"\"\"Resolve JSON Pointer _pointer_ against _data_.\n\n    Args:\n        pointer: A string representation of a JSON Pointer or an iterable of\n            JSON Pointer parts.\n        data: The target JSON \"document\" or equivalent Python objects.\n        default: A default value to return if the pointer can't be resolved.\n            against the given data.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n\n    Returns:\n        The object in _data_ pointed to by this pointer.\n\n    Raises:\n        JSONPointerIndexError: When attempting to access a sequence by\n            an out of range index, unless a default is given.\n        JSONPointerKeyError: If any mapping object along the path does not contain\n            a specified key, unless a default is given.\n        JSONPointerTypeError: When attempting to resolve a non-index string path\n            part against a sequence, unless a default is given.\n    \"\"\"\n    if isinstance(pointer, str):\n        try:\n            return JSONPointer(\n                pointer, unicode_escape=unicode_escape, uri_decode=uri_decode\n            ).resolve(data)\n        except JSONPointerResolutionError:\n            if default is not UNDEFINED:\n                return default\n            raise\n\n    try:\n        return JSONPointer.from_parts(\n            pointer, unicode_escape=unicode_escape, uri_decode=uri_decode\n        ).resolve(data)\n    except JSONPointerResolutionError:\n        if default is not UNDEFINED:\n            return default\n        raise\n",
    "jsonpath/path.py": "# noqa: D100\nfrom __future__ import annotations\n\nimport itertools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import AsyncIterable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import TypeVar\nfrom typing import Union\n\nfrom jsonpath._data import load_data\nfrom jsonpath.fluent_api import Query\nfrom jsonpath.match import FilterContextVars\nfrom jsonpath.match import JSONPathMatch\nfrom jsonpath.selectors import IndexSelector\nfrom jsonpath.selectors import ListSelector\nfrom jsonpath.selectors import PropertySelector\n\nif TYPE_CHECKING:\n    from io import IOBase\n\n    from .env import JSONPathEnvironment\n    from .selectors import JSONPathSelector\n\n\nclass JSONPath:\n    \"\"\"A compiled JSONPath ready to be applied to a JSON string or Python object.\n\n    Arguments:\n        env: The `JSONPathEnvironment` this path is bound to.\n        selectors: An iterable of `JSONPathSelector` objects, as generated by\n            a `Parser`.\n        fake_root: Indicates if target JSON values should be wrapped in a single-\n            element array, so as to make the target root value selectable.\n\n\n    Attributes:\n        env: The `JSONPathEnvironment` this path is bound to.\n        selectors: The `JSONPathSelector` instances that make up this path.\n    \"\"\"\n\n    __slots__ = (\"env\", \"fake_root\", \"selectors\")\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        selectors: Iterable[JSONPathSelector],\n        fake_root: bool = False,\n    ) -> None:\n        self.env = env\n        self.selectors = tuple(selectors)\n        self.fake_root = fake_root\n\n    def __str__(self) -> str:\n        return self.env.root_token + \"\".join(\n            str(selector) for selector in self.selectors\n        )\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, JSONPath) and self.selectors == __value.selectors\n\n    def __hash__(self) -> int:\n        return hash(self.selectors)\n\n    def findall(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> List[object]:\n        \"\"\"Find all objects in `data` matching the given JSONPath `path`.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A list of matched objects. If there are no matches, the list will\n            be empty.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return [\n            match.obj for match in self.finditer(data, filter_context=filter_context)\n        ]\n\n    def finditer(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Iterable[JSONPathMatch]:\n        \"\"\"Generate `JSONPathMatch` objects for each match.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            An iterator yielding `JSONPathMatch` objects for each match.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        _data = load_data(data)\n        matches: Iterable[JSONPathMatch] = [\n            JSONPathMatch(\n                filter_context=filter_context or {},\n                obj=[_data] if self.fake_root else _data,\n                parent=None,\n                path=self.env.root_token,\n                parts=(),\n                root=_data,\n            )\n        ]\n\n        for selector in self.selectors:\n            matches = selector.resolve(matches)\n\n        return matches\n\n    async def findall_async(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> List[object]:\n        \"\"\"An async version of `findall()`.\"\"\"\n        return [\n            match.obj\n            async for match in await self.finditer_async(\n                data, filter_context=filter_context\n            )\n        ]\n\n    async def finditer_async(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `finditer()`.\"\"\"\n        _data = load_data(data)\n\n        async def root_iter() -> AsyncIterable[JSONPathMatch]:\n            yield self.env.match_class(\n                filter_context=filter_context or {},\n                obj=[_data] if self.fake_root else _data,\n                parent=None,\n                path=self.env.root_token,\n                parts=(),\n                root=_data,\n            )\n\n        matches: AsyncIterable[JSONPathMatch] = root_iter()\n\n        for selector in self.selectors:\n            matches = selector.resolve_async(matches)\n\n        return matches\n\n    def match(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Union[JSONPathMatch, None]:\n        \"\"\"Return a `JSONPathMatch` instance for the first object found in _data_.\n\n        `None` is returned if there are no matches.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A `JSONPathMatch` object for the first match, or `None` if there were\n                no matches.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        try:\n            return next(iter(self.finditer(data, filter_context=filter_context)))\n        except StopIteration:\n            return None\n\n    def query(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Query:\n        \"\"\"Return a `Query` iterator over matches found by applying this path to _data_.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A query iterator.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return Query(self.finditer(data, filter_context=filter_context), self.env)\n\n    def empty(self) -> bool:\n        \"\"\"Return `True` if this path has no selectors.\"\"\"\n        return not bool(self.selectors)\n\n    def singular_query(self) -> bool:\n        \"\"\"Return `True` if this JSONPath query is a singular query.\"\"\"\n        for selector in self.selectors:\n            if isinstance(selector, (PropertySelector, IndexSelector)):\n                continue\n            if (\n                isinstance(selector, ListSelector)\n                and len(selector.items) == 1\n                and isinstance(selector.items[0], (PropertySelector, IndexSelector))\n            ):\n                continue\n            return False\n        return True\n\n\nclass CompoundJSONPath:\n    \"\"\"Multiple `JSONPath`s combined.\"\"\"\n\n    __slots__ = (\"env\", \"path\", \"paths\")\n\n    def __init__(\n        self,\n        *,\n        env: JSONPathEnvironment,\n        path: Union[JSONPath, CompoundJSONPath],\n        paths: Iterable[Tuple[str, JSONPath]] = (),\n    ) -> None:\n        self.env = env\n        self.path = path\n        self.paths = tuple(paths)\n\n    def __str__(self) -> str:\n        buf: List[str] = [str(self.path)]\n        for op, path in self.paths:\n            buf.append(f\" {op} \")\n            buf.append(str(path))\n        return \"\".join(buf)\n\n    def __eq__(self, __value: object) -> bool:\n        return (\n            isinstance(__value, CompoundJSONPath)\n            and self.path == __value.path\n            and self.paths == __value.paths\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.path, self.paths))\n\n    def findall(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> List[object]:\n        \"\"\"Find all objects in `data` matching the given JSONPath `path`.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A list of matched objects. If there are no matches, the list will\n                be empty.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        objs = self.path.findall(data, filter_context=filter_context)\n\n        for op, path in self.paths:\n            _objs = path.findall(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                objs.extend(_objs)\n            else:\n                assert op == self.env.intersection_token, op\n                objs = [obj for obj in objs if obj in _objs]\n\n        return objs\n\n    def finditer(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Iterable[JSONPathMatch]:\n        \"\"\"Generate `JSONPathMatch` objects for each match.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            An iterator yielding `JSONPathMatch` objects for each match.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        matches = self.path.finditer(data, filter_context=filter_context)\n\n        for op, path in self.paths:\n            _matches = path.finditer(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                matches = itertools.chain(matches, _matches)\n            else:\n                assert op == self.env.intersection_token\n                _objs = [match.obj for match in _matches]\n                matches = (match for match in matches if match.obj in _objs)\n\n        return matches\n\n    def match(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Union[JSONPathMatch, None]:\n        \"\"\"Return a `JSONPathMatch` instance for the first object found in _data_.\n\n        `None` is returned if there are no matches.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A `JSONPathMatch` object for the first match, or `None` if there were\n                no matches.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        try:\n            return next(iter(self.finditer(data, filter_context=filter_context)))\n        except StopIteration:\n            return None\n\n    async def findall_async(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> List[object]:\n        \"\"\"An async version of `findall()`.\"\"\"\n        objs = await self.path.findall_async(data, filter_context=filter_context)\n\n        for op, path in self.paths:\n            _objs = await path.findall_async(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                objs.extend(_objs)\n            else:\n                assert op == self.env.intersection_token\n                objs = [obj for obj in objs if obj in _objs]\n\n        return objs\n\n    async def finditer_async(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `finditer()`.\"\"\"\n        matches = await self.path.finditer_async(data, filter_context=filter_context)\n\n        for op, path in self.paths:\n            _matches = await path.finditer_async(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                matches = _achain(matches, _matches)\n            else:\n                assert op == self.env.intersection_token\n                _objs = [match.obj async for match in _matches]\n                matches = (match async for match in matches if match.obj in _objs)\n\n        return matches\n\n    def query(\n        self,\n        data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]],\n        *,\n        filter_context: Optional[FilterContextVars] = None,\n    ) -> Query:\n        \"\"\"Return a `Query` iterator over matches found by applying this path to _data_.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A query iterator.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return Query(self.finditer(data, filter_context=filter_context), self.env)\n\n    def union(self, path: JSONPath) -> CompoundJSONPath:\n        \"\"\"Union of this path and another path.\"\"\"\n        return self.__class__(\n            env=self.env,\n            path=self.path,\n            paths=self.paths + ((self.env.union_token, path),),\n        )\n\n    def intersection(self, path: JSONPath) -> CompoundJSONPath:\n        \"\"\"Intersection of this path and another path.\"\"\"\n        return self.__class__(\n            env=self.env,\n            path=self.path,\n            paths=self.paths + ((self.env.intersection_token, path),),\n        )\n\n\nT = TypeVar(\"T\")\n\n\nasync def _achain(*iterables: AsyncIterable[T]) -> AsyncIterable[T]:\n    for it in iterables:\n        async for element in it:\n            yield element\n"
  },
  "GT_src_dict": {
    "jsonpath/filter.py": {},
    "jsonpath/selectors.py": {},
    "jsonpath/match.py": {},
    "jsonpath/pointer.py": {
      "JSONPointer.__init__": {
        "code": "    def __init__(self, pointer: str, *, parts: Tuple[Union[int, str], ...]=(), unicode_escape: bool=True, uri_decode: bool=False) -> None:\n        \"\"\"Initialize a JSONPointer instance to identify a specific value in JSON-like data as per RFC 6901.\n\nArgs:\n    pointer (str): A string representation of a JSON Pointer.\n    parts (Tuple[Union[int, str], ...], optional): Pre-parsed keys, indices, and/or slices that comprise the JSON Pointer. If provided, this bypasses parsing.\n    unicode_escape (bool, optional): If True, UTF-16 escape sequences will be decoded before parsing. Defaults to True.\n    uri_decode (bool, optional): If True, the pointer will be URI decoded before parsing. Defaults to False.\n\nAttributes:\n    parts (Tuple[Union[int, str], ...]): The keys or indices describing the path to a specific value within a JSON structure.\n    _s (str): The string representation of the JSON Pointer, created by encoding the parts.\n\nThe constructor leverages the `_parse` method to convert the pointer string into a tuple of parts (if not already provided) and calls `_encode` to generate its string representation.\"\"\"\n        self.parts = parts or self._parse(pointer, unicode_escape=unicode_escape, uri_decode=uri_decode)\n        self._s = self._encode(self.parts)",
        "docstring": "Initialize a JSONPointer instance to identify a specific value in JSON-like data as per RFC 6901.\n\nArgs:\n    pointer (str): A string representation of a JSON Pointer.\n    parts (Tuple[Union[int, str], ...], optional): Pre-parsed keys, indices, and/or slices that comprise the JSON Pointer. If provided, this bypasses parsing.\n    unicode_escape (bool, optional): If True, UTF-16 escape sequences will be decoded before parsing. Defaults to True.\n    uri_decode (bool, optional): If True, the pointer will be URI decoded before parsing. Defaults to False.\n\nAttributes:\n    parts (Tuple[Union[int, str], ...]): The keys or indices describing the path to a specific value within a JSON structure.\n    _s (str): The string representation of the JSON Pointer, created by encoding the parts.\n\nThe constructor leverages the `_parse` method to convert the pointer string into a tuple of parts (if not already provided) and calls `_encode` to generate its string representation.",
        "signature": "def __init__(self, pointer: str, *, parts: Tuple[Union[int, str], ...]=(), unicode_escape: bool=True, uri_decode: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class JSONPointer:"
      },
      "JSONPointer._parse": {
        "code": "    def _parse(self, s: str, *, unicode_escape: bool, uri_decode: bool) -> Tuple[Union[int, str], ...]:\n        \"\"\"Parse a JSON Pointer string into its constituent parts.\n\nArgs:\n    s (str): The JSON Pointer string to be parsed.\n    unicode_escape (bool): If `True`, applies UTF-16 escape sequence decoding to the pointer.\n    uri_decode (bool): If `True`, applies URI decoding to the pointer.\n\nReturns:\n    Tuple[Union[int, str], ...]: A tuple of keys, indices, and/or slices representing the parsed parts of the JSON Pointer. The first element is omitted as it corresponds to the root.\n\nRaises:\n    JSONPointerError: If the pointer does not start with a slash or is not an empty string.\n\nThis method uses the `unquote` function to decode URI-encoded strings and `_unicode_escape` to handle UTF-16 escape sequences if specified. It relies on `_index` to convert path elements into appropriate types (either integers or strings). The `~1` and `~0` sequences are specifically replaced with their corresponding characters (`/` and `~`) for correct parsing.\"\"\"\n        if uri_decode:\n            s = unquote(s)\n        if unicode_escape:\n            s = self._unicode_escape(s)\n        s = s.lstrip()\n        if s and (not s.startswith('/')):\n            raise JSONPointerError('pointer must start with a slash or be the empty string')\n        return tuple((self._index(p.replace('~1', '/').replace('~0', '~')) for p in s.split('/')))[1:]",
        "docstring": "Parse a JSON Pointer string into its constituent parts.\n\nArgs:\n    s (str): The JSON Pointer string to be parsed.\n    unicode_escape (bool): If `True`, applies UTF-16 escape sequence decoding to the pointer.\n    uri_decode (bool): If `True`, applies URI decoding to the pointer.\n\nReturns:\n    Tuple[Union[int, str], ...]: A tuple of keys, indices, and/or slices representing the parsed parts of the JSON Pointer. The first element is omitted as it corresponds to the root.\n\nRaises:\n    JSONPointerError: If the pointer does not start with a slash or is not an empty string.\n\nThis method uses the `unquote` function to decode URI-encoded strings and `_unicode_escape` to handle UTF-16 escape sequences if specified. It relies on `_index` to convert path elements into appropriate types (either integers or strings). The `~1` and `~0` sequences are specifically replaced with their corresponding characters (`/` and `~`) for correct parsing.",
        "signature": "def _parse(self, s: str, *, unicode_escape: bool, uri_decode: bool) -> Tuple[Union[int, str], ...]:",
        "type": "Method",
        "class_signature": "class JSONPointer:"
      },
      "JSONPointer._encode": {
        "code": "    def _encode(parts: Iterable[Union[int, str]]) -> str:\n        \"\"\"Encode a sequence of JSON Pointer parts into a valid JSON Pointer string format.\n\nArgs:\n    parts (Iterable[Union[int, str]]): An iterable containing keys and/or indices that make up the JSON Pointer path.\n\nReturns:\n    str: A string representation of the JSON Pointer, beginning with a leading '/'\n          and with special characters escaped according to JSON Pointer syntax.\n          \nThis method replaces '~' with '~0' and '/' with '~1' to ensure proper encoding\nof characters as specified in RFC 6901. The use of this method is vital for forming\nvalid JSON Pointer strings, which can then be utilized for resolving paths within\nJSON-like data structures.\"\"\"\n        if parts:\n            return '/' + '/'.join((str(p).replace('~', '~0').replace('/', '~1') for p in parts))\n        return ''",
        "docstring": "Encode a sequence of JSON Pointer parts into a valid JSON Pointer string format.\n\nArgs:\n    parts (Iterable[Union[int, str]]): An iterable containing keys and/or indices that make up the JSON Pointer path.\n\nReturns:\n    str: A string representation of the JSON Pointer, beginning with a leading '/'\n          and with special characters escaped according to JSON Pointer syntax.\n          \nThis method replaces '~' with '~0' and '/' with '~1' to ensure proper encoding\nof characters as specified in RFC 6901. The use of this method is vital for forming\nvalid JSON Pointer strings, which can then be utilized for resolving paths within\nJSON-like data structures.",
        "signature": "def _encode(parts: Iterable[Union[int, str]]) -> str:",
        "type": "Method",
        "class_signature": "class JSONPointer:"
      },
      "RelativeJSONPointer.__init__": {
        "code": "    def __init__(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> None:\n        \"\"\"Initialize a RelativeJSONPointer instance based on the given relative pointer string.\n\nArgs:\n    rel (str): A string representing the relative JSON pointer, which follows the Relative JSON Pointer syntax.\n    unicode_escape (bool, optional): If `True`, UTF-16 escape sequences will be decoded before parsing the pointer. Defaults to `True`.\n    uri_decode (bool, optional): If `True`, the pointer will be unescaped using urllib before being parsed. Defaults to `False`.\n\nThis constructor parses the `rel` string to extract the origin, index, and pointer components using the `_parse` method. The `origin` indicates the starting point within a target JSON structure, while `index` can adjust the pointer's position and `pointer` holds the actual JSON Pointer or may represent the current object's reference in the JSON structure. It interacts with other methods in the class to allow for relative navigation in JSON structures, as defined in the external RFC specifications.\"\"\"\n        self.origin, self.index, self.pointer = self._parse(rel, unicode_escape=unicode_escape, uri_decode=uri_decode)",
        "docstring": "Initialize a RelativeJSONPointer instance based on the given relative pointer string.\n\nArgs:\n    rel (str): A string representing the relative JSON pointer, which follows the Relative JSON Pointer syntax.\n    unicode_escape (bool, optional): If `True`, UTF-16 escape sequences will be decoded before parsing the pointer. Defaults to `True`.\n    uri_decode (bool, optional): If `True`, the pointer will be unescaped using urllib before being parsed. Defaults to `False`.\n\nThis constructor parses the `rel` string to extract the origin, index, and pointer components using the `_parse` method. The `origin` indicates the starting point within a target JSON structure, while `index` can adjust the pointer's position and `pointer` holds the actual JSON Pointer or may represent the current object's reference in the JSON structure. It interacts with other methods in the class to allow for relative navigation in JSON structures, as defined in the external RFC specifications.",
        "signature": "def __init__(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      },
      "RelativeJSONPointer.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Return a string representation of the RelativeJSONPointer instance.\n\nThe format includes the origin, an optional index adjustment (prefixed with '+' or '-' depending on its sign), and the pointer path. The `origin` indicates the starting point in the parent JSON structure, while the `index` may modify the last item in the pointer's path. If the `index` is zero, it is omitted from the output. This method is useful for obtaining a textual description of the relative pointer for debugging or logging purposes.\n\nAttributes:\n- `origin` (int): The origin from which the relative pointer is based, defined during initialization.\n- `index` (int): An adjustment to the last index of the pointer, also defined during initialization.\n- `pointer` (Union[JSONPointer, str]): The remaining pointer path, which can be another JSONPointer instance or a string, initialized with the relative pointer syntax.\n\nThis method depends on the format specified in the Relative JSON Pointer specification.\"\"\"\n        sign = '+' if self.index > 0 else ''\n        index = '' if self.index == 0 else f'{sign}{self.index}'\n        return f'{self.origin}{index}{self.pointer}'",
        "docstring": "Return a string representation of the RelativeJSONPointer instance.\n\nThe format includes the origin, an optional index adjustment (prefixed with '+' or '-' depending on its sign), and the pointer path. The `origin` indicates the starting point in the parent JSON structure, while the `index` may modify the last item in the pointer's path. If the `index` is zero, it is omitted from the output. This method is useful for obtaining a textual description of the relative pointer for debugging or logging purposes.\n\nAttributes:\n- `origin` (int): The origin from which the relative pointer is based, defined during initialization.\n- `index` (int): An adjustment to the last index of the pointer, also defined during initialization.\n- `pointer` (Union[JSONPointer, str]): The remaining pointer path, which can be another JSONPointer instance or a string, initialized with the relative pointer syntax.\n\nThis method depends on the format specified in the Relative JSON Pointer specification.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      },
      "RelativeJSONPointer.__eq__": {
        "code": "    def __eq__(self, __value: object) -> bool:\n        \"\"\"Check for equality between two `RelativeJSONPointer` instances.\n\nArgs:\n    __value (object): The object to compare against the current instance. It can be of any type.\n\nReturns:\n    bool: `True` if `__value` is a `RelativeJSONPointer` and its string representation is equal to that of the current instance; otherwise, `False`.\n\nThe method relies on the `__str__` method of the `RelativeJSONPointer` class to obtain string representations for comparison.\"\"\"\n        return isinstance(__value, RelativeJSONPointer) and str(self) == str(__value)",
        "docstring": "Check for equality between two `RelativeJSONPointer` instances.\n\nArgs:\n    __value (object): The object to compare against the current instance. It can be of any type.\n\nReturns:\n    bool: `True` if `__value` is a `RelativeJSONPointer` and its string representation is equal to that of the current instance; otherwise, `False`.\n\nThe method relies on the `__str__` method of the `RelativeJSONPointer` class to obtain string representations for comparison.",
        "signature": "def __eq__(self, __value: object) -> bool:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      },
      "RelativeJSONPointer._parse": {
        "code": "    def _parse(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> Tuple[int, int, Union[JSONPointer, str]]:\n        \"\"\"Parse a relative JSON Pointer string and extract its components.\n\nArgs:\n    rel: A string following Relative JSON Pointer syntax that indicates the origin,\n         optional index, and pointer to the target location.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using urllib before being parsed.\n\nReturns:\n    A tuple containing:\n        - origin (int): A zero or positive integer indicating the reference point for the pointer.\n        - index (int): An integer representing the optional index offset (can be positive or negative).\n        - pointer (Union[JSONPointer, str]): A JSONPointer instance or a string representing the pointer, \n          which can be an empty string or a special \"#\" for the current node.\n\nRaises:\n    RelativeJSONPointerSyntaxError: If the input string does not match the expected format or contains invalid values.\n\nThis method relies on RE_RELATIVE_POINTER, a compiled regular expression that defines the syntax for \nrelative JSON pointers. It is used to validate and extract components of the input string.\"\"\"\n        rel = rel.lstrip()\n        match = RE_RELATIVE_POINTER.match(rel)\n        if not match:\n            raise RelativeJSONPointerSyntaxError('', rel)\n        origin = self._zero_or_positive(match.group('ORIGIN'), rel)\n        if match.group('INDEX_G'):\n            index = self._zero_or_positive(match.group('INDEX'), rel)\n            if index == 0:\n                raise RelativeJSONPointerSyntaxError(\"index offset can't be zero\", rel)\n            if match.group('SIGN') == '-':\n                index = -index\n        else:\n            index = 0\n        _pointer = match.group('POINTER').strip()\n        pointer = JSONPointer(_pointer, unicode_escape=unicode_escape, uri_decode=uri_decode) if _pointer != '#' else _pointer\n        return (origin, index, pointer)",
        "docstring": "Parse a relative JSON Pointer string and extract its components.\n\nArgs:\n    rel: A string following Relative JSON Pointer syntax that indicates the origin,\n         optional index, and pointer to the target location.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using urllib before being parsed.\n\nReturns:\n    A tuple containing:\n        - origin (int): A zero or positive integer indicating the reference point for the pointer.\n        - index (int): An integer representing the optional index offset (can be positive or negative).\n        - pointer (Union[JSONPointer, str]): A JSONPointer instance or a string representing the pointer, \n          which can be an empty string or a special \"#\" for the current node.\n\nRaises:\n    RelativeJSONPointerSyntaxError: If the input string does not match the expected format or contains invalid values.\n\nThis method relies on RE_RELATIVE_POINTER, a compiled regular expression that defines the syntax for \nrelative JSON pointers. It is used to validate and extract components of the input string.",
        "signature": "def _parse(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> Tuple[int, int, Union[JSONPointer, str]]:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      },
      "RelativeJSONPointer._int_like": {
        "code": "    def _int_like(self, obj: Any) -> bool:\n        \"\"\"Check if an object is integer-like.\n\nArgs:\n    obj: The object to be checked for integer-like behavior. It can be of any type.\n\nReturns:\n    bool: True if the object is an instance of int or can be converted to an int without raising a ValueError; otherwise, False.\n\nThis method is utilized within the `RelativeJSONPointer` class to determine if a given value can be treated as a numerical index, especially when handling JSON-like structures that contain sequences. It plays a significant role in parsing and resolving relative JSON pointers.\"\"\"\n        if isinstance(obj, int):\n            return True\n        try:\n            int(obj)\n        except ValueError:\n            return False\n        return True",
        "docstring": "Check if an object is integer-like.\n\nArgs:\n    obj: The object to be checked for integer-like behavior. It can be of any type.\n\nReturns:\n    bool: True if the object is an instance of int or can be converted to an int without raising a ValueError; otherwise, False.\n\nThis method is utilized within the `RelativeJSONPointer` class to determine if a given value can be treated as a numerical index, especially when handling JSON-like structures that contain sequences. It plays a significant role in parsing and resolving relative JSON pointers.",
        "signature": "def _int_like(self, obj: Any) -> bool:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      },
      "RelativeJSONPointer.to": {
        "code": "    def to(self, pointer: Union[JSONPointer, str], *, unicode_escape: bool=True, uri_decode: bool=False) -> JSONPointer:\n        \"\"\"Return a new JSONPointer that is relative to the specified pointer.\n\nArgs:\n    pointer: A `JSONPointer` instance or a string representing a JSON Pointer.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using `urllib` before being parsed.\n\nReturns:\n    A new `JSONPointer` that represents the relative reference from the original pointer, constructed based on the origin and index specified in the `RelativeJSONPointer`.\n\nRaises:\n    RelativeJSONPointerIndexError: If the origin exceeds the number of parts available in the specified pointer or if the calculated index becomes negative.\n\nThe method utilizes attributes `origin`, `index`, and `pointer` defined in the `RelativeJSONPointer` class to determine the new relative position and construct the resulting JSONPointer. The logic for calculating the new pointer involves navigating to the origin and applying any specified index offsets.\"\"\"\n        'Return a new JSONPointer relative to _pointer_.\\n\\n        Args:\\n            pointer: A `JSONPointer` instance or a string following JSON\\n                Pointer syntax.\\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\\n                before parsing the pointer.\\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\\n                before being parsed.\\n        '\n        _pointer = JSONPointer(pointer, unicode_escape=unicode_escape, uri_decode=uri_decode) if isinstance(pointer, str) else pointer\n        if self.origin > len(_pointer.parts):\n            raise RelativeJSONPointerIndexError(f'origin ({self.origin}) exceeds root ({len(_pointer.parts)})')\n        if self.origin < 1:\n            parts = list(_pointer.parts)\n        else:\n            parts = list(_pointer.parts[:-self.origin])\n        if self.index and parts and self._int_like(parts[-1]):\n            new_index = int(parts[-1]) + self.index\n            if new_index < 0:\n                raise RelativeJSONPointerIndexError(f'index offset out of range {new_index}')\n            parts[-1] = int(parts[-1]) + self.index\n        if isinstance(self.pointer, JSONPointer):\n            parts.extend(self.pointer.parts)\n        else:\n            assert self.pointer == '#'\n            parts[-1] = f'#{parts[-1]}'\n        return JSONPointer.from_parts(parts, unicode_escape=unicode_escape, uri_decode=uri_decode)",
        "docstring": "Return a new JSONPointer that is relative to the specified pointer.\n\nArgs:\n    pointer: A `JSONPointer` instance or a string representing a JSON Pointer.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using `urllib` before being parsed.\n\nReturns:\n    A new `JSONPointer` that represents the relative reference from the original pointer, constructed based on the origin and index specified in the `RelativeJSONPointer`.\n\nRaises:\n    RelativeJSONPointerIndexError: If the origin exceeds the number of parts available in the specified pointer or if the calculated index becomes negative.\n\nThe method utilizes attributes `origin`, `index`, and `pointer` defined in the `RelativeJSONPointer` class to determine the new relative position and construct the resulting JSONPointer. The logic for calculating the new pointer involves navigating to the origin and applying any specified index offsets.",
        "signature": "def to(self, pointer: Union[JSONPointer, str], *, unicode_escape: bool=True, uri_decode: bool=False) -> JSONPointer:",
        "type": "Method",
        "class_signature": "class RelativeJSONPointer:"
      }
    },
    "jsonpath/path.py": {}
  },
  "dependency_dict": {
    "jsonpath/pointer.py:RelativeJSONPointer:__init__": {},
    "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
      "jsonpath/pointer.py": {
        "RelativeJSONPointer._zero_or_positive": {
          "code": "    def _zero_or_positive(self, s: str, rel: str) -> int:\n        if s.startswith('0') and len(s) > 1:\n            raise RelativeJSONPointerSyntaxError('unexpected leading zero', rel)\n        try:\n            return int(s)\n        except ValueError as err:\n            raise RelativeJSONPointerSyntaxError('expected positive int or zero', rel) from err",
          "docstring": "",
          "signature": "def _zero_or_positive(self, s: str, rel: str) -> int:",
          "type": "Method",
          "class_signature": "class RelativeJSONPointer:"
        }
      },
      "jsonpath/exceptions.py": {
        "RelativeJSONPointerSyntaxError.__init__": {
          "code": "    def __init__(self, msg: str, rel: str) -> None:\n        super().__init__(msg)\n        self.rel = rel",
          "docstring": "",
          "signature": "def __init__(self, msg: str, rel: str) -> None:",
          "type": "Method",
          "class_signature": "class RelativeJSONPointerSyntaxError(RelativeJSONPointerError):"
        }
      }
    },
    "jsonpath/pointer.py:JSONPointer:__init__": {},
    "jsonpath/pointer.py:JSONPointer:_parse": {
      "jsonpath/pointer.py": {
        "JSONPointer._index": {
          "code": "    def _index(self, s: str) -> Union[str, int]:\n        if len(s) > 1 and s.startswith('0'):\n            return s\n        try:\n            index = int(s)\n            if index < self.min_int_index or index > self.max_int_index:\n                raise JSONPointerIndexError('index out of range')\n            return index\n        except ValueError:\n            return s",
          "docstring": "",
          "signature": "def _index(self, s: str) -> Union[str, int]:",
          "type": "Method",
          "class_signature": "class JSONPointer:"
        },
        "JSONPointer._unicode_escape": {
          "code": "    def _unicode_escape(self, s: str) -> str:\n        return codecs.decode(s.replace('\\\\/', '/'), 'unicode-escape').encode('utf-16', 'surrogatepass').decode('utf-16')",
          "docstring": "",
          "signature": "def _unicode_escape(self, s: str) -> str:",
          "type": "Method",
          "class_signature": "class JSONPointer:"
        }
      }
    },
    "jsonpath/pointer.py:JSONPointer:_encode": {},
    "jsonpath/pointer.py:RelativeJSONPointer:to": {},
    "jsonpath/pointer.py:JSONPointer:JSONPointer": {},
    "jsonpath/pointer.py:RelativeJSONPointer:__eq__": {},
    "jsonpath/pointer.py:RelativeJSONPointer:RelativeJSONPointer": {},
    "jsonpath/pointer.py:RelativeJSONPointer:__str__": {
      "jsonpath/pointer.py": {
        "JSONPointer.__str__": {
          "code": "    def __str__(self) -> str:\n        return self._s",
          "docstring": "",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class JSONPointer:"
        }
      }
    },
    "jsonpath/pointer.py:RelativeJSONPointer:_int_like": {}
  },
  "call_tree": {
    "tests/test_relative_json_pointer.py:test_syntax_error": {
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/exceptions.py:RelativeJSONPointerSyntaxError:__init__": {}
        }
      }
    },
    "tests/test_relative_json_pointer.py:test_origin_leading_zero": {
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/pointer.py:RelativeJSONPointer:_zero_or_positive": {
            "jsonpath/exceptions.py:RelativeJSONPointerSyntaxError:__init__": {}
          }
        }
      }
    },
    "tests/test_relative_json_pointer.py:test_origin_beyond_pointer": {
      "jsonpath/pointer.py:JSONPointer:__init__": {
        "jsonpath/pointer.py:JSONPointer:_parse": {
          "jsonpath/pointer.py:JSONPointer:_unicode_escape": {},
          "jsonpath/pointer.py:JSONPointer:_index": {}
        },
        "jsonpath/pointer.py:JSONPointer:_encode": {}
      },
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/pointer.py:RelativeJSONPointer:_zero_or_positive": {},
          "jsonpath/pointer.py:JSONPointer:__init__": {
            "jsonpath/pointer.py:JSONPointer:_parse": {
              "jsonpath/pointer.py:JSONPointer:_unicode_escape": {},
              "jsonpath/pointer.py:JSONPointer:_index": {}
            },
            "jsonpath/pointer.py:JSONPointer:_encode": {}
          }
        }
      },
      "jsonpath/pointer.py:RelativeJSONPointer:to": {
        "jsonpath/pointer.py:JSONPointer:JSONPointer": {}
      }
    },
    "tests/test_relative_json_pointer.py:test_equality": {
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/pointer.py:RelativeJSONPointer:_zero_or_positive": {},
          "jsonpath/pointer.py:JSONPointer:__init__": {
            "jsonpath/pointer.py:JSONPointer:_parse": {
              "jsonpath/pointer.py:JSONPointer:_unicode_escape": {},
              "jsonpath/pointer.py:JSONPointer:_index": {}
            },
            "jsonpath/pointer.py:JSONPointer:_encode": {}
          }
        }
      },
      "jsonpath/pointer.py:RelativeJSONPointer:__eq__": {
        "jsonpath/pointer.py:RelativeJSONPointer:RelativeJSONPointer": {},
        "jsonpath/pointer.py:RelativeJSONPointer:__str__": {
          "jsonpath/pointer.py:JSONPointer:__str__": {}
        }
      }
    },
    "tests/test_relative_json_pointer.py:test_zero_index_offset": {
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/pointer.py:RelativeJSONPointer:_zero_or_positive": {},
          "jsonpath/exceptions.py:RelativeJSONPointerSyntaxError:__init__": {}
        }
      }
    },
    "tests/test_relative_json_pointer.py:test_negative_index_offset": {
      "jsonpath/pointer.py:JSONPointer:__init__": {
        "jsonpath/pointer.py:JSONPointer:_parse": {
          "jsonpath/pointer.py:JSONPointer:_unicode_escape": {},
          "jsonpath/pointer.py:JSONPointer:_index": {}
        },
        "jsonpath/pointer.py:JSONPointer:_encode": {}
      },
      "jsonpath/pointer.py:RelativeJSONPointer:__init__": {
        "jsonpath/pointer.py:RelativeJSONPointer:_parse": {
          "jsonpath/pointer.py:RelativeJSONPointer:_zero_or_positive": {},
          "jsonpath/pointer.py:JSONPointer:__init__": {
            "jsonpath/pointer.py:JSONPointer:_parse": {
              "jsonpath/pointer.py:JSONPointer:_unicode_escape": {},
              "jsonpath/pointer.py:JSONPointer:_index": {}
            },
            "jsonpath/pointer.py:JSONPointer:_encode": {}
          }
        }
      },
      "jsonpath/pointer.py:RelativeJSONPointer:to": {
        "jsonpath/pointer.py:RelativeJSONPointer:_int_like": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_filter_expression_caching.py:test_cache_root_path": {
      "jsonpath/path.py:JSONPath:JSONPath": {},
      "jsonpath/selectors.py:ListSelector:ListSelector": {},
      "jsonpath/filter.py:BooleanExpression:BooleanExpression": {},
      "jsonpath/filter.py:InfixExpression:InfixExpression": {},
      "jsonpath/filter.py:SelfPath:SelfPath": {},
      "jsonpath/filter.py:RootPath:RootPath": {},
      "jsonpath/filter.py:CachingFilterExpression:CachingFilterExpression": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_filter_expression_caching.py:test_cache_context_path": {
      "jsonpath/path.py:JSONPath:JSONPath": {},
      "jsonpath/selectors.py:ListSelector:ListSelector": {},
      "jsonpath/filter.py:BooleanExpression:BooleanExpression": {},
      "jsonpath/filter.py:InfixExpression:InfixExpression": {},
      "jsonpath/filter.py:FilterContextPath:FilterContextPath": {},
      "jsonpath/filter.py:SelfPath:SelfPath": {},
      "jsonpath/filter.py:CachingFilterExpression:CachingFilterExpression": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_filter_expression_caching.py:test_uncacheable_filter": {
      "jsonpath/path.py:JSONPath:JSONPath": {},
      "jsonpath/selectors.py:ListSelector:ListSelector": {},
      "jsonpath/filter.py:BooleanExpression:BooleanExpression": {},
      "jsonpath/filter.py:InfixExpression:InfixExpression": {},
      "jsonpath/filter.py:SelfPath:SelfPath": {},
      "jsonpath/filter.py:IntegerLiteral:IntegerLiteral": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_fluent_api.py:test_query_first_one": {
      "jsonpath/match.py:JSONPathMatch:JSONPathMatch": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_fluent_api.py:test_query_one": {
      "jsonpath/match.py:JSONPathMatch:JSONPathMatch": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_fluent_api.py:test_query_last_one": {
      "jsonpath/match.py:JSONPathMatch:JSONPathMatch": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/python_jsonpath-image-test_relative_json_pointer/python_jsonpath-test_relative_json_pointer/tests/test_walk_filter_expression_tree.py:test_is_volatile": {
      "jsonpath/selectors.py:ListSelector:ListSelector": {}
    }
  },
  "PRD": "# PROJECT NAME: python_jsonpath-test_relative_json_pointer\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 jsonpath/\n    \u251c\u2500\u2500 filter.py\n    \u2502   \u251c\u2500\u2500 BooleanExpression.BooleanExpression\n    \u2502   \u251c\u2500\u2500 CachingFilterExpression.CachingFilterExpression\n    \u2502   \u251c\u2500\u2500 FilterContextPath.FilterContextPath\n    \u2502   \u251c\u2500\u2500 InfixExpression.InfixExpression\n    \u2502   \u251c\u2500\u2500 IntegerLiteral.IntegerLiteral\n    \u2502   \u251c\u2500\u2500 RootPath.RootPath\n    \u2502   \u2514\u2500\u2500 SelfPath.SelfPath\n    \u251c\u2500\u2500 match.py\n    \u2502   \u2514\u2500\u2500 JSONPathMatch.JSONPathMatch\n    \u251c\u2500\u2500 path.py\n    \u2502   \u2514\u2500\u2500 JSONPath.JSONPath\n    \u251c\u2500\u2500 pointer.py\n    \u2502   \u251c\u2500\u2500 JSONPointer.JSONPointer\n    \u2502   \u251c\u2500\u2500 JSONPointer.__init__\n    \u2502   \u251c\u2500\u2500 JSONPointer._encode\n    \u2502   \u251c\u2500\u2500 JSONPointer._parse\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer.RelativeJSONPointer\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer.__eq__\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer.__init__\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer.__str__\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer._int_like\n    \u2502   \u251c\u2500\u2500 RelativeJSONPointer._parse\n    \u2502   \u2514\u2500\u2500 RelativeJSONPointer.to\n    \u2514\u2500\u2500 selectors.py\n        \u2514\u2500\u2500 ListSelector.ListSelector\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates robust validation and manipulation of JSON Pointers, with a specific focus on supporting and enforcing the Relative JSON Pointer specification. It provides functionality to parse, evaluate, and compare relative JSON pointers, ensuring compliance with syntax rules and handling edge cases such as invalid syntax, out-of-bounds references, or malformed offsets. By raising well-defined errors like `RelativeJSONPointerSyntaxError` and `RelativeJSONPointerIndexError`, the module helps developers identify and resolve issues early in JSON pointer usage. This eliminates potential errors when working with nested JSON structures, streamlines pointer-based navigation, and ensures reliable data access in JSON-based workflows or APIs.\n\n## FILE 1: jsonpath/filter.py\n\n## FILE 2: jsonpath/selectors.py\n\n## FILE 3: jsonpath/match.py\n\n## FILE 4: jsonpath/pointer.py\n\n- CLASS METHOD: RelativeJSONPointer._parse\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def _parse(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> Tuple[int, int, Union[JSONPointer, str]]:\n  - DOCSTRING: \n```python\n\"\"\"\nParse a relative JSON Pointer string and extract its components.\n\nArgs:\n    rel: A string following Relative JSON Pointer syntax that indicates the origin,\n         optional index, and pointer to the target location.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using urllib before being parsed.\n\nReturns:\n    A tuple containing:\n        - origin (int): A zero or positive integer indicating the reference point for the pointer.\n        - index (int): An integer representing the optional index offset (can be positive or negative).\n        - pointer (Union[JSONPointer, str]): A JSONPointer instance or a string representing the pointer, \n          which can be an empty string or a special \"#\" for the current node.\n\nRaises:\n    RelativeJSONPointerSyntaxError: If the input string does not match the expected format or contains invalid values.\n\nThis method relies on RE_RELATIVE_POINTER, a compiled regular expression that defines the syntax for \nrelative JSON pointers. It is used to validate and extract components of the input string.\n\"\"\"\n```\n\n- CLASS METHOD: RelativeJSONPointer.to\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def to(self, pointer: Union[JSONPointer, str], *, unicode_escape: bool=True, uri_decode: bool=False) -> JSONPointer:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a new JSONPointer that is relative to the specified pointer.\n\nArgs:\n    pointer: A `JSONPointer` instance or a string representing a JSON Pointer.\n    unicode_escape: If `True`, UTF-16 escape sequences will be decoded before parsing the pointer.\n    uri_decode: If `True`, the pointer will be unescaped using `urllib` before being parsed.\n\nReturns:\n    A new `JSONPointer` that represents the relative reference from the original pointer, constructed based on the origin and index specified in the `RelativeJSONPointer`.\n\nRaises:\n    RelativeJSONPointerIndexError: If the origin exceeds the number of parts available in the specified pointer or if the calculated index becomes negative.\n\nThe method utilizes attributes `origin`, `index`, and `pointer` defined in the `RelativeJSONPointer` class to determine the new relative position and construct the resulting JSONPointer. The logic for calculating the new pointer involves navigating to the origin and applying any specified index offsets.\n\"\"\"\n```\n\n- CLASS METHOD: RelativeJSONPointer._int_like\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def _int_like(self, obj: Any) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if an object is integer-like.\n\nArgs:\n    obj: The object to be checked for integer-like behavior. It can be of any type.\n\nReturns:\n    bool: True if the object is an instance of int or can be converted to an int without raising a ValueError; otherwise, False.\n\nThis method is utilized within the `RelativeJSONPointer` class to determine if a given value can be treated as a numerical index, especially when handling JSON-like structures that contain sequences. It plays a significant role in parsing and resolving relative JSON pointers.\n\"\"\"\n```\n\n- CLASS METHOD: JSONPointer._parse\n  - CLASS SIGNATURE: class JSONPointer:\n  - SIGNATURE: def _parse(self, s: str, *, unicode_escape: bool, uri_decode: bool) -> Tuple[Union[int, str], ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nParse a JSON Pointer string into its constituent parts.\n\nArgs:\n    s (str): The JSON Pointer string to be parsed.\n    unicode_escape (bool): If `True`, applies UTF-16 escape sequence decoding to the pointer.\n    uri_decode (bool): If `True`, applies URI decoding to the pointer.\n\nReturns:\n    Tuple[Union[int, str], ...]: A tuple of keys, indices, and/or slices representing the parsed parts of the JSON Pointer. The first element is omitted as it corresponds to the root.\n\nRaises:\n    JSONPointerError: If the pointer does not start with a slash or is not an empty string.\n\nThis method uses the `unquote` function to decode URI-encoded strings and `_unicode_escape` to handle UTF-16 escape sequences if specified. It relies on `_index` to convert path elements into appropriate types (either integers or strings). The `~1` and `~0` sequences are specifically replaced with their corresponding characters (`/` and `~`) for correct parsing.\n\"\"\"\n```\n\n- CLASS METHOD: RelativeJSONPointer.__str__\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a string representation of the RelativeJSONPointer instance.\n\nThe format includes the origin, an optional index adjustment (prefixed with '+' or '-' depending on its sign), and the pointer path. The `origin` indicates the starting point in the parent JSON structure, while the `index` may modify the last item in the pointer's path. If the `index` is zero, it is omitted from the output. This method is useful for obtaining a textual description of the relative pointer for debugging or logging purposes.\n\nAttributes:\n- `origin` (int): The origin from which the relative pointer is based, defined during initialization.\n- `index` (int): An adjustment to the last index of the pointer, also defined during initialization.\n- `pointer` (Union[JSONPointer, str]): The remaining pointer path, which can be another JSONPointer instance or a string, initialized with the relative pointer syntax.\n\nThis method depends on the format specified in the Relative JSON Pointer specification.\n\"\"\"\n```\n\n- CLASS METHOD: RelativeJSONPointer.__init__\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def __init__(self, rel: str, *, unicode_escape: bool=True, uri_decode: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a RelativeJSONPointer instance based on the given relative pointer string.\n\nArgs:\n    rel (str): A string representing the relative JSON pointer, which follows the Relative JSON Pointer syntax.\n    unicode_escape (bool, optional): If `True`, UTF-16 escape sequences will be decoded before parsing the pointer. Defaults to `True`.\n    uri_decode (bool, optional): If `True`, the pointer will be unescaped using urllib before being parsed. Defaults to `False`.\n\nThis constructor parses the `rel` string to extract the origin, index, and pointer components using the `_parse` method. The `origin` indicates the starting point within a target JSON structure, while `index` can adjust the pointer's position and `pointer` holds the actual JSON Pointer or may represent the current object's reference in the JSON structure. It interacts with other methods in the class to allow for relative navigation in JSON structures, as defined in the external RFC specifications.\n\"\"\"\n```\n\n- CLASS METHOD: JSONPointer.__init__\n  - CLASS SIGNATURE: class JSONPointer:\n  - SIGNATURE: def __init__(self, pointer: str, *, parts: Tuple[Union[int, str], ...]=(), unicode_escape: bool=True, uri_decode: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a JSONPointer instance to identify a specific value in JSON-like data as per RFC 6901.\n\nArgs:\n    pointer (str): A string representation of a JSON Pointer.\n    parts (Tuple[Union[int, str], ...], optional): Pre-parsed keys, indices, and/or slices that comprise the JSON Pointer. If provided, this bypasses parsing.\n    unicode_escape (bool, optional): If True, UTF-16 escape sequences will be decoded before parsing. Defaults to True.\n    uri_decode (bool, optional): If True, the pointer will be URI decoded before parsing. Defaults to False.\n\nAttributes:\n    parts (Tuple[Union[int, str], ...]): The keys or indices describing the path to a specific value within a JSON structure.\n    _s (str): The string representation of the JSON Pointer, created by encoding the parts.\n\nThe constructor leverages the `_parse` method to convert the pointer string into a tuple of parts (if not already provided) and calls `_encode` to generate its string representation.\n\"\"\"\n```\n\n- CLASS METHOD: JSONPointer._encode\n  - CLASS SIGNATURE: class JSONPointer:\n  - SIGNATURE: def _encode(parts: Iterable[Union[int, str]]) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nEncode a sequence of JSON Pointer parts into a valid JSON Pointer string format.\n\nArgs:\n    parts (Iterable[Union[int, str]]): An iterable containing keys and/or indices that make up the JSON Pointer path.\n\nReturns:\n    str: A string representation of the JSON Pointer, beginning with a leading '/'\n          and with special characters escaped according to JSON Pointer syntax.\n          \nThis method replaces '~' with '~0' and '/' with '~1' to ensure proper encoding\nof characters as specified in RFC 6901. The use of this method is vital for forming\nvalid JSON Pointer strings, which can then be utilized for resolving paths within\nJSON-like data structures.\n\"\"\"\n```\n\n- CLASS METHOD: RelativeJSONPointer.__eq__\n  - CLASS SIGNATURE: class RelativeJSONPointer:\n  - SIGNATURE: def __eq__(self, __value: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck for equality between two `RelativeJSONPointer` instances.\n\nArgs:\n    __value (object): The object to compare against the current instance. It can be of any type.\n\nReturns:\n    bool: `True` if `__value` is a `RelativeJSONPointer` and its string representation is equal to that of the current instance; otherwise, `False`.\n\nThe method relies on the `__str__` method of the `RelativeJSONPointer` class to obtain string representations for comparison.\n\"\"\"\n```\n\n## FILE 5: jsonpath/path.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "jsonpath/filter.py": "\"\"\"Filter expression nodes.\"\"\"\nfrom __future__ import annotations\nimport copy\nimport json\nimport re\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Pattern\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom jsonpath.function_extensions.filter_function import ExpressionType\nfrom .exceptions import JSONPathTypeError\nfrom .function_extensions import FilterFunction\nfrom .match import NodeList\nfrom .selectors import Filter as FilterSelector\nfrom .selectors import ListSelector\nif TYPE_CHECKING:\n    from .path import JSONPath\n    from .selectors import FilterContext\n\nclass FilterExpression(ABC):\n    \"\"\"Base class for all filter expression nodes.\"\"\"\n    __slots__ = ('volatile',)\n    FORCE_CACHE = False\n\n    def __init__(self) -> None:\n        self.volatile: bool = any((child.volatile for child in self.children()))\n\n    @abstractmethod\n    def evaluate(self, context: FilterContext) -> object:\n        \"\"\"Resolve the filter expression in the given _context_.\n\n        Arguments:\n            context: Contextual information the expression might choose\n                use during evaluation.\n\n        Returns:\n            The result of evaluating the expression.\n        \"\"\"\n\n    @abstractmethod\n    async def evaluate_async(self, context: FilterContext) -> object:\n        \"\"\"An async version of `evaluate`.\"\"\"\n\n    @abstractmethod\n    def children(self) -> List[FilterExpression]:\n        \"\"\"Return a list of direct child expressions.\"\"\"\n\n    @abstractmethod\n    def set_children(self, children: List[FilterExpression]) -> None:\n        \"\"\"Update this expression's child expressions.\n\n        _children_ is assumed to have the same number of items as is returned\n        by _self.children_, and in the same order.\n        \"\"\"\n\nclass Nil(FilterExpression):\n    \"\"\"The constant `nil`.\n\n    Also aliased as `null` and `None`, sometimes.\n    \"\"\"\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return other is None or isinstance(other, Nil)\n\n    def __repr__(self) -> str:\n        return 'NIL()'\n\n    def __str__(self) -> str:\n        return 'nil'\n\n    def evaluate(self, _: FilterContext) -> None:\n        return None\n\n    async def evaluate_async(self, _: FilterContext) -> None:\n        return None\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        return\nNIL = Nil()\n\nclass _Undefined:\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return other is UNDEFINED_LITERAL or other is UNDEFINED or (isinstance(other, NodeList) and other.empty())\n\n    def __str__(self) -> str:\n        return '<UNDEFINED>'\n\n    def __repr__(self) -> str:\n        return '<UNDEFINED>'\nUNDEFINED = _Undefined()\n\nclass Undefined(FilterExpression):\n    \"\"\"The constant `undefined`.\"\"\"\n    __slots__ = ()\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, Undefined) or other is UNDEFINED or (isinstance(other, NodeList) and len(other) == 0)\n\n    def __str__(self) -> str:\n        return 'undefined'\n\n    def evaluate(self, _: FilterContext) -> object:\n        return UNDEFINED\n\n    async def evaluate_async(self, _: FilterContext) -> object:\n        return UNDEFINED\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        return\nUNDEFINED_LITERAL = Undefined()\nLITERAL_EXPRESSION_T = TypeVar('LITERAL_EXPRESSION_T')\n\nclass Literal(FilterExpression, Generic[LITERAL_EXPRESSION_T]):\n    \"\"\"Base class for filter expression literals.\"\"\"\n    __slots__ = ('value',)\n\n    def __init__(self, *, value: LITERAL_EXPRESSION_T) -> None:\n        self.value = value\n        super().__init__()\n\n    def __str__(self) -> str:\n        return repr(self.value).lower()\n\n    def __eq__(self, other: object) -> bool:\n        return self.value == other\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n    def evaluate(self, _: FilterContext) -> LITERAL_EXPRESSION_T:\n        return self.value\n\n    async def evaluate_async(self, _: FilterContext) -> LITERAL_EXPRESSION_T:\n        return self.value\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        return\n\nclass BooleanLiteral(Literal[bool]):\n    \"\"\"A Boolean `True` or `False`.\"\"\"\n    __slots__ = ()\nTRUE = BooleanLiteral(value=True)\nFALSE = BooleanLiteral(value=False)\n\nclass StringLiteral(Literal[str]):\n    \"\"\"A string literal.\"\"\"\n    __slots__ = ()\n\n    def __str__(self) -> str:\n        return json.dumps(self.value)\n\nclass IntegerLiteral(Literal[int]):\n    \"\"\"An integer literal.\"\"\"\n    __slots__ = ()\n\nclass FloatLiteral(Literal[float]):\n    \"\"\"A float literal.\"\"\"\n    __slots__ = ()\n\nclass RegexLiteral(Literal[Pattern[str]]):\n    \"\"\"A regex literal.\"\"\"\n    __slots__ = ()\n    RE_FLAG_MAP = {re.A: 'a', re.I: 'i', re.M: 'm', re.S: 's'}\n    RE_UNESCAPE = re.compile('\\\\\\\\(.)')\n\n    def __str__(self) -> str:\n        flags: List[str] = []\n        for flag, ch in self.RE_FLAG_MAP.items():\n            if self.value.flags & flag:\n                flags.append(ch)\n        pattern = re.sub('\\\\\\\\(.)', '\\\\1', self.value.pattern)\n        return f'/{pattern}/{''.join(flags)}'\n\nclass ListLiteral(FilterExpression):\n    \"\"\"A list literal.\"\"\"\n    __slots__ = ('items',)\n\n    def __init__(self, items: List[FilterExpression]) -> None:\n        self.items = items\n        super().__init__()\n\n    def __str__(self) -> str:\n        items = ', '.join((str(item) for item in self.items))\n        return f'[{items}]'\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, ListLiteral) and self.items == other.items\n\n    def evaluate(self, context: FilterContext) -> object:\n        return [item.evaluate(context) for item in self.items]\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return [await item.evaluate_async(context) for item in self.items]\n\n    def children(self) -> List[FilterExpression]:\n        return self.items\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        self.items = children\n\nclass PrefixExpression(FilterExpression):\n    \"\"\"An expression composed of a prefix operator and another expression.\"\"\"\n    __slots__ = ('operator', 'right')\n\n    def __init__(self, operator: str, right: FilterExpression):\n        self.operator = operator\n        self.right = right\n        super().__init__()\n\n    def __str__(self) -> str:\n        return f'{self.operator}{self.right}'\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, PrefixExpression) and self.operator == other.operator and (self.right == other.right)\n\n    def _evaluate(self, context: FilterContext, right: object) -> object:\n        if self.operator == '!':\n            return not context.env.is_truthy(right)\n        raise JSONPathTypeError(f'unknown operator {self.operator} {self.right}')\n\n    def evaluate(self, context: FilterContext) -> object:\n        return self._evaluate(context, self.right.evaluate(context))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return self._evaluate(context, await self.right.evaluate_async(context))\n\n    def children(self) -> List[FilterExpression]:\n        return [self.right]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 1\n        self.right = children[0]\n\nclass InfixExpression(FilterExpression):\n    \"\"\"A pair of expressions and a comparison or logical operator.\"\"\"\n    __slots__ = ('left', 'operator', 'right', 'logical')\n\n    def __init__(self, left: FilterExpression, operator: str, right: FilterExpression):\n        self.left = left\n        self.operator = operator\n        self.right = right\n        self.logical = operator in ('&&', '||')\n        super().__init__()\n\n    def __str__(self) -> str:\n        if self.logical:\n            return f'({self.left} {self.operator} {self.right})'\n        return f'{self.left} {self.operator} {self.right}'\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, InfixExpression) and self.left == other.left and (self.operator == other.operator) and (self.right == other.right)\n\n    def evaluate(self, context: FilterContext) -> bool:\n        left = self.left.evaluate(context)\n        if not self.logical and isinstance(left, NodeList) and (len(left) == 1):\n            left = left[0].obj\n        right = self.right.evaluate(context)\n        if not self.logical and isinstance(right, NodeList) and (len(right) == 1):\n            right = right[0].obj\n        return context.env.compare(left, self.operator, right)\n\n    async def evaluate_async(self, context: FilterContext) -> bool:\n        left = await self.left.evaluate_async(context)\n        if not self.logical and isinstance(left, NodeList) and (len(left) == 1):\n            left = left[0].obj\n        right = await self.right.evaluate_async(context)\n        if not self.logical and isinstance(right, NodeList) and (len(right) == 1):\n            right = right[0].obj\n        return context.env.compare(left, self.operator, right)\n\n    def children(self) -> List[FilterExpression]:\n        return [self.left, self.right]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 2\n        self.left = children[0]\n        self.right = children[1]\n\nclass BooleanExpression(FilterExpression):\n    \"\"\"An expression that always evaluates to `True` or `False`.\"\"\"\n    __slots__ = ('expression',)\n\n    def __init__(self, expression: FilterExpression):\n        self.expression = expression\n        super().__init__()\n\n    def cache_tree(self) -> BooleanExpression:\n        \"\"\"Return a copy of _self.expression_ augmented with caching nodes.\"\"\"\n\n        def _cache_tree(expr: FilterExpression) -> FilterExpression:\n            children = expr.children()\n            if expr.volatile:\n                _expr = copy.copy(expr)\n            elif not expr.FORCE_CACHE and len(children) == 0:\n                _expr = expr\n            else:\n                _expr = CachingFilterExpression(copy.copy(expr))\n            _expr.set_children([_cache_tree(child) for child in children])\n            return _expr\n        return BooleanExpression(_cache_tree(copy.copy(self.expression)))\n\n    def cacheable_nodes(self) -> bool:\n        \"\"\"Return `True` if there are any cacheable nodes in this expression tree.\"\"\"\n        return any((isinstance(node, CachingFilterExpression) for node in walk(self.cache_tree())))\n\n    def __str__(self) -> str:\n        return str(self.expression)\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, BooleanExpression) and self.expression == other.expression\n\n    def evaluate(self, context: FilterContext) -> bool:\n        return context.env.is_truthy(self.expression.evaluate(context))\n\n    async def evaluate_async(self, context: FilterContext) -> bool:\n        return context.env.is_truthy(await self.expression.evaluate_async(context))\n\n    def children(self) -> List[FilterExpression]:\n        return [self.expression]\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == 1\n        self.expression = children[0]\n\nclass CachingFilterExpression(FilterExpression):\n    \"\"\"A FilterExpression wrapper that caches the result.\"\"\"\n    __slots__ = ('_cached', '_expr')\n    _UNSET = object()\n\n    def __init__(self, expression: FilterExpression):\n        self.volatile = False\n        self._expr = expression\n        self._cached: object = self._UNSET\n\n    def evaluate(self, context: FilterContext) -> object:\n        if self._cached is self._UNSET:\n            self._cached = self._expr.evaluate(context)\n        return self._cached\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        if self._cached is self._UNSET:\n            self._cached = await self._expr.evaluate_async(context)\n        return self._cached\n\n    def children(self) -> List[FilterExpression]:\n        return self._expr.children()\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        self._expr.set_children(children)\n\nclass Path(FilterExpression, ABC):\n    \"\"\"Base expression for all _sub paths_ found in filter expressions.\"\"\"\n    __slots__ = ('path',)\n\n    def __init__(self, path: JSONPath) -> None:\n        self.path = path\n        super().__init__()\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, Path) and str(self) == str(other)\n\n    def children(self) -> List[FilterExpression]:\n        _children: List[FilterExpression] = []\n        for segment in self.path.selectors:\n            if isinstance(segment, ListSelector):\n                _children.extend((selector.expression for selector in segment.items if isinstance(selector, FilterSelector)))\n        return _children\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        return\n\nclass SelfPath(Path):\n    \"\"\"A JSONPath starting at the current node.\"\"\"\n    __slots__ = ()\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = True\n\n    def __str__(self) -> str:\n        return '@' + str(self.path)[1:]\n\n    def evaluate(self, context: FilterContext) -> object:\n        if isinstance(context.current, str):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        if not isinstance(context.current, (Sequence, Mapping)):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        return NodeList(self.path.finditer(context.current))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        if isinstance(context.current, str):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        if not isinstance(context.current, (Sequence, Mapping)):\n            if self.path.empty():\n                return context.current\n            return NodeList()\n        return NodeList([match async for match in await self.path.finditer_async(context.current)])\n\nclass RootPath(Path):\n    \"\"\"A JSONPath starting at the root node.\"\"\"\n    __slots__ = ()\n    FORCE_CACHE = True\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = False\n\n    def __str__(self) -> str:\n        return str(self.path)\n\n    def evaluate(self, context: FilterContext) -> object:\n        return NodeList(self.path.finditer(context.root))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return NodeList([match async for match in await self.path.finditer_async(context.root)])\n\nclass FilterContextPath(Path):\n    \"\"\"A JSONPath starting at the root of any extra context data.\"\"\"\n    __slots__ = ()\n    FORCE_CACHE = True\n\n    def __init__(self, path: JSONPath) -> None:\n        super().__init__(path)\n        self.volatile = False\n\n    def __str__(self) -> str:\n        path_repr = str(self.path)\n        return '_' + path_repr[1:]\n\n    def evaluate(self, context: FilterContext) -> object:\n        return NodeList(self.path.finditer(context.extra_context))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return NodeList([match async for match in await self.path.finditer_async(context.extra_context)])\n\nclass FunctionExtension(FilterExpression):\n    \"\"\"A filter function.\"\"\"\n    __slots__ = ('name', 'args')\n\n    def __init__(self, name: str, args: Sequence[FilterExpression]) -> None:\n        self.name = name\n        self.args = args\n        super().__init__()\n\n    def __str__(self) -> str:\n        args = [str(arg) for arg in self.args]\n        return f'{self.name}({', '.join(args)})'\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, FunctionExtension) and other.name == self.name and (other.args == self.args)\n\n    def evaluate(self, context: FilterContext) -> object:\n        try:\n            func = context.env.function_extensions[self.name]\n        except KeyError:\n            return UNDEFINED\n        args = [arg.evaluate(context) for arg in self.args]\n        return func(*self._unpack_node_lists(func, args))\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        try:\n            func = context.env.function_extensions[self.name]\n        except KeyError:\n            return UNDEFINED\n        args = [await arg.evaluate_async(context) for arg in self.args]\n        return func(*self._unpack_node_lists(func, args))\n\n    def _unpack_node_lists(self, func: Callable[..., Any], args: List[object]) -> List[object]:\n        if isinstance(func, FilterFunction):\n            _args: List[object] = []\n            for idx, arg in enumerate(args):\n                if func.arg_types[idx] != ExpressionType.NODES and isinstance(arg, NodeList):\n                    if len(arg) == 0:\n                        _args.append(UNDEFINED)\n                    elif len(arg) == 1:\n                        _args.append(arg[0].obj)\n                    else:\n                        _args.append(arg)\n                else:\n                    _args.append(arg)\n            return _args\n        if getattr(func, 'with_node_lists', False):\n            return args\n        return [obj.values_or_singular() if isinstance(obj, NodeList) else obj for obj in args]\n\n    def children(self) -> List[FilterExpression]:\n        return list(self.args)\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        assert len(children) == len(self.args)\n        self.args = children\n\nclass CurrentKey(FilterExpression):\n    \"\"\"The key/property or index associated with the current object.\"\"\"\n    __slots__ = ()\n\n    def __init__(self) -> None:\n        super().__init__()\n        self.volatile = True\n\n    def __str__(self) -> str:\n        return '#'\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, CurrentKey)\n\n    def evaluate(self, context: FilterContext) -> object:\n        if context.current_key is None:\n            return UNDEFINED\n        return context.current_key\n\n    async def evaluate_async(self, context: FilterContext) -> object:\n        return self.evaluate(context)\n\n    def children(self) -> List[FilterExpression]:\n        return []\n\n    def set_children(self, children: List[FilterExpression]) -> None:\n        return\nCURRENT_KEY = CurrentKey()\n\ndef walk(expr: FilterExpression) -> Iterable[FilterExpression]:\n    \"\"\"Walk the filter expression tree starting at _expr_.\"\"\"\n    yield expr\n    for child in expr.children():\n        yield from walk(child)\nVALUE_TYPE_EXPRESSIONS = (Nil, Undefined, Literal, ListLiteral, CurrentKey)",
    "jsonpath/selectors.py": "\"\"\"JSONPath segments and selectors, as returned from `Parser.parse`.\"\"\"\nfrom __future__ import annotations\nfrom abc import ABC\nfrom abc import abstractmethod\nfrom collections.abc import Mapping\nfrom collections.abc import Sequence\nfrom contextlib import suppress\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import AsyncIterable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\nfrom .exceptions import JSONPathIndexError\nfrom .exceptions import JSONPathTypeError\nif TYPE_CHECKING:\n    from .env import JSONPathEnvironment\n    from .filter import BooleanExpression\n    from .match import JSONPathMatch\n    from .token import Token\n\nclass JSONPathSelector(ABC):\n    \"\"\"Base class for all JSONPath segments and selectors.\"\"\"\n    __slots__ = ('env', 'token')\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token) -> None:\n        self.env = env\n        self.token = token\n\n    @abstractmethod\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        \"\"\"Apply the segment/selector to each node in _matches_.\n\n        Arguments:\n            matches: Nodes matched by preceding segments/selectors. This is like\n                a lazy _NodeList_, as described in RFC 9535, but each match carries\n                more than the node's value and location.\n\n        Returns:\n            The `JSONPathMatch` instances created by applying this selector to each\n            preceding node.\n        \"\"\"\n\n    @abstractmethod\n    def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `resolve`.\"\"\"\n\nclass PropertySelector(JSONPathSelector):\n    \"\"\"A shorthand or bracketed property selector.\"\"\"\n    __slots__ = ('name', 'shorthand')\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, name: str, shorthand: bool) -> None:\n        super().__init__(env=env, token=token)\n        self.name = name\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return f\"['{self.name}']\" if self.shorthand else f\"'{self.name}'\"\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, PropertySelector) and self.name == __value.name and (self.token == __value.token)\n\n    def __hash__(self) -> int:\n        return hash((self.name, self.token))\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if not isinstance(match.obj, Mapping):\n                continue\n            with suppress(KeyError):\n                _match = self.env.match_class(filter_context=match.filter_context(), obj=self.env.getitem(match.obj, self.name), parent=match, parts=match.parts + (self.name,), path=match.path + f\"['{self.name}']\", root=match.root)\n                match.add_child(_match)\n                yield _match\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if not isinstance(match.obj, Mapping):\n                continue\n            with suppress(KeyError):\n                _match = self.env.match_class(filter_context=match.filter_context(), obj=await self.env.getitem_async(match.obj, self.name), parent=match, parts=match.parts + (self.name,), path=match.path + f\"['{self.name}']\", root=match.root)\n                match.add_child(_match)\n                yield _match\n\nclass IndexSelector(JSONPathSelector):\n    \"\"\"Select an element from an array by index.\n\n    Considering we don't require mapping (JSON object) keys/properties to\n    be quoted, and that we support mappings with numeric keys, we also check\n    to see if the \"index\" is a mapping key, which is non-standard.\n    \"\"\"\n    __slots__ = ('index', '_as_key')\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, index: int) -> None:\n        if index < env.min_int_index or index > env.max_int_index:\n            raise JSONPathIndexError('index out of range', token=token)\n        super().__init__(env=env, token=token)\n        self.index = index\n        self._as_key = str(self.index)\n\n    def __str__(self) -> str:\n        return str(self.index)\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, IndexSelector) and self.index == __value.index and (self.token == __value.token)\n\n    def __hash__(self) -> int:\n        return hash((self.index, self.token))\n\n    def _normalized_index(self, obj: Sequence[object]) -> int:\n        if self.index < 0 and len(obj) >= abs(self.index):\n            return len(obj) + self.index\n        return self.index\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if isinstance(match.obj, Mapping):\n                with suppress(KeyError):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=self.env.getitem(match.obj, self._as_key), parent=match, parts=match.parts + (self._as_key,), path=f\"{match.path}['{self.index}']\", root=match.root)\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence) and (not isinstance(match.obj, str)):\n                norm_index = self._normalized_index(match.obj)\n                with suppress(IndexError):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=self.env.getitem(match.obj, self.index), parent=match, parts=match.parts + (norm_index,), path=match.path + f'[{norm_index}]', root=match.root)\n                    match.add_child(_match)\n                    yield _match\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                with suppress(KeyError):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=await self.env.getitem_async(match.obj, self._as_key), parent=match, parts=match.parts + (self._as_key,), path=f\"{match.path}['{self.index}']\", root=match.root)\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence) and (not isinstance(match.obj, str)):\n                norm_index = self._normalized_index(match.obj)\n                with suppress(IndexError):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=await self.env.getitem_async(match.obj, self.index), parent=match, parts=match.parts + (norm_index,), path=match.path + f'[{norm_index}]', root=match.root)\n                    match.add_child(_match)\n                    yield _match\n\nclass KeysSelector(JSONPathSelector):\n    \"\"\"Select mapping/object keys/properties.\n\n    NOTE: This is a non-standard selector.\n    \"\"\"\n    __slots__ = ('shorthand',)\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, shorthand: bool) -> None:\n        super().__init__(env=env, token=token)\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return f'[{self.env.keys_selector_token}]' if self.shorthand else self.env.keys_selector_token\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, KeysSelector) and self.token == __value.token\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def _keys(self, match: JSONPathMatch) -> Iterable[JSONPathMatch]:\n        if isinstance(match.obj, Mapping):\n            for i, key in enumerate(match.obj.keys()):\n                _match = self.env.match_class(filter_context=match.filter_context(), obj=key, parent=match, parts=match.parts + (f'{self.env.keys_selector_token}{key}',), path=f'{match.path}[{self.env.keys_selector_token}][{i}]', root=match.root)\n                match.add_child(_match)\n                yield _match\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            yield from self._keys(match)\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            for _match in self._keys(match):\n                yield _match\n\nclass SliceSelector(JSONPathSelector):\n    \"\"\"Sequence slicing selector.\"\"\"\n    __slots__ = ('slice',)\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, start: Optional[int]=None, stop: Optional[int]=None, step: Optional[int]=None) -> None:\n        super().__init__(env=env, token=token)\n        self._check_range(start, stop, step)\n        self.slice = slice(start, stop, step)\n\n    def __str__(self) -> str:\n        stop = self.slice.stop if self.slice.stop is not None else ''\n        start = self.slice.start if self.slice.start is not None else ''\n        step = self.slice.step if self.slice.step is not None else '1'\n        return f'{start}:{stop}:{step}'\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, SliceSelector) and self.slice == __value.slice and (self.token == __value.token)\n\n    def __hash__(self) -> int:\n        return hash((str(self), self.token))\n\n    def _check_range(self, *indices: Optional[int]) -> None:\n        for i in indices:\n            if i is not None and (i < self.env.min_int_index or i > self.env.max_int_index):\n                raise JSONPathIndexError('index out of range', token=self.token)\n\n    def _normalized_index(self, obj: Sequence[object], index: int) -> int:\n        if index < 0 and len(obj) >= abs(index):\n            return len(obj) + index\n        return index\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if not isinstance(match.obj, Sequence) or self.slice.step == 0:\n                continue\n            idx = self.slice.start or 0\n            step = self.slice.step or 1\n            for obj in self.env.getitem(match.obj, self.slice):\n                norm_index = self._normalized_index(match.obj, idx)\n                _match = self.env.match_class(filter_context=match.filter_context(), obj=obj, parent=match, parts=match.parts + (norm_index,), path=f'{match.path}[{norm_index}]', root=match.root)\n                match.add_child(_match)\n                yield _match\n                idx += step\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if not isinstance(match.obj, Sequence) or self.slice.step == 0:\n                continue\n            idx = self.slice.start or 0\n            step = self.slice.step or 1\n            for obj in await self.env.getitem_async(match.obj, self.slice):\n                norm_index = self._normalized_index(match.obj, idx)\n                _match = self.env.match_class(filter_context=match.filter_context(), obj=obj, parent=match, parts=match.parts + (norm_index,), path=f'{match.path}[{norm_index}]', root=match.root)\n                match.add_child(_match)\n                yield _match\n                idx += step\n\nclass WildSelector(JSONPathSelector):\n    \"\"\"Select all items from a sequence/array or values from a mapping/object.\"\"\"\n    __slots__ = ('shorthand',)\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, shorthand: bool) -> None:\n        super().__init__(env=env, token=token)\n        self.shorthand = shorthand\n\n    def __str__(self) -> str:\n        return '[*]' if self.shorthand else '*'\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, WildSelector) and self.token == __value.token\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            if isinstance(match.obj, str):\n                continue\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (key,), path=match.path + f\"['{key}']\", root=match.root)\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence):\n                for i, val in enumerate(match.obj):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (i,), path=f'{match.path}[{i}]', root=match.root)\n                    match.add_child(_match)\n                    yield _match\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (key,), path=match.path + f\"['{key}']\", root=match.root)\n                    match.add_child(_match)\n                    yield _match\n            elif isinstance(match.obj, Sequence):\n                for i, val in enumerate(match.obj):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (i,), path=f'{match.path}[{i}]', root=match.root)\n                    match.add_child(_match)\n                    yield _match\n\nclass RecursiveDescentSelector(JSONPathSelector):\n    \"\"\"A JSONPath selector that visits all nodes recursively.\n\n    NOTE: Strictly this is a \"segment\", not a \"selector\".\n    \"\"\"\n\n    def __str__(self) -> str:\n        return '..'\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, RecursiveDescentSelector) and self.token == __value.token\n\n    def __hash__(self) -> int:\n        return hash(self.token)\n\n    def _expand(self, match: JSONPathMatch) -> Iterable[JSONPathMatch]:\n        if isinstance(match.obj, Mapping):\n            for key, val in match.obj.items():\n                if isinstance(val, str):\n                    pass\n                elif isinstance(val, (Mapping, Sequence)):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (key,), path=match.path + f\"['{key}']\", root=match.root)\n                    match.add_child(_match)\n                    yield _match\n                    yield from self._expand(_match)\n        elif isinstance(match.obj, Sequence) and (not isinstance(match.obj, str)):\n            for i, val in enumerate(match.obj):\n                if isinstance(val, str):\n                    pass\n                elif isinstance(val, (Mapping, Sequence)):\n                    _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (i,), path=f'{match.path}[{i}]', root=match.root)\n                    match.add_child(_match)\n                    yield _match\n                    yield from self._expand(_match)\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match in matches:\n            yield match\n            yield from self._expand(match)\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match in matches:\n            yield match\n            for _match in self._expand(match):\n                yield _match\nT = TypeVar('T')\n\nasync def _alist(it: List[T]) -> AsyncIterable[T]:\n    for item in it:\n        yield item\n\nclass ListSelector(JSONPathSelector):\n    \"\"\"A bracketed list of selectors, the results of which are concatenated together.\n\n    NOTE: Strictly this is a \"segment\", not a \"selector\".\n    \"\"\"\n    __slots__ = ('items',)\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, items: List[Union[SliceSelector, KeysSelector, IndexSelector, PropertySelector, WildSelector, Filter]]) -> None:\n        super().__init__(env=env, token=token)\n        self.items = tuple(items)\n\n    def __str__(self) -> str:\n        return f'[{', '.join((str(itm) for itm in self.items))}]'\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, ListSelector) and self.items == __value.items and (self.token == __value.token)\n\n    def __hash__(self) -> int:\n        return hash((self.items, self.token))\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        for match_ in matches:\n            for item in self.items:\n                yield from item.resolve([match_])\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        async for match_ in matches:\n            for item in self.items:\n                async for m in item.resolve_async(_alist([match_])):\n                    yield m\n\nclass Filter(JSONPathSelector):\n    \"\"\"Filter sequence/array items or mapping/object values with a filter expression.\"\"\"\n    __slots__ = ('expression', 'cacheable_nodes')\n\n    def __init__(self, *, env: JSONPathEnvironment, token: Token, expression: BooleanExpression) -> None:\n        super().__init__(env=env, token=token)\n        self.expression = expression\n        self.cacheable_nodes = self.expression.cacheable_nodes()\n\n    def __str__(self) -> str:\n        return f'?{self.expression}'\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, Filter) and self.expression == __value.expression and (self.token == __value.token)\n\n    def __hash__(self) -> int:\n        return hash((str(self.expression), self.token))\n\n    def resolve(self, matches: Iterable[JSONPathMatch]) -> Iterable[JSONPathMatch]:\n        if self.cacheable_nodes and self.env.filter_caching:\n            expr = self.expression.cache_tree()\n        else:\n            expr = self.expression\n        for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    context = FilterContext(env=self.env, current=val, root=match.root, extra_context=match.filter_context(), current_key=key)\n                    try:\n                        if expr.evaluate(context):\n                            _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (key,), path=match.path + f\"['{key}']\", root=match.root)\n                            match.add_child(_match)\n                            yield _match\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n            elif isinstance(match.obj, Sequence) and (not isinstance(match.obj, str)):\n                for i, obj in enumerate(match.obj):\n                    context = FilterContext(env=self.env, current=obj, root=match.root, extra_context=match.filter_context(), current_key=i)\n                    try:\n                        if expr.evaluate(context):\n                            _match = self.env.match_class(filter_context=match.filter_context(), obj=obj, parent=match, parts=match.parts + (i,), path=f'{match.path}[{i}]', root=match.root)\n                            match.add_child(_match)\n                            yield _match\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n\n    async def resolve_async(self, matches: AsyncIterable[JSONPathMatch]) -> AsyncIterable[JSONPathMatch]:\n        if self.cacheable_nodes and self.env.filter_caching:\n            expr = self.expression.cache_tree()\n        else:\n            expr = self.expression\n        async for match in matches:\n            if isinstance(match.obj, Mapping):\n                for key, val in match.obj.items():\n                    context = FilterContext(env=self.env, current=val, root=match.root, extra_context=match.filter_context(), current_key=key)\n                    try:\n                        result = await expr.evaluate_async(context)\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n                    if result:\n                        _match = self.env.match_class(filter_context=match.filter_context(), obj=val, parent=match, parts=match.parts + (key,), path=match.path + f\"['{key}']\", root=match.root)\n                        match.add_child(_match)\n                        yield _match\n            elif isinstance(match.obj, Sequence) and (not isinstance(match.obj, str)):\n                for i, obj in enumerate(match.obj):\n                    context = FilterContext(env=self.env, current=obj, root=match.root, extra_context=match.filter_context(), current_key=i)\n                    try:\n                        result = await expr.evaluate_async(context)\n                    except JSONPathTypeError as err:\n                        if not err.token:\n                            err.token = self.token\n                        raise\n                    if result:\n                        _match = self.env.match_class(filter_context=match.filter_context(), obj=obj, parent=match, parts=match.parts + (i,), path=f'{match.path}[{i}]', root=match.root)\n                        match.add_child(_match)\n                        yield _match\n\nclass FilterContext:\n    \"\"\"Contextual information and data for evaluating a filter expression.\"\"\"\n    __slots__ = ('current_key', 'current', 'env', 'extra_context', 'root')\n\n    def __init__(self, *, env: JSONPathEnvironment, current: object, root: Union[Sequence[Any], Mapping[str, Any]], extra_context: Optional[Mapping[str, Any]]=None, current_key: Union[str, int, None]=None) -> None:\n        self.env = env\n        self.current = current\n        self.root = root\n        self.extra_context = extra_context or {}\n        self.current_key = current_key\n\n    def __str__(self) -> str:\n        return f'FilterContext(current={self.current}, extra_context={self.extra_context!r})'",
    "jsonpath/match.py": "\"\"\"The JSONPath match object, as returned from `JSONPath.finditer()`.\"\"\"\nfrom __future__ import annotations\nfrom typing import Any\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nfrom .pointer import JSONPointer\nFilterContextVars = Mapping[str, Any]\nPathPart = Union[int, str]\n\nclass JSONPathMatch:\n    \"\"\"A matched object with a concrete path.\n\n    Attributes:\n        children: Matched child nodes. This will only be populated after\n            all children have been visited, usually by using `findall()`\n            or `list(finditer())`.\n        obj: The matched object.\n        parent: The immediate parent to this match in the JSON document.\n            If this is the root node, _parent_ will be `None`.\n        path: The canonical string representation of the path to this match.\n        parts: The keys, indices and/or slices that make up the path to this\n            match.\n        root: A reference to the root node in the JSON document.\n    \"\"\"\n    __slots__ = ('_filter_context', 'children', 'obj', 'parent', 'parts', 'path', 'root')\n    pointer_class = JSONPointer\n\n    def __init__(self, *, filter_context: FilterContextVars, obj: object, parent: Optional[JSONPathMatch], path: str, parts: Tuple[PathPart, ...], root: Union[Sequence[Any], Mapping[str, Any]]) -> None:\n        self._filter_context = filter_context\n        self.children: List[JSONPathMatch] = []\n        self.obj: object = obj\n        self.parent: Optional[JSONPathMatch] = parent\n        self.parts: Tuple[PathPart, ...] = parts\n        self.path: str = path\n        self.root: Union[Sequence[Any], Mapping[str, Any]] = root\n\n    def __str__(self) -> str:\n        return f'{_truncate(str(self.obj), 5)!r} @ {_truncate(self.path, 5)}'\n\n    def add_child(self, *children: JSONPathMatch) -> None:\n        \"\"\"Append one or more children to this match.\"\"\"\n        self.children.extend(children)\n\n    def filter_context(self) -> FilterContextVars:\n        \"\"\"Return filter context data for this match.\"\"\"\n        return self._filter_context\n\n    def pointer(self) -> JSONPointer:\n        \"\"\"Return a `JSONPointer` pointing to this match's path.\"\"\"\n        return JSONPointer.from_match(self)\n\n    @property\n    def value(self) -> object:\n        \"\"\"Return the value associated with this match/node.\"\"\"\n        return self.obj\n\ndef _truncate(val: str, num: int, end: str='...') -> str:\n    words = val.split()\n    if len(words) < num:\n        return ' '.join(words)\n    return ' '.join(words[:num]) + end\n\nclass NodeList(List[JSONPathMatch]):\n    \"\"\"List of JSONPathMatch objects, analogous to the spec's nodelist.\"\"\"\n\n    def values(self) -> List[object]:\n        \"\"\"Return the values from this node list.\"\"\"\n        return [match.obj for match in self]\n\n    def values_or_singular(self) -> object:\n        \"\"\"Return the values from this node list.\"\"\"\n        if len(self) == 1:\n            return self[0].obj\n        return [match.obj for match in self]\n\n    def empty(self) -> bool:\n        \"\"\"Return `True` if this node list is empty.\"\"\"\n        return not bool(self)\n\n    def __str__(self) -> str:\n        return f'NodeList{super().__str__()}'",
    "jsonpath/pointer.py": "\"\"\"JSON Pointer. See https://datatracker.ietf.org/doc/html/rfc6901.\"\"\"\nfrom __future__ import annotations\nimport codecs\nimport re\nfrom functools import reduce\nfrom operator import getitem\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nfrom urllib.parse import unquote\nfrom jsonpath._data import load_data\nfrom jsonpath.exceptions import JSONPointerError\nfrom jsonpath.exceptions import JSONPointerIndexError\nfrom jsonpath.exceptions import JSONPointerKeyError\nfrom jsonpath.exceptions import JSONPointerResolutionError\nfrom jsonpath.exceptions import JSONPointerTypeError\nfrom jsonpath.exceptions import RelativeJSONPointerIndexError\nfrom jsonpath.exceptions import RelativeJSONPointerSyntaxError\nif TYPE_CHECKING:\n    from io import IOBase\n    from .match import JSONPathMatch\n\nclass _Undefined:\n\n    def __str__(self) -> str:\n        return '<jsonpath.pointer.UNDEFINED>'\nUNDEFINED = _Undefined()\n\nclass JSONPointer:\n    \"\"\"Identify a single, specific value in JSON-like data, as per RFC 6901.\n\n    Args:\n        pointer: A string representation of a JSON Pointer.\n        parts: The keys, indices and/or slices that make up a JSON Pointer. If\n            given, it is assumed that the parts have already been parsed by the\n            JSONPath parser. `unicode_escape` and `uri_decode` are ignored if\n            _parts_ is given.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n\n    Attributes:\n        keys_selector (str): The non-standard token used to target a mapping\n            key or name.\n        max_int_index (int): The maximum integer allowed when resolving array\n            items by index. Defaults to `(2**53) - 1`.\n        min_int_index (int): The minimum integer allowed when resolving array\n            items by index. Defaults to `-(2**53) + 1`.\n    \"\"\"\n    __slots__ = ('_s', 'parts')\n    keys_selector = '~'\n    max_int_index = 2 ** 53 - 1\n    min_int_index = -2 ** 53 + 1\n\n    def __str__(self) -> str:\n        return self._s\n\n    def _index(self, s: str) -> Union[str, int]:\n        if len(s) > 1 and s.startswith('0'):\n            return s\n        try:\n            index = int(s)\n            if index < self.min_int_index or index > self.max_int_index:\n                raise JSONPointerIndexError('index out of range')\n            return index\n        except ValueError:\n            return s\n\n    def _getitem(self, obj: Any, key: Any) -> Any:\n        try:\n            return getitem(obj, key)\n        except KeyError as err:\n            if isinstance(key, int):\n                try:\n                    return getitem(obj, str(key))\n                except KeyError:\n                    raise JSONPointerKeyError(key) from err\n            if isinstance(key, str) and isinstance(obj, Mapping) and key.startswith((self.keys_selector, '#')) and (key[1:] in obj):\n                return key[1:]\n            raise JSONPointerKeyError(key) from err\n        except TypeError as err:\n            if isinstance(obj, Sequence) and (not isinstance(obj, str)):\n                if key == '-':\n                    raise JSONPointerIndexError('index out of range') from None\n                if isinstance(key, str) and key.startswith('#'):\n                    _index = int(key[1:])\n                    if _index >= len(obj):\n                        raise JSONPointerIndexError(f'index out of range: {_index}') from err\n                    return _index\n                if isinstance(key, str):\n                    index = self._index(key)\n                    if isinstance(index, int):\n                        try:\n                            return getitem(obj, int(key))\n                        except IndexError as index_err:\n                            raise JSONPointerIndexError(f'index out of range: {key}') from index_err\n            raise JSONPointerTypeError(f'{key}: {err}') from err\n        except IndexError as err:\n            raise JSONPointerIndexError(f'index out of range: {key}') from err\n\n    def resolve(self, data: Union[str, IOBase, Sequence[object], Mapping[str, object]], *, default: object=UNDEFINED) -> object:\n        \"\"\"Resolve this pointer against _data_.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n            default: A default value to return if the pointer can't be resolved\n                against the given data.\n\n        Returns:\n            The object in _data_ pointed to by this pointer.\n\n        Raises:\n            JSONPointerIndexError: When attempting to access a sequence by\n                an out of range index, unless a default is given.\n            JSONPointerKeyError: If any mapping object along the path does not\n                contain a specified key, unless a default is given.\n            JSONPointerTypeError: When attempting to resolve a non-index string\n                path part against a sequence, unless a default is given.\n        \"\"\"\n        data = load_data(data)\n        try:\n            return reduce(self._getitem, self.parts, data)\n        except JSONPointerResolutionError:\n            if default is not UNDEFINED:\n                return default\n            raise\n\n    def resolve_parent(self, data: Union[str, IOBase, Sequence[object], Mapping[str, object]]) -> Tuple[Union[Sequence[object], Mapping[str, object], None], object]:\n        \"\"\"Resolve this pointer against _data_, return the object and its parent.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n\n        Returns:\n            A `(parent, object)` tuple, where parent will be `None` if this\n                pointer points to the root node in the document. If the parent\n                exists but the last object does not, `(parent, UNDEFINED)` will\n                be returned.\n\n        Raises:\n            JSONPointerIndexError: When attempting to access a sequence by\n                an out of range index, unless using the special `-` index.\n            JSONPointerKeyError: If any mapping object along the path does not\n                contain a specified key, unless it is the last part of the\n                pointer.\n            JSONPointerTypeError: When attempting to resolve a non-index string\n                path part against a sequence.\n        \"\"\"\n        if not self.parts:\n            return (None, self.resolve(data))\n        _data = load_data(data)\n        parent = reduce(self._getitem, self.parts[:-1], _data)\n        try:\n            return (parent, self._getitem(parent, self.parts[-1]))\n        except (JSONPointerIndexError, JSONPointerKeyError):\n            return (parent, UNDEFINED)\n\n    def _unicode_escape(self, s: str) -> str:\n        return codecs.decode(s.replace('\\\\/', '/'), 'unicode-escape').encode('utf-16', 'surrogatepass').decode('utf-16')\n\n    @classmethod\n    def from_match(cls, match: JSONPathMatch) -> JSONPointer:\n        \"\"\"Return a JSON Pointer for the path from a JSONPathMatch instance.\"\"\"\n        if match.parts:\n            pointer = cls._encode(match.parts)\n        else:\n            pointer = ''\n        return cls(pointer, parts=match.parts, unicode_escape=False, uri_decode=False)\n\n    @classmethod\n    def from_parts(cls, parts: Iterable[Union[int, str]], *, unicode_escape: bool=True, uri_decode: bool=False) -> JSONPointer:\n        \"\"\"Build a JSON Pointer from _parts_.\n\n        Args:\n            parts: The keys, indices and/or slices that make up a JSONPointer.\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n                before parsing the pointer.\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\n                before being parsed.\n\n        Returns:\n            A new `JSONPointer` built from _parts_.\n        \"\"\"\n        _parts = (str(p) for p in parts)\n        if uri_decode:\n            _parts = (unquote(p) for p in _parts)\n        if unicode_escape:\n            _parts = (codecs.decode(p.replace('\\\\/', '/'), 'unicode-escape').encode('utf-16', 'surrogatepass').decode('utf-16') for p in _parts)\n        __parts = tuple(_parts)\n        if __parts:\n            pointer = cls._encode(__parts)\n        else:\n            pointer = ''\n        return cls(pointer, parts=__parts, unicode_escape=False, uri_decode=False)\n\n    def is_relative_to(self, other: JSONPointer) -> bool:\n        \"\"\"Return _True_ if this pointer points to a child of _other_.\"\"\"\n        return len(other.parts) < len(self.parts) and self.parts[:len(other.parts)] == other.parts\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, JSONPointer) and self.parts == other.parts\n\n    def __hash__(self) -> int:\n        return hash(self.parts)\n\n    def __repr__(self) -> str:\n        return f'JSONPointer({self._s!r})'\n\n    def exists(self, data: Union[str, IOBase, Sequence[object], Mapping[str, object]]) -> bool:\n        \"\"\"Return _True_ if this pointer can be resolved against _data_.\n\n        Note that `JSONPointer.resolve()` can return legitimate falsy values\n        that form part of the target JSON document. This method will return\n        `True` if a falsy value is found.\n\n        Args:\n            data: The target JSON \"document\" or equivalent Python objects.\n\n        Returns:\n            _True_ if this pointer can be resolved against _data_, or _False_\n                otherwise.\n\n        **_New in version 0.9.0_**\n        \"\"\"\n        try:\n            self.resolve(data)\n        except JSONPointerResolutionError:\n            return False\n        return True\n\n    def parent(self) -> JSONPointer:\n        \"\"\"Return this pointer's parent, as a new `JSONPointer`.\n\n        If this pointer points to the document root, _self_ is returned.\n\n        **_New in version 0.9.0_**\n        \"\"\"\n        if not self.parts:\n            return self\n        parent_parts = self.parts[:-1]\n        return JSONPointer(self._encode(parent_parts), parts=parent_parts, unicode_escape=False, uri_decode=False)\n\n    def __truediv__(self, other: object) -> JSONPointer:\n        \"\"\"Join this pointer with _other_.\n\n        _other_ is expected to be a JSON Pointer string, possibly without a\n        leading slash. If _other_ does have a leading slash, the previous\n        pointer is ignored and a new JSONPath is returned from _other_.\n\n        _other_ should not be a \"Relative JSON Pointer\".\n        \"\"\"\n        if not isinstance(other, str):\n            raise TypeError(f'unsupported operand type for /: {self.__class__.__name__!r} and {other.__class__.__name__!r}')\n        other = self._unicode_escape(other.lstrip())\n        if other.startswith('/'):\n            return JSONPointer(other, unicode_escape=False, uri_decode=False)\n        parts = self.parts + tuple((self._index(p.replace('~1', '/').replace('~0', '~')) for p in other.split('/')))\n        return JSONPointer(self._encode(parts), parts=parts, unicode_escape=False, uri_decode=False)\n\n    def join(self, *parts: str) -> JSONPointer:\n        \"\"\"Join this pointer with _parts_.\n\n        Each part is expected to be a JSON Pointer string, possibly without a\n        leading slash. If a part does have a leading slash, the previous\n        pointer is ignored and a new `JSONPointer` is created, and processing of\n        remaining parts continues.\n        \"\"\"\n        pointer = self\n        for part in parts:\n            pointer = pointer / part\n        return pointer\n\n    def to(self, rel: Union[RelativeJSONPointer, str], *, unicode_escape: bool=True, uri_decode: bool=False) -> JSONPointer:\n        \"\"\"Return a new pointer relative to this pointer.\n\n        Args:\n            rel: A `RelativeJSONPointer` or a string following \"Relative JSON\n                Pointer\" syntax.\n            unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n                before parsing the pointer.\n            uri_decode: If `True`, the pointer will be unescaped using _urllib_\n                before being parsed.\n\n        See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html\n        \"\"\"\n        relative_pointer = RelativeJSONPointer(rel, unicode_escape=unicode_escape, uri_decode=uri_decode) if isinstance(rel, str) else rel\n        return relative_pointer.to(self)\nRE_RELATIVE_POINTER = re.compile('(?P<ORIGIN>\\\\d+)(?P<INDEX_G>(?P<SIGN>[+\\\\-])(?P<INDEX>\\\\d))?(?P<POINTER>.*)', re.DOTALL)\n\nclass RelativeJSONPointer:\n    \"\"\"A Relative JSON Pointer.\n\n    See https://www.ietf.org/id/draft-hha-relative-json-pointer-00.html\n\n    Args:\n        rel: A string following Relative JSON Pointer syntax.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n    \"\"\"\n    __slots__ = ('origin', 'index', 'pointer')\n\n    def _zero_or_positive(self, s: str, rel: str) -> int:\n        if s.startswith('0') and len(s) > 1:\n            raise RelativeJSONPointerSyntaxError('unexpected leading zero', rel)\n        try:\n            return int(s)\n        except ValueError as err:\n            raise RelativeJSONPointerSyntaxError('expected positive int or zero', rel) from err\n\ndef resolve(pointer: Union[str, Iterable[Union[str, int]]], data: Union[str, IOBase, Sequence[object], Mapping[str, object]], *, default: object=UNDEFINED, unicode_escape: bool=True, uri_decode: bool=False) -> object:\n    \"\"\"Resolve JSON Pointer _pointer_ against _data_.\n\n    Args:\n        pointer: A string representation of a JSON Pointer or an iterable of\n            JSON Pointer parts.\n        data: The target JSON \"document\" or equivalent Python objects.\n        default: A default value to return if the pointer can't be resolved.\n            against the given data.\n        unicode_escape: If `True`, UTF-16 escape sequences will be decoded\n            before parsing the pointer.\n        uri_decode: If `True`, the pointer will be unescaped using _urllib_\n            before being parsed.\n\n    Returns:\n        The object in _data_ pointed to by this pointer.\n\n    Raises:\n        JSONPointerIndexError: When attempting to access a sequence by\n            an out of range index, unless a default is given.\n        JSONPointerKeyError: If any mapping object along the path does not contain\n            a specified key, unless a default is given.\n        JSONPointerTypeError: When attempting to resolve a non-index string path\n            part against a sequence, unless a default is given.\n    \"\"\"\n    if isinstance(pointer, str):\n        try:\n            return JSONPointer(pointer, unicode_escape=unicode_escape, uri_decode=uri_decode).resolve(data)\n        except JSONPointerResolutionError:\n            if default is not UNDEFINED:\n                return default\n            raise\n    try:\n        return JSONPointer.from_parts(pointer, unicode_escape=unicode_escape, uri_decode=uri_decode).resolve(data)\n    except JSONPointerResolutionError:\n        if default is not UNDEFINED:\n            return default\n        raise",
    "jsonpath/path.py": "from __future__ import annotations\nimport itertools\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import AsyncIterable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import TypeVar\nfrom typing import Union\nfrom jsonpath._data import load_data\nfrom jsonpath.fluent_api import Query\nfrom jsonpath.match import FilterContextVars\nfrom jsonpath.match import JSONPathMatch\nfrom jsonpath.selectors import IndexSelector\nfrom jsonpath.selectors import ListSelector\nfrom jsonpath.selectors import PropertySelector\nif TYPE_CHECKING:\n    from io import IOBase\n    from .env import JSONPathEnvironment\n    from .selectors import JSONPathSelector\n\nclass JSONPath:\n    \"\"\"A compiled JSONPath ready to be applied to a JSON string or Python object.\n\n    Arguments:\n        env: The `JSONPathEnvironment` this path is bound to.\n        selectors: An iterable of `JSONPathSelector` objects, as generated by\n            a `Parser`.\n        fake_root: Indicates if target JSON values should be wrapped in a single-\n            element array, so as to make the target root value selectable.\n\n\n    Attributes:\n        env: The `JSONPathEnvironment` this path is bound to.\n        selectors: The `JSONPathSelector` instances that make up this path.\n    \"\"\"\n    __slots__ = ('env', 'fake_root', 'selectors')\n\n    def __init__(self, *, env: JSONPathEnvironment, selectors: Iterable[JSONPathSelector], fake_root: bool=False) -> None:\n        self.env = env\n        self.selectors = tuple(selectors)\n        self.fake_root = fake_root\n\n    def __str__(self) -> str:\n        return self.env.root_token + ''.join((str(selector) for selector in self.selectors))\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, JSONPath) and self.selectors == __value.selectors\n\n    def __hash__(self) -> int:\n        return hash(self.selectors)\n\n    def findall(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> List[object]:\n        \"\"\"Find all objects in `data` matching the given JSONPath `path`.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A list of matched objects. If there are no matches, the list will\n            be empty.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return [match.obj for match in self.finditer(data, filter_context=filter_context)]\n\n    def finditer(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Iterable[JSONPathMatch]:\n        \"\"\"Generate `JSONPathMatch` objects for each match.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            An iterator yielding `JSONPathMatch` objects for each match.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        _data = load_data(data)\n        matches: Iterable[JSONPathMatch] = [JSONPathMatch(filter_context=filter_context or {}, obj=[_data] if self.fake_root else _data, parent=None, path=self.env.root_token, parts=(), root=_data)]\n        for selector in self.selectors:\n            matches = selector.resolve(matches)\n        return matches\n\n    async def findall_async(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> List[object]:\n        \"\"\"An async version of `findall()`.\"\"\"\n        return [match.obj async for match in await self.finditer_async(data, filter_context=filter_context)]\n\n    async def finditer_async(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `finditer()`.\"\"\"\n        _data = load_data(data)\n\n        async def root_iter() -> AsyncIterable[JSONPathMatch]:\n            yield self.env.match_class(filter_context=filter_context or {}, obj=[_data] if self.fake_root else _data, parent=None, path=self.env.root_token, parts=(), root=_data)\n        matches: AsyncIterable[JSONPathMatch] = root_iter()\n        for selector in self.selectors:\n            matches = selector.resolve_async(matches)\n        return matches\n\n    def match(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Union[JSONPathMatch, None]:\n        \"\"\"Return a `JSONPathMatch` instance for the first object found in _data_.\n\n        `None` is returned if there are no matches.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A `JSONPathMatch` object for the first match, or `None` if there were\n                no matches.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        try:\n            return next(iter(self.finditer(data, filter_context=filter_context)))\n        except StopIteration:\n            return None\n\n    def query(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Query:\n        \"\"\"Return a `Query` iterator over matches found by applying this path to _data_.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A query iterator.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return Query(self.finditer(data, filter_context=filter_context), self.env)\n\n    def empty(self) -> bool:\n        \"\"\"Return `True` if this path has no selectors.\"\"\"\n        return not bool(self.selectors)\n\n    def singular_query(self) -> bool:\n        \"\"\"Return `True` if this JSONPath query is a singular query.\"\"\"\n        for selector in self.selectors:\n            if isinstance(selector, (PropertySelector, IndexSelector)):\n                continue\n            if isinstance(selector, ListSelector) and len(selector.items) == 1 and isinstance(selector.items[0], (PropertySelector, IndexSelector)):\n                continue\n            return False\n        return True\n\nclass CompoundJSONPath:\n    \"\"\"Multiple `JSONPath`s combined.\"\"\"\n    __slots__ = ('env', 'path', 'paths')\n\n    def __init__(self, *, env: JSONPathEnvironment, path: Union[JSONPath, CompoundJSONPath], paths: Iterable[Tuple[str, JSONPath]]=()) -> None:\n        self.env = env\n        self.path = path\n        self.paths = tuple(paths)\n\n    def __str__(self) -> str:\n        buf: List[str] = [str(self.path)]\n        for op, path in self.paths:\n            buf.append(f' {op} ')\n            buf.append(str(path))\n        return ''.join(buf)\n\n    def __eq__(self, __value: object) -> bool:\n        return isinstance(__value, CompoundJSONPath) and self.path == __value.path and (self.paths == __value.paths)\n\n    def __hash__(self) -> int:\n        return hash((self.path, self.paths))\n\n    def findall(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> List[object]:\n        \"\"\"Find all objects in `data` matching the given JSONPath `path`.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A list of matched objects. If there are no matches, the list will\n                be empty.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        objs = self.path.findall(data, filter_context=filter_context)\n        for op, path in self.paths:\n            _objs = path.findall(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                objs.extend(_objs)\n            else:\n                assert op == self.env.intersection_token, op\n                objs = [obj for obj in objs if obj in _objs]\n        return objs\n\n    def finditer(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Iterable[JSONPathMatch]:\n        \"\"\"Generate `JSONPathMatch` objects for each match.\n\n        If `data` is a string or a file-like objects, it will be loaded\n        using `json.loads()` and the default `JSONDecoder`.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            An iterator yielding `JSONPathMatch` objects for each match.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        matches = self.path.finditer(data, filter_context=filter_context)\n        for op, path in self.paths:\n            _matches = path.finditer(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                matches = itertools.chain(matches, _matches)\n            else:\n                assert op == self.env.intersection_token\n                _objs = [match.obj for match in _matches]\n                matches = (match for match in matches if match.obj in _objs)\n        return matches\n\n    def match(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Union[JSONPathMatch, None]:\n        \"\"\"Return a `JSONPathMatch` instance for the first object found in _data_.\n\n        `None` is returned if there are no matches.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A `JSONPathMatch` object for the first match, or `None` if there were\n                no matches.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        try:\n            return next(iter(self.finditer(data, filter_context=filter_context)))\n        except StopIteration:\n            return None\n\n    async def findall_async(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> List[object]:\n        \"\"\"An async version of `findall()`.\"\"\"\n        objs = await self.path.findall_async(data, filter_context=filter_context)\n        for op, path in self.paths:\n            _objs = await path.findall_async(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                objs.extend(_objs)\n            else:\n                assert op == self.env.intersection_token\n                objs = [obj for obj in objs if obj in _objs]\n        return objs\n\n    async def finditer_async(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> AsyncIterable[JSONPathMatch]:\n        \"\"\"An async version of `finditer()`.\"\"\"\n        matches = await self.path.finditer_async(data, filter_context=filter_context)\n        for op, path in self.paths:\n            _matches = await path.finditer_async(data, filter_context=filter_context)\n            if op == self.env.union_token:\n                matches = _achain(matches, _matches)\n            else:\n                assert op == self.env.intersection_token\n                _objs = [match.obj async for match in _matches]\n                matches = (match async for match in matches if match.obj in _objs)\n        return matches\n\n    def query(self, data: Union[str, IOBase, Sequence[Any], Mapping[str, Any]], *, filter_context: Optional[FilterContextVars]=None) -> Query:\n        \"\"\"Return a `Query` iterator over matches found by applying this path to _data_.\n\n        Arguments:\n            data: A JSON document or Python object implementing the `Sequence`\n                or `Mapping` interfaces.\n            filter_context: Arbitrary data made available to filters using\n                the _filter context_ selector.\n\n        Returns:\n            A query iterator.\n\n        Raises:\n            JSONPathSyntaxError: If the path is invalid.\n            JSONPathTypeError: If a filter expression attempts to use types in\n                an incompatible way.\n        \"\"\"\n        return Query(self.finditer(data, filter_context=filter_context), self.env)\n\n    def union(self, path: JSONPath) -> CompoundJSONPath:\n        \"\"\"Union of this path and another path.\"\"\"\n        return self.__class__(env=self.env, path=self.path, paths=self.paths + ((self.env.union_token, path),))\n\n    def intersection(self, path: JSONPath) -> CompoundJSONPath:\n        \"\"\"Intersection of this path and another path.\"\"\"\n        return self.__class__(env=self.env, path=self.path, paths=self.paths + ((self.env.intersection_token, path),))\nT = TypeVar('T')\n\nasync def _achain(*iterables: AsyncIterable[T]) -> AsyncIterable[T]:\n    for it in iterables:\n        async for element in it:\n            yield element"
  }
}