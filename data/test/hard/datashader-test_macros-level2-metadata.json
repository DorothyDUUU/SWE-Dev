{
  "dir_path": "/app/datashader",
  "package_name": "datashader",
  "sample_name": "datashader-test_macros",
  "src_dir": "datashader/",
  "test_dir": "datashader/tests/",
  "test_file": "datashader/tests/test_macros.py",
  "test_code": "from __future__ import annotations\nimport warnings\nimport pytest\n\nfrom datashader.macros import expand_varargs\nimport inspect\nfrom numba import jit\n\n\n# Example functions to test expand_varargs on\ndef function_no_vararg(a, b):\n    return a + b\n\n\ndef function_with_vararg(a, b, *others):\n    return a + b - function_no_vararg(*others)\n\n\ndef function_with_unsupported_vararg_use(a, b, *others):\n    print(others[0])\n    function_with_vararg(a, b, *others)\n\n\n@jit(nopython=True, nogil=True)\ndef function_no_vararg_numba(a, b):\n    return a + b\n\n\ndef function_with_vararg_call_numba(a, b, *others):\n    return a + b - function_no_vararg_numba(*others)\n\n\n# Help functions\ndef get_args(fn):\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        spec = inspect.getfullargspec(fn)\n\n    args = spec.args\n    if spec.varargs:\n        args += ['*' + spec.varargs]\n\n    return args\n\n\n# Tests\ndef test_expand_varargs():\n    assert get_args(function_with_vararg) == ['a', 'b', '*others']\n    function_with_vararg_expanded = expand_varargs(2)(function_with_vararg)\n    assert get_args(function_with_vararg_expanded) == ['a', 'b', '_0', '_1']\n\n    assert (function_with_vararg(1, 2, 3, 4) ==\n            function_with_vararg_expanded(1, 2, 3, 4))\n\n\ndef test_invalid_expand_number():\n    with pytest.raises(ValueError) as e:\n        # User forgets to construct decorator with expand_number\n        expand_varargs(function_no_vararg)\n\n    assert e.match(r\"non\\-negative integer\")\n\n\ndef test_no_varargs_error():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_no_vararg)\n\n    assert e.match(r\"does not have a variable length positional argument\")\n\n\ndef test_unsupported_vararg_use():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_with_unsupported_vararg_use)\n\n    assert e.match(r\"unsupported context\")\n\n\ndef test_numba_jit_expanded_function():\n    jit_fn = jit(nopython=True, nogil=True)(\n        expand_varargs(2)(function_with_vararg_call_numba)\n    )\n    assert function_with_vararg_call_numba(1, 2, 3, 4) == jit_fn(1, 2, 3, 4)\n",
  "GT_file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()\n\n    def visit_Name(self, node):\n        self.names.add(node.id)\n\n    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)\n\n    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile(r\"^_(\\d+)$\")\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n\n        return [\"_\" + str(n) for n in\n                range(start_number, start_number + num_names)]\n\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names\n\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n    # Python 3\n    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in\n                    self.expand_names]\n        else:\n            return node\n\n\ndef function_to_ast(fn):\n    \"\"\"\n    Get the AST representation of a function\n    \"\"\"\n    # Get source code for function\n    # Dedent is needed if this is a nested function\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n\n    # Parse function source code into an AST\n    fn_ast = ast.parse(fn_source)\n\n    # # The function will be the fist element of the module body\n    # fn_ast = module_ast.body[0]\n\n    return fn_ast\n\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)\n\n\ndef compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, \"<%s>\" % fndef_ast.name, mode='exec')\n\n\ndef function_ast_to_function(fn_ast, stacklevel=1):\n    # Validate\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Compile AST to code object\n    code = compile_function_ast(fn_ast)\n\n    # Evaluate the function in a scope that includes the globals and\n    # locals of desired frame.\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n\n    # Evaluate function in scope\n    eval(code, scope)\n\n    # Return the newly evaluated function from the scope\n    return scope[fndef_ast.name]\n\n\ndef _build_arg(name):\n    return ast.arg(arg=name)\n\n\ndef expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"\n    Given a function AST that use a variable length positional argument\n    (e.g. *args), return a function that replaces the use of this argument\n    with one or more fixed arguments.\n\n    To be supported, a function must have a starred argument in the function\n    signature, and it may only use this argument in starred form as the\n    input to other functions.\n\n    For example, suppose expand_number is 3 and fn_ast is an AST\n    representing this function...\n\n    def my_fn1(a, b, *args):\n        print(a, b)\n        other_fn(a, b, *args)\n\n    Then this function will return the AST of a function equivalent to...\n\n    def my_fn1(a, b, _0, _1, _2):\n        print(a, b)\n        other_fn(a, b, _0, _1, _2)\n\n    If the input function uses `args` for anything other than passing it to\n    other functions in starred form, an error will be raised.\n\n    Parameters\n    ----------\n    fn_ast: ast.FunctionDef\n    expand_number: int\n\n    Returns\n    -------\n    ast.FunctionDef\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n\n    # Copy ast so we don't modify the input\n    fn_ast = copy.deepcopy(fn_ast)\n\n    # Extract function definition\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Get function args\n    fn_args = fndef_ast.args\n\n    # Function variable arity argument\n    fn_vararg = fn_args.vararg\n\n    # Require vararg\n    if not fn_vararg:\n        raise ValueError(\"\"\"\\\nInput function AST does not have a variable length positional argument\n(e.g. *args) in the function signature\"\"\")\n    assert fn_vararg\n\n    # Get vararg name\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n\n    # Compute new unique names to use in place of the variable argument\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n\n    # Replace use of *args in function body\n    expand_transformer = ExpandVarargTransformerStarred\n\n    new_fn_ast = expand_transformer(\n        vararg_name, expand_names\n    ).visit(fn_ast)\n\n    new_fndef_ast = new_fn_ast.body[0]\n\n    # Replace vararg with additional args in function signature\n    new_fndef_ast.args.args.extend(\n        [_build_arg(name=name) for name in expand_names]\n    )\n    new_fndef_ast.args.vararg = None\n\n    # Run a new NameVistor an see if there were any other non-starred uses\n    # of the variable length argument. If so, raise an exception\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError(\"\"\"\\\nThe variable length positional argument {n} is used in an unsupported context\n\"\"\".format(n=vararg_name))\n\n    # Remove decorators if present to avoid recursion\n    fndef_ast.decorator_list = []\n\n    # Add missing source code locations\n    ast.fix_missing_locations(new_fn_ast)\n\n    # Return result\n    return new_fn_ast\n\n\ndef expand_varargs(expand_number):\n    \"\"\"\n    Decorator to expand the variable length (starred) argument in a function\n    signature with a fixed number of arguments.\n\n    Parameters\n    ----------\n    expand_number: int\n        The number of fixed arguments that should replace the variable length\n        argument\n\n    Returns\n    -------\n    function\n        Decorator Function\n    \"\"\"\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError(\"expand_number must be a non-negative integer\")\n\n    def _expand_varargs(fn):\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs\n"
  },
  "GT_src_dict": {
    "datashader/macros.py": {
      "function_to_ast": {
        "code": "def function_to_ast(fn):\n    \"\"\"Get the Abstract Syntax Tree (AST) representation of a Python function.\n\nParameters\n----------\nfn: callable\n    The function whose AST representation is to be obtained. The function can be a user-defined function or a nested function within other functions.\n\nReturns\n-------\nast.Module\n    An AST representation of the function wrapped in a module node.\n\nDependencies\n------------\nThe function makes use of the `inspect` module to retrieve the source code of the function and the `textwrap` module to dedent it, ensuring that any nested functions are correctly formatted for AST parsing. The `ast` module is utilized to parse the dedented source code into an AST.\n\nNote\n----\nThe function returns the AST of the entire module containing the specified function, with the function as the first element of the module's body.\"\"\"\n    '\\n    Get the AST representation of a function\\n    '\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n    fn_ast = ast.parse(fn_source)\n    return fn_ast",
        "docstring": "Get the Abstract Syntax Tree (AST) representation of a Python function.\n\nParameters\n----------\nfn: callable\n    The function whose AST representation is to be obtained. The function can be a user-defined function or a nested function within other functions.\n\nReturns\n-------\nast.Module\n    An AST representation of the function wrapped in a module node.\n\nDependencies\n------------\nThe function makes use of the `inspect` module to retrieve the source code of the function and the `textwrap` module to dedent it, ensuring that any nested functions are correctly formatted for AST parsing. The `ast` module is utilized to parse the dedented source code into an AST.\n\nNote\n----\nThe function returns the AST of the entire module containing the specified function, with the function as the first element of the module's body.",
        "signature": "def function_to_ast(fn):",
        "type": "Function",
        "class_signature": null
      },
      "function_ast_to_function": {
        "code": "def function_ast_to_function(fn_ast, stacklevel=1):\n    \"\"\"Convert an AST representation of a function back into a callable Python function.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of a function, which must include a single function definition as its first element.\n\nstacklevel : int, optional\n    The level of the stack to evaluate the function in, allowing the function to access the local and global scopes of a specified stack frame. Defaults to 1 (the immediate caller).\n\nReturns\n-------\nfunction\n    The callable function defined by the provided AST.\n\nDependencies\n------------\nThis function relies on `compile_function_ast` to compile the AST into a code object, and uses the `inspect` module to access the current stack frame's local and global variables. The function cannot work if the input AST doesn't conform to the expected structure (having a valid single function definition).\"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    code = compile_function_ast(fn_ast)\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n    eval(code, scope)\n    return scope[fndef_ast.name]",
        "docstring": "Convert an AST representation of a function back into a callable Python function.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of a function, which must include a single function definition as its first element.\n\nstacklevel : int, optional\n    The level of the stack to evaluate the function in, allowing the function to access the local and global scopes of a specified stack frame. Defaults to 1 (the immediate caller).\n\nReturns\n-------\nfunction\n    The callable function defined by the provided AST.\n\nDependencies\n------------\nThis function relies on `compile_function_ast` to compile the AST into a code object, and uses the `inspect` module to access the current stack frame's local and global variables. The function cannot work if the input AST doesn't conform to the expected structure (having a valid single function definition).",
        "signature": "def function_ast_to_function(fn_ast, stacklevel=1):",
        "type": "Function",
        "class_signature": null
      },
      "expand_function_ast_varargs": {
        "code": "def expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"Given a function's Abstract Syntax Tree (AST) that uses a variable-length positional argument (e.g., *args), this function returns a modified AST that replaces the starred argument with a specified number of fixed arguments. This transformation supports functions that only pass the starred argument to other functions in starred form, ensuring no other uses of the argument exist within the function body.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of the function definition, which must include a variable-length positional argument.\nexpand_number : int\n    The number of fixed arguments that should replace the variable-length positional argument.\n\nReturns\n-------\nast.Module\n    An AST of the modified function with fixed arguments replacing the starred argument.\n\nRaises\n------\nValueError\n    If the input AST does not contain a variable-length argument or if the variable-length argument is used in an unsupported context.\n\nDependencies\n------------\nThis function utilizes the `NameVisitor` class to collect existing identifier names in the AST and the `ExpandVarargTransformerStarred` class to perform the transformation of the starred variable. It also relies on `copy.deepcopy` to prevent modifications to the original AST, ensuring that the input remains unaltered during processing.\"\"\"\n    '\\n    Given a function AST that use a variable length positional argument\\n    (e.g. *args), return a function that replaces the use of this argument\\n    with one or more fixed arguments.\\n\\n    To be supported, a function must have a starred argument in the function\\n    signature, and it may only use this argument in starred form as the\\n    input to other functions.\\n\\n    For example, suppose expand_number is 3 and fn_ast is an AST\\n    representing this function...\\n\\n    def my_fn1(a, b, *args):\\n        print(a, b)\\n        other_fn(a, b, *args)\\n\\n    Then this function will return the AST of a function equivalent to...\\n\\n    def my_fn1(a, b, _0, _1, _2):\\n        print(a, b)\\n        other_fn(a, b, _0, _1, _2)\\n\\n    If the input function uses `args` for anything other than passing it to\\n    other functions in starred form, an error will be raised.\\n\\n    Parameters\\n    ----------\\n    fn_ast: ast.FunctionDef\\n    expand_number: int\\n\\n    Returns\\n    -------\\n    ast.FunctionDef\\n    '\n    assert isinstance(fn_ast, ast.Module)\n    fn_ast = copy.deepcopy(fn_ast)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    fn_args = fndef_ast.args\n    fn_vararg = fn_args.vararg\n    if not fn_vararg:\n        raise ValueError('Input function AST does not have a variable length positional argument\\n(e.g. *args) in the function signature')\n    assert fn_vararg\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n    expand_transformer = ExpandVarargTransformerStarred\n    new_fn_ast = expand_transformer(vararg_name, expand_names).visit(fn_ast)\n    new_fndef_ast = new_fn_ast.body[0]\n    new_fndef_ast.args.args.extend([_build_arg(name=name) for name in expand_names])\n    new_fndef_ast.args.vararg = None\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError('The variable length positional argument {n} is used in an unsupported context\\n'.format(n=vararg_name))\n    fndef_ast.decorator_list = []\n    ast.fix_missing_locations(new_fn_ast)\n    return new_fn_ast",
        "docstring": "Given a function's Abstract Syntax Tree (AST) that uses a variable-length positional argument (e.g., *args), this function returns a modified AST that replaces the starred argument with a specified number of fixed arguments. This transformation supports functions that only pass the starred argument to other functions in starred form, ensuring no other uses of the argument exist within the function body.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of the function definition, which must include a variable-length positional argument.\nexpand_number : int\n    The number of fixed arguments that should replace the variable-length positional argument.\n\nReturns\n-------\nast.Module\n    An AST of the modified function with fixed arguments replacing the starred argument.\n\nRaises\n------\nValueError\n    If the input AST does not contain a variable-length argument or if the variable-length argument is used in an unsupported context.\n\nDependencies\n------------\nThis function utilizes the `NameVisitor` class to collect existing identifier names in the AST and the `ExpandVarargTransformerStarred` class to perform the transformation of the starred variable. It also relies on `copy.deepcopy` to prevent modifications to the original AST, ensuring that the input remains unaltered during processing.",
        "signature": "def expand_function_ast_varargs(fn_ast, expand_number):",
        "type": "Function",
        "class_signature": null
      },
      "expand_varargs": {
        "code": "def expand_varargs(expand_number):\n    \"\"\"Decorator for expanding a variable-length (starred) argument in a function signature into a fixed number of explicit arguments.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments (non-negative integer) that will replace the variable-length argument.\n\nReturns\n-------\nfunction\n    A decorator function that transforms the decorated function's AST, replacing the starred argument with fixed arguments.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nDependencies\n------------\nThis decorator relies on several helper functions to manipulate the function's Abstract Syntax Tree (AST):\n- `function_to_ast(fn)`: Converts a function to its AST representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Expands the variable-length argument in the AST.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a function.\n\nThe function also interacts with Python's `ast` module for AST manipulation and uses an inner function `_expand_varargs` to perform the transformation.\"\"\"\n    '\\n    Decorator to expand the variable length (starred) argument in a function\\n    signature with a fixed number of arguments.\\n\\n    Parameters\\n    ----------\\n    expand_number: int\\n        The number of fixed arguments that should replace the variable length\\n        argument\\n\\n    Returns\\n    -------\\n    function\\n        Decorator Function\\n    '\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError('expand_number must be a non-negative integer')\n\n    def _expand_varargs(fn):\n        \"\"\"Expand the variable length argument in a function's signature with a fixed number of arguments.\n\nParameters\n----------\nfn: Callable\n    The function whose variable length argument is to be expanded. It should be\n    defined with a starred argument (e.g. *args) in its signature.\n\nReturns\n-------\nCallable\n    A new function equivalent to the input function, but with the variable length\n    argument replaced by a fixed number of positional arguments.\n\nDependencies\n------------\nThis function relies on:\n- `function_to_ast`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs`: Modifies the AST to replace the starred argument with a set of fixed arguments.\n- `function_ast_to_function`: Converts the modified AST back into a callable function.\n\nThe parameter `expand_number`, defined in the enclosing `expand_varargs` function, indicates how many fixed arguments will replace the starred argument. It must be a non-negative integer.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs",
        "docstring": "Decorator for expanding a variable-length (starred) argument in a function signature into a fixed number of explicit arguments.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments (non-negative integer) that will replace the variable-length argument.\n\nReturns\n-------\nfunction\n    A decorator function that transforms the decorated function's AST, replacing the starred argument with fixed arguments.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nDependencies\n------------\nThis decorator relies on several helper functions to manipulate the function's Abstract Syntax Tree (AST):\n- `function_to_ast(fn)`: Converts a function to its AST representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Expands the variable-length argument in the AST.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a function.\n\nThe function also interacts with Python's `ast` module for AST manipulation and uses an inner function `_expand_varargs` to perform the transformation.",
        "signature": "def expand_varargs(expand_number):",
        "type": "Function",
        "class_signature": null
      },
      "_expand_varargs": {
        "code": "    def _expand_varargs(fn):\n        \"\"\"Expand the variable length argument in a function's signature with a fixed number of arguments.\n\nParameters\n----------\nfn: Callable\n    The function whose variable length argument is to be expanded. It should be\n    defined with a starred argument (e.g. *args) in its signature.\n\nReturns\n-------\nCallable\n    A new function equivalent to the input function, but with the variable length\n    argument replaced by a fixed number of positional arguments.\n\nDependencies\n------------\nThis function relies on:\n- `function_to_ast`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs`: Modifies the AST to replace the starred argument with a set of fixed arguments.\n- `function_ast_to_function`: Converts the modified AST back into a callable function.\n\nThe parameter `expand_number`, defined in the enclosing `expand_varargs` function, indicates how many fixed arguments will replace the starred argument. It must be a non-negative integer.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)",
        "docstring": "Expand the variable length argument in a function's signature with a fixed number of arguments.\n\nParameters\n----------\nfn: Callable\n    The function whose variable length argument is to be expanded. It should be\n    defined with a starred argument (e.g. *args) in its signature.\n\nReturns\n-------\nCallable\n    A new function equivalent to the input function, but with the variable length\n    argument replaced by a fixed number of positional arguments.\n\nDependencies\n------------\nThis function relies on:\n- `function_to_ast`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs`: Modifies the AST to replace the starred argument with a set of fixed arguments.\n- `function_ast_to_function`: Converts the modified AST back into a callable function.\n\nThe parameter `expand_number`, defined in the enclosing `expand_varargs` function, indicates how many fixed arguments will replace the starred argument. It must be a non-negative integer.",
        "signature": "def _expand_varargs(fn):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "datashader/macros.py:_expand_varargs": {},
    "datashader/macros.py:function_to_ast": {},
    "datashader/macros.py:expand_function_ast_varargs": {
      "datashader/macros.py": {
        "NameVisitor.__init__": {
          "code": "    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()",
          "docstring": "",
          "signature": "def __init__(self, *args, **kwargs):",
          "type": "Method",
          "class_signature": "class NameVisitor(ast.NodeVisitor):"
        },
        "NameVisitor.visit_Name": {
          "code": "    def visit_Name(self, node):\n        self.names.add(node.id)",
          "docstring": "",
          "signature": "def visit_Name(self, node):",
          "type": "Method",
          "class_signature": "class NameVisitor(ast.NodeVisitor):"
        },
        "NameVisitor.visit_arg": {
          "code": "    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)",
          "docstring": "",
          "signature": "def visit_arg(self, node):",
          "type": "Method",
          "class_signature": "class NameVisitor(ast.NodeVisitor):"
        },
        "NameVisitor.get_new_names": {
          "code": "    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile('^_(\\\\d+)$')\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n        return ['_' + str(n) for n in range(start_number, start_number + num_names)]",
          "docstring": "Returns a list of new names that are not already present in the AST.\n\nNew names will have the form _N, for N a non-negative integer. If the\nAST has no existing identifiers of this form, then the returned names\nwill start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\nof this form, then the names returned will not include the existing\nidentifiers.\n\nParameters\n----------\nnum_names: int\n    The number of new names to return\n\nReturns\n-------\nlist of str",
          "signature": "def get_new_names(self, num_names):",
          "type": "Method",
          "class_signature": "class NameVisitor(ast.NodeVisitor):"
        },
        "ExpandVarargTransformer.__init__": {
          "code": "    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names",
          "docstring": "Parameters\n----------\nstarred_name: str\n    The name of the starred variable to replace\nexpand_names: list of stf\n    List of the new names that should be used to replace the starred\n    variable",
          "signature": "def __init__(self, starred_name, expand_names, *args, **kwargs):",
          "type": "Method",
          "class_signature": "class ExpandVarargTransformer(ast.NodeTransformer):"
        },
        "ExpandVarargTransformerStarred.visit_Starred": {
          "code": "    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in self.expand_names]\n        else:\n            return node",
          "docstring": "",
          "signature": "def visit_Starred(self, node):",
          "type": "Method",
          "class_signature": "class ExpandVarargTransformerStarred(ExpandVarargTransformer):"
        },
        "_build_arg": {
          "code": "def _build_arg(name):\n    return ast.arg(arg=name)",
          "docstring": "",
          "signature": "def _build_arg(name):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "datashader/macros.py:function_ast_to_function": {
      "datashader/macros.py": {
        "compile_function_ast": {
          "code": "def compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, '<%s>' % fndef_ast.name, mode='exec')",
          "docstring": "Compile function AST into a code object suitable for use in eval/exec",
          "signature": "def compile_function_ast(fn_ast):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "datashader/tests/test_macros.py:test_expand_varargs": {
      "datashader/tests/test_macros.py:get_args": {},
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg": {
        "datashader/tests/test_macros.py:function_no_vararg": {}
      },
      "datashader/tests/test_macros.py:function_no_vararg": {}
    },
    "datashader/tests/test_macros.py:test_invalid_expand_number": {
      "datashader/macros.py:expand_varargs": {}
    },
    "datashader/tests/test_macros.py:test_no_varargs_error": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {}
      }
    },
    "datashader/tests/test_macros.py:test_unsupported_vararg_use": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        }
      }
    },
    "datashader/tests/test_macros.py:test_numba_jit_expanded_function": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg_call_numba": {}
    }
  },
  "PRD": "# PROJECT NAME: datashader-test_macros\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 datashader/\n    \u2514\u2500\u2500 macros.py\n        \u251c\u2500\u2500 _expand_varargs\n        \u251c\u2500\u2500 expand_function_ast_varargs\n        \u251c\u2500\u2500 expand_varargs\n        \u251c\u2500\u2500 function_ast_to_function\n        \u2514\u2500\u2500 function_to_ast\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates dynamic function argument manipulation by providing functionality to expand variable-length positional arguments (`*args`) into explicitly defined, fixed positional arguments. It enables developers to transform functions with flexible inputs into forms that streamline compatibility with tools or frameworks that require fixed argument signatures, such as JIT (Just-In-Time) compilation via Numba. This capability simplifies handling of ambiguous or complex `*args` usage patterns while ensuring robust error handling for unsupported cases, improving code clarity, reusability, and integration with performance-critical contexts. By addressing these challenges, the module helps developers write more predictable and optimized code for scenarios requiring explicit argument specification.\n\n## FILE 1: datashader/macros.py\n\n- FUNCTION NAME: function_to_ast\n  - SIGNATURE: def function_to_ast(fn):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the Abstract Syntax Tree (AST) representation of a Python function.\n\nParameters\n----------\nfn: callable\n    The function whose AST representation is to be obtained. The function can be a user-defined function or a nested function within other functions.\n\nReturns\n-------\nast.Module\n    An AST representation of the function wrapped in a module node.\n\nDependencies\n------------\nThe function makes use of the `inspect` module to retrieve the source code of the function and the `textwrap` module to dedent it, ensuring that any nested functions are correctly formatted for AST parsing. The `ast` module is utilized to parse the dedented source code into an AST.\n\nNote\n----\nThe function returns the AST of the entire module containing the specified function, with the function as the first element of the module's body.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:_expand_varargs\n\n- FUNCTION NAME: expand_function_ast_varargs\n  - SIGNATURE: def expand_function_ast_varargs(fn_ast, expand_number):\n  - DOCSTRING: \n```python\n\"\"\"\nGiven a function's Abstract Syntax Tree (AST) that uses a variable-length positional argument (e.g., *args), this function returns a modified AST that replaces the starred argument with a specified number of fixed arguments. This transformation supports functions that only pass the starred argument to other functions in starred form, ensuring no other uses of the argument exist within the function body.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of the function definition, which must include a variable-length positional argument.\nexpand_number : int\n    The number of fixed arguments that should replace the variable-length positional argument.\n\nReturns\n-------\nast.Module\n    An AST of the modified function with fixed arguments replacing the starred argument.\n\nRaises\n------\nValueError\n    If the input AST does not contain a variable-length argument or if the variable-length argument is used in an unsupported context.\n\nDependencies\n------------\nThis function utilizes the `NameVisitor` class to collect existing identifier names in the AST and the `ExpandVarargTransformerStarred` class to perform the transformation of the starred variable. It also relies on `copy.deepcopy` to prevent modifications to the original AST, ensuring that the input remains unaltered during processing.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:_expand_varargs\n    - datashader/macros.py:NameVisitor:get_new_names\n    - datashader/macros.py:NameVisitor:__init__\n    - datashader/macros.py:NameVisitor:visit_Name\n    - datashader/macros.py:NameVisitor:visit_arg\n    - datashader/macros.py:ExpandVarargTransformer:__init__\n    - datashader/macros.py:_build_arg\n    - datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred\n\n- FUNCTION NAME: _expand_varargs\n  - SIGNATURE: def _expand_varargs(fn):\n  - DOCSTRING: \n```python\n\"\"\"\nExpand the variable length argument in a function's signature with a fixed number of arguments.\n\nParameters\n----------\nfn: Callable\n    The function whose variable length argument is to be expanded. It should be\n    defined with a starred argument (e.g. *args) in its signature.\n\nReturns\n-------\nCallable\n    A new function equivalent to the input function, but with the variable length\n    argument replaced by a fixed number of positional arguments.\n\nDependencies\n------------\nThis function relies on:\n- `function_to_ast`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs`: Modifies the AST to replace the starred argument with a set of fixed arguments.\n- `function_ast_to_function`: Converts the modified AST back into a callable function.\n\nThe parameter `expand_number`, defined in the enclosing `expand_varargs` function, indicates how many fixed arguments will replace the starred argument. It must be a non-negative integer.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:function_ast_to_function\n    - datashader/macros.py:expand_function_ast_varargs\n    - datashader/macros.py:function_to_ast\n\n- FUNCTION NAME: function_ast_to_function\n  - SIGNATURE: def function_ast_to_function(fn_ast, stacklevel=1):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an AST representation of a function back into a callable Python function.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST of a function, which must include a single function definition as its first element.\n\nstacklevel : int, optional\n    The level of the stack to evaluate the function in, allowing the function to access the local and global scopes of a specified stack frame. Defaults to 1 (the immediate caller).\n\nReturns\n-------\nfunction\n    The callable function defined by the provided AST.\n\nDependencies\n------------\nThis function relies on `compile_function_ast` to compile the AST into a code object, and uses the `inspect` module to access the current stack frame's local and global variables. The function cannot work if the input AST doesn't conform to the expected structure (having a valid single function definition).\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:compile_function_ast\n    - datashader/macros.py:_expand_varargs\n\n- FUNCTION NAME: expand_varargs\n  - SIGNATURE: def expand_varargs(expand_number):\n  - DOCSTRING: \n```python\n\"\"\"\nDecorator for expanding a variable-length (starred) argument in a function signature into a fixed number of explicit arguments.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments (non-negative integer) that will replace the variable-length argument.\n\nReturns\n-------\nfunction\n    A decorator function that transforms the decorated function's AST, replacing the starred argument with fixed arguments.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nDependencies\n------------\nThis decorator relies on several helper functions to manipulate the function's Abstract Syntax Tree (AST):\n- `function_to_ast(fn)`: Converts a function to its AST representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Expands the variable-length argument in the AST.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a function.\n\nThe function also interacts with Python's `ast` module for AST manipulation and uses an inner function `_expand_varargs` to perform the transformation.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()\n\n    def visit_Name(self, node):\n        self.names.add(node.id)\n\n    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)\n\n    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile('^_(\\\\d+)$')\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n        return ['_' + str(n) for n in range(start_number, start_number + num_names)]\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n\n    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n\n    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in self.expand_names]\n        else:\n            return node\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)\n\ndef compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, '<%s>' % fndef_ast.name, mode='exec')\n\ndef _build_arg(name):\n    return ast.arg(arg=name)"
  }
}