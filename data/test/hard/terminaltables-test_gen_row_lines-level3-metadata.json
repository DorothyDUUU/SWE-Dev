{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_gen_row_lines",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_base_table/test_gen_row_lines.py",
  "test_code": "\"\"\"Test method in BaseTable class.\"\"\"\n\nimport pytest\n\nfrom terminaltables3.base_table import BaseTable\n\n\n@pytest.mark.parametrize(\"style\", [\"heading\", \"footing\", \"row\"])\ndef test_single_line(style):\n    \"\"\"Test with single-line row.\n\n    :param str style: Passed to method.\n    \"\"\"\n    row = [\"Row One Column One\", \"Two\", \"Three\"]\n    table = BaseTable([row])\n    actual = [tuple(i) for i in table.gen_row_lines(row, style, [18, 3, 5], 1)]\n    expected = [\n        (\"|\", \" Row One Column One \", \"|\", \" Two \", \"|\", \" Three \", \"|\"),\n    ]\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"style\", [\"heading\", \"footing\", \"row\"])\ndef test_multi_line(style):\n    \"\"\"Test with multi-line row.\n\n    :param str style: Passed to method.\n    \"\"\"\n    row = [\"Row One\\nColumn One\", \"Two\", \"Three\"]\n    table = BaseTable([row])\n    actual = [tuple(i) for i in table.gen_row_lines(row, style, [10, 3, 5], 2)]\n    expected = [\n        (\"|\", \" Row One    \", \"|\", \" Two \", \"|\", \" Three \", \"|\"),\n        (\"|\", \" Column One \", \"|\", \"     \", \"|\", \"       \", \"|\"),\n    ]\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"style\", [\"heading\", \"footing\", \"row\"])\ndef test_no_padding_no_borders(style):\n    \"\"\"Test without padding or borders.\n\n    :param str style: Passed to method.\n    \"\"\"\n    row = [\"Row One\\nColumn One\", \"Two\", \"Three\"]\n    table = BaseTable([row])\n    table.inner_column_border = False\n    table.outer_border = False\n    table.padding_left = 0\n    table.padding_right = 0\n    actual = [tuple(i) for i in table.gen_row_lines(row, style, [10, 3, 5], 2)]\n    expected = [\n        (\"Row One   \", \"Two\", \"Three\"),\n        (\"Column One\", \"   \", \"     \"),\n    ]\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"style\", [\"heading\", \"footing\", \"row\"])\ndef test_uneven(style):\n    \"\"\"Test with row missing cells.\n\n    :param str style: Passed to method.\n    \"\"\"\n    row = [\"Row One Column One\"]\n    table = BaseTable([row])\n    actual = [tuple(i) for i in table.gen_row_lines(row, style, [18, 3, 5], 1)]\n    expected = [\n        (\"|\", \" Row One Column One \", \"|\", \"     \", \"|\", \"       \", \"|\"),\n    ]\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"style\", [\"heading\", \"footing\", \"row\"])\ndef test_empty_table(style):\n    \"\"\"Test empty table.\n\n    :param str style: Passed to method.\n    \"\"\"\n    row = []\n    table = BaseTable([row])\n    actual = [tuple(i) for i in table.gen_row_lines(row, style, [], 0)]\n    expected = [\n        (\"|\", \"|\"),\n    ]\n    assert actual == expected\n",
  "GT_file_code": {
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\n\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\n\nfrom terminaltables3.terminal_io import terminal_size\n\nRE_COLOR_ANSI = re.compile(r\"(\\033\\[[\\d;]+m)\")\n\n\ndef visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string.\n\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\n\n    From: https://github.com/Robpol86/terminaltables3/pull/9\n\n    :param str string: String to measure.\n\n    :return: String's width.\n    :rtype: int\n    \"\"\"\n    if \"\\033\" in string:\n        string = RE_COLOR_ANSI.sub(\"\", string)\n\n    # Convert to unicode.\n    try:\n        string = string.decode(\"u8\")\n    except (AttributeError, UnicodeEncodeError):\n        pass\n\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in (\"F\", \"W\"):\n            width += 2\n        else:\n            width += 1\n\n    return width\n\n\ndef align_and_pad_cell(\n    string: str,\n    align: Tuple,\n    inner_dimensions: Tuple,\n    padding: Sequence[int],\n    space: str = \" \",\n) -> List[str]:\n    \"\"\"Align a string horizontally and vertically. Also add additional padding in both dimensions.\n\n    :param str string: Input string to operate on.\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\n\n    :return: Padded cell split into lines.\n    :rtype: list\n    \"\"\"\n    if not hasattr(string, \"splitlines\"):\n        string = str(string)\n\n    # Handle trailing newlines or empty strings, str.splitlines() does not satisfy.\n    lines = string.splitlines() or [\"\"]\n    if string.endswith(\"\\n\"):\n        lines.append(\"\")\n\n    # Vertically align and pad.\n    if \"bottom\" in align:\n        lines = (\n            ([\"\"] * (inner_dimensions[1] - len(lines) + padding[2]))\n            + lines\n            + ([\"\"] * padding[3])\n        )\n    elif \"middle\" in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = (\n            ([\"\"] * (delta // 2 + delta % 2 + padding[2]))\n            + lines\n            + ([\"\"] * (delta // 2 + padding[3]))\n        )\n    else:\n        lines = (\n            ([\"\"] * padding[2])\n            + lines\n            + ([\"\"] * (inner_dimensions[1] - len(lines) + padding[3]))\n        )\n\n    # Horizontally align and pad.\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if \"right\" in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + (space * padding[1])\n        elif \"center\" in align:\n            lines[i] = (\n                (space * padding[0])\n                + line.center(new_width, space)\n                + (space * padding[1])\n            )\n        else:\n            lines[i] = (space * padding[0]) + line.ljust(new_width + padding[1], space)\n\n    return lines\n\n\ndef max_dimensions(\n    table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0\n):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max(len(r) for r in table_data) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n\n    # Find max width and heights.\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, \"count\") or not hasattr(cell, \"splitlines\"):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count(\"\\n\") + 1)\n            inner_widths[i] = max(\n                inner_widths[i],\n                *[visible_width(the_line) for the_line in cell.splitlines()],\n            )\n\n    # Calculate with padding.\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n\n    return inner_widths, inner_heights, outer_widths, outer_heights\n\n\ndef column_max_width(\n    inner_widths: Sequence[int],\n    column_number: int,\n    outer_border: int,\n    inner_border: int,\n    padding: int,\n) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n\n    # Count how much space padding, outer, and inner borders take up.\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n\n    # Exclude selected column's width.\n    data_space = sum(inner_widths) - inner_widths[column_number]\n\n    return terminal_width - data_space - non_data_space\n\n\ndef table_width(\n    outer_widths: Sequence[int], outer_border: int, inner_border: int\n) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n\n    # Count how much space outer and inner borders take up.\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n\n    # Space of all columns and their padding.\n    data_space = sum(outer_widths)\n    return data_space + non_data_space\n",
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\n\nfrom typing import Generator, Iterator, Optional, Sequence, Union\n\nfrom terminaltables3.width_and_alignment import visible_width\n\n\ndef combine(\n    line: Union[\n        Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]\n    ],\n    left: str,\n    intersect: Optional[str],\n    right: str,\n) -> Generator[int, None, None]:\n    \"\"\"Zip borders between items in `line`.\n\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\n\n    :param iter line: List to iterate.\n    :param left: Left border.\n    :param intersect: Column separator.\n    :param right: Right border.\n\n    :return: Yields combined objects.\n    \"\"\"\n    # Yield left border.\n    if left:\n        yield left\n\n    # Yield items with intersect characters.\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:  # Generator.\n            try:\n                item = next(line)\n            except StopIteration:  # Was empty all along.\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n\n        # Yield right border.\n    if right:\n        yield right\n\n\ndef build_border(\n    outer_widths: Sequence[int],\n    horizontal: str,\n    left: str,\n    intersect: str,\n    right: str,\n    title: Optional[str] = None,\n):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n\n    # Hide title if it doesn't fit.\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n\n    # Handle no title.\n    if title is None or not outer_widths or not horizontal:\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n\n    # Handle title fitting in the first column.\n    if length == outer_widths[0]:\n        return combine(\n            [title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right\n        )\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [\n            horizontal * c for c in outer_widths[1:]\n        ]\n        return combine(columns, left, intersect, right)\n\n    # Handle wide titles/narrow columns.\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        # If title is taken care of.\n        if length < 1:\n            columns_and_intersects.append(\n                intersect if width is True else horizontal * width\n            )\n        # If title's last character overrides an intersect character.\n        elif width is True and length == 1:\n            length = 0\n        # If this is an intersect character that is overridden by the title.\n        elif width is True:\n            length -= 1\n        # If title's last character is within a column.\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (\n                width - length\n            )  # Append horizontal chars to title.\n            length = 0\n        # If remainder of title won't fit in a column.\n        else:\n            length -= width\n\n    return combine(columns_and_intersects, left, None, right)\n\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)\n",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\n\nfrom typing import Generator, Optional, Sequence, Tuple\n\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"-\"\n    CHAR_F_INNER_INTERSECT = \"+\"\n    CHAR_F_INNER_VERTICAL = \"|\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_H_INNER_HORIZONTAL = \"-\"\n    CHAR_H_INNER_INTERSECT = \"+\"\n    CHAR_H_INNER_VERTICAL = \"|\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_INNER_HORIZONTAL = \"-\"\n    CHAR_INNER_INTERSECT = \"+\"\n    CHAR_INNER_VERTICAL = \"|\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"-\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"+\"\n    CHAR_OUTER_BOTTOM_LEFT = \"+\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"+\"\n    CHAR_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"-\"\n    CHAR_OUTER_TOP_INTERSECT = \"+\"\n    CHAR_OUTER_TOP_LEFT = \"+\"\n    CHAR_OUTER_TOP_RIGHT = \"+\"\n\n    def __init__(\n        self, table_data: Sequence[Sequence[str]], title: Optional[str] = None\n    ):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n\n        self.justify_columns = {}  # {0: 'right', 1: 'left', 2: 'center'}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(\n        self, style: str, outer_widths: Sequence[int]\n    ) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == \"top\":\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = (\n                self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == \"bottom\":\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = (\n                self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == \"heading\":\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        elif style == \"footing\":\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(\n        self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int\n    ) -> Generator[Tuple[str, ...], None, None]:\n        r\"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n\n        # Resize row if it doesn't have enough cells.\n        if len(row) != len(inner_widths):\n            row = row + [\"\"] * (len(inner_widths) - len(row))\n\n        # Pad and align each cell. Split each cell into lines to support multi-line cells.\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(\n                align_and_pad_cell(cell, align, inner_dimensions, padding)\n            )\n\n        # Determine border characters.\n        if style == \"heading\":\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        elif style == \"footing\":\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n\n        # Yield each line.\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(\n        self,\n        inner_widths: Sequence[int],\n        inner_heights: Sequence[int],\n        outer_widths: Sequence[int],\n    ) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        # Yield top border.\n        if self.outer_border:\n            yield self.horizontal_border(\"top\", outer_widths)\n\n        # Yield table body.\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = row_count - 1, row_count - 2\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            if self.inner_heading_row_border and i == 0:\n                style = \"heading\"\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = \"footing\"\n            else:\n                style = \"row\"\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            # If this is the last row then break. No separator needed.\n            if i == last_row_index:\n                break\n            # Yield heading separator.\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border(\"heading\", outer_widths)\n            # Yield footing separator.\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border(\"footing\", outer_widths)\n            # Yield row separator.\n            elif self.inner_row_border:\n                yield self.horizontal_border(\"row\", outer_widths)\n\n        # Yield bottom border.\n        if self.outer_border:\n            yield self.horizontal_border(\"bottom\", outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(\n            self.table_data, self.padding_left, self.padding_right\n        )[:3]\n        return flatten(self.gen_table(*dimensions))\n"
  },
  "GT_src_dict": {
    "terminaltables3/width_and_alignment.py": {
      "visible_width": {
        "code": "def visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string, accounting for multi-byte characters such as CJK (Chinese, Japanese, Korean) characters which may take up more space than ASCII characters.\n\n:param str string: The input string whose visible width is to be measured. The function handles ANSI color codes by stripping them out, utilizing the regular expression defined by the constant RE_COLOR_ANSI.\n:rtype: int: Returns the width of the string as an integer, where CJK characters contribute a width of 2, and all other characters contribute a width of 1.\n\nThis function depends on the `unicodedata` module to determine the width of characters based on their east Asian width classification.\"\"\"\n    \"Get the visible width of a unicode string.\\n\\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\\n\\n    From: https://github.com/Robpol86/terminaltables3/pull/9\\n\\n    :param str string: String to measure.\\n\\n    :return: String's width.\\n    :rtype: int\\n    \"\n    if '\\x1b' in string:\n        string = RE_COLOR_ANSI.sub('', string)\n    try:\n        string = string.decode('u8')\n    except (AttributeError, UnicodeEncodeError):\n        pass\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in ('F', 'W'):\n            width += 2\n        else:\n            width += 1\n    return width",
        "docstring": "Get the visible width of a unicode string, accounting for multi-byte characters such as CJK (Chinese, Japanese, Korean) characters which may take up more space than ASCII characters.\n\n:param str string: The input string whose visible width is to be measured. The function handles ANSI color codes by stripping them out, utilizing the regular expression defined by the constant RE_COLOR_ANSI.\n:rtype: int: Returns the width of the string as an integer, where CJK characters contribute a width of 2, and all other characters contribute a width of 1.\n\nThis function depends on the `unicodedata` module to determine the width of characters based on their east Asian width classification.",
        "signature": "def visible_width(string: str) -> int:",
        "type": "Function",
        "class_signature": null
      },
      "align_and_pad_cell": {
        "code": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n    \"\"\"Align and pad a string within specified dimensions, supporting both horizontal and vertical alignment, along with additional padding.\n\n:param str string: The input string to align and pad. If the string contains ANSI color codes, they will be ignored for width calculations.\n:param tuple align: A tuple specifying horizontal ('left', 'center', 'right') and vertical ('top', 'middle', 'bottom') alignment options.\n:param tuple inner_dimensions: A tuple consisting of the target width and height (integers) for the cell without padding.\n:param iter padding: A sequence of four integers representing left, right, top, and bottom padding spaces.\n:param str space: The character used for padding; defaults to a single space.\n\n:return: A list of strings representing the padded and aligned cell, with each string corresponding to a line in the cell.\n:rtype: list\n\nThis function interacts with the `visible_width` function to determine the effective width of the text, accounting for diverse character widths, especially CJK decimals. The expected output is influenced by the alignment parameters and padding settings, ensuring the cell content is properly centered or justified based on input criteria.\"\"\"\n    'Align a string horizontally and vertically. Also add additional padding in both dimensions.\\n\\n    :param str string: Input string to operate on.\\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\\n\\n    :return: Padded cell split into lines.\\n    :rtype: list\\n    '\n    if not hasattr(string, 'splitlines'):\n        string = str(string)\n    lines = string.splitlines() or ['']\n    if string.endswith('\\n'):\n        lines.append('')\n    if 'bottom' in align:\n        lines = [''] * (inner_dimensions[1] - len(lines) + padding[2]) + lines + [''] * padding[3]\n    elif 'middle' in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = [''] * (delta // 2 + delta % 2 + padding[2]) + lines + [''] * (delta // 2 + padding[3])\n    else:\n        lines = [''] * padding[2] + lines + [''] * (inner_dimensions[1] - len(lines) + padding[3])\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if 'right' in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + space * padding[1]\n        elif 'center' in align:\n            lines[i] = space * padding[0] + line.center(new_width, space) + space * padding[1]\n        else:\n            lines[i] = space * padding[0] + line.ljust(new_width + padding[1], space)\n    return lines",
        "docstring": "Align and pad a string within specified dimensions, supporting both horizontal and vertical alignment, along with additional padding.\n\n:param str string: The input string to align and pad. If the string contains ANSI color codes, they will be ignored for width calculations.\n:param tuple align: A tuple specifying horizontal ('left', 'center', 'right') and vertical ('top', 'middle', 'bottom') alignment options.\n:param tuple inner_dimensions: A tuple consisting of the target width and height (integers) for the cell without padding.\n:param iter padding: A sequence of four integers representing left, right, top, and bottom padding spaces.\n:param str space: The character used for padding; defaults to a single space.\n\n:return: A list of strings representing the padded and aligned cell, with each string corresponding to a line in the cell.\n:rtype: list\n\nThis function interacts with the `visible_width` function to determine the effective width of the text, accounting for diverse character widths, especially CJK decimals. The expected output is influenced by the alignment parameters and padding settings, ensuring the cell content is properly centered or justified based on input criteria.",
        "signature": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/build.py": {
      "combine": {
        "code": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n    \"\"\"Combine elements of the `line` into a single structure, surrounded by specified border characters.\n\nThis function accepts an iterable `line`, which can either be a generator or an iterator of items (strings or integers). It allows for a left border and a right border to be added around the items. If an `intersect` character is provided, it will be inserted between each of the items in the line. The behavior adapts based on whether the input is a generator (which may not be of fixed length) or a list-like iterator.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable collection of items to combine.\n- left (str): A string representing the left border.\n- intersect (Optional[str]): A string used as a separator between items.\n- right (str): A string representing the right border.\n\nReturns:\n- Generator[int, None, None]: A generator that yields the combined elements, including the borders and separators.\n\nThe function is important for constructing formatted table rows within the larger code context, particularly in conjunction with `build_row` and `build_border`, which rely on the structured output of `combine` to format tables correctly.\"\"\"\n    \"Zip borders between items in `line`.\\n\\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\\n\\n    :param iter line: List to iterate.\\n    :param left: Left border.\\n    :param intersect: Column separator.\\n    :param right: Right border.\\n\\n    :return: Yields combined objects.\\n    \"\n    if left:\n        yield left\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:\n            try:\n                item = next(line)\n            except StopIteration:\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n    if right:\n        yield right",
        "docstring": "Combine elements of the `line` into a single structure, surrounded by specified border characters.\n\nThis function accepts an iterable `line`, which can either be a generator or an iterator of items (strings or integers). It allows for a left border and a right border to be added around the items. If an `intersect` character is provided, it will be inserted between each of the items in the line. The behavior adapts based on whether the input is a generator (which may not be of fixed length) or a list-like iterator.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable collection of items to combine.\n- left (str): A string representing the left border.\n- intersect (Optional[str]): A string used as a separator between items.\n- right (str): A string representing the right border.\n\nReturns:\n- Generator[int, None, None]: A generator that yields the combined elements, including the borders and separators.\n\nThe function is important for constructing formatted table rows within the larger code context, particularly in conjunction with `build_row` and `build_border`, which rely on the structured output of `combine` to format tables correctly.",
        "signature": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:",
        "type": "Function",
        "class_signature": null
      },
      "build_row": {
        "code": "def build_row(row, left, center, right):\n    \"\"\"Combines multi-lined cells from a given row into a single formatted row, including specified border characters.\n\n:param iter row: A list of lists where each inner list represents a cell and must be padded to have the same number of lines.\n:param str left: The character(s) to use as the left border of the row.\n:param str center: The character(s) used as the column separator between cells.\n:param str right: The character(s) to use as the right border of the row.\n\n:yield: A generator yielding formatted strings for each row including borders and separators.\n:rtype: iter\n\nThis function depends on the `combine` function to format output with specified borders. If the input `row` is empty or contains an empty first cell, it yields a combined border with no content. Otherwise, it iterates over the number of lines in the cells and combines the corresponding lines from each cell into a complete formatted row.\"\"\"\n    \"Combine single or multi-lined cells into a single row of list of lists including borders.\\n\\n    Row must already be padded and extended so each cell has the same number of lines.\\n\\n    Example return value:\\n    [\\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\\n    ]\\n\\n    :param iter row: List of cells for one row.\\n    :param str left: Left border.\\n    :param str center: Column separator.\\n    :param str right: Right border.\\n\\n    :return: Yields other generators that yield strings.\\n    :rtype: iter\\n    \"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)",
        "docstring": "Combines multi-lined cells from a given row into a single formatted row, including specified border characters.\n\n:param iter row: A list of lists where each inner list represents a cell and must be padded to have the same number of lines.\n:param str left: The character(s) to use as the left border of the row.\n:param str center: The character(s) used as the column separator between cells.\n:param str right: The character(s) to use as the right border of the row.\n\n:yield: A generator yielding formatted strings for each row including borders and separators.\n:rtype: iter\n\nThis function depends on the `combine` function to format output with specified borders. If the input `row` is empty or contains an empty first cell, it yields a combined border with no content. Otherwise, it iterates over the number of lines in the cells and combines the corresponding lines from each cell into a complete formatted row.",
        "signature": "def build_row(row, left, center, right):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/base_table.py": {
      "BaseTable.__init__": {
        "code": "    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Initializer for the BaseTable class, which defines the structure and appearance of a textual table.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A sequence containing rows of the table, where each row is a list of strings representing cell data. This can be empty or contain multiple lists of strings.\n- title (Optional[str]): An optional title for the table that is displayed within the top border.\n\nAttributes:\n- inner_column_border (bool): Determines if there is a vertical separator between columns (default is True).\n- inner_footing_row_border (bool): Determines if there is a border before the last row (default is False).\n- inner_heading_row_border (bool): Determines if there is a border after the first row (default is True).\n- inner_row_border (bool): Determines if there is a border between every row (default is False).\n- outer_border (bool): Determines if the table has a border around its outer edges (default is True).\n- justify_columns (dict): A dictionary that specifies the horizontal alignment for columns by index (default is empty).\n- padding_left (int): The number of spaces to add to the left of each cell (default is 1).\n- padding_right (int): The number of spaces to add to the right of each cell (default is 1).\n\nThe constants CHAR_F_INNER_HORIZONTAL, CHAR_F_INNER_INTERSECT, CHAR_F_INNER_VERTICAL, and others defined in the BaseTable class are used to delineate various parts of the table (such as borders and intersections) when rendering the table in a textual format. These constants support consistent styling across different elements of the table.\"\"\"\n        'Constructor.\\n\\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\\n        :param title: Optional title to show within the top border of the table.\\n        '\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1",
        "docstring": "Initializer for the BaseTable class, which defines the structure and appearance of a textual table.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A sequence containing rows of the table, where each row is a list of strings representing cell data. This can be empty or contain multiple lists of strings.\n- title (Optional[str]): An optional title for the table that is displayed within the top border.\n\nAttributes:\n- inner_column_border (bool): Determines if there is a vertical separator between columns (default is True).\n- inner_footing_row_border (bool): Determines if there is a border before the last row (default is False).\n- inner_heading_row_border (bool): Determines if there is a border after the first row (default is True).\n- inner_row_border (bool): Determines if there is a border between every row (default is False).\n- outer_border (bool): Determines if the table has a border around its outer edges (default is True).\n- justify_columns (dict): A dictionary that specifies the horizontal alignment for columns by index (default is empty).\n- padding_left (int): The number of spaces to add to the left of each cell (default is 1).\n- padding_right (int): The number of spaces to add to the right of each cell (default is 1).\n\nThe constants CHAR_F_INNER_HORIZONTAL, CHAR_F_INNER_INTERSECT, CHAR_F_INNER_VERTICAL, and others defined in the BaseTable class are used to delineate various parts of the table (such as borders and intersections) when rendering the table in a textual format. These constants support consistent styling across different elements of the table.",
        "signature": "def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_row_lines": {
        "code": "    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Generate lines for a specified table row, including vertical borders and cell alignment. This method accepts a row of data and produces formatted lines suitable for displaying in a text-based table.\n\nParameters:\n- row (Sequence[str]): A sequence representing the content of the row, where each element corresponds to a cell in the table.\n- style (str): A string indicating the type of border style to apply (e.g., 'heading', 'footing', or 'row').\n- inner_widths (Sequence[int]): A sequence of integers representing the widths of each column without padding.\n- height (int): An integer representing the desired height (number of lines) for the row, accounting for multi-line cells.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples representing formatted lines of the row for further processing in table generation. Each tuple contains strings formatted with appropriate padding and alignment.\n\nConstants Used:\n- The method utilizes several constants defined in the `BaseTable` class, such as `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, and others to determine border characters based on the style parameter. These constants define how various borders are rendered and are critical for visually distinguishing between the row types (e.g., heading and footer) and ensuring consistent styling across the table.\"\"\"\n        \"Combine cells in row and group them into lines with vertical borders.\\n\\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\\n        newline character to the end of joined line.\\n\\n        In:\\n        ['Row One Column One', 'Two', 'Three']\\n        Out:\\n        [\\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\\n        ]\\n\\n        In:\\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\\n        Out:\\n        [\\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\\n        ]\\n\\n        :param iter row: One row in the table. List of cells.\\n        :param str style: Type of border characters to use.\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\\n\\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\\n        \"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)",
        "docstring": "Generate lines for a specified table row, including vertical borders and cell alignment. This method accepts a row of data and produces formatted lines suitable for displaying in a text-based table.\n\nParameters:\n- row (Sequence[str]): A sequence representing the content of the row, where each element corresponds to a cell in the table.\n- style (str): A string indicating the type of border style to apply (e.g., 'heading', 'footing', or 'row').\n- inner_widths (Sequence[int]): A sequence of integers representing the widths of each column without padding.\n- height (int): An integer representing the desired height (number of lines) for the row, accounting for multi-line cells.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples representing formatted lines of the row for further processing in table generation. Each tuple contains strings formatted with appropriate padding and alignment.\n\nConstants Used:\n- The method utilizes several constants defined in the `BaseTable` class, such as `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, and others to determine border characters based on the style parameter. These constants define how various borders are rendered and are critical for visually distinguishing between the row types (e.g., heading and footer) and ensuring consistent styling across the table.",
        "signature": "def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      }
    }
  },
  "dependency_dict": {
    "terminaltables3/base_table.py:BaseTable:gen_row_lines": {},
    "terminaltables3/width_and_alignment.py:align_and_pad_cell": {},
    "terminaltables3/build.py:build_row": {}
  },
  "PRD": "# PROJECT NAME: terminaltables-test_gen_row_lines\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u251c\u2500\u2500 base_table.py\n    \u2502   \u251c\u2500\u2500 BaseTable.__init__\n    \u2502   \u2514\u2500\u2500 BaseTable.gen_row_lines\n    \u251c\u2500\u2500 build.py\n    \u2502   \u251c\u2500\u2500 build_row\n    \u2502   \u2514\u2500\u2500 combine\n    \u2514\u2500\u2500 width_and_alignment.py\n        \u251c\u2500\u2500 align_and_pad_cell\n        \u2514\u2500\u2500 visible_width\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module serves as a testing framework for the `BaseTable` class, a utility designed to generate formatted table structures for terminal-based applications. It validates the table's ability to handle various row configurations, including single-line and multi-line rows, rows with uneven or missing cells, and cases with or without padding and borders. This module ensures that the table rendering logic correctly accommodates different table styles (e.g., headers, footings, and rows) and layout constraints, such as column widths and cell alignment. By thoroughly verifying these functionalities, it addresses potential formatting issues, ensuring consistency in table presentation and reliability for developers integrating the `BaseTable` class into their terminal-based applications.\n\n## FILE 1: terminaltables3/width_and_alignment.py\n\n- FUNCTION NAME: align_and_pad_cell\n  - SIGNATURE: def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nAlign and pad a string within specified dimensions, supporting both horizontal and vertical alignment, along with additional padding.\n\n:param str string: The input string to align and pad. If the string contains ANSI color codes, they will be ignored for width calculations.\n:param tuple align: A tuple specifying horizontal ('left', 'center', 'right') and vertical ('top', 'middle', 'bottom') alignment options.\n:param tuple inner_dimensions: A tuple consisting of the target width and height (integers) for the cell without padding.\n:param iter padding: A sequence of four integers representing left, right, top, and bottom padding spaces.\n:param str space: The character used for padding; defaults to a single space.\n\n:return: A list of strings representing the padded and aligned cell, with each string corresponding to a line in the cell.\n:rtype: list\n\nThis function interacts with the `visible_width` function to determine the effective width of the text, accounting for diverse character widths, especially CJK decimals. The expected output is influenced by the alignment parameters and padding settings, ensuring the cell content is properly centered or justified based on input criteria.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n    - terminaltables3/base_table.py:BaseTable:gen_row_lines\n\n- FUNCTION NAME: visible_width\n  - SIGNATURE: def visible_width(string: str) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the visible width of a unicode string, accounting for multi-byte characters such as CJK (Chinese, Japanese, Korean) characters which may take up more space than ASCII characters.\n\n:param str string: The input string whose visible width is to be measured. The function handles ANSI color codes by stripping them out, utilizing the regular expression defined by the constant RE_COLOR_ANSI.\n:rtype: int: Returns the width of the string as an integer, where CJK characters contribute a width of 2, and all other characters contribute a width of 1.\n\nThis function depends on the `unicodedata` module to determine the width of characters based on their east Asian width classification.\n\"\"\"\n```\n\n## FILE 2: terminaltables3/build.py\n\n- FUNCTION NAME: combine\n  - SIGNATURE: def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine elements of the `line` into a single structure, surrounded by specified border characters.\n\nThis function accepts an iterable `line`, which can either be a generator or an iterator of items (strings or integers). It allows for a left border and a right border to be added around the items. If an `intersect` character is provided, it will be inserted between each of the items in the line. The behavior adapts based on whether the input is a generator (which may not be of fixed length) or a list-like iterator.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable collection of items to combine.\n- left (str): A string representing the left border.\n- intersect (Optional[str]): A string used as a separator between items.\n- right (str): A string representing the right border.\n\nReturns:\n- Generator[int, None, None]: A generator that yields the combined elements, including the borders and separators.\n\nThe function is important for constructing formatted table rows within the larger code context, particularly in conjunction with `build_row` and `build_border`, which rely on the structured output of `combine` to format tables correctly.\n\"\"\"\n```\n\n- FUNCTION NAME: build_row\n  - SIGNATURE: def build_row(row, left, center, right):\n  - DOCSTRING: \n```python\n\"\"\"\nCombines multi-lined cells from a given row into a single formatted row, including specified border characters.\n\n:param iter row: A list of lists where each inner list represents a cell and must be padded to have the same number of lines.\n:param str left: The character(s) to use as the left border of the row.\n:param str center: The character(s) used as the column separator between cells.\n:param str right: The character(s) to use as the right border of the row.\n\n:yield: A generator yielding formatted strings for each row including borders and separators.\n:rtype: iter\n\nThis function depends on the `combine` function to format output with specified borders. If the input `row` is empty or contains an empty first cell, it yields a combined border with no content. Otherwise, it iterates over the number of lines in the cells and combines the corresponding lines from each cell into a complete formatted row.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/base_table.py:BaseTable:gen_row_lines\n\n## FILE 3: terminaltables3/base_table.py\n\n- CLASS METHOD: BaseTable.gen_row_lines\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate lines for a specified table row, including vertical borders and cell alignment. This method accepts a row of data and produces formatted lines suitable for displaying in a text-based table.\n\nParameters:\n- row (Sequence[str]): A sequence representing the content of the row, where each element corresponds to a cell in the table.\n- style (str): A string indicating the type of border style to apply (e.g., 'heading', 'footing', or 'row').\n- inner_widths (Sequence[int]): A sequence of integers representing the widths of each column without padding.\n- height (int): An integer representing the desired height (number of lines) for the row, accounting for multi-line cells.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples representing formatted lines of the row for further processing in table generation. Each tuple contains strings formatted with appropriate padding and alignment.\n\nConstants Used:\n- The method utilizes several constants defined in the `BaseTable` class, such as `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, and others to determine border characters based on the style parameter. These constants define how various borders are rendered and are critical for visually distinguishing between the row types (e.g., heading and footer) and ensuring consistent styling across the table.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.__init__\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializer for the BaseTable class, which defines the structure and appearance of a textual table.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A sequence containing rows of the table, where each row is a list of strings representing cell data. This can be empty or contain multiple lists of strings.\n- title (Optional[str]): An optional title for the table that is displayed within the top border.\n\nAttributes:\n- inner_column_border (bool): Determines if there is a vertical separator between columns (default is True).\n- inner_footing_row_border (bool): Determines if there is a border before the last row (default is False).\n- inner_heading_row_border (bool): Determines if there is a border after the first row (default is True).\n- inner_row_border (bool): Determines if there is a border between every row (default is False).\n- outer_border (bool): Determines if the table has a border around its outer edges (default is True).\n- justify_columns (dict): A dictionary that specifies the horizontal alignment for columns by index (default is empty).\n- padding_left (int): The number of spaces to add to the left of each cell (default is 1).\n- padding_right (int): The number of spaces to add to the right of each cell (default is 1).\n\nThe constants CHAR_F_INNER_HORIZONTAL, CHAR_F_INNER_INTERSECT, CHAR_F_INNER_VERTICAL, and others defined in the BaseTable class are used to delineate various parts of the table (such as borders and intersections) when rendering the table in a textual format. These constants support consistent styling across different elements of the table.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\nfrom terminaltables3.terminal_io import terminal_size\nRE_COLOR_ANSI = re.compile('(\\\\033\\\\[[\\\\d;]+m)')\n\ndef max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max((len(r) for r in table_data)) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, 'count') or not hasattr(cell, 'splitlines'):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count('\\n') + 1)\n            inner_widths[i] = max(inner_widths[i], *[visible_width(the_line) for the_line in cell.splitlines()])\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n    return (inner_widths, inner_heights, outer_widths, outer_heights)\n\ndef column_max_width(inner_widths: Sequence[int], column_number: int, outer_border: int, inner_border: int, padding: int) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n    data_space = sum(inner_widths) - inner_widths[column_number]\n    return terminal_width - data_space - non_data_space\n\ndef table_width(outer_widths: Sequence[int], outer_border: int, inner_border: int) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n    data_space = sum(outer_widths)\n    return data_space + non_data_space",
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\nfrom typing import Generator, Iterator, Optional, Sequence, Union\nfrom terminaltables3.width_and_alignment import visible_width\n\ndef build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n    if title is None or not outer_widths or (not horizontal):\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n    if length == outer_widths[0]:\n        return combine([title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right)\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [horizontal * c for c in outer_widths[1:]]\n        return combine(columns, left, intersect, right)\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        if length < 1:\n            columns_and_intersects.append(intersect if width is True else horizontal * width)\n        elif width is True and length == 1:\n            length = 0\n        elif width is True:\n            length -= 1\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (width - length)\n            length = 0\n        else:\n            length -= width\n    return combine(columns_and_intersects, left, None, right)\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return '\\n'.join((''.join(r) for r in table))",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\nfrom typing import Generator, Optional, Sequence, Tuple\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '-'\n    CHAR_F_INNER_INTERSECT = '+'\n    CHAR_F_INNER_VERTICAL = '|'\n    CHAR_F_OUTER_LEFT_INTERSECT = '+'\n    CHAR_F_OUTER_LEFT_VERTICAL = '|'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_H_INNER_HORIZONTAL = '-'\n    CHAR_H_INNER_INTERSECT = '+'\n    CHAR_H_INNER_VERTICAL = '|'\n    CHAR_H_OUTER_LEFT_INTERSECT = '+'\n    CHAR_H_OUTER_LEFT_VERTICAL = '|'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_INNER_HORIZONTAL = '-'\n    CHAR_INNER_INTERSECT = '+'\n    CHAR_INNER_VERTICAL = '|'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '-'\n    CHAR_OUTER_BOTTOM_INTERSECT = '+'\n    CHAR_OUTER_BOTTOM_LEFT = '+'\n    CHAR_OUTER_BOTTOM_RIGHT = '+'\n    CHAR_OUTER_LEFT_INTERSECT = '+'\n    CHAR_OUTER_LEFT_VERTICAL = '|'\n    CHAR_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_OUTER_TOP_HORIZONTAL = '-'\n    CHAR_OUTER_TOP_INTERSECT = '+'\n    CHAR_OUTER_TOP_LEFT = '+'\n    CHAR_OUTER_TOP_RIGHT = '+'\n\n    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        if self.outer_border:\n            yield self.horizontal_border('top', outer_widths)\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = (row_count - 1, row_count - 2)\n        for i, row in enumerate(self.table_data):\n            if self.inner_heading_row_border and i == 0:\n                style = 'heading'\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = 'footing'\n            else:\n                style = 'row'\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            if i == last_row_index:\n                break\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border('heading', outer_widths)\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border('footing', outer_widths)\n            elif self.inner_row_border:\n                yield self.horizontal_border('row', outer_widths)\n        if self.outer_border:\n            yield self.horizontal_border('bottom', outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(self.table_data, self.padding_left, self.padding_right)[:3]\n        return flatten(self.gen_table(*dimensions))"
  },
  "call_tree": {
    "tests/test_base_table/test_gen_row_lines.py:test_single_line": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
        "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:build_row": {}
      },
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_base_table/test_gen_row_lines.py:test_multi_line": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
        "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:build_row": {}
      },
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_base_table/test_gen_row_lines.py:test_no_padding_no_borders": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
        "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:build_row": {}
      },
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_base_table/test_gen_row_lines.py:test_uneven": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
        "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:build_row": {}
      },
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_base_table/test_gen_row_lines.py:test_empty_table": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
        "terminaltables3/build.py:build_row": {}
      },
      "terminaltables3/build.py:combine": {}
    }
  }
}