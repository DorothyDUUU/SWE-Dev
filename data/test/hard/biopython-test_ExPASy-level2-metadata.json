{
  "dir_path": "/app/biopython",
  "package_name": "biopython",
  "sample_name": "biopython-test_ExPASy",
  "src_dir": "BioSQL/",
  "test_dir": "Tests/",
  "test_file": "Tests/test_ExPASy.py",
  "test_code": "# Copyright 2017 by Peter Cock.  All rights reserved.\n# This code is part of the Biopython distribution and governed by its\n# license.  Please see the LICENSE file that should have been included\n# as part of this package.\n\n\"\"\"Testing Bio.ExPASy online code.\"\"\"\n\nimport unittest\n\nimport requires_internet\n\n# We want to test these:\nfrom Bio import ExPASy\n\n# In order to check any records returned\nfrom Bio.ExPASy import Prodoc\nfrom Bio.ExPASy import Prosite\n\nrequires_internet.check()\n\n\nclass ExPASyOnlineTests(unittest.TestCase):\n    \"\"\"Test ExPASy online resources.\"\"\"\n\n    def test_prosite_raw(self):\n        with ExPASy.get_prosite_raw(\"PS00001\") as handle:\n            record = Prosite.read(handle)\n        self.assertEqual(record.accession, \"PS00001\")\n        self.assertEqual(record.name, \"ASN_GLYCOSYLATION\")\n\n    def test_prodoc_raw(self):\n        with ExPASy.get_prosite_raw(\"PDOC00001\") as handle:\n            record = Prodoc.read(handle)\n        self.assertEqual(record.accession, \"PDOC00001\")\n\n    def test_prosite_html(self):\n        with ExPASy.get_prosite_entry(\"PS00001\") as handle:\n            html = handle.read()\n        self.assertEqual(\n            handle.url,\n            \"https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry?PS00001\",\n        )\n        self.assertIn(\"<title>PROSITE - PS00001</title>\", html)\n\n    def test_prodoc_html(self):\n        with ExPASy.get_prodoc_entry(\"PDOC00001\") as handle:\n            html = handle.read()\n        self.assertEqual(\n            handle.url,\n            \"https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry?PDOC00001\",\n        )\n        self.assertIn(\"{PS00001; ASN_GLYCOSYLATION}\", html)\n\n\nif __name__ == \"__main__\":\n    runner = unittest.TextTestRunner(verbosity=2)\n    unittest.main(testRunner=runner)\n",
  "GT_file_code": {
    "Bio/ExPASy/__init__.py": "# Copyright 2000 by Jeffrey Chang.  All rights reserved.\n# This code is part of the Biopython distribution and governed by its\n# license.  Please see the LICENSE file that should have been included\n# as part of this package.\n\n\"\"\"Code to access resources at ExPASy over the WWW.\n\nSee https://www.expasy.org/\n\n\nFunctions:\n - get_prodoc_entry  Interface to the get-prodoc-entry CGI script.\n - get_prosite_entry Interface to the get-prosite-entry CGI script.\n - get_prosite_raw   Interface to the get-prosite-raw CGI script.\n - get_sprot_raw     Interface to the get-sprot-raw CGI script.\n\n\"\"\"\n\nimport io\nfrom urllib.error import HTTPError\nfrom urllib.request import urlopen\n\n\ndef get_prodoc_entry(\n    id, cgi=\"https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry\"\n):\n    \"\"\"Get a text handle to a PRODOC entry at ExPASy in HTML format.\n\n    >>> from Bio import ExPASy\n    >>> import os\n    >>> with ExPASy.get_prodoc_entry('PDOC00001') as in_handle:\n    ...     html = in_handle.read()\n    ...\n    >>> with open(\"myprodocrecord.html\", \"w\") as out_handle:\n    ...     length = out_handle.write(html)\n    ...\n    >>> os.remove(\"myprodocrecord.html\")  # tidy up\n\n    For a non-existing key XXX, ExPASy returns an HTML-formatted page\n    containing this text: 'There is currently no PROSITE entry for'\n    \"\"\"\n    return _open(f\"{cgi}?{id}\")\n\n\ndef get_prosite_entry(\n    id, cgi=\"https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry\"\n):\n    \"\"\"Get a text handle to a PROSITE entry at ExPASy in HTML format.\n\n    >>> from Bio import ExPASy\n    >>> import os\n    >>> with ExPASy.get_prosite_entry('PS00001') as in_handle:\n    ...     html = in_handle.read()\n    ...\n    >>> with open(\"myprositerecord.html\", \"w\") as out_handle:\n    ...     length = out_handle.write(html)\n    ...\n    >>> os.remove(\"myprositerecord.html\")  # tidy up\n\n    For a non-existing key XXX, ExPASy returns an HTML-formatted page\n    containing this text: 'There is currently no PROSITE entry for'\n    \"\"\"\n    return _open(f\"{cgi}?{id}\")\n\n\ndef get_prosite_raw(id, cgi=None):\n    \"\"\"Get a text handle to a raw PROSITE or PRODOC record at ExPASy.\n\n    The cgi argument is deprecated due to changes in the ExPASy\n    website.\n\n    >>> from Bio import ExPASy\n    >>> from Bio.ExPASy import Prosite\n    >>> with ExPASy.get_prosite_raw('PS00001') as handle:\n    ...     record = Prosite.read(handle)\n    ...\n    >>> print(record.accession)\n    PS00001\n\n    This function raises a ValueError if the identifier does not exist:\n\n    >>> handle = ExPASy.get_prosite_raw(\"DOES_NOT_EXIST\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Failed to find entry 'DOES_NOT_EXIST' on ExPASy\n\n    \"\"\"\n    try:\n        handle = _open(f\"https://prosite.expasy.org/{id}.txt\")\n    except HTTPError as exception:\n        if exception.code == 404:\n            raise ValueError(\"Failed to find entry '%s' on ExPASy\" % id) from None\n        else:\n            raise\n    # This has happened historically, redirected to main page:\n    if handle.url == \"https://www.expasy.org/\":\n        raise ValueError(f\"Failed to find entry '{id}' on ExPASy\") from None\n    return handle\n\n\ndef get_sprot_raw(id):\n    \"\"\"Get a text handle to a raw SwissProt entry at ExPASy.\n\n    For an ID of XXX, fetches http://www.uniprot.org/uniprot/XXX.txt\n    (as per the https://www.expasy.org/expasy_urls.html documentation).\n\n    >>> from Bio import ExPASy\n    >>> from Bio import SwissProt\n    >>> with ExPASy.get_sprot_raw(\"O23729\") as handle:\n    ...     record = SwissProt.read(handle)\n    ...\n    >>> print(record.entry_name)\n    CHS3_BROFI\n\n    This function raises a ValueError if the identifier does not exist:\n\n    >>> ExPASy.get_sprot_raw(\"DOES_NOT_EXIST\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Failed to find SwissProt entry 'DOES_NOT_EXIST'\n\n    \"\"\"\n    try:\n        handle = _open(f\"http://www.uniprot.org/uniprot/{id}.txt\")\n    except HTTPError as exception:\n        if exception.code in (400, 404):\n            raise ValueError(f\"Failed to find SwissProt entry '{id}'\") from None\n        else:\n            raise\n    return handle\n\n\ndef _open(url):\n    \"\"\"Open URL and convert to text assuming UTF-8 encoding (PRIVATE).\"\"\"\n    handle = urlopen(url)\n    text_handle = io.TextIOWrapper(handle, encoding=\"UTF-8\")\n    text_handle.url = handle.url\n    return text_handle\n",
    "Bio/ExPASy/Prodoc.py": "# Copyright 2000 by Jeffrey Chang.  All rights reserved.\n# This code is part of the Biopython distribution and governed by its\n# license.  Please see the LICENSE file that should have been included\n# as part of this package.\n\n\"\"\"Code to work with the prosite.doc file from Prosite.\n\nSee https://www.expasy.org/prosite/\n\nTested with:\n - Release 15.0, July 1998\n - Release 16.0, July 1999\n - Release 20.22, 13 November 2007\n - Release 20.43, 10 February 2009\n\nFunctions:\n - read               Read a Prodoc file containing exactly one Prodoc entry.\n - parse              Iterates over entries in a Prodoc file.\n\nClasses:\n - Record             Holds Prodoc data.\n - Reference          Holds data from a Prodoc reference.\n\n\"\"\"\n\n\ndef read(handle):\n    \"\"\"Read in a record from a file with exactly one Prodoc record.\"\"\"\n    record = __read(handle)\n    # We should have reached the end of the record by now\n    line = handle.readline()\n    if line:\n        raise ValueError(\"More than one Prodoc record found\")\n    return record\n\n\ndef parse(handle):\n    \"\"\"Iterate over the records in a Prodoc file.\"\"\"\n    while True:\n        record = __read(handle)\n        if not record:\n            return\n        yield record\n\n\nclass Record:\n    \"\"\"Holds information from a Prodoc record.\n\n    Attributes:\n     - accession      Accession number of the record.\n     - prosite_refs   List of tuples (prosite accession, prosite name).\n     - text           Free format text.\n     - references     List of reference objects.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.accession = \"\"\n        self.prosite_refs = []\n        self.text = \"\"\n        self.references = []\n\n\nclass Reference:\n    \"\"\"Holds information from a Prodoc citation.\n\n    Attributes:\n     - number     Number of the reference. (string)\n     - authors    Names of the authors.\n     - citation   Describes the citation.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.number = \"\"\n        self.authors = \"\"\n        self.citation = \"\"\n\n\n# Below are private functions\n\n\ndef __read_prosite_reference_line(record, line):\n    line = line.rstrip()\n    if line[-1] != \"}\":\n        raise ValueError(f\"I don't understand the Prosite reference on line\\n{line}\")\n    acc, name = line[1:-1].split(\"; \")\n    record.prosite_refs.append((acc, name))\n\n\ndef __read_text_line(record, line):\n    record.text += line\n    return True\n\n\ndef __read_reference_start(record, line):\n    # Read the references\n    reference = Reference()\n    reference.number = line[1:3].strip()\n    if line[1] == \"E\":\n        # If it's an electronic reference, then the URL is on the\n        # line, instead of the author.\n        reference.citation = line[4:].strip()\n    else:\n        reference.authors = line[4:].strip()\n    record.references.append(reference)\n\n\ndef __read_reference_line(record, line):\n    if not line.strip():\n        return False\n    reference = record.references[-1]\n    if line.startswith(\"     \"):\n        if reference.authors[-1] == \",\":\n            reference.authors += line[4:].rstrip()\n        else:\n            reference.citation += line[5:]\n        return True\n    raise Exception(f\"I don't understand the reference line\\n{line}\")\n\n\ndef __read_copyright_line(record, line):\n    # Skip the copyright statement\n    if line.startswith(\"+----\"):\n        return False\n    return True\n\n\ndef __read(handle):\n    # Skip blank lines between records\n    for line in handle:\n        line = line.rstrip()\n        if line and not line.startswith(\"//\"):\n            break\n    else:\n        return None\n    record = Record()\n    # Read the accession number\n    if not line.startswith(\"{PDOC\"):\n        raise ValueError(\"Line does not start with '{PDOC':\\n%s\" % line)\n    if line[-1] != \"}\":\n        raise ValueError(f\"I don't understand accession line\\n{line}\")\n    record.accession = line[1:-1]\n    # Read the Prosite references\n    for line in handle:\n        if line.startswith(\"{PS\"):\n            __read_prosite_reference_line(record, line)\n        else:\n            break\n    else:\n        raise ValueError(\"Unexpected end of stream.\")\n    # Read the actual text\n    if not line.startswith(\"{BEGIN\"):\n        raise ValueError(\"Line does not start with '{BEGIN':\\n%s\" % line)\n    read_line = __read_text_line\n    for line in handle:\n        if line.startswith(\"{END}\"):\n            # Clean up the record and return\n            for reference in record.references:\n                reference.citation = reference.citation.rstrip()\n                reference.authors = reference.authors.rstrip()\n            return record\n        elif line[0] == \"[\" and line[3] == \"]\" and line[4] == \" \":\n            __read_reference_start(record, line)\n            read_line = __read_reference_line\n        elif line.startswith(\"+----\"):\n            read_line = __read_copyright_line\n        elif read_line:\n            if not read_line(record, line):\n                read_line = None\n    raise ValueError(\"Unexpected end of stream.\")\n",
    "Bio/ExPASy/Prosite.py": "# Copyright 1999 by Jeffrey Chang.  All rights reserved.\n# Copyright 2000 by Jeffrey Chang.  All rights reserved.\n# Revisions Copyright 2007 by Peter Cock.  All rights reserved.\n# Revisions Copyright 2009 by Michiel de Hoon.  All rights reserved.\n# This code is part of the Biopython distribution and governed by its\n# license.  Please see the LICENSE file that should have been included\n# as part of this package.\n\"\"\"Parser for the prosite dat file from Prosite at ExPASy.\n\nSee https://www.expasy.org/prosite/\n\nTested with:\n - Release 20.43, 10-Feb-2009\n - Release 2017_03 of 15-Mar-2017.\n\nFunctions:\n - read                  Reads a Prosite file containing one Prosite record\n - parse                 Iterates over records in a Prosite file.\n\nClasses:\n - Record                Holds Prosite data.\n\n\"\"\"\n\n\ndef parse(handle):\n    \"\"\"Parse Prosite records.\n\n    This function is for parsing Prosite files containing multiple\n    records.\n\n    Arguments:\n     - handle   - handle to the file.\n\n    \"\"\"\n    while True:\n        record = __read(handle)\n        if not record:\n            break\n        yield record\n\n\ndef read(handle):\n    \"\"\"Read one Prosite record.\n\n    This function is for parsing Prosite files containing\n    exactly one record.\n\n    Arguments:\n     - handle   - handle to the file.\n\n    \"\"\"\n    record = __read(handle)\n    # We should have reached the end of the record by now\n    remainder = handle.read()\n    if remainder:\n        raise ValueError(\"More than one Prosite record found\")\n    return record\n\n\nclass Record:\n    \"\"\"Holds information from a Prosite record.\n\n    Main attributes:\n     - name           ID of the record.  e.g. ADH_ZINC\n     - type           Type of entry.  e.g. PATTERN, MATRIX, or RULE\n     - accession      e.g. PS00387\n     - created        Date the entry was created.  (MMM-YYYY for releases\n       before January 2017, DD-MMM-YYYY since January 2017)\n     - data_update    Date the 'primary' data was last updated.\n     - info_update    Date data other than 'primary' data was last updated.\n     - pdoc           ID of the PROSITE DOCumentation.\n     - description    Free-format description.\n     - pattern        The PROSITE pattern.  See docs.\n     - matrix         List of strings that describes a matrix entry.\n     - rules          List of rule definitions (from RU lines).  (strings)\n     - prorules       List of prorules (from PR lines). (strings)\n\n    NUMERICAL RESULTS:\n     - nr_sp_release  SwissProt release.\n     - nr_sp_seqs     Number of seqs in that release of Swiss-Prot. (int)\n     - nr_total       Number of hits in Swiss-Prot.  tuple of (hits, seqs)\n     - nr_positive    True positives.  tuple of (hits, seqs)\n     - nr_unknown     Could be positives.  tuple of (hits, seqs)\n     - nr_false_pos   False positives.  tuple of (hits, seqs)\n     - nr_false_neg   False negatives.  (int)\n     - nr_partial     False negatives, because they are fragments. (int)\n\n    COMMENTS:\n     - cc_taxo_range  Taxonomic range.  See docs for format\n     - cc_max_repeat  Maximum number of repetitions in a protein\n     - cc_site        Interesting site.  list of tuples (pattern pos, desc.)\n     - cc_skip_flag   Can this entry be ignored?\n     - cc_matrix_type\n     - cc_scaling_db\n     - cc_author\n     - cc_ft_key\n     - cc_ft_desc\n     - cc_version     version number (introduced in release 19.0)\n\n    The following are all lists if tuples (swiss-prot accession, swiss-prot name).\n\n    DATA BANK REFERENCES:\n     - dr_positive\n     - dr_false_neg\n     - dr_false_pos\n     - dr_potential   Potential hits, but fingerprint region not yet available.\n     - dr_unknown     Could possibly belong\n     - pdb_structs    List of PDB entries.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.name = \"\"\n        self.type = \"\"\n        self.accession = \"\"\n        self.created = \"\"\n        self.data_update = \"\"\n        self.info_update = \"\"\n        self.pdoc = \"\"\n\n        self.description = \"\"\n        self.pattern = \"\"\n        self.matrix = []\n        self.rules = []\n        self.prorules = []\n        self.postprocessing = []\n\n        self.nr_sp_release = \"\"\n        self.nr_sp_seqs = \"\"\n        self.nr_total = (None, None)\n        self.nr_positive = (None, None)\n        self.nr_unknown = (None, None)\n        self.nr_false_pos = (None, None)\n        self.nr_false_neg = None\n        self.nr_partial = None\n\n        self.cc_taxo_range = \"\"\n        self.cc_max_repeat = \"\"\n        self.cc_site = []\n        self.cc_skip_flag = \"\"\n\n        self.dr_positive = []\n        self.dr_false_neg = []\n        self.dr_false_pos = []\n        self.dr_potential = []\n        self.dr_unknown = []\n\n        self.pdb_structs = []\n\n\n# Everything below are private functions\n\n\ndef __read(handle):\n    import re\n\n    record = None\n    for line in handle:\n        keyword, value = line[:2], line[5:].rstrip()\n        if keyword == \"ID\":\n            record = Record()\n            cols = value.split(\"; \")\n            if len(cols) != 2:\n                raise ValueError(f\"I don't understand identification line\\n{line}\")\n            record.name = cols[0]\n            record.type = cols[1].rstrip(\".\")  # don't want '.'\n        elif keyword == \"AC\":\n            record.accession = value.rstrip(\";\")\n        elif keyword == \"DT\":\n            # e.g. from January 2017,\n            # DT   01-APR-1990 CREATED; 01-APR-1990 DATA UPDATE; 01-APR-1990 INFO UPDATE.\n            # Older files had brackets round the date descriptions and used MMM-YYYY\n            dates = value.rstrip(\".\").split(\"; \")\n            if dates[0].endswith((\" (CREATED)\", \" CREATED\")):\n                # Remove last word\n                record.created = dates[0].rsplit(\" \", 1)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n            if dates[1].endswith((\" (DATA UPDATE)\", \" DATA UPDATE\")):\n                # Remove last two words\n                record.data_update = dates[1].rsplit(\" \", 2)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n            if dates[2].endswith((\" (INFO UPDATE)\", \" INFO UPDATE\")):\n                # Remove last two words\n                record.info_update = dates[2].rsplit(\" \", 2)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n        elif keyword == \"DE\":\n            record.description = value\n        elif keyword == \"PA\":\n            record.pattern += value\n        elif keyword == \"MA\":\n            record.matrix.append(value)\n        elif keyword == \"PP\":\n            record.postprocessing.extend(value.split(\";\"))\n        elif keyword == \"RU\":\n            record.rules.append(value)\n        elif keyword == \"NR\":\n            cols = value.split(\";\")\n            for col in cols:\n                if not col:\n                    continue\n                qual, data = (word.lstrip() for word in col.split(\"=\"))\n                if qual == \"/RELEASE\":\n                    release, seqs = data.split(\",\")\n                    record.nr_sp_release = release\n                    record.nr_sp_seqs = int(seqs)\n                elif qual == \"/FALSE_NEG\":\n                    record.nr_false_neg = int(data)\n                elif qual == \"/PARTIAL\":\n                    record.nr_partial = int(data)\n                elif qual in [\"/TOTAL\", \"/POSITIVE\", \"/UNKNOWN\", \"/FALSE_POS\"]:\n                    m = re.match(r\"(\\d+)\\((\\d+)\\)\", data)\n                    if not m:\n                        raise Exception(f\"Broken data {data} in comment line\\n{line!r}\")\n                    hits = tuple(map(int, m.groups()))\n                    if qual == \"/TOTAL\":\n                        record.nr_total = hits\n                    elif qual == \"/POSITIVE\":\n                        record.nr_positive = hits\n                    elif qual == \"/UNKNOWN\":\n                        record.nr_unknown = hits\n                    elif qual == \"/FALSE_POS\":\n                        record.nr_false_pos = hits\n                else:\n                    raise ValueError(f\"Unknown qual {qual} in comment line\\n{line!r}\")\n        elif keyword == \"CC\":\n            # Expect CC lines like this:\n            # CC   /TAXO-RANGE=??EPV; /MAX-REPEAT=2;\n            # Can (normally) split on \";\" and then on \"=\"\n            cols = value.split(\";\")\n            for col in cols:\n                if not col or col[:17] == \"Automatic scaling\":\n                    # DNAJ_2 in Release 15 has a non-standard comment line:\n                    # CC   Automatic scaling using reversed database\n                    # Throw it away.  (Should I keep it?)\n                    continue\n                if col.count(\"=\") == 0:\n                    # Missing qualifier!  Can we recover gracefully?\n                    # For example, from Bug 2403, in PS50293 have:\n                    # CC /AUTHOR=K_Hofmann; N_Hulo\n                    continue\n                qual, data = (word.lstrip() for word in col.split(\"=\"))\n                if qual == \"/TAXO-RANGE\":\n                    record.cc_taxo_range = data\n                elif qual == \"/MAX-REPEAT\":\n                    record.cc_max_repeat = data\n                elif qual == \"/SITE\":\n                    pos, desc = data.split(\",\")\n                    record.cc_site.append((int(pos), desc))\n                elif qual == \"/SKIP-FLAG\":\n                    record.cc_skip_flag = data\n                elif qual == \"/MATRIX_TYPE\":\n                    record.cc_matrix_type = data\n                elif qual == \"/SCALING_DB\":\n                    record.cc_scaling_db = data\n                elif qual == \"/AUTHOR\":\n                    record.cc_author = data\n                elif qual == \"/FT_KEY\":\n                    record.cc_ft_key = data\n                elif qual == \"/FT_DESC\":\n                    record.cc_ft_desc = data\n                elif qual == \"/VERSION\":\n                    record.cc_version = data\n                else:\n                    raise ValueError(f\"Unknown qual {qual} in comment line\\n{line!r}\")\n        elif keyword == \"DR\":\n            refs = value.split(\";\")\n            for ref in refs:\n                if not ref:\n                    continue\n                acc, name, type = (word.strip() for word in ref.split(\",\"))\n                if type == \"T\":\n                    record.dr_positive.append((acc, name))\n                elif type == \"F\":\n                    record.dr_false_pos.append((acc, name))\n                elif type == \"N\":\n                    record.dr_false_neg.append((acc, name))\n                elif type == \"P\":\n                    record.dr_potential.append((acc, name))\n                elif type == \"?\":\n                    record.dr_unknown.append((acc, name))\n                else:\n                    raise ValueError(f\"I don't understand type flag {type}\")\n        elif keyword == \"3D\":\n            cols = value.split()\n            for id in cols:\n                record.pdb_structs.append(id.rstrip(\";\"))\n        elif keyword == \"PR\":\n            rules = value.split(\";\")\n            record.prorules.extend(rules)\n        elif keyword == \"DO\":\n            record.pdoc = value.rstrip(\";\")\n        elif keyword == \"//\":\n            if not record:\n                # Then this was the copyright statement\n                continue\n            break\n        else:\n            raise ValueError(f\"Unknown keyword {keyword} found\")\n    else:\n        return\n    if not record:\n        raise ValueError(\"Unexpected end of stream.\")\n    return record\n"
  },
  "GT_src_dict": {
    "Bio/ExPASy/__init__.py": {
      "get_prodoc_entry": {
        "code": "def get_prodoc_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry'):\n    \"\"\"Retrieve a PRODOC entry from ExPASy in HTML format.\n\nParameters:\n- id (str): The identifier for the PRODOC entry to be retrieved.\n- cgi (str, optional): The URL for the CGI script to fetch the PRODOC entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry\".\n\nReturns:\n- A text handle (an io.TextIOWrapper) that allows access to the HTML content of the requested PRODOC entry.\n\nUsage:\nThis function interacts with the ExPASy database and returns an HTML-formatted page. If the specified entry does not exist, ExPASy will return a page indicating that no entry is available for the given identifier.\n\nDependencies:\nThis function uses the private helper function _open to handle the URL opening and ensure the response is properly encoded in UTF-8.\"\"\"\n    'Get a text handle to a PRODOC entry at ExPASy in HTML format.\\n\\n    >>> from Bio import ExPASy\\n    >>> import os\\n    >>> with ExPASy.get_prodoc_entry(\\'PDOC00001\\') as in_handle:\\n    ...     html = in_handle.read()\\n    ...\\n    >>> with open(\"myprodocrecord.html\", \"w\") as out_handle:\\n    ...     length = out_handle.write(html)\\n    ...\\n    >>> os.remove(\"myprodocrecord.html\")  # tidy up\\n\\n    For a non-existing key XXX, ExPASy returns an HTML-formatted page\\n    containing this text: \\'There is currently no PROSITE entry for\\'\\n    '\n    return _open(f'{cgi}?{id}')",
        "docstring": "Retrieve a PRODOC entry from ExPASy in HTML format.\n\nParameters:\n- id (str): The identifier for the PRODOC entry to be retrieved.\n- cgi (str, optional): The URL for the CGI script to fetch the PRODOC entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry\".\n\nReturns:\n- A text handle (an io.TextIOWrapper) that allows access to the HTML content of the requested PRODOC entry.\n\nUsage:\nThis function interacts with the ExPASy database and returns an HTML-formatted page. If the specified entry does not exist, ExPASy will return a page indicating that no entry is available for the given identifier.\n\nDependencies:\nThis function uses the private helper function _open to handle the URL opening and ensure the response is properly encoded in UTF-8.",
        "signature": "def get_prodoc_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry'):",
        "type": "Function",
        "class_signature": null
      },
      "get_prosite_entry": {
        "code": "def get_prosite_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry'):\n    \"\"\"Retrieve a PROSITE entry from ExPASy as an HTML document.\n\nParameters:\n- id (str): The unique identifier for the PROSITE entry to be fetched.\n- cgi (str, optional): The CGI URL for accessing the PROSITE entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry\".\n\nReturns:\n- A text handle to the HTML content of the requested PROSITE entry. The handle should be used in a context manager (with statement) to ensure proper resource management.\n\nNotes:\n- If the specified entry does not exist, ExPASy will return an HTML page indicating that no entry is available for the provided id.\n- This function internally calls `_open`, which handles the URL request and ensures the response is decoded in UTF-8.\"\"\"\n    'Get a text handle to a PROSITE entry at ExPASy in HTML format.\\n\\n    >>> from Bio import ExPASy\\n    >>> import os\\n    >>> with ExPASy.get_prosite_entry(\\'PS00001\\') as in_handle:\\n    ...     html = in_handle.read()\\n    ...\\n    >>> with open(\"myprositerecord.html\", \"w\") as out_handle:\\n    ...     length = out_handle.write(html)\\n    ...\\n    >>> os.remove(\"myprositerecord.html\")  # tidy up\\n\\n    For a non-existing key XXX, ExPASy returns an HTML-formatted page\\n    containing this text: \\'There is currently no PROSITE entry for\\'\\n    '\n    return _open(f'{cgi}?{id}')",
        "docstring": "Retrieve a PROSITE entry from ExPASy as an HTML document.\n\nParameters:\n- id (str): The unique identifier for the PROSITE entry to be fetched.\n- cgi (str, optional): The CGI URL for accessing the PROSITE entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry\".\n\nReturns:\n- A text handle to the HTML content of the requested PROSITE entry. The handle should be used in a context manager (with statement) to ensure proper resource management.\n\nNotes:\n- If the specified entry does not exist, ExPASy will return an HTML page indicating that no entry is available for the provided id.\n- This function internally calls `_open`, which handles the URL request and ensures the response is decoded in UTF-8.",
        "signature": "def get_prosite_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry'):",
        "type": "Function",
        "class_signature": null
      },
      "get_prosite_raw": {
        "code": "def get_prosite_raw(id, cgi=None):\n    \"\"\"Get a text handle to a raw PROSITE or PRODOC record at ExPASy.\n\nThis function retrieves raw data associated with a specified PROSITE entry ID from ExPASy. If the entry does not exist, it raises a ValueError.\n\nParameters:\n- id (str): The identifier of the PROSITE entry to fetch.\n- cgi (str, optional): Deprecated parameter for specifying the CGI URL, not used in current functionality.\n\nReturns:\n- io.TextIOWrapper: A text handle containing the raw PROSITE or PRODOC data in UTF-8 encoding.\n\nRaises:\n- ValueError: If the identifier does not correspond to an existing entry on ExPASy.\n\nThe function relies on the private _open function which handles URL opening and encoding. The URLs used are in the form \"https://prosite.expasy.org/{id}.txt\". If the entry is not found (404 error), a ValueError is raised with a specific message.\"\"\"\n    'Get a text handle to a raw PROSITE or PRODOC record at ExPASy.\\n\\n    The cgi argument is deprecated due to changes in the ExPASy\\n    website.\\n\\n    >>> from Bio import ExPASy\\n    >>> from Bio.ExPASy import Prosite\\n    >>> with ExPASy.get_prosite_raw(\\'PS00001\\') as handle:\\n    ...     record = Prosite.read(handle)\\n    ...\\n    >>> print(record.accession)\\n    PS00001\\n\\n    This function raises a ValueError if the identifier does not exist:\\n\\n    >>> handle = ExPASy.get_prosite_raw(\"DOES_NOT_EXIST\")\\n    Traceback (most recent call last):\\n        ...\\n    ValueError: Failed to find entry \\'DOES_NOT_EXIST\\' on ExPASy\\n\\n    '\n    try:\n        handle = _open(f'https://prosite.expasy.org/{id}.txt')\n    except HTTPError as exception:\n        if exception.code == 404:\n            raise ValueError(\"Failed to find entry '%s' on ExPASy\" % id) from None\n        else:\n            raise\n    if handle.url == 'https://www.expasy.org/':\n        raise ValueError(f\"Failed to find entry '{id}' on ExPASy\") from None\n    return handle",
        "docstring": "Get a text handle to a raw PROSITE or PRODOC record at ExPASy.\n\nThis function retrieves raw data associated with a specified PROSITE entry ID from ExPASy. If the entry does not exist, it raises a ValueError.\n\nParameters:\n- id (str): The identifier of the PROSITE entry to fetch.\n- cgi (str, optional): Deprecated parameter for specifying the CGI URL, not used in current functionality.\n\nReturns:\n- io.TextIOWrapper: A text handle containing the raw PROSITE or PRODOC data in UTF-8 encoding.\n\nRaises:\n- ValueError: If the identifier does not correspond to an existing entry on ExPASy.\n\nThe function relies on the private _open function which handles URL opening and encoding. The URLs used are in the form \"https://prosite.expasy.org/{id}.txt\". If the entry is not found (404 error), a ValueError is raised with a specific message.",
        "signature": "def get_prosite_raw(id, cgi=None):",
        "type": "Function",
        "class_signature": null
      },
      "_open": {
        "code": "def _open(url):\n    \"\"\"Open a URL and return a text handle with UTF-8 encoding.\n\nParameters:\n- url (str): The URL of the resource to open.\n\nReturns:\n- TextIOWrapper: A text handle to read the content of the URL as text, with the encoding set to UTF-8. The handle also contains the original URL as an attribute `url`.\n\nThis function is primarily used by other functions in the module to access ExPASy resources, converting the raw response into a more suitable format for text processing. It utilizes the `urlopen` function from the `urllib.request` module to perform the URL request.\"\"\"\n    'Open URL and convert to text assuming UTF-8 encoding (PRIVATE).'\n    handle = urlopen(url)\n    text_handle = io.TextIOWrapper(handle, encoding='UTF-8')\n    text_handle.url = handle.url\n    return text_handle",
        "docstring": "Open a URL and return a text handle with UTF-8 encoding.\n\nParameters:\n- url (str): The URL of the resource to open.\n\nReturns:\n- TextIOWrapper: A text handle to read the content of the URL as text, with the encoding set to UTF-8. The handle also contains the original URL as an attribute `url`.\n\nThis function is primarily used by other functions in the module to access ExPASy resources, converting the raw response into a more suitable format for text processing. It utilizes the `urlopen` function from the `urllib.request` module to perform the URL request.",
        "signature": "def _open(url):",
        "type": "Function",
        "class_signature": null
      }
    },
    "Bio/ExPASy/Prodoc.py": {
      "read": {
        "code": "def read(handle):\n    \"\"\"Read in a single Prodoc record from a file handle.\n\nParameters:\n- handle (file-like object): An open file handle that contains a Prodoc file with exactly one record.\n\nReturns:\n- Record: An instance of the Record class containing the parsed data from the Prodoc record, including the accession number, references, text, and prosite references.\n\nRaises:\n- ValueError: If more than one Prodoc record is found in the file or if the Prodoc record format is invalid (e.g., missing expected markers like '{PDOC', '{BEGIN', etc.). \n\nThis function relies on the private __read function to perform the actual reading and parsing of the Prodoc data. It ensures that the handle is consumed completely after reading one record.\"\"\"\n    'Read in a record from a file with exactly one Prodoc record.'\n    record = __read(handle)\n    line = handle.readline()\n    if line:\n        raise ValueError('More than one Prodoc record found')\n    return record",
        "docstring": "Read in a single Prodoc record from a file handle.\n\nParameters:\n- handle (file-like object): An open file handle that contains a Prodoc file with exactly one record.\n\nReturns:\n- Record: An instance of the Record class containing the parsed data from the Prodoc record, including the accession number, references, text, and prosite references.\n\nRaises:\n- ValueError: If more than one Prodoc record is found in the file or if the Prodoc record format is invalid (e.g., missing expected markers like '{PDOC', '{BEGIN', etc.). \n\nThis function relies on the private __read function to perform the actual reading and parsing of the Prodoc data. It ensures that the handle is consumed completely after reading one record.",
        "signature": "def read(handle):",
        "type": "Function",
        "class_signature": null
      },
      "__read": {
        "code": "def __read(handle):\n    \"\"\"Reads a Prodoc record from the given file handle. This function handles the parsing of Prodoc-specific formatted data, specifically looking for the accession number, Prosite references, text content, and citations within the record. The function ensures the record adheres to expected formats, raising errors for non-compliant lines.\n\nParameters:\n- handle: An I/O stream (file-like object) from which the Prodoc record is read.\n\nReturns:\n- An instance of the Record class, populated with the extracted data from the Prodoc record.\n\nRaises:\n- ValueError: If the record format does not meet specified criteria, such as missing expected prefixes or improper line endings.\n\nThe function operates closely with the Record and Reference classes defined in the same module, using constants such as \"{PDOC\", \"{PS\", \"{BEGIN\", and \"{END}\" to identify different sections of the input data.\"\"\"\n    for line in handle:\n        line = line.rstrip()\n        if line and (not line.startswith('//')):\n            break\n    else:\n        return None\n    record = Record()\n    if not line.startswith('{PDOC'):\n        raise ValueError(\"Line does not start with '{PDOC':\\n%s\" % line)\n    if line[-1] != '}':\n        raise ValueError(f\"I don't understand accession line\\n{line}\")\n    record.accession = line[1:-1]\n    for line in handle:\n        if line.startswith('{PS'):\n            __read_prosite_reference_line(record, line)\n        else:\n            break\n    else:\n        raise ValueError('Unexpected end of stream.')\n    if not line.startswith('{BEGIN'):\n        raise ValueError(\"Line does not start with '{BEGIN':\\n%s\" % line)\n    read_line = __read_text_line\n    for line in handle:\n        if line.startswith('{END}'):\n            for reference in record.references:\n                reference.citation = reference.citation.rstrip()\n                reference.authors = reference.authors.rstrip()\n            return record\n        elif line[0] == '[' and line[3] == ']' and (line[4] == ' '):\n            __read_reference_start(record, line)\n            read_line = __read_reference_line\n        elif line.startswith('+----'):\n            read_line = __read_copyright_line\n        elif read_line:\n            if not read_line(record, line):\n                read_line = None\n    raise ValueError('Unexpected end of stream.')",
        "docstring": "Reads a Prodoc record from the given file handle. This function handles the parsing of Prodoc-specific formatted data, specifically looking for the accession number, Prosite references, text content, and citations within the record. The function ensures the record adheres to expected formats, raising errors for non-compliant lines.\n\nParameters:\n- handle: An I/O stream (file-like object) from which the Prodoc record is read.\n\nReturns:\n- An instance of the Record class, populated with the extracted data from the Prodoc record.\n\nRaises:\n- ValueError: If the record format does not meet specified criteria, such as missing expected prefixes or improper line endings.\n\nThe function operates closely with the Record and Reference classes defined in the same module, using constants such as \"{PDOC\", \"{PS\", \"{BEGIN\", and \"{END}\" to identify different sections of the input data.",
        "signature": "def __read(handle):",
        "type": "Function",
        "class_signature": null
      }
    },
    "Bio/ExPASy/Prosite.py": {
      "read": {
        "code": "def read(handle):\n    \"\"\"Read a single Prosite record from a file handle.\n\nThis function is designed to parse files that contain exactly one Prosite record. It reads the record data using the private `__read` function and ensures that no additional records are present in the file. If any additional data is found after the record, a `ValueError` is raised to indicate that the input was not as expected.\n\nArguments:\n - handle   - A file handle to the Prosite file from which the record will be read.\n\nReturns:\n - A `Record` instance containing the parsed information from the Prosite record.\n\nRaises:\n - ValueError if more than one Prosite record is found in the file.\n\nDependencies:\n - Relies on the private `__read` function for parsing the input file.\n - The `Record` class, which encapsulates the structure and attributes of a Prosite record.\"\"\"\n    'Read one Prosite record.\\n\\n    This function is for parsing Prosite files containing\\n    exactly one record.\\n\\n    Arguments:\\n     - handle   - handle to the file.\\n\\n    '\n    record = __read(handle)\n    remainder = handle.read()\n    if remainder:\n        raise ValueError('More than one Prosite record found')\n    return record",
        "docstring": "Read a single Prosite record from a file handle.\n\nThis function is designed to parse files that contain exactly one Prosite record. It reads the record data using the private `__read` function and ensures that no additional records are present in the file. If any additional data is found after the record, a `ValueError` is raised to indicate that the input was not as expected.\n\nArguments:\n - handle   - A file handle to the Prosite file from which the record will be read.\n\nReturns:\n - A `Record` instance containing the parsed information from the Prosite record.\n\nRaises:\n - ValueError if more than one Prosite record is found in the file.\n\nDependencies:\n - Relies on the private `__read` function for parsing the input file.\n - The `Record` class, which encapsulates the structure and attributes of a Prosite record.",
        "signature": "def read(handle):",
        "type": "Function",
        "class_signature": null
      },
      "__read": {
        "code": "def __read(handle):\n    \"\"\"Read and parse a Prosite record from the given file handle.\n\nThis function processes each line of the Prosite data file, extracting key information based on predefined keywords. It constructs a `Record` object containing attributes such as `name`, `accession`, `created`, and various data statistics. The function handles keywords representing identifiers, dates, descriptions, patterns, matrices, and references, along with special comment and data lines. \n\nParameters:\n- handle: A file handle (iterator) for reading lines from a Prosite data file.\n\nReturns:\n- A `Record` object populated with parsed data from the Prosite file.\n\nRaises:\n- ValueError: If the line format does not match expected keyword patterns or if there is unexpected data.\n\nDependencies:\n- Imports the `re` module for regular expression operations to validate certain data formats. The `Record` class is defined outside this function and is crucial for structuring the parsed data.\"\"\"\n    import re\n    record = None\n    for line in handle:\n        keyword, value = (line[:2], line[5:].rstrip())\n        if keyword == 'ID':\n            record = Record()\n            cols = value.split('; ')\n            if len(cols) != 2:\n                raise ValueError(f\"I don't understand identification line\\n{line}\")\n            record.name = cols[0]\n            record.type = cols[1].rstrip('.')\n        elif keyword == 'AC':\n            record.accession = value.rstrip(';')\n        elif keyword == 'DT':\n            dates = value.rstrip('.').split('; ')\n            if dates[0].endswith((' (CREATED)', ' CREATED')):\n                record.created = dates[0].rsplit(' ', 1)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n            if dates[1].endswith((' (DATA UPDATE)', ' DATA UPDATE')):\n                record.data_update = dates[1].rsplit(' ', 2)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n            if dates[2].endswith((' (INFO UPDATE)', ' INFO UPDATE')):\n                record.info_update = dates[2].rsplit(' ', 2)[0]\n            else:\n                raise ValueError(f\"I don't understand date line\\n{line}\")\n        elif keyword == 'DE':\n            record.description = value\n        elif keyword == 'PA':\n            record.pattern += value\n        elif keyword == 'MA':\n            record.matrix.append(value)\n        elif keyword == 'PP':\n            record.postprocessing.extend(value.split(';'))\n        elif keyword == 'RU':\n            record.rules.append(value)\n        elif keyword == 'NR':\n            cols = value.split(';')\n            for col in cols:\n                if not col:\n                    continue\n                qual, data = (word.lstrip() for word in col.split('='))\n                if qual == '/RELEASE':\n                    release, seqs = data.split(',')\n                    record.nr_sp_release = release\n                    record.nr_sp_seqs = int(seqs)\n                elif qual == '/FALSE_NEG':\n                    record.nr_false_neg = int(data)\n                elif qual == '/PARTIAL':\n                    record.nr_partial = int(data)\n                elif qual in ['/TOTAL', '/POSITIVE', '/UNKNOWN', '/FALSE_POS']:\n                    m = re.match('(\\\\d+)\\\\((\\\\d+)\\\\)', data)\n                    if not m:\n                        raise Exception(f'Broken data {data} in comment line\\n{line!r}')\n                    hits = tuple(map(int, m.groups()))\n                    if qual == '/TOTAL':\n                        record.nr_total = hits\n                    elif qual == '/POSITIVE':\n                        record.nr_positive = hits\n                    elif qual == '/UNKNOWN':\n                        record.nr_unknown = hits\n                    elif qual == '/FALSE_POS':\n                        record.nr_false_pos = hits\n                else:\n                    raise ValueError(f'Unknown qual {qual} in comment line\\n{line!r}')\n        elif keyword == 'CC':\n            cols = value.split(';')\n            for col in cols:\n                if not col or col[:17] == 'Automatic scaling':\n                    continue\n                if col.count('=') == 0:\n                    continue\n                qual, data = (word.lstrip() for word in col.split('='))\n                if qual == '/TAXO-RANGE':\n                    record.cc_taxo_range = data\n                elif qual == '/MAX-REPEAT':\n                    record.cc_max_repeat = data\n                elif qual == '/SITE':\n                    pos, desc = data.split(',')\n                    record.cc_site.append((int(pos), desc))\n                elif qual == '/SKIP-FLAG':\n                    record.cc_skip_flag = data\n                elif qual == '/MATRIX_TYPE':\n                    record.cc_matrix_type = data\n                elif qual == '/SCALING_DB':\n                    record.cc_scaling_db = data\n                elif qual == '/AUTHOR':\n                    record.cc_author = data\n                elif qual == '/FT_KEY':\n                    record.cc_ft_key = data\n                elif qual == '/FT_DESC':\n                    record.cc_ft_desc = data\n                elif qual == '/VERSION':\n                    record.cc_version = data\n                else:\n                    raise ValueError(f'Unknown qual {qual} in comment line\\n{line!r}')\n        elif keyword == 'DR':\n            refs = value.split(';')\n            for ref in refs:\n                if not ref:\n                    continue\n                acc, name, type = (word.strip() for word in ref.split(','))\n                if type == 'T':\n                    record.dr_positive.append((acc, name))\n                elif type == 'F':\n                    record.dr_false_pos.append((acc, name))\n                elif type == 'N':\n                    record.dr_false_neg.append((acc, name))\n                elif type == 'P':\n                    record.dr_potential.append((acc, name))\n                elif type == '?':\n                    record.dr_unknown.append((acc, name))\n                else:\n                    raise ValueError(f\"I don't understand type flag {type}\")\n        elif keyword == '3D':\n            cols = value.split()\n            for id in cols:\n                record.pdb_structs.append(id.rstrip(';'))\n        elif keyword == 'PR':\n            rules = value.split(';')\n            record.prorules.extend(rules)\n        elif keyword == 'DO':\n            record.pdoc = value.rstrip(';')\n        elif keyword == '//':\n            if not record:\n                continue\n            break\n        else:\n            raise ValueError(f'Unknown keyword {keyword} found')\n    else:\n        return\n    if not record:\n        raise ValueError('Unexpected end of stream.')\n    return record",
        "docstring": "Read and parse a Prosite record from the given file handle.\n\nThis function processes each line of the Prosite data file, extracting key information based on predefined keywords. It constructs a `Record` object containing attributes such as `name`, `accession`, `created`, and various data statistics. The function handles keywords representing identifiers, dates, descriptions, patterns, matrices, and references, along with special comment and data lines. \n\nParameters:\n- handle: A file handle (iterator) for reading lines from a Prosite data file.\n\nReturns:\n- A `Record` object populated with parsed data from the Prosite file.\n\nRaises:\n- ValueError: If the line format does not match expected keyword patterns or if there is unexpected data.\n\nDependencies:\n- Imports the `re` module for regular expression operations to validate certain data formats. The `Record` class is defined outside this function and is crucial for structuring the parsed data.",
        "signature": "def __read(handle):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "Bio/ExPASy/__init__.py:get_prodoc_entry": {},
    "Bio/ExPASy/__init__.py:_open": {},
    "Bio/ExPASy/__init__.py:get_prosite_raw": {},
    "Bio/ExPASy/Prodoc.py:read": {},
    "Bio/ExPASy/Prodoc.py:__read": {
      "Bio/ExPASy/Prodoc.py": {
        "Record.__init__": {
          "code": "    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.accession = ''\n        self.prosite_refs = []\n        self.text = ''\n        self.references = []",
          "docstring": "Initialize the class.",
          "signature": "def __init__(self):",
          "type": "Method",
          "class_signature": "class Record:"
        },
        "__read_prosite_reference_line": {
          "code": "def __read_prosite_reference_line(record, line):\n    line = line.rstrip()\n    if line[-1] != '}':\n        raise ValueError(f\"I don't understand the Prosite reference on line\\n{line}\")\n    acc, name = line[1:-1].split('; ')\n    record.prosite_refs.append((acc, name))",
          "docstring": "",
          "signature": "def __read_prosite_reference_line(record, line):",
          "type": "Function",
          "class_signature": null
        },
        "__read_text_line": {
          "code": "def __read_text_line(record, line):\n    record.text += line\n    return True",
          "docstring": "",
          "signature": "def __read_text_line(record, line):",
          "type": "Function",
          "class_signature": null
        },
        "__read_reference_start": {
          "code": "def __read_reference_start(record, line):\n    reference = Reference()\n    reference.number = line[1:3].strip()\n    if line[1] == 'E':\n        reference.citation = line[4:].strip()\n    else:\n        reference.authors = line[4:].strip()\n    record.references.append(reference)",
          "docstring": "",
          "signature": "def __read_reference_start(record, line):",
          "type": "Function",
          "class_signature": null
        },
        "__read_reference_line": {
          "code": "def __read_reference_line(record, line):\n    if not line.strip():\n        return False\n    reference = record.references[-1]\n    if line.startswith('     '):\n        if reference.authors[-1] == ',':\n            reference.authors += line[4:].rstrip()\n        else:\n            reference.citation += line[5:]\n        return True\n    raise Exception(f\"I don't understand the reference line\\n{line}\")",
          "docstring": "",
          "signature": "def __read_reference_line(record, line):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "Bio/ExPASy/__init__.py:get_prosite_entry": {},
    "Bio/ExPASy/Prosite.py:read": {},
    "Bio/ExPASy/Prosite.py:__read": {
      "Bio/ExPASy/Prosite.py": {
        "Record.__init__": {
          "code": "    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.name = ''\n        self.type = ''\n        self.accession = ''\n        self.created = ''\n        self.data_update = ''\n        self.info_update = ''\n        self.pdoc = ''\n        self.description = ''\n        self.pattern = ''\n        self.matrix = []\n        self.rules = []\n        self.prorules = []\n        self.postprocessing = []\n        self.nr_sp_release = ''\n        self.nr_sp_seqs = ''\n        self.nr_total = (None, None)\n        self.nr_positive = (None, None)\n        self.nr_unknown = (None, None)\n        self.nr_false_pos = (None, None)\n        self.nr_false_neg = None\n        self.nr_partial = None\n        self.cc_taxo_range = ''\n        self.cc_max_repeat = ''\n        self.cc_site = []\n        self.cc_skip_flag = ''\n        self.dr_positive = []\n        self.dr_false_neg = []\n        self.dr_false_pos = []\n        self.dr_potential = []\n        self.dr_unknown = []\n        self.pdb_structs = []",
          "docstring": "Initialize the class.",
          "signature": "def __init__(self):",
          "type": "Method",
          "class_signature": "class Record:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: biopython-test_ExPASy\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 Bio/\n    \u2514\u2500\u2500 ExPASy/\n        \u251c\u2500\u2500 Prodoc.py\n        \u2502   \u251c\u2500\u2500 __read\n        \u2502   \u2514\u2500\u2500 read\n        \u251c\u2500\u2500 Prosite.py\n        \u2502   \u251c\u2500\u2500 __read\n        \u2502   \u2514\u2500\u2500 read\n        \u2514\u2500\u2500 __init__.py\n            \u251c\u2500\u2500 _open\n            \u251c\u2500\u2500 get_prodoc_entry\n            \u251c\u2500\u2500 get_prosite_entry\n            \u2514\u2500\u2500 get_prosite_raw\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides an interface for interacting with ExPASy (Expert Protein Analysis System) online resources, specifically the Prosite and Prodoc databases, which are widely used in bioinformatics for protein sequence analysis. It enables users to retrieve and parse raw records and HTML entries for specific Prosite patterns and Prodoc documentation files, facilitating access to protein domain and motif information. By streamlining the retrieval and validation of biological data, the module simplifies workflows for researchers and developers working on protein characterization and annotation, offering a reliable mechanism for programmatically accessing essential bioinformatics resources.\n\n## FILE 1: Bio/ExPASy/__init__.py\n\n- FUNCTION NAME: get_prodoc_entry\n  - SIGNATURE: def get_prodoc_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry'):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a PRODOC entry from ExPASy in HTML format.\n\nParameters:\n- id (str): The identifier for the PRODOC entry to be retrieved.\n- cgi (str, optional): The URL for the CGI script to fetch the PRODOC entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prodoc-entry\".\n\nReturns:\n- A text handle (an io.TextIOWrapper) that allows access to the HTML content of the requested PRODOC entry.\n\nUsage:\nThis function interacts with the ExPASy database and returns an HTML-formatted page. If the specified entry does not exist, ExPASy will return a page indicating that no entry is available for the given identifier.\n\nDependencies:\nThis function uses the private helper function _open to handle the URL opening and ensure the response is properly encoded in UTF-8.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/__init__.py:_open\n\n- FUNCTION NAME: get_prosite_raw\n  - SIGNATURE: def get_prosite_raw(id, cgi=None):\n  - DOCSTRING: \n```python\n\"\"\"\nGet a text handle to a raw PROSITE or PRODOC record at ExPASy.\n\nThis function retrieves raw data associated with a specified PROSITE entry ID from ExPASy. If the entry does not exist, it raises a ValueError.\n\nParameters:\n- id (str): The identifier of the PROSITE entry to fetch.\n- cgi (str, optional): Deprecated parameter for specifying the CGI URL, not used in current functionality.\n\nReturns:\n- io.TextIOWrapper: A text handle containing the raw PROSITE or PRODOC data in UTF-8 encoding.\n\nRaises:\n- ValueError: If the identifier does not correspond to an existing entry on ExPASy.\n\nThe function relies on the private _open function which handles URL opening and encoding. The URLs used are in the form \"https://prosite.expasy.org/{id}.txt\". If the entry is not found (404 error), a ValueError is raised with a specific message.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/__init__.py:_open\n\n- FUNCTION NAME: _open\n  - SIGNATURE: def _open(url):\n  - DOCSTRING: \n```python\n\"\"\"\nOpen a URL and return a text handle with UTF-8 encoding.\n\nParameters:\n- url (str): The URL of the resource to open.\n\nReturns:\n- TextIOWrapper: A text handle to read the content of the URL as text, with the encoding set to UTF-8. The handle also contains the original URL as an attribute `url`.\n\nThis function is primarily used by other functions in the module to access ExPASy resources, converting the raw response into a more suitable format for text processing. It utilizes the `urlopen` function from the `urllib.request` module to perform the URL request.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/__init__.py:get_prosite_raw\n    - Bio/ExPASy/__init__.py:get_prodoc_entry\n    - Bio/ExPASy/__init__.py:get_prosite_entry\n\n- FUNCTION NAME: get_prosite_entry\n  - SIGNATURE: def get_prosite_entry(id, cgi='https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry'):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a PROSITE entry from ExPASy as an HTML document.\n\nParameters:\n- id (str): The unique identifier for the PROSITE entry to be fetched.\n- cgi (str, optional): The CGI URL for accessing the PROSITE entry. Defaults to \"https://prosite.expasy.org/cgi-bin/prosite/get-prosite-entry\".\n\nReturns:\n- A text handle to the HTML content of the requested PROSITE entry. The handle should be used in a context manager (with statement) to ensure proper resource management.\n\nNotes:\n- If the specified entry does not exist, ExPASy will return an HTML page indicating that no entry is available for the provided id.\n- This function internally calls `_open`, which handles the URL request and ensures the response is decoded in UTF-8.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/__init__.py:_open\n\n## FILE 2: Bio/ExPASy/Prodoc.py\n\n- FUNCTION NAME: __read\n  - SIGNATURE: def __read(handle):\n  - DOCSTRING: \n```python\n\"\"\"\nReads a Prodoc record from the given file handle. This function handles the parsing of Prodoc-specific formatted data, specifically looking for the accession number, Prosite references, text content, and citations within the record. The function ensures the record adheres to expected formats, raising errors for non-compliant lines.\n\nParameters:\n- handle: An I/O stream (file-like object) from which the Prodoc record is read.\n\nReturns:\n- An instance of the Record class, populated with the extracted data from the Prodoc record.\n\nRaises:\n- ValueError: If the record format does not meet specified criteria, such as missing expected prefixes or improper line endings.\n\nThe function operates closely with the Record and Reference classes defined in the same module, using constants such as \"{PDOC\", \"{PS\", \"{BEGIN\", and \"{END}\" to identify different sections of the input data.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/Prodoc.py:__read_text_line\n    - Bio/ExPASy/Prodoc.py:Record:__init__\n    - Bio/ExPASy/Prodoc.py:__read_reference_start\n    - Bio/ExPASy/Prodoc.py:__read_prosite_reference_line\n    - Bio/ExPASy/Prodoc.py:__read_reference_line\n    - Bio/ExPASy/Prodoc.py:read\n\n- FUNCTION NAME: read\n  - SIGNATURE: def read(handle):\n  - DOCSTRING: \n```python\n\"\"\"\nRead in a single Prodoc record from a file handle.\n\nParameters:\n- handle (file-like object): An open file handle that contains a Prodoc file with exactly one record.\n\nReturns:\n- Record: An instance of the Record class containing the parsed data from the Prodoc record, including the accession number, references, text, and prosite references.\n\nRaises:\n- ValueError: If more than one Prodoc record is found in the file or if the Prodoc record format is invalid (e.g., missing expected markers like '{PDOC', '{BEGIN', etc.). \n\nThis function relies on the private __read function to perform the actual reading and parsing of the Prodoc data. It ensures that the handle is consumed completely after reading one record.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/Prodoc.py:__read\n\n## FILE 3: Bio/ExPASy/Prosite.py\n\n- FUNCTION NAME: read\n  - SIGNATURE: def read(handle):\n  - DOCSTRING: \n```python\n\"\"\"\nRead a single Prosite record from a file handle.\n\nThis function is designed to parse files that contain exactly one Prosite record. It reads the record data using the private `__read` function and ensures that no additional records are present in the file. If any additional data is found after the record, a `ValueError` is raised to indicate that the input was not as expected.\n\nArguments:\n - handle   - A file handle to the Prosite file from which the record will be read.\n\nReturns:\n - A `Record` instance containing the parsed information from the Prosite record.\n\nRaises:\n - ValueError if more than one Prosite record is found in the file.\n\nDependencies:\n - Relies on the private `__read` function for parsing the input file.\n - The `Record` class, which encapsulates the structure and attributes of a Prosite record.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/Prosite.py:__read\n\n- FUNCTION NAME: __read\n  - SIGNATURE: def __read(handle):\n  - DOCSTRING: \n```python\n\"\"\"\nRead and parse a Prosite record from the given file handle.\n\nThis function processes each line of the Prosite data file, extracting key information based on predefined keywords. It constructs a `Record` object containing attributes such as `name`, `accession`, `created`, and various data statistics. The function handles keywords representing identifiers, dates, descriptions, patterns, matrices, and references, along with special comment and data lines. \n\nParameters:\n- handle: A file handle (iterator) for reading lines from a Prosite data file.\n\nReturns:\n- A `Record` object populated with parsed data from the Prosite file.\n\nRaises:\n- ValueError: If the line format does not match expected keyword patterns or if there is unexpected data.\n\nDependencies:\n- Imports the `re` module for regular expression operations to validate certain data formats. The `Record` class is defined outside this function and is crucial for structuring the parsed data.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - Bio/ExPASy/Prosite.py:read\n    - Bio/ExPASy/Prosite.py:Record:__init__\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "Bio/ExPASy/__init__.py": "\"\"\"Code to access resources at ExPASy over the WWW.\n\nSee https://www.expasy.org/\n\n\nFunctions:\n - get_prodoc_entry  Interface to the get-prodoc-entry CGI script.\n - get_prosite_entry Interface to the get-prosite-entry CGI script.\n - get_prosite_raw   Interface to the get-prosite-raw CGI script.\n - get_sprot_raw     Interface to the get-sprot-raw CGI script.\n\n\"\"\"\nimport io\nfrom urllib.error import HTTPError\nfrom urllib.request import urlopen\n\ndef get_sprot_raw(id):\n    \"\"\"Get a text handle to a raw SwissProt entry at ExPASy.\n\n    For an ID of XXX, fetches http://www.uniprot.org/uniprot/XXX.txt\n    (as per the https://www.expasy.org/expasy_urls.html documentation).\n\n    >>> from Bio import ExPASy\n    >>> from Bio import SwissProt\n    >>> with ExPASy.get_sprot_raw(\"O23729\") as handle:\n    ...     record = SwissProt.read(handle)\n    ...\n    >>> print(record.entry_name)\n    CHS3_BROFI\n\n    This function raises a ValueError if the identifier does not exist:\n\n    >>> ExPASy.get_sprot_raw(\"DOES_NOT_EXIST\")\n    Traceback (most recent call last):\n        ...\n    ValueError: Failed to find SwissProt entry 'DOES_NOT_EXIST'\n\n    \"\"\"\n    try:\n        handle = _open(f'http://www.uniprot.org/uniprot/{id}.txt')\n    except HTTPError as exception:\n        if exception.code in (400, 404):\n            raise ValueError(f\"Failed to find SwissProt entry '{id}'\") from None\n        else:\n            raise\n    return handle",
    "Bio/ExPASy/Prodoc.py": "\"\"\"Code to work with the prosite.doc file from Prosite.\n\nSee https://www.expasy.org/prosite/\n\nTested with:\n - Release 15.0, July 1998\n - Release 16.0, July 1999\n - Release 20.22, 13 November 2007\n - Release 20.43, 10 February 2009\n\nFunctions:\n - read               Read a Prodoc file containing exactly one Prodoc entry.\n - parse              Iterates over entries in a Prodoc file.\n\nClasses:\n - Record             Holds Prodoc data.\n - Reference          Holds data from a Prodoc reference.\n\n\"\"\"\n\ndef parse(handle):\n    \"\"\"Iterate over the records in a Prodoc file.\"\"\"\n    while True:\n        record = __read(handle)\n        if not record:\n            return\n        yield record\n\nclass Record:\n    \"\"\"Holds information from a Prodoc record.\n\n    Attributes:\n     - accession      Accession number of the record.\n     - prosite_refs   List of tuples (prosite accession, prosite name).\n     - text           Free format text.\n     - references     List of reference objects.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.accession = ''\n        self.prosite_refs = []\n        self.text = ''\n        self.references = []\n\nclass Reference:\n    \"\"\"Holds information from a Prodoc citation.\n\n    Attributes:\n     - number     Number of the reference. (string)\n     - authors    Names of the authors.\n     - citation   Describes the citation.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.number = ''\n        self.authors = ''\n        self.citation = ''\n\ndef __read_prosite_reference_line(record, line):\n    line = line.rstrip()\n    if line[-1] != '}':\n        raise ValueError(f\"I don't understand the Prosite reference on line\\n{line}\")\n    acc, name = line[1:-1].split('; ')\n    record.prosite_refs.append((acc, name))\n\ndef __read_text_line(record, line):\n    record.text += line\n    return True\n\ndef __read_reference_start(record, line):\n    reference = Reference()\n    reference.number = line[1:3].strip()\n    if line[1] == 'E':\n        reference.citation = line[4:].strip()\n    else:\n        reference.authors = line[4:].strip()\n    record.references.append(reference)\n\ndef __read_reference_line(record, line):\n    if not line.strip():\n        return False\n    reference = record.references[-1]\n    if line.startswith('     '):\n        if reference.authors[-1] == ',':\n            reference.authors += line[4:].rstrip()\n        else:\n            reference.citation += line[5:]\n        return True\n    raise Exception(f\"I don't understand the reference line\\n{line}\")\n\ndef __read_copyright_line(record, line):\n    if line.startswith('+----'):\n        return False\n    return True",
    "Bio/ExPASy/Prosite.py": "\"\"\"Parser for the prosite dat file from Prosite at ExPASy.\n\nSee https://www.expasy.org/prosite/\n\nTested with:\n - Release 20.43, 10-Feb-2009\n - Release 2017_03 of 15-Mar-2017.\n\nFunctions:\n - read                  Reads a Prosite file containing one Prosite record\n - parse                 Iterates over records in a Prosite file.\n\nClasses:\n - Record                Holds Prosite data.\n\n\"\"\"\n\ndef parse(handle):\n    \"\"\"Parse Prosite records.\n\n    This function is for parsing Prosite files containing multiple\n    records.\n\n    Arguments:\n     - handle   - handle to the file.\n\n    \"\"\"\n    while True:\n        record = __read(handle)\n        if not record:\n            break\n        yield record\n\nclass Record:\n    \"\"\"Holds information from a Prosite record.\n\n    Main attributes:\n     - name           ID of the record.  e.g. ADH_ZINC\n     - type           Type of entry.  e.g. PATTERN, MATRIX, or RULE\n     - accession      e.g. PS00387\n     - created        Date the entry was created.  (MMM-YYYY for releases\n       before January 2017, DD-MMM-YYYY since January 2017)\n     - data_update    Date the 'primary' data was last updated.\n     - info_update    Date data other than 'primary' data was last updated.\n     - pdoc           ID of the PROSITE DOCumentation.\n     - description    Free-format description.\n     - pattern        The PROSITE pattern.  See docs.\n     - matrix         List of strings that describes a matrix entry.\n     - rules          List of rule definitions (from RU lines).  (strings)\n     - prorules       List of prorules (from PR lines). (strings)\n\n    NUMERICAL RESULTS:\n     - nr_sp_release  SwissProt release.\n     - nr_sp_seqs     Number of seqs in that release of Swiss-Prot. (int)\n     - nr_total       Number of hits in Swiss-Prot.  tuple of (hits, seqs)\n     - nr_positive    True positives.  tuple of (hits, seqs)\n     - nr_unknown     Could be positives.  tuple of (hits, seqs)\n     - nr_false_pos   False positives.  tuple of (hits, seqs)\n     - nr_false_neg   False negatives.  (int)\n     - nr_partial     False negatives, because they are fragments. (int)\n\n    COMMENTS:\n     - cc_taxo_range  Taxonomic range.  See docs for format\n     - cc_max_repeat  Maximum number of repetitions in a protein\n     - cc_site        Interesting site.  list of tuples (pattern pos, desc.)\n     - cc_skip_flag   Can this entry be ignored?\n     - cc_matrix_type\n     - cc_scaling_db\n     - cc_author\n     - cc_ft_key\n     - cc_ft_desc\n     - cc_version     version number (introduced in release 19.0)\n\n    The following are all lists if tuples (swiss-prot accession, swiss-prot name).\n\n    DATA BANK REFERENCES:\n     - dr_positive\n     - dr_false_neg\n     - dr_false_pos\n     - dr_potential   Potential hits, but fingerprint region not yet available.\n     - dr_unknown     Could possibly belong\n     - pdb_structs    List of PDB entries.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the class.\"\"\"\n        self.name = ''\n        self.type = ''\n        self.accession = ''\n        self.created = ''\n        self.data_update = ''\n        self.info_update = ''\n        self.pdoc = ''\n        self.description = ''\n        self.pattern = ''\n        self.matrix = []\n        self.rules = []\n        self.prorules = []\n        self.postprocessing = []\n        self.nr_sp_release = ''\n        self.nr_sp_seqs = ''\n        self.nr_total = (None, None)\n        self.nr_positive = (None, None)\n        self.nr_unknown = (None, None)\n        self.nr_false_pos = (None, None)\n        self.nr_false_neg = None\n        self.nr_partial = None\n        self.cc_taxo_range = ''\n        self.cc_max_repeat = ''\n        self.cc_site = []\n        self.cc_skip_flag = ''\n        self.dr_positive = []\n        self.dr_false_neg = []\n        self.dr_false_pos = []\n        self.dr_potential = []\n        self.dr_unknown = []\n        self.pdb_structs = []"
  },
  "call_tree": {
    "Tests/test_ExPASy.py:ExPASyOnlineTests:test_prodoc_html": {
      "Bio/ExPASy/__init__.py:get_prodoc_entry": {
        "Bio/ExPASy/__init__.py:_open": {}
      }
    },
    "Tests/test_ExPASy.py:ExPASyOnlineTests:test_prodoc_raw": {
      "Bio/ExPASy/__init__.py:get_prosite_raw": {
        "Bio/ExPASy/__init__.py:_open": {}
      },
      "Bio/ExPASy/Prodoc.py:read": {
        "Bio/ExPASy/Prodoc.py:__read": {
          "Bio/ExPASy/Prodoc.py:Record:__init__": {},
          "Bio/ExPASy/Prodoc.py:__read_prosite_reference_line": {},
          "Bio/ExPASy/Prodoc.py:__read_text_line": {},
          "Bio/ExPASy/Prodoc.py:__read_reference_start": {
            "Bio/ExPASy/Prodoc.py:Reference:__init__": {}
          },
          "Bio/ExPASy/Prodoc.py:__read_reference_line": {}
        }
      }
    },
    "Tests/test_ExPASy.py:ExPASyOnlineTests:test_prosite_html": {
      "Bio/ExPASy/__init__.py:get_prosite_entry": {
        "Bio/ExPASy/__init__.py:_open": {}
      }
    },
    "Tests/test_ExPASy.py:ExPASyOnlineTests:test_prosite_raw": {
      "Bio/ExPASy/__init__.py:get_prosite_raw": {
        "Bio/ExPASy/__init__.py:_open": {}
      },
      "Bio/ExPASy/Prosite.py:read": {
        "Bio/ExPASy/Prosite.py:__read": {
          "Bio/ExPASy/Prosite.py:Record:__init__": {}
        }
      }
    }
  }
}