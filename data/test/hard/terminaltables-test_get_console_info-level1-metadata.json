{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_get_console_info",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_terminal_io/test_get_console_info.py",
  "test_code": "\"\"\"Test function in module.\"\"\"\n\nimport ctypes\n\nimport pytest\n\nfrom terminaltables3.terminal_io import (\n    get_console_info,\n    INVALID_HANDLE_VALUE,\n    IS_WINDOWS,\n)\n\nfrom tests.test_terminal_io import MockKernel32\n\n\ndef test():\n    \"\"\"Test function.\"\"\"\n    # Test live WinError.\n    if IS_WINDOWS:\n        with pytest.raises(OSError):\n            get_console_info(ctypes.windll.kernel32, 0)\n\n    # Test INVALID_HANDLE_VALUE.\n    kernel32 = MockKernel32(stderr=1)\n    with pytest.raises(OSError):\n        get_console_info(kernel32, INVALID_HANDLE_VALUE)\n\n    # Test no error with mock methods.\n    width, height = get_console_info(kernel32, 1)\n    assert width == 119\n    assert height == 29\n",
  "GT_file_code": {
    "terminaltables3/terminal_io.py": "\"\"\"Get info about the current terminal window/screen buffer.\"\"\"\n\nimport ctypes\nimport struct\nimport sys\nfrom typing import Tuple, Union\n\nDEFAULT_HEIGHT = 24\nDEFAULT_WIDTH = 79\nINVALID_HANDLE_VALUE = -1\nIS_WINDOWS = sys.platform == \"win32\"\nSTD_ERROR_HANDLE = -12\nSTD_OUTPUT_HANDLE = -11\n\n\ndef get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n    \"\"\"Get information about this current console window (Windows only).\n\n    https://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\n\n    :raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\n\n    :param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\n    :param int handle: stderr or stdout handle.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if handle == INVALID_HANDLE_VALUE:\n        raise OSError(\"Invalid handle.\")\n\n    # Query Win32 API.\n    lpcsbi = ctypes.create_string_buffer(22)  # Populated by GetConsoleScreenBufferInfo.\n    if not kernel32.GetConsoleScreenBufferInfo(handle, lpcsbi):\n        raise ctypes.WinError()  # Subclass of OSError.\n\n    # Parse data.\n    left, top, right, bottom = struct.unpack(\"hhhhHhhhhhh\", lpcsbi.raw)[5:-2]\n    width, height = right - left, bottom - top\n    return width, height\n\n\ndef terminal_size(kernel32=None) -> Tuple[int, int]:\n    \"\"\"Get the width and height of the terminal.\n\n    http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/\n    http://stackoverflow.com/questions/17993814/why-the-irrelevant-code-made-a-difference\n\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            return get_console_info(kernel32, kernel32.GetStdHandle(STD_ERROR_HANDLE))\n        except OSError:\n            try:\n                return get_console_info(\n                    kernel32, kernel32.GetStdHandle(STD_OUTPUT_HANDLE)\n                )\n            except OSError:\n                return DEFAULT_WIDTH, DEFAULT_HEIGHT\n\n    try:\n        device = __import__(\"fcntl\").ioctl(\n            0, __import__(\"termios\").TIOCGWINSZ, \"\\0\\0\\0\\0\\0\\0\\0\\0\"\n        )\n    except OSError:\n        return DEFAULT_WIDTH, DEFAULT_HEIGHT\n    height, width = struct.unpack(\"hhhh\", device)[:2]\n    return width, height\n\n\ndef set_terminal_title(title: Union[str, bytes], kernel32=None) -> bool:\n    \"\"\"Set the terminal title.\n\n    :param title: The title to set (string, unicode, bytes accepted).\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: If title changed successfully (Windows only, always True on Linux/OSX).\n    :rtype: bool\n    \"\"\"\n    try:\n        title_bytes = title.encode(\"utf-8\")\n    except AttributeError:\n        title_bytes = title\n\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            is_ascii = all(ord(c) < 128 for c in title)  # str/unicode.\n        except TypeError:\n            is_ascii = all(c < 128 for c in title)  # bytes.\n        if is_ascii:\n            return kernel32.SetConsoleTitleA(title_bytes) != 0\n        return kernel32.SetConsoleTitleW(title) != 0\n\n    # Linux/OSX.\n    sys.stdout.write(b\"\\033]0;\" + title_bytes + b\"\\007\")\n    return True\n"
  },
  "GT_src_dict": {
    "terminaltables3/terminal_io.py": {
      "get_console_info": {
        "code": "def get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n    \"\"\"Get information about the current console window's dimensions (width and height) on Windows systems.\n\nThis function interfaces with the Windows API to retrieve the console screen buffer's information using a specified handle for standard output or error. It raises an OSError if the provided handle is invalid or if the API call fails. The HANDLE constants defined outside this function, such as INVALID_HANDLE_VALUE, are used to check for invalid handles, and the function depends on the ctypes module to interface with the Windows kernel32 library.\n\nParameters:\n- kernel32 (ctypes.windll.kernel32): The loaded kernel32 instance for API calls (default is required for actual calls).\n- handle (int): The handle for either stderr or stdout.\n\nReturns:\n- Tuple[int, int]: A tuple containing the width (number of characters) and height (number of lines) of the terminal.\n\nRaises:\n- OSError: If the handle is invalid or if the API call fails.\"\"\"\n    'Get information about this current console window (Windows only).\\n\\n    https://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\\n\\n    :raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\\n\\n    :param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\\n    :param int handle: stderr or stdout handle.\\n\\n    :return: Width (number of characters) and height (number of lines) of the terminal.\\n    :rtype: tuple\\n    '\n    if handle == INVALID_HANDLE_VALUE:\n        raise OSError('Invalid handle.')\n    lpcsbi = ctypes.create_string_buffer(22)\n    if not kernel32.GetConsoleScreenBufferInfo(handle, lpcsbi):\n        raise ctypes.WinError()\n    left, top, right, bottom = struct.unpack('hhhhHhhhhhh', lpcsbi.raw)[5:-2]\n    width, height = (right - left, bottom - top)\n    return (width, height)",
        "docstring": "Get information about the current console window's dimensions (width and height) on Windows systems.\n\nThis function interfaces with the Windows API to retrieve the console screen buffer's information using a specified handle for standard output or error. It raises an OSError if the provided handle is invalid or if the API call fails. The HANDLE constants defined outside this function, such as INVALID_HANDLE_VALUE, are used to check for invalid handles, and the function depends on the ctypes module to interface with the Windows kernel32 library.\n\nParameters:\n- kernel32 (ctypes.windll.kernel32): The loaded kernel32 instance for API calls (default is required for actual calls).\n- handle (int): The handle for either stderr or stdout.\n\nReturns:\n- Tuple[int, int]: A tuple containing the width (number of characters) and height (number of lines) of the terminal.\n\nRaises:\n- OSError: If the handle is invalid or if the API call fails.",
        "signature": "def get_console_info(kernel32, handle: int) -> Tuple[int, int]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "terminaltables3/terminal_io.py:get_console_info": {
      "tests/test_terminal_io/__init__.py": {
        "MockKernel32.GetConsoleScreenBufferInfo": {
          "code": "    def GetConsoleScreenBufferInfo(self, handle, lpcsbi):  # noqa\n        \"\"\"Mock GetConsoleScreenBufferInfo.\n\n        :param handle: Unused handle.\n        :param lpcsbi: ctypes.create_string_buffer() return value.\n        \"\"\"\n        if handle == self.stderr:\n            lpcsbi.raw = self.csbi_err\n        else:\n            lpcsbi.raw = self.csbi_out\n        return 1",
          "docstring": "Mock GetConsoleScreenBufferInfo.\n\n:param handle: Unused handle.\n:param lpcsbi: ctypes.create_string_buffer() return value.",
          "signature": "def GetConsoleScreenBufferInfo(self, handle, lpcsbi):",
          "type": "Method",
          "class_signature": "class MockKernel32:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: terminaltables-test_get_console_info\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u2514\u2500\u2500 terminal_io.py\n        \u2514\u2500\u2500 get_console_info\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module validates the functionality of retrieving console dimensions and handling console-related errors in terminal environments. It ensures compatibility with Windows systems by interacting with platform-specific APIs to fetch console metadata such as width and height, while appropriately managing invalid or erroneous conditions. By providing robust mechanisms to verify edge cases and failure states, the module aids developers in reliably accessing and managing terminal layout information, reducing potential runtime errors when working with console-based applications.\n\n## FILE 1: terminaltables3/terminal_io.py\n\n- FUNCTION NAME: get_console_info\n  - SIGNATURE: def get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet information about the current console window's dimensions (width and height) on Windows systems.\n\nThis function interfaces with the Windows API to retrieve the console screen buffer's information using a specified handle for standard output or error. It raises an OSError if the provided handle is invalid or if the API call fails. The HANDLE constants defined outside this function, such as INVALID_HANDLE_VALUE, are used to check for invalid handles, and the function depends on the ctypes module to interface with the Windows kernel32 library.\n\nParameters:\n- kernel32 (ctypes.windll.kernel32): The loaded kernel32 instance for API calls (default is required for actual calls).\n- handle (int): The handle for either stderr or stdout.\n\nReturns:\n- Tuple[int, int]: A tuple containing the width (number of characters) and height (number of lines) of the terminal.\n\nRaises:\n- OSError: If the handle is invalid or if the API call fails.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/test_terminal_io/__init__.py:MockKernel32:GetConsoleScreenBufferInfo\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/terminal_io.py": "\"\"\"Get info about the current terminal window/screen buffer.\"\"\"\nimport ctypes\nimport struct\nimport sys\nfrom typing import Tuple, Union\nDEFAULT_HEIGHT = 24\nDEFAULT_WIDTH = 79\nINVALID_HANDLE_VALUE = -1\nIS_WINDOWS = sys.platform == 'win32'\nSTD_ERROR_HANDLE = -12\nSTD_OUTPUT_HANDLE = -11\n\ndef terminal_size(kernel32=None) -> Tuple[int, int]:\n    \"\"\"Get the width and height of the terminal.\n\n    http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/\n    http://stackoverflow.com/questions/17993814/why-the-irrelevant-code-made-a-difference\n\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            return get_console_info(kernel32, kernel32.GetStdHandle(STD_ERROR_HANDLE))\n        except OSError:\n            try:\n                return get_console_info(kernel32, kernel32.GetStdHandle(STD_OUTPUT_HANDLE))\n            except OSError:\n                return (DEFAULT_WIDTH, DEFAULT_HEIGHT)\n    try:\n        device = __import__('fcntl').ioctl(0, __import__('termios').TIOCGWINSZ, '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    except OSError:\n        return (DEFAULT_WIDTH, DEFAULT_HEIGHT)\n    height, width = struct.unpack('hhhh', device)[:2]\n    return (width, height)\n\ndef set_terminal_title(title: Union[str, bytes], kernel32=None) -> bool:\n    \"\"\"Set the terminal title.\n\n    :param title: The title to set (string, unicode, bytes accepted).\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: If title changed successfully (Windows only, always True on Linux/OSX).\n    :rtype: bool\n    \"\"\"\n    try:\n        title_bytes = title.encode('utf-8')\n    except AttributeError:\n        title_bytes = title\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            is_ascii = all((ord(c) < 128 for c in title))\n        except TypeError:\n            is_ascii = all((c < 128 for c in title))\n        if is_ascii:\n            return kernel32.SetConsoleTitleA(title_bytes) != 0\n        return kernel32.SetConsoleTitleW(title) != 0\n    sys.stdout.write(b'\\x1b]0;' + title_bytes + b'\\x07')\n    return True"
  },
  "call_tree": {
    "tests/test_terminal_io/test_get_console_info.py:test": {
      "tests/test_terminal_io/__init__.py:MockKernel32:__init__": {},
      "terminaltables3/terminal_io.py:get_console_info": {
        "tests/test_terminal_io/__init__.py:MockKernel32:GetConsoleScreenBufferInfo": {}
      }
    }
  }
}