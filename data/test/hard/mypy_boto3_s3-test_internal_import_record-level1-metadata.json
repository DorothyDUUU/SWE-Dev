{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_internal_import_record",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_internal_import_record.py",
  "test_code": "from unittest.mock import MagicMock\n\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\n\n\nclass TestImportRecord:\n    def test_init(self) -> None:\n        service_name_mock = MagicMock()\n        service_name_mock.name = \"service_name\"\n        result = InternalImportRecord(service_name_mock, \"name\", \"alias\")\n        assert result.source.render() == \".service_name\"\n        assert result.name == \"name\"\n        assert result.alias == \"alias\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/import_helpers/internal_import_record.py": "\"\"\"\nHelper for Python import strings with not set master module name.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass InternalImportRecord(ImportRecord):\n    \"\"\"\n    Helper for Python import strings with not set master module name.\n\n    Arguments:\n        service_module_name -- Service module name.\n        name -- Import name.\n        alias -- Import local name.\n    \"\"\"\n\n    def __init__(\n        self,\n        service_module_name: ServiceModuleName,\n        name: str = \"\",\n        alias: str = \"\",\n    ) -> None:\n        self._local_source = ImportString(service_module_name.name)\n        source = ImportString(\"\", *self._local_source.parts)\n        super().__init__(source, name=name, alias=alias)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string as a dot-separated string.\n\nThis method combines all parts of the import string, which were initialized through the constructor, into a single valid Python import statement. The parts are joined using a dot ('.') separator to form a standard import string format. \n\nReturns:\n    str: A dot-separated string representing the import.\n\nThis method relies on the `parts` attribute, which is a tuple of string components defined during the initialization of the ImportString instance. It does not take any input parameters nor does it have side effects.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string as a dot-separated string.\n\nThis method combines all parts of the import string, which were initialized through the constructor, into a single valid Python import statement. The parts are joined using a dot ('.') separator to form a standard import string format. \n\nReturns:\n    str: A dot-separated string representing the import.\n\nThis method relies on the `parts` attribute, which is a tuple of string components defined during the initialization of the ImportString instance. It does not take any input parameters nor does it have side effects.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/import_helpers/internal_import_record.py": {
      "InternalImportRecord.__init__": {
        "code": "    def __init__(self, service_module_name: ServiceModuleName, name: str='', alias: str='') -> None:\n        \"\"\"Initializes an instance of the InternalImportRecord class, which helps build Python import strings without a master module name. It takes the service module name, import name, and alias, and sets up the local source for the import.\n\nArgs:\n    service_module_name (ServiceModuleName): The service module name used to create the local source for the import string.\n    name (str, optional): The name of the import. Defaults to an empty string.\n    alias (str, optional): The local alias for the import. Defaults to an empty string.\n\nReturns:\n    None: This method does not return a value but initializes the instance attributes.\n\nDependencies:\n- ServiceModuleName: An enum that represents the service module names, used to derive the local source name.\n- ImportString: A helper class that constructs the import string based on provided parts. The instance of this class is created with the service module name and further processed to create the final source for the ImportRecord.\"\"\"\n        self._local_source = ImportString(service_module_name.name)\n        source = ImportString('', *self._local_source.parts)\n        super().__init__(source, name=name, alias=alias)",
        "docstring": "Initializes an instance of the InternalImportRecord class, which helps build Python import strings without a master module name. It takes the service module name, import name, and alias, and sets up the local source for the import.\n\nArgs:\n    service_module_name (ServiceModuleName): The service module name used to create the local source for the import string.\n    name (str, optional): The name of the import. Defaults to an empty string.\n    alias (str, optional): The local alias for the import. Defaults to an empty string.\n\nReturns:\n    None: This method does not return a value but initializes the instance attributes.\n\nDependencies:\n- ServiceModuleName: An enum that represents the service module names, used to derive the local source name.\n- ImportString: A helper class that constructs the import string based on provided parts. The instance of this class is created with the service module name and further processed to create the final source for the ImportRecord.",
        "signature": "def __init__(self, service_module_name: ServiceModuleName, name: str='', alias: str='') -> None:",
        "type": "Method",
        "class_signature": "class InternalImportRecord(ImportRecord):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/internal_import_record.py:InternalImportRecord:__init__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__init__": {
          "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
          "docstring": "",
          "signature": "def __init__(self, parent: str, *parts: str) -> None:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.__init__": {
          "code": "    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback",
          "docstring": "",
          "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_internal_import_record\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u251c\u2500\u2500 import_string.py\n        \u2502   \u2514\u2500\u2500 ImportString.render\n        \u2514\u2500\u2500 internal_import_record.py\n            \u2514\u2500\u2500 InternalImportRecord.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and test the functionality of the `InternalImportRecord` class, which facilitates the creation and management of import references within a broader code generation or API interaction framework. It ensures that the class correctly captures and represents imported identifiers, including their sources, names, and optional aliases, to streamline dependency handling and namespacing. By verifying the behavior of this class, the module addresses the need for reliable and consistent import management, reducing errors related to import generation and improving code maintainability for developers integrating with services or generating client libraries.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string as a dot-separated string.\n\nThis method combines all parts of the import string, which were initialized through the constructor, into a single valid Python import statement. The parts are joined using a dot ('.') separator to form a standard import string format. \n\nReturns:\n    str: A dot-separated string representing the import.\n\nThis method relies on the `parts` attribute, which is a tuple of string components defined during the initialization of the ImportString instance. It does not take any input parameters nor does it have side effects.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/import_helpers/internal_import_record.py\n\n- CLASS METHOD: InternalImportRecord.__init__\n  - CLASS SIGNATURE: class InternalImportRecord(ImportRecord):\n  - SIGNATURE: def __init__(self, service_module_name: ServiceModuleName, name: str='', alias: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the InternalImportRecord class, which helps build Python import strings without a master module name. It takes the service module name, import name, and alias, and sets up the local source for the import.\n\nArgs:\n    service_module_name (ServiceModuleName): The service module name used to create the local source for the import string.\n    name (str, optional): The name of the import. Defaults to an empty string.\n    alias (str, optional): The local alias for the import. Defaults to an empty string.\n\nReturns:\n    None: This method does not return a value but initializes the instance attributes.\n\nDependencies:\n- ServiceModuleName: An enum that represents the service module names, used to derive the local source name.\n- ImportString: A helper class that constructs the import string based on provided parts. The instance of this class is created with the service module name and further processed to create the final source for the ImportRecord.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/import_helpers/internal_import_record.py": "\"\"\"\nHelper for Python import strings with not set master module name.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\nclass InternalImportRecord(ImportRecord):\n    \"\"\"\n    Helper for Python import strings with not set master module name.\n\n    Arguments:\n        service_module_name -- Service module name.\n        name -- Import name.\n        alias -- Import local name.\n    \"\"\""
  },
  "call_tree": {
    "tests/import_helpers/test_internal_import_record.py:TestImportRecord:test_init": {
      "mypy_boto3_builder/import_helpers/internal_import_record.py:InternalImportRecord:__init__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    }
  }
}