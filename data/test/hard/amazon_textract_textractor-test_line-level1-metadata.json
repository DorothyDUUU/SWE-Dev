{
  "dir_path": "/app/amazon_textract_textractor",
  "package_name": "amazon_textract_textractor",
  "sample_name": "amazon_textract_textractor-test_line",
  "src_dir": "textractor/",
  "test_dir": "tests/",
  "test_file": "tests/test_line.py",
  "test_code": "import unittest\n\nfrom textractor.entities.line import Line\nfrom textractor.entities.word import Word\nfrom textractor.data.constants import TextTypes\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\n\nclass TestLine(unittest.TestCase):\n    def setUp(self):\n        self.word_bb_1 = {\n            \"Width\": 0.10809839516878128,\n            \"Height\": 0.01363567914813757,\n            \"Left\": 0.036161474883556366,\n            \"Top\": 0.03439946100115776,\n        }\n        self.word_bb_2 = {\n            \"Width\": 0.18033172190189362,\n            \"Height\": 0.01742148958146572,\n            \"Left\": 0.22032427787780762,\n            \"Top\": 0.03645794093608856,\n        }\n        self.word_bb_3 = {\n            \"Width\": 0.03744738921523094,\n            \"Height\": 0.016524378210306168,\n            \"Left\": 0.4087739884853363,\n            \"Top\": 0.0368686243891716,\n        }\n        self.line_bb = {\n            \"Width\": 0.3,\n            \"Height\": 0.01742148958146572,\n            \"Left\": 0.036161474883556366,\n            \"Top\": 0.03439946100115776,\n        }\n\n        self.word_1 = Word(\n            entity_id=\"word-id-1\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_1, spatial_object=None),\n            text=\"TEST\",\n            text_type=TextTypes.PRINTED,\n        )\n        self.word_2 = Word(\n            entity_id=\"word-id-2\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_2, spatial_object=None),\n            text=\"WORDS\",\n            text_type=TextTypes.HANDWRITING,\n        )\n        self.word_3 = Word(\n            entity_id=\"word-id-3\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_3, spatial_object=None),\n            text=\"ADDED\",\n            text_type=TextTypes.PRINTED,\n        )\n\n        self.line = Line(\n            \"line-id\",\n            BoundingBox.from_normalized_dict(self.line_bb, spatial_object=None),\n            [self.word_1, self.word_2, self.word_3],\n        )\n\n\n    def test_get_words_by_type(self):\n        \"\"\"Test case to filter words of the Line by their type\"\"\"\n        self.assertEqual(self.line.get_words_by_type(TextTypes.PRINTED), EntityList([self.word_1, self.word_3]))\n        self.assertEqual(self.line.get_words_by_type(TextTypes.HANDWRITING), EntityList([self.word_2]))\n\n\n    def test_get_text(self):\n        \"\"\"Test case setter for the text attribute\"\"\"\n        self.assertEqual(self.line.text, \"TEST WORDS ADDED\")\n\n\n    def test_set_page(self):\n        \"\"\"Test case setter for the page attribute\"\"\"\n        self.line.page = 2\n        self.assertEqual(self.line.page, 2)\n\n\n    def test_set_page_id(self):\n        \"\"\"Test case setter for the page_id attribute\"\"\"\n        self.line.page_id = \"page-id\"\n        self.assertEqual(self.line.page_id, \"page-id\")\n\n\n    def test_repr(self):\n        \"\"\"Test case setter for the repr function\"\"\"\n        self.assertEqual(self.line.__repr__(), \"TEST WORDS ADDED\")\n",
  "GT_file_code": {
    "textractor/entities/line.py": "\"\"\"\nRepresents a single :class:`Line` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as LINE BlockTypes. They contain :class:`Word` entities as children. \n\nThis class contains the associated metadata with the :class:`Line` entity including the entity ID, \nbounding box information, child words, page number, Page ID and confidence of detection.\n\"\"\"\n\nimport logging\nfrom typing import List\n\nfrom textractor.entities.word import Word\nfrom textractor.data.constants import TextTypes\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.exceptions import InputError\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.utils.html_utils import escape_text\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\n\nclass Line(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Line` object we need the following:\n\n    :param entity_id: Unique identifier of the Line entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the line entity.\n    :type bbox: BoundingBox\n    :param words: List of the Word entities present in the line\n    :type words: list, optional\n    :param confidence: confidence with which the entity was detected.\n    :type confidence: float, optional\n    \"\"\"\n\n    def __init__(\n        self,\n        entity_id: str,\n        bbox: BoundingBox,\n        words: List[Word] = None,\n        confidence: float = 0,\n    ):\n        super().__init__(entity_id, bbox)\n        if words is not None and len(words) > 0:\n            self._children: List[Word] = sorted(words, key=lambda x: (x.bbox.x, x.bbox.y))\n        else:\n            self._children = []\n\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None\n\n    @property\n    def text(self):\n        \"\"\"\n        :return: Returns the text transcription of the :class:`Line` entity.\n        :rtype: str\n        \"\"\"\n        return \" \".join([word.text for word in self.words])\n\n    @property\n    def words(self):\n        \"\"\"\n        :return: Returns the line's children\n        :rtype: List[Word]\n        \"\"\"\n        return self._children\n\n    def get_text_and_words(self, config: TextLinearizationConfig = TextLinearizationConfig()):\n        if not self.bbox:\n            self.bbox = BoundingBox.enclosing_bbox(self.words)\n        for w in self.words:\n            w.line_id = self.id\n            w.line_bbox = self.bbox\n        return escape_text(self.text, config), self.words\n\n    @property\n    def page(self):\n        \"\"\"\n        :return: Returns the page number of the page the :class:`Line` entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the Line entity.\n\n        :param page_num: Page number where the Line entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Line` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: TextTypes = TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n        :return: Returns EntityList of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError(\n                \"text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants\"\n            )\n\n        if not self.words:\n            return []\n        return EntityList([word for word in self.words if word.text_type == text_type])\n\n    def __repr__(self):\n        \"\"\"\n        :return: String representation of the Line entity.\n        :rtype: str\n        \"\"\"\n        return \" \".join([word.text for word in self.words])\n",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities \\\nin a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\n\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\n\nfrom textractor.data.constants import (\n    TextractType,\n    TableFormat,\n    AnalyzeExpenseLineItemFields,\n    AnalyzeExpenseFields,\n)\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\n\nlogger = logging.getLogger(__name__)\n\npresent_path = os.path.abspath(os.path.dirname(__file__))\n\nT = TypeVar(\"T\")\n\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def __init__(self, objs=None):\n        super().__init__()\n\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n\n        self.extend(objs)\n\n    def visualize(\n        self,\n        with_text: bool = True,\n        with_words: bool = True,\n        with_confidence: bool = False,\n        font_size_ratio: float = 0.5,\n    ) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        # FIXME: This is inelegant\n        if len(self) > 0 and any(\n            [ent.__class__.__name__ == \"Document\" for ent in self]\n        ):\n            return EntityList(self[0].pages).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and any([ent.__class__.__name__ == \"Page\" for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (\n                    entity.__class__.__name__ == \"Word\"\n                    or entity.__class__.__name__ == \"Line\"\n                ):\n                    continue\n                if entity.__class__.__name__ == \"Page\":\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(\n                            new_entity_list, expense_document\n                        )\n                elif entity.__class__.__name__ == \"ExpenseDocument\":\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException(\n                \"Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.\"\n            )\n\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            # FIXME: There should be a way to recurse through all entities\n            except AttributeError:\n                pass\n\n        for page in list(entities_pagewise.keys()):\n            # Deduplication\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(\n                entities_pagewise[page],\n                with_text,\n                with_confidence,\n                font_size_ratio,\n            )\n\n        images = [image.convert(\"RGB\") for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if (\n                        expense.type.text\n                        != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name\n                    ):\n                        entity_list.append(expense)\n        return entity_list\n\n    def pretty_print(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        with_page_number: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for each of the entities in the list according to its entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.WORDS,\n        )\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.LINES,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.KEY_VALUE_SET,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.SELECTION_ELEMENT,\n        )\n        result_value += self._get_tables_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n        )\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value\n\n    def _get_text_string(\n        self,\n        with_page_number=False,\n        with_confidence=False,\n        trim=False,\n        textract_type=TextractType.WORDS,\n    ):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n\n        if textract_type == TextractType.WORDS:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Word\"],\n                key=lambda x: x.page,\n            )\n        else:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Line\"],\n                key=lambda x: x.page,\n            )\n\n        current_page = -1\n\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f\"--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}\"\n                current_page = word.page\n            if trim:\n                result_value += f\"{word.text.strip()}\"\n            else:\n                result_value += f\"{word.text}\"\n\n            if with_confidence:\n                result_value += f\", {word.confidence}\"\n            result_value += os.linesep\n\n        return result_value\n\n    def _get_forms_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n        textract_type=TextractType.KEY_VALUE_SET,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n        result_value = \"\"\n\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and not obj.contains_checkbox\n            ]\n        else:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and obj.contains_checkbox\n            ]\n\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                result_value += (\n                    tabulate(forms_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            csv_output = StringIO()\n            csv_writer = csv.writer(\n                csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n            )\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == \"Table\":\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == \"TableCell\":\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n\n        result_value = \"\"\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                result_value += (\n                    tabulate(table_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n                csv_output = StringIO()\n                csv_writer = csv.writer(\n                    csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = \"\"\n        queries = [obj for obj in self if obj.__class__.__name__ == \"Query\"]\n\n        for query in queries:\n            if query.result is not None:\n                result_value += f\"{query.query} => {query.result.answer}{os.linesep}\"\n            else:\n                result_value += f\"{query.query} => {os.linesep}\"\n\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = \"\"\n        expense_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"ExpenseDocument\"\n        ]\n\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f\"Expense Document {i+1}:{os.linesep}\"\n            result_value += f\"### Summary Fields:{os.linesep}\"\n            result_value += f\"{expense_document.summary_fields}{os.linesep}\"\n            result_value += f\"### Line Item Groups: {os.linesep}\"\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f\"{line_item_group}{os.linesep}\"\n\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = \"\"\n        id_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"IdentityDocument\"\n        ]\n\n        for id_document in id_documents:\n            result_value += f\"{id_document}{os.linesep}\"\n\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig = TextLinearizationConfig()):\n        texts, words = [], []\n        separator = (\n            config.same_paragraph_separator\n            if all([entity.__class__.__name__ == \"Word\" for entity in self]) else\n            config.layout_element_separator\n        )\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return separator.join(texts), words\n\ndef _convert_form_to_list(\n    form_objects,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.KEY_VALUE_SET,\n) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n\n    rows_list = list()\n    rows_list.append([\"Key\", \"Value\"])\n    for field in form_objects:\n        t_key = \"\"\n        t_value = \"\"\n        if field.key:\n            text = \" \".join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + field.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({field.key.confidence:.1f})\"\n        if field.value:\n            text = (\n                field.value.words\n                if textract_type == TextractType.SELECTION_ELEMENT\n                else \" \".join([word.text for word in field.value.words])\n            )\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += \" {\" + field.value.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_value += f\" ({field.value.confidence:.1f})\"\n        rows_list.append([t_key, t_value])\n    return rows_list\n\n\ndef _convert_table_to_list(\n    table_object,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.TABLES,\n) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split(\">\")[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + cell.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({cell.confidence:.1f})\"\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\n\ndef _draw_bbox(\n    entities: List[Any],\n    with_text: bool = False,\n    with_confidence: bool = False,\n    font_size_ratio: float = 0.5,\n):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception(\"Could not find an entity with an associated image!\")\n    image = image.convert(\"RGBA\")\n    overlay = Image.new(\"RGBA\", image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, \"RGBA\")\n\n    text_locations = {}\n\n    # First drawing tables\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == \"Table\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.title:\n                drw.rectangle(\n                    (\n                        int(entity.title.bbox.x * width),\n                        int(entity.title.bbox.y * height),\n                        int((entity.title.bbox.x + entity.title.bbox.width) * width),\n                        int((entity.title.bbox.y + entity.title.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"red\") + (120,),\n                    width=2,\n                )\n\n            for footer in entity.footers:\n                drw.rectangle(\n                    (\n                        int(footer.bbox.x * width),\n                        int(footer.bbox.y * height),\n                        int((footer.bbox.x + footer.bbox.width) * width),\n                        int((footer.bbox.y + footer.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"cyan\") + (120,),\n                    width=2,\n                )\n\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(\n                        zip(\n                            *[\n                                (\n                                    c.bbox.x,\n                                    c.bbox.y,\n                                    c.bbox.x + c.bbox.width,\n                                    c.bbox.y + c.bbox.height,\n                                )\n                                for c in cell.siblings + [cell]\n                            ]\n                        )\n                    )\n                    min_x, min_y, max_x, max_y = (\n                        min(min_x),\n                        min(min_y),\n                        max(max_x),\n                        max(max_y),\n                    )\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (\n                        cell.bbox.x,\n                        cell.bbox.y,\n                        cell.bbox.x + cell.bbox.width,\n                        cell.bbox.y + cell.bbox.height,\n                    )\n\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb(\"blue\") + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb(\"red\") + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb(\"cyan\") + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb(\"yellow\") + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb(\"green\") + (120,)\n\n                drw.rectangle(\n                    (\n                        int(min_x * width),\n                        int(min_y * height),\n                        int(max_x * width),\n                        int(max_y * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=fill_color,\n                    width=2,\n                )\n                for checkbox in cell.checkboxes:\n                    drw.rectangle(\n                        (\n                            int(checkbox.bbox.x * width),\n                            int(checkbox.bbox.y * height),\n                            int((checkbox.bbox.x + checkbox.bbox.width) * width),\n                            int((checkbox.bbox.y + checkbox.bbox.height) * height),\n                        ),\n                        outline=ImageColor.getrgb(\"lightgreen\")\n                        if checkbox.is_selected()\n                        else ImageColor.getrgb(\"indianred\"),\n                    )\n    # Second drawing bounding boxes\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == \"Query\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableTitle\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableFooter\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"ExpenseField\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords_value\"],\n                outline=overlayer_data[\"color_value\"],\n                width=2,\n            )\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(\n                    xy=overlayer_data[\"coords_key\"],\n                    outline=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n                drw.line(\n                    [\n                        (\n                            (b1.x + b1.width / 2) * width,\n                            (b1.y + b1.height / 2) * height,\n                        ),\n                        (\n                            (b2.x + b2.width / 2) * width,\n                            (b2.y + b2.height / 2) * height,\n                        ),\n                    ],\n                    fill=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n        elif entity.__class__.__name__ == \"ExpenseDocument\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            for coord, text in zip(\n                overlayer_data[\"coords_list\"], overlayer_data[\"coords_list\"]\n            ):\n                drw.rectangle(\n                    xy=coord, outline=overlayer_data[\"color_expense_group\"], width=2\n                )\n        elif entity.__class__.__name__.startswith(\"Layout\"):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=4\n            )\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.__class__.__name__ == \"KeyValue\":\n                drw.rectangle(\n                    xy=overlayer_data[\"value_bbox\"],\n                    outline=overlayer_data[\"color_value\"],\n                    width=2,\n                )\n                b1 = overlayer_data[\"value_bbox\"]\n                b2 = overlayer_data[\"coords\"]\n                drw.line(\n                    [\n                        ((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2),\n                        ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2),\n                    ],\n                    fill=overlayer_data[\"color_value\"],\n                    width=1,\n                )\n\n    # Second drawing, text\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == \"Word\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__ == \"KeyValue\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                # Key Text\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(\n                    int(0.03 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color\"],\n                )\n\n                # Value Text\n                final_txt = overlayer_data[\"value_text\"]\n\n                bbox_height = (\n                    overlayer_data[\"value_bbox\"][3] - overlayer_data[\"value_bbox\"][1]\n                )\n                text_height = min(\n                    int(0.01 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"value_conf\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"value_bbox\"][0],\n                        overlayer_data[\"value_bbox\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color_value\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseField\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = overlayer_data[\"text\"]\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                if entity.key is not None:\n                    x = overlayer_data[\"coords_key\"][0] + 0.3 * (\n                        overlayer_data[\"coords_key\"][2]\n                        - overlayer_data[\"coords_key\"][0]\n                    )\n                    y = overlayer_data[\"coords_key\"][1] - text_height - 1\n                else:\n                    x = int(\n                        overlayer_data[\"coords\"][0]\n                        + 0.3\n                        * (overlayer_data[\"coords\"][2] - overlayer_data[\"coords\"][0])\n                    )\n                    y = overlayer_data[\"coords\"][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[(x, y)] != final_txt:\n                    y = y - text_height - 1\n                text_locations[(x, y)] = final_txt\n                drw.text(\n                    (x, y),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseDocument\":\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(\n                    overlayer_data[\"coords_list\"], overlayer_data[\"text_list\"]\n                ):\n                    drw.text(\n                        (coord[0], coord[3]),\n                        text,\n                        font=fnt,\n                        fill=overlayer_data[\"color_expense_group\"],\n                    )\n\n            elif entity.__class__.__name__ == \"Query\":\n                if entity.result is None:\n                    continue\n\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n\n                final_txt = entity.query + \" \" + overlayer_data[\"text\"]\n\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(entity.result.confidence)[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__.startswith(\"Layout\"):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (\n        bbox.x * width,\n        bbox.y * height,\n        bbox.width * width,\n        bbox.height * height,\n    )\n    data[\"coords\"] = [x, y, x + w, y + h]\n    data[\"confidence\"] = (\n        entity.confidence\n        if entity.__class__.__name__\n        not in [\n            \"Table\",\n            \"ExpenseField\",\n            \"ExpenseDocument\",\n            \"LineItemRow\",\n            \"LineItemGroup\",\n        ]\n        else \"\"\n    )\n    data[\"color\"] = (0, 0, 0)\n    data[\"text_color\"] = (0, 0, 0)\n\n    if entity.__class__.__name__ == \"Word\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"blue\")\n\n    elif entity.__class__.__name__ == \"Line\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"lightgrey\")\n        data[\"coords\"] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == \"KeyValue\":\n        data[\"text\"] = entity.key.__repr__()\n        data[\"color\"] = ImageColor.getrgb(\"brown\")\n        data[\"value_text\"] = entity.value.__repr__()\n        data[\"coords\"] = [x - 2, y - 2, x + w + 2, y + h + 2]\n\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data[\"value_conf\"] = entity.children[0].confidence\n\n        else:\n            value_bbox = entity.value.bbox\n            data[\"value_conf\"] = entity.value.confidence\n\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        x, y, w, h = (\n            value_bbox.x * width - 2,\n            value_bbox.y * height - 2,\n            value_bbox.width * width + 2,\n            value_bbox.height * height + 2,\n        )\n        data[\"value_bbox\"] = [x, y, x + w, y + h]\n\n    elif entity.__class__.__name__ == \"Table\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableTitle\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableFooter\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n\n    elif entity.__class__.__name__ == \"TableCell\":\n        data[\"color\"] = ImageColor.getrgb(\"skyblue\")\n        data[\"text\"] = entity.__repr__().split(\">\")[-1][1:]\n\n    elif entity.__class__.__name__ == \"QueryResult\":\n        data[\"color\"] = ImageColor.getrgb(\"mediumturquoise\")\n        data[\"text\"] = entity.answer\n    elif entity.__class__.__name__ == \"Signature\":\n        data[\"color\"] = ImageColor.getrgb(\"coral\")\n    elif entity.__class__.__name__ == \"ExpenseField\":\n        data[\"text\"] = entity.type.text\n        data[\"text_color\"] = ImageColor.getrgb(\"brown\")\n        data[\"coords\"] = [x - 5, y - 5, x + w + 5, y + h + 5]\n\n        if entity.key:\n            data[\"color_key\"] = ImageColor.getrgb(\"brown\")\n            data[\"coords_key\"] = (\n                entity.key.bbox.x * width - 3,\n                entity.key.bbox.y * height - 3,\n                (entity.key.bbox.x + entity.key.bbox.width) * width + 3,\n                ((entity.key.bbox.y + entity.key.bbox.height)) * height + 3,\n            )\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        data[\"coords_value\"] = (\n            entity.value.bbox.x * width - 3,\n            entity.value.bbox.y * height - 3,\n            (entity.value.bbox.x + entity.value.bbox.width) * width + 3,\n            ((entity.value.bbox.y + entity.value.bbox.height)) * height + 3,\n        )\n    elif entity.__class__.__name__ == \"Expense\":\n        data[\"text\"] = entity.text\n        data[\"coords\"] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == \"ExpenseDocument\":\n        data[\"color\"] = ImageColor.getrgb(\"beige\")\n        data[\"coords_list\"] = []\n        data[\"text_list\"] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data[\"coords_list\"].append(\n                    (\n                        bbox.x * width - 5,\n                        bbox.y * height - 5,\n                        (bbox.x + bbox.width) * width + 3,\n                        (bbox.y + bbox.height) * height + 3,\n                    )\n                )\n                data[\"text_list\"].append(group)\n        data[\"color_expense_group\"] = ImageColor.getrgb(\"coral\")\n\n    elif entity.__class__.__name__ == \"LineItemGroup\":\n        data[\"color\"] = ImageColor.getrgb(\"lightblue\")\n        data[\"coords\"] = [x - 10, y - 10, x + w + 10, y + h + 10]\n\n    elif entity.__class__.__name__ == \"LineItemRow\":\n        data[\"color\"] = ImageColor.getrgb(\"lightyellow\")\n        data[\"coords\"] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith(\"Layout\"):\n        data[\"color\"] = ImageColor.getrgb(\"teal\")\n        data[\"text\"] = f\"{entity.layout_type} - {entity.reading_order}\"\n    else:\n        pass\n    return data\n",
    "textractor/entities/word.py": "\"\"\"\nRepresents a single :class:`Word` within the :class:`Document`.\nThis class contains the associated metadata with the :class:`Word` entity including the text transcription, \ntext type, bounding box information, page number, Page ID and confidence of detection.\n\"\"\"\n\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.utils.html_utils import escape_text\n\nclass Word(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Word` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param text: Transcription of the Word object.\n    :type text: str\n    :param text_type: Enum value stating the type of text stored in the entity. Takes 2 values - PRINTED and HANDWRITING\n    :type text_type: TextTypes\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(\n        self,\n        entity_id: str,\n        bbox: BoundingBox,\n        text: str = \"\",\n        text_type: TextTypes = TextTypes.PRINTED,\n        confidence: float = 0,\n        is_clickable: bool = False,\n        is_structure: bool = False,\n    ):\n        super().__init__(entity_id, bbox)\n        self._text = text\n        self._text_type = text_type\n        self._confidence = confidence / 100\n        self.is_clickable = is_clickable\n        self.is_structure = is_structure\n        self._page = None\n        self._page_id = None\n        self.line = None\n        self.cell_bbox = None\n        self.cell_id = None\n        self.row_index = None\n        self.col_index = None\n        self.row_span = None\n        self.col_span = None\n        self.key_bbox = None\n        self.value_bbox = None\n        self.key_id = None\n        self.value_id = None\n        self.kv_id = None\n        self.kv_bbox = None\n        self.line_id = None\n        self.line_bbox = None\n        self.table_id = None\n        self.table_bbox = None\n        self.layout_id = None\n        self.layout_type = None\n        self.layout_bbox = None\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        :return: Returns the text transcription of the Word entity.\n        :rtype: str\n        \"\"\"\n        return self._text\n\n    @text.setter\n    def text(self, text: str):\n        \"\"\"\n        Sets the transcription of the :class:`Word` entity.\n\n        :param text: String containing the text transcription of the Word entity.\n        :type text: str\n        \"\"\"\n        self._text = text\n\n    @property\n    def text_type(self) -> TextTypes:\n        \"\"\"\n        :return: Returns the property of :class:`Word` class that holds the text type of Word object.\n        :rtype: str\n        \"\"\"\n        return self._text_type\n\n    @text_type.setter\n    def text_type(self, text_type: TextTypes):\n        \"\"\"\n        Sets the text type of the :class:`Word` entity.\n\n        :param text_type: Constant containing the type of text\n        \"\"\"\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the Word entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Word` entity.\n\n        :param page_num: Page number where the Word entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the Word entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    @property\n    def words(self):\n        \"\"\"Returns itself\n\n        :rtype: Word\n        \"\"\"\n        return [self]\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ):\n        return escape_text(self.text, config), [self]\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f\"{self.text}\"\n",
    "textractor/entities/bbox.py": "\"\"\"BoundingBox class contains all the co-ordinate information for a :class:`DocumentEntity`. This class is mainly useful to locate the entity\non the image of the document page.\"\"\"\n\nfrom abc import ABC\nimport logging\nimport math\nfrom typing import Tuple, List\n\ntry:\n    import numpy as np\nexcept ImportError:\n    # Used in an export_as_numpy function which won't be called if the user doesn't have numpy.\n    pass\n\nfrom typing import Dict\nfrom dataclasses import dataclass\n\n\nclass SpatialObject(ABC):\n    \"\"\"\n    The :class:`SpatialObject` interface defines an object that has a width and height. This mostly used for :class:`BoundingBox` \\\n    reference to be able to provide normalized coordinates.\n    \"\"\"\n\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n\n@dataclass\nclass BoundingBox(SpatialObject):\n    \"\"\"\n    Represents the bounding box of an object in the format of a dataclass with (x, y, width, height). \\\n    By default :class:`BoundingBox` is set to work with denormalized co-ordinates: :math:`x \\\\in [0, docwidth]` and :math:`y \\\\in [0, docheight]`. \\\n    Use the as_normalized_dict function to obtain BoundingBox with normalized co-ordinates: :math:`x \\\\in [0, 1]` and :math:`y \\\\in [0, 1]`. \\\\\n\n    Create a BoundingBox like shown below: \\\\\n\n    * Directly:             :code:`bb = BoundingBox(x, y, width, height)` \\\\\n    * From dict:            :code:`bb = BoundingBox.from_dict(bb_dict)` where :code:`bb_dict = {'x': x, 'y': y, 'width': width, 'height': height}` \\\\\n\n    Use a BoundingBox like shown below: \\\\\n\n    * Directly:            :code:`print('The top left is: ' + str(bb.x) + ' ' + str(bb.y))` \\\\\n    * Convert to dict:     :code:`bb_dict = bb.as_dict()` returns :code:`{'x': x, 'y': y, 'width': width, 'height': height}`\n    \"\"\"\n\n    def __init__(\n        self, x: float, y: float, width: float, height: float, spatial_object=None\n    ):\n        super().__init__(width, height)\n        self.spatial_object = spatial_object\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def from_normalized_dict(\n        cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject = None\n    ):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`. \\\n        The coordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized co-ordinates\n        :rtype: BoundingBox\n        \"\"\"\n        return cls._from_dict(bbox_dict, spatial_object)\n\n    @staticmethod\n    def _denormalize(\n        x: float,\n        y: float,\n        width: float,\n        height: float,\n        spatial_object: SpatialObject = None,\n    ) -> Tuple[float, float, float, float]:\n        \"\"\"\n        Denormalizes the coordinates according to spatial_object (used as a calibrator). \\\n        The SpatialObject is assumed to be a container for the bounding boxes (i.e: Page). \\\n        Any object with width, height attributes can be used as a SpatialObject.\n\n        :param x: Normalized co-ordinate x\n        :type x: float\n        :param y: Normalized co-ordinate y\n        :type y: float\n        :param width: Normalized width of BoundingBox\n        :type width: float\n        :param height: Normalized height of BoundingBox\n        :type height: float\n        :param spatial_object: Object with width and height attributes (i.e: Page).\n        :type spatial_object: SpatialObject\n\n        :return: Returns x, y, width, height as denormalized co-ordinates.\n        :rtype: Tuple[float, float, float, float]\n        \"\"\"\n\n        x = x * spatial_object.width\n        y = y * spatial_object.height\n        width = width * spatial_object.width\n        height = height * spatial_object.height\n\n        return x, y, width, height\n\n    @classmethod\n    def from_denormalized_xywh(\n        cls,\n        x: float,\n        y: float,\n        width: float,\n        height: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left, width and height properties.\n        The coordinates are assumed to be denormalized.\n        :param x: Left ~ [0, doc_width]\n        :param y: Top  ~ [0, doc_height]\n        :param width: Width ~ [0, doc_width]\n        :param height: Height  ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    @classmethod\n    def from_denormalized_corners(\n        cls,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        :param x1: Left  ~ [0, wdoc_idth]\n        :param y1: Top ~ [0, doc_height]\n        :param x2: Right  ~ [0, doc_width]\n        :param y2: Bottom ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = x1\n        y = y1\n        width = x2 - x1\n        height = y2 - y1\n        return BoundingBox(x, y, width, height, spatial_object=spatial_object)\n\n    @classmethod\n    def from_denormalized_borders(\n        cls,\n        left: float,\n        top: float,\n        right: float,\n        bottom: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        If spatial_object is not None, the coordinates will be denormalized according to the spatial object.\n        :param left: ~ [0, doc_width]\n        :param top: ~ [0, doc_height]\n        :param right: ~ [0, doc_width]\n        :param bottom: ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return cls.from_denormalized_corners(left, top, right, bottom, spatial_object)\n\n    @classmethod\n    def from_denormalized_dict(cls, bbox_dict: Dict[str, float]):\n        \"\"\"\n        Builds an axis aligned bounding box from a dictionary of:\n        {'x': x, 'y': y, 'width': width, 'height': height}\n        The coordinates will be denormalized according to the spatial object.\n        :param bbox_dict: {'x': x, 'y': y, 'width': width, 'height': height} of [0, doc_height] x [0, doc_width]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = bbox_dict[\"x\"]\n        y = bbox_dict[\"y\"]\n        width = bbox_dict[\"width\"]\n        height = bbox_dict[\"height\"]\n        return BoundingBox(x, y, width, height)\n\n    @classmethod\n    def enclosing_bbox(cls, bboxes, spatial_object: SpatialObject = None):\n        \"\"\"\n        :param bboxes [BoundingBox]: list of bounding boxes\n        :param spatial_object SpatialObject: spatial object to be added to the returned bbox\n        :return:\n        \"\"\"\n        bboxes = [bbox for bbox in bboxes if bbox is not None]\n        if bboxes and not isinstance(bboxes[0], BoundingBox):\n            try:\n                bboxes = [bbox.bbox for bbox in bboxes]\n            except:\n                raise Exception(\n                    \"bboxes must be of type List[BoundingBox] or of type List[DocumentEntity]\"\n                )\n\n        x1, y1, x2, y2 = float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\")\\\n        \n        # FIXME: This should not happen\n        if not any([bbox is not None for bbox in bboxes]):\n            logging.warning(\"At least one bounding box needs to be non-null\")\n            return BoundingBox(0, 0, 1, 1, spatial_object=spatial_object)            \n        \n        if spatial_object is None:\n            spatial_object = bboxes[0].spatial_object\n\n        for bbox in bboxes:\n            if bbox is not None:\n                x1 = min(x1, bbox.x)\n                x2 = max(x2, bbox.x + bbox.width)\n                y1 = min(y1, bbox.y)\n                y2 = max(y2, bbox.y + bbox.height)\n        return BoundingBox(x1, y1, x2 - x1, y2 - y1, spatial_object=spatial_object)\n\n    @classmethod\n    def is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if Bounding Box A is within Bounding Box B\n        \"\"\"\n        return (\n            bbox_a.x >= bbox_b.x and\n            (bbox_a.x + bbox_a.width) <= (bbox_b.x + bbox_b.width) and\n            bbox_a.y >= bbox_b.y and\n            (bbox_a.y + bbox_a.height) <= (bbox_b.y + bbox_b.height)\n        )\n\n    @classmethod\n    def center_is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if the center point of Bounding Box A is within Bounding Box B\n        \"\"\"\n        return (\n            (bbox_a.x + bbox_a.width / 2) >= bbox_b.x and\n            (bbox_a.x + bbox_a.width / 2) <= (bbox_b.x + bbox_b.width) and\n            (bbox_a.y + bbox_a.height / 2) >= bbox_b.y and\n            (bbox_a.y + bbox_a.height / 2) <= (bbox_b.y + bbox_b.height)\n        )\n\n    @property\n    def area(self):\n        \"\"\"\n        Returns the area of the bounding box, handles negative bboxes as 0-area\n\n        :return: Bounding box area\n        :rtype: float\n        \"\"\"\n        if self.width < 0 or self.height < 0:\n            return 0\n        else:\n            return self.width * self.height\n\n    @classmethod\n    def _from_dict(\n        cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject = None\n    ):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`. \\\n        The co-ordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized coordinates\n        :rtype: BoundingBox\n        \"\"\"\n        x = bbox_dict[\"Left\"]\n        y = bbox_dict[\"Top\"]\n        width = bbox_dict[\"Width\"]\n        height = bbox_dict[\"Height\"]\n        # if spatial_object is not None:\n        #    x, y, width, height = cls._denormalize(x, y, width, height, spatial_object)\n        # else:\n        #    spatial_object = None\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    def as_denormalized_numpy(self):\n        \"\"\"\n        :return: Returns denormalized co-ordinates x, y and dimensions width, height as numpy array.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.x, self.y, self.width, self.height])\n\n    def get_intersection(self, bbox):\n        \"\"\"\n        Returns the intersection of this object's bbox and another BoundingBox\n        :return: a BoundingBox object\n        \"\"\"\n        assert isinstance(bbox, BoundingBox)\n        x1y1x2y2 = (\n            max(self.x, bbox.x),\n            max(self.y, bbox.y),\n            min(self.x + self.width, bbox.x + bbox.width),\n            min(self.y + self.height, bbox.y + bbox.height),\n        )\n        return BoundingBox.from_denormalized_corners(\n            *x1y1x2y2, spatial_object=self.spatial_object\n        )\n\n    def get_distance(self, bbox):\n        \"\"\"\n        Returns the distance between the center point of the bounding box and another bounding box\n\n        :return: Returns the distance as float\n        :rtype: float\n        \"\"\"\n        return math.sqrt(\n            ((self.x + self.width / 2) - (bbox.x + bbox.width / 2)) ** 2\n            + ((self.y + self.height / 2) - (bbox.y + bbox.height / 2)) ** 2\n        )\n\n    def __repr__(self):\n        return f\"x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height}\"\n"
  },
  "GT_src_dict": {
    "textractor/entities/line.py": {
      "Line.__init__": {
        "code": "    def __init__(self, entity_id: str, bbox: BoundingBox, words: List[Word]=None, confidence: float=0):\n        \"\"\"Initializes a new instance of the Line class, representing a line entity in a document. \n\nParameters:\n- entity_id (str): A unique identifier for the Line entity.\n- bbox (BoundingBox): A bounding box defining the position and size of the line entity.\n- words (List[Word], optional): A list of Word entities that make up the line; if not provided, defaults to an empty list.\n- confidence (float, optional): A confidence score indicating the accuracy of the line detection, expected as a percentage (0 to 100); stored as a fraction in the instance.\n\nThe constructor initializes the line entity's children words by sorting them based on their bounding box coordinates and sets the confidence, page, and page ID attributes. Keys constants include:\n- BoundingBox: Represents the spatial bounds of the line and is used for positioning.\n- The class also interacts with the DocumentEntity class through inheritance, utilizing its initialization with entity_id and bbox parameters.\"\"\"\n        super().__init__(entity_id, bbox)\n        if words is not None and len(words) > 0:\n            self._children: List[Word] = sorted(words, key=lambda x: (x.bbox.x, x.bbox.y))\n        else:\n            self._children = []\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None",
        "docstring": "Initializes a new instance of the Line class, representing a line entity in a document. \n\nParameters:\n- entity_id (str): A unique identifier for the Line entity.\n- bbox (BoundingBox): A bounding box defining the position and size of the line entity.\n- words (List[Word], optional): A list of Word entities that make up the line; if not provided, defaults to an empty list.\n- confidence (float, optional): A confidence score indicating the accuracy of the line detection, expected as a percentage (0 to 100); stored as a fraction in the instance.\n\nThe constructor initializes the line entity's children words by sorting them based on their bounding box coordinates and sets the confidence, page, and page ID attributes. Keys constants include:\n- BoundingBox: Represents the spatial bounds of the line and is used for positioning.\n- The class also interacts with the DocumentEntity class through inheritance, utilizing its initialization with entity_id and bbox parameters.",
        "signature": "def __init__(self, entity_id: str, bbox: BoundingBox, words: List[Word]=None, confidence: float=0):",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      },
      "Line.text": {
        "code": "    def text(self):\n        \"\"\"Returns the concatenated text transcription of the current :class:`Line` entity by joining the text attributes of the contained :class:`Word` entities. The `words` property, which is a list of `Word` entities present in the line, is utilized to assemble the full text.\n\n:return: A string representing the full text of the line.\n:rtype: str\"\"\"\n        '\\n        :return: Returns the text transcription of the :class:`Line` entity.\\n        :rtype: str\\n        '\n        return ' '.join([word.text for word in self.words])",
        "docstring": "Returns the concatenated text transcription of the current :class:`Line` entity by joining the text attributes of the contained :class:`Word` entities. The `words` property, which is a list of `Word` entities present in the line, is utilized to assemble the full text.\n\n:return: A string representing the full text of the line.\n:rtype: str",
        "signature": "def text(self):",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      },
      "Line.page": {
        "code": "    def page(self, page_num: int):\n        \"\"\"Sets the page number for the Line entity, indicating the specific page in the document where the line is located.\n\n:param page_num: An integer representing the page number of the document where the Line entity exists.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which is used to track the page number related to the Line instance. The page number can be utilized in conjunction with other attributes and methods of the `Line` class, aiding in organizing and retrieving document information. There are no return values or side effects associated with this method.\"\"\"\n        '\\n        Sets the page number attribute of the Line entity.\\n\\n        :param page_num: Page number where the Line entity exists.\\n        :type page_num: int\\n        '\n        self._page = page_num",
        "docstring": "Sets the page number for the Line entity, indicating the specific page in the document where the line is located.\n\n:param page_num: An integer representing the page number of the document where the Line entity exists.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which is used to track the page number related to the Line instance. The page number can be utilized in conjunction with other attributes and methods of the `Line` class, aiding in organizing and retrieving document information. There are no return values or side effects associated with this method.",
        "signature": "def page(self, page_num: int):",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      },
      "Line.page_id": {
        "code": "    def page_id(self, page_id: str):\n        \"\"\"Sets the Page ID of the Line entity, linking it to a specific page within a document. \n\n:param page_id: The unique identifier for the page where this Line entity is located.\n:type page_id: str\"\"\"\n        '\\n        Sets the Page ID of the :class:`Line` entity.\\n\\n        :param page_id: Page ID of the page the entity belongs to.\\n        :type page_id: str\\n        '\n        self._page_id = page_id",
        "docstring": "Sets the Page ID of the Line entity, linking it to a specific page within a document. \n\n:param page_id: The unique identifier for the page where this Line entity is located.\n:type page_id: str",
        "signature": "def page_id(self, page_id: str):",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      },
      "Line.get_words_by_type": {
        "code": "    def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> List[Word]:\n        \"\"\"Retrieves a list of `Word` entities from the `Line` object that match a specified text type.\n\n:param text_type: The type of text to filter by, which can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`. Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n:return: An `EntityList` containing `Word` entities that correspond to the specified text type. If no words match the criteria, an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not an instance of the `TextTypes` enum, which is defined in `textractor.data.constants`. This ensures that only valid text types are processed.\n\nThis method interacts with the `Word` entities stored in the `self.words` list and filters them based on their `text_type` attribute.\"\"\"\n        '\\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\\n        :type text_type: TextTypes\\n        :return: Returns EntityList of Word entities that match the input text type.\\n        :rtype: EntityList[Word]\\n        '\n        if not isinstance(text_type, TextTypes):\n            raise InputError('text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants')\n        if not self.words:\n            return []\n        return EntityList([word for word in self.words if word.text_type == text_type])",
        "docstring": "Retrieves a list of `Word` entities from the `Line` object that match a specified text type.\n\n:param text_type: The type of text to filter by, which can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`. Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n:return: An `EntityList` containing `Word` entities that correspond to the specified text type. If no words match the criteria, an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not an instance of the `TextTypes` enum, which is defined in `textractor.data.constants`. This ensures that only valid text types are processed.\n\nThis method interacts with the `Word` entities stored in the `self.words` list and filters them based on their `text_type` attribute.",
        "signature": "def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> List[Word]:",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      },
      "Line.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Return a string representation of the Line entity by concatenating the text of its child Word entities. This method provides a human-readable format of the Line, making it easier to visualize the textual content detected within a specific line of a document. It accesses the `words` property, which holds a list of Word objects associated with the Line. The method does not take any parameters and returns a single string that consolidates the text from all Word entities in the Line.\"\"\"\n        '\\n        :return: String representation of the Line entity.\\n        :rtype: str\\n        '\n        return ' '.join([word.text for word in self.words])",
        "docstring": "Return a string representation of the Line entity by concatenating the text of its child Word entities. This method provides a human-readable format of the Line, making it easier to visualize the textual content detected within a specific line of a document. It accesses the `words` property, which holds a list of Word objects associated with the Line. The method does not take any parameters and returns a single string that consolidates the text from all Word entities in the Line.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class Line(DocumentEntity):"
      }
    },
    "textractor/visualizers/entitylist.py": {
      "EntityList.__init__": {
        "code": "    def __init__(self, objs=None):\n        \"\"\"Initializes an EntityList instance, which is an extension of the built-in list type specifically designed to hold document entities. \n\nThe constructor accepts an optional parameter `objs`, which can either be a list of entities or a single entity. If no list is provided, it initializes an empty EntityList.\n\nParameters:\n- objs (Optional[List[Any]]): A list of document entities to populate the EntityList. If a single entity is provided, it is converted into a list. Defaults to None, which initializes an empty list.\n\nReturns:\n- None\n\nThis constructor interacts with the `extend` method of the base list class to add entities to the list. The EntityList can then be utilized in conjunction with methods like `visualize()` and `pretty_print()`, which rely on the content of the list for formatting and displaying document information.\"\"\"\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
        "docstring": "Initializes an EntityList instance, which is an extension of the built-in list type specifically designed to hold document entities. \n\nThe constructor accepts an optional parameter `objs`, which can either be a list of entities or a single entity. If no list is provided, it initializes an empty EntityList.\n\nParameters:\n- objs (Optional[List[Any]]): A list of document entities to populate the EntityList. If a single entity is provided, it is converted into a list. Defaults to None, which initializes an empty list.\n\nReturns:\n- None\n\nThis constructor interacts with the `extend` method of the base list class to add entities to the list. The EntityList can then be utilized in conjunction with methods like `visualize()` and `pretty_print()`, which rely on the content of the list for formatting and displaying document information.",
        "signature": "def __init__(self, objs=None):",
        "type": "Method",
        "class_signature": "class EntityList(list, Generic[T], Linearizable):"
      }
    },
    "textractor/entities/word.py": {
      "Word.__init__": {
        "code": "    def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):\n        \"\"\"Initializes a new instance of the Word class, representing a single word within a Document along with its metadata.\n\nParameters:\n- entity_id (str): Unique identifier for the Word entity.\n- bbox (BoundingBox): Bounding box information defining the position of the Word entity.\n- text (str, optional): The transcription of the Word object. Defaults to an empty string.\n- text_type (TextTypes, optional): Enum value indicating the type of text (PRINTED or HANDWRITING). Defaults to TextTypes.PRINTED.\n- confidence (float, optional): Confidence level of text detection, expressed as a percentage. Value is converted to a fraction by dividing by 100. Defaults to 0.\n- is_clickable (bool, optional): Indicates if the Word entity is clickable. Defaults to False.\n- is_structure (bool, optional): Indicates if the Word entity is part of a structural element. Defaults to False.\n\nThe constructor is dependent on the BoundingBox class for bounding box information, and on the TextTypes enum imported from textractor.data.constants for text classification.\"\"\"\n        super().__init__(entity_id, bbox)\n        self._text = text\n        self._text_type = text_type\n        self._confidence = confidence / 100\n        self.is_clickable = is_clickable\n        self.is_structure = is_structure\n        self._page = None\n        self._page_id = None\n        self.line = None\n        self.cell_bbox = None\n        self.cell_id = None\n        self.row_index = None\n        self.col_index = None\n        self.row_span = None\n        self.col_span = None\n        self.key_bbox = None\n        self.value_bbox = None\n        self.key_id = None\n        self.value_id = None\n        self.kv_id = None\n        self.kv_bbox = None\n        self.line_id = None\n        self.line_bbox = None\n        self.table_id = None\n        self.table_bbox = None\n        self.layout_id = None\n        self.layout_type = None\n        self.layout_bbox = None",
        "docstring": "Initializes a new instance of the Word class, representing a single word within a Document along with its metadata.\n\nParameters:\n- entity_id (str): Unique identifier for the Word entity.\n- bbox (BoundingBox): Bounding box information defining the position of the Word entity.\n- text (str, optional): The transcription of the Word object. Defaults to an empty string.\n- text_type (TextTypes, optional): Enum value indicating the type of text (PRINTED or HANDWRITING). Defaults to TextTypes.PRINTED.\n- confidence (float, optional): Confidence level of text detection, expressed as a percentage. Value is converted to a fraction by dividing by 100. Defaults to 0.\n- is_clickable (bool, optional): Indicates if the Word entity is clickable. Defaults to False.\n- is_structure (bool, optional): Indicates if the Word entity is part of a structural element. Defaults to False.\n\nThe constructor is dependent on the BoundingBox class for bounding box information, and on the TextTypes enum imported from textractor.data.constants for text classification.",
        "signature": "def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):",
        "type": "Method",
        "class_signature": "class Word(DocumentEntity):"
      }
    },
    "textractor/entities/bbox.py": {
      "BoundingBox.from_normalized_dict": {
        "code": "    def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n        \"\"\"Constructs a `BoundingBox` instance from a given dictionary of normalized coordinates. The input dictionary must contain keys `'x'`, `'y'`, `'width'`, and `'height'`, representing the bounding box's position and size in a normalized format (values ranging from 0 to 1). Optionally, a `spatial_object` can be provided to denormalize these coordinates based on the dimensions of that object. \n\n    :param bbox_dict: A dictionary containing normalized bounding box coordinates.\n    :type bbox_dict: Dict[str, float]\n    :param spatial_object: An instance of `SpatialObject` which has `width` and `height` attributes for denormalization, if needed.\n    :type spatial_object: SpatialObject, optional\n\n    :return: A `BoundingBox` object with denormalized coordinates based on the provided `spatial_object`.\n    :rtype: BoundingBox\n\n    This method interacts with the `BoundingBox._from_dict` method to create the instance using the denormalized coordinates.\"\"\"\n        \"\\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The coordinates will be denormalized according to spatial_object.\\n\\n        :param bbox_dict: Dictionary of normalized co-ordinates.\\n        :type bbox_dict: dict\\n        :param spatial_object: Object with width and height attributes.\\n        :type spatial_object: SpatialObject\\n\\n        :return: Object with denormalized co-ordinates\\n        :rtype: BoundingBox\\n        \"\n        return cls._from_dict(bbox_dict, spatial_object)",
        "docstring": "Constructs a `BoundingBox` instance from a given dictionary of normalized coordinates. The input dictionary must contain keys `'x'`, `'y'`, `'width'`, and `'height'`, representing the bounding box's position and size in a normalized format (values ranging from 0 to 1). Optionally, a `spatial_object` can be provided to denormalize these coordinates based on the dimensions of that object. \n\n:param bbox_dict: A dictionary containing normalized bounding box coordinates.\n:type bbox_dict: Dict[str, float]\n:param spatial_object: An instance of `SpatialObject` which has `width` and `height` attributes for denormalization, if needed.\n:type spatial_object: SpatialObject, optional\n\n:return: A `BoundingBox` object with denormalized coordinates based on the provided `spatial_object`.\n:rtype: BoundingBox\n\nThis method interacts with the `BoundingBox._from_dict` method to create the instance using the denormalized coordinates.",
        "signature": "def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):",
        "type": "Method",
        "class_signature": "class BoundingBox(SpatialObject):"
      }
    }
  },
  "dependency_dict": {
    "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
      "textractor/entities/bbox.py": {
        "BoundingBox._from_dict": {
          "code": "    def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The co-ordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized coordinates\n        :rtype: BoundingBox\n        \"\"\"\n        x = bbox_dict['Left']\n        y = bbox_dict['Top']\n        width = bbox_dict['Width']\n        height = bbox_dict['Height']\n        return BoundingBox(x, y, width, height, spatial_object)",
          "docstring": "Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The co-ordinates will be denormalized according to spatial_object.\n\n:param bbox_dict: Dictionary of normalized co-ordinates.\n:type bbox_dict: dict\n:param spatial_object: Object with width and height attributes.\n:type spatial_object: SpatialObject\n\n:return: Object with denormalized coordinates\n:rtype: BoundingBox",
          "signature": "def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):",
          "type": "Method",
          "class_signature": "class BoundingBox(SpatialObject):"
        }
      }
    },
    "textractor/entities/word.py:Word:__init__": {
      "textractor/entities/document_entity.py": {
        "DocumentEntity.__init__": {
          "code": "    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\n        child entities within a document entity.\n\n        :param entity_id: Unique identifier of the document entity.\n        :param bbox: Bounding box of the entity\n        \"\"\"\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}  # Holds optional information about the entity\n        self._children = []\n        self._children_type = None\n        self._raw_object = None",
          "docstring": "Initialize the common properties to DocumentEntities. Additionally, it contains information about\nchild entities within a document entity.\n\n:param entity_id: Unique identifier of the document entity.\n:param bbox: Bounding box of the entity",
          "signature": "def __init__(self, entity_id: str, bbox: BoundingBox):",
          "type": "Method",
          "class_signature": "class DocumentEntity(Linearizable, ABC):"
        }
      }
    },
    "textractor/entities/line.py:Line:__init__": {
      "textractor/entities/document_entity.py": {
        "DocumentEntity.__init__": {
          "code": "    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\n        child entities within a document entity.\n\n        :param entity_id: Unique identifier of the document entity.\n        :param bbox: Bounding box of the entity\n        \"\"\"\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}  # Holds optional information about the entity\n        self._children = []\n        self._children_type = None\n        self._raw_object = None",
          "docstring": "Initialize the common properties to DocumentEntities. Additionally, it contains information about\nchild entities within a document entity.\n\n:param entity_id: Unique identifier of the document entity.\n:param bbox: Bounding box of the entity",
          "signature": "def __init__(self, entity_id: str, bbox: BoundingBox):",
          "type": "Method",
          "class_signature": "class DocumentEntity(Linearizable, ABC):"
        },
        "DocumentEntity.bbox": {
          "code": "    def bbox(self, bbox: BoundingBox):\n        self._bbox = bbox",
          "docstring": "",
          "signature": "def bbox(self, bbox: BoundingBox):",
          "type": "Method",
          "class_signature": "class DocumentEntity(Linearizable, ABC):"
        }
      }
    },
    "textractor/entities/line.py:Line:text": {
      "textractor/entities/word.py": {
        "Word.text": {
          "code": "    def text(self, text: str):\n        \"\"\"\n        Sets the transcription of the :class:`Word` entity.\n\n        :param text: String containing the text transcription of the Word entity.\n        :type text: str\n        \"\"\"\n        self._text = text",
          "docstring": "Sets the transcription of the :class:`Word` entity.\n\n:param text: String containing the text transcription of the Word entity.\n:type text: str",
          "signature": "def text(self, text: str):",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/entities/line.py": {
        "Line.words": {
          "code": "    def words(self):\n        \"\"\"\n        :return: Returns the line's children\n        :rtype: List[Word]\n        \"\"\"\n        return self._children",
          "docstring": ":return: Returns the line's children\n:rtype: List[Word]",
          "signature": "def words(self):",
          "type": "Method",
          "class_signature": "class Line(DocumentEntity):"
        }
      }
    },
    "textractor/entities/line.py:Line:get_words_by_type": {
      "textractor/entities/line.py": {
        "Line.words": {
          "code": "    def words(self):\n        \"\"\"\n        :return: Returns the line's children\n        :rtype: List[Word]\n        \"\"\"\n        return self._children",
          "docstring": ":return: Returns the line's children\n:rtype: List[Word]",
          "signature": "def words(self):",
          "type": "Method",
          "class_signature": "class Line(DocumentEntity):"
        }
      },
      "textractor/entities/word.py": {
        "Word.text_type": {
          "code": "    def text_type(self, text_type: TextTypes):\n        \"\"\"\n        Sets the text type of the :class:`Word` entity.\n\n        :param text_type: Constant containing the type of text\n        \"\"\"\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type",
          "docstring": "Sets the text type of the :class:`Word` entity.\n\n:param text_type: Constant containing the type of text",
          "signature": "def text_type(self, text_type: TextTypes):",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      }
    },
    "textractor/entities/line.py:Line:__repr__": {
      "textractor/entities/word.py": {
        "Word.text": {
          "code": "    def text(self, text: str):\n        \"\"\"\n        Sets the transcription of the :class:`Word` entity.\n\n        :param text: String containing the text transcription of the Word entity.\n        :type text: str\n        \"\"\"\n        self._text = text",
          "docstring": "Sets the transcription of the :class:`Word` entity.\n\n:param text: String containing the text transcription of the Word entity.\n:type text: str",
          "signature": "def text(self, text: str):",
          "type": "Method",
          "class_signature": "class Word(DocumentEntity):"
        }
      },
      "textractor/entities/line.py": {
        "Line.words": {
          "code": "    def words(self):\n        \"\"\"\n        :return: Returns the line's children\n        :rtype: List[Word]\n        \"\"\"\n        return self._children",
          "docstring": ":return: Returns the line's children\n:rtype: List[Word]",
          "signature": "def words(self):",
          "type": "Method",
          "class_signature": "class Line(DocumentEntity):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: amazon_textract_textractor-test_line\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 textractor/\n    \u251c\u2500\u2500 entities/\n    \u2502   \u251c\u2500\u2500 bbox.py\n    \u2502   \u2502   \u2514\u2500\u2500 BoundingBox.from_normalized_dict\n    \u2502   \u251c\u2500\u2500 line.py\n    \u2502   \u2502   \u251c\u2500\u2500 Line.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 Line.__repr__\n    \u2502   \u2502   \u251c\u2500\u2500 Line.get_words_by_type\n    \u2502   \u2502   \u251c\u2500\u2500 Line.page\n    \u2502   \u2502   \u251c\u2500\u2500 Line.page_id\n    \u2502   \u2502   \u2514\u2500\u2500 Line.text\n    \u2502   \u2514\u2500\u2500 word.py\n    \u2502       \u2514\u2500\u2500 Word.__init__\n    \u2514\u2500\u2500 visualizers/\n        \u2514\u2500\u2500 entitylist.py\n            \u2514\u2500\u2500 EntityList.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed for managing and testing the functionality of textual entities extracted from documents, specifically focusing on the representation and handling of lines and words along with their spatial properties. It provides core capabilities, such as filtering words by their text type (e.g., printed or handwritten), retrieving or modifying page-related metadata, and composing line-level text from its constituent words. This module addresses the need for structured and spatially aware manipulation of document text data, enabling developers to process and analyze extracted text more effectively within workflows that involve OCR or document parsing.\n\n## FILE 1: textractor/entities/line.py\n\n- CLASS METHOD: Line.page_id\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def page_id(self, page_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the Page ID of the Line entity, linking it to a specific page within a document. \n\n:param page_id: The unique identifier for the page where this Line entity is located.\n:type page_id: str\n\"\"\"\n```\n\n- CLASS METHOD: Line.page\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def page(self, page_num: int):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the page number for the Line entity, indicating the specific page in the document where the line is located.\n\n:param page_num: An integer representing the page number of the document where the Line entity exists.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which is used to track the page number related to the Line instance. The page number can be utilized in conjunction with other attributes and methods of the `Line` class, aiding in organizing and retrieving document information. There are no return values or side effects associated with this method.\n\"\"\"\n```\n\n- CLASS METHOD: Line.get_words_by_type\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def get_words_by_type(self, text_type: TextTypes=TextTypes.PRINTED) -> List[Word]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves a list of `Word` entities from the `Line` object that match a specified text type.\n\n:param text_type: The type of text to filter by, which can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`. Defaults to `TextTypes.PRINTED`.\n:type text_type: TextTypes\n:return: An `EntityList` containing `Word` entities that correspond to the specified text type. If no words match the criteria, an empty list is returned.\n\n:raises InputError: If the `text_type` parameter is not an instance of the `TextTypes` enum, which is defined in `textractor.data.constants`. This ensures that only valid text types are processed.\n\nThis method interacts with the `Word` entities stored in the `self.words` list and filters them based on their `text_type` attribute.\n\"\"\"\n```\n\n- CLASS METHOD: Line.__init__\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def __init__(self, entity_id: str, bbox: BoundingBox, words: List[Word]=None, confidence: float=0):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the Line class, representing a line entity in a document. \n\nParameters:\n- entity_id (str): A unique identifier for the Line entity.\n- bbox (BoundingBox): A bounding box defining the position and size of the line entity.\n- words (List[Word], optional): A list of Word entities that make up the line; if not provided, defaults to an empty list.\n- confidence (float, optional): A confidence score indicating the accuracy of the line detection, expected as a percentage (0 to 100); stored as a fraction in the instance.\n\nThe constructor initializes the line entity's children words by sorting them based on their bounding box coordinates and sets the confidence, page, and page ID attributes. Keys constants include:\n- BoundingBox: Represents the spatial bounds of the line and is used for positioning.\n- The class also interacts with the DocumentEntity class through inheritance, utilizing its initialization with entity_id and bbox parameters.\n\"\"\"\n```\n\n- CLASS METHOD: Line.__repr__\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a string representation of the Line entity by concatenating the text of its child Word entities. This method provides a human-readable format of the Line, making it easier to visualize the textual content detected within a specific line of a document. It accesses the `words` property, which holds a list of Word objects associated with the Line. The method does not take any parameters and returns a single string that consolidates the text from all Word entities in the Line.\n\"\"\"\n```\n\n- CLASS METHOD: Line.text\n  - CLASS SIGNATURE: class Line(DocumentEntity):\n  - SIGNATURE: def text(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the concatenated text transcription of the current :class:`Line` entity by joining the text attributes of the contained :class:`Word` entities. The `words` property, which is a list of `Word` entities present in the line, is utilized to assemble the full text.\n\n:return: A string representing the full text of the line.\n:rtype: str\n\"\"\"\n```\n\n## FILE 2: textractor/visualizers/entitylist.py\n\n- CLASS METHOD: EntityList.__init__\n  - CLASS SIGNATURE: class EntityList(list, Generic[T], Linearizable):\n  - SIGNATURE: def __init__(self, objs=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an EntityList instance, which is an extension of the built-in list type specifically designed to hold document entities. \n\nThe constructor accepts an optional parameter `objs`, which can either be a list of entities or a single entity. If no list is provided, it initializes an empty EntityList.\n\nParameters:\n- objs (Optional[List[Any]]): A list of document entities to populate the EntityList. If a single entity is provided, it is converted into a list. Defaults to None, which initializes an empty list.\n\nReturns:\n- None\n\nThis constructor interacts with the `extend` method of the base list class to add entities to the list. The EntityList can then be utilized in conjunction with methods like `visualize()` and `pretty_print()`, which rely on the content of the list for formatting and displaying document information.\n\"\"\"\n```\n\n## FILE 3: textractor/entities/word.py\n\n- CLASS METHOD: Word.__init__\n  - CLASS SIGNATURE: class Word(DocumentEntity):\n  - SIGNATURE: def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the Word class, representing a single word within a Document along with its metadata.\n\nParameters:\n- entity_id (str): Unique identifier for the Word entity.\n- bbox (BoundingBox): Bounding box information defining the position of the Word entity.\n- text (str, optional): The transcription of the Word object. Defaults to an empty string.\n- text_type (TextTypes, optional): Enum value indicating the type of text (PRINTED or HANDWRITING). Defaults to TextTypes.PRINTED.\n- confidence (float, optional): Confidence level of text detection, expressed as a percentage. Value is converted to a fraction by dividing by 100. Defaults to 0.\n- is_clickable (bool, optional): Indicates if the Word entity is clickable. Defaults to False.\n- is_structure (bool, optional): Indicates if the Word entity is part of a structural element. Defaults to False.\n\nThe constructor is dependent on the BoundingBox class for bounding box information, and on the TextTypes enum imported from textractor.data.constants for text classification.\n\"\"\"\n```\n\n## FILE 4: textractor/entities/bbox.py\n\n- CLASS METHOD: BoundingBox.from_normalized_dict\n  - CLASS SIGNATURE: class BoundingBox(SpatialObject):\n  - SIGNATURE: def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n  - DOCSTRING: \n```python\n\"\"\"\nConstructs a `BoundingBox` instance from a given dictionary of normalized coordinates. The input dictionary must contain keys `'x'`, `'y'`, `'width'`, and `'height'`, representing the bounding box's position and size in a normalized format (values ranging from 0 to 1). Optionally, a `spatial_object` can be provided to denormalize these coordinates based on the dimensions of that object. \n\n:param bbox_dict: A dictionary containing normalized bounding box coordinates.\n:type bbox_dict: Dict[str, float]\n:param spatial_object: An instance of `SpatialObject` which has `width` and `height` attributes for denormalization, if needed.\n:type spatial_object: SpatialObject, optional\n\n:return: A `BoundingBox` object with denormalized coordinates based on the provided `spatial_object`.\n:rtype: BoundingBox\n\nThis method interacts with the `BoundingBox._from_dict` method to create the instance using the denormalized coordinates.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "textractor/entities/line.py": "\"\"\"\nRepresents a single :class:`Line` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as LINE BlockTypes. They contain :class:`Word` entities as children. \n\nThis class contains the associated metadata with the :class:`Line` entity including the entity ID, \nbounding box information, child words, page number, Page ID and confidence of detection.\n\"\"\"\nimport logging\nfrom typing import List\nfrom textractor.entities.word import Word\nfrom textractor.data.constants import TextTypes\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.exceptions import InputError\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.utils.html_utils import escape_text\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\n\nclass Line(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Line` object we need the following:\n\n    :param entity_id: Unique identifier of the Line entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the line entity.\n    :type bbox: BoundingBox\n    :param words: List of the Word entities present in the line\n    :type words: list, optional\n    :param confidence: confidence with which the entity was detected.\n    :type confidence: float, optional\n    \"\"\"\n\n    @property\n    def words(self):\n        \"\"\"\n        :return: Returns the line's children\n        :rtype: List[Word]\n        \"\"\"\n        return self._children\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        if not self.bbox:\n            self.bbox = BoundingBox.enclosing_bbox(self.words)\n        for w in self.words:\n            w.line_id = self.id\n            w.line_bbox = self.bbox\n        return (escape_text(self.text, config), self.words)",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities in a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\nfrom textractor.data.constants import TextractType, TableFormat, AnalyzeExpenseLineItemFields, AnalyzeExpenseFields\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nlogger = logging.getLogger(__name__)\npresent_path = os.path.abspath(os.path.dirname(__file__))\nT = TypeVar('T')\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def visualize(self, with_text: bool=True, with_words: bool=True, with_confidence: bool=False, font_size_ratio: float=0.5) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        if len(self) > 0 and any([ent.__class__.__name__ == 'Document' for ent in self]):\n            return EntityList(self[0].pages).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and any([ent.__class__.__name__ == 'Page' for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (entity.__class__.__name__ == 'Word' or entity.__class__.__name__ == 'Line'):\n                    continue\n                if entity.__class__.__name__ == 'Page':\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(new_entity_list, expense_document)\n                elif entity.__class__.__name__ == 'ExpenseDocument':\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException('Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.')\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            except AttributeError:\n                pass\n        for page in list(entities_pagewise.keys()):\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(entities_pagewise[page], with_text, with_confidence, font_size_ratio)\n        images = [image.convert('RGB') for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if expense.type.text != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name:\n                        entity_list.append(expense)\n        return entity_list\n\n    def pretty_print(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, with_page_number: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for each of the entities in the list according to its entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.WORDS)\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.LINES)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.KEY_VALUE_SET)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.SELECTION_ELEMENT)\n        result_value += self._get_tables_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim)\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value\n\n    def _get_text_string(self, with_page_number=False, with_confidence=False, trim=False, textract_type=TextractType.WORDS):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        if textract_type == TextractType.WORDS:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Word'], key=lambda x: x.page)\n        else:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Line'], key=lambda x: x.page)\n        current_page = -1\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f'--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}'\n                current_page = word.page\n            if trim:\n                result_value += f'{word.text.strip()}'\n            else:\n                result_value += f'{word.text}'\n            if with_confidence:\n                result_value += f', {word.confidence}'\n            result_value += os.linesep\n        return result_value\n\n    def _get_forms_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        result_value = ''\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and (not obj.contains_checkbox)]\n        else:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and obj.contains_checkbox]\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                result_value += tabulate(forms_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            csv_output = StringIO()\n            csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == 'Table':\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == 'TableCell':\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n        result_value = ''\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                result_value += tabulate(table_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                csv_output = StringIO()\n                csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = ''\n        queries = [obj for obj in self if obj.__class__.__name__ == 'Query']\n        for query in queries:\n            if query.result is not None:\n                result_value += f'{query.query} => {query.result.answer}{os.linesep}'\n            else:\n                result_value += f'{query.query} => {os.linesep}'\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = ''\n        expense_documents = [obj for obj in self if obj.__class__.__name__ == 'ExpenseDocument']\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f'Expense Document {i + 1}:{os.linesep}'\n            result_value += f'### Summary Fields:{os.linesep}'\n            result_value += f'{expense_document.summary_fields}{os.linesep}'\n            result_value += f'### Line Item Groups: {os.linesep}'\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f'{line_item_group}{os.linesep}'\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = ''\n        id_documents = [obj for obj in self if obj.__class__.__name__ == 'IdentityDocument']\n        for id_document in id_documents:\n            result_value += f'{id_document}{os.linesep}'\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        texts, words = ([], [])\n        separator = config.same_paragraph_separator if all([entity.__class__.__name__ == 'Word' for entity in self]) else config.layout_element_separator\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return (separator.join(texts), words)\n\ndef _convert_form_to_list(form_objects, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n    rows_list = list()\n    rows_list.append(['Key', 'Value'])\n    for field in form_objects:\n        t_key = ''\n        t_value = ''\n        if field.key:\n            text = ' '.join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + field.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({field.key.confidence:.1f})'\n        if field.value:\n            text = field.value.words if textract_type == TextractType.SELECTION_ELEMENT else ' '.join([word.text for word in field.value.words])\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += ' {' + field.value.bbox.__repr__() + '} '\n            if with_confidence:\n                t_value += f' ({field.value.confidence:.1f})'\n        rows_list.append([t_key, t_value])\n    return rows_list\n\ndef _convert_table_to_list(table_object, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.TABLES) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split('>')[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + cell.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({cell.confidence:.1f})'\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\ndef _draw_bbox(entities: List[Any], with_text: bool=False, with_confidence: bool=False, font_size_ratio: float=0.5):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception('Could not find an entity with an associated image!')\n    image = image.convert('RGBA')\n    overlay = Image.new('RGBA', image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, 'RGBA')\n    text_locations = {}\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == 'Table':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.title:\n                drw.rectangle((int(entity.title.bbox.x * width), int(entity.title.bbox.y * height), int((entity.title.bbox.x + entity.title.bbox.width) * width), int((entity.title.bbox.y + entity.title.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('red') + (120,), width=2)\n            for footer in entity.footers:\n                drw.rectangle((int(footer.bbox.x * width), int(footer.bbox.y * height), int((footer.bbox.x + footer.bbox.width) * width), int((footer.bbox.y + footer.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('cyan') + (120,), width=2)\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(zip(*[(c.bbox.x, c.bbox.y, c.bbox.x + c.bbox.width, c.bbox.y + c.bbox.height) for c in cell.siblings + [cell]]))\n                    min_x, min_y, max_x, max_y = (min(min_x), min(min_y), max(max_x), max(max_y))\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (cell.bbox.x, cell.bbox.y, cell.bbox.x + cell.bbox.width, cell.bbox.y + cell.bbox.height)\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb('blue') + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb('red') + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb('cyan') + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb('yellow') + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb('green') + (120,)\n                drw.rectangle((int(min_x * width), int(min_y * height), int(max_x * width), int(max_y * height)), outline=overlayer_data['color'], fill=fill_color, width=2)\n                for checkbox in cell.checkboxes:\n                    drw.rectangle((int(checkbox.bbox.x * width), int(checkbox.bbox.y * height), int((checkbox.bbox.x + checkbox.bbox.width) * width), int((checkbox.bbox.y + checkbox.bbox.height) * height)), outline=ImageColor.getrgb('lightgreen') if checkbox.is_selected() else ImageColor.getrgb('indianred'))\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == 'Query':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableTitle':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableFooter':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseField':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords_value'], outline=overlayer_data['color_value'], width=2)\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(xy=overlayer_data['coords_key'], outline=overlayer_data['color_key'], width=2)\n                drw.line([((b1.x + b1.width / 2) * width, (b1.y + b1.height / 2) * height), ((b2.x + b2.width / 2) * width, (b2.y + b2.height / 2) * height)], fill=overlayer_data['color_key'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseDocument':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            for coord, text in zip(overlayer_data['coords_list'], overlayer_data['coords_list']):\n                drw.rectangle(xy=coord, outline=overlayer_data['color_expense_group'], width=2)\n        elif entity.__class__.__name__.startswith('Layout'):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=4)\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.__class__.__name__ == 'KeyValue':\n                drw.rectangle(xy=overlayer_data['value_bbox'], outline=overlayer_data['color_value'], width=2)\n                b1 = overlayer_data['value_bbox']\n                b2 = overlayer_data['coords']\n                drw.line([((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2), ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2)], fill=overlayer_data['color_value'], width=1)\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == 'Word':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'KeyValue':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(int(0.03 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color'])\n                final_txt = overlayer_data['value_text']\n                bbox_height = overlayer_data['value_bbox'][3] - overlayer_data['value_bbox'][1]\n                text_height = min(int(0.01 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['value_conf'])[:4] + ')'\n                drw.text((overlayer_data['value_bbox'][0], overlayer_data['value_bbox'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color_value'])\n            elif entity.__class__.__name__ == 'ExpenseField':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = overlayer_data['text']\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if entity.key is not None:\n                    x = overlayer_data['coords_key'][0] + 0.3 * (overlayer_data['coords_key'][2] - overlayer_data['coords_key'][0])\n                    y = overlayer_data['coords_key'][1] - text_height - 1\n                else:\n                    x = int(overlayer_data['coords'][0] + 0.3 * (overlayer_data['coords'][2] - overlayer_data['coords'][0]))\n                    y = overlayer_data['coords'][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[x, y] != final_txt:\n                    y = y - text_height - 1\n                text_locations[x, y] = final_txt\n                drw.text((x, y), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'ExpenseDocument':\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(overlayer_data['coords_list'], overlayer_data['text_list']):\n                    drw.text((coord[0], coord[3]), text, font=fnt, fill=overlayer_data['color_expense_group'])\n            elif entity.__class__.__name__ == 'Query':\n                if entity.result is None:\n                    continue\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n                final_txt = entity.query + ' ' + overlayer_data['text']\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(entity.result.confidence)[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__.startswith('Layout'):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (bbox.x * width, bbox.y * height, bbox.width * width, bbox.height * height)\n    data['coords'] = [x, y, x + w, y + h]\n    data['confidence'] = entity.confidence if entity.__class__.__name__ not in ['Table', 'ExpenseField', 'ExpenseDocument', 'LineItemRow', 'LineItemGroup'] else ''\n    data['color'] = (0, 0, 0)\n    data['text_color'] = (0, 0, 0)\n    if entity.__class__.__name__ == 'Word':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('blue')\n    elif entity.__class__.__name__ == 'Line':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('lightgrey')\n        data['coords'] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == 'KeyValue':\n        data['text'] = entity.key.__repr__()\n        data['color'] = ImageColor.getrgb('brown')\n        data['value_text'] = entity.value.__repr__()\n        data['coords'] = [x - 2, y - 2, x + w + 2, y + h + 2]\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data['value_conf'] = entity.children[0].confidence\n        else:\n            value_bbox = entity.value.bbox\n            data['value_conf'] = entity.value.confidence\n        data['color_value'] = ImageColor.getrgb('orange')\n        x, y, w, h = (value_bbox.x * width - 2, value_bbox.y * height - 2, value_bbox.width * width + 2, value_bbox.height * height + 2)\n        data['value_bbox'] = [x, y, x + w, y + h]\n    elif entity.__class__.__name__ == 'Table':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableTitle':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableFooter':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableCell':\n        data['color'] = ImageColor.getrgb('skyblue')\n        data['text'] = entity.__repr__().split('>')[-1][1:]\n    elif entity.__class__.__name__ == 'QueryResult':\n        data['color'] = ImageColor.getrgb('mediumturquoise')\n        data['text'] = entity.answer\n    elif entity.__class__.__name__ == 'Signature':\n        data['color'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'ExpenseField':\n        data['text'] = entity.type.text\n        data['text_color'] = ImageColor.getrgb('brown')\n        data['coords'] = [x - 5, y - 5, x + w + 5, y + h + 5]\n        if entity.key:\n            data['color_key'] = ImageColor.getrgb('brown')\n            data['coords_key'] = (entity.key.bbox.x * width - 3, entity.key.bbox.y * height - 3, (entity.key.bbox.x + entity.key.bbox.width) * width + 3, (entity.key.bbox.y + entity.key.bbox.height) * height + 3)\n        data['color_value'] = ImageColor.getrgb('orange')\n        data['coords_value'] = (entity.value.bbox.x * width - 3, entity.value.bbox.y * height - 3, (entity.value.bbox.x + entity.value.bbox.width) * width + 3, (entity.value.bbox.y + entity.value.bbox.height) * height + 3)\n    elif entity.__class__.__name__ == 'Expense':\n        data['text'] = entity.text\n        data['coords'] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == 'ExpenseDocument':\n        data['color'] = ImageColor.getrgb('beige')\n        data['coords_list'] = []\n        data['text_list'] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data['coords_list'].append((bbox.x * width - 5, bbox.y * height - 5, (bbox.x + bbox.width) * width + 3, (bbox.y + bbox.height) * height + 3))\n                data['text_list'].append(group)\n        data['color_expense_group'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'LineItemGroup':\n        data['color'] = ImageColor.getrgb('lightblue')\n        data['coords'] = [x - 10, y - 10, x + w + 10, y + h + 10]\n    elif entity.__class__.__name__ == 'LineItemRow':\n        data['color'] = ImageColor.getrgb('lightyellow')\n        data['coords'] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith('Layout'):\n        data['color'] = ImageColor.getrgb('teal')\n        data['text'] = f'{entity.layout_type} - {entity.reading_order}'\n    else:\n        pass\n    return data",
    "textractor/entities/word.py": "\"\"\"\nRepresents a single :class:`Word` within the :class:`Document`.\nThis class contains the associated metadata with the :class:`Word` entity including the text transcription, \ntext type, bounding box information, page number, Page ID and confidence of detection.\n\"\"\"\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.utils.html_utils import escape_text\n\nclass Word(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Word` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param text: Transcription of the Word object.\n    :type text: str\n    :param text_type: Enum value stating the type of text stored in the entity. Takes 2 values - PRINTED and HANDWRITING\n    :type text_type: TextTypes\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        :return: Returns the text transcription of the Word entity.\n        :rtype: str\n        \"\"\"\n        return self._text\n\n    @text.setter\n    def text(self, text: str):\n        \"\"\"\n        Sets the transcription of the :class:`Word` entity.\n\n        :param text: String containing the text transcription of the Word entity.\n        :type text: str\n        \"\"\"\n        self._text = text\n\n    @property\n    def text_type(self) -> TextTypes:\n        \"\"\"\n        :return: Returns the property of :class:`Word` class that holds the text type of Word object.\n        :rtype: str\n        \"\"\"\n        return self._text_type\n\n    @text_type.setter\n    def text_type(self, text_type: TextTypes):\n        \"\"\"\n        Sets the text type of the :class:`Word` entity.\n\n        :param text_type: Constant containing the type of text\n        \"\"\"\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the Word entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Word` entity.\n\n        :param page_num: Page number where the Word entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the Word entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    @property\n    def words(self):\n        \"\"\"Returns itself\n\n        :rtype: Word\n        \"\"\"\n        return [self]\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        return (escape_text(self.text, config), [self])\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f'{self.text}'",
    "textractor/entities/bbox.py": "\"\"\"BoundingBox class contains all the co-ordinate information for a :class:`DocumentEntity`. This class is mainly useful to locate the entity\non the image of the document page.\"\"\"\nfrom abc import ABC\nimport logging\nimport math\nfrom typing import Tuple, List\ntry:\n    import numpy as np\nexcept ImportError:\n    pass\nfrom typing import Dict\nfrom dataclasses import dataclass\n\nclass SpatialObject(ABC):\n    \"\"\"\n    The :class:`SpatialObject` interface defines an object that has a width and height. This mostly used for :class:`BoundingBox`     reference to be able to provide normalized coordinates.\n    \"\"\"\n\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n@dataclass\nclass BoundingBox(SpatialObject):\n    \"\"\"\n    Represents the bounding box of an object in the format of a dataclass with (x, y, width, height).     By default :class:`BoundingBox` is set to work with denormalized co-ordinates: :math:`x \\\\in [0, docwidth]` and :math:`y \\\\in [0, docheight]`.     Use the as_normalized_dict function to obtain BoundingBox with normalized co-ordinates: :math:`x \\\\in [0, 1]` and :math:`y \\\\in [0, 1]`. \\\\\n\n    Create a BoundingBox like shown below: \\\\\n\n    * Directly:             :code:`bb = BoundingBox(x, y, width, height)` \\\\\n    * From dict:            :code:`bb = BoundingBox.from_dict(bb_dict)` where :code:`bb_dict = {'x': x, 'y': y, 'width': width, 'height': height}` \\\\\n\n    Use a BoundingBox like shown below: \\\\\n\n    * Directly:            :code:`print('The top left is: ' + str(bb.x) + ' ' + str(bb.y))` \\\\\n    * Convert to dict:     :code:`bb_dict = bb.as_dict()` returns :code:`{'x': x, 'y': y, 'width': width, 'height': height}`\n    \"\"\"\n\n    def __init__(self, x: float, y: float, width: float, height: float, spatial_object=None):\n        super().__init__(width, height)\n        self.spatial_object = spatial_object\n        self.x = x\n        self.y = y\n\n    @staticmethod\n    def _denormalize(x: float, y: float, width: float, height: float, spatial_object: SpatialObject=None) -> Tuple[float, float, float, float]:\n        \"\"\"\n        Denormalizes the coordinates according to spatial_object (used as a calibrator).         The SpatialObject is assumed to be a container for the bounding boxes (i.e: Page).         Any object with width, height attributes can be used as a SpatialObject.\n\n        :param x: Normalized co-ordinate x\n        :type x: float\n        :param y: Normalized co-ordinate y\n        :type y: float\n        :param width: Normalized width of BoundingBox\n        :type width: float\n        :param height: Normalized height of BoundingBox\n        :type height: float\n        :param spatial_object: Object with width and height attributes (i.e: Page).\n        :type spatial_object: SpatialObject\n\n        :return: Returns x, y, width, height as denormalized co-ordinates.\n        :rtype: Tuple[float, float, float, float]\n        \"\"\"\n        x = x * spatial_object.width\n        y = y * spatial_object.height\n        width = width * spatial_object.width\n        height = height * spatial_object.height\n        return (x, y, width, height)\n\n    @classmethod\n    def from_denormalized_xywh(cls, x: float, y: float, width: float, height: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left, width and height properties.\n        The coordinates are assumed to be denormalized.\n        :param x: Left ~ [0, doc_width]\n        :param y: Top  ~ [0, doc_height]\n        :param width: Width ~ [0, doc_width]\n        :param height: Height  ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    @classmethod\n    def from_denormalized_corners(cls, x1: float, y1: float, x2: float, y2: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        :param x1: Left  ~ [0, wdoc_idth]\n        :param y1: Top ~ [0, doc_height]\n        :param x2: Right  ~ [0, doc_width]\n        :param y2: Bottom ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = x1\n        y = y1\n        width = x2 - x1\n        height = y2 - y1\n        return BoundingBox(x, y, width, height, spatial_object=spatial_object)\n\n    @classmethod\n    def from_denormalized_borders(cls, left: float, top: float, right: float, bottom: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        If spatial_object is not None, the coordinates will be denormalized according to the spatial object.\n        :param left: ~ [0, doc_width]\n        :param top: ~ [0, doc_height]\n        :param right: ~ [0, doc_width]\n        :param bottom: ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return cls.from_denormalized_corners(left, top, right, bottom, spatial_object)\n\n    @classmethod\n    def from_denormalized_dict(cls, bbox_dict: Dict[str, float]):\n        \"\"\"\n        Builds an axis aligned bounding box from a dictionary of:\n        {'x': x, 'y': y, 'width': width, 'height': height}\n        The coordinates will be denormalized according to the spatial object.\n        :param bbox_dict: {'x': x, 'y': y, 'width': width, 'height': height} of [0, doc_height] x [0, doc_width]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = bbox_dict['x']\n        y = bbox_dict['y']\n        width = bbox_dict['width']\n        height = bbox_dict['height']\n        return BoundingBox(x, y, width, height)\n\n    @classmethod\n    def enclosing_bbox(cls, bboxes, spatial_object: SpatialObject=None):\n        \"\"\"\n        :param bboxes [BoundingBox]: list of bounding boxes\n        :param spatial_object SpatialObject: spatial object to be added to the returned bbox\n        :return:\n        \"\"\"\n        bboxes = [bbox for bbox in bboxes if bbox is not None]\n        if bboxes and (not isinstance(bboxes[0], BoundingBox)):\n            try:\n                bboxes = [bbox.bbox for bbox in bboxes]\n            except:\n                raise Exception('bboxes must be of type List[BoundingBox] or of type List[DocumentEntity]')\n        x1, y1, x2, y2 = (float('inf'), float('inf'), float('-inf'), float('-inf'))\n        if not any([bbox is not None for bbox in bboxes]):\n            logging.warning('At least one bounding box needs to be non-null')\n            return BoundingBox(0, 0, 1, 1, spatial_object=spatial_object)\n        if spatial_object is None:\n            spatial_object = bboxes[0].spatial_object\n        for bbox in bboxes:\n            if bbox is not None:\n                x1 = min(x1, bbox.x)\n                x2 = max(x2, bbox.x + bbox.width)\n                y1 = min(y1, bbox.y)\n                y2 = max(y2, bbox.y + bbox.height)\n        return BoundingBox(x1, y1, x2 - x1, y2 - y1, spatial_object=spatial_object)\n\n    @classmethod\n    def is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if Bounding Box A is within Bounding Box B\n        \"\"\"\n        return bbox_a.x >= bbox_b.x and bbox_a.x + bbox_a.width <= bbox_b.x + bbox_b.width and (bbox_a.y >= bbox_b.y) and (bbox_a.y + bbox_a.height <= bbox_b.y + bbox_b.height)\n\n    @classmethod\n    def center_is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if the center point of Bounding Box A is within Bounding Box B\n        \"\"\"\n        return bbox_a.x + bbox_a.width / 2 >= bbox_b.x and bbox_a.x + bbox_a.width / 2 <= bbox_b.x + bbox_b.width and (bbox_a.y + bbox_a.height / 2 >= bbox_b.y) and (bbox_a.y + bbox_a.height / 2 <= bbox_b.y + bbox_b.height)\n\n    @property\n    def area(self):\n        \"\"\"\n        Returns the area of the bounding box, handles negative bboxes as 0-area\n\n        :return: Bounding box area\n        :rtype: float\n        \"\"\"\n        if self.width < 0 or self.height < 0:\n            return 0\n        else:\n            return self.width * self.height\n\n    @classmethod\n    def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The co-ordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized coordinates\n        :rtype: BoundingBox\n        \"\"\"\n        x = bbox_dict['Left']\n        y = bbox_dict['Top']\n        width = bbox_dict['Width']\n        height = bbox_dict['Height']\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    def as_denormalized_numpy(self):\n        \"\"\"\n        :return: Returns denormalized co-ordinates x, y and dimensions width, height as numpy array.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.x, self.y, self.width, self.height])\n\n    def get_intersection(self, bbox):\n        \"\"\"\n        Returns the intersection of this object's bbox and another BoundingBox\n        :return: a BoundingBox object\n        \"\"\"\n        assert isinstance(bbox, BoundingBox)\n        x1y1x2y2 = (max(self.x, bbox.x), max(self.y, bbox.y), min(self.x + self.width, bbox.x + bbox.width), min(self.y + self.height, bbox.y + bbox.height))\n        return BoundingBox.from_denormalized_corners(*x1y1x2y2, spatial_object=self.spatial_object)\n\n    def get_distance(self, bbox):\n        \"\"\"\n        Returns the distance between the center point of the bounding box and another bounding box\n\n        :return: Returns the distance as float\n        :rtype: float\n        \"\"\"\n        return math.sqrt((self.x + self.width / 2 - (bbox.x + bbox.width / 2)) ** 2 + (self.y + self.height / 2 - (bbox.y + bbox.height / 2)) ** 2)\n\n    def __repr__(self):\n        return f'x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height}'"
  },
  "call_tree": {
    "tests/test_line.py:TestLine:setUp": {
      "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
        "textractor/entities/bbox.py:BoundingBox:_from_dict": {
          "textractor/entities/bbox.py:BoundingBox:__init__": {
            "textractor/entities/bbox.py:SpatialObject:__init__": {}
          }
        }
      },
      "textractor/entities/word.py:Word:__init__": {
        "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
      },
      "textractor/entities/line.py:Line:__init__": {
        "textractor/entities/document_entity.py:DocumentEntity:__init__": {},
        "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
      }
    },
    "tests/test_line.py:TestLine:test_get_text": {
      "textractor/entities/line.py:Line:text": {
        "textractor/entities/line.py:Line:words": {},
        "textractor/entities/word.py:Word:text": {}
      }
    },
    "tests/test_line.py:TestLine:test_get_words_by_type": {
      "textractor/entities/line.py:Line:get_words_by_type": {
        "textractor/data/constants.py:TextTypes:TextTypes": {},
        "textractor/entities/line.py:Line:words": {},
        "textractor/entities/word.py:Word:text_type": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/visualizers/entitylist.py:EntityList:__init__": {}
    },
    "tests/test_line.py:TestLine:test_repr": {
      "textractor/entities/line.py:Line:__repr__": {
        "textractor/entities/line.py:Line:words": {},
        "textractor/entities/word.py:Word:text": {}
      }
    },
    "tests/test_line.py:TestLine:test_set_page": {
      "textractor/entities/line.py:Line:page": {}
    },
    "tests/test_line.py:TestLine:test_set_page_id": {
      "textractor/entities/line.py:Line:page_id": {}
    }
  }
}