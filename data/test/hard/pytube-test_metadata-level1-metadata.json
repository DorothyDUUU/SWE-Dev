{
  "dir_path": "/app/pytube",
  "package_name": "pytube",
  "sample_name": "pytube-test_metadata",
  "src_dir": "pytube/",
  "test_dir": "tests/",
  "test_file": "tests/test_metadata.py",
  "test_code": "\"\"\"Unit tests for the :module:`metadata <metadata>` module.\"\"\"\nfrom pytube import extract\n\n\ndef test_extract_metadata_empty():\n    ytmd = extract.metadata({})\n    assert ytmd._raw_metadata == []\n\n\ndef test_metadata_from_initial_data(stream_dict):\n    initial_data = extract.initial_data(stream_dict)\n    ytmd = extract.metadata(initial_data)\n    assert len(ytmd.raw_metadata) > 0\n    assert 'contents' in ytmd.raw_metadata[0]\n    assert len(ytmd.metadata) > 0\n    assert 'Song' in ytmd.metadata[0]\n",
  "GT_file_code": {
    "pytube/metadata.py": "\"\"\"This module contains the YouTubeMetadata class.\"\"\"\nimport json\nfrom typing import Dict, List, Optional\n\n\nclass YouTubeMetadata:\n    def __init__(self, metadata: List):\n        self._raw_metadata: List = metadata\n        self._metadata = [{}]\n\n        for el in metadata:\n            # We only add metadata to the dict if it has a simpleText title.\n            if 'title' in el and 'simpleText' in el['title']:\n                metadata_title = el['title']['simpleText']\n            else:\n                continue\n\n            contents = el['contents'][0]\n            if 'simpleText' in contents:\n                self._metadata[-1][metadata_title] = contents['simpleText']\n            elif 'runs' in contents:\n                self._metadata[-1][metadata_title] = contents['runs'][0]['text']\n\n            # Upon reaching a dividing line, create a new grouping\n            if el.get('hasDividerLine', False):\n                self._metadata.append({})\n\n        # If we happen to create an empty dict at the end, drop it\n        if self._metadata[-1] == {}:\n            self._metadata = self._metadata[:-1]\n\n    def __getitem__(self, key):\n        return self._metadata[key]\n\n    def __iter__(self):\n        for el in self._metadata:\n            yield el\n\n    def __str__(self):\n        return json.dumps(self._metadata)\n\n    @property\n    def raw_metadata(self) -> Optional[Dict]:\n        return self._raw_metadata\n\n    @property\n    def metadata(self):\n        return self._metadata\n",
    "pytube/extract.py": "\"\"\"This module contains all non-cipher related data extraction logic.\"\"\"\nimport logging\nimport urllib.parse\nimport re\nfrom collections import OrderedDict\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom urllib.parse import parse_qs, quote, urlencode, urlparse\n\nfrom pytube.cipher import Cipher\nfrom pytube.exceptions import HTMLParseError, LiveStreamError, RegexMatchError\nfrom pytube.helpers import regex_search\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.parser import parse_for_object, parse_for_all_objects\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef publish_date(watch_html: str):\n    \"\"\"Extract publish date\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Publish date of the video.\n    \"\"\"\n    try:\n        result = regex_search(\n            r\"(?<=itemprop=\\\"datePublished\\\" content=\\\")\\d{4}-\\d{2}-\\d{2}\",\n            watch_html, group=0\n        )\n    except RegexMatchError:\n        return None\n    return datetime.strptime(result, '%Y-%m-%d')\n\n\ndef recording_available(watch_html):\n    \"\"\"Check if live stream recording is available.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is private.\n    \"\"\"\n    unavailable_strings = [\n        'This live stream recording is not available.'\n    ]\n    for string in unavailable_strings:\n        if string in watch_html:\n            return False\n    return True\n\n\ndef is_private(watch_html):\n    \"\"\"Check if content is private.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is private.\n    \"\"\"\n    private_strings = [\n        \"This is a private video. Please sign in to verify that you may see it.\",\n        \"\\\"simpleText\\\":\\\"Private video\\\"\",\n        \"This video is private.\"\n    ]\n    for string in private_strings:\n        if string in watch_html:\n            return True\n    return False\n\n\ndef is_age_restricted(watch_html: str) -> bool:\n    \"\"\"Check if content is age restricted.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is age restricted.\n    \"\"\"\n    try:\n        regex_search(r\"og:restrictions:age\", watch_html, group=0)\n    except RegexMatchError:\n        return False\n    return True\n\n\ndef playability_status(watch_html: str) -> (str, str):\n    \"\"\"Return the playability status and status explanation of a video.\n\n    For example, a video may have a status of LOGIN_REQUIRED, and an explanation\n    of \"This is a private video. Please sign in to verify that you may see it.\"\n\n    This explanation is what gets incorporated into the media player overlay.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Playability status and reason of the video.\n    \"\"\"\n    player_response = initial_player_response(watch_html)\n    status_dict = player_response.get('playabilityStatus', {})\n    if 'liveStreamability' in status_dict:\n        return 'LIVE_STREAM', 'Video is a live stream.'\n    if 'status' in status_dict:\n        if 'reason' in status_dict:\n            return status_dict['status'], [status_dict['reason']]\n        if 'messages' in status_dict:\n            return status_dict['status'], status_dict['messages']\n    return None, [None]\n\n\ndef video_id(url: str) -> str:\n    \"\"\"Extract the ``video_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/watch?v={video_id}`\n    - :samp:`https://youtube.com/embed/{video_id}`\n    - :samp:`https://youtu.be/{video_id}`\n\n    :param str url:\n        A YouTube url containing a video id.\n    :rtype: str\n    :returns:\n        YouTube video id.\n    \"\"\"\n    return regex_search(r\"(?:v=|\\/)([0-9A-Za-z_-]{11}).*\", url, group=1)\n\n\ndef playlist_id(url: str) -> str:\n    \"\"\"Extract the ``playlist_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/playlist?list={playlist_id}`\n    - :samp:`https://youtube.com/watch?v={video_id}&list={playlist_id}`\n\n    :param str url:\n        A YouTube url containing a playlist id.\n    :rtype: str\n    :returns:\n        YouTube playlist id.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    return parse_qs(parsed.query)['list'][0]\n\n\ndef channel_name(url: str) -> str:\n    \"\"\"Extract the ``channel_name`` or ``channel_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/c/{channel_name}/*`\n    - :samp:`https://youtube.com/channel/{channel_id}/*\n    - :samp:`https://youtube.com/u/{channel_name}/*`\n    - :samp:`https://youtube.com/user/{channel_id}/*\n\n    :param str url:\n        A YouTube url containing a channel name.\n    :rtype: str\n    :returns:\n        YouTube channel name.\n    \"\"\"\n    patterns = [\n        r\"(?:\\/(c)\\/([%\\d\\w_\\-]+)(\\/.*)?)\",\n        r\"(?:\\/(channel)\\/([%\\w\\d_\\-]+)(\\/.*)?)\",\n        r\"(?:\\/(u)\\/([%\\d\\w_\\-]+)(\\/.*)?)\",\n        r\"(?:\\/(user)\\/([%\\w\\d_\\-]+)(\\/.*)?)\"\n    ]\n    for pattern in patterns:\n        regex = re.compile(pattern)\n        function_match = regex.search(url)\n        if function_match:\n            logger.debug(\"finished regex search, matched: %s\", pattern)\n            uri_style = function_match.group(1)\n            uri_identifier = function_match.group(2)\n            return f'/{uri_style}/{uri_identifier}'\n\n    raise RegexMatchError(\n        caller=\"channel_name\", pattern=\"patterns\"\n    )\n\n\ndef video_info_url(video_id: str, watch_url: str) -> str:\n    \"\"\"Construct the video_info url.\n\n    :param str video_id:\n        A YouTube video identifier.\n    :param str watch_url:\n        A YouTube watch url.\n    :rtype: str\n    :returns:\n        :samp:`https://youtube.com/get_video_info` with necessary GET\n        parameters.\n    \"\"\"\n    params = OrderedDict(\n        [\n            (\"video_id\", video_id),\n            (\"ps\", \"default\"),\n            (\"eurl\", quote(watch_url)),\n            (\"hl\", \"en_US\"),\n            (\"html5\", \"1\"),\n            (\"c\", \"TVHTML5\"),\n            (\"cver\", \"7.20201028\"),\n        ]\n    )\n    return _video_info_url(params)\n\n\ndef video_info_url_age_restricted(video_id: str, embed_html: str) -> str:\n    \"\"\"Construct the video_info url.\n\n    :param str video_id:\n        A YouTube video identifier.\n    :param str embed_html:\n        The html contents of the embed page (for age restricted videos).\n    :rtype: str\n    :returns:\n        :samp:`https://youtube.com/get_video_info` with necessary GET\n        parameters.\n    \"\"\"\n    try:\n        sts = regex_search(r'\"sts\"\\s*:\\s*(\\d+)', embed_html, group=1)\n    except RegexMatchError:\n        sts = \"\"\n    # Here we use ``OrderedDict`` so that the output is consistent between\n    # Python 2.7+.\n    eurl = f\"https://youtube.googleapis.com/v/{video_id}\"\n    params = OrderedDict(\n        [\n            (\"video_id\", video_id),\n            (\"eurl\", eurl),\n            (\"sts\", sts),\n            (\"html5\", \"1\"),\n            (\"c\", \"TVHTML5\"),\n            (\"cver\", \"7.20201028\"),\n        ]\n    )\n    return _video_info_url(params)\n\n\ndef _video_info_url(params: OrderedDict) -> str:\n    return \"https://www.youtube.com/get_video_info?\" + urlencode(params)\n\n\ndef js_url(html: str) -> str:\n    \"\"\"Get the base JavaScript url.\n\n    Construct the base JavaScript url, which contains the decipher\n    \"transforms\".\n\n    :param str html:\n        The html contents of the watch page.\n    \"\"\"\n    try:\n        base_js = get_ytplayer_config(html)['assets']['js']\n    except (KeyError, RegexMatchError):\n        base_js = get_ytplayer_js(html)\n    return \"https://youtube.com\" + base_js\n\n\ndef mime_type_codec(mime_type_codec: str) -> Tuple[str, List[str]]:\n    \"\"\"Parse the type data.\n\n    Breaks up the data in the ``type`` key of the manifest, which contains the\n    mime type and codecs serialized together, and splits them into separate\n    elements.\n\n    **Example**:\n\n    mime_type_codec('audio/webm; codecs=\"opus\"') -> ('audio/webm', ['opus'])\n\n    :param str mime_type_codec:\n        String containing mime type and codecs.\n    :rtype: tuple\n    :returns:\n        The mime type and a list of codecs.\n\n    \"\"\"\n    pattern = r\"(\\w+\\/\\w+)\\;\\scodecs=\\\"([a-zA-Z-0-9.,\\s]*)\\\"\"\n    regex = re.compile(pattern)\n    results = regex.search(mime_type_codec)\n    if not results:\n        raise RegexMatchError(caller=\"mime_type_codec\", pattern=pattern)\n    mime_type, codecs = results.groups()\n    return mime_type, [c.strip() for c in codecs.split(\",\")]\n\n\ndef get_ytplayer_js(html: str) -> Any:\n    \"\"\"Get the YouTube player base JavaScript path.\n\n    :param str html\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Path to YouTube's base.js file.\n    \"\"\"\n    js_url_patterns = [\n        r\"(/s/player/[\\w\\d]+/[\\w\\d_/.]+/base\\.js)\"\n    ]\n    for pattern in js_url_patterns:\n        regex = re.compile(pattern)\n        function_match = regex.search(html)\n        if function_match:\n            logger.debug(\"finished regex search, matched: %s\", pattern)\n            yt_player_js = function_match.group(1)\n            return yt_player_js\n\n    raise RegexMatchError(\n        caller=\"get_ytplayer_js\", pattern=\"js_url_patterns\"\n    )\n\n\ndef get_ytplayer_config(html: str) -> Any:\n    \"\"\"Get the YouTube player configuration data from the watch html.\n\n    Extract the ``ytplayer_config``, which is json data embedded within the\n    watch html and serves as the primary source of obtaining the stream\n    manifest data.\n\n    :param str html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Substring of the html containing the encoded manifest data.\n    \"\"\"\n    logger.debug(\"finding initial function name\")\n    config_patterns = [\n        r\"ytplayer\\.config\\s*=\\s*\",\n        r\"ytInitialPlayerResponse\\s*=\\s*\"\n    ]\n    for pattern in config_patterns:\n        # Try each pattern consecutively if they don't find a match\n        try:\n            return parse_for_object(html, pattern)\n        except HTMLParseError as e:\n            logger.debug(f'Pattern failed: {pattern}')\n            logger.debug(e)\n            continue\n\n    # setConfig() needs to be handled a little differently.\n    # We want to parse the entire argument to setConfig()\n    #  and use then load that as json to find PLAYER_CONFIG\n    #  inside of it.\n    setconfig_patterns = [\n        r\"yt\\.setConfig\\(.*['\\\"]PLAYER_CONFIG['\\\"]:\\s*\"\n    ]\n    for pattern in setconfig_patterns:\n        # Try each pattern consecutively if they don't find a match\n        try:\n            return parse_for_object(html, pattern)\n        except HTMLParseError:\n            continue\n\n    raise RegexMatchError(\n        caller=\"get_ytplayer_config\", pattern=\"config_patterns, setconfig_patterns\"\n    )\n\n\ndef get_ytcfg(html: str) -> str:\n    \"\"\"Get the entirety of the ytcfg object.\n\n    This is built over multiple pieces, so we have to find all matches and\n    combine the dicts together.\n\n    :param str html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Substring of the html containing the encoded manifest data.\n    \"\"\"\n    ytcfg = {}\n    ytcfg_patterns = [\n        r\"ytcfg\\s=\\s\",\n        r\"ytcfg\\.set\\(\"\n    ]\n    for pattern in ytcfg_patterns:\n        # Try each pattern consecutively and try to build a cohesive object\n        try:\n            found_objects = parse_for_all_objects(html, pattern)\n            for obj in found_objects:\n                ytcfg.update(obj)\n        except HTMLParseError:\n            continue\n\n    if len(ytcfg) > 0:\n        return ytcfg\n\n    raise RegexMatchError(\n        caller=\"get_ytcfg\", pattern=\"ytcfg_pattenrs\"\n    )\n\n\ndef apply_signature(stream_manifest: Dict, vid_info: Dict, js: str) -> None:\n    \"\"\"Apply the decrypted signature to the stream manifest.\n\n    :param dict stream_manifest:\n        Details of the media streams available.\n    :param str js:\n        The contents of the base.js asset file.\n\n    \"\"\"\n    cipher = Cipher(js=js)\n\n    for i, stream in enumerate(stream_manifest):\n        try:\n            url: str = stream[\"url\"]\n        except KeyError:\n            live_stream = (\n                vid_info.get(\"playabilityStatus\", {},)\n                .get(\"liveStreamability\")\n            )\n            if live_stream:\n                raise LiveStreamError(\"UNKNOWN\")\n        # 403 Forbidden fix.\n        if \"signature\" in url or (\n            \"s\" not in stream and (\"&sig=\" in url or \"&lsig=\" in url)\n        ):\n            # For certain videos, YouTube will just provide them pre-signed, in\n            # which case there's no real magic to download them and we can skip\n            # the whole signature descrambling entirely.\n            logger.debug(\"signature found, skip decipher\")\n            continue\n\n        signature = cipher.get_signature(ciphered_signature=stream[\"s\"])\n\n        logger.debug(\n            \"finished descrambling signature for itag=%s\", stream[\"itag\"]\n        )\n        parsed_url = urlparse(url)\n\n        # Convert query params off url to dict\n        query_params = parse_qs(urlparse(url).query)\n        query_params = {\n            k: v[0] for k,v in query_params.items()\n        }\n        query_params['sig'] = signature\n        if 'ratebypass' not in query_params.keys():\n            # Cipher n to get the updated value\n\n            initial_n = list(query_params['n'])\n            new_n = cipher.calculate_n(initial_n)\n            query_params['n'] = new_n\n\n        url = f'{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query_params)}'  # noqa:E501\n\n        # 403 forbidden fix\n        stream_manifest[i][\"url\"] = url\n\n\ndef apply_descrambler(stream_data: Dict) -> None:\n    \"\"\"Apply various in-place transforms to YouTube's media stream data.\n\n    Creates a ``list`` of dictionaries by string splitting on commas, then\n    taking each list item, parsing it as a query string, converting it to a\n    ``dict`` and unquoting the value.\n\n    :param dict stream_data:\n        Dictionary containing query string encoded values.\n\n    **Example**:\n\n    >>> d = {'foo': 'bar=1&var=test,em=5&t=url%20encoded'}\n    >>> apply_descrambler(d, 'foo')\n    >>> print(d)\n    {'foo': [{'bar': '1', 'var': 'test'}, {'em': '5', 't': 'url encoded'}]}\n\n    \"\"\"\n    if 'url' in stream_data:\n        return None\n\n    # Merge formats and adaptiveFormats into a single list\n    formats = []\n    if 'formats' in stream_data.keys():\n        formats.extend(stream_data['formats'])\n    if 'adaptiveFormats' in stream_data.keys():\n        formats.extend(stream_data['adaptiveFormats'])\n\n    # Extract url and s from signatureCiphers as necessary\n    for data in formats:\n        if 'url' not in data:\n            if 'signatureCipher' in data:\n                cipher_url = parse_qs(data['signatureCipher'])\n                data['url'] = cipher_url['url'][0]\n                data['s'] = cipher_url['s'][0]\n        data['is_otf'] = data.get('type') == 'FORMAT_STREAM_TYPE_OTF'\n\n    logger.debug(\"applying descrambler\")\n    return formats\n\n\ndef initial_data(watch_html: str) -> str:\n    \"\"\"Extract the ytInitialData json from the watch_html page.\n\n    This mostly contains metadata necessary for rendering the page on-load,\n    such as video information, copyright notices, etc.\n\n    @param watch_html: Html of the watch page\n    @return:\n    \"\"\"\n    patterns = [\n        r\"window\\[['\\\"]ytInitialData['\\\"]]\\s*=\\s*\",\n        r\"ytInitialData\\s*=\\s*\"\n    ]\n    for pattern in patterns:\n        try:\n            return parse_for_object(watch_html, pattern)\n        except HTMLParseError:\n            pass\n\n    raise RegexMatchError(caller='initial_data', pattern='initial_data_pattern')\n\n\ndef initial_player_response(watch_html: str) -> str:\n    \"\"\"Extract the ytInitialPlayerResponse json from the watch_html page.\n\n    This mostly contains metadata necessary for rendering the page on-load,\n    such as video information, copyright notices, etc.\n\n    @param watch_html: Html of the watch page\n    @return:\n    \"\"\"\n    patterns = [\n        r\"window\\[['\\\"]ytInitialPlayerResponse['\\\"]]\\s*=\\s*\",\n        r\"ytInitialPlayerResponse\\s*=\\s*\"\n    ]\n    for pattern in patterns:\n        try:\n            return parse_for_object(watch_html, pattern)\n        except HTMLParseError:\n            pass\n\n    raise RegexMatchError(\n        caller='initial_player_response',\n        pattern='initial_player_response_pattern'\n    )\n\n\ndef metadata(initial_data) -> Optional[YouTubeMetadata]:\n    \"\"\"Get the informational metadata for the video.\n\n    e.g.:\n    [\n        {\n            'Song': '\uac15\ub0a8\uc2a4\ud0c0\uc77c(Gangnam Style)',\n            'Artist': 'PSY',\n            'Album': 'PSY SIX RULES Pt.1',\n            'Licensed to YouTube by': 'YG Entertainment Inc. [...]'\n        }\n    ]\n\n    :rtype: YouTubeMetadata\n    \"\"\"\n    try:\n        metadata_rows: List = initial_data[\"contents\"][\"twoColumnWatchNextResults\"][\n            \"results\"][\"results\"][\"contents\"][1][\"videoSecondaryInfoRenderer\"][\n            \"metadataRowContainer\"][\"metadataRowContainerRenderer\"][\"rows\"]\n    except (KeyError, IndexError):\n        # If there's an exception accessing this data, it probably doesn't exist.\n        return YouTubeMetadata([])\n\n    # Rows appear to only have \"metadataRowRenderer\" or \"metadataRowHeaderRenderer\"\n    #  and we only care about the former, so we filter the others\n    metadata_rows = filter(\n        lambda x: \"metadataRowRenderer\" in x.keys(),\n        metadata_rows\n    )\n\n    # We then access the metadataRowRenderer key in each element\n    #  and build a metadata object from this new list\n    metadata_rows = [x[\"metadataRowRenderer\"] for x in metadata_rows]\n\n    return YouTubeMetadata(metadata_rows)\n"
  },
  "GT_src_dict": {
    "pytube/metadata.py": {
      "YouTubeMetadata.raw_metadata": {
        "code": "    def raw_metadata(self) -> Optional[Dict]:\n        \"\"\"Returns the raw metadata retrieved during the initialization of the YouTubeMetadata instance.\n\nThis property does not take any parameters and returns a dictionary (or None) containing the original metadata list passed to the constructor. The raw metadata can be used for further inspection or processing outside the structured format of the processed metadata.\n\nAttributes:\n- _raw_metadata (List): A list of raw metadata entries passed to the class constructor, which is meant for internal processing and is preserved for external access via this property.\"\"\"\n        return self._raw_metadata",
        "docstring": "Returns the raw metadata retrieved during the initialization of the YouTubeMetadata instance.\n\nThis property does not take any parameters and returns a dictionary (or None) containing the original metadata list passed to the constructor. The raw metadata can be used for further inspection or processing outside the structured format of the processed metadata.\n\nAttributes:\n- _raw_metadata (List): A list of raw metadata entries passed to the class constructor, which is meant for internal processing and is preserved for external access via this property.",
        "signature": "def raw_metadata(self) -> Optional[Dict]:",
        "type": "Method",
        "class_signature": "class YouTubeMetadata:"
      },
      "YouTubeMetadata.metadata": {
        "code": "    def metadata(self):\n        \"\"\"@property\ndef metadata(self):\"\"\"\n        return self._metadata",
        "docstring": "@property\ndef metadata(self):",
        "signature": "def metadata(self):",
        "type": "Method",
        "class_signature": "class YouTubeMetadata:"
      }
    },
    "pytube/extract.py": {
      "initial_data": {
        "code": "def initial_data(watch_html: str) -> str:\n    \"\"\"Extracts the `ytInitialData` JSON object from the HTML of a YouTube watch page. This data contains important metadata necessary for rendering the page upon loading, including video details and copyright information.\n\n:param watch_html: The HTML content of the YouTube watch page.\n:return: A string representation of the extracted `ytInitialData` JSON. \n:raises RegexMatchError: If the expected patterns to locate the JSON data are not found.\n\nThe function utilizes a list of regex patterns to identify and extract the `ytInitialData`. If the extraction fails, it raises a `RegexMatchError` indicating which pattern caused the failure. The function is dependent on the helper function `parse_for_object`, which parses the HTML content based on the provided regex pattern.\"\"\"\n    'Extract the ytInitialData json from the watch_html page.\\n\\n    This mostly contains metadata necessary for rendering the page on-load,\\n    such as video information, copyright notices, etc.\\n\\n    @param watch_html: Html of the watch page\\n    @return:\\n    '\n    patterns = ['window\\\\[[\\'\\\\\"]ytInitialData[\\'\\\\\"]]\\\\s*=\\\\s*', 'ytInitialData\\\\s*=\\\\s*']\n    for pattern in patterns:\n        try:\n            return parse_for_object(watch_html, pattern)\n        except HTMLParseError:\n            pass\n    raise RegexMatchError(caller='initial_data', pattern='initial_data_pattern')",
        "docstring": "Extracts the `ytInitialData` JSON object from the HTML of a YouTube watch page. This data contains important metadata necessary for rendering the page upon loading, including video details and copyright information.\n\n:param watch_html: The HTML content of the YouTube watch page.\n:return: A string representation of the extracted `ytInitialData` JSON. \n:raises RegexMatchError: If the expected patterns to locate the JSON data are not found.\n\nThe function utilizes a list of regex patterns to identify and extract the `ytInitialData`. If the extraction fails, it raises a `RegexMatchError` indicating which pattern caused the failure. The function is dependent on the helper function `parse_for_object`, which parses the HTML content based on the provided regex pattern.",
        "signature": "def initial_data(watch_html: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "metadata": {
        "code": "def metadata(initial_data) -> Optional[YouTubeMetadata]:\n    \"\"\"Retrieve informational metadata for a YouTube video from its initial data structure.\n\nThis function extracts metadata such as song title, artist, album, and licensing information from the `initial_data` dictionary, which is typically obtained from the YouTube watch page's HTML. It navigates the structure of `initial_data` to access `contents`, specifically focusing on `twoColumnWatchNextResults`, which houses video-related information.\n\nParameters:\n- initial_data (dict): The JSON-like dictionary containing the video details retrieved from the watch page.\n\nReturns:\n- Optional[YouTubeMetadata]: An instance of `YouTubeMetadata` containing the parsed metadata rows. If the relevant data cannot be accessed, an empty `YouTubeMetadata` object will be returned.\n\nDependencies:\n- The function relies on the `YouTubeMetadata` class, which is defined in the `pytube.metadata` module, to construct and return the metadata representation. Additionally, it assumes the structure of `initial_data` follows specific keys and nesting; if these are not present, it gracefully handles potential exceptions.\"\"\"\n    \"Get the informational metadata for the video.\\n\\n    e.g.:\\n    [\\n        {\\n            'Song': '\uac15\ub0a8\uc2a4\ud0c0\uc77c(Gangnam Style)',\\n            'Artist': 'PSY',\\n            'Album': 'PSY SIX RULES Pt.1',\\n            'Licensed to YouTube by': 'YG Entertainment Inc. [...]'\\n        }\\n    ]\\n\\n    :rtype: YouTubeMetadata\\n    \"\n    try:\n        metadata_rows: List = initial_data['contents']['twoColumnWatchNextResults']['results']['results']['contents'][1]['videoSecondaryInfoRenderer']['metadataRowContainer']['metadataRowContainerRenderer']['rows']\n    except (KeyError, IndexError):\n        return YouTubeMetadata([])\n    metadata_rows = filter(lambda x: 'metadataRowRenderer' in x.keys(), metadata_rows)\n    metadata_rows = [x['metadataRowRenderer'] for x in metadata_rows]\n    return YouTubeMetadata(metadata_rows)",
        "docstring": "Retrieve informational metadata for a YouTube video from its initial data structure.\n\nThis function extracts metadata such as song title, artist, album, and licensing information from the `initial_data` dictionary, which is typically obtained from the YouTube watch page's HTML. It navigates the structure of `initial_data` to access `contents`, specifically focusing on `twoColumnWatchNextResults`, which houses video-related information.\n\nParameters:\n- initial_data (dict): The JSON-like dictionary containing the video details retrieved from the watch page.\n\nReturns:\n- Optional[YouTubeMetadata]: An instance of `YouTubeMetadata` containing the parsed metadata rows. If the relevant data cannot be accessed, an empty `YouTubeMetadata` object will be returned.\n\nDependencies:\n- The function relies on the `YouTubeMetadata` class, which is defined in the `pytube.metadata` module, to construct and return the metadata representation. Additionally, it assumes the structure of `initial_data` follows specific keys and nesting; if these are not present, it gracefully handles potential exceptions.",
        "signature": "def metadata(initial_data) -> Optional[YouTubeMetadata]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "pytube/extract.py:metadata": {
      "pytube/metadata.py": {
        "YouTubeMetadata.__init__": {
          "code": "    def __init__(self, metadata: List):\n        self._raw_metadata: List = metadata\n        self._metadata = [{}]\n        for el in metadata:\n            if 'title' in el and 'simpleText' in el['title']:\n                metadata_title = el['title']['simpleText']\n            else:\n                continue\n            contents = el['contents'][0]\n            if 'simpleText' in contents:\n                self._metadata[-1][metadata_title] = contents['simpleText']\n            elif 'runs' in contents:\n                self._metadata[-1][metadata_title] = contents['runs'][0]['text']\n            if el.get('hasDividerLine', False):\n                self._metadata.append({})\n        if self._metadata[-1] == {}:\n            self._metadata = self._metadata[:-1]",
          "docstring": "",
          "signature": "def __init__(self, metadata: List):",
          "type": "Method",
          "class_signature": "class YouTubeMetadata:"
        }
      }
    },
    "pytube/extract.py:initial_data": {
      "pytube/parser.py": {
        "parse_for_object": {
          "code": "def parse_for_object(html, preceding_regex):\n    \"\"\"Parses input html to find the end of a JavaScript object.\n\n    :param str html:\n        HTML to be parsed for an object.\n    :param str preceding_regex:\n        Regex to find the string preceding the object.\n    :rtype dict:\n    :returns:\n        A dict created from parsing the object.\n    \"\"\"\n    regex = re.compile(preceding_regex)\n    result = regex.search(html)\n    if not result:\n        raise HTMLParseError(f'No matches for regex {preceding_regex}')\n\n    start_index = result.end()\n    return parse_for_object_from_startpoint(html, start_index)",
          "docstring": "Parses input html to find the end of a JavaScript object.\n\n:param str html:\n    HTML to be parsed for an object.\n:param str preceding_regex:\n    Regex to find the string preceding the object.\n:rtype dict:\n:returns:\n    A dict created from parsing the object.",
          "signature": "def parse_for_object(html, preceding_regex):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pytube-test_metadata\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pytube/\n    \u251c\u2500\u2500 extract.py\n    \u2502   \u251c\u2500\u2500 initial_data\n    \u2502   \u2514\u2500\u2500 metadata\n    \u2514\u2500\u2500 metadata.py\n        \u251c\u2500\u2500 YouTubeMetadata.metadata\n        \u2514\u2500\u2500 YouTubeMetadata.raw_metadata\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe metadata module is designed to extract, parse, and structure metadata from given data sources, enabling streamlined access to organized information. It provides functionality to handle raw input, transform it into structured metadata objects, and expose key details such as content attributes or specific metadata fields. This module is particularly useful for developers needing to process and interpret metadata from online video or streaming platforms, reducing the complexity of manual data parsing and ensuring a consistent format for integration into broader systems or user-facing features.\n\n## FILE 1: pytube/metadata.py\n\n- CLASS METHOD: YouTubeMetadata.raw_metadata\n  - CLASS SIGNATURE: class YouTubeMetadata:\n  - SIGNATURE: def raw_metadata(self) -> Optional[Dict]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the raw metadata retrieved during the initialization of the YouTubeMetadata instance.\n\nThis property does not take any parameters and returns a dictionary (or None) containing the original metadata list passed to the constructor. The raw metadata can be used for further inspection or processing outside the structured format of the processed metadata.\n\nAttributes:\n- _raw_metadata (List): A list of raw metadata entries passed to the class constructor, which is meant for internal processing and is preserved for external access via this property.\n\"\"\"\n```\n\n- CLASS METHOD: YouTubeMetadata.metadata\n  - CLASS SIGNATURE: class YouTubeMetadata:\n  - SIGNATURE: def metadata(self):\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef metadata(self):\n\"\"\"\n```\n\n## FILE 2: pytube/extract.py\n\n- FUNCTION NAME: initial_data\n  - SIGNATURE: def initial_data(watch_html: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the `ytInitialData` JSON object from the HTML of a YouTube watch page. This data contains important metadata necessary for rendering the page upon loading, including video details and copyright information.\n\n:param watch_html: The HTML content of the YouTube watch page.\n:return: A string representation of the extracted `ytInitialData` JSON. \n:raises RegexMatchError: If the expected patterns to locate the JSON data are not found.\n\nThe function utilizes a list of regex patterns to identify and extract the `ytInitialData`. If the extraction fails, it raises a `RegexMatchError` indicating which pattern caused the failure. The function is dependent on the helper function `parse_for_object`, which parses the HTML content based on the provided regex pattern.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/parser.py:parse_for_object\n\n- FUNCTION NAME: metadata\n  - SIGNATURE: def metadata(initial_data) -> Optional[YouTubeMetadata]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve informational metadata for a YouTube video from its initial data structure.\n\nThis function extracts metadata such as song title, artist, album, and licensing information from the `initial_data` dictionary, which is typically obtained from the YouTube watch page's HTML. It navigates the structure of `initial_data` to access `contents`, specifically focusing on `twoColumnWatchNextResults`, which houses video-related information.\n\nParameters:\n- initial_data (dict): The JSON-like dictionary containing the video details retrieved from the watch page.\n\nReturns:\n- Optional[YouTubeMetadata]: An instance of `YouTubeMetadata` containing the parsed metadata rows. If the relevant data cannot be accessed, an empty `YouTubeMetadata` object will be returned.\n\nDependencies:\n- The function relies on the `YouTubeMetadata` class, which is defined in the `pytube.metadata` module, to construct and return the metadata representation. Additionally, it assumes the structure of `initial_data` follows specific keys and nesting; if these are not present, it gracefully handles potential exceptions.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/metadata.py:YouTubeMetadata:__init__\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pytube/metadata.py": "\"\"\"This module contains the YouTubeMetadata class.\"\"\"\nimport json\nfrom typing import Dict, List, Optional\n\nclass YouTubeMetadata:\n\n    def __init__(self, metadata: List):\n        self._raw_metadata: List = metadata\n        self._metadata = [{}]\n        for el in metadata:\n            if 'title' in el and 'simpleText' in el['title']:\n                metadata_title = el['title']['simpleText']\n            else:\n                continue\n            contents = el['contents'][0]\n            if 'simpleText' in contents:\n                self._metadata[-1][metadata_title] = contents['simpleText']\n            elif 'runs' in contents:\n                self._metadata[-1][metadata_title] = contents['runs'][0]['text']\n            if el.get('hasDividerLine', False):\n                self._metadata.append({})\n        if self._metadata[-1] == {}:\n            self._metadata = self._metadata[:-1]\n\n    def __getitem__(self, key):\n        return self._metadata[key]\n\n    def __iter__(self):\n        for el in self._metadata:\n            yield el\n\n    def __str__(self):\n        return json.dumps(self._metadata)",
    "pytube/extract.py": "\"\"\"This module contains all non-cipher related data extraction logic.\"\"\"\nimport logging\nimport urllib.parse\nimport re\nfrom collections import OrderedDict\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional, Tuple\nfrom urllib.parse import parse_qs, quote, urlencode, urlparse\nfrom pytube.cipher import Cipher\nfrom pytube.exceptions import HTMLParseError, LiveStreamError, RegexMatchError\nfrom pytube.helpers import regex_search\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.parser import parse_for_object, parse_for_all_objects\nlogger = logging.getLogger(__name__)\n\ndef publish_date(watch_html: str):\n    \"\"\"Extract publish date\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Publish date of the video.\n    \"\"\"\n    try:\n        result = regex_search('(?<=itemprop=\\\\\"datePublished\\\\\" content=\\\\\")\\\\d{4}-\\\\d{2}-\\\\d{2}', watch_html, group=0)\n    except RegexMatchError:\n        return None\n    return datetime.strptime(result, '%Y-%m-%d')\n\ndef recording_available(watch_html):\n    \"\"\"Check if live stream recording is available.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is private.\n    \"\"\"\n    unavailable_strings = ['This live stream recording is not available.']\n    for string in unavailable_strings:\n        if string in watch_html:\n            return False\n    return True\n\ndef is_private(watch_html):\n    \"\"\"Check if content is private.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is private.\n    \"\"\"\n    private_strings = ['This is a private video. Please sign in to verify that you may see it.', '\"simpleText\":\"Private video\"', 'This video is private.']\n    for string in private_strings:\n        if string in watch_html:\n            return True\n    return False\n\ndef is_age_restricted(watch_html: str) -> bool:\n    \"\"\"Check if content is age restricted.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Whether or not the content is age restricted.\n    \"\"\"\n    try:\n        regex_search('og:restrictions:age', watch_html, group=0)\n    except RegexMatchError:\n        return False\n    return True\n\ndef playability_status(watch_html: str) -> (str, str):\n    \"\"\"Return the playability status and status explanation of a video.\n\n    For example, a video may have a status of LOGIN_REQUIRED, and an explanation\n    of \"This is a private video. Please sign in to verify that you may see it.\"\n\n    This explanation is what gets incorporated into the media player overlay.\n\n    :param str watch_html:\n        The html contents of the watch page.\n    :rtype: bool\n    :returns:\n        Playability status and reason of the video.\n    \"\"\"\n    player_response = initial_player_response(watch_html)\n    status_dict = player_response.get('playabilityStatus', {})\n    if 'liveStreamability' in status_dict:\n        return ('LIVE_STREAM', 'Video is a live stream.')\n    if 'status' in status_dict:\n        if 'reason' in status_dict:\n            return (status_dict['status'], [status_dict['reason']])\n        if 'messages' in status_dict:\n            return (status_dict['status'], status_dict['messages'])\n    return (None, [None])\n\ndef video_id(url: str) -> str:\n    \"\"\"Extract the ``video_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/watch?v={video_id}`\n    - :samp:`https://youtube.com/embed/{video_id}`\n    - :samp:`https://youtu.be/{video_id}`\n\n    :param str url:\n        A YouTube url containing a video id.\n    :rtype: str\n    :returns:\n        YouTube video id.\n    \"\"\"\n    return regex_search('(?:v=|\\\\/)([0-9A-Za-z_-]{11}).*', url, group=1)\n\ndef playlist_id(url: str) -> str:\n    \"\"\"Extract the ``playlist_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/playlist?list={playlist_id}`\n    - :samp:`https://youtube.com/watch?v={video_id}&list={playlist_id}`\n\n    :param str url:\n        A YouTube url containing a playlist id.\n    :rtype: str\n    :returns:\n        YouTube playlist id.\n    \"\"\"\n    parsed = urllib.parse.urlparse(url)\n    return parse_qs(parsed.query)['list'][0]\n\ndef channel_name(url: str) -> str:\n    \"\"\"Extract the ``channel_name`` or ``channel_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/c/{channel_name}/*`\n    - :samp:`https://youtube.com/channel/{channel_id}/*\n    - :samp:`https://youtube.com/u/{channel_name}/*`\n    - :samp:`https://youtube.com/user/{channel_id}/*\n\n    :param str url:\n        A YouTube url containing a channel name.\n    :rtype: str\n    :returns:\n        YouTube channel name.\n    \"\"\"\n    patterns = ['(?:\\\\/(c)\\\\/([%\\\\d\\\\w_\\\\-]+)(\\\\/.*)?)', '(?:\\\\/(channel)\\\\/([%\\\\w\\\\d_\\\\-]+)(\\\\/.*)?)', '(?:\\\\/(u)\\\\/([%\\\\d\\\\w_\\\\-]+)(\\\\/.*)?)', '(?:\\\\/(user)\\\\/([%\\\\w\\\\d_\\\\-]+)(\\\\/.*)?)']\n    for pattern in patterns:\n        regex = re.compile(pattern)\n        function_match = regex.search(url)\n        if function_match:\n            logger.debug('finished regex search, matched: %s', pattern)\n            uri_style = function_match.group(1)\n            uri_identifier = function_match.group(2)\n            return f'/{uri_style}/{uri_identifier}'\n    raise RegexMatchError(caller='channel_name', pattern='patterns')\n\ndef video_info_url(video_id: str, watch_url: str) -> str:\n    \"\"\"Construct the video_info url.\n\n    :param str video_id:\n        A YouTube video identifier.\n    :param str watch_url:\n        A YouTube watch url.\n    :rtype: str\n    :returns:\n        :samp:`https://youtube.com/get_video_info` with necessary GET\n        parameters.\n    \"\"\"\n    params = OrderedDict([('video_id', video_id), ('ps', 'default'), ('eurl', quote(watch_url)), ('hl', 'en_US'), ('html5', '1'), ('c', 'TVHTML5'), ('cver', '7.20201028')])\n    return _video_info_url(params)\n\ndef video_info_url_age_restricted(video_id: str, embed_html: str) -> str:\n    \"\"\"Construct the video_info url.\n\n    :param str video_id:\n        A YouTube video identifier.\n    :param str embed_html:\n        The html contents of the embed page (for age restricted videos).\n    :rtype: str\n    :returns:\n        :samp:`https://youtube.com/get_video_info` with necessary GET\n        parameters.\n    \"\"\"\n    try:\n        sts = regex_search('\"sts\"\\\\s*:\\\\s*(\\\\d+)', embed_html, group=1)\n    except RegexMatchError:\n        sts = ''\n    eurl = f'https://youtube.googleapis.com/v/{video_id}'\n    params = OrderedDict([('video_id', video_id), ('eurl', eurl), ('sts', sts), ('html5', '1'), ('c', 'TVHTML5'), ('cver', '7.20201028')])\n    return _video_info_url(params)\n\ndef _video_info_url(params: OrderedDict) -> str:\n    return 'https://www.youtube.com/get_video_info?' + urlencode(params)\n\ndef js_url(html: str) -> str:\n    \"\"\"Get the base JavaScript url.\n\n    Construct the base JavaScript url, which contains the decipher\n    \"transforms\".\n\n    :param str html:\n        The html contents of the watch page.\n    \"\"\"\n    try:\n        base_js = get_ytplayer_config(html)['assets']['js']\n    except (KeyError, RegexMatchError):\n        base_js = get_ytplayer_js(html)\n    return 'https://youtube.com' + base_js\n\ndef mime_type_codec(mime_type_codec: str) -> Tuple[str, List[str]]:\n    \"\"\"Parse the type data.\n\n    Breaks up the data in the ``type`` key of the manifest, which contains the\n    mime type and codecs serialized together, and splits them into separate\n    elements.\n\n    **Example**:\n\n    mime_type_codec('audio/webm; codecs=\"opus\"') -> ('audio/webm', ['opus'])\n\n    :param str mime_type_codec:\n        String containing mime type and codecs.\n    :rtype: tuple\n    :returns:\n        The mime type and a list of codecs.\n\n    \"\"\"\n    pattern = '(\\\\w+\\\\/\\\\w+)\\\\;\\\\scodecs=\\\\\"([a-zA-Z-0-9.,\\\\s]*)\\\\\"'\n    regex = re.compile(pattern)\n    results = regex.search(mime_type_codec)\n    if not results:\n        raise RegexMatchError(caller='mime_type_codec', pattern=pattern)\n    mime_type, codecs = results.groups()\n    return (mime_type, [c.strip() for c in codecs.split(',')])\n\ndef get_ytplayer_js(html: str) -> Any:\n    \"\"\"Get the YouTube player base JavaScript path.\n\n    :param str html\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Path to YouTube's base.js file.\n    \"\"\"\n    js_url_patterns = ['(/s/player/[\\\\w\\\\d]+/[\\\\w\\\\d_/.]+/base\\\\.js)']\n    for pattern in js_url_patterns:\n        regex = re.compile(pattern)\n        function_match = regex.search(html)\n        if function_match:\n            logger.debug('finished regex search, matched: %s', pattern)\n            yt_player_js = function_match.group(1)\n            return yt_player_js\n    raise RegexMatchError(caller='get_ytplayer_js', pattern='js_url_patterns')\n\ndef get_ytplayer_config(html: str) -> Any:\n    \"\"\"Get the YouTube player configuration data from the watch html.\n\n    Extract the ``ytplayer_config``, which is json data embedded within the\n    watch html and serves as the primary source of obtaining the stream\n    manifest data.\n\n    :param str html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Substring of the html containing the encoded manifest data.\n    \"\"\"\n    logger.debug('finding initial function name')\n    config_patterns = ['ytplayer\\\\.config\\\\s*=\\\\s*', 'ytInitialPlayerResponse\\\\s*=\\\\s*']\n    for pattern in config_patterns:\n        try:\n            return parse_for_object(html, pattern)\n        except HTMLParseError as e:\n            logger.debug(f'Pattern failed: {pattern}')\n            logger.debug(e)\n            continue\n    setconfig_patterns = ['yt\\\\.setConfig\\\\(.*[\\'\\\\\"]PLAYER_CONFIG[\\'\\\\\"]:\\\\s*']\n    for pattern in setconfig_patterns:\n        try:\n            return parse_for_object(html, pattern)\n        except HTMLParseError:\n            continue\n    raise RegexMatchError(caller='get_ytplayer_config', pattern='config_patterns, setconfig_patterns')\n\ndef get_ytcfg(html: str) -> str:\n    \"\"\"Get the entirety of the ytcfg object.\n\n    This is built over multiple pieces, so we have to find all matches and\n    combine the dicts together.\n\n    :param str html:\n        The html contents of the watch page.\n    :rtype: str\n    :returns:\n        Substring of the html containing the encoded manifest data.\n    \"\"\"\n    ytcfg = {}\n    ytcfg_patterns = ['ytcfg\\\\s=\\\\s', 'ytcfg\\\\.set\\\\(']\n    for pattern in ytcfg_patterns:\n        try:\n            found_objects = parse_for_all_objects(html, pattern)\n            for obj in found_objects:\n                ytcfg.update(obj)\n        except HTMLParseError:\n            continue\n    if len(ytcfg) > 0:\n        return ytcfg\n    raise RegexMatchError(caller='get_ytcfg', pattern='ytcfg_pattenrs')\n\ndef apply_signature(stream_manifest: Dict, vid_info: Dict, js: str) -> None:\n    \"\"\"Apply the decrypted signature to the stream manifest.\n\n    :param dict stream_manifest:\n        Details of the media streams available.\n    :param str js:\n        The contents of the base.js asset file.\n\n    \"\"\"\n    cipher = Cipher(js=js)\n    for i, stream in enumerate(stream_manifest):\n        try:\n            url: str = stream['url']\n        except KeyError:\n            live_stream = vid_info.get('playabilityStatus', {}).get('liveStreamability')\n            if live_stream:\n                raise LiveStreamError('UNKNOWN')\n        if 'signature' in url or ('s' not in stream and ('&sig=' in url or '&lsig=' in url)):\n            logger.debug('signature found, skip decipher')\n            continue\n        signature = cipher.get_signature(ciphered_signature=stream['s'])\n        logger.debug('finished descrambling signature for itag=%s', stream['itag'])\n        parsed_url = urlparse(url)\n        query_params = parse_qs(urlparse(url).query)\n        query_params = {k: v[0] for k, v in query_params.items()}\n        query_params['sig'] = signature\n        if 'ratebypass' not in query_params.keys():\n            initial_n = list(query_params['n'])\n            new_n = cipher.calculate_n(initial_n)\n            query_params['n'] = new_n\n        url = f'{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{urlencode(query_params)}'\n        stream_manifest[i]['url'] = url\n\ndef apply_descrambler(stream_data: Dict) -> None:\n    \"\"\"Apply various in-place transforms to YouTube's media stream data.\n\n    Creates a ``list`` of dictionaries by string splitting on commas, then\n    taking each list item, parsing it as a query string, converting it to a\n    ``dict`` and unquoting the value.\n\n    :param dict stream_data:\n        Dictionary containing query string encoded values.\n\n    **Example**:\n\n    >>> d = {'foo': 'bar=1&var=test,em=5&t=url%20encoded'}\n    >>> apply_descrambler(d, 'foo')\n    >>> print(d)\n    {'foo': [{'bar': '1', 'var': 'test'}, {'em': '5', 't': 'url encoded'}]}\n\n    \"\"\"\n    if 'url' in stream_data:\n        return None\n    formats = []\n    if 'formats' in stream_data.keys():\n        formats.extend(stream_data['formats'])\n    if 'adaptiveFormats' in stream_data.keys():\n        formats.extend(stream_data['adaptiveFormats'])\n    for data in formats:\n        if 'url' not in data:\n            if 'signatureCipher' in data:\n                cipher_url = parse_qs(data['signatureCipher'])\n                data['url'] = cipher_url['url'][0]\n                data['s'] = cipher_url['s'][0]\n        data['is_otf'] = data.get('type') == 'FORMAT_STREAM_TYPE_OTF'\n    logger.debug('applying descrambler')\n    return formats\n\ndef initial_player_response(watch_html: str) -> str:\n    \"\"\"Extract the ytInitialPlayerResponse json from the watch_html page.\n\n    This mostly contains metadata necessary for rendering the page on-load,\n    such as video information, copyright notices, etc.\n\n    @param watch_html: Html of the watch page\n    @return:\n    \"\"\"\n    patterns = ['window\\\\[[\\'\\\\\"]ytInitialPlayerResponse[\\'\\\\\"]]\\\\s*=\\\\s*', 'ytInitialPlayerResponse\\\\s*=\\\\s*']\n    for pattern in patterns:\n        try:\n            return parse_for_object(watch_html, pattern)\n        except HTMLParseError:\n            pass\n    raise RegexMatchError(caller='initial_player_response', pattern='initial_player_response_pattern')"
  },
  "call_tree": {
    "tests/test_metadata.py:test_extract_metadata_empty": {
      "pytube/extract.py:metadata": {
        "pytube/metadata.py:YouTubeMetadata:__init__": {}
      }
    },
    "tests/test_metadata.py:test_metadata_from_initial_data": {
      "pytube/extract.py:initial_data": {
        "pytube/parser.py:parse_for_object": {
          "pytube/parser.py:parse_for_object_from_startpoint": {
            "pytube/parser.py:find_object_from_startpoint": {}
          }
        }
      },
      "pytube/extract.py:metadata": {
        "pytube/metadata.py:YouTubeMetadata:__init__": {}
      },
      "pytube/metadata.py:YouTubeMetadata:raw_metadata": {},
      "pytube/metadata.py:YouTubeMetadata:metadata": {}
    }
  }
}