{
  "dir_path": "/app/pymonetdb",
  "package_name": "pymonetdb",
  "sample_name": "pymonetdb-test_target",
  "src_dir": "pymonetdb/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_target.py",
  "test_code": "#!/usr/bin/env python3\n\nimport os\nimport re\nfrom typing import List, Optional, Tuple\nfrom unittest import TestCase\nimport unittest\n\nfrom pymonetdb.target import VIRTUAL, Target, parse_bool\n\n\nclass Line(str):\n    \"\"\"A Line is a string that remembers which file and line number it came from\"\"\"\n    file: str\n    idx: int\n    nr: int\n\n    def __new__(cls, text: str, file: str, idx: int):\n        line = super().__new__(cls, text)\n        line.file = file\n        line.idx = idx\n        line.nr = idx + 1\n        return line\n\n    @property\n    def location(self):\n        return self.file + \":\" + str(self.nr)\n\n\ndef read_lines(f, filename: str, start_line=0) -> List[Line]:\n    \"\"\"Read from 'f' and turn the lines into Lines\"\"\"\n    n = start_line\n    lines = []\n    for s in f:\n        s = s.rstrip()\n        line = Line(s, filename, n)\n        lines.append(line)\n        n += 1\n    return lines\n\n\ndef split_tests(lines: List[Line]) -> List[Tuple[str, List[Line]]]:\n    tests: List[Tuple[str, List[Line]]] = []\n    cur: Optional[List[Line]] = None\n    header = None\n    count = 0\n    location = None\n    for line in lines:\n        if cur is None:\n            if line.startswith(\"```test\"):\n                location = line.location\n                cur = []\n            elif line.startswith('#'):\n                header = line.lstrip('#').strip()\n                header = re.sub(r'\\W+', '_', header).lower()\n                count = 0\n        else:\n            if line.startswith(\"```\"):\n                count += 1\n                name = f\"{header}_{count}\"\n                assert len(cur) > 0\n                tests.append((name, cur))\n                cur = None\n            else:\n                cur.append(line)\n    if cur is not None:\n        raise Exception(f\"Unclosed block at {location}\")\n    return tests\n\n\n# Note: we programmatically add test methods to this file\n# based on the contents of tests.md.\nclass TargetTests(TestCase):\n\n    def test_dummy_tests(self):\n        \"\"\"Convenience method. Run the tests from t.md if that exists.\"\"\"\n        filename = 't.md'\n        if not os.path.exists(filename):\n            raise unittest.SkipTest(f\"{filename} does not exist\")\n        lines = read_lines(open(filename), filename)\n        tests = split_tests(lines)\n        for name, test in tests:\n            self.run_test(test)\n\n    def run_test(self, test):\n        target = Target()\n        for line in test:\n            try:\n                self.apply_line(target, line)\n                continue\n            except AssertionError as e:\n                if hasattr(e, 'add_note'):\n                    e.add_note(f\"At {line.location}\")\n                    raise\n                else:\n                    raise AssertionError(f\"At {line.location}: {e}\")\n            except unittest.SkipTest:\n                break\n            except Exception as e:\n                if hasattr(e, 'add_note'):\n                    e.add_note(f\"At {line.location}\")\n                    raise\n\n    def apply_line(self, target: Target, line: Line):  # noqa C901\n        if not line:\n            return\n\n        command, rest = line.split(None, 1)\n        command = command.upper()\n        if command == \"PARSE\":\n            self.apply_parse(target, rest)\n        elif command == \"ACCEPT\":\n            self.apply_accept(target, rest)\n        elif command == \"REJECT\":\n            self.apply_reject(target, rest)\n        elif command == \"EXPECT\":\n            key, value = rest.split('=', 1)\n            self.apply_expect(target, key, value)\n        elif command == \"SET\":\n            key, value = rest.split('=', 1)\n            self.apply_set(target, key, value)\n        elif command == \"ONLY\":\n            impl = rest\n            if impl != 'pymonetdb':\n                raise unittest.SkipTest(f\"only for {impl}\")\n        elif command == \"NOT\":\n            impl = rest\n            if impl == 'pymonetdb':\n                raise unittest.SkipTest(f\"not for {impl}\")\n        else:\n            self.fail(f\"Unknown command: {command}\")\n\n    def apply_parse(self, target: Target, url):\n        target.parse(url)\n\n    def apply_accept(self, target: Target, url):\n        target.parse(url)\n        target.validate()\n\n    def apply_reject(self, target: Target, url):\n        try:\n            target.parse(url)\n        except ValueError:\n            return\n        # last hope\n        try:\n            target.validate()\n        except ValueError:\n            return\n        raise ValueError(\"Expected URL to be rejected\")\n\n    def apply_set(self, target: Target, key, value):\n        target.set(key, value)\n\n    def apply_expect(self, target: Target, key, expected_value):\n        if key == 'valid':\n            return self.apply_expect_valid(target, key, expected_value)\n\n        if key in VIRTUAL:\n            target.validate()\n\n        if key == 'connect_binary':\n            actual_value = target.connect_binary(65535)\n        else:\n            actual_value = target.get(key)\n\n        self.verify_expected_value(key, expected_value, actual_value)\n\n    def verify_expected_value(self, key, expected_value, actual_value):\n        if isinstance(actual_value, bool):\n            expected_value = parse_bool(expected_value)\n        elif isinstance(actual_value, int):\n            try:\n                expected_value = int(expected_value)\n            except ValueError:\n                # will show up in the comparison below\n                pass\n        if actual_value != expected_value:\n            self.fail(f\"Expected {key}={expected_value!r}, found {actual_value!r}\")\n\n    def apply_expect_valid(self, target, key, expected_value):\n        should_succeed = parse_bool(expected_value)\n        try:\n            target.validate()\n            if not should_succeed:\n                self.fail(\"Expected valid=false\")\n        except ValueError as e:\n            if should_succeed:\n                self.fail(f\"Expected valid=true, got error {e}\")\n        return\n\n\n# Magic alert!\n# Read tests.md and generate test cases programmatically!\nfilename = os.path.join(os.path.dirname(__file__), 'tests.md')\nlines = read_lines(open(filename), filename)\ntests = split_tests(lines)\nfor name, test in tests:\n    if test:\n        line_nr = f\"line_{test[0].nr}_\"\n    else:\n        line_nr = \"\"\n\n    def newlexicalscope(test):\n        return lambda this: this.run_test(test)\n    setattr(TargetTests, f\"tests_md_{line_nr}{name}\", newlexicalscope(test))\n",
  "GT_file_code": {
    "pymonetdb/target.py": "\"\"\"\nUtilities for parsing MonetDB URLs\n\"\"\"\n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0.  If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n#\n# Copyright 1997 - July 2008 CWI, August 2008 - 2016 MonetDB B.V.\n\n\nimport re\nfrom typing import Any, Callable, Union\nfrom urllib.parse import parse_qsl, urlparse, quote as urlquote\n\n\ndef looks_like_url(text: str) -> bool:\n    return (\n        text.startswith(\"mapi:\")\n        or text.startswith(\"monetdb:\")\n        or text.startswith(\"monetdbs:\")\n        or text.startswith(\"monetdbe:\")\n    )\n\n\n# Note that 'valid' is not in VIRTUAL:\nCORE = set(['tls', 'host', 'port', 'database', 'tableschema', 'table'])\nKNOWN = set([\n    'tls', 'host', 'port', 'database', 'tableschema', 'table',\n    'sock', 'sockdir', 'sockprefix', 'cert', 'certhash', 'clientkey', 'clientcert',\n    'user', 'password', 'language', 'autocommit', 'schema', 'timezone',\n    'binary', 'replysize', 'fetchsize', 'maxprefetch',\n    'connect_timeout',\n    'client_info', 'client_application', 'client_remark',\n])\nIGNORED = set(['hash', 'debug', 'logfile'])\nVIRTUAL = set([\n    'connect_scan', 'connect_sockdir',\n    'connect_unix', 'connect_tcp', 'connect_port',\n    'connect_tls_verify', 'connect_certhash_digits',\n    'connect_binary', 'connect_clientkey', 'connect_clientcert',\n])\n\n_BOOLEANS = dict(\n    true=True,\n    false=False,\n    yes=True,\n    no=False,\n    on=True,\n    off=False\n)\n\n_DEFAULTS = dict(\n    tls=False,\n    host=\"\",\n    port=-1,\n    database=\"\",\n    tableschema=\"\",\n    table=\"\",\n    sock=\"\",\n    sockdir=\"\",\n    sockprefix=\".s.monetdb.\",\n    cert=\"\",\n    certhash=\"\",\n    clientkey=\"\",\n    clientcert=\"\",\n    user=\"monetdb\",\n    password=\"monetdb\",\n    language=\"sql\",\n    autocommit=False,\n    schema=\"\",\n    timezone=None,\n    binary=\"on\",\n    replysize=None,\n    fetchsize=None,\n    maxprefetch=None,\n    connect_timeout=-1,\n    client_info=True,\n    client_application=\"\",\n    client_remark=\"\",\n    dangerous_tls_nocheck=\"\",\n)\n\n\ndef parse_bool(x: Union[str, bool]):\n    if isinstance(x, bool):\n        return x\n    try:\n        return _BOOLEANS[x.lower()]\n    except KeyError:\n        raise ValueError(\"invalid boolean value\")\n\n\nclass urlparam:\n    \"\"\"Decorator to create getter/setter for url parameter on a Target instance\"\"\"\n\n    field: str\n    parser: Callable[[Union[str, Any]], Any]\n\n    def __init__(self, name, typ, doc):\n        self.field = name\n        if typ == 'string' or typ == 'path':\n            self.parser = str\n        elif typ == 'integer':\n            self.parser = int\n        elif typ == 'bool':\n            self.parser = parse_bool\n        elif typ == 'float':\n            self.parser = float\n        else:\n            raise ValueError(f\"invalid type '{typ}'\")\n        self.__doc__ = doc\n\n    def __get__(self, instance, owner):\n        # don't know the meaning of the owner parameter; irrelevant?\n        return instance._VALUES.get(self.field)\n\n    def __set__(self, instance, value):\n        parsed = (self.parser)(value)\n        instance._VALUES[self.field] = parsed\n        if self.field in instance._TOUCHED:\n            instance._TOUCHED[self.field] = True\n\n    def __delete__(self, instance):\n        raise Exception(\"cannot delete url parameter\")\n\n\nclass Target:\n    \"\"\"Holds all parameters needed to connect to MonetDB.\"\"\"\n    __slots__ = [\n        '_VALUES',\n        '_OTHERS',\n        '_TOUCHED',\n    ]\n\n    def __init__(self, *, prototype=None):\n        if prototype:\n            self._VALUES = {**prototype._VALUES}\n            self._OTHERS = {**prototype._OTHERS}\n            self._TOUCHED = {**prototype._TOUCHED}\n        else:\n            self._VALUES = dict(**_DEFAULTS)\n            self._OTHERS = {}\n            self._TOUCHED = dict(user=False, password=False)\n\n    def clone(self):\n        return Target(prototype=self)\n\n    tls = urlparam('tls', 'bool', 'secure the connection using TLS')\n    host = urlparam(\n        'host', 'string', 'IP number, domain name or one of the special values `localhost` and `localhost.`')\n    port = urlparam('port', 'integer',\n                    'TCP port, also used to pick Unix Domain socket path')\n    database = urlparam('database', 'string', 'name of database to connect to')\n    tableschema = urlparam('tableschema', 'string', 'only used for REMOTE TABLE, otherwise unused')\n    table = urlparam('table', 'string', 'only used for REMOTE TABLE, otherwise unused')\n    sock = urlparam('sock', 'path', 'path to Unix Domain socket to connect to')\n    sockdir = urlparam('sockdir', 'path', 'directory where implicit Unix domain sockets are created')\n    sockprefix = urlparam('sockprefix', 'string', 'prefix for implicit Unix domain sockets')\n    cert = urlparam(\n        'cert', 'path', 'path to TLS certificate to authenticate server with')\n    certhash = urlparam(\n        'certhash', 'string', 'hash of server TLS certificate must start with these hex digits; overrides cert')\n    clientkey = urlparam(\n        'clientkey', 'path', 'path to TLS key (+certs) to authenticate with as client')\n    clientcert = urlparam(\n        'clientcert', 'path', \"path to TLS certs for 'clientkey', if not included there\")\n    user = urlparam('user', 'string', 'user name to authenticate as')\n    password = urlparam('password', 'string', 'password to authenticate with')\n    language = urlparam('language', 'string',\n                        'for example, \"sql\", \"mal\", \"msql\", \"profiler\"')\n    autocommit = urlparam('autocommit', 'bool', 'initial value of autocommit')\n    schema = urlparam('schema', 'string', 'initial schema')\n    timezone = urlparam('timezone', 'integer',\n                        'client time zone as minutes east of UTC')\n    binary = urlparam(\n        'binary', 'string', 'whether to use binary result set format (number or bool)')\n    replysize = urlparam('replysize', 'integer',\n                         'rows beyond this limit are retrieved on demand, <1 means unlimited')\n    maxprefetch = urlparam('maxprefetch', 'integer', 'specific to pymonetdb')\n    connect_timeout = urlparam('connect_timeout', 'float',\n                               'abort if connect takes longer than this; 0=block indefinitely; -1=system default')\n    client_info = urlparam('client_info', 'bool', 'whether to send client details when connecting')\n    client_application = urlparam('client_application', 'string', 'application name to send in client details')\n    client_remark = urlparam('client_remark', 'string', 'application name to send in client details')\n    dangerous_tls_nocheck = urlparam(\n        'dangerous_tls_nocheck', 'bool',\n        'comma separated certificate checks to skip, host: do not verify host, cert: do not verify certificate chain')\n\n    # alias\n    fetchsize = replysize\n\n    def set(self, key: str, value: str):\n        if key in KNOWN:\n            setattr(self, key, value)\n        elif key in IGNORED or '_' in key:\n            self._OTHERS[key] = value\n        else:\n            raise ValueError(f\"unknown parameter {key!r}\")\n\n    def get(self, key: str):\n        if key in KNOWN or key in VIRTUAL:\n            return getattr(self, key)\n        elif key in IGNORED or '_' in key:\n            return self._OTHERS[key]\n        else:\n            raise KeyError(key)\n\n    def boundary(self):\n        \"\"\"If user was set and password wasn't, clear password\"\"\"\n        if self._TOUCHED['user'] and not self._TOUCHED['password']:\n            self.password = ''\n        self._TOUCHED['user'] = False\n        self._TOUCHED['password'] = False\n\n    def summary_url(self):\n        db = self.database or ''\n        if self.sock:\n            return f\"monetdb://localhost/{db}?sock={urlquote(self.sock)}\"\n        scheme = \"monetdbs\" if self.tls else \"monetdb\"\n        host = self.host or \"localhost\"\n        if self.port and self.port > 0 and self.port != 50_000:\n            return f\"{scheme}://{host}:{self.port}/{db}\"\n        else:\n            return f\"{scheme}://{host}/{db}\"\n\n    def parse(self, url: str):\n        self.boundary()\n        if url.startswith(\"monetdb://\") or url.startswith(\"monetdbs://\"):\n            self._set_core_defaults()\n            self._parse_monetdb_url(url)\n        elif url.startswith(\"mapi:monetdb://\"):\n            self._set_core_defaults()\n            self._parse_mapi_monetdb_url(url)\n        else:\n            raise ValueError(\"URL must start with monetdb://, monetdbs:// or mapi:monetdb://\")\n        self.boundary()\n\n    def _set_core_defaults(self):\n        self.tls = False\n        self.host = ''\n        self.port = _DEFAULTS['port']\n        self.database = ''\n\n    def _parse_monetdb_url(self, url):    # noqa C901\n        parsed = urlparse(url, allow_fragments=True)\n\n        if parsed.scheme == 'monetdb':\n            self.tls = False\n        elif parsed.scheme == 'monetdbs':\n            self.tls = True\n        else:\n            raise ValueError(f\"Invalid URL scheme: {parsed.scheme}\")\n\n        if parsed.hostname is not None:\n            host = strict_percent_decode('host name', parsed.hostname)\n            if host == 'localhost':\n                host = ''\n            elif host == 'localhost.':\n                host = 'localhost'\n            self.host = host\n        if parsed.port is not None:\n            port = parsed.port\n            if port is not None and not 1 <= port <= 65535:\n                raise ValueError(f\"Invalid port number: {port}\")\n            self.port = port\n\n        path = parsed.path\n        if path:\n            parts = path.split(\"/\")\n            # 0: before leading slash, always empty\n            # 1: database name\n            # 2: schema name, ignored\n            # 3: table name, ignored\n            # more: error\n            assert parts[0] == \"\"\n            if len(parts) > 4:\n                raise ValueError(\"invalid table name: \" + '/'.join(parts[3:]))\n            self.database = strict_percent_decode('database name', parts[1])\n            if len(parts) > 2:\n                self.tableschema = strict_percent_decode('schema name', parts[2])\n            if len(parts) > 3:\n                self.table = strict_percent_decode('table name', parts[3])\n\n        if not parsed.query:\n            return\n        for key, value in parse_qsl(parsed.query, keep_blank_values=True, strict_parsing=True):\n            if not key:\n                raise ValueError(\"empty key is not allowed\")\n            key = strict_percent_decode(repr(key), key)\n            value = strict_percent_decode(f\"value of {key!r}\", value)\n            if key in CORE:\n                raise ValueError(\n                    f\"key {key!r} is not allowed in the query parameters\")\n            self.set(key, value)\n\n    def _parse_mapi_monetdb_url(self, url):    # noqa C901\n        # mapi urls have no percent encoding at all\n        parsed = urlparse(url[5:])\n        if parsed.scheme != 'monetdb':\n            raise ValueError(f\"Invalid scheme {parsed.scheme!r}\")\n        self.tls = False\n        if parsed.username is not None:\n            self.user = parsed.username\n        if parsed.password is not None:\n            self.password = parsed.password\n        if parsed.hostname is not None:\n            self.host = parsed.hostname\n        if parsed.port is not None:\n            self.port = parsed.port\n\n        path = parsed.path\n        if path is not None:\n            if parsed.hostname is None and parsed.port is None:\n                self.sock = path\n            else:\n                path = path[1:]\n                self.database = path  # validation will happen later\n\n        # parse query manually, the library functions perform percent decoding\n        if not parsed.query:\n            return\n        for part in parsed.query.split('&'):\n            # language\n            if part.startswith('language='):\n                self.language = part[9:]\n            elif part.startswith('database='):\n                self.database = part[9:]\n            elif part.startswith('user=') or part.startswith('password='):\n                # ignored because libmapi does so\n                pass\n            elif part.startswith('binary='):\n                # pymonetdb-only, backward compat\n                self.binary = part[7:]\n            elif part.startswith('replysize='):\n                # pymonetdb-only, backward compat\n                self.replysize = part[10:]\n            elif part.startswith('maxprefetch='):\n                # pymonetdb-only, backward compat\n                self.maxprefetch = part[12:]\n            else:\n                # unknown parameters are ignored\n                pass\n\n    def _parse_mapi_merovingian_url(self, url):    # noqa C901\n        # mapi urls have no percent encoding at all\n        parsed = urlparse(url[5:])\n        if parsed.scheme != 'merovingian':\n            raise ValueError(f\"Invalid scheme {parsed.scheme!r}\")\n        if parsed.username is not None:\n            self.user = parsed.username\n        if parsed.password is not None:\n            self.password = parsed.password\n        if parsed.hostname is not None:\n            self.host = parsed.hostname\n        if parsed.port is not None:\n            self.port = parsed.port\n\n        path = parsed.path\n        if path is not None:\n            if parsed.hostname is None and parsed.port is None:\n                self.sock = path\n            else:\n                path = path[1:]\n                self.database = path  # validation will happen later\n\n        # parse query manually, the library functions perform percent decoding\n        if not parsed.query:\n            return\n        for part in parsed.query.split('&'):\n            # language\n            if part.startswith('language='):\n                self.language = part[9:]\n            elif part.startswith('database='):\n                self.database = part[9:]\n            elif part.startswith('user=') or part.startswith('password='):\n                # ignored because libmapi does so\n                pass\n            elif part.startswith('binary='):\n                # pymonetdb-only, backward compat\n                self.binary = part[7:]\n            elif part.startswith('replysize='):\n                # pymonetdb-only, backward compat\n                self.replysize = part[10:]\n            elif part.startswith('maxprefetch='):\n                # pymonetdb-only, backward compat\n                self.maxprefetch = part[12:]\n            else:\n                # unknown parameters are ignored\n                pass\n\n    def validate(self):    # noqa C901\n        # 1. The parameters have the types listed in the table in [Section\n        #    Parameters](#parameters).\n        #\n        # This has already been checked by the url_param magic.\n\n        # 2. At least one of **sock** and **host** must be empty.\n        if self.sock and self.host:\n            raise ValueError(\"With sock=, host must be empty or 'localhost'\")\n\n        # 3. The string parameter **binary** must either parse as a boolean or as a\n        #    non-negative integer.\n        #\n        # Let connect_binary do all the work.\n        if self.connect_binary(1) < 0:\n            raise ValueError(\"Parameter 'binary' must be \u2265 0\")\n\n        # 4. If **sock** is not empty, **tls** must be 'off'.\n        if self.sock and self.tls:\n            raise ValueError(\"TLS cannot be used with Unix domain sockets\")\n\n        # 5. If **certhash** is not empty, it must be of the form `{sha256}hexdigits`\n        #    where hexdigits is a non-empty sequence of 0-9, a-f, A-F and colons.\n        if self.certhash and not _HASH_PATTERN.match(self.certhash):\n            raise ValueError(f\"invalid certhash: {self.certhash}\")\n\n        # 6. If **tls** is 'off', **cert** and **certhash** must be 'off' as well.\n        if not self.tls and (self.cert or self.certhash):\n            raise ValueError(\"'cert' and 'certhash' can only be used with monetdbs:\")\n\n        # 7. Parameters **database**, **tableschema** and **table** must consist only of\n        #    upper- and lowercase letters, digits, dashes and underscores. They must not\n        #    start with a dash.\n        if self.database and not _DATABASE_PATTERN.match(self.database):\n            raise ValueError(f\"invalid database name {self.database!r}\")\n        if self.tableschema and not _DATABASE_PATTERN.match(self.tableschema):\n            raise ValueError(f\"invalid schema name {self.tableschema!r}\")\n        if self.table and not _DATABASE_PATTERN.match(self.table):\n            raise ValueError(f\"invalid table name {self.table!r}\")\n\n        # 8. Parameter **port**, if present, must be in the range 1-65535.\n        if self.port != -1 and not 1 <= self.port <= 65535:\n            raise ValueError(f\"Invalid port number: {self.port}\")\n\n        # 9. If **clientcert** is set, **clientkey** must also be set.\n        if self.clientcert and not self.clientkey:\n            raise ValueError(\"clientcert can only be used together with clientkey\")\n\n        # 10. pymonetdb-specific\n        if self.connect_timeout < 0 and self.connect_timeout != -1:\n            raise ValueError(\"connection_timeout must either be >= 0 or -1\")\n\n    @property\n    def connect_scan(self):\n        if not self.database:\n            return False\n        if self.sock:\n            return False\n        if self.host and not self.host.startswith('/'):\n            return False\n        if self.port != -1:\n            return False\n        if self.tls:\n            return False\n        return True\n\n    @property\n    def connect_sockdir(self):\n        if self.sockdir:\n            return self.sockdir\n        elif self.host and self.host.startswith('/'):\n            return self.host\n        else:\n            return \"/tmp\"\n\n    @property\n    def connect_unix(self):\n        if self.sock:\n            return self.sock\n        if self.tls:\n            return \"\"\n        if self.host == \"\" or self.host.startswith('/'):\n            return f\"{self.connect_sockdir}/{self.sockprefix}{self.connect_port}\"\n        return \"\"\n\n    @property\n    def connect_tcp(self):\n        if self.sock:\n            return \"\"\n        if self.host and not self.host.startswith('/'):\n            return self.host\n        return \"localhost\"\n\n    @property\n    def connect_port(self):\n        assert self.port == -1 or 1 <= self.port <= 65535\n        if self.port == -1:\n            return 50000\n        else:\n            return self.port\n\n    @property\n    def connect_tls_verify(self):\n        if not self.tls:\n            return \"\"\n        if self.certhash:\n            return \"hash\"\n        if self.cert:\n            return \"cert\"\n        return \"system\"\n\n    @property\n    def connect_clientkey(self):\n        return self.clientkey\n\n    @property\n    def connect_clientcert(self):\n        return self.clientcert or self.clientkey\n\n    def connect_binary(self, max: int):\n        try:\n            return int(self.binary)\n        except ValueError:\n            try:\n                return max if parse_bool(self.binary) else 0\n            except ValueError:\n                raise ValueError(\"invalid value for 'binary': {self.binary}, must be int or bool\")\n\n    @property\n    def connect_certhash_digits(self):\n        m = _HASH_PATTERN.match(self.certhash)\n        if m:\n            return m.group(1).lower().replace(':', '')\n        else:\n            return None\n\n\n_UNQUOTE_PATTERN = re.compile(b\"[%](.?.?)\")\n_DATABASE_PATTERN = re.compile(\"^[A-Za-z0-9_][-A-Za-z0-9_.]*$\")\n_HASH_PATTERN = re.compile(r\"^sha256:([0-9a-fA-F:]+)$\")\n\n\ndef _unquote_fun(m) -> bytes:\n    digits = m.group(1)\n    if len(digits) != 2:\n        raise ValueError()\n    return bytes([int(digits, 16)])\n\n\ndef strict_percent_decode(context: str, text: str) -> str:\n    try:\n        return str(_UNQUOTE_PATTERN.sub(_unquote_fun, bytes(text, \"ascii\")), \"utf-8\")\n    except (ValueError, UnicodeDecodeError) as e:\n        raise ValueError(\"invalid percent escape in {context}\") from e\n"
  },
  "GT_src_dict": {
    "pymonetdb/target.py": {
      "parse_bool": {
        "code": "def parse_bool(x: Union[str, bool]):\n    \"\"\"Converts a value to a boolean based on its string representation or direct boolean input.\n\nParameters:\n- x (Union[str, bool]): The input value to be converted, which can be a string representing a boolean ('true', 'false', 'yes', 'no', 'on', 'off') or a direct boolean value.\n\nReturns:\n- bool: The boolean representation of the input.\n\nRaises:\n- ValueError: If the input is a string that does not correspond to a valid boolean representation as defined in the _BOOLEANS dictionary.\n\nDependencies:\n- _BOOLEANS (dict): A predefined dictionary that maps string representations of boolean values to their corresponding boolean types. This dictionary is defined in the global scope of the module and supports case-insensitive lookups.\"\"\"\n    if isinstance(x, bool):\n        return x\n    try:\n        return _BOOLEANS[x.lower()]\n    except KeyError:\n        raise ValueError('invalid boolean value')",
        "docstring": "Converts a value to a boolean based on its string representation or direct boolean input.\n\nParameters:\n- x (Union[str, bool]): The input value to be converted, which can be a string representing a boolean ('true', 'false', 'yes', 'no', 'on', 'off') or a direct boolean value.\n\nReturns:\n- bool: The boolean representation of the input.\n\nRaises:\n- ValueError: If the input is a string that does not correspond to a valid boolean representation as defined in the _BOOLEANS dictionary.\n\nDependencies:\n- _BOOLEANS (dict): A predefined dictionary that maps string representations of boolean values to their corresponding boolean types. This dictionary is defined in the global scope of the module and supports case-insensitive lookups.",
        "signature": "def parse_bool(x: Union[str, bool]):",
        "type": "Function",
        "class_signature": null
      },
      "Target.__init__": {
        "code": "    def __init__(self, *, prototype=None):\n        \"\"\"Initialize a Target instance for connecting to MonetDB.\n\nParameters:\n- prototype (Target, optional): An existing Target instance from which to clone parameter values. If provided, the new instance will inherit its values, touching state, and other attributes from the prototype. If not specified, the instance will be initialized with default parameter values defined in the _DEFAULTS constant.\n\nAttributes:\n- _VALUES (dict): Stores parameter values relevant for the connection, initialized from _DEFAULTS if no prototype is provided.\n- _OTHERS (dict): A dictionary to hold any extra parameters not defined as known fields.\n- _TOUCHED (dict): Tracks the state of sensitive fields like user and password, initialized to indicate that they are not touched if no prototype is used.\n\nConstants:\n- _DEFAULTS: A predefined dictionary that specifies default values for various connection parameters. This ensures all necessary fields have a valid state upon initialization.\"\"\"\n        if prototype:\n            self._VALUES = {**prototype._VALUES}\n            self._OTHERS = {**prototype._OTHERS}\n            self._TOUCHED = {**prototype._TOUCHED}\n        else:\n            self._VALUES = dict(**_DEFAULTS)\n            self._OTHERS = {}\n            self._TOUCHED = dict(user=False, password=False)",
        "docstring": "Initialize a Target instance for connecting to MonetDB.\n\nParameters:\n- prototype (Target, optional): An existing Target instance from which to clone parameter values. If provided, the new instance will inherit its values, touching state, and other attributes from the prototype. If not specified, the instance will be initialized with default parameter values defined in the _DEFAULTS constant.\n\nAttributes:\n- _VALUES (dict): Stores parameter values relevant for the connection, initialized from _DEFAULTS if no prototype is provided.\n- _OTHERS (dict): A dictionary to hold any extra parameters not defined as known fields.\n- _TOUCHED (dict): Tracks the state of sensitive fields like user and password, initialized to indicate that they are not touched if no prototype is used.\n\nConstants:\n- _DEFAULTS: A predefined dictionary that specifies default values for various connection parameters. This ensures all necessary fields have a valid state upon initialization.",
        "signature": "def __init__(self, *, prototype=None):",
        "type": "Method",
        "class_signature": "class Target:"
      },
      "Target.set": {
        "code": "    def set(self, key: str, value: str):\n        \"\"\"Sets a parameter for the Target instance based on the provided key and value.\n\nParameters:\n- key (str): The name of the parameter to set. It must be one of the parameters defined in the KNOWN set, which includes connection parameters such as 'tls', 'host', 'port', etc. If the key is unknown, a ValueError will be raised.\n- value (str): The value to assign to the specified key. The function handles both known parameters and those that are ignored (defined in the IGNORED set).\n\nSide Effects:\nThis method updates the _VALUES dictionary of the Target instance, setting the specified key to the provided value. If the key is in the IGNORED set or contains an underscore, it stores the value in the _OTHERS dictionary instead. \n\nConstants Used:\n- KNOWN: A set of valid parameter names that can be set on the Target instance.\n- IGNORED: A set of parameter names that are not to be managed explicitly but are still stored.\"\"\"\n        if key in KNOWN:\n            setattr(self, key, value)\n        elif key in IGNORED or '_' in key:\n            self._OTHERS[key] = value\n        else:\n            raise ValueError(f'unknown parameter {key!r}')",
        "docstring": "Sets a parameter for the Target instance based on the provided key and value.\n\nParameters:\n- key (str): The name of the parameter to set. It must be one of the parameters defined in the KNOWN set, which includes connection parameters such as 'tls', 'host', 'port', etc. If the key is unknown, a ValueError will be raised.\n- value (str): The value to assign to the specified key. The function handles both known parameters and those that are ignored (defined in the IGNORED set).\n\nSide Effects:\nThis method updates the _VALUES dictionary of the Target instance, setting the specified key to the provided value. If the key is in the IGNORED set or contains an underscore, it stores the value in the _OTHERS dictionary instead. \n\nConstants Used:\n- KNOWN: A set of valid parameter names that can be set on the Target instance.\n- IGNORED: A set of parameter names that are not to be managed explicitly but are still stored.",
        "signature": "def set(self, key: str, value: str):",
        "type": "Method",
        "class_signature": "class Target:"
      },
      "Target.get": {
        "code": "    def get(self, key: str):\n        \"\"\"Retrieves the value of a specified parameter from the Target instance.\n\nParameters:\n- key (str): The name of the parameter to retrieve, which must be one of the known parameters (defined in the KNOWN constant) or virtual parameters (defined in the VIRTUAL constant). If the key is found in the IGNORED constant or contains an underscore, it will attempt to retrieve the value from the _OTHERS dictionary.\n\nReturns:\n- The value associated with the specified key.\n\nRaises:\n- KeyError: If the key is not recognized (not found in KNOWN, VIRTUAL, IGNORED, or does not contain an underscore).\n\nThis method interacts primarily with the KNOWN and VIRTUAL constants to determine valid keys for retrieval and with the _OTHERS dictionary to manage parameters that are not explicitly defined as attributes of the Target instance.\"\"\"\n        if key in KNOWN or key in VIRTUAL:\n            return getattr(self, key)\n        elif key in IGNORED or '_' in key:\n            return self._OTHERS[key]\n        else:\n            raise KeyError(key)",
        "docstring": "Retrieves the value of a specified parameter from the Target instance.\n\nParameters:\n- key (str): The name of the parameter to retrieve, which must be one of the known parameters (defined in the KNOWN constant) or virtual parameters (defined in the VIRTUAL constant). If the key is found in the IGNORED constant or contains an underscore, it will attempt to retrieve the value from the _OTHERS dictionary.\n\nReturns:\n- The value associated with the specified key.\n\nRaises:\n- KeyError: If the key is not recognized (not found in KNOWN, VIRTUAL, IGNORED, or does not contain an underscore).\n\nThis method interacts primarily with the KNOWN and VIRTUAL constants to determine valid keys for retrieval and with the _OTHERS dictionary to manage parameters that are not explicitly defined as attributes of the Target instance.",
        "signature": "def get(self, key: str):",
        "type": "Method",
        "class_signature": "class Target:"
      },
      "Target.parse": {
        "code": "    def parse(self, url: str):\n        \"\"\"Parses a MonetDB connection URL to set the parameters for connecting to a database.\n\nParameters:\n- url (str): The connection URL, which must start with 'monetdb://', 'monetdbs://', or 'mapi:monetdb://'. The user's connection details are extracted from this URL and assigned to the instance attributes.\n\nBehavior:\n- Calls the boundary method to handle sensitive user/password transitions.\n- Depending on the scheme in the URL, it utilizes either `_parse_monetdb_url` or `_parse_mapi_monetdb_url` to decode and populate the relevant attributes such as `host`, `port`, `database`, etc.\n- Raises a ValueError if the URL does not conform to the expected format.\n\nDependencies:\n- Utilizes `_set_core_defaults` to initialize core attributes before parsing.\n- Interacts with internal attributes like `_VALUES` for storing parsed parameters and `_TOUCHED` to track changes.\"\"\"\n        self.boundary()\n        if url.startswith('monetdb://') or url.startswith('monetdbs://'):\n            self._set_core_defaults()\n            self._parse_monetdb_url(url)\n        elif url.startswith('mapi:monetdb://'):\n            self._set_core_defaults()\n            self._parse_mapi_monetdb_url(url)\n        else:\n            raise ValueError('URL must start with monetdb://, monetdbs:// or mapi:monetdb://')\n        self.boundary()",
        "docstring": "Parses a MonetDB connection URL to set the parameters for connecting to a database.\n\nParameters:\n- url (str): The connection URL, which must start with 'monetdb://', 'monetdbs://', or 'mapi:monetdb://'. The user's connection details are extracted from this URL and assigned to the instance attributes.\n\nBehavior:\n- Calls the boundary method to handle sensitive user/password transitions.\n- Depending on the scheme in the URL, it utilizes either `_parse_monetdb_url` or `_parse_mapi_monetdb_url` to decode and populate the relevant attributes such as `host`, `port`, `database`, etc.\n- Raises a ValueError if the URL does not conform to the expected format.\n\nDependencies:\n- Utilizes `_set_core_defaults` to initialize core attributes before parsing.\n- Interacts with internal attributes like `_VALUES` for storing parsed parameters and `_TOUCHED` to track changes.",
        "signature": "def parse(self, url: str):",
        "type": "Method",
        "class_signature": "class Target:"
      },
      "Target.validate": {
        "code": "    def validate(self):\n        \"\"\"Validate the connection parameters of the Target instance to ensure they comply with MonetDB's connection requirements.\n\nThis method checks the following conditions:\n1. Ensures at least one of `sock` and `host` is empty.\n2. Validates that `binary` parses as a boolean or non-negative integer.\n3. Checks that `tls` is not enabled when `sock` is specified.\n4. Verifies that `certhash`, if set, matches the expected format.\n5. Confirms that `cert` and `certhash` are not specified if `tls` is off.\n6. Validates that `database`, `tableschema`, and `table` names conform to allowed patterns.\n7. Ensures `port` is within the valid range of 1-65535.\n8. Ensures that if `clientcert` is set, `clientkey` must also be set.\n9. Validates specific conditions related to `connect_timeout`.\n\nConstants used:\n- `_HASH_PATTERN`: A compiled regex pattern for validating `certhash` format; defined at the module level.\n- `_DATABASE_PATTERN`: A regex pattern that ensures valid naming conventions for `database`, `tableschema`, and `table`; also defined at the module level.\n\nThis method raises `ValueError` if any check fails, providing a detail of the validation failure.\"\"\"\n        if self.sock and self.host:\n            raise ValueError(\"With sock=, host must be empty or 'localhost'\")\n        if self.connect_binary(1) < 0:\n            raise ValueError(\"Parameter 'binary' must be \u2265 0\")\n        if self.sock and self.tls:\n            raise ValueError('TLS cannot be used with Unix domain sockets')\n        if self.certhash and (not _HASH_PATTERN.match(self.certhash)):\n            raise ValueError(f'invalid certhash: {self.certhash}')\n        if not self.tls and (self.cert or self.certhash):\n            raise ValueError(\"'cert' and 'certhash' can only be used with monetdbs:\")\n        if self.database and (not _DATABASE_PATTERN.match(self.database)):\n            raise ValueError(f'invalid database name {self.database!r}')\n        if self.tableschema and (not _DATABASE_PATTERN.match(self.tableschema)):\n            raise ValueError(f'invalid schema name {self.tableschema!r}')\n        if self.table and (not _DATABASE_PATTERN.match(self.table)):\n            raise ValueError(f'invalid table name {self.table!r}')\n        if self.port != -1 and (not 1 <= self.port <= 65535):\n            raise ValueError(f'Invalid port number: {self.port}')\n        if self.clientcert and (not self.clientkey):\n            raise ValueError('clientcert can only be used together with clientkey')\n        if self.connect_timeout < 0 and self.connect_timeout != -1:\n            raise ValueError('connection_timeout must either be >= 0 or -1')",
        "docstring": "Validate the connection parameters of the Target instance to ensure they comply with MonetDB's connection requirements.\n\nThis method checks the following conditions:\n1. Ensures at least one of `sock` and `host` is empty.\n2. Validates that `binary` parses as a boolean or non-negative integer.\n3. Checks that `tls` is not enabled when `sock` is specified.\n4. Verifies that `certhash`, if set, matches the expected format.\n5. Confirms that `cert` and `certhash` are not specified if `tls` is off.\n6. Validates that `database`, `tableschema`, and `table` names conform to allowed patterns.\n7. Ensures `port` is within the valid range of 1-65535.\n8. Ensures that if `clientcert` is set, `clientkey` must also be set.\n9. Validates specific conditions related to `connect_timeout`.\n\nConstants used:\n- `_HASH_PATTERN`: A compiled regex pattern for validating `certhash` format; defined at the module level.\n- `_DATABASE_PATTERN`: A regex pattern that ensures valid naming conventions for `database`, `tableschema`, and `table`; also defined at the module level.\n\nThis method raises `ValueError` if any check fails, providing a detail of the validation failure.",
        "signature": "def validate(self):",
        "type": "Method",
        "class_signature": "class Target:"
      },
      "Target.connect_binary": {
        "code": "    def connect_binary(self, max: int):\n        \"\"\"Determine the binary connection setting for the MonetDB instance.\n\nParameters:\n- max (int): The maximum value to consider if the 'binary' parameter is interpreted as a boolean. This value is returned when 'binary' is evaluated as True.\n\nReturns:\n- int: The value representing the binary connection setting. The return value can either be the integer value of 'binary', or\n  - a provided max value if 'binary' is True,\n  - or 0 if 'binary' is False.\n\nRaises:\n- ValueError: If 'binary' cannot be converted to an integer or a boolean, an exception is raised, indicating an invalid value for 'binary'.\n\nThe function interacts with a class attribute 'binary', which is defined as a urlparam in the Target class. This attribute can either be a boolean or a string representing an integer, influencing how the connection to MonetDB handles result set formats.\"\"\"\n        try:\n            return int(self.binary)\n        except ValueError:\n            try:\n                return max if parse_bool(self.binary) else 0\n            except ValueError:\n                raise ValueError(\"invalid value for 'binary': {self.binary}, must be int or bool\")",
        "docstring": "Determine the binary connection setting for the MonetDB instance.\n\nParameters:\n- max (int): The maximum value to consider if the 'binary' parameter is interpreted as a boolean. This value is returned when 'binary' is evaluated as True.\n\nReturns:\n- int: The value representing the binary connection setting. The return value can either be the integer value of 'binary', or\n  - a provided max value if 'binary' is True,\n  - or 0 if 'binary' is False.\n\nRaises:\n- ValueError: If 'binary' cannot be converted to an integer or a boolean, an exception is raised, indicating an invalid value for 'binary'.\n\nThe function interacts with a class attribute 'binary', which is defined as a urlparam in the Target class. This attribute can either be a boolean or a string representing an integer, influencing how the connection to MonetDB handles result set formats.",
        "signature": "def connect_binary(self, max: int):",
        "type": "Method",
        "class_signature": "class Target:"
      }
    }
  },
  "dependency_dict": {
    "pymonetdb/target.py:Target:set": {
      "pymonetdb/target.py": {
        "urlparam.__set__": {
          "code": "    def __set__(self, instance, value):\n        parsed = self.parser(value)\n        instance._VALUES[self.field] = parsed\n        if self.field in instance._TOUCHED:\n            instance._TOUCHED[self.field] = True",
          "docstring": "",
          "signature": "def __set__(self, instance, value):",
          "type": "Method",
          "class_signature": "class urlparam:"
        }
      }
    },
    "pymonetdb/target.py:Target:validate": {
      "pymonetdb/target.py": {
        "urlparam.__get__": {
          "code": "    def __get__(self, instance, owner):\n        return instance._VALUES.get(self.field)",
          "docstring": "",
          "signature": "def __get__(self, instance, owner):",
          "type": "Method",
          "class_signature": "class urlparam:"
        }
      }
    },
    "pymonetdb/target.py:Target:get": {
      "pymonetdb/target.py": {
        "urlparam.__get__": {
          "code": "    def __get__(self, instance, owner):\n        return instance._VALUES.get(self.field)",
          "docstring": "",
          "signature": "def __get__(self, instance, owner):",
          "type": "Method",
          "class_signature": "class urlparam:"
        },
        "Target.connect_scan": {
          "code": "    def connect_scan(self):\n        if not self.database:\n            return False\n        if self.sock:\n            return False\n        if self.host and (not self.host.startswith('/')):\n            return False\n        if self.port != -1:\n            return False\n        if self.tls:\n            return False\n        return True",
          "docstring": "",
          "signature": "def connect_scan(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_sockdir": {
          "code": "    def connect_sockdir(self):\n        if self.sockdir:\n            return self.sockdir\n        elif self.host and self.host.startswith('/'):\n            return self.host\n        else:\n            return '/tmp'",
          "docstring": "",
          "signature": "def connect_sockdir(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_unix": {
          "code": "    def connect_unix(self):\n        if self.sock:\n            return self.sock\n        if self.tls:\n            return ''\n        if self.host == '' or self.host.startswith('/'):\n            return f'{self.connect_sockdir}/{self.sockprefix}{self.connect_port}'\n        return ''",
          "docstring": "",
          "signature": "def connect_unix(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_tcp": {
          "code": "    def connect_tcp(self):\n        if self.sock:\n            return ''\n        if self.host and (not self.host.startswith('/')):\n            return self.host\n        return 'localhost'",
          "docstring": "",
          "signature": "def connect_tcp(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_port": {
          "code": "    def connect_port(self):\n        assert self.port == -1 or 1 <= self.port <= 65535\n        if self.port == -1:\n            return 50000\n        else:\n            return self.port",
          "docstring": "",
          "signature": "def connect_port(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_tls_verify": {
          "code": "    def connect_tls_verify(self):\n        if not self.tls:\n            return ''\n        if self.certhash:\n            return 'hash'\n        if self.cert:\n            return 'cert'\n        return 'system'",
          "docstring": "",
          "signature": "def connect_tls_verify(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_clientkey": {
          "code": "    def connect_clientkey(self):\n        return self.clientkey",
          "docstring": "",
          "signature": "def connect_clientkey(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_clientcert": {
          "code": "    def connect_clientcert(self):\n        return self.clientcert or self.clientkey",
          "docstring": "",
          "signature": "def connect_clientcert(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target.connect_certhash_digits": {
          "code": "    def connect_certhash_digits(self):\n        m = _HASH_PATTERN.match(self.certhash)\n        if m:\n            return m.group(1).lower().replace(':', '')\n        else:\n            return None",
          "docstring": "",
          "signature": "def connect_certhash_digits(self):",
          "type": "Method",
          "class_signature": "class Target:"
        }
      }
    },
    "pymonetdb/target.py:Target:connect_binary": {
      "pymonetdb/target.py": {
        "urlparam.__get__": {
          "code": "    def __get__(self, instance, owner):\n        return instance._VALUES.get(self.field)",
          "docstring": "",
          "signature": "def __get__(self, instance, owner):",
          "type": "Method",
          "class_signature": "class urlparam:"
        }
      }
    },
    "pymonetdb/target.py:Target:parse": {
      "pymonetdb/target.py": {
        "Target.boundary": {
          "code": "    def boundary(self):\n        \"\"\"If user was set and password wasn't, clear password\"\"\"\n        if self._TOUCHED['user'] and (not self._TOUCHED['password']):\n            self.password = ''\n        self._TOUCHED['user'] = False\n        self._TOUCHED['password'] = False",
          "docstring": "If user was set and password wasn't, clear password",
          "signature": "def boundary(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target._set_core_defaults": {
          "code": "    def _set_core_defaults(self):\n        self.tls = False\n        self.host = ''\n        self.port = _DEFAULTS['port']\n        self.database = ''",
          "docstring": "",
          "signature": "def _set_core_defaults(self):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target._parse_monetdb_url": {
          "code": "    def _parse_monetdb_url(self, url):\n        parsed = urlparse(url, allow_fragments=True)\n        if parsed.scheme == 'monetdb':\n            self.tls = False\n        elif parsed.scheme == 'monetdbs':\n            self.tls = True\n        else:\n            raise ValueError(f'Invalid URL scheme: {parsed.scheme}')\n        if parsed.hostname is not None:\n            host = strict_percent_decode('host name', parsed.hostname)\n            if host == 'localhost':\n                host = ''\n            elif host == 'localhost.':\n                host = 'localhost'\n            self.host = host\n        if parsed.port is not None:\n            port = parsed.port\n            if port is not None and (not 1 <= port <= 65535):\n                raise ValueError(f'Invalid port number: {port}')\n            self.port = port\n        path = parsed.path\n        if path:\n            parts = path.split('/')\n            assert parts[0] == ''\n            if len(parts) > 4:\n                raise ValueError('invalid table name: ' + '/'.join(parts[3:]))\n            self.database = strict_percent_decode('database name', parts[1])\n            if len(parts) > 2:\n                self.tableschema = strict_percent_decode('schema name', parts[2])\n            if len(parts) > 3:\n                self.table = strict_percent_decode('table name', parts[3])\n        if not parsed.query:\n            return\n        for key, value in parse_qsl(parsed.query, keep_blank_values=True, strict_parsing=True):\n            if not key:\n                raise ValueError('empty key is not allowed')\n            key = strict_percent_decode(repr(key), key)\n            value = strict_percent_decode(f'value of {key!r}', value)\n            if key in CORE:\n                raise ValueError(f'key {key!r} is not allowed in the query parameters')\n            self.set(key, value)",
          "docstring": "",
          "signature": "def _parse_monetdb_url(self, url):",
          "type": "Method",
          "class_signature": "class Target:"
        },
        "Target._parse_mapi_monetdb_url": {
          "code": "    def _parse_mapi_monetdb_url(self, url):\n        parsed = urlparse(url[5:])\n        if parsed.scheme != 'monetdb':\n            raise ValueError(f'Invalid scheme {parsed.scheme!r}')\n        self.tls = False\n        if parsed.username is not None:\n            self.user = parsed.username\n        if parsed.password is not None:\n            self.password = parsed.password\n        if parsed.hostname is not None:\n            self.host = parsed.hostname\n        if parsed.port is not None:\n            self.port = parsed.port\n        path = parsed.path\n        if path is not None:\n            if parsed.hostname is None and parsed.port is None:\n                self.sock = path\n            else:\n                path = path[1:]\n                self.database = path\n        if not parsed.query:\n            return\n        for part in parsed.query.split('&'):\n            if part.startswith('language='):\n                self.language = part[9:]\n            elif part.startswith('database='):\n                self.database = part[9:]\n            elif part.startswith('user=') or part.startswith('password='):\n                pass\n            elif part.startswith('binary='):\n                self.binary = part[7:]\n            elif part.startswith('replysize='):\n                self.replysize = part[10:]\n            elif part.startswith('maxprefetch='):\n                self.maxprefetch = part[12:]\n            else:\n                pass",
          "docstring": "",
          "signature": "def _parse_mapi_monetdb_url(self, url):",
          "type": "Method",
          "class_signature": "class Target:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pymonetdb-test_target\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pymonetdb/\n    \u2514\u2500\u2500 target.py\n        \u251c\u2500\u2500 Target.__init__\n        \u251c\u2500\u2500 Target.connect_binary\n        \u251c\u2500\u2500 Target.get\n        \u251c\u2500\u2500 Target.parse\n        \u251c\u2500\u2500 Target.set\n        \u251c\u2500\u2500 Target.validate\n        \u2514\u2500\u2500 parse_bool\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the automated testing and validation of target configuration logic implemented in the `pymonetdb` library by programmatically generating and executing test cases derived from a Markdown file (`tests.md`). It provides functionality to parse and interpret test definitions, execute various commands against the `Target` class, and verify behavior through assertions, ensuring correct handling of operations such as parsing, validation, and property management. This module streamlines the process of testing configuration rules by allowing developers to define test scenarios in a readable format and enabling dynamic execution without manual test case creation, thus promoting efficiency and consistency in maintaining robust validation logic.\n\n## FILE 1: pymonetdb/target.py\n\n- CLASS METHOD: Target.set\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def set(self, key: str, value: str):\n  - DOCSTRING: \n```python\n\"\"\"\nSets a parameter for the Target instance based on the provided key and value.\n\nParameters:\n- key (str): The name of the parameter to set. It must be one of the parameters defined in the KNOWN set, which includes connection parameters such as 'tls', 'host', 'port', etc. If the key is unknown, a ValueError will be raised.\n- value (str): The value to assign to the specified key. The function handles both known parameters and those that are ignored (defined in the IGNORED set).\n\nSide Effects:\nThis method updates the _VALUES dictionary of the Target instance, setting the specified key to the provided value. If the key is in the IGNORED set or contains an underscore, it stores the value in the _OTHERS dictionary instead. \n\nConstants Used:\n- KNOWN: A set of valid parameter names that can be set on the Target instance.\n- IGNORED: A set of parameter names that are not to be managed explicitly but are still stored.\n\"\"\"\n```\n\n- FUNCTION NAME: parse_bool\n  - SIGNATURE: def parse_bool(x: Union[str, bool]):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a value to a boolean based on its string representation or direct boolean input.\n\nParameters:\n- x (Union[str, bool]): The input value to be converted, which can be a string representing a boolean ('true', 'false', 'yes', 'no', 'on', 'off') or a direct boolean value.\n\nReturns:\n- bool: The boolean representation of the input.\n\nRaises:\n- ValueError: If the input is a string that does not correspond to a valid boolean representation as defined in the _BOOLEANS dictionary.\n\nDependencies:\n- _BOOLEANS (dict): A predefined dictionary that maps string representations of boolean values to their corresponding boolean types. This dictionary is defined in the global scope of the module and supports case-insensitive lookups.\n\"\"\"\n```\n\n- CLASS METHOD: Target.get\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def get(self, key: str):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the value of a specified parameter from the Target instance.\n\nParameters:\n- key (str): The name of the parameter to retrieve, which must be one of the known parameters (defined in the KNOWN constant) or virtual parameters (defined in the VIRTUAL constant). If the key is found in the IGNORED constant or contains an underscore, it will attempt to retrieve the value from the _OTHERS dictionary.\n\nReturns:\n- The value associated with the specified key.\n\nRaises:\n- KeyError: If the key is not recognized (not found in KNOWN, VIRTUAL, IGNORED, or does not contain an underscore).\n\nThis method interacts primarily with the KNOWN and VIRTUAL constants to determine valid keys for retrieval and with the _OTHERS dictionary to manage parameters that are not explicitly defined as attributes of the Target instance.\n\"\"\"\n```\n\n- CLASS METHOD: Target.parse\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def parse(self, url: str):\n  - DOCSTRING: \n```python\n\"\"\"\nParses a MonetDB connection URL to set the parameters for connecting to a database.\n\nParameters:\n- url (str): The connection URL, which must start with 'monetdb://', 'monetdbs://', or 'mapi:monetdb://'. The user's connection details are extracted from this URL and assigned to the instance attributes.\n\nBehavior:\n- Calls the boundary method to handle sensitive user/password transitions.\n- Depending on the scheme in the URL, it utilizes either `_parse_monetdb_url` or `_parse_mapi_monetdb_url` to decode and populate the relevant attributes such as `host`, `port`, `database`, etc.\n- Raises a ValueError if the URL does not conform to the expected format.\n\nDependencies:\n- Utilizes `_set_core_defaults` to initialize core attributes before parsing.\n- Interacts with internal attributes like `_VALUES` for storing parsed parameters and `_TOUCHED` to track changes.\n\"\"\"\n```\n\n- CLASS METHOD: Target.validate\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def validate(self):\n  - DOCSTRING: \n```python\n\"\"\"\nValidate the connection parameters of the Target instance to ensure they comply with MonetDB's connection requirements.\n\nThis method checks the following conditions:\n1. Ensures at least one of `sock` and `host` is empty.\n2. Validates that `binary` parses as a boolean or non-negative integer.\n3. Checks that `tls` is not enabled when `sock` is specified.\n4. Verifies that `certhash`, if set, matches the expected format.\n5. Confirms that `cert` and `certhash` are not specified if `tls` is off.\n6. Validates that `database`, `tableschema`, and `table` names conform to allowed patterns.\n7. Ensures `port` is within the valid range of 1-65535.\n8. Ensures that if `clientcert` is set, `clientkey` must also be set.\n9. Validates specific conditions related to `connect_timeout`.\n\nConstants used:\n- `_HASH_PATTERN`: A compiled regex pattern for validating `certhash` format; defined at the module level.\n- `_DATABASE_PATTERN`: A regex pattern that ensures valid naming conventions for `database`, `tableschema`, and `table`; also defined at the module level.\n\nThis method raises `ValueError` if any check fails, providing a detail of the validation failure.\n\"\"\"\n```\n\n- CLASS METHOD: Target.connect_binary\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def connect_binary(self, max: int):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine the binary connection setting for the MonetDB instance.\n\nParameters:\n- max (int): The maximum value to consider if the 'binary' parameter is interpreted as a boolean. This value is returned when 'binary' is evaluated as True.\n\nReturns:\n- int: The value representing the binary connection setting. The return value can either be the integer value of 'binary', or\n  - a provided max value if 'binary' is True,\n  - or 0 if 'binary' is False.\n\nRaises:\n- ValueError: If 'binary' cannot be converted to an integer or a boolean, an exception is raised, indicating an invalid value for 'binary'.\n\nThe function interacts with a class attribute 'binary', which is defined as a urlparam in the Target class. This attribute can either be a boolean or a string representing an integer, influencing how the connection to MonetDB handles result set formats.\n\"\"\"\n```\n\n- CLASS METHOD: Target.__init__\n  - CLASS SIGNATURE: class Target:\n  - SIGNATURE: def __init__(self, *, prototype=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Target instance for connecting to MonetDB.\n\nParameters:\n- prototype (Target, optional): An existing Target instance from which to clone parameter values. If provided, the new instance will inherit its values, touching state, and other attributes from the prototype. If not specified, the instance will be initialized with default parameter values defined in the _DEFAULTS constant.\n\nAttributes:\n- _VALUES (dict): Stores parameter values relevant for the connection, initialized from _DEFAULTS if no prototype is provided.\n- _OTHERS (dict): A dictionary to hold any extra parameters not defined as known fields.\n- _TOUCHED (dict): Tracks the state of sensitive fields like user and password, initialized to indicate that they are not touched if no prototype is used.\n\nConstants:\n- _DEFAULTS: A predefined dictionary that specifies default values for various connection parameters. This ensures all necessary fields have a valid state upon initialization.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pymonetdb/target.py": "\"\"\"\nUtilities for parsing MonetDB URLs\n\"\"\"\nimport re\nfrom typing import Any, Callable, Union\nfrom urllib.parse import parse_qsl, urlparse, quote as urlquote\n\ndef looks_like_url(text: str) -> bool:\n    return text.startswith('mapi:') or text.startswith('monetdb:') or text.startswith('monetdbs:') or text.startswith('monetdbe:')\nCORE = set(['tls', 'host', 'port', 'database', 'tableschema', 'table'])\nKNOWN = set(['tls', 'host', 'port', 'database', 'tableschema', 'table', 'sock', 'sockdir', 'sockprefix', 'cert', 'certhash', 'clientkey', 'clientcert', 'user', 'password', 'language', 'autocommit', 'schema', 'timezone', 'binary', 'replysize', 'fetchsize', 'maxprefetch', 'connect_timeout', 'client_info', 'client_application', 'client_remark'])\nIGNORED = set(['hash', 'debug', 'logfile'])\nVIRTUAL = set(['connect_scan', 'connect_sockdir', 'connect_unix', 'connect_tcp', 'connect_port', 'connect_tls_verify', 'connect_certhash_digits', 'connect_binary', 'connect_clientkey', 'connect_clientcert'])\n_BOOLEANS = dict(true=True, false=False, yes=True, no=False, on=True, off=False)\n_DEFAULTS = dict(tls=False, host='', port=-1, database='', tableschema='', table='', sock='', sockdir='', sockprefix='.s.monetdb.', cert='', certhash='', clientkey='', clientcert='', user='monetdb', password='monetdb', language='sql', autocommit=False, schema='', timezone=None, binary='on', replysize=None, fetchsize=None, maxprefetch=None, connect_timeout=-1, client_info=True, client_application='', client_remark='', dangerous_tls_nocheck='')\n\nclass urlparam:\n    \"\"\"Decorator to create getter/setter for url parameter on a Target instance\"\"\"\n    field: str\n    parser: Callable[[Union[str, Any]], Any]\n\n    def __init__(self, name, typ, doc):\n        self.field = name\n        if typ == 'string' or typ == 'path':\n            self.parser = str\n        elif typ == 'integer':\n            self.parser = int\n        elif typ == 'bool':\n            self.parser = parse_bool\n        elif typ == 'float':\n            self.parser = float\n        else:\n            raise ValueError(f\"invalid type '{typ}'\")\n        self.__doc__ = doc\n\n    def __get__(self, instance, owner):\n        return instance._VALUES.get(self.field)\n\n    def __set__(self, instance, value):\n        parsed = self.parser(value)\n        instance._VALUES[self.field] = parsed\n        if self.field in instance._TOUCHED:\n            instance._TOUCHED[self.field] = True\n\n    def __delete__(self, instance):\n        raise Exception('cannot delete url parameter')\n\nclass Target:\n    \"\"\"Holds all parameters needed to connect to MonetDB.\"\"\"\n    __slots__ = ['_VALUES', '_OTHERS', '_TOUCHED']\n\n    def clone(self):\n        return Target(prototype=self)\n    tls = urlparam('tls', 'bool', 'secure the connection using TLS')\n    host = urlparam('host', 'string', 'IP number, domain name or one of the special values `localhost` and `localhost.`')\n    port = urlparam('port', 'integer', 'TCP port, also used to pick Unix Domain socket path')\n    database = urlparam('database', 'string', 'name of database to connect to')\n    tableschema = urlparam('tableschema', 'string', 'only used for REMOTE TABLE, otherwise unused')\n    table = urlparam('table', 'string', 'only used for REMOTE TABLE, otherwise unused')\n    sock = urlparam('sock', 'path', 'path to Unix Domain socket to connect to')\n    sockdir = urlparam('sockdir', 'path', 'directory where implicit Unix domain sockets are created')\n    sockprefix = urlparam('sockprefix', 'string', 'prefix for implicit Unix domain sockets')\n    cert = urlparam('cert', 'path', 'path to TLS certificate to authenticate server with')\n    certhash = urlparam('certhash', 'string', 'hash of server TLS certificate must start with these hex digits; overrides cert')\n    clientkey = urlparam('clientkey', 'path', 'path to TLS key (+certs) to authenticate with as client')\n    clientcert = urlparam('clientcert', 'path', \"path to TLS certs for 'clientkey', if not included there\")\n    user = urlparam('user', 'string', 'user name to authenticate as')\n    password = urlparam('password', 'string', 'password to authenticate with')\n    language = urlparam('language', 'string', 'for example, \"sql\", \"mal\", \"msql\", \"profiler\"')\n    autocommit = urlparam('autocommit', 'bool', 'initial value of autocommit')\n    schema = urlparam('schema', 'string', 'initial schema')\n    timezone = urlparam('timezone', 'integer', 'client time zone as minutes east of UTC')\n    binary = urlparam('binary', 'string', 'whether to use binary result set format (number or bool)')\n    replysize = urlparam('replysize', 'integer', 'rows beyond this limit are retrieved on demand, <1 means unlimited')\n    maxprefetch = urlparam('maxprefetch', 'integer', 'specific to pymonetdb')\n    connect_timeout = urlparam('connect_timeout', 'float', 'abort if connect takes longer than this; 0=block indefinitely; -1=system default')\n    client_info = urlparam('client_info', 'bool', 'whether to send client details when connecting')\n    client_application = urlparam('client_application', 'string', 'application name to send in client details')\n    client_remark = urlparam('client_remark', 'string', 'application name to send in client details')\n    dangerous_tls_nocheck = urlparam('dangerous_tls_nocheck', 'bool', 'comma separated certificate checks to skip, host: do not verify host, cert: do not verify certificate chain')\n    fetchsize = replysize\n\n    def boundary(self):\n        \"\"\"If user was set and password wasn't, clear password\"\"\"\n        if self._TOUCHED['user'] and (not self._TOUCHED['password']):\n            self.password = ''\n        self._TOUCHED['user'] = False\n        self._TOUCHED['password'] = False\n\n    def summary_url(self):\n        db = self.database or ''\n        if self.sock:\n            return f'monetdb://localhost/{db}?sock={urlquote(self.sock)}'\n        scheme = 'monetdbs' if self.tls else 'monetdb'\n        host = self.host or 'localhost'\n        if self.port and self.port > 0 and (self.port != 50000):\n            return f'{scheme}://{host}:{self.port}/{db}'\n        else:\n            return f'{scheme}://{host}/{db}'\n\n    def _set_core_defaults(self):\n        self.tls = False\n        self.host = ''\n        self.port = _DEFAULTS['port']\n        self.database = ''\n\n    def _parse_monetdb_url(self, url):\n        parsed = urlparse(url, allow_fragments=True)\n        if parsed.scheme == 'monetdb':\n            self.tls = False\n        elif parsed.scheme == 'monetdbs':\n            self.tls = True\n        else:\n            raise ValueError(f'Invalid URL scheme: {parsed.scheme}')\n        if parsed.hostname is not None:\n            host = strict_percent_decode('host name', parsed.hostname)\n            if host == 'localhost':\n                host = ''\n            elif host == 'localhost.':\n                host = 'localhost'\n            self.host = host\n        if parsed.port is not None:\n            port = parsed.port\n            if port is not None and (not 1 <= port <= 65535):\n                raise ValueError(f'Invalid port number: {port}')\n            self.port = port\n        path = parsed.path\n        if path:\n            parts = path.split('/')\n            assert parts[0] == ''\n            if len(parts) > 4:\n                raise ValueError('invalid table name: ' + '/'.join(parts[3:]))\n            self.database = strict_percent_decode('database name', parts[1])\n            if len(parts) > 2:\n                self.tableschema = strict_percent_decode('schema name', parts[2])\n            if len(parts) > 3:\n                self.table = strict_percent_decode('table name', parts[3])\n        if not parsed.query:\n            return\n        for key, value in parse_qsl(parsed.query, keep_blank_values=True, strict_parsing=True):\n            if not key:\n                raise ValueError('empty key is not allowed')\n            key = strict_percent_decode(repr(key), key)\n            value = strict_percent_decode(f'value of {key!r}', value)\n            if key in CORE:\n                raise ValueError(f'key {key!r} is not allowed in the query parameters')\n            self.set(key, value)\n\n    def _parse_mapi_monetdb_url(self, url):\n        parsed = urlparse(url[5:])\n        if parsed.scheme != 'monetdb':\n            raise ValueError(f'Invalid scheme {parsed.scheme!r}')\n        self.tls = False\n        if parsed.username is not None:\n            self.user = parsed.username\n        if parsed.password is not None:\n            self.password = parsed.password\n        if parsed.hostname is not None:\n            self.host = parsed.hostname\n        if parsed.port is not None:\n            self.port = parsed.port\n        path = parsed.path\n        if path is not None:\n            if parsed.hostname is None and parsed.port is None:\n                self.sock = path\n            else:\n                path = path[1:]\n                self.database = path\n        if not parsed.query:\n            return\n        for part in parsed.query.split('&'):\n            if part.startswith('language='):\n                self.language = part[9:]\n            elif part.startswith('database='):\n                self.database = part[9:]\n            elif part.startswith('user=') or part.startswith('password='):\n                pass\n            elif part.startswith('binary='):\n                self.binary = part[7:]\n            elif part.startswith('replysize='):\n                self.replysize = part[10:]\n            elif part.startswith('maxprefetch='):\n                self.maxprefetch = part[12:]\n            else:\n                pass\n\n    def _parse_mapi_merovingian_url(self, url):\n        parsed = urlparse(url[5:])\n        if parsed.scheme != 'merovingian':\n            raise ValueError(f'Invalid scheme {parsed.scheme!r}')\n        if parsed.username is not None:\n            self.user = parsed.username\n        if parsed.password is not None:\n            self.password = parsed.password\n        if parsed.hostname is not None:\n            self.host = parsed.hostname\n        if parsed.port is not None:\n            self.port = parsed.port\n        path = parsed.path\n        if path is not None:\n            if parsed.hostname is None and parsed.port is None:\n                self.sock = path\n            else:\n                path = path[1:]\n                self.database = path\n        if not parsed.query:\n            return\n        for part in parsed.query.split('&'):\n            if part.startswith('language='):\n                self.language = part[9:]\n            elif part.startswith('database='):\n                self.database = part[9:]\n            elif part.startswith('user=') or part.startswith('password='):\n                pass\n            elif part.startswith('binary='):\n                self.binary = part[7:]\n            elif part.startswith('replysize='):\n                self.replysize = part[10:]\n            elif part.startswith('maxprefetch='):\n                self.maxprefetch = part[12:]\n            else:\n                pass\n\n    @property\n    def connect_scan(self):\n        if not self.database:\n            return False\n        if self.sock:\n            return False\n        if self.host and (not self.host.startswith('/')):\n            return False\n        if self.port != -1:\n            return False\n        if self.tls:\n            return False\n        return True\n\n    @property\n    def connect_sockdir(self):\n        if self.sockdir:\n            return self.sockdir\n        elif self.host and self.host.startswith('/'):\n            return self.host\n        else:\n            return '/tmp'\n\n    @property\n    def connect_unix(self):\n        if self.sock:\n            return self.sock\n        if self.tls:\n            return ''\n        if self.host == '' or self.host.startswith('/'):\n            return f'{self.connect_sockdir}/{self.sockprefix}{self.connect_port}'\n        return ''\n\n    @property\n    def connect_tcp(self):\n        if self.sock:\n            return ''\n        if self.host and (not self.host.startswith('/')):\n            return self.host\n        return 'localhost'\n\n    @property\n    def connect_port(self):\n        assert self.port == -1 or 1 <= self.port <= 65535\n        if self.port == -1:\n            return 50000\n        else:\n            return self.port\n\n    @property\n    def connect_tls_verify(self):\n        if not self.tls:\n            return ''\n        if self.certhash:\n            return 'hash'\n        if self.cert:\n            return 'cert'\n        return 'system'\n\n    @property\n    def connect_clientkey(self):\n        return self.clientkey\n\n    @property\n    def connect_clientcert(self):\n        return self.clientcert or self.clientkey\n\n    @property\n    def connect_certhash_digits(self):\n        m = _HASH_PATTERN.match(self.certhash)\n        if m:\n            return m.group(1).lower().replace(':', '')\n        else:\n            return None\n_UNQUOTE_PATTERN = re.compile(b'[%](.?.?)')\n_DATABASE_PATTERN = re.compile('^[A-Za-z0-9_][-A-Za-z0-9_.]*$')\n_HASH_PATTERN = re.compile('^sha256:([0-9a-fA-F:]+)$')\n\ndef _unquote_fun(m) -> bytes:\n    digits = m.group(1)\n    if len(digits) != 2:\n        raise ValueError()\n    return bytes([int(digits, 16)])\n\ndef strict_percent_decode(context: str, text: str) -> str:\n    try:\n        return str(_UNQUOTE_PATTERN.sub(_unquote_fun, bytes(text, 'ascii')), 'utf-8')\n    except (ValueError, UnicodeDecodeError) as e:\n        raise ValueError('invalid percent escape in {context}') from e"
  },
  "call_tree": {
    "modified_testcases/test_target.py:read_lines": {
      "modified_testcases/test_target.py:Line:__new__": {}
    },
    "modified_testcases/test_target.py:split_tests": {
      "modified_testcases/test_target.py:Line:location": {}
    },
    "modified_testcases/test_target.py:TargetTests:run_test": {
      "pymonetdb/target.py:Target:__init__": {},
      "modified_testcases/test_target.py:TargetTests:apply_line": {
        "modified_testcases/test_target.py:TargetTests:apply_set": {
          "pymonetdb/target.py:Target:set": {
            "pymonetdb/target.py:urlparam:__set__": {
              "pymonetdb/target.py:parse_bool": {}
            }
          }
        },
        "modified_testcases/test_target.py:TargetTests:apply_expect": {
          "modified_testcases/test_target.py:TargetTests:apply_expect_valid": {
            "pymonetdb/target.py:parse_bool": {},
            "pymonetdb/target.py:Target:validate": {
              "pymonetdb/target.py:urlparam:__get__": {},
              "pymonetdb/target.py:Target:connect_binary": {
                "pymonetdb/target.py:urlparam:__get__": {},
                "pymonetdb/target.py:parse_bool": {}
              }
            }
          },
          "pymonetdb/target.py:Target:validate": {
            "pymonetdb/target.py:urlparam:__get__": {},
            "pymonetdb/target.py:Target:connect_binary": {
              "pymonetdb/target.py:urlparam:__get__": {},
              "pymonetdb/target.py:parse_bool": {}
            }
          },
          "pymonetdb/target.py:Target:get": {
            "pymonetdb/target.py:Target:connect_tls_verify": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_scan": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_unix": {
              "pymonetdb/target.py:urlparam:__get__": {},
              "pymonetdb/target.py:Target:connect_sockdir": {
                "pymonetdb/target.py:urlparam:__get__": {}
              },
              "pymonetdb/target.py:Target:connect_port": {
                "pymonetdb/target.py:urlparam:__get__": {}
              }
            },
            "pymonetdb/target.py:Target:connect_tcp": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_port": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:urlparam:__get__": {},
            "pymonetdb/target.py:Target:connect_sockdir": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_certhash_digits": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_clientkey": {
              "pymonetdb/target.py:urlparam:__get__": {}
            },
            "pymonetdb/target.py:Target:connect_clientcert": {
              "pymonetdb/target.py:urlparam:__get__": {}
            }
          },
          "modified_testcases/test_target.py:TargetTests:verify_expected_value": {
            "pymonetdb/target.py:parse_bool": {}
          },
          "pymonetdb/target.py:Target:connect_binary": {
            "pymonetdb/target.py:urlparam:__get__": {},
            "pymonetdb/target.py:parse_bool": {}
          }
        },
        "modified_testcases/test_target.py:TargetTests:apply_accept": {
          "pymonetdb/target.py:Target:parse": {
            "pymonetdb/target.py:Target:boundary": {
              "pymonetdb/target.py:urlparam:__set__": {}
            },
            "pymonetdb/target.py:Target:_set_core_defaults": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            },
            "pymonetdb/target.py:Target:_parse_monetdb_url": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              },
              "pymonetdb/target.py:strict_percent_decode": {
                "pymonetdb/target.py:_unquote_fun": {}
              },
              "pymonetdb/target.py:Target:set": {
                "pymonetdb/target.py:urlparam:__set__": {
                  "pymonetdb/target.py:parse_bool": {}
                }
              }
            },
            "pymonetdb/target.py:Target:_parse_mapi_monetdb_url": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            }
          },
          "pymonetdb/target.py:Target:validate": {
            "pymonetdb/target.py:urlparam:__get__": {},
            "pymonetdb/target.py:Target:connect_binary": {
              "pymonetdb/target.py:urlparam:__get__": {},
              "pymonetdb/target.py:parse_bool": {}
            }
          }
        },
        "modified_testcases/test_target.py:TargetTests:apply_reject": {
          "pymonetdb/target.py:Target:parse": {
            "pymonetdb/target.py:Target:boundary": {},
            "pymonetdb/target.py:Target:_set_core_defaults": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            },
            "pymonetdb/target.py:Target:_parse_monetdb_url": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              },
              "pymonetdb/target.py:strict_percent_decode": {
                "pymonetdb/target.py:_unquote_fun": {}
              },
              "pymonetdb/target.py:Target:set": {
                "pymonetdb/target.py:urlparam:__set__": {
                  "pymonetdb/target.py:parse_bool": {}
                }
              }
            },
            "pymonetdb/target.py:Target:_parse_mapi_monetdb_url": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            }
          },
          "pymonetdb/target.py:Target:validate": {
            "pymonetdb/target.py:urlparam:__get__": {},
            "pymonetdb/target.py:Target:connect_binary": {
              "pymonetdb/target.py:urlparam:__get__": {},
              "pymonetdb/target.py:parse_bool": {}
            }
          }
        },
        "modified_testcases/test_target.py:TargetTests:apply_parse": {
          "pymonetdb/target.py:Target:parse": {
            "pymonetdb/target.py:Target:boundary": {},
            "pymonetdb/target.py:Target:_set_core_defaults": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            },
            "pymonetdb/target.py:Target:_parse_mapi_monetdb_url": {
              "pymonetdb/target.py:urlparam:__set__": {
                "pymonetdb/target.py:parse_bool": {}
              }
            }
          }
        }
      }
    }
  }
}