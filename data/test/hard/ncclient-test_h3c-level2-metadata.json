{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_h3c",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_h3c.py",
  "test_code": "import unittest\nfrom ncclient.devices.h3c import *\n\n\ncapabilities = ['urn:ietf:params:netconf:base:1.0',\n                'urn:ietf:params:netconf:base:1.1',\n                'urn:ietf:params:netconf:capability:writable-running:1.0',\n                'urn:ietf:params:netconf:capability:candidate:1.0',\n                'urn:ietf:params:netconf:capability:confirmed-commit:1.0',\n                'urn:ietf:params:netconf:capability:rollback-on-error:1.0',\n                'urn:ietf:params:netconf:capability:startup:1.0',\n                'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp',\n                'urn:ietf:params:netconf:capability:validate:1.0',\n                'urn:ietf:params:netconf:capability:xpath:1.0',\n                'urn:ietf:params:netconf:capability:notification:1.0',\n                'urn:ietf:params:netconf:capability:interleave:1.0',\n                'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n\nclass TestH3cDevice(unittest.TestCase):\n\n    def setUp(self):\n        self.obj = H3cDeviceHandler({'name': 'h3c'})\n\n    def test_add_additional_operations(self):\n        expected = dict()\n        expected['get_bulk'] = GetBulk\n        expected['get_bulk_config'] = GetBulkConfig\n        expected['cli'] = CLI\n        expected['action'] = Action\n        expected['save'] = Save\n        expected['load'] = Load\n        expected['rollback'] = Rollback\n        self.assertDictEqual(expected, self.obj.add_additional_operations())\n\n    def test_get_capabilities(self):\n        self.assertListEqual(capabilities, self.obj.get_capabilities())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected['nsmap'] = self.obj.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n\n    def test_perform_qualify_check(self):\n        self.assertFalse(self.obj.perform_qualify_check())\n",
  "GT_file_code": {
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/devices/h3c.py": "\"\"\"\nHandler for H3c device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"H3c\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.h3c.rpc import *\n\n\nclass H3cDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    H3C handler for device specific information.\n\n    In the device_params dictionary, which is passed to __init__, you can specify\n    the parameter \"ssh_subsystem_name\". That allows you to configure the preferred\n    SSH subsystem name that should be tried on your H3C switch. If connecting with\n    that name fails, or you didn't specify that name, the other known subsystem names\n    will be tried. However, if you specify it then this name will be tried first.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n\n    def __init__(self, device_params):\n        super(H3cDeviceHandler, self).__init__(device_params)\n\n    def add_additional_operations(self):\n        dict = {}\n        dict[\"get_bulk\"] = GetBulk\n        dict[\"get_bulk_config\"] = GetBulkConfig\n        dict[\"cli\"] = CLI\n        dict[\"action\"] = Action\n        dict[\"save\"] = Save\n        dict[\"load\"] = Load\n        dict[\"rollback\"] = Rollback\n        return dict\n\n    def get_capabilities(self):\n        # Just need to replace a single value in the default capabilities\n        c = super(H3cDeviceHandler, self).get_capabilities()\n        return c\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def perform_qualify_check(self):\n        return False\n"
  },
  "GT_src_dict": {
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initializes a DefaultDeviceHandler instance, setting up device-specific parameters and configuring error handling for RPC responses.\n\nParameters:\n- device_params (optional): A dictionary of parameters specific to the device being handled. This can include information like device type, connection settings, etc.\n\nAttributes:\n- self.device_params: Stores the device-specific parameters passed during initialization.\n- self.capabilities: Initializes an empty list for storing NETCONF capabilities specific to the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists created to categorize exempt error messages (defined in the class constant _EXEMPT_ERRORS), which are used to determine whether an error message should raise an exception during RPC operations.\n\nThe _EXEMPT_ERRORS constant is defined as an empty list by default but can be overridden in subclasses to specify particular error messages that should be ignored. Each error message is normalized to lowercase to facilitate case-insensitive comparisons, and categorized based on whether they have wildcard characters.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initializes a DefaultDeviceHandler instance, setting up device-specific parameters and configuring error handling for RPC responses.\n\nParameters:\n- device_params (optional): A dictionary of parameters specific to the device being handled. This can include information like device type, connection settings, etc.\n\nAttributes:\n- self.device_params: Stores the device-specific parameters passed during initialization.\n- self.capabilities: Initializes an empty list for storing NETCONF capabilities specific to the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists created to categorize exempt error messages (defined in the class constant _EXEMPT_ERRORS), which are used to determine whether an error message should raise an exception during RPC operations.\n\nThe _EXEMPT_ERRORS constant is defined as an empty list by default but can be overridden in subclasses to specify particular error messages that should be ignored. Each error message is normalized to lowercase to facilitate case-insensitive comparisons, and categorized based on whether they have wildcard characters.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      },
      "DefaultDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Return the list of capabilities for the device handler.\n\nThis method combines the base capabilities defined in the `_BASE_CAPABILITIES` class attribute, which includes standard NETCONF capabilities, with any additional capabilities that may have been specified in the `self.capabilities` attribute. This combined list is used during the initial capability exchange in NETCONF communication.\n\nReturns:\n    list: A list of URIs representing the client's capabilities.\n\nConstants:\n- `_BASE_CAPABILITIES`: A class attribute that contains a list of standard capabilities supported by the device handler. This list is foundational for establishing capabilities during NETCONF sessions and should be extended in device-specific subclasses if necessary.\"\"\"\n        \"\\n        Return the capability list.\\n\\n        A list of URI's representing the client's capabilities. This is used during\\n        the initial capability exchange. Modify (in a new device-handler subclass)\\n        as needed.\\n\\n        \"\n        return self._BASE_CAPABILITIES + self.capabilities",
        "docstring": "Return the list of capabilities for the device handler.\n\nThis method combines the base capabilities defined in the `_BASE_CAPABILITIES` class attribute, which includes standard NETCONF capabilities, with any additional capabilities that may have been specified in the `self.capabilities` attribute. This combined list is used during the initial capability exchange in NETCONF communication.\n\nReturns:\n    list: A list of URIs representing the client's capabilities.\n\nConstants:\n- `_BASE_CAPABILITIES`: A class attribute that contains a list of standard capabilities supported by the device handler. This list is foundational for establishing capabilities during NETCONF sessions and should be extended in device-specific subclasses if necessary.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/devices/h3c.py": {
      "H3cDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initialize an instance of the H3cDeviceHandler class, which is responsible for managing H3C device-specific operations.\n\nParameters:\n    device_params (dict): A dictionary containing parameters for device configuration. This may include the key \"ssh_subsystem_name\" to specify a preferred SSH subsystem for connecting to the H3C switch.\n\nThis constructor calls the constructor of the parent class, DefaultDeviceHandler, to initialize shared functionality for interactions with a Netconf server. No return value is provided as this method is a constructor.\"\"\"\n        super(H3cDeviceHandler, self).__init__(device_params)",
        "docstring": "Initialize an instance of the H3cDeviceHandler class, which is responsible for managing H3C device-specific operations.\n\nParameters:\n    device_params (dict): A dictionary containing parameters for device configuration. This may include the key \"ssh_subsystem_name\" to specify a preferred SSH subsystem for connecting to the H3C switch.\n\nThis constructor calls the constructor of the parent class, DefaultDeviceHandler, to initialize shared functionality for interactions with a Netconf server. No return value is provided as this method is a constructor.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      },
      "H3cDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Returns a dictionary of additional operations specific to the H3C device.\n\nThis method defines and returns a dictionary mapping operation names to their corresponding classes, including operations such as 'get_bulk', 'get_bulk_config', 'cli', 'action', 'save', 'load', and 'rollback'. These operations are imported from the H3C specific library, enabling extended functionality beyond the default operations provided by the parent class.\n\nReturns:\n    dict: A dictionary where keys are operation names as strings and values are the corresponding operation classes.\n\nDependencies:\n    - GetBulk, GetBulkConfig, CLI, Action, Save, Load, Rollback: These operation classes are imported from `ncclient.operations.third_party.h3c.rpc` and provide functionality specific to H3C devices.\"\"\"\n        dict = {}\n        dict['get_bulk'] = GetBulk\n        dict['get_bulk_config'] = GetBulkConfig\n        dict['cli'] = CLI\n        dict['action'] = Action\n        dict['save'] = Save\n        dict['load'] = Load\n        dict['rollback'] = Rollback\n        return dict",
        "docstring": "Returns a dictionary of additional operations specific to the H3C device.\n\nThis method defines and returns a dictionary mapping operation names to their corresponding classes, including operations such as 'get_bulk', 'get_bulk_config', 'cli', 'action', 'save', 'load', and 'rollback'. These operations are imported from the H3C specific library, enabling extended functionality beyond the default operations provided by the parent class.\n\nReturns:\n    dict: A dictionary where keys are operation names as strings and values are the corresponding operation classes.\n\nDependencies:\n    - GetBulk, GetBulkConfig, CLI, Action, Save, Load, Rollback: These operation classes are imported from `ncclient.operations.third_party.h3c.rpc` and provide functionality specific to H3C devices.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      },
      "H3cDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Retrieve the capabilities of the H3C device handler.\n\nThis method overrides the `get_capabilities` method from the `DefaultDeviceHandler` class to return the capabilities of an H3C device. It does not modify the capabilities itself but serves as a placeholder for any specific adjustments related to H3C devices if necessary. The method does not take any parameters and relies on the capabilities provided by the superclass.\n\nReturns:\n    dict: The capabilities of the H3C device, as retrieved from the superclass method.\n\nDependencies:\n    - This method calls `super(H3cDeviceHandler, self).get_capabilities()` to obtain the base capabilities from `DefaultDeviceHandler`.\"\"\"\n        c = super(H3cDeviceHandler, self).get_capabilities()\n        return c",
        "docstring": "Retrieve the capabilities of the H3C device handler.\n\nThis method overrides the `get_capabilities` method from the `DefaultDeviceHandler` class to return the capabilities of an H3C device. It does not modify the capabilities itself but serves as a placeholder for any specific adjustments related to H3C devices if necessary. The method does not take any parameters and relies on the capabilities provided by the superclass.\n\nReturns:\n    dict: The capabilities of the H3C device, as retrieved from the superclass method.\n\nDependencies:\n    - This method calls `super(H3cDeviceHandler, self).get_capabilities()` to obtain the base capabilities from `DefaultDeviceHandler`.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      },
      "H3cDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary mapping the XML namespace for the H3C device. The key is set to None, and the value is BASE_NS_1_0, which defines the base namespace version used for XML operations specific to H3C devices.\n\nReturns:\n    dict: A dictionary containing the base namespace, where None is the key and BASE_NS_1_0 is its value.\n\nDependencies:\n    BASE_NS_1_0: This constant is likely defined elsewhere in the code, possibly in a module related to H3C device configurations, and denotes the specific XML namespace that adheres to the standards expected by the device's Netconf implementation.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary mapping the XML namespace for the H3C device. The key is set to None, and the value is BASE_NS_1_0, which defines the base namespace version used for XML operations specific to H3C devices.\n\nReturns:\n    dict: A dictionary containing the base namespace, where None is the key and BASE_NS_1_0 is its value.\n\nDependencies:\n    BASE_NS_1_0: This constant is likely defined elsewhere in the code, possibly in a module related to H3C device configurations, and denotes the specific XML namespace that adheres to the standards expected by the device's Netconf implementation.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      },
      "H3cDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing extra XML namespace prefixes for H3C devices.\n\nThis method retrieves the base XML namespace dictionary from `get_xml_base_namespace_dict()` \nand constructs a new dictionary with the key \"nsmap\". The returned dictionary is used for \nnamespace mapping in XML operations specific to H3C devices. \n\nParameters:\n    None\n\nReturns:\n    dict: A dictionary with a single entry where the key is \"nsmap\" and the value is another\n    dictionary containing the XML base namespace mappings.\n\nDependencies:\n    - The method `get_xml_base_namespace_dict()` is called to retrieve the base namespace dictionary, \n      which includes the constant `BASE_NS_1_0`. This constant represents the base namespace used \n      in XML operations and is imported from the relevant module.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing extra XML namespace prefixes for H3C devices.\n\nThis method retrieves the base XML namespace dictionary from `get_xml_base_namespace_dict()` \nand constructs a new dictionary with the key \"nsmap\". The returned dictionary is used for \nnamespace mapping in XML operations specific to H3C devices. \n\nParameters:\n    None\n\nReturns:\n    dict: A dictionary with a single entry where the key is \"nsmap\" and the value is another\n    dictionary containing the XML base namespace mappings.\n\nDependencies:\n    - The method `get_xml_base_namespace_dict()` is called to retrieve the base namespace dictionary, \n      which includes the constant `BASE_NS_1_0`. This constant represents the base namespace used \n      in XML operations and is imported from the relevant module.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      },
      "H3cDeviceHandler.perform_qualify_check": {
        "code": "    def perform_qualify_check(self):\n        \"\"\"Perform a qualification check for the H3C device.\n\nThis method always returns False, indicating that no qualification check is necessary or applicable for the H3C device being managed. It overrides the `perform_qualify_check` method from the parent class `DefaultDeviceHandler` to provide a device-specific implementation.\n\nReturns:\n    bool: False, signifying that qualification is not applied for this device handler.\"\"\"\n        return False",
        "docstring": "Perform a qualification check for the H3C device.\n\nThis method always returns False, indicating that no qualification check is necessary or applicable for the H3C device being managed. It overrides the `perform_qualify_check` method from the parent class `DefaultDeviceHandler` to provide a device-specific implementation.\n\nReturns:\n    bool: False, signifying that qualification is not applied for this device handler.",
        "signature": "def perform_qualify_check(self):",
        "type": "Method",
        "class_signature": "class H3cDeviceHandler(DefaultDeviceHandler):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/h3c.py:H3cDeviceHandler:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {},
    "ncclient/devices/h3c.py:H3cDeviceHandler:get_capabilities": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {},
    "ncclient/devices/h3c.py:H3cDeviceHandler:get_xml_extra_prefix_kwargs": {},
    "ncclient/devices/h3c.py:H3cDeviceHandler:get_xml_base_namespace_dict": {}
  },
  "PRD": "# PROJECT NAME: ncclient-test_h3c\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 default.py\n    \u2502   \u2502   \u251c\u2500\u2500 DefaultDeviceHandler.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultDeviceHandler.get_capabilities\n    \u2502   \u2514\u2500\u2500 h3c.py\n    \u2502       \u251c\u2500\u2500 H3cDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 H3cDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 H3cDeviceHandler.get_capabilities\n    \u2502       \u251c\u2500\u2500 H3cDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u251c\u2500\u2500 H3cDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2502       \u2514\u2500\u2500 H3cDeviceHandler.perform_qualify_check\n    \u2514\u2500\u2500 transport/\n        \u2514\u2500\u2500 errors.py\n            \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a device handler to integrate and manage H3C network devices using the NETCONF protocol, encapsulating essential operations and capabilities specific to H3C devices. It supports a range of NETCONF capabilities, including configuration management, validation, rollback, and custom operations such as bulk retrieval and CLI execution, tailored to H3C devices. This module simplifies the interaction with H3C devices for developers by abstracting low-level NETCONF mechanisms, offering a standardized interface to perform advanced configurations, manage device states, and execute device-specific operations effectively. By doing so, it reduces the complexity of handling H3C devices in automation workflows and improves the efficiency of network management processes.\n\n## FILE 1: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the list of capabilities for the device handler.\n\nThis method combines the base capabilities defined in the `_BASE_CAPABILITIES` class attribute, which includes standard NETCONF capabilities, with any additional capabilities that may have been specified in the `self.capabilities` attribute. This combined list is used during the initial capability exchange in NETCONF communication.\n\nReturns:\n    list: A list of URIs representing the client's capabilities.\n\nConstants:\n- `_BASE_CAPABILITIES`: A class attribute that contains a list of standard capabilities supported by the device handler. This list is foundational for establishing capabilities during NETCONF sessions and should be extended in device-specific subclasses if necessary.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DefaultDeviceHandler instance, setting up device-specific parameters and configuring error handling for RPC responses.\n\nParameters:\n- device_params (optional): A dictionary of parameters specific to the device being handled. This can include information like device type, connection settings, etc.\n\nAttributes:\n- self.device_params: Stores the device-specific parameters passed during initialization.\n- self.capabilities: Initializes an empty list for storing NETCONF capabilities specific to the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists created to categorize exempt error messages (defined in the class constant _EXEMPT_ERRORS), which are used to determine whether an error message should raise an exception during RPC operations.\n\nThe _EXEMPT_ERRORS constant is defined as an empty list by default but can be overridden in subclasses to specify particular error messages that should be ignored. Each error message is normalized to lowercase to facilitate case-insensitive comparisons, and categorized based on whether they have wildcard characters.\n\"\"\"\n```\n\n## FILE 2: ncclient/transport/errors.py\n\n## FILE 3: ncclient/devices/h3c.py\n\n- CLASS METHOD: H3cDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary of additional operations specific to the H3C device.\n\nThis method defines and returns a dictionary mapping operation names to their corresponding classes, including operations such as 'get_bulk', 'get_bulk_config', 'cli', 'action', 'save', 'load', and 'rollback'. These operations are imported from the H3C specific library, enabling extended functionality beyond the default operations provided by the parent class.\n\nReturns:\n    dict: A dictionary where keys are operation names as strings and values are the corresponding operation classes.\n\nDependencies:\n    - GetBulk, GetBulkConfig, CLI, Action, Save, Load, Rollback: These operation classes are imported from `ncclient.operations.third_party.h3c.rpc` and provide functionality specific to H3C devices.\n\"\"\"\n```\n\n- CLASS METHOD: H3cDeviceHandler.__init__\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the H3cDeviceHandler class, which is responsible for managing H3C device-specific operations.\n\nParameters:\n    device_params (dict): A dictionary containing parameters for device configuration. This may include the key \"ssh_subsystem_name\" to specify a preferred SSH subsystem for connecting to the H3C switch.\n\nThis constructor calls the constructor of the parent class, DefaultDeviceHandler, to initialize shared functionality for interactions with a Netconf server. No return value is provided as this method is a constructor.\n\"\"\"\n```\n\n- CLASS METHOD: H3cDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary mapping the XML namespace for the H3C device. The key is set to None, and the value is BASE_NS_1_0, which defines the base namespace version used for XML operations specific to H3C devices.\n\nReturns:\n    dict: A dictionary containing the base namespace, where None is the key and BASE_NS_1_0 is its value.\n\nDependencies:\n    BASE_NS_1_0: This constant is likely defined elsewhere in the code, possibly in a module related to H3C device configurations, and denotes the specific XML namespace that adheres to the standards expected by the device's Netconf implementation.\n\"\"\"\n```\n\n- CLASS METHOD: H3cDeviceHandler.perform_qualify_check\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def perform_qualify_check(self):\n  - DOCSTRING: \n```python\n\"\"\"\nPerform a qualification check for the H3C device.\n\nThis method always returns False, indicating that no qualification check is necessary or applicable for the H3C device being managed. It overrides the `perform_qualify_check` method from the parent class `DefaultDeviceHandler` to provide a device-specific implementation.\n\nReturns:\n    bool: False, signifying that qualification is not applied for this device handler.\n\"\"\"\n```\n\n- CLASS METHOD: H3cDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the capabilities of the H3C device handler.\n\nThis method overrides the `get_capabilities` method from the `DefaultDeviceHandler` class to return the capabilities of an H3C device. It does not modify the capabilities itself but serves as a placeholder for any specific adjustments related to H3C devices if necessary. The method does not take any parameters and relies on the capabilities provided by the superclass.\n\nReturns:\n    dict: The capabilities of the H3C device, as retrieved from the superclass method.\n\nDependencies:\n    - This method calls `super(H3cDeviceHandler, self).get_capabilities()` to obtain the base capabilities from `DefaultDeviceHandler`.\n\"\"\"\n```\n\n- CLASS METHOD: H3cDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class H3cDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing extra XML namespace prefixes for H3C devices.\n\nThis method retrieves the base XML namespace dictionary from `get_xml_base_namespace_dict()` \nand constructs a new dictionary with the key \"nsmap\". The returned dictionary is used for \nnamespace mapping in XML operations specific to H3C devices. \n\nParameters:\n    None\n\nReturns:\n    dict: A dictionary with a single entry where the key is \"nsmap\" and the value is another\n    dictionary containing the XML base namespace mappings.\n\nDependencies:\n    - The method `get_xml_base_namespace_dict()` is called to retrieve the base namespace dictionary, \n      which includes the constant `BASE_NS_1_0`. This constant represents the base namespace used \n      in XML operations and is imported from the relevant module.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/devices/h3c.py": "\"\"\"\nHandler for H3c device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"H3c\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.h3c.rpc import *\n\nclass H3cDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    H3C handler for device specific information.\n\n    In the device_params dictionary, which is passed to __init__, you can specify\n    the parameter \"ssh_subsystem_name\". That allows you to configure the preferred\n    SSH subsystem name that should be tried on your H3C switch. If connecting with\n    that name fails, or you didn't specify that name, the other known subsystem names\n    will be tried. However, if you specify it then this name will be tried first.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []"
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_h3c.py:TestH3cDevice:setUp": {
      "ncclient/devices/h3c.py:H3cDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_h3c.py:TestH3cDevice:test_add_additional_operations": {
      "ncclient/devices/h3c.py:H3cDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_h3c.py:TestH3cDevice:test_get_capabilities": {
      "ncclient/devices/h3c.py:H3cDeviceHandler:get_capabilities": {
        "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {}
      }
    },
    "modified_testcases/unit/devices/test_h3c.py:TestH3cDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/h3c.py:H3cDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/h3c.py:H3cDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/h3c.py:H3cDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "modified_testcases/unit/devices/test_h3c.py:TestH3cDevice:test_perform_qualify_check": {
      "ncclient/devices/h3c.py:H3cDeviceHandler:perform_qualify_check": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}