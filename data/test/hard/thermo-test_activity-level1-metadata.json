{
  "dir_path": "/app/thermo",
  "package_name": "thermo",
  "sample_name": "thermo-test_activity",
  "src_dir": "thermo/",
  "test_dir": "tests/",
  "test_file": "tests/test_activity.py",
  "test_code": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2021 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'''\n\nimport json\nimport pickle\n\nimport numpy as np\nfrom fluids.numerics import assert_close\n\nfrom thermo.activity import IdealSolution\nfrom thermo.test_utils import check_np_output_activity\n\n\ndef test_IdealSolution():\n    GE = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n\n    assert 0.0 == GE.GE()\n    assert 0.0 == GE.dGE_dT()\n    assert 0.0 == GE.d2GE_dT2()\n    assert 0.0 == GE.d3GE_dT3()\n\n    assert GE.d2GE_dTdxs() == [0.0]*4\n    assert GE.dGE_dxs() == [0.0]*4\n    assert GE.d2GE_dxixjs() == [[0.0]*4 for _ in range(4)]\n    assert GE.d3GE_dxixjxks() == [[[0.0]*4 for _ in range(4)] for _ in range(4)]\n\n\n    assert_close(GE.gammas(), [1]*4, atol=0)\n    assert_close(GE.gammas_dGE_dxs(), [1]*4, atol=0)\n    assert_close(GE.gammas_infinite_dilution(), [1]*4, atol=0)\n\n\n\n    assert eval(str(GE)).GE() == GE.GE()\n\n    string = GE.as_json()\n    assert 'json_version' in string\n\n    assert IdealSolution.from_json(string).__dict__ == GE.__dict__\n\n\ndef test_IdealSolution_numpy_output():\n    model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n    modelnp = IdealSolution(T=300.0, xs=np.array([.1, .2, .3, .4]))\n    modelnp2 = modelnp.to_T_xs(T=model.T*(1.0-1e-16), xs=np.array([.1, .2, .3, .4]))\n    check_np_output_activity(model, modelnp, modelnp2)\n\n    json_string = modelnp.as_json()\n    new = IdealSolution.from_json(json_string)\n    assert new == modelnp\n\n    new = IdealSolution.from_json(json.loads(json.dumps(modelnp.as_json())))\n    assert new == modelnp\n\n\n    assert model.model_hash() == modelnp.model_hash()\n    assert new.model_hash() == modelnp.model_hash()\n    assert new.model_hash() == modelnp2.model_hash()\n\n    # Pickle checks\n    modelnp_pickle = pickle.loads(pickle.dumps(modelnp))\n    assert modelnp_pickle == modelnp\n    model_pickle = pickle.loads(pickle.dumps(model))\n    assert model_pickle == model\n\n\n\ndef test_IdealSolution():\n    GE = IdealSolution(T=300.0, xs=[1])\n    for s in GE._point_properties:\n        if hasattr(GE, s):\n            res = getattr(GE, s)()\n",
  "GT_file_code": {
    "thermo/activity.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2016, 2017, 2018, 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nThis module contains a base class :obj:`GibbsExcess` for handling activity\ncoefficient based\nmodels. The design is for a sub-class to provide the minimum possible number of\nderivatives of Gibbs energy, and for this base class to provide the rest of the\nmethods.  An ideal-liquid class with no excess Gibbs energy\n:obj:`IdealSolution` is also available.\n\nFor reporting bugs, adding feature requests, or submitting pull requests,\nplease use the `GitHub issue tracker <https://github.com/CalebBell/thermo/>`_.\n\n.. contents:: :local:\n\nBase Class\n==========\n\n.. autoclass:: GibbsExcess\n    :members:\n    :undoc-members:\n    :show-inheritance:\n    :exclude-members: d2GE_dT2_numerical, d2GE_dTdxs_numerical, d2GE_dxixjs_numerical, d3GE_dT3_numerical, dGE_dT_numerical, dGE_dxs_numerical\n    :special-members: __hash__, __eq__, __repr__\n\nIdeal Liquid Class\n==================\n\n.. autoclass:: IdealSolution\n    :members: to_T_xs, GE, dGE_dT, d2GE_dT2, d3GE_dT3, d2GE_dTdxs, dGE_dxs, d2GE_dxixjs, d3GE_dxixjxks\n    :undoc-members:\n    :show-inheritance:\n    :exclude-members: gammas\n\nNotes\n-----\n=====\nExcellent references for working with activity coefficient models are [1]_ and\n[2]_.\n\nReferences\n----------\n.. [1] Walas, Stanley M. Phase Equilibria in Chemical Engineering.\n   Butterworth-Heinemann, 1985.\n.. [2] Gmehling, Jurgen. Chemical Thermodynamics: For Process\n   Simulation. Weinheim, Germany: Wiley-VCH, 2012.\n\n'''\n\n\n__all__ = ['GibbsExcess', 'IdealSolution']\nfrom chemicals.utils import d2xs_to_dxdn_partials, dns_to_dn_partials, dxs_to_dn_partials, dxs_to_dns, hash_any_primitive, normalize, object_data\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, exp, hessian, jacobian, log, trunc_exp\nfrom fluids.numerics import numpy as np\n\nfrom thermo.fitting import fit_customized\nfrom thermo.serialize import JsonOptEncodable\n\ntry:\n    npexp, ones, zeros, array, ndarray = np.exp, np.ones, np.zeros, np.array, np.ndarray\nexcept:\n    pass\n\ndef gibbs_excess_gammas(xs, dG_dxs, GE, T, gammas=None):\n    xdx_totF = GE\n    N = len(xs)\n    for i in range(N):\n        xdx_totF -= xs[i]*dG_dxs[i]\n    RT_inv = R_inv/T\n    if gammas is None:\n        gammas = [0.0]*N\n    for i in range(N):\n        gammas[i] = exp((dG_dxs[i] + xdx_totF)*RT_inv)\n    return gammas\n\ndef gibbs_excess_dHE_dxs(dGE_dxs, d2GE_dTdxs, N, T, dHE_dxs=None):\n    if dHE_dxs is None:\n        dHE_dxs = [0.0]*N\n    for i in range(N):\n        dHE_dxs[i] = -T*d2GE_dTdxs[i] + dGE_dxs[i]\n    return dHE_dxs\n\n\ndef gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, T, dgammas_dns=None, vec0=None):\n    if vec0 is None:\n        vec0 = [0.0]*N\n    if dgammas_dns is None:\n        dgammas_dns = [[0.0]*N for _ in range(N)] # numba : delete\n#        dgammas_dns = zeros((N, N)) # numba : uncomment\n\n    for j in range(N):\n        tot = 0.0\n        row = d2GE_dxixjs[j]\n        for k in range(N):\n            tot += xs[k]*row[k]\n        vec0[j] = tot\n\n    RT_inv = R_inv/(T)\n\n    for i in range(N):\n        gammai_RT = gammas[i]*RT_inv\n        for j in range(N):\n            dgammas_dns[i][j] = gammai_RT*(d2GE_dxixjs[i][j] - vec0[j])\n\n    return dgammas_dns\n\ndef gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T, dgammas_dT=None):\n    if dgammas_dT is None:\n        dgammas_dT = [0.0]*N\n\n    xdx_totF0 = dGE_dT\n    for j in range(N):\n        xdx_totF0 -= xs[j]*d2GE_dTdxs[j]\n    xdx_totF1 = GE\n    for j in range(N):\n        xdx_totF1 -= xs[j]*dG_dxs[j]\n\n    T_inv = 1.0/T\n    RT_inv = R_inv*T_inv\n    for i in range(N):\n        dG_dni = xdx_totF1 + dG_dxs[i]\n        dgammas_dT[i] = RT_inv*(d2GE_dTdxs[i] - dG_dni*T_inv + xdx_totF0)*exp(dG_dni*RT_inv)\n    return dgammas_dT\n\ndef interaction_exp(T, N, A, B, C, D, E, F, lambdas=None):\n    if lambdas is None:\n        lambdas = [[0.0]*N for i in range(N)] # numba: delete\n#        lambdas = zeros((N, N)) # numba: uncomment\n\n#        # 87% of the time of this routine is the exponential.\n    T2 = T*T\n    Tinv = 1.0/T\n    T2inv = Tinv*Tinv\n    logT = log(T)\n    for i in range(N):\n        Ai = A[i]\n        Bi = B[i]\n        Ci = C[i]\n        Di = D[i]\n        Ei = E[i]\n        Fi = F[i]\n        lambdais = lambdas[i]\n        # Might be more efficient to pass over this matrix later,\n        # and compute all the exps\n        # Spoiler: it was not.\n\n        # Also - it was tested the impact of using fewer terms\n        # there was very little, to no impact from that\n        # the exp is the huge time sink.\n        for j in range(N):\n            lambdais[j] = exp(Ai[j] + Bi[j]*Tinv\n                    + Ci[j]*logT + Di[j]*T\n                    + Ei[j]*T2inv + Fi[j]*T2)\n#            lambdas[i][j] = exp(A[i][j] + B[i][j]*Tinv\n#                    + C[i][j]*logT + D[i][j]*T\n#                    + E[i][j]*T2inv + F[i][j]*T2)\n#    135 \u00b5s \u00b1 1.09 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each) # without out specified numba\n#    129 \u00b5s \u00b1 2.45 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each) # with out specified numba\n#    118 \u00b5s \u00b1 2.67 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each) # without out specified numba 1 term\n#    115 \u00b5s \u00b1 1.77 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each) # with out specified numba 1 term\n\n    return lambdas\n\n\ndef dinteraction_exp_dT(T, N, B, C, D, E, F, lambdas, dlambdas_dT=None):\n    if dlambdas_dT is None:\n        dlambdas_dT = [[0.0]*N for i in range(N)] # numba: delete\n#        dlambdas_dT = zeros((N, N)) # numba: uncomment\n\n    T2 = T + T\n    Tinv = 1.0/T\n    nT2inv = -Tinv*Tinv\n    nT3inv2 = 2.0*nT2inv*Tinv\n    for i in range(N):\n        lambdasi = lambdas[i]\n        Bi = B[i]\n        Ci = C[i]\n        Di = D[i]\n        Ei = E[i]\n        Fi = F[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        for j in range(N):\n            dlambdas_dTi[j] = (T2*Fi[j] + Di[j] + Ci[j]*Tinv + Bi[j]*nT2inv\n                             + Ei[j]*nT3inv2)*lambdasi[j]\n    return dlambdas_dT\n\ndef d2interaction_exp_dT2(T, N, B, C, E, F, lambdas, dlambdas_dT, d2lambdas_dT2=None):\n    if d2lambdas_dT2 is None:\n        d2lambdas_dT2 = [[0.0]*N for i in range(N)] # numba: delete\n#        d2lambdas_dT2 = zeros((N, N)) # numba: uncomment\n\n    Tinv = 1.0/T\n    nT2inv = -Tinv*Tinv\n    T3inv2 = -2.0*nT2inv*Tinv\n    T4inv6 = 3.0*T3inv2*Tinv\n    for i in range(N):\n        lambdasi = lambdas[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        Bi = B[i]\n        Ci = C[i]\n        Ei = E[i]\n        Fi = F[i]\n        d2lambdas_dT2i = d2lambdas_dT2[i]\n        for j in range(N):\n            d2lambdas_dT2i[j] = ((2.0*Fi[j] + nT2inv*Ci[j]\n                             + T3inv2*Bi[j] + T4inv6*Ei[j]\n                               )*lambdasi[j] + dlambdas_dTi[j]*dlambdas_dTi[j]/lambdasi[j])\n    return d2lambdas_dT2\n\ndef d3interaction_exp_dT3(T, N, B, C, E, F, lambdas, dlambdas_dT, d3lambdas_dT3=None):\n    if d3lambdas_dT3 is None:\n        d3lambdas_dT3 = [[0.0]*N for i in range(N)] # numba: delete\n#        d3lambdas_dT3 = zeros((N, N)) # numba: uncomment\n\n    Tinv = 1.0/T\n    Tinv3 = 3.0*Tinv\n    nT2inv = -Tinv*Tinv\n    nT2inv05 = 0.5*nT2inv\n    T3inv = -nT2inv*Tinv\n    T3inv2 = T3inv+T3inv\n    T4inv3 = 1.5*T3inv2*Tinv\n    T2_12 = -12.0*nT2inv\n\n    for i in range(N):\n        lambdasi = lambdas[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        Bi = B[i]\n        Ci = C[i]\n        Ei = E[i]\n        Fi = F[i]\n        d3lambdas_dT3i = d3lambdas_dT3[i]\n        for j in range(N):\n            term2 = (Fi[j] + nT2inv05*Ci[j] + T3inv*Bi[j] + T4inv3*Ei[j])\n\n            term3 = dlambdas_dTi[j]/lambdasi[j]\n\n            term4 = (T3inv2*(Ci[j] - Tinv3*Bi[j] - T2_12*Ei[j]))\n\n            d3lambdas_dT3i[j] = ((term3*(6.0*term2 + term3*term3) + term4)*lambdasi[j])\n\n    return d3lambdas_dT3\n\nclass GibbsExcess:\n    r'''Class for representing an activity coefficient model.\n    While these are typically presented as tools to compute activity\n    coefficients, in truth they are excess Gibbs energy models and activity\n    coefficients are just one derived aspect of them.\n\n    This class does not implement any activity coefficient models itself; it\n    must be subclassed by another model. All properties are\n    derived with the CAS SymPy, not relying on any derivations previously\n    published, and checked numerically for consistency.\n\n    Different subclasses have different parameter requirements for\n    initialization; :obj:`IdealSolution` is\n    available as a simplest model with activity coefficients of 1 to show\n    what needs to be implemented in subclasses. It is also intended subclasses\n    implement the method `to_T_xs`, which creates a new object at the\n    specified temperature and composition but with the same parameters.\n\n    These objects are intended to lazy-calculate properties as much as\n    possible, and for the temperature and composition of an object to be\n    immutable.\n\n    '''\n    T_DEFAULT = 298.15\n    _x_infinite_dilution = 0.0\n    \"\"\"When set, this will be the limiting mole fraction used to approximate\n    the :obj:`gammas_infinite_dilution` calculation. This is important\n    as not all models can mathematically be evaluated at zero mole-fraction.\"\"\"\n\n\n    __slots__ = ('T', 'N', 'xs', 'vectorized', '_GE', '_dGE_dT', '_SE','_d2GE_dT2', '_d2GE_dTdxs', '_dGE_dxs',\n                  '_gammas', '_dgammas_dns', '_dgammas_dT', '_d2GE_dxixjs',  '_dHE_dxs', '_dSE_dxs',\n                  '_model_hash')\n\n    recalculable_attributes = ('_GE', '_dGE_dT', '_SE','_d2GE_dT2', '_d2GE_dTdxs', '_dGE_dxs',\n                  '_gammas', '_dgammas_dns', '_dgammas_dT', '_d2GE_dxixjs',  '_dHE_dxs', '_dSE_dxs')\n\n    _point_properties = ('CpE', 'GE', 'HE', 'SE', 'd2GE_dT2', 'd2GE_dTdns',\n                         'd2GE_dTdxs', 'd2GE_dxixjs', 'd2nGE_dTdns', 'd2nGE_dninjs',\n                         'dGE_dT', 'dGE_dns', 'dGE_dxs', 'dHE_dT', 'dHE_dns', 'dHE_dxs',\n                         'dSE_dT', 'dSE_dns', 'dSE_dxs', 'dgammas_dT', 'dgammas_dns',\n                         'dnGE_dns', 'dnHE_dns', 'dnSE_dns', 'gammas')\n    \"\"\"These are all methods which take no arguments. For use in testing.\"\"\"\n\n    def __init_subclass__(cls):\n        cls.__full_path__ = f\"{cls.__module__}.{cls.__qualname__}\"\n\n    json_version = 1\n    obj_references = []\n    non_json_attributes = ['_model_hash']\n\n    def __repr__(self):\n        r'''Method to create a string representation of the state of the model.\n        Included is `T`, `xs`, and all constants necessary to create the model.\n        This can be passed into :py:func:`exec` to re-create the\n        model. Note that parsing strings like this can be slow.\n\n        Returns\n        -------\n        repr : str\n            String representation of the object, [-]\n\n        Examples\n        --------\n        >>> IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        '''\n        # Other classes with different parameters should expose them here too\n        s = f'{self.__class__.__name__}(T={self.T!r}, xs={self.xs!r})'\n        return s\n\n    def __eq__(self, other):\n        return self.__hash__() == hash(other)\n\n    def model_hash(self):\n        r'''Basic method to calculate a hash of the non-state parts of the model\n        This is useful for comparing to models to\n        determine if they are the same, i.e. in a VLL flash it is important to\n        know if both liquids have the same model.\n\n        Note that the hashes should only be compared on the same system running\n        in the same process!\n\n        Returns\n        -------\n        model_hash : int\n            Hash of the object's model parameters, [-]\n        '''\n        try:\n            return self._model_hash\n        except AttributeError:\n            pass\n        to_hash = [self.__class__.__name__, self.N]\n        for k in self._model_attributes:\n            v = getattr(self, k)\n            if type(v) is ndarray:\n                v = v.tolist()\n            to_hash.append(v)\n        self._model_hash = hash_any_primitive(to_hash)\n        return self._model_hash\n\n    def state_hash(self):\n        r'''Basic method to calculate a hash of the state of the model and its\n        model parameters.\n\n        Note that the hashes should only be compared on the same system running\n        in the same process!\n\n        Returns\n        -------\n        state_hash : int\n            Hash of the object's model parameters and state, [-]\n        '''\n        xs = self.xs if not self.vectorized else self.xs.tolist()\n        return hash_any_primitive((self.model_hash(), float(self.T), xs))\n\n    __hash__ = state_hash\n\n    def exact_hash(self):\n        r'''Method to calculate and return a hash representing the exact state\n        of the object. This includes `T`, `xs`,\n        the model class, and which values have already been calculated.\n\n        Returns\n        -------\n        hash : int\n            Hash of the object, [-]\n        '''\n        d = object_data(self)\n        ans = hash_any_primitive((self.__class__.__name__, d))\n        return ans\n\n    def as_json(self, cache=None, option=0):\n        r'''Method to create a JSON-friendly representation of the Gibbs Excess\n        model which can be stored, and reloaded later.\n\n        Returns\n        -------\n        json_repr : dict\n            JSON-friendly representation, [-]\n\n        Notes\n        -----\n\n        Examples\n        --------\n        >>> import json\n        >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        >>> json_view = model.as_json()\n        >>> json_str = json.dumps(json_view)\n        >>> assert type(json_str) is str\n        >>> model_copy = IdealSolution.from_json(json.loads(json_str))\n        >>> assert model_copy == model\n        '''\n        return JsonOptEncodable.as_json(self, cache, option)\n\n    @classmethod\n    def from_json(cls, json_repr, cache=None):\n        r'''Method to create a Gibbs Excess model from a JSON-friendly\n        serialization of another Gibbs Excess model.\n\n        Parameters\n        ----------\n        json_repr : dict\n            JSON-friendly representation, [-]\n\n        Returns\n        -------\n        model : :obj:`GibbsExcess`\n            Newly created object from the json serialization, [-]\n\n        Notes\n        -----\n        It is important that the input string be in the same format as that\n        created by :obj:`GibbsExcess.as_json`.\n\n        Examples\n        --------\n        >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        >>> json_view = model.as_json()\n        >>> new_model = IdealSolution.from_json(json_view)\n        >>> assert model == new_model\n        '''\n        return JsonOptEncodable.from_json(json_repr, cache)\n\n    def _custom_from_json(self, *args):\n        vectorized = self.vectorized\n        if vectorized and hasattr(self, 'cmp_group_idx'):\n            self.cmp_group_idx = tuple(array(v) for v in self.cmp_group_idx)\n        if vectorized and hasattr(self, 'group_cmp_idx'):\n            self.group_cmp_idx = tuple(array(v) for v in self.group_cmp_idx)\n\n    def HE(self):\n        r'''Calculate and return the excess entropy of a liquid phase using an\n        activity coefficient model.\n\n        .. math::\n            h^E = -T \\frac{\\partial g^E}{\\partial T} + g^E\n\n        Returns\n        -------\n        HE : float\n            Excess enthalpy of the liquid phase, [J/mol]\n\n        Notes\n        -----\n        '''\n        \"\"\"f = symbols('f', cls=Function)\n        T = symbols('T')\n        simplify(-T**2*diff(f(T)/T, T))\n        \"\"\"\n        return -self.T*self.dGE_dT() + self.GE()\n\n    def dHE_dT(self):\n        r'''Calculate and return the first temperature derivative of excess\n        enthalpy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial h^E}{\\partial T} = -T \\frac{\\partial^2 g^E}\n            {\\partial T^2}\n\n        Returns\n        -------\n        dHE_dT : float\n            First temperature derivative of excess enthalpy of the liquid\n            phase, [J/mol/K]\n\n        Notes\n        -----\n        '''\n        return -self.T*self.d2GE_dT2()\n\n    CpE = dHE_dT\n\n    def dHE_dxs(self):\n        r'''Calculate and return the mole fraction derivative of excess\n        enthalpy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial h^E}{\\partial x_i} = -T \\frac{\\partial^2 g^E}\n            {\\partial T \\partial x_i} + \\frac{\\partial g^E}{\\partial x_i}\n\n        Returns\n        -------\n        dHE_dxs : list[float]\n            First mole fraction derivative of excess enthalpy of the liquid\n            phase, [J/mol]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._dHE_dxs\n        except:\n            pass\n        # Derived by hand taking into account the expression for excess enthalpy\n        d2GE_dTdxs = self.d2GE_dTdxs()\n        try:\n            dGE_dxs = self._dGE_dxs\n        except:\n            dGE_dxs = self.dGE_dxs()\n        dHE_dxs = gibbs_excess_dHE_dxs(dGE_dxs, d2GE_dTdxs, self.N, self.T)\n        if self.vectorized and type(dHE_dxs) is list:\n            dHE_dxs = array(dHE_dxs)\n        self._dHE_dxs = dHE_dxs\n        return dHE_dxs\n\n    def dHE_dns(self):\n        r'''Calculate and return the mole number derivative of excess\n        enthalpy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial h^E}{\\partial n_i}\n\n        Returns\n        -------\n        dHE_dns : list[float]\n            First mole number derivative of excess enthalpy of the liquid\n            phase, [J/mol^2]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dHE_dns = dxs_to_dns(self.dHE_dxs(), self.xs, out)\n        return dHE_dns\n\n    def dnHE_dns(self):\n        r'''Calculate and return the partial mole number derivative of excess\n        enthalpy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial n h^E}{\\partial n_i}\n\n        Returns\n        -------\n        dnHE_dns : list[float]\n            First partial mole number derivative of excess enthalpy of the\n            liquid phase, [J/mol]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dnHE_dns = dxs_to_dn_partials(self.dHE_dxs(), self.xs, self.HE(), out)\n        return dnHE_dns\n\n    def SE(self):\n        r'''Calculates the excess entropy of a liquid phase using an\n        activity coefficient model.\n\n        .. math::\n            s^E = \\frac{h^E - g^E}{T}\n\n        Returns\n        -------\n        SE : float\n            Excess entropy of the liquid phase, [J/mol/K]\n\n        Notes\n        -----\n        Note also the relationship of the expressions for partial excess\n        entropy:\n\n        .. math::\n            S_i^E = -R\\left(T \\frac{\\partial \\ln \\gamma_i}{\\partial T}\n            + \\ln \\gamma_i\\right)\n\n\n        '''\n        try:\n            return self._SE\n        except:\n            self._SE = (self.HE() - self.GE())/self.T\n        return self._SE\n\n    def dSE_dT(self):\n        r'''Calculate and return the first temperature derivative of excess\n        entropy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial s^E}{\\partial T} = \\frac{1}{T}\n            \\left(\\frac{-\\partial g^E}{\\partial T} + \\frac{\\partial h^E}{\\partial T}\n            - \\frac{(G + H)}{T}\\right)\n\n        Returns\n        -------\n        dSE_dT : float\n            First temperature derivative of excess entropy of the liquid\n            phase, [J/mol/K]\n\n        Notes\n        -----\n\n        '''\n        \"\"\"from sympy import *\n        T = symbols('T')\n        G, H = symbols('G, H', cls=Function)\n        S = (H(T) - G(T))/T\n        print(diff(S, T))\n        # (-Derivative(G(T), T) + Derivative(H(T), T))/T - (-G(T) + H(T))/T**2\n        \"\"\"\n        # excess entropy temperature derivative\n        dHE_dT = self.dHE_dT()\n        try:\n            HE = self._HE\n        except:\n            HE = self.HE()\n        try:\n            dGE_dT = self._dGE_dT\n        except:\n            dGE_dT = self.dGE_dT()\n        try:\n            GE = self._GE\n        except:\n            GE = self.GE()\n        T_inv = 1.0/self.T\n        return T_inv*(-dGE_dT + dHE_dT - (HE - GE)*T_inv)\n\n    def dSE_dxs(self):\n        r'''Calculate and return the mole fraction derivative of excess\n        entropy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial S^E}{\\partial x_i} = \\frac{1}{T}\\left( \\frac{\\partial h^E}\n            {\\partial x_i} - \\frac{\\partial g^E}{\\partial x_i}\\right)\n            = -\\frac{\\partial^2 g^E}{\\partial x_i \\partial T}\n\n        Returns\n        -------\n        dSE_dxs : list[float]\n            First mole fraction derivative of excess entropy of the liquid\n            phase, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._dSE_dxs\n        except:\n            pass\n        try:\n            d2GE_dTdxs = self._d2GE_dTdxs\n        except:\n            d2GE_dTdxs = self.d2GE_dTdxs()\n        if not self.vectorized:\n            dSE_dxs = [-v for v in d2GE_dTdxs]\n        else:\n            dSE_dxs = -d2GE_dTdxs\n        self._dSE_dxs = dSE_dxs\n        return dSE_dxs\n\n    def dSE_dns(self):\n        r'''Calculate and return the mole number derivative of excess\n        entropy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial S^E}{\\partial n_i}\n\n        Returns\n        -------\n        dSE_dns : list[float]\n            First mole number derivative of excess entropy of the liquid\n            phase, [J/(mol^2*K)]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dSE_dns = dxs_to_dns(self.dSE_dxs(), self.xs, out)\n        return dSE_dns\n\n    def dnSE_dns(self):\n        r'''Calculate and return the partial mole number derivative of excess\n        entropy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial n S^E}{\\partial n_i}\n\n        Returns\n        -------\n        dnSE_dns : list[float]\n            First partial mole number derivative of excess entropy of the liquid\n            phase, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dnSE_dns = dxs_to_dn_partials(self.dSE_dxs(), self.xs, self.SE(), out)\n        return dnSE_dns\n\n    def dGE_dns(self):\n        r'''Calculate and return the mole number derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial G^E}{\\partial n_i}\n\n        Returns\n        -------\n        dGE_dns : list[float]\n            First mole number derivative of excess Gibbs entropy of the liquid\n            phase, [J/(mol^2*K)]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dGE_dns = dxs_to_dns(self.dGE_dxs(), self.xs, out)\n        return dGE_dns\n\n    def dnGE_dns(self):\n        r'''Calculate and return the partial mole number derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial n G^E}{\\partial n_i}\n\n        Returns\n        -------\n        dnGE_dns : list[float]\n            First partial mole number derivative of excess Gibbs entropy of the\n            liquid phase, [J/(mol)]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        dnGE_dns = dxs_to_dn_partials(self.dGE_dxs(), self.xs, self.GE(), out)\n        return dnGE_dns\n\n    def d2GE_dTdns(self):\n        r'''Calculate and return the mole number derivative of the first\n        temperature derivative of excess Gibbs energy of a liquid phase using\n        an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial^2 G^E}{\\partial n_i \\partial T}\n\n        Returns\n        -------\n        d2GE_dTdns : list[float]\n            First mole number derivative of the temperature derivative of\n            excess Gibbs entropy of the liquid phase, [J/(mol^2*K)]\n\n        Notes\n        -----\n        '''\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        d2GE_dTdns = dxs_to_dns(self.d2GE_dTdxs(), self.xs, out)\n        return d2GE_dTdns\n\n\n    def d2nGE_dTdns(self):\n        r'''Calculate and return the partial mole number derivative of the first\n        temperature derivative of excess Gibbs energy of a liquid phase using\n        an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial^2 n G^E}{\\partial n_i \\partial T}\n\n        Returns\n        -------\n        d2nGE_dTdns : list[float]\n            First partial mole number derivative of the temperature derivative\n            of excess Gibbs entropy of the liquid phase, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        # needed in gammas temperature derivatives\n        dGE_dT = self.dGE_dT()\n        d2GE_dTdns = self.d2GE_dTdns()\n        out = [0.0]*self.N if not self.vectorized else zeros(self.N)\n        d2nGE_dTdns = dns_to_dn_partials(d2GE_dTdns, dGE_dT, out)\n        return d2nGE_dTdns\n\n\n    def d2nGE_dninjs(self):\n        r'''Calculate and return the second partial mole number derivative of\n        excess Gibbs energy of a liquid phase using\n        an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial^2 n G^E}{\\partial n_i \\partial n_i}\n\n        Returns\n        -------\n        d2nGE_dninjs : list[list[float]]\n            Second partial mole number derivative of excess Gibbs energy of a\n            liquid phase, [J/(mol^2)]\n\n        Notes\n        -----\n        '''\n        # This one worked out\n        d2nGE_dninjs = d2xs_to_dxdn_partials(self.d2GE_dxixjs(), self.xs)\n        if self.vectorized and type(d2nGE_dninjs) is list:\n            d2nGE_dninjs = array(d2nGE_dninjs)\n        return d2nGE_dninjs\n\n    def gammas_infinite_dilution(self):\n        r'''Calculate and return the infinite dilution activity coefficients\n        of each component.\n\n        Returns\n        -------\n        gammas_infinite : list[float]\n            Infinite dilution activity coefficients, [-]\n\n        Notes\n        -----\n        The algorithm is as follows. For each component, set its composition to\n        zero. Normalize the remaining compositions to 1. Create a new object\n        with that composition, and calculate the activity coefficient of the\n        component whose concentration was set to zero.\n        '''\n        T, N = self.T, self.N\n        xs_base = self.xs\n        x_infinite_dilution = self._x_infinite_dilution\n        if not self.vectorized:\n            gammas_inf = [0.0]*N\n            copy_fun = list\n        else:\n            gammas_inf = zeros(N)\n            copy_fun = array\n        for i in range(N):\n            xs = copy_fun(xs_base)\n            xs[i] = x_infinite_dilution\n            xs = normalize(xs)\n            gammas_inf[i] = self.to_T_xs(T, xs=xs).gammas()[i]\n        return gammas_inf\n\n    def gammas(self):\n        r'''Calculate and return the activity coefficients of a liquid phase\n        using an activity coefficient model.\n\n        .. math::\n            \\gamma_i = \\exp\\left(\\frac{\\frac{\\partial n_i G^E}{\\partial n_i }}{RT}\\right)\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._gammas\n        except:\n            pass\n        # Matches the gamma formulation perfectly\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        if not self.vectorized:\n            dG_dns = dxs_to_dn_partials(dG_dxs, self.xs, GE)\n            RT_inv = 1.0/(R*self.T)\n            gammas = [trunc_exp(i*RT_inv) for i in dG_dns]\n        else:\n            gammas = gibbs_excess_gammas(self.xs, dG_dxs, GE, self.T)\n            if type(gammas) is list:\n                gammas = array(gammas)\n        self._gammas = gammas\n        return gammas\n\n    def gammas_dGE_dxs(self):\n        try:\n            del self._gammas\n        except:\n            pass\n        return GibbsExcess.gammas(self)\n    \n    def gammas_numerical(self):\n        # for testing purposes\n        def nGE_func(ns):\n            total_n = sum(ns)\n            xs = [n / total_n for n in ns]\n            return total_n * self.to_T_xs(T=self.T, xs=xs).GE()\n        dnGE_dns = jacobian(nGE_func, self.xs, perturbation=1e-7)\n        \n        RT_inv = 1.0/(self.T *R)\n        gammas = np.exp(np.array(dnGE_dns)*RT_inv) if self.vectorized else [exp(v*RT_inv) for v in dnGE_dns]\n        return gammas\n\n    def lngammas(self):\n        r'''Calculate and return the natural logarithm of the activity coefficients\n        of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\ln \\gamma_i = \\frac{\\frac{\\partial n_i G^E}{\\partial n_i }}{RT}\n\n        Returns\n        -------\n        log_gammas : list[float]\n            Natural logarithm of activity coefficients, [-]\n\n        Notes\n        -----\n        '''\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        dG_dns = dxs_to_dn_partials(dG_dxs, self.xs, GE)\n        RT_inv = 1.0/(R * self.T)\n        if not self.vectorized:\n            return [dG_dn * RT_inv for dG_dn in dG_dns]\n        else:\n            return array(dG_dns) * RT_inv\n\n    def dlngammas_dT(self):\n        r'''Calculate and return the temperature derivatives of the natural logarithm\n        of activity coefficients of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial \\ln \\gamma_i}{\\partial T} = \\frac{1}{\\gamma_i} \\frac{\\partial \\gamma_i}{\\partial T}\n\n        Returns\n        -------\n        dlog_gammas_dT : list[float]\n            Temperature derivatives of the natural logarithm of activity coefficients, [1/K]\n\n        Notes\n        -----\n        This method uses the chain rule to calculate the temperature derivative\n        of log activity coefficients.\n        '''\n        gammas = self.gammas()\n        dgammas_dT = self.dgammas_dT()\n        \n        if not self.vectorized:\n            return [dgamma_dT / gamma for gamma, dgamma_dT in zip(gammas, dgammas_dT)]\n        else:\n            return dgammas_dT / gammas\n    \n    def dgammas_dns(self):\n        r'''Calculate and return the mole number derivative of activity\n        coefficients of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial \\gamma_i}{\\partial n_i} = \\gamma_i\n            \\left(\\frac{\\frac{\\partial^2 G^E}{\\partial x_i \\partial x_j}}{RT}\\right)\n\n        Returns\n        -------\n        dgammas_dns : list[list[float]]\n            Mole number derivatives of activity coefficients, [1/mol]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._dgammas_dns\n        except AttributeError:\n            pass\n        gammas = self.gammas()\n        N = self.N\n        xs = self.xs\n        d2GE_dxixjs = self.d2GE_dxixjs()\n\n        dgammas_dns = [[0.0]*N for _ in range(N)] if not self.vectorized else zeros((N, N))\n\n        dgammas_dns = gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, self.T, dgammas_dns)\n\n        if self.vectorized and type(dgammas_dns) is list:\n            dgammas_dns = array(dgammas_dns)\n\n        self._dgammas_dns = dgammas_dns\n        return dgammas_dns\n\n#    def dgammas_dxs(self):\n        # TODO - compare with UNIFAC, which has a dx derivative working\n#        # NOT WORKING\n#        gammas = self.gammas()\n#        cmps = self.cmps\n#        RT_inv = 1.0/(R*self.T)\n#        d2GE_dxixjs = self.d2GE_dxixjs() # Thi smatrix is symmetric\n#\n#        def thing(d2xs, xs):\n#            cmps = range(len(xs))\n#\n#            double_sums = []\n#            for j in cmps:\n#                tot = 0.0\n#                for k in cmps:\n#                    tot += xs[k]*d2xs[j][k]\n#                double_sums.append(tot)\n#\n#            mat = []\n#            for i in cmps:\n#                row = []\n#                for j in cmps:\n#                    row.append(d2xs[i][j] - double_sums[i])\n#                mat.append(row)\n#            return mat\n#\n#            return [[d2xj - tot for (d2xj, tot) in zip(d2xsi, double_sums)]\n#                     for d2xsi in d2xs]\n#\n#        d2nGE_dxjnis = thing(d2GE_dxixjs, self.xs)\n#\n#        matrix = []\n#        for i in cmps:\n#            row = []\n#            gammai = gammas[i]\n#            for j in cmps:\n#                v = gammai*d2nGE_dxjnis[i][j]*RT_inv\n#                row.append(v)\n#            matrix.append(row)\n#        return matrix\n\n\n    def dgammas_dT(self):\n        r'''Calculate and return the temperature derivatives of activity\n        coefficients of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial \\gamma_i}{\\partial T} =\n            \\left(\\frac{\\frac{\\partial^2 n G^E}{\\partial T \\partial n_i}}{RT} -\n            \\frac{{\\frac{\\partial n_i G^E}{\\partial n_i }}}{RT^2}\\right)\n             \\exp\\left(\\frac{\\frac{\\partial n_i G^E}{\\partial n_i }}{RT}\\right)\n\n        Returns\n        -------\n        dgammas_dT : list[float]\n            Temperature derivatives of activity coefficients, [1/K]\n\n        Notes\n        -----\n        '''\n        r\"\"\"\n        from sympy import *\n        R, T = symbols('R, T')\n        f = symbols('f', cls=Function)\n        diff(exp(f(T)/(R*T)), T)\n        \"\"\"\n        try:\n            return self._dgammas_dT\n        except AttributeError:\n            pass\n        N, T, xs = self.N, self.T, self.xs\n        dGE_dT = self.dGE_dT()\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        d2GE_dTdxs = self.d2GE_dTdxs()\n        dgammas_dT = gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T)\n        if self.vectorized and type(dgammas_dT) is list:\n            dgammas_dT = array(dgammas_dT)\n        self._dgammas_dT = dgammas_dT\n        return dgammas_dT\n\n    @classmethod\n    def _regress_binary_parameters(cls, gammas, xs, fitting_func, fit_parameters,\n                                   use_fit_parameters, initial_guesses=None, analytical_jac=None,\n                                   **kwargs):\n\n        fit_kwargs = dict(fit_method='lm',\n                    # fit_method='differential_evolution',\n                   objective='MeanSquareErr', multiple_tries_max_objective='MeanRelErr',\n                   initial_guesses=initial_guesses, analytical_jac=analytical_jac,\n                   solver_kwargs=None, use_numba=False, multiple_tries=False,\n                   do_statistics=True, multiple_tries_max_err=1e-5)\n        fit_kwargs.update(kwargs)\n\n\n        res = fit_customized(xs, data=gammas, fitting_func=fitting_func, fit_parameters=fit_parameters, use_fit_parameters=use_fit_parameters,\n                    **fit_kwargs)\n        return res\n\n\nderivatives_added = [('dGE_dT', 'GE', 1),\n ('d2GE_dT2', 'GE', 2),\n ('d3GE_dT3', 'GE', 3),\n ('d4GE_dT4', 'GE', 4),\n]\nfor create_derivative, derive_attr, order in derivatives_added:\n    def numerical_derivative(self, derive_attr=derive_attr, n=order, ):\n        order = 2*n+1\n        perturbation = 1e-7\n        xs = self.xs\n        def func(T):\n            if T == self.T:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=T)\n            return getattr(obj, derive_attr)()\n        return derivative(func, x0=self.T, dx=self.T*perturbation, lower_limit=0.0, n=n, order=order)\n    setattr(GibbsExcess, create_derivative+'_numerical', numerical_derivative)\n\nfirst_comp_derivatives = [\n    ('dGE_dxs', 'GE'),\n    ('d2GE_dTdxs', 'dGE_dT'),\n    ('d3GE_dT2dxs', 'd2GE_dT2'),\n    ('d4GE_dT3dxs', 'd3GE_dT3'),\n]\nfor create_derivative, derive_attr in first_comp_derivatives:\n    def numerical_derivative(self, derive_attr=derive_attr):\n        perturbation = 1e-7\n        def func(xs):\n            if not self.vectorized and xs == self.xs:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=self.T)\n            return getattr(obj, derive_attr)()\n        return jacobian(func, self.xs, perturbation=perturbation)\n    setattr(GibbsExcess, create_derivative+'_numerical', numerical_derivative)\n\nsecond_comp_derivatives = [\n    ('d2GE_dxixjs', 'GE'),\n    ('d3GE_dTdxixjs', 'dGE_dT'),\n    ('d4GE_dT2dxixjs', 'd2GE_dT2'),\n    ('d5GE_dT3dxixjs', 'd3GE_dT3'),\n]\nfor create_derivative, derive_attr in second_comp_derivatives:\n    def numerical_derivative(self, derive_attr=derive_attr):\n        perturbation = 1e-5\n        def func(xs):\n            if not self.vectorized and xs == self.xs:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=self.T)\n            return getattr(obj, derive_attr)()\n        return hessian(func, self.xs, perturbation=perturbation)\n    setattr(GibbsExcess, create_derivative+'_numerical', numerical_derivative)\n\nclass IdealSolution(GibbsExcess):\n    r'''Class for  representing an ideal liquid, with no excess gibbs energy\n    and thus activity coefficients of 1.\n\n    Parameters\n    ----------\n    T : float\n        Temperature, [K]\n    xs : list[float]\n        Mole fractions, [-]\n\n    Attributes\n    ----------\n    T : float\n        Temperature, [K]\n    xs : list[float]\n        Mole fractions, [-]\n\n    Examples\n    --------\n    >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n    >>> model.GE()\n    0.0\n    >>> model.gammas()\n    [1.0, 1.0, 1.0, 1.0]\n    >>> model.dgammas_dT()\n    [0.0, 0.0, 0.0, 0.0]\n    '''\n\n    _model_attributes = ()\n\n    model_id = 0\n    __slots__ = GibbsExcess.__slots__\n\n    def gammas_args(self, T=None):\n        N = self.N\n        return (N,)\n\n    def __init__(self, *, xs, T=GibbsExcess.T_DEFAULT):\n        self.T = T\n        self.xs = xs\n        self.N = len(xs)\n        self.vectorized = type(xs) is not list\n\n    def to_T_xs(self, T, xs):\n        r'''Method to construct a new :obj:`IdealSolution` instance at\n        temperature `T`, and mole fractions `xs`\n        with the same parameters as the existing object.\n\n        Parameters\n        ----------\n        T : float\n            Temperature, [K]\n        xs : list[float]\n            Mole fractions of each component, [-]\n\n        Returns\n        -------\n        obj : IdealSolution\n            New :obj:`IdealSolution` object at the specified conditions [-]\n\n        Notes\n        -----\n\n        Examples\n        --------\n        >>> p = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        >>> p.to_T_xs(T=500.0, xs=[.25, .25, .25, .25])\n        IdealSolution(T=500.0, xs=[0.25, 0.25, 0.25, 0.25])\n        '''\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.xs = xs\n        new.vectorized = self.vectorized\n        new.N = len(xs)\n        return new\n\n    def GE(self):\n        r'''Calculate and return the excess Gibbs energy of a liquid phase\n        using an activity coefficient model.\n\n        .. math::\n            g^E = 0\n\n        Returns\n        -------\n        GE : float\n            Excess Gibbs energy of an ideal liquid, [J/mol]\n\n        Notes\n        -----\n        '''\n        return 0.0\n\n    def dGE_dT(self):\n        r'''Calculate and return the temperature derivative of excess Gibbs\n        energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial g^E}{\\partial T} = 0\n\n        Returns\n        -------\n        dGE_dT : float\n            First temperature derivative of excess Gibbs energy of an\n            ideal liquid, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        return 0.0\n\n    def d2GE_dT2(self):\n        r'''Calculate and return the second temperature derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial^2 g^E}{\\partial T^2} = 0\n\n        Returns\n        -------\n        d2GE_dT2 : float\n            Second temperature derivative of excess Gibbs energy of an\n            ideal liquid, [J/(mol*K^2)]\n\n        Notes\n        -----\n        '''\n        return 0.0\n\n    def d3GE_dT3(self):\n        r'''Calculate and return the third temperature derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\frac{\\partial^3 g^E}{\\partial T^3} = 0\n\n        Returns\n        -------\n        d3GE_dT3 : float\n            Third temperature derivative of excess Gibbs energy of an ideal\n            liquid, [J/(mol*K^3)]\n\n        Notes\n        -----\n        '''\n        return 0.0\n\n    def d2GE_dTdxs(self):\n        r'''Calculate and return the temperature derivative of mole fraction\n        derivatives of excess Gibbs energy of an ideal liquid.\n\n        .. math::\n            \\frac{\\partial^2 g^E}{\\partial x_i \\partial T} = 0\n\n        Returns\n        -------\n        d2GE_dTdxs : list[float]\n            Temperature derivative of mole fraction derivatives of excess Gibbs\n            energy of an ideal liquid, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        if not self.vectorized:\n            return [0.0]*self.N\n        return zeros(self.N)\n\n    def dGE_dxs(self):\n        r'''Calculate and return the mole fraction derivatives of excess Gibbs\n        energy of an ideal liquid.\n\n        .. math::\n            \\frac{\\partial g^E}{\\partial x_i} = 0\n\n        Returns\n        -------\n        dGE_dxs : list[float]\n            Mole fraction derivatives of excess Gibbs energy of an ideal\n            liquid, [J/mol]\n\n        Notes\n        -----\n        '''\n        if not self.vectorized:\n            return [0.0]*self.N\n        return zeros(self.N)\n\n    def d2GE_dxixjs(self):\n        r'''Calculate and return the second mole fraction derivatives of excess\n        Gibbs energy of an ideal liquid.\n\n        .. math::\n            \\frac{\\partial^2 g^E}{\\partial x_i \\partial x_j} = 0\n\n        Returns\n        -------\n        d2GE_dxixjs : list[list[float]]\n            Second mole fraction derivatives of excess Gibbs energy of an ideal\n            liquid, [J/mol]\n\n        Notes\n        -----\n        '''\n        N = self.N\n        if not self.vectorized:\n            return [[0.0]*N for i in range(self.N)]\n        return zeros((N, N))\n\n    def d3GE_dxixjxks(self):\n        r'''Calculate and return the third mole fraction derivatives of excess\n        Gibbs energy of an ideal liquid.\n\n        .. math::\n            \\frac{\\partial^3 g^E}{\\partial x_i \\partial x_j \\partial x_k} = 0\n\n        Returns\n        -------\n        d3GE_dxixjxks : list[list[list[float]]]\n            Third mole fraction derivatives of excess Gibbs energy of an ideal\n            liquid, [J/mol]\n\n        Notes\n        -----\n        '''\n        N = self.N\n        if not self.vectorized:\n            return [[[0.0]*N for i in range(N)] for j in range(N)]\n        return zeros((N, N, N))\n\n    def gammas(self):\n        if not self.vectorized:\n            return [1.0]*self.N\n        else:\n            return ones(self.N)\n\n    try:\n        gammas.__doc__ = GibbsExcess.__doc__\n    except:\n        pass\n",
    "thermo/phases/iapws_phase.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'''\n\n__all__ = ['IAPWS95', 'IAPWS95Gas', 'IAPWS95Liquid', 'IAPWS97', 'IAPWS06']\n\nfrom cmath import log as logc\nfrom math import exp\n\nfrom chemicals import iapws\nfrom chemicals.interface import sigma_IAPWS\nfrom chemicals.thermal_conductivity import k_IAPWS\nfrom chemicals.utils import Vm_to_rho, rho_to_Vm\nfrom chemicals.viscosity import mu_IAPWS\nfrom fluids.numerics import secant\n\nfrom thermo.phases.gibbs_eos import GibbsEOS\nfrom thermo.phases.helmholtz_eos import HelmholtzEOS\nfrom thermo.phases.phase import Phase\n\n# from thermo.chemical_package import iapws_correlations\n\nclass IAPWS95(HelmholtzEOS):\n    model_name = 'iapws95'\n    _MW = iapws.iapws95_MW\n    Tc = iapws.iapws95_Tc\n    Pc = iapws.iapws95_Pc\n    rhoc_mass = iapws.iapws95_rhoc\n    rhoc_mass_inv = 1.0/rhoc_mass\n\n    Hfs = [-241822.0]\n    Sfs = [-44.5]\n    Gfs = [-228554.325]\n\n    N = 1\n    rhoc_inv = rho_to_Vm(rhoc_mass, _MW)\n    rhoc = 1.0/rhoc_inv\n\n    rho_red = rhoc\n    rho_red_inv = rhoc_inv\n\n    T_red = Tc\n    T_fixed_transport = 1.5*T_red\n\n    _MW_kg = _MW*1e-3\n    R = _MW_kg*iapws.iapws95_R # This is just the gas constant 8.314... but matching iapws to their decimals\n    R_inv = 1.0/R\n    R2 = R*R\n\n    #R = property_mass_to_molar(iapws95_R, iapws95_MW)\n    zs = [1.0]\n    cmps = [0]\n    # HeatCapacityGases = iapws_correlations.HeatCapacityGases\n\n    T_MAX_FLASH = T_MAX_FIXED = 5000.0\n    T_MIN_FLASH = T_MIN_FIXED = 243.0 # PU has flash failures at < 242 ish K\n\n    _d4Ar_ddelta2dtau2_func = staticmethod(iapws.iapws95_d4Ar_ddelta2dtau2)\n    _d3Ar_ddeltadtau2_func = staticmethod(iapws.iapws95_d3Ar_ddeltadtau2)\n    _d3Ar_ddelta2dtau_func = staticmethod(iapws.iapws95_d3Ar_ddelta2dtau)\n    _d2Ar_ddeltadtau_func = staticmethod(iapws.iapws95_d2Ar_ddeltadtau)\n    _d2Ar_dtau2_func = staticmethod(iapws.iapws95_d2Ar_dtau2)\n    _dAr_dtau_func = staticmethod(iapws.iapws95_dAr_dtau)\n    _d3Ar_ddelta3_func = staticmethod(iapws.iapws95_d3Ar_ddelta3)\n    _d2Ar_ddelta2_func = staticmethod(iapws.iapws95_d2Ar_ddelta2)\n    _dAr_ddelta_func = staticmethod(iapws.iapws95_dAr_ddelta)\n    _Ar_func = staticmethod(iapws.iapws95_Ar)\n\n\n    def __init__(self, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        self.tau = tau = self.Tc/T\n        self.delta = delta = rho_mass*self.rhoc_mass_inv\n        self.A0, self.dA0_dtau, self.d2A0_dtau2, self.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n    def to_TP_zs(self, T, P, zs):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.T = T\n        new.P = P\n        new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        new.tau = tau = new.Tc/T\n        new.delta = delta = rho_mass*new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None and P is not None:\n            new.T = T\n            new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n            new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n            new.P = P\n        elif T is not None and V is not None:\n            new.T = T\n            new._rho_mass = rho_mass = 1e-3*self._MW/V\n            P = iapws.iapws95_P(T, rho_mass)\n            new._V = V\n            new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws95_T(P, rho_mass)\n            new._V = V\n            new.P = P\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.P = P\n        new.T = T\n        new.tau = tau = new.Tc/T\n        new.delta = delta = rho_mass*new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n        return new\n\n\n    def mu(self):\n        r'''Calculate and return the viscosity of water according to the IAPWS.\n        For details, see :obj:`chemicals.viscosity.mu_IAPWS`.\n\n        Returns\n        -------\n        mu : float\n            Viscosity of water, [Pa*s]\n        '''\n        try:\n            return self._mu\n        except:\n            pass\n        self.__mu_k()\n        return self._mu\n\n    def k(self):\n        r'''Calculate and return the thermal conductivity of water according to the IAPWS.\n        For details, see :obj:`chemicals.thermal_conductivity.k_IAPWS`.\n\n        Returns\n        -------\n        k : float\n            Thermal conductivity of water, [W/m/K]\n        '''\n        try:\n            return self._k\n        except:\n            pass\n        self.__mu_k()\n        return self._k\n\n    def __mu_k(self):\n        drho_mass_dP = self.drho_mass_dP()\n\n        # TODO: curve fit drho_dP_Tr better than IAPWS did (mpmath)\n        drho_dP_Tr = self.to(T=self.T_fixed_transport, V=self._V, zs=self.zs).drho_mass_dP()\n        self._mu = mu_IAPWS(T=self.T, rho=self._rho_mass, drho_dP=drho_mass_dP,\n                        drho_dP_Tr=drho_dP_Tr)\n\n        self._k = k_IAPWS(T=self.T, rho=self._rho_mass, Cp=self.Cp_mass(), Cv=self.Cv_mass(),\n                       mu=self._mu, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n\n\n\nclass IAPWS95Gas(IAPWS95):\n    is_gas = True\n    is_liquid = False\n    force_phase = 'g'\n\nclass IAPWS95Liquid(IAPWS95):\n    force_phase = 'l'\n    is_gas = False\n    is_liquid = True\n\n    def sigma(self):\n        try:\n            return self._sigma\n        except:\n            pass\n\n        self._sigma = sigma_IAPWS(self.T)\n        return self._sigma\n\nclass IAPWS97(Phase):\n    model_name = 'iapws97'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    R = 461.526\n    Tc = 647.096\n    Pc = 22.064E6\n    rhoc = 322.\n    zs = [1.0]\n    cmps = [0]\n    def mu(self):\n        return mu_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def k(self):\n        # TODO add properties; even industrial formulation recommends them\n        return k_IAPWS(T=self.T, rho=self._rho_mass)\n\n    ### Region 1,2,5 Gibbs\n    def G(self):\n        try:\n            return self._G\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            G = iapws.iapws97_G_region1(tau, pi)\n        elif region == 2:\n            G = iapws.iapws97_Gr_region2(tau, pi) + iapws.iapws97_G0_region2(tau, pi)\n        elif region == 5:\n            G = iapws.iapws97_Gr_region5(tau, pi) + iapws.iapws97_G0_region5(tau, pi)\n        elif region == 4:\n            G = self.H() - self.T*self.S()\n        self._G = G\n        return G\n\n\n    def dG_dpi(self):\n        try:\n            return self._dG_dpi\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            dG_dpi = iapws.iapws97_dG_dpi_region1(tau, pi)\n        elif region == 2:\n            dG_dpi = 1.0/pi + iapws.iapws97_dGr_dpi_region2(tau, pi)\n        elif region == 5:\n            dG_dpi = 1.0/pi + iapws.iapws97_dGr_dpi_region5(tau, pi)\n        self._dG_dpi = dG_dpi\n        return dG_dpi\n\n    def d2G_d2pi(self):\n        try:\n            return self._d2G_d2pi\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_d2pi = iapws.iapws97_d2G_dpi2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2pi = -1.0/(pi*pi) + iapws.iapws97_d2Gr_dpi2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2pi = -1.0/(pi*pi) + iapws.iapws97_d2Gr_dpi2_region5(tau, pi)\n        self._d2G_d2pi = d2G_d2pi\n        return d2G_d2pi\n\n    def dG_dtau(self):\n        try:\n            return self._dG_dtau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            dG_dtau = iapws.iapws97_dG_dtau_region1(tau, pi)\n        elif region == 2:\n            dG_dtau = iapws.iapws97_dG0_dtau_region2(tau, pi) + iapws.iapws97_dGr_dtau_region2(tau, pi)\n        elif region == 5:\n            dG_dtau = iapws.iapws97_dG0_dtau_region5(tau, pi) + iapws.iapws97_dGr_dtau_region5(tau, pi)\n        self._dG_dtau = dG_dtau\n        return dG_dtau\n\n    def d2G_d2tau(self):\n        try:\n            return self._d2G_d2tau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_d2tau = iapws.iapws97_d2G_dtau2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2tau = (iapws.iapws97_d2Gr_dtau2_region2(tau, pi)\n                         + iapws.iapws97_d2G0_dtau2_region2(tau, pi))\n        elif region == 5:\n            d2G_d2tau = (iapws.iapws97_d2Gr_dtau2_region5(tau, pi)\n                         + iapws.iapws97_d2G0_dtau2_region5(tau, pi))\n        self._d2G_d2tau = d2G_d2tau\n        return d2G_d2tau\n\n    def d2G_dpidtau(self):\n        try:\n            return self._d2G_dpidtau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_dpidtau = iapws.iapws97_d2G_dpidtau_region1(tau, pi)\n        elif region == 2:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region2(tau, pi)\n        elif region == 5:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region5(tau, pi)\n        self._d2G_dpidtau = d2G_dpidtau\n        return d2G_dpidtau\n\n\n    ### Region 3 Helmholtz\n    def A_region3(self):\n        try:\n            return self._A_region3\n        except:\n            pass\n        self._A_region3 = A_region3 = iapws.iapws97_A_region3_region3(self.tau, self.delta)\n        return A_region3\n\n    def dA_ddelta(self):\n        try:\n            return self._dA_ddelta\n        except:\n            pass\n        self._dA_ddelta = dA_ddelta = iapws.iapws97_dA_ddelta_region3(self.tau, self.delta)\n        return dA_ddelta\n\n    def d2A_d2delta(self):\n        try:\n            return self._d2A_d2delta\n        except:\n            pass\n        self._d2A_d2delta = d2A_d2delta = iapws.iapws97_d2A_d2delta_region3(self.tau, self.delta)\n        return d2A_d2delta\n\n    def dA_dtau(self):\n        try:\n            return self._dA_dtau\n        except:\n            pass\n        self._dA_dtau = dA_dtau = iapws.iapws97_dA_dtau_region3(self.tau, self.delta)\n        return dA_dtau\n\n    def d2A_d2tau(self):\n        try:\n            return self._d2A_d2tau\n        except:\n            pass\n        self._d2A_d2tau = d2A_d2tau = iapws.iapws97_d2A_d2tau_region3(self.tau, self.delta)\n        return d2A_d2tau\n\n    def d2A_ddeltadtau(self):\n        try:\n            return self._d2A_ddeltadtau\n        except:\n            pass\n        self._d2A_ddeltadtau = d2A_ddeltadtau = iapws.iapws97_d2A_ddeltadtau_region3(self.tau, self.delta)\n        return d2A_ddeltadtau\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P*6.049606775559589e-08 #1/16.53E6\n            self.tau = 1386.0/T\n            self.Pref = 16.53E6\n            self.Tref = 1386.0\n        elif region == 2:\n            self.pi = P*1e-6\n            self.tau = 540.0/T\n            self.Pref = 1e6\n            self.Tref = 540.0\n        elif region == 3:\n            self.tau = self.Tc/T\n            self.Tref = self.Tc\n            self.delta = self._rho_mass*0.003105590062111801 # 1/322.0\n            self.rhoref = 322.0\n        elif region == 5:\n            self.pi = P*1e-6\n            self.tau = 1000.0/T\n            self.Tref = 1000.0\n            self.Pref = 1e6\n\n\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P*6.049606775559589e-08 #1/16.53E6\n            self.tau = 1386.0/T\n        elif region == 2:\n            self.pi = P*1e-6\n            self.tau = 540.0/T\n        elif region == 3:\n            self.tau = self.Tc/T\n            self.delta = self._rho_mass*0.003105590062111801 # 1/322.0\n        elif region == 5:\n            self.pi = P*1e-6\n            self.tau = 1000.0/T\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new._rho_mass = rho_mass = iapws.iapws97_rho(T, P)\n                new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n                new.P = P\n            elif V is not None:\n                new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n                P = iapws.iapws97_P(T, rho_mass)\n                new.V = V\n                new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws97_T(P, rho_mass)\n            new.V = V\n            new.P = P\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.region = region = iapws.iapws97_identify_region_TP(new.T, new.P)\n        if region == 1:\n            new.pi = P*6.049606775559589e-08 #1/16.53E6\n            new.tau = 1386.0/T\n            new.Pref = 16.53E6\n            new.Tref = 1386.0\n        elif region == 2:\n            new.pi = P*1e-6\n            new.tau = 540.0/T\n            new.Pref = 1e6\n            new.Tref = 540.0\n        elif region == 3:\n            new.tau = new.Tc/T\n            new.Tref = new.Tc\n            new.delta = new._rho_mass*0.003105590062111801 # 1/322.0\n            new.rhoref = 322.0\n        elif region == 5:\n            new.pi = P*1e-6\n            new.tau = 1000.0/T\n            new.Tref = 1000.0\n            new.Pref = 1e6\n\n        new.P = P\n        new.T = T\n\n        return new\n\n    def V(self):\n        return self._V\n\n    def U(self):\n        try:\n            return self._U\n        except:\n            pass\n\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            U = self.R*self.T(*self.tau*dG_dtau - self.pi*dG_dpi)\n        self._U = U\n        return U\n\n    def S(self):\n        try:\n            return self._S\n        except:\n            pass\n        if self.region != 3:\n            try:\n                G = self._G\n            except:\n                G = self.G()\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            S = self.R*(self.tau*dG_dtau - G)\n        self._S = S\n        return S\n\n    def H(self):\n        try:\n            return self._H\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            H = self.R*self.T*self.tau*dG_dtau\n        self._H = H\n        return H\n\n    def Cv(self):\n        try:\n            return self._Cv\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2tau = self._d2G_d2tau\n            except:\n                d2G_d2tau = self.d2G_d2tau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n\n            tau = self.tau\n            x0 = (dG_dpi - tau*d2G_dpidtau)\n            Cv = self.R*(-tau*tau*d2G_d2tau + x0*x0/d2G_d2pi)\n\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except:\n            pass\n\n        if self.region == 3:\n            tau, delta = self.tau, self.delta # attributes set on init\n            try:\n                dA_ddelta = self._dA_ddelta\n            except:\n                dA_ddelta = self.dA_ddelta()\n            try:\n                d2A_ddeltadtau = self._d2A_ddeltadtau\n            except:\n                d2A_ddeltadtau = self.d2A_ddeltadtau()\n            try:\n                d2A_d2delta = self._d2A_d2delta\n            except:\n                d2A_d2delta = self.d2A_d2delta()\n            try:\n                d2A_d2tau = self._d2A_d2tau\n            except:\n                d2A_d2tau = self.d2A_d2tau()\n\n            x0 = (delta*dA_ddelta - delta*tau*d2A_ddeltadtau)\n            Cp = self.R*(-tau*tau*d2A_d2tau + x0*x0/(delta*(2.0*dA_ddelta + delta*d2A_d2delta)))\n\n#        self.Cp = (-self.tau**2*self.ddA_ddtau + (self.delta*self.dA_ddelta - self.delta*self.tau*self.ddA_ddelta_dtau)**2\\\n#                  /(2*self.delta*self.dA_ddelta + self.delta**2*self.ddA_dddelta))*R\n\n        else:\n            tau = self.tau\n            Cp = -self.R*tau*tau*self.d2G_d2tau()\n        Cp *= self._MW*1e-3\n        self._Cp = Cp\n        return Cp\n\n    dH_dT = dH_dT_P = Cp\n\n    ### Derivatives\n    def dV_dP(self):\n        '''\n        from sympy import *\n        R, T, MW, P, Pref, Tref = symbols('R, T, MW, P, Pref, Tref')\n        dG_dpif = symbols('dG_dpi', cls=Function)\n        pi = P/Pref\n        tau = Tref/T\n        dG_dpi = dG_dpif(tau, pi)\n        V = (R*T*pi*dG_dpi*MW)/(1000*P)\n        print(diff(V, P))\n\n        MW*R*T*Subs(Derivative(dG_dpi(Tref/T, _xi_2), _xi_2), _xi_2, P/Pref)/(1000*Pref**2)\n        '''\n        try:\n            return self._dV_dP\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            dV_dP = self._MW*self.R*self.T*d2G_d2pi/(1000.0*self.Pref*self.Pref)\n\n        self._dV_dP = dV_dP\n        return dV_dP\n\n    def dV_dT(self):\n        # similar to dV_dP\n        try:\n            return self._dV_dT\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n\n\n            dV_dT = (self._MW*self.R*dG_dpi/(1000*self.Pref)\n            - self._MW*self.R*self.Tref*d2G_dpidtau/(1000*self.Pref*self.T))\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except:\n            pass\n        if self.region != 3:\n            dP_dT = -self.dV_dT()/self.dV_dP()\n        self._dP_dT = dP_dT\n        return dP_dT\n\n    def dP_dV(self):\n        return 1.0/self.dV_dP()\n\n\nclass IAPWS06(GibbsEOS):\n    T_MAX_FLASH = T_MAX_FIXED = 273.16 # Above this ice does not form\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n\n    model_name = 'iapws06'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    zs = [1.0]\n    cmps = [0]\n    R06 = iapws.iapws95_R\n    R06_inv = 1.0/R06\n\n    _MW_kg = _MW*1e-3\n    R = _MW_kg*iapws.iapws95_R # This is just the gas constant 8.314... but matching iapws to their decimals\n    R_inv = 1.0/R\n    R2 = R*R\n\n    Tt = 273.16\n    Tt_inv = 1.0/Tt\n    p0 = 101325.\n    pt = 611.657\n    pt_inv = 1.0/pt\n    pi0 = p0/pt\n\n    g0n = [-0.632020233335886E6, 0.655022213658955, -0.189369929326131E-7,\n        0.339746123271053E-14, -0.556464869058991E-21]\n    g0n_rev = g0n[::-1]\n\n    s0 = -0.332733756492168E4 # IAPWS value not \"absolute\"\n    t1 = 0.368017112855051E-1 + 0.510878114959572E-1j\n    r1 = 0.447050716285388E2 + 0.656876847463481E2j\n    t2 = 0.337315741065416 + 0.335449415919309j\n    r2n = [-0.725974574329220E2 - 0.781008427112870E2j,\n        -0.557107698030123E-4 + 0.464578634580806E-4j,\n        0.234801409215913E-10 - 0.285651142904972E-10j]\n    r2n_rev = r2n[::-1]\n    r2np_rev = [(7.677551608692879e-14-9.340239477516712e-14j),\n                (-9.108171704568459e-08+7.595411065038183e-08j)]\n\n    g0p_coeffs = [-3.6390648292032365e-24, 1.666356094695489e-17, -6.192030151739651e-11, 0.0010708979275295713]\n    g0pp_coeffs = [-1.7848556441943294e-26, 5.44866189611331e-20, -1.0123370045204503e-13]\n\n    r2pp = r2n[2]*2.0/(pt*pt) # (1.2552053861384531e-16-1.5270387615144944e-16j)\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._set_core()\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new._set_core()\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new.P = P\n                new._set_core()\n            elif V is not None:\n                def V_err(P):\n                    new.P = P\n                    new._set_core()\n                    return new._V - V\n                P = secant(V_err, 1e5, xtol=1e-12, bisection=True)\n                new.P = P\n                new._set_core()\n        elif P is not None and V is not None:\n            new.P = P\n            def V_err(T):\n                new.T = T\n                new._set_core()\n                return new._V - V\n            T = secant(V_err, 250.0, xtol=1e-12, bisection=True)\n            new.T = T\n            new._set_core()\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.P = P\n        new.T = T\n        return new\n\n\n    def _set_core(self):\n        T, P = self.T, self.P\n        self.tau = T*self.Tt_inv\n        self.pi = P*self.pt_inv\n\n        pi, tau = self.pi, self.tau # for convenience\n        R06_inv = self.R06_inv\n        t1, t2, pi0 = self.t1, self.t2, self.pi0\n        s0, Tt, r1 = self.s0, self.Tt, self.r1\n\n\n\n        tau2 = tau*tau\n        v0 = pi - pi0\n        r2 = (v0*(v0*(2.34801409215913e-11 - 2.85651142904972e-11j)\n                     + (-5.57107698030123e-5 + 4.64578634580806e-5j))\n                     + (-72.597457432922 - 78.100842711287j))\n\n        r2p = (v0*(7.677551608692879e-14-9.340239477516712e-14j)\n               + (-9.108171704568459e-08+7.595411065038183e-08j))\n        g0 = (v0*(v0*(v0*(-5.56464869058991e-22*v0 + 3.39746123271053e-15)\n               - 1.89369929326131e-8) + 0.655022213658955) - 632020.233335886)\n        g0p = (v0*(v0*(-3.6390648292032365e-24*v0 + 1.666356094695489e-17)\n                - 6.192030151739651e-11) + 0.0010708979275295713)\n        g0pp = ((-1.7848556441943294e-26*v0 + 5.44866189611331e-20)*v0\n                - 1.0123370045204503e-13)\n\n\n        log_t1_tau = logc(t1 + tau)\n        log_t1_n_tau = logc(t1 - tau)\n        log_t2_tau = logc(t2 + tau)\n        log_t2_n_tau = logc(t2 - tau)\n\n        log_t1 = logc(t1)\n        log_t2 = logc(t2)\n\n        t2_inv = 1.0/t2\n        t1_inv = 1.0/t1\n\n        tau_t2inv = tau*t2_inv\n        t2_log_t2 = t2*log_t2\n        t2_log_t2_2 = t2_log_t2 + t2_log_t2\n\n        g_real_sum = (r1*((t1-tau)*log_t1_n_tau + (t1+tau)*log_t1_tau - 2.0*t1*log_t1 - tau2*t1_inv)\n                   + (r2*((t2-tau)*log_t2_n_tau + (t2+tau)*log_t2_tau - t2_log_t2_2 - tau2*t2_inv))).real\n        g = g0 - s0*Tt*tau + Tt*g_real_sum\n\n\n        g_T_real_sum = (r1*(-log_t1_n_tau + log_t1_tau - 2.0*tau*t1_inv) + r2*( -log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_T = -s0 + g_T_real_sum\n\n        g_TT_real_sum = (r1*(1./(t1-tau) + 1./(t1+tau) - t1_inv - t1_inv)\n                       + r2*(1./(t2-tau) + 1./(t2+tau) - t2_inv - t2_inv)).real\n        g_TT = 0.0036608581051398447*g_TT_real_sum #1.0/Tt*g_TT_real_sum\n\n        x0 = (t2-tau)*log_t2_n_tau + (t2+tau)*log_t2_tau - t2_log_t2_2 - tau2*t2_inv\n\n        g_P_real_sum = (r2p*(x0)).real\n        g_P = g0p + Tt*g_P_real_sum\n        g_PP_real_sum = (self.r2pp*(x0)).real\n        g_PP = g0pp + Tt*g_PP_real_sum\n\n        g_TP_real_sum = (r2p*(-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_TP = g_TP_real_sum\n\n\n\n        self._rho_mass = rho_mass = 1.0/g_P\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n\n        # self.g0, self.g0p, self.g0pp, self.r2, self.r2p = g0, g0p, g0pp, r2, r2p\n\n        fact = self._MW_kg\n\n        self._G = g*fact\n        self._dG_dT = g_T*fact\n        self._d2G_dT2 = g_TT*fact\n        self._dG_dP = g_P*fact\n        self._d2G_dP2 = g_PP*fact\n        self._d2G_dTdP = g_TP*fact\n\n    def G(self):\n        return self._G\n\n    def dG_dT(self):\n        return self._dG_dT\n\n    def d2G_dT2(self):\n        return self._d2G_dT2\n\n    def dG_dP(self):\n        return self._dG_dP\n\n    def d2G_dP2(self):\n        return self._d2G_dP2\n\n    def d2G_dTdP(self):\n        return self._d2G_dTdP\n\n    d2G_dPdT = d2G_dTdP\n\n    def P_sub(self):\n        return iapws.iapws11_Psub(self.T)\n\n    def vapor_fugacity_coefficient(self):\n        # model does not allow for extrapolation to 1 K so cannot be used\n        # marginal impact to accuracy because of the low pressure\n        # if experimental sublimation pressure does not incorporate this factor,\n        # this factor should be set to 1 anyway!\n        return 1.0\n\n    def fugacities(self):\n        P_sub = self.P_sub()\n        phi = self.vapor_fugacity_coefficient()\n        # Correct with Poynting factor\n        # Gibbs can be used if consistent byt can be very challenging and it requires an offset\n        # Gibbs which is hard to extrapolate\n        # If it is consistent, the equation is phi*P_sub*exp(((self.G()-G_ideal_gas)/self.R/self.T))\n        fugacity = phi*P_sub*exp(self.V()/(self.R*self.T)*(self.P -  P_sub))\n        return [fugacity]\n",
    "thermo/test_utils.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'''\n\nfrom math import log10\n\nimport numpy as np\nfrom fluids.numerics import assert_close, assert_close1d, assert_close2d, assert_close3d\nfrom thermo.activity import GibbsExcess\n\ndef check_np_output_activity(model, modelnp, modelnp2):\n    # model is flat, scalar, list-based model\n    # modelnp is numba model\n    # modelnp2 is created from the numba model with to_T_xs at a different composition\n\n    scalar_attrs = ['d3GE_dT3', 'd2GE_dT2', 'GE', 'dGE_dT']\n    for attr in scalar_attrs:\n        if hasattr(model, attr):\n#            print(attr)\n            assert_close(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n            assert_close(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n            assert type(getattr(model, attr)()) is float\n    #        assert type(getattr(modelnp, attr)()) is float\n    #        assert type(getattr(modelnp2, attr)()) is float\n\n    vec_attrs = ['dGE_dxs', 'gammas', 'gammas_dGE_dxs',\n                 'd2GE_dTdxs', 'dHE_dxs', 'gammas_infinite_dilution', 'dHE_dns',\n                'dnHE_dns', 'dSE_dxs', 'dSE_dns', 'dnSE_dns', 'dGE_dns', 'dnGE_dns', 'd2GE_dTdns',\n                'd2nGE_dTdns', 'dgammas_dT']\n\n    for attr in vec_attrs:\n#        print(attr)\n        assert_close1d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n        assert_close1d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n        assert type(getattr(model, attr)()) is list\n        assert type(getattr(modelnp, attr)()) is np.ndarray\n        assert type(getattr(modelnp2, attr)()) is np.ndarray\n\n    mat_attrs = ['d2GE_dxixjs', 'd2nGE_dninjs', 'dgammas_dns']\n    for attr in mat_attrs:\n        if model.__class__.d2GE_dxixjs is GibbsExcess.d2GE_dxixjs_numerical:\n            # no point in checking numerical derivatives of second order, too imprecise\n            continue\n#        print(attr)\n        assert_close2d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=1e-12)\n        assert_close2d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=1e-12)\n        assert type(getattr(model, attr)()) is list\n        assert type(getattr(modelnp, attr)()) is np.ndarray\n        assert type(getattr(modelnp2, attr)()) is np.ndarray\n\n    attrs_3d = ['d3GE_dxixjxks']\n    for attr in attrs_3d:\n        if hasattr(model, attr):\n#            print(attr)\n            # some models do not have this implemented\n            assert_close3d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=1e-13)\n            assert_close3d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=1e-13)\n            assert type(getattr(model, attr)()) is list\n            assert type(getattr(modelnp, attr)()) is np.ndarray\n            assert type(getattr(modelnp2, attr)()) is np.ndarray\n\n\ndef plot_unsupported(reason, color='r'):\n    '''Helper function - draw a plot with an `x` over it displaying a message\n    why that plot is not supported.\n    '''\n    import matplotlib.pyplot as plt\n    fig, ax = plt.subplots()\n\n    xlims = ax.get_xlim()\n    ylims = ax.get_ylim()\n    ax.plot([0, 1], [0, 1], lw=5, c=color)\n    ax.plot([0, 1], [1, 0], lw=5, c=color)\n\n    ax.text(.5, .5, reason, ha='center', va='center', bbox=dict(fc='white'))\n    return fig\n\n\n\ndef mark_plot_unsupported(plot_fig, reason, color='r'):\n    ax = plot_fig.axes[0]\n    xlims = ax.get_xlim()\n    ylims = ax.get_ylim()\n    xmid = 10**(0.5*(log10(xlims[0]) + log10(xlims[1])))\n    ymid = 10**(0.5*(log10(ylims[0]) + log10(ylims[1])))\n    ax.text(xmid, ymid, reason, ha='center', va='center', bbox=dict(fc='white'))\n    color = 'r'\n    ax.plot(xlims, ylims, lw=5, c=color)\n    ax.plot(xlims, ylims[::-1], lw=5, c=color)\n\n\n\ndef flash_rounding(x):\n    if isinstance(x, float):\n        return float(f'{x:.10e}')\n    return x\n",
    "thermo/phases/gibbs_excess.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n'''\n__all__ = ['GibbsExcessLiquid', 'GibbsExcessSolid']\n\nfrom math import isinf, isnan\n\nfrom chemicals.solubility import Henry_constants, d2Henry_constants_dT2, dHenry_constants_dT\nfrom chemicals.utils import phase_identification_parameter\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, evaluate_linear_fits, evaluate_linear_fits_d, evaluate_linear_fits_d2, exp, horner_and_der2, log, secant, trunc_exp\nfrom fluids.numerics import numpy as np\n\nfrom thermo.activity import IdealSolution\nfrom thermo.heat_capacity import HeatCapacityGas, HeatCapacityLiquid\nfrom thermo.nrtl import nrtl_d2taus_dT2 as d2ln_henries_dT2\nfrom thermo.nrtl import nrtl_dtaus_dT as dln_henries_dT\nfrom thermo.nrtl import nrtl_taus as ln_henries\nfrom thermo.phase_change import EnthalpySublimation, EnthalpyVaporization\nfrom thermo.phases.phase import Phase\nfrom thermo.utils import POLY_FIT, TRANSFORM_SECOND_DERIVATIVE_RATIO, TRANSFORM_SECOND_LOG_DERIVATIVE, TRANSFORM_DERIVATIVE_RATIO, TRANSFORM_LOG_DERIVATIVE, TRANSFORM_LOG\nfrom thermo.vapor_pressure import SublimationPressure, VaporPressure\nfrom thermo.volume import VolumeLiquid, VolumeSolid\n\ntry:\n    zeros, array = np.zeros, np.array\nexcept:\n    pass\n\nclass GibbsExcessLiquid(Phase):\n    r'''Phase based on combining Raoult's law with a\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model, optionally\n    including saturation fugacity coefficient corrections (if the vapor phase\n    is a cubic equation of state) and Poynting correction factors (if more\n    accuracy is desired).\n\n    The equilibrium equation options (controlled by `equilibrium_basis`)\n    are as follows:\n\n    * 'Psat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat}}{P}`\n    * 'Poynting&PhiSat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat} \\text{Poynting}_i}{P}`\n    * 'Poynting': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat}\\text{Poynting}_i}{P}`\n    * 'PhiSat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat}}{P}`\n\n    In all cases, the activity coefficient is derived from the\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model specified as\n    input; use the :obj:`IdealSolution <thermo.activity.IdealSolution>`\n    class as an input to set the activity coefficients to one.\n\n    The enthalpy `H` and entropy `S` (and other caloric properties `U`, `G`, `A`)\n    equation options are similar to the equilibrium ones. If the same option\n    is selected for `equilibrium_basis` and `caloric_basis`, the phase will be\n    `thermodynamically consistent`. This is recommended for many reasons.\n    The full 'Poynting&PhiSat' equations for `H` and `S` are as follows; see\n    :obj:`GibbsExcessLiquid.H` and :obj:`GibbsExcessLiquid.S` for all of the\n    other equations:\n\n    .. math::\n        H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n        \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n        + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n        + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n        + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n    .. math::\n        S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n        - \\sum_i z_i\\left[R\\left(\n        T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n        + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n        + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n        + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}\\cdot\\phi_{\\text{sat},i}}{P}\\right)\n        \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n    An additional caloric mode is `Hvap`, which uses enthalpy of vaporization;\n    this mode can never be thermodynamically consistent, but is still widely\n    used.\n\n    .. math::\n        H = H_{\\text{excess}} + \\sum_i z_i\\left[-H_{vap,i}\n        + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n    .. math::\n        S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n        - \\sum_i z_i\\left[R\\left(\\ln P_{\\text{sat},i} + \\ln\\left(\\frac{1}{P}\\right)\\right)\n        + \\frac{H_{vap,i}}{T}\n        - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n\n    .. warning::\n        Note that above the critical point, there is no definition for what vapor\n        pressure is. The vapor pressure also tends to reach zero at temperatures\n        in the 4-20 K range. These aspects mean extrapolation in the supercritical and\n        very low temperature region is critical to ensure the equations will still\n        converge. Extrapolation can be performed using either the equation\n        :math:`P^{\\text{sat}} = \\exp\\left(A - \\frac{B}{T}\\right)` or\n        :math:`P^{\\text{sat}} = \\exp\\left(A + \\frac{B}{T} + C\\cdot \\ln T\\right)` by\n        setting `Psat_extrpolation` to either 'AB' or 'ABC' respectively.\n        The extremely low temperature region's issue is solved by calculating the\n        logarithm of vapor pressures instead of the actual value. While floating\n        point values in Python (doubles) can reach a minimum value of around\n        1e-308, if only the logarithm of that number is computed no issues arise.\n        Both of these features only work when the vapor pressure correlations are\n        polynomials.\n\n    .. warning::\n        When using 'PhiSat' as an option, note that the factor cannot be\n        calculated when a compound is supercritical,\n        as there is no longer any vapor-liquid pure-component equilibrium\n        (by definition).\n\n    Parameters\n    ----------\n    VaporPressures : list[:obj:`thermo.vapor_pressure.VaporPressure`]\n        Objects holding vapor pressure data and methods, [-]\n    VolumeLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods; required for Poynting\n        factors and volumetric properties, [-]\n    HeatCapacityGases : list[:obj:`thermo.heat_capacity.HeatCapacityGas`], optional\n        Objects proiding pure-component heat capacity correlations; required\n        for caloric properties, [-]\n    GibbsExcessModel : :obj:`GibbsExcess <thermo.activity.GibbsExcess>`, optional\n        Configured instance for calculating activity coefficients and excess properties;\n        set to :obj:`IdealSolution <thermo.activity.IdealSolution>` if not provided, [-]\n    eos_pure_instances : list[:obj:`thermo.eos.GCEOS`], optional\n        Cubic equation of state object instances for each pure component, [-]\n    EnthalpyVaporizations : list[:obj:`thermo.phase_change.EnthalpyVaporization`], optional\n        Objects holding enthalpy of vaporization data and methods; used only\n        with the 'Hvap' optional, [-]\n    HeatCapacityLiquids : list[:obj:`thermo.heat_capacity.HeatCapacityLiquid`], optional\n        Objects holding liquid heat capacity data and methods; not used at\n        present, [-]\n    VolumeSupercriticalLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods but that are used for\n        supercritical temperatures on a per-component basis only; required for\n        Poynting factors and volumetric properties at supercritical conditions;\n        `VolumeLiquids` is used if not provided, [-]\n    Hfs : list[float], optional\n        Molar ideal-gas standard heats of formation at 298.15 K and 1 atm,\n        [J/mol]\n    Gfs : list[float], optional\n        Molar ideal-gas standard Gibbs energies of formation at 298.15 K and\n        1 atm, [J/mol]\n    T : float, optional\n        Temperature, [K]\n    P : float, optional\n        Pressure, [Pa]\n    zs : list[float], optional\n        Mole fractions of each component, [-]\n    equilibrium_basis : str, optional\n        Which set of equilibrium equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', [-]\n    caloric_basis : str, optional\n        Which set of caloric equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', 'Hvap' [-]\n    Psat_extrpolation : str, optional\n        One of 'AB' or 'ABC'; configures extrapolation for vapor pressure, [-]\n    henry_abcdef : tuple[list[list[float]], 6], optional\n        Contains the parameters used for henry's law constant, [-]\n    henry_as : list[list[float]], optional\n        `a` parameters used in calculating henry's law constant, [-]\n    henry_bs : list[list[float]], optional\n        `b` parameters used in calculating henry's law constant, [K]\n    henry_cs : list[list[float]], optional\n        `c` parameters used in calculating henry's law constant, [-]\n    henry_ds : list[list[float]], optional\n        `d` paraemeters used in calculating henry's law constant, [1/K]\n    henry_es : list[list[float]], optional\n        `e` parameters used in calculating henry's law constant, [K^2]\n    henry_fs : list[list[float]], optional\n        `f` parameters used in calculating henry's law constant, [1/K^2]\n    henry_mode : str\n        The setting for henry's law. 'solvents' to consider all\n        components set not to be henry's law components a solvent (if\n        any parameters are missing this will not make sense at all);\n        'solvents_with_parameters' to consider only the solvents with\n        parameters (vapor pressures will be used if a component has\n        no solvents whatsoever)\n\n    use_Hvap_caloric : bool, optional\n        If True, enthalpy and entropy will be calculated using ideal-gas\n        heat capacity and the heat of vaporization of the fluid only. This\n        forces enthalpy to be pressure-independent. This supersedes other\n        options which would otherwise impact these properties. The molar volume\n        of the fluid has no impact on enthalpy or entropy if this option is\n        True. This option is not thermodynamically consistent, but is still\n        often an assumption that is made.\n\n    '''\n\n    PIP_INCALCULABLE_VALUE = 2\n    force_phase = 'l'\n    phase = 'l'\n    is_gas = False\n    is_liquid = True\n    P_DEPENDENT_H_LIQ = True\n    PHI_SAT_IDEAL_TR = 0.1\n    _Psats_data = None\n    _Vms_sat_data = None\n    _Hvap_data = None\n\n    use_IG_Cp = True # Deprecated! Remove with S_old and H_old\n\n    ideal_gas_basis = True\n    supercritical_volumes = False\n\n    Cpls_poly_fit = False\n    _Cpls_data = None\n\n    _Tait_B_data = None\n    _Tait_C_data = None\n\n    pure_references = ('HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids',\n                       'EnthalpyVaporizations')\n    pure_reference_types = (HeatCapacityGas, VolumeLiquid, VaporPressure, HeatCapacityLiquid,\n                            EnthalpyVaporization)\n\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel',\n                        'eos_pure_instances', 'use_Poynting', 'use_phis_sat',\n                        'use_Tait', 'use_eos_volume', 'henry_components',\n                        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs','henry_mode',\n                        'Psat_extrpolation') + pure_references\n\n    obj_references = ('GibbsExcessModel', 'eos_pure_instances', 'result', 'constants', 'correlations',\n                        'HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids',\n                                        'EnthalpyVaporizations')\n\n\n    # Not sure how this will progress\n    __slots__ = ('VaporPressures', 'Psats_poly_fit', 'Psat_extrpolation', 'N', 'HeatCapacityGases', 'Cpgs_poly_fit',\n     '_Cpgs_data', 'HeatCapacityLiquids', 'use_eos_volume', 'VolumeLiquids', 'Vms_sat_poly_fit', 'VolumeSupercriticalLiquids',\n      'Vms_supercritical_poly_fit', 'incompressible', 'use_Tait', 'EnthalpyVaporizations', 'Hvap_poly_fit', 'GibbsExcessModel',\n       'eos_pure_instances', 'equilibrium_basis', 'caloric_basis', 'use_phis_sat', 'use_Poynting', 'use_phis_sat_caloric',\n        'use_Poynting_caloric', 'use_Hvap_caloric', 'has_henry_components', 'henry_components',\n        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs','henry_mode',\n         'composition_independent',\n        'Hfs', 'Gfs', 'Sfs', 'model_id', 'T', 'P', 'zs', '_model_hash_ignore_phase', '_model_hash')\n\n    def __repr__(self):\n        r'''Method to create a string representation of the phase object, with\n        the goal of making it easy to obtain standalone code which reproduces\n        the current state of the phase. This is extremely helpful in creating\n        new test cases.\n\n        Returns\n        -------\n        recreation : str\n            String which is valid Python and recreates the current state of\n            the object if ran, [-]\n\n        '''\n        pure_strs = ''\n        for k in self.pure_references:\n            v = getattr(self, k)\n            if v is not None:\n                try:\n                    s = '[' + ', '.join(str(o) for o in v) + ']'\n                except:\n                    continue\n                pure_strs += f'{k}={s}, '\n\n\n        base = f\"\"\"{self.__class__.__name__}(GibbsExcessModel={self.GibbsExcessModel},\n               equilibrium_basis={self.equilibrium_basis}, caloric_basis={self.caloric_basis},\n               eos_pure_instances={self.eos_pure_instances}, {pure_strs}\"\"\"\n        for s in ('Hfs', 'Gfs', 'Sfs', 'T', 'P', 'zs'):\n            if hasattr(self, s) and getattr(self, s) is not None:\n                base += f'{s}={getattr(self, s)}, '\n        if base[-2:] == ', ':\n            base = base[:-2]\n        base += ')'\n        return base\n\n\n    def __init__(self, VaporPressures, VolumeLiquids=None,\n                 HeatCapacityGases=None,\n                 GibbsExcessModel=None,\n                 eos_pure_instances=None,\n                 EnthalpyVaporizations=None,\n                 HeatCapacityLiquids=None,\n                 VolumeSupercriticalLiquids=None,\n\n                 use_Hvap_caloric=False,\n                 use_Poynting=False,\n                 use_phis_sat=False,\n                 use_Tait=False,\n                 use_eos_volume=False,\n\n                 Hfs=None, Gfs=None, Sfs=None,\n\n                 henry_components=None,\n                 henry_abcdef=None,\n                 henry_as=None, henry_bs=None,\n                 henry_cs=None, henry_ds=None,\n                 henry_es=None, henry_fs=None,\n                 henry_mode='solvents_with_parameters',\n\n                 T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None,\n                 Psat_extrpolation='AB',\n                 equilibrium_basis=None,\n                 caloric_basis=None,\n                 ):\n        '''It is quite possible to introduce a PVT relation ship for liquid\n        density and remain thermodynamically consistent. However, must be\n        applied on a per-component basis! This class cannot have an\n        equation-of-state or VolumeLiquidMixture for a liquid MIXTURE!\n\n        (it might still be nice to generalize the handling; maybe even allow)\n        pure EOSs to be used too, and as a form/template for which functions to\n        use).\n\n        In conclusion, you have\n        1) The standard H/S model\n        2) The H/S model with all pressure correction happening at P\n        3) The inconsistent model which has no pressure dependence whatsover in H/S\n           This model is required due to its popularity, not its consistency (but still volume dependency)\n\n        All mixture volumetric properties have to be averages of the pure\n        components properties and derivatives. A Multiphase will be needed to\n        allow flashes with different properties from different phases.\n        '''\n        self.N = N = len(VaporPressures)\n        if zs is None:\n            zs = [1.0/N]*N\n        if henry_components is None:\n            henry_components = [False]*self.N\n        self.has_henry_components = any(henry_components)\n        self.henry_components = henry_components\n\n        self.VaporPressures = VaporPressures\n        self.Psats_poly_fit = (all(i.method == POLY_FIT for i in VaporPressures) and not self.has_henry_components) if VaporPressures is not None else False\n        self.Psat_extrpolation = Psat_extrpolation\n        if self.Psats_poly_fit:\n            Psats_data = [[i.poly_fit_Tmin for i in VaporPressures],\n                               [i.poly_fit_Tmin_slope for i in VaporPressures],\n                               [i.poly_fit_Tmin_value for i in VaporPressures],\n                               [i.poly_fit_Tmax for i in VaporPressures],\n                               [i.poly_fit_Tmax_slope for i in VaporPressures],\n                               [i.poly_fit_Tmax_value for i in VaporPressures],\n                               [i.poly_fit_coeffs for i in VaporPressures],\n                               [i.poly_fit_d_coeffs for i in VaporPressures],\n                               [i.poly_fit_d2_coeffs for i in VaporPressures],\n                               [i.DIPPR101_ABC for i in VaporPressures]]\n            if Psat_extrpolation == 'AB':\n                Psats_data.append([i.poly_fit_AB_high_ABC_compat + [0.0] for i in VaporPressures])\n            elif Psat_extrpolation == 'ABC':\n                Psats_data.append([i.DIPPR101_ABC_high for i in VaporPressures])\n            # Other option: raise?\n            self._Psats_data = Psats_data\n\n\n        if self.vectorized:\n            zero_coeffs = zeros((N, N))\n        else:\n            zero_coeffs = [[0.0]*N for _ in range(N)]\n\n        self.HeatCapacityGases = HeatCapacityGases\n        self.Cpgs_poly_fit, self._Cpgs_data = self._setup_Cpigs(HeatCapacityGases)\n\n        self.HeatCapacityLiquids = HeatCapacityLiquids\n        if HeatCapacityLiquids is not None:\n            self.Cpls_poly_fit, self._Cpls_data = self._setup_Cpigs(HeatCapacityLiquids)\n            T_REF_IG = self.T_REF_IG\n            T_REF_IG_INV = 1.0/T_REF_IG\n            self.Hvaps_T_ref = [obj(T_REF_IG) for obj in EnthalpyVaporizations]\n            self.dSvaps_T_ref = [T_REF_IG_INV*dH for dH in self.Hvaps_T_ref]\n\n        self.use_eos_volume = use_eos_volume\n        self.VolumeLiquids = VolumeLiquids\n        self.Vms_sat_poly_fit = ((not use_eos_volume and all(i.method == POLY_FIT for i in VolumeLiquids)) if VolumeLiquids is not None else False)\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_data = [[i.poly_fit_Tmin for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_slope for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_value for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax_slope for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax_value for i in VolumeLiquids],\n                                 [i.poly_fit_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_d_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_d2_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_quadratic for i in VolumeLiquids],\n                                 ]\n#            low_fits = self._Vms_sat_data[9]\n#            for i in range(self.N):\n#                low_fits[i][0] = max(0, low_fits[i][0])\n\n        self.VolumeSupercriticalLiquids = VolumeSupercriticalLiquids\n        self.Vms_supercritical_poly_fit = all(i.method == POLY_FIT for i in VolumeSupercriticalLiquids) if VolumeSupercriticalLiquids is not None else False\n        if self.Vms_supercritical_poly_fit:\n            self.Vms_supercritical_data = [[i.poly_fit_Tmin for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_slope for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_value for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax_slope for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax_value for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_d_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_d2_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_quadratic for i in VolumeSupercriticalLiquids],\n                                 ]\n\n\n        self.incompressible = not use_Tait\n        self.use_Tait = use_Tait\n        if self.use_Tait:\n            Tait_B_data, Tait_C_data = [[] for i in range(9)], [[] for i in range(9)]\n            for v in VolumeLiquids:\n                for (d, store) in zip(v.Tait_data(), [Tait_B_data, Tait_C_data]):\n                    for i in range(len(d)):\n                        store[i].append(d[i])\n            self._Tait_B_data = Tait_B_data\n            self._Tait_C_data = Tait_C_data\n\n\n        self.EnthalpyVaporizations = EnthalpyVaporizations\n        self.Hvap_poly_fit = all(i.method == POLY_FIT for i in EnthalpyVaporizations) if EnthalpyVaporizations is not None else False\n        if self.Hvap_poly_fit:\n            self._Hvap_data = [[i.poly_fit_Tmin for i in EnthalpyVaporizations],\n                              [i.poly_fit_Tmax for i in EnthalpyVaporizations],\n                              [i.poly_fit_Tc for i in EnthalpyVaporizations],\n                              [1.0/i.poly_fit_Tc for i in EnthalpyVaporizations],\n                              [i.poly_fit_coeffs for i in EnthalpyVaporizations]]\n\n\n\n        if GibbsExcessModel is None:\n            GibbsExcessModel = IdealSolution(T=T, xs=zs)\n\n        self.GibbsExcessModel = GibbsExcessModel\n        self.eos_pure_instances = eos_pure_instances\n\n        self.equilibrium_basis = equilibrium_basis\n        self.caloric_basis = caloric_basis\n\n        if equilibrium_basis is not None:\n            if equilibrium_basis == 'Poynting':\n                self.use_Poynting = True\n                self.use_phis_sat = False\n            elif equilibrium_basis == 'Poynting&PhiSat':\n                self.use_Poynting = True\n                self.use_phis_sat = True\n            elif equilibrium_basis == 'PhiSat':\n                self.use_phis_sat = True\n                self.use_Poynting = False\n            elif equilibrium_basis == 'Psat':\n                self.use_phis_sat = False\n                self.use_Poynting = False\n        else:\n            self.use_Poynting = use_Poynting\n            self.use_phis_sat = use_phis_sat\n\n        if caloric_basis is not None:\n            if caloric_basis == 'Poynting':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Poynting&PhiSat':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = True\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'PhiSat':\n                self.use_phis_sat_caloric = True\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Psat':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Hvap':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = True\n        else:\n            self.use_Poynting_caloric = use_Poynting\n            self.use_phis_sat_caloric = use_phis_sat\n            self.use_Hvap_caloric = use_Hvap_caloric\n\n\n\n\n        if henry_mode not in ('solvents', 'solvents_with_parameters'):\n            raise ValueError(\"Henry's law model setting not recognized\")\n        self.henry_mode = henry_mode\n\n\n        multiple_henry_inputs = (henry_as, henry_bs, henry_cs, henry_ds, henry_es, henry_fs)\n        input_count_henry = (henry_abcdef is not None) + (any(i is not None for i in multiple_henry_inputs))\n        if input_count_henry > 1:\n            raise ValueError(\"Input only one of henry_abcdef, or (henry_as...henry_fs)\")\n        if henry_abcdef is not None:\n            if self.vectorized:\n                self.henry_as = array(henry_abcdef[:,:,0], order='C', copy=True)\n                self.henry_bs = array(henry_abcdef[:,:,1], order='C', copy=True)\n                self.henry_cs = array(henry_abcdef[:,:,2], order='C', copy=True)\n                self.henry_ds = array(henry_abcdef[:,:,3], order='C', copy=True)\n                self.henry_es = array(henry_abcdef[:,:,4], order='C', copy=True)\n                self.henry_fs = array(henry_abcdef[:,:,5], order='C', copy=True)\n            else:\n                self.henry_as = [[i[0] for i in l] for l in henry_abcdef]\n                self.henry_bs = [[i[1] for i in l] for l in henry_abcdef]\n                self.henry_cs = [[i[2] for i in l] for l in henry_abcdef]\n                self.henry_ds = [[i[3] for i in l] for l in henry_abcdef]\n                self.henry_es = [[i[4] for i in l] for l in henry_abcdef]\n                self.henry_fs = [[i[5] for i in l] for l in henry_abcdef]\n        else:\n            if henry_abcdef is None:\n                henry_abcdef = multiple_henry_inputs\n            henry_abcdef_len = 0 if henry_abcdef is None else len(henry_abcdef)\n            if not henry_abcdef_len or henry_abcdef[0] is None:\n                self.henry_as = zero_coeffs\n            else:\n                self.henry_as = henry_abcdef[0]\n            if not henry_abcdef_len or henry_abcdef[1] is None:\n                self.henry_bs = zero_coeffs\n            else:\n                self.henry_bs = henry_abcdef[1]\n            if not henry_abcdef_len or henry_abcdef[2] is None:\n                self.henry_cs = zero_coeffs\n            else:\n                self.henry_cs = henry_abcdef[2]\n            if not henry_abcdef_len or henry_abcdef[3] is None:\n                self.henry_ds = zero_coeffs\n            else:\n                self.henry_ds = henry_abcdef[3]\n            if not henry_abcdef_len or henry_abcdef[4] is None:\n                self.henry_es = zero_coeffs\n            else:\n                self.henry_es = henry_abcdef[4]\n            if not henry_abcdef_len or henry_abcdef[5] is None:\n                self.henry_fs = zero_coeffs\n            else:\n                self.henry_fs = henry_abcdef[5]\n\n        self.composition_independent = isinstance(GibbsExcessModel, IdealSolution) and not self.has_henry_components\n\n        self.Hfs = Hfs\n        self.Gfs = Gfs\n        self.Sfs = Sfs\n\n        self.model_id = 20000 + GibbsExcessModel.model_id\n\n        if T is not None and P is not None and zs is not None:\n            self.T = T\n            self.P = P\n            self.zs = zs\n\n    def to_TP_zs(self, T, P, zs):\n        T_equal = hasattr(self, 'T') and T == self.T\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new.N = self.N\n\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n\n    def to(self, zs, T=None, P=None, V=None):\n        try:\n            T_equal = T == self.T\n        except:\n            T_equal = False\n\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.N = self.N\n\n        if T is not None:\n            if P is not None:\n                new.T = T\n                new.P = P\n            elif V is not None:\n                def to_solve(P):\n                    return self.to_TP_zs(T, P, zs).V() - V\n                P = secant(to_solve, 0.0002, xtol=1e-8, ytol=1e-10)\n                new.P = P\n        elif P is not None and V is not None:\n            def to_solve(T):\n                return self.to_TP_zs(T, P, zs).V() - V\n            T = secant(to_solve, 300, xtol=1e-9, ytol=1e-5)\n            new.T = T\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def transfer_data(self, new, zs, T, T_equal):\n        new.VaporPressures = self.VaporPressures\n        new.VolumeLiquids = self.VolumeLiquids\n        new.eos_pure_instances = self.eos_pure_instances\n        new.HeatCapacityGases = self.HeatCapacityGases\n        new.EnthalpyVaporizations = self.EnthalpyVaporizations\n        new.HeatCapacityLiquids = self.HeatCapacityLiquids\n\n\n        new.Psats_poly_fit = self.Psats_poly_fit\n        new._Psats_data = self._Psats_data\n        new.Psat_extrpolation = self.Psat_extrpolation\n\n        new.Cpgs_poly_fit = self.Cpgs_poly_fit\n        new._Cpgs_data = self._Cpgs_data\n\n        new.Cpls_poly_fit = self.Cpls_poly_fit\n        new._Cpls_data = self._Cpls_data\n\n        new.Vms_sat_poly_fit = self.Vms_sat_poly_fit\n        new._Vms_sat_data = self._Vms_sat_data\n\n        new._Hvap_data = self._Hvap_data\n        new.Hvap_poly_fit = self.Hvap_poly_fit\n\n        new.incompressible = self.incompressible\n\n        new.equilibrium_basis = self.equilibrium_basis\n        new.caloric_basis = self.caloric_basis\n\n        new.use_phis_sat = self.use_phis_sat\n        new.use_Poynting = self.use_Poynting\n        new.P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        new.use_eos_volume = self.use_eos_volume\n        new.use_Hvap_caloric = self.use_Hvap_caloric\n\n        new.Hfs = self.Hfs\n        new.Gfs = self.Gfs\n        new.Sfs = self.Sfs\n\n        new.henry_as = self.henry_as\n        new.henry_bs = self.henry_bs\n        new.henry_cs = self.henry_cs\n        new.henry_ds = self.henry_ds\n        new.henry_es = self.henry_es\n        new.henry_fs = self.henry_fs\n        new.henry_components = self.henry_components\n        new.has_henry_components = self.has_henry_components\n        new.henry_mode = self.henry_mode\n\n        new.composition_independent = self.composition_independent\n        new.model_id = self.model_id\n\n        new.use_Tait = self.use_Tait\n        new._Tait_B_data = self._Tait_B_data\n        new._Tait_C_data = self._Tait_C_data\n\n\n        if T_equal and (self.composition_independent or self.zs is zs):\n            # Allow the composition inconsistency as it is harmless\n            new.GibbsExcessModel = self.GibbsExcessModel\n        else:\n            new.GibbsExcessModel = self.GibbsExcessModel.to_T_xs(T=T, xs=zs)\n\n        try:\n            if T_equal:\n                if not self.has_henry_components:\n                    try:\n                        new._Psats = self._Psats\n                        new._dPsats_dT = self._dPsats_dT\n                        new._d2Psats_dT2 = self._d2Psats_dT2\n                    except:\n                        pass\n                    try:\n                        new._lnPsats = self._lnPsats\n                        new._dPsats_dT_over_Psats = self._dPsats_dT_over_Psats\n                    except:\n                        pass\n                else:\n                    try:\n                        new._lnHenry_matrix = self._lnHenry_matrix\n                        new._dlnHenry_matrix_dT = self._dlnHenry_matrix_dT\n                        new._d2lnHenry_matrix_dT2 = self._d2lnHenry_matrix_dT2\n                    except:\n                        pass\n\n                try:\n                    new._Vms_sat = self._Vms_sat\n                    new._Vms_sat_dT = self._Vms_sat_dT\n                    new._d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n                except:\n                    pass\n                try:\n                    new._Cpigs = self._Cpigs\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_pure = self._Cpig_integrals_pure\n                except:\n                    pass\n        except:\n            pass\n        return new\n\n    supports_lnphis_args = False\n\n    def lnphis_args(self):\n        try:\n            return self._lnphis_args\n        except:\n            pass\n        lnPsats = self.lnPsats()\n        Poyntings = self.Poyntings()\n        phis_sat = self.phis_sat()\n        activity_args = self.GibbsExcessModel.gammas_args()\n        lnphis = zeros(self.N) if self.vectorized else [0.0]*self.N\n        self._lnphis_args = (self.model_id, self.T, self.P, self.N, lnPsats, Poyntings, phis_sat) + activity_args +(lnphis,)\n        return self._lnphis_args\n\n\n    def lnHenry_matrix(self):\n        r'''Method to calculate and return the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        .. math::\n            \\ln \\text{H}_{i,j} = A_{ij}+\\frac{B_{ij}}{T}+C_{ij}\\ln T + D_{ij}T\n            + \\frac{E_{ij}}{T^2} + F_{ij}{T^2}\n\n        Returns\n        -------\n        lnHenry_matrix : list[list[float]]\n            Henry's law interaction parameters, [log(Pa)]\n\n        Notes\n        -----\n        Solvent/solvent and gas/gas values are all 0.\n        '''\n        try:\n            return self._lnHenry_matrix\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            lnHenry_matrix = zeros((N, N))\n        else:\n            lnHenry_matrix = [[0.0]*N for _ in range(N)]\n\n        lnHenry_matrix = ln_henries(self.T, N, self.henry_as, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, lnHenry_matrix)\n        self._lnHenry_matrix = lnHenry_matrix\n        return lnHenry_matrix\n\n    def dlnHenry_matrix_dT(self):\n        r'''Method to calculate and return the first temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        dlnHenry_matrix_dT : list[list[float]]\n            First temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._dlnHenry_matrix_dT\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            dlnHenry_matrix_dT = zeros((N, N))\n        else:\n            dlnHenry_matrix_dT = [[0.0]*N for _ in range(N)]\n        dlnHenry_matrix_dT = dln_henries_dT(self.T, N, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, dlnHenry_matrix_dT)\n        self._dlnHenry_matrix_dT = dlnHenry_matrix_dT\n        return dlnHenry_matrix_dT\n\n    def d2lnHenry_matrix_dT2(self):\n        r'''Method to calculate and return the second temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        d2lnHenry_matrix_dT2 : list[list[float]]\n            Second temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._d2lnHenry_matrix_dT2\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            d2lnHenry_matrix_dT2 = zeros((N, N))\n        else:\n            d2lnHenry_matrix_dT2 = [[0.0]*N for _ in range(N)]\n        d2lnHenry_matrix_dT2 = d2ln_henries_dT2(self.T, N, self.henry_bs, self.henry_cs, self.henry_es, self.henry_fs, d2lnHenry_matrix_dT2)\n        self._d2lnHenry_matrix_dT2 = d2lnHenry_matrix_dT2\n        return d2lnHenry_matrix_dT2\n\n    def Henry_constants(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        Hs = zeros(N) if vectorized else [0.0]*N\n        Henry_constants(lnHenry_matrix, zs, henry_components, solvents_with_parameters, Hs)\n        return Hs\n        dHenry_constants_dT\n\n    def dHenry_constants_dT(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        dHs = zeros(N) if vectorized else [0.0]*N\n        dHenry_constants_dT(lnHenry_matrix, dlnHenry_matrix_dT, zs, henry_components, solvents_with_parameters, dHs)\n        return dHs\n\n    def d2Henry_constants_dT2(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        d2lnHenry_matrix_dT2 = self.d2lnHenry_matrix_dT2()\n        d2Hs = zeros(N) if vectorized else [0.0]*N\n        d2Henry_constants_dT2(lnHenry_matrix, dlnHenry_matrix_dT, d2lnHenry_matrix_dT2, zs, henry_components, solvents_with_parameters, d2Hs)\n        return d2Hs\n\n\n    def Psats_T_ref(self):\n        try:\n            return self._Psats_T_ref\n        except AttributeError:\n            pass\n        VaporPressures, N = self.VaporPressures, self.N\n        T_REF_IG = self.T_REF_IG\n        if self.has_henry_components:\n            self._Psats_T_ref = self.to(T=T_REF_IG, P=self.P, zs=self.zs).Psats()\n        else:\n            self._Psats_T_ref = [VaporPressures[i](T_REF_IG) for i in range(N)]\n        return self._Psats_T_ref\n\n    def Psats_at(self, T):\n        if self.Psats_poly_fit:\n            return self._Psats_at_poly_fit(T, self._Psats_data, range(self.N))\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).Psats()\n        VaporPressures = self.VaporPressures\n        return [VaporPressures[i](T) for i in range(self.N)]\n\n    @staticmethod\n    def _Psats_at_poly_fit(T, Psats_data, cmps):\n        Psats = []\n        T_inv = 1.0/T\n        logT = log(T)\n        Tmins, Tmaxes, coeffs = Psats_data[0], Psats_data[3], Psats_data[6]\n        for i in cmps:\n            if T < Tmins[i]:\n                A, B, C = Psats_data[9][i]\n                Psat = (A + B*T_inv + C*logT)\n#                    A, B = _Psats_data[9][i]\n#                    Psat = (A - B*T_inv)\n#                    Psat = (T - Tmins[i])*_Psats_data[1][i] + _Psats_data[2][i]\n            elif T > Tmaxes[i]:\n                A, B, C = Psats_data[10][i]\n                Psat = (A + B*T_inv + C*logT)\n#                A, B = _Psats_data[10][i]\n#                Psat = (A - B*T_inv)\n#                Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n            else:\n                Psat = 0.0\n                for c in coeffs[i]:\n                    Psat = Psat*T + c\n            try:\n                Psats.append(exp(Psat))\n            except:\n                Psats.append(1.6549840276802644e+300)\n\n        return Psats\n\n    def Psats(self):\n        try:\n            return self._Psats\n        except AttributeError:\n            pass\n        N = self.N\n        T, cmps = self.T, range(N)\n        if self.Psats_poly_fit:\n            self._Psats = Psats = self._Psats_at_poly_fit(T, self._Psats_data, cmps)\n#            _Psats_data = self._Psats_data\n#            Tmins, Tmaxes, coeffs = _Psats_data[0], _Psats_data[3], _Psats_data[6]\n#            for i in cmps:\n#                if T < Tmins[i]:\n#                    A, B, C = _Psats_data[9][i]\n#                    Psat = (A + B*T_inv + C*logT)\n##                    A, B = _Psats_data[9][i]\n##                    Psat = (A - B*T_inv)\n##                    Psat = (T - Tmins[i])*_Psats_data[1][i] + _Psats_data[2][i]\n#                elif T > Tmaxes[i]:\n#                    Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n#                else:\n#                    Psat = 0.0\n#                    for c in coeffs[i]:\n#                        Psat = Psat*T + c\n#                Psats.append(exp(Psat))\n        else:\n            self._Psats = Psats = []\n            for i in self.VaporPressures:\n                Psats.append(i.T_dependent_property(T))\n\n        if self.has_henry_components:\n            Hs, henry_components = self.Henry_constants(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    Psats[i] = Hs[i]\n        return Psats\n\n    def PIP(self):\n        dP_dT = self.dP_dT()\n        if dP_dT == 0:\n            return self.PIP_INCALCULABLE_VALUE\n        return phase_identification_parameter(self.V(), self.dP_dT(), self.dP_dV(),\n                                              self.d2P_dV2(), self.d2P_dTdV())\n\n    @staticmethod\n    def _dPsats_dT_at_poly_fit(T, Psats_data, cmps, Psats):\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        dPsats_dT = []\n        Tmins, Tmaxes, dcoeffs, coeffs_low, coeffs_high = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n        for i in cmps:\n            if T < Tmins[i]:\n#                    A, B = _Psats_data[9][i]\n#                    dPsat_dT = B*Tinv2*Psats[i]\n                dPsat_dT = Psats[i]*(-coeffs_low[i][1]*Tinv2 + coeffs_low[i][2]*T_inv)\n#                    dPsat_dT = _Psats_data[1][i]*Psats[i]#*exp((T - Tmins[i])*_Psats_data[1][i]\n                                             #   + _Psats_data[2][i])\n            elif T > Tmaxes[i]:\n                dPsat_dT = Psats[i]*(-coeffs_high[i][1]*Tinv2 + coeffs_high[i][2]*T_inv)\n\n#                dPsat_dT = _Psats_data[4][i]*Psats[i]#*exp((T - Tmaxes[i])\n#                                                    #*_Psats_data[4][i]\n#                                                    #+ _Psats_data[5][i])\n            else:\n                dPsat_dT = 0.0\n                for c in dcoeffs[i]:\n                    dPsat_dT = dPsat_dT*T + c\n#                    v, der = horner_and_der(coeffs[i], T)\n                dPsat_dT *= Psats[i]\n            dPsats_dT.append(dPsat_dT)\n        return dPsats_dT\n\n    def dPsats_dT_at(self, T, Psats=None):\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if self.Psats_poly_fit:\n            return self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(self.N), Psats)\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).dPsats_dT()\n        return [VaporPressure.T_dependent_property_derivative(T=T)\n                     for VaporPressure in self.VaporPressures]\n\n    def dPsats_dT(self):\n        try:\n            return self._dPsats_dTT_dependent_property_derivative\n        except:\n            pass\n        T, N = self.T, self.N\n        # Need to reset the method because for the T bounded solver,\n        # will normally get a different than prefered method as it starts\n        # at the boundaries\n        if self.Psats_poly_fit:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            self._dPsats_dT = dPsats_dT = self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(N), Psats)\n            return dPsats_dT\n\n        self._dPsats_dT = dPsats_dT = [VaporPressure.T_dependent_property_derivative(T=T)\n                     for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            dHs, henry_components = self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dPsats_dT[i] = dHs[i]\n        return dPsats_dT\n\n    def d2Psats_dT2(self):\n        try:\n            return self._d2Psats_dT2\n        except:\n            pass\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        T_inv2 = T_inv*T_inv\n        # Tinv3 = T_inv*T_inv*T_inv\n\n        self._d2Psats_dT2 = d2Psats_dT2 = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = Psats_data[0], Psats_data[3], Psats_data[8]\n            for i in range(N):\n                if T < Tmins[i]:\n#                    A, B = _Psats_data[9][i]\n#                    d2Psat_dT2 = B*Psats[i]*(B*T_inv - 2.0)*Tinv3\n                    A, B, C = Psats_data[9][i]\n                    x0 = (B*T_inv - C)\n                    d2Psat_dT2 = Psats[i]*(2.0*B*T_inv - C + x0*x0)*T_inv2\n#                    d2Psat_dT2 = _Psats_data[1][i]*dPsats_dT[i]\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    x0 = (B*T_inv - C)\n                    d2Psat_dT2 = Psats[i]*(2.0*B*T_inv - C + x0*x0)*T_inv2\n#                    d2Psat_dT2 = _Psats_data[4][i]*dPsats_dT[i]\n                else:\n                    d2Psat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2Psat_dT2 = d2Psat_dT2*T + c\n                    d2Psat_dT2 = (dPsats_dT[i]*dPsats_dT[i]/Psats[i] + Psats[i]*d2Psat_dT2)\n                d2Psats_dT2.append(d2Psat_dT2)\n            return d2Psats_dT2\n\n        self._d2Psats_dT2 = d2Psats_dT2 = [VaporPressure.T_dependent_property_derivative(T=T, order=2)\n                     for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            d2Hs, henry_components = self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psats_dT2[i] = d2Hs[i]\n        return d2Psats_dT2\n\n    def lnPsats(self):\n        try:\n            return self._lnPsats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        logT = log(T)\n        lnPsats = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, coeffs = Psats_data[0], Psats_data[3], Psats_data[6]\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    Psat = (A + B*T_inv + C*logT)\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    Psat = (A + B*T_inv + C*logT)\n#                    Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n                else:\n                    Psat = 0.0\n                    for c in coeffs[i]:\n                        Psat = Psat*T + c\n                lnPsats.append(Psat)\n            self._lnPsats = lnPsats\n            return lnPsats\n\n        self._lnPsats = lnPsats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG)\n                                   for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, henry_components = self.Henry_constants(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    lnPsats[i] = log(Hs[i])\n        return lnPsats\n\n    def dlnPsats_dT(self):\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs = Psats_data[0], Psats_data[3], Psats_data[7]\n            dlnPsats_dT = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    dPsat_dT = (-B*Tinv2 + C*T_inv)\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    dPsat_dT = (-B*Tinv2 + C*T_inv)\n#                    dPsat_dT = _Psats_data[4][i]\n                else:\n                    dPsat_dT = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT = dPsat_dT*T + c\n                dlnPsats_dT.append(dPsat_dT)\n            return dlnPsats_dT\n        dlnPsats_dT = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dlnPsats_dT[i] = dHs[i]/Hs[i]\n\n        return dlnPsats_dT\n\n    def d2lnPsats_dT2(self):\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        T_inv2 = T_inv*T_inv\n        # Tinv3 = T_inv*T_inv*T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = Psats_data[0], Psats_data[3], Psats_data[8]\n            d2lnPsats_dT2 = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    d2lnPsat_dT2 = (2.0*B*T_inv - C)*T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    d2lnPsat_dT2 = (2.0*B*T_inv - C)*T_inv2\n#                    d2lnPsat_dT2 = 0.0\n                else:\n                    d2lnPsat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2lnPsat_dT2 = d2lnPsat_dT2*T + c\n                d2lnPsats_dT2.append(d2lnPsat_dT2)\n            return d2lnPsats_dT2\n        d2lnPsats_dT2 = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, d2Hs, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2lnPsats_dT2[i] = (d2Hs[i] - dHs[i]*dHs[i]/Hs[i])/Hs[i]\n\n        return d2lnPsats_dT2\n\n    def dPsats_dT_over_Psats(self):\n        try:\n            return self._dPsats_dT_over_Psats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        if self.Psats_poly_fit:\n            dPsat_dT_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n            for i in range(N):\n                if T < Tmins[i]:\n                    dPsat_dT_over_Psat = (-low_coeffs[i][1]*Tinv2 + low_coeffs[i][2]*T_inv)\n                elif T > Tmaxes[i]:\n                    dPsat_dT_over_Psat = (-high_coeffs[i][1]*Tinv2 + high_coeffs[i][2]*T_inv)\n#                    dPsat_dT_over_Psat = _Psats_data[4][i]\n                else:\n                    dPsat_dT_over_Psat = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT_over_Psat = dPsat_dT_over_Psat*T + c\n                dPsat_dT_over_Psats.append(dPsat_dT_over_Psat)\n            self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n            return dPsat_dT_over_Psats\n\n        # dPsat_dT_over_Psats = [i/j for i, j in zip(self.dPsats_dT(), self.Psats())]\n        dPsat_dT_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n\n        if self.has_henry_components:\n            Hs, dHenry_constants_dT, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dPsat_dT_over_Psats[i] = dHenry_constants_dT[i]/Hs[i]\n\n        self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n        return dPsat_dT_over_Psats\n\n    def d2Psats_dT2_over_Psats(self):\n        try:\n            return self._d2Psats_dT2_over_Psats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        Tinv4 = Tinv2*Tinv2\n        c0 = (T + T)*Tinv4\n        if self.Psats_poly_fit:\n            d2Psat_dT2_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n            for i in range(N):\n                if T < Tmins[i]:\n                    B, C = low_coeffs[i][1], low_coeffs[i][2]\n                    x0 = (B - C*T)\n                    d2Psat_dT2_over_Psat = c0*B - C*Tinv2 + x0*x0*Tinv4\n#                    d2Psat_dT2_over_Psat = (2*B*T - C*T**2 + (B - C*T)**2)/T**4\n                elif T > Tmaxes[i]:\n                    B, C = high_coeffs[i][1], high_coeffs[i][2]\n                    x0 = (B - C*T)\n                    d2Psat_dT2_over_Psat = c0*B - C*Tinv2 + x0*x0*Tinv4\n                else:\n                    dPsat_dT = 0.0\n                    d2Psat_dT2 = 0.0\n                    for a in dcoeffs[i]:\n                        d2Psat_dT2 = T*d2Psat_dT2 + dPsat_dT\n                        dPsat_dT = T*dPsat_dT + a\n                    d2Psat_dT2_over_Psat = dPsat_dT*dPsat_dT + d2Psat_dT2\n\n                d2Psat_dT2_over_Psats.append(d2Psat_dT2_over_Psat)\n            self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n            return d2Psat_dT2_over_Psats\n\n        # d2Psat_dT2_over_Psats = [i/j for i, j in zip(self.d2Psats_dT2(), self.Psats())]\n        d2Psat_dT2_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, d2Henry_constants_dT2, henry_components = self.Henry_constants(), self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psat_dT2_over_Psats[i] = d2Henry_constants_dT2[i]/Hs[i]\n\n        self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n        return d2Psat_dT2_over_Psats\n\n    @staticmethod\n    def _Vms_sat_at(T, Vms_sat_data, cmps):\n        Tmins, Tmaxes, coeffs, coeffs_Tmin = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[6], Vms_sat_data[9]\n        Vms_sat = []\n        for i in cmps:\n            if T < Tmins[i]:\n                Vm = 0.0\n                for c in coeffs_Tmin[i]:\n                    Vm = Vm*T + c\n#                    Vm = (T - Tmins[i])*Vms_sat_data[1][i] + Vms_sat_data[2][i]\n            elif T > Tmaxes[i]:\n                Vm = (T - Tmaxes[i])*Vms_sat_data[4][i] + Vms_sat_data[5][i]\n            else:\n                Vm = 0.0\n                for c in coeffs[i]:\n                    Vm = Vm*T + c\n            Vms_sat.append(Vm)\n        return Vms_sat\n\n    def Vms_sat_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n        VolumeLiquids = self.VolumeLiquids\n        return [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n\n    def Vms_sat(self):\n        try:\n            return self._Vms_sat\n        except AttributeError:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n#            self._Vms_sat = evaluate_linear_fits(self._Vms_sat_data, T)\n#            return self._Vms_sat\n            self._Vms_sat = Vms_sat = self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n            return Vms_sat\n        elif self.use_eos_volume:\n            Vms = []\n            eoss = self.eos_pure_instances\n            Psats = self.Psats()\n            for i, e in enumerate(eoss):\n                if T < e.Tc:\n                    Vms.append(e.V_l_sat(T))\n                else:\n                    e = e.to(T=T, P=Psats[i])\n                    try:\n                        Vms.append(e.V_l)\n                    except:\n                        Vms.append(e.V_g)\n            self._Vms_sat = Vms\n            return Vms\n\n\n        VolumeLiquids = self.VolumeLiquids\n#        Psats = self.Psats()\n#        self._Vms_sat = [VolumeLiquids[i](T, Psats[i]) for i in range(self.N)]\n        self._Vms_sat = [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n        return self._Vms_sat\n\n    @staticmethod\n    def _dVms_sat_dT_at(T, Vms_sat_data, cmps):\n        Vms_sat_dT = []\n        Tmins, Tmaxes, dcoeffs = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[7]\n        for i in cmps:\n            if T < Tmins[i]:\n                dVm = horner_and_der2(Vms_sat_data[9][i], T)[1]\n            elif T > Tmaxes[i]:\n                dVm = Vms_sat_data[4][i]\n            else:\n                dVm = 0.0\n                for c in dcoeffs[i]:\n                    dVm = dVm*T + c\n            Vms_sat_dT.append(dVm)\n        return Vms_sat_dT\n\n    def dVms_sat_dT_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n        return [obj.T_dependent_property_derivative(T=T) for obj in self.VolumeLiquids]\n\n    def dVms_sat_dT(self):\n        try:\n            return self._Vms_sat_dT\n        except:\n            pass\n        T = self.T\n\n        if self.Vms_sat_poly_fit:\n#            self._Vms_sat_dT = evaluate_linear_fits_d(self._Vms_sat_data, T)\n            self._Vms_sat_dT = self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n            return self._Vms_sat_dT\n\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat_dT = Vms_sat_dT = [obj.T_dependent_property_derivative(T=T) for obj in VolumeLiquids]\n        return Vms_sat_dT\n\n    def d2Vms_sat_dT2(self):\n        try:\n            return self._d2Vms_sat_dT2\n        except:\n            pass\n\n        T = self.T\n\n        if self.Vms_sat_poly_fit:\n#            self._d2Vms_sat_dT2 = evaluate_linear_fits_d2(self._Vms_sat_data, T)\n#            return self._d2Vms_sat_dT2\n            d2Vms_sat_dT2 = self._d2Vms_sat_dT2 = []\n\n            Vms_sat_data = self._Vms_sat_data\n            Tmins, Tmaxes, d2coeffs = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[8]\n            for i in range(self.N):\n                d2Vm = 0.0\n                if Tmins[i] < T < Tmaxes[i]:\n                    for c in d2coeffs[i]:\n                        d2Vm = d2Vm*T + c\n                elif T < Tmins[i]:\n                    d2Vm = horner_and_der2(Vms_sat_data[9][i], T)[2]\n                d2Vms_sat_dT2.append(d2Vm)\n            return d2Vms_sat_dT2\n\n        VolumeLiquids = self.VolumeLiquids\n        self._d2Vms_sat_dT2 = [obj.T_dependent_property_derivative(T=T, order=2) for obj in VolumeLiquids]\n        return self._d2Vms_sat_dT2\n\n    def Vms_sat_T_ref(self):\n        try:\n            return self._Vms_sat_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_T_ref = evaluate_linear_fits(self._Vms_sat_data, T_REF_IG)\n        else:\n            VolumeLiquids, cmps = self.VolumeLiquids, range(self.N)\n            self._Vms_sat_T_ref = [VolumeLiquids[i].T_dependent_property(T_REF_IG) for i in cmps]\n        return self._Vms_sat_T_ref\n\n    def dVms_sat_dT_T_ref(self):\n        try:\n            return self._dVms_sat_dT_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._dVms_sat_dT_T_ref = evaluate_linear_fits_d(self._Vms_sat_data, self.T)\n        else:\n            VolumeLiquids, cmps = self.VolumeLiquids, range(self.N)\n            self._dVms_sat_dT_T_ref = [VolumeLiquids[i].T_dependent_property_derivative(T_REF_IG) for i in cmps]\n        return self._dVms_sat_dT_T_ref\n\n    def Vms(self):\n        # Fill in tait/eos function to be called instead of Vms_sat\n        return self.Vms_sat()\n\n    def dVms_dT(self):\n        return self.dVms_sat_dT()\n\n    def d2Vms_dT2(self):\n        return self.d2Vms_sat_dT2()\n\n    def dVms_dP(self):\n        return [0.0]*self.N\n\n    def d2Vms_dP2(self):\n        return [0.0]*self.N\n\n    def d2Vms_dPdT(self):\n        return [0.0]*self.N\n\n    def Hvaps(self):\n        try:\n            return self._Hvaps\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = self.T, self.EnthalpyVaporizations, range(self.N)\n\n        self._Hvaps = Hvaps = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = Hvap_data[2], Hvap_data[3], Hvap_data[4]\n            for i in cmps:\n                Hvap = 0.0\n                if T < Tcs[i]:\n                    x = log(1.0 - T*Tcs_inv[i])\n                    for c in coeffs[i]:\n                        Hvap = Hvap*x + c\n    #                    Vm = horner(coeffs[i], log(1.0 - T*Tcs_inv[i])\n                Hvaps.append(Hvap)\n            return Hvaps\n\n        self._Hvaps = Hvaps = [EnthalpyVaporizations[i](T) for i in cmps]\n        for i in cmps:\n            if Hvaps[i] is None:\n                Hvaps[i] = 0.0\n        return Hvaps\n\n    def dHvaps_dT(self):\n        try:\n            return self._dHvaps_dT\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = self.T, self.EnthalpyVaporizations, range(self.N)\n\n        self._dHvaps_dT = dHvaps_dT = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = Hvap_data[2], Hvap_data[3], Hvap_data[4]\n            for i in cmps:\n                dHvap_dT = 0.0\n                if T < Tcs[i]:\n                    p = log((Tcs[i] - T)*Tcs_inv[i])\n                    x = 1.0\n                    a = 1.0\n                    for c in coeffs[i][-2::-1]:\n                        dHvap_dT += a*c*x\n                        x *= p\n                        a += 1.0\n                    dHvap_dT /= T - Tcs[i]\n\n                dHvaps_dT.append(dHvap_dT)\n            return dHvaps_dT\n\n        self._dHvaps_dT = dHvaps_dT = [EnthalpyVaporizations[i].T_dependent_property_derivative(T) for i in cmps]\n        for i in cmps:\n            if dHvaps_dT[i] is None:\n                dHvaps_dT[i] = 0.0\n        return dHvaps_dT\n\n    def Hvaps_T_ref(self):\n        try:\n            return self._Hvaps_T_ref\n        except AttributeError:\n            pass\n        EnthalpyVaporizations, cmps = self.EnthalpyVaporizations, range(self.N)\n        T_REF_IG = self.T_REF_IG\n        self._Hvaps_T_ref = [EnthalpyVaporizations[i](T_REF_IG) for i in cmps]\n        return self._Hvaps_T_ref\n\n    def Poyntings_at(self, T, P, Psats=None, Vms=None):\n        if not self.use_Poynting:\n            return [1.0]*self.N\n\n        cmps = range(self.N)\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        RT_inv = 1.0/(R*T)\n        return [exp(Vms[i]*(P-Psats[i])*RT_inv) for i in cmps]\n\n    def Poyntings(self):\n        r'''Method to calculate and return the Poynting pressure correction\n        factors of the phase, [-].\n\n        .. math::\n            \\text{Poynting}_i = \\exp\\left(\\frac{V_{m,i}(P-P_{sat})}{RT}\\right)\n\n        Returns\n        -------\n        Poyntings : list[float]\n            Poynting pressure correction factors, [-]\n\n        Notes\n        -----\n        The above formula is correct for pressure-independent molar volumes.\n        When the volume does depend on pressure, the full expression is:\n\n        .. math::\n            \\text{Poynting} = \\exp\\left[\\frac{\\int_{P_i^{sat}}^P V_i^l dP}{RT}\\right]\n\n        When a specified model e.g. the Tait equation is used, an analytical\n        integral of this term is normally available.\n\n        '''\n        try:\n            return self._Poyntings\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._Poyntings = [1.0]*self.N\n            return self._Poyntings\n\n        T, P = self.T, self.P\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        RT_inv = 1.0/(R*T)\n        self._Poyntings = [trunc_exp(Vml*(P-Psat)*RT_inv) for Psat, Vml in zip(Psats, Vms_sat)]\n        return self._Poyntings\n\n\n    def dPoyntings_dT(self):\n        try:\n            return self._dPoyntings_dT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dT = [0.0]*self.N\n            return self._dPoyntings_dT\n\n        T, P = self.T, self.P\n\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n\n        x0 = 1.0/R\n        x1 = 1.0/T\n        RT_inv = x0*x1\n\n        self._dPoyntings_dT = dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = Psats[i]\n\n            x4 = P - x3\n            x5 = x1*x2*x4\n            dPoyntings_dTi = -RT_inv*(x2*dPsats_dT[i] - x4*dVms_sat_dT[i] + x5)*trunc_exp(x0*x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def dPoyntings_dT_at(self, T, P, Psats=None, Vms=None, dPsats_dT=None, dVms_sat_dT=None):\n        if not self.use_Poynting:\n            return [0.0]*self.N\n\n        if Psats is None:\n            Psats = self.Psats_at(T)\n\n        if dPsats_dT is None:\n            dPsats_dT = self.dPsats_dT_at(T, Psats)\n\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n\n        if dVms_sat_dT is None:\n            dVms_sat_dT = self.dVms_sat_dT_at(T)\n        x0 = 1.0/R\n        x1 = 1.0/T\n        dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x4 = P - Psats[i]\n            x5 = x1*x2*x4\n            dPoyntings_dTi = -x0*x1*(x2*dPsats_dT[i] - x4*dVms_sat_dT[i] + x5)*exp(x0*x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def d2Poyntings_dT2(self):\n        try:\n            return self._d2Poyntings_dT2\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dT2 = [0.0]*self.N\n            return self._d2Poyntings_dT2\n\n        T, P = self.T, self.P\n\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        d2Psats_dT2 = self.d2Psats_dT2()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n\n        x6 = 1.0/T\n        x7 = x6 + x6\n        x11 = 1.0/R\n        x12 = x11*x6\n        c0 = 2.0*x6*x6\n\n        self._d2Poyntings_dT2 = d2Poyntings_dT2 = []\n        \"\"\"\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        cse(diff(Poy, T, 2), optimizations='basic')\n        \"\"\"\n        for i in range(self.N):\n            x0 = Vms[i]\n            x1 = Psats[i]\n            x2 = P - x1\n            x3 = x0*x2\n            x4 = dPsats_dT[i]\n            x5 = x0*x4\n            x8 = dVms_sat_dT[i]\n            x9 = x2*x8\n            x10 = x3*x6\n            x50 = (x10 + x5 - x9)\n            d2Poyntings_dT2i = (x12*(-x0*d2Psats_dT2[i] + x12*x50*x50\n                                    + x2*d2Vms_sat_dT2[i] - 2.0*x4*x8 + x5*x7\n                                    - x7*x9 + x3*c0)*exp(x10*x11))\n            d2Poyntings_dT2.append(d2Poyntings_dT2i)\n        return d2Poyntings_dT2\n\n    def dPoyntings_dP(self):\n        '''from sympy import *\n        R, T, P, zi = symbols('R, T, P, zi')\n        Vml = symbols('Vml', cls=Function)\n        cse(diff(exp(Vml(T)*(P - Psati(T))/(R*T)), P), optimizations='basic')\n        '''\n        try:\n            return self._dPoyntings_dP\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dP = [0.0]*self.N\n            return self._dPoyntings_dP\n        T, P = self.T, self.P\n        Psats = self.Psats()\n\n        Vms = self.Vms_sat()\n\n        self._dPoyntings_dP = dPoyntings_dPs = []\n        for i in range(self.N):\n            x0 = Vms[i]/(R*T)\n            dPoyntings_dPs.append(x0*exp(x0*(P - Psats[i])))\n        return dPoyntings_dPs\n\n    def d2Poyntings_dPdT(self):\n        '''\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        Poyf = symbols('Poyf')\n        cse(diff(Poy, T, P).subs(Poy, Poyf), optimizations='basic')\n        '''\n        try:\n            return self._d2Poyntings_dPdT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dPdT = [0.0]*self.N\n            return self._d2Poyntings_dPdT\n\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms = self._Vms_sat\n        except AttributeError:\n            Vms = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._dVms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        x0 = R_inv\n        x1 = 1.0/self.T\n        P = self.P\n        nRT_inv = -x0*x1\n        self._d2Poyntings_dPdT = d2Poyntings_dPdT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = x1*x2\n            x4 = dVms_sat_dT[i]\n            x5 = Psats[i]\n            x6 = P - x5\n            v = Poyntings[i]*nRT_inv*(x0*x3*(x2*dPsats_dT[i] + x3*x6 - x4*x6) + x3 - x4)\n            d2Poyntings_dPdT.append(v)\n        return d2Poyntings_dPdT\n\n\n    d2Poyntings_dTdP = d2Poyntings_dPdT\n\n    def phis_sat_at(self, T):\n        if not self.use_phis_sat:\n            return [1.0]*self.N\n        phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def phis_sat(self):\n        r'''Method to calculate and return the saturation fugacity coefficient\n        correction factors of the phase, [-].\n\n        These are calculated from the\n        provided pure-component equations of state. This term should only be\n        used with a consistent vapor-phase cubic equation of state.\n\n        Returns\n        -------\n        phis_sat : list[float]\n            Saturation fugacity coefficient correction factors, [-]\n\n        Notes\n        -----\n        .. warning::\n            This factor cannot be calculated when a compound is supercritical,\n            as there is no longer any vapor-liquid pure-component equilibrium\n            (by definition).\n\n        '''\n        try:\n            return self._phis_sat\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._phis_sat = [1.0]*self.N\n            return self._phis_sat\n\n        T = self.T\n        self._phis_sat = phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n\n\n\n    def dphis_sat_dT_at(self, T):\n        if not self.use_phis_sat:\n            return [0.0]*self.N\n        dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def dphis_sat_dT(self):\n        try:\n            return self._dphis_sat_dT\n        except AttributeError:\n            pass\n\n        if not self.use_phis_sat:\n            self._dphis_sat_dT = [0.0]*self.N\n            return self._dphis_sat_dT\n\n        T = self.T\n        self._dphis_sat_dT = dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def d2phis_sat_dT2(self):\n        # Numerically implemented\n        try:\n            return self._d2phis_sat_dT2\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._d2phis_sat_dT2 = [0.0]*self.N\n            return self._d2phis_sat_dT2\n\n        T = self.T\n        self._d2phis_sat_dT2 = d2phis_sat_dT2 = []\n        for i in self.eos_pure_instances:\n            try:\n                d2phis_sat_dT2.append(i.d2phi_sat_dT2(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    d2phis_sat_dT2.append(0.0)\n                else:\n                    raise e\n        return d2phis_sat_dT2\n\n\n    def phis_at(self, T, P, zs, Psats=None, gammas=None, phis_sat=None, Poyntings=None):\n        P_inv = 1.0/P\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if gammas is None:\n            gammas = self.gammas_at(T, zs)\n        if phis_sat is None:\n            phis_sat = self.phis_sat_at(T)\n        if Poyntings is None:\n            Poyntings = self.Poyntings_at(T, P, Psats=Psats)\n        return [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv\n                for i in range(self.N)]\n\n    def phis(self):\n        r'''Method to calculate the fugacity coefficients of the\n        GibbsExcessLiquid phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat} \\text{Poynting}_i}\n            {P}\n\n        Returns\n        -------\n        phis : list[float]\n            Fugacity coefficients of all components in the phase, [-]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1.\n        '''\n        try:\n            return self._phis\n        except AttributeError:\n            pass\n        P = self.P\n        try:\n            gammas = self._gammas\n        except AttributeError:\n            gammas = self.gammas()\n\n\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n\n        try:\n            phis_sat = self._phis_sat\n        except AttributeError:\n            phis_sat = self.phis_sat()\n\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        P_inv = 1.0/P\n        self._phis = [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv\n                for i in range(self.N)]\n        return self._phis\n\n\n    def lnphis(self):\n        try:\n            return self._lnphis\n        except AttributeError:\n            pass\n        try:\n            self._lnphis = [log(i) for i in self.phis()]\n        except:\n            # Zero Psats - must compute them inline\n            P = self.P\n            try:\n                gammas = self._gammas\n            except AttributeError:\n                gammas = self.gammas()\n            try:\n                lnPsats = self._lnPsats\n            except AttributeError:\n                lnPsats = self.lnPsats()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n            P_inv = 1.0/P\n            self._lnphis = [log(gammas[i]*Poyntings[i]*phis_sat[i]*P_inv) + lnPsats[i]\n                    for i in range(self.N)]\n\n        return self._lnphis\n\n    lnphis_G_min = lnphis\n    lnphis_lowest_Gibbs = lnphis\n\n#    def fugacities(self, T, P, zs):\n#        # DO NOT EDIT _ CORRECT\n#        gammas = self.gammas(T, zs)\n#        Psats = self._Psats(T=T)\n#        if self.use_phis_sat:\n#            phis = self.phis(T=T, zs=zs)\n#        else:\n#            phis = [1.0]*self.N\n#\n#        if self.use_Poynting:\n#            Poyntings = self.Poyntings(T=T, P=P, Psats=Psats)\n#        else:\n#            Poyntings = [1.0]*self.N\n#        return [zs[i]*gammas[i]*Psats[i]*Poyntings[i]*phis[i]\n#                for i in range(self.N)]\n#\n#    def dphis_dxs(self):\n#        if\n    def dphis_dT(self):\n        try:\n            return self._dphis_dT\n        except AttributeError:\n            pass\n        P = self.P\n        Psats = self.Psats()\n        gammas = self.gammas()\n\n        if self.use_Poynting:\n            # Evidence suggests poynting derivatives are not worth calculating\n            dPoyntings_dT = self.dPoyntings_dT() #[0.0]*self.N\n            Poyntings = self.Poyntings()\n        else:\n            dPoyntings_dT = [0.0]*self.N\n            Poyntings = [1.0]*self.N\n\n        dPsats_dT = self.dPsats_dT()\n\n        dgammas_dT = self.GibbsExcessModel.dgammas_dT()\n\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT()\n            phis_sat = self.phis_sat()\n        else:\n            dphis_sat_dT = [0.0]*self.N\n            phis_sat = [1.0]*self.N\n\n#        print(gammas, phis_sat, Psats, Poyntings, dgammas_dT, dPoyntings_dT, dPsats_dT)\n        self._dphis_dT = dphis_dTl = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2*x3\n            x5 = x0*x1\n            v = (x0*x4*dphis_sat_dT[i] + x1*x4*dgammas_dT[i] + x2*x5*dPoyntings_dT[i] + x3*x5*dPsats_dT[i])/P\n            dphis_dTl.append(v)\n        return dphis_dTl\n\n    def dphis_dT_at(self, T, P, zs, phis_also=False):\n        Psats = self.Psats_at(T)\n        dPsats_dT = self.dPsats_dT_at(T, Psats)\n        Vms = self.Vms_sat_at(T)\n        dVms_sat_dT = self.dVms_sat_dT_at(T)\n\n        gammas = self.gammas_at(T, zs)\n        dgammas_dT = self.dgammas_dT_at(T, zs)\n\n        if self.use_Poynting:\n            Poyntings = self.Poyntings_at(T, P, Psats, Vms)\n            dPoyntings_dT = self.dPoyntings_dT_at(T, P, Psats=Psats, Vms=Vms, dPsats_dT=dPsats_dT, dVms_sat_dT=dVms_sat_dT)\n        else:\n            Poyntings = [1.0]*self.N\n            dPoyntings_dT = [0.0]*self.N\n\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT_at(T)\n            phis_sat = self.phis_sat_at(T)\n        else:\n            dphis_sat_dT = [0.0]*self.N\n            phis_sat = [1.0]*self.N\n\n\n        dphis_dT = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2*x3\n            x5 = x0*x1\n            v = (x0*x4*dphis_sat_dT[i] + x1*x4*dgammas_dT[i] + x2*x5*dPoyntings_dT[i] + x3*x5*dPsats_dT[i])/P\n            dphis_dT.append(v)\n        if phis_also:\n            P_inv = 1.0/P\n            phis = [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv for i in range(self.N)]\n            return dphis_dT, phis\n        return dphis_dT\n\n    def dlnphis_dT(self):\n        try:\n            return self._dlnphis_dT\n        except AttributeError:\n            pass\n        dphis_dT = self.dphis_dT()\n        phis = self.phis()\n        self._dlnphis_dT = [i/j for i, j in zip(dphis_dT, phis)]\n        return self._dlnphis_dT\n\n    def dlnphis_dP(self):\n        r'''Method to calculate the pressure derivative of log fugacity\n        coefficients of the phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\frac{\\partial \\ln \\phi_i}{\\partial P} =\n            \\frac{\\frac{\\partial \\text{Poynting}_i}{\\partial P}}\n            {\\text{Poynting}_i} - \\frac{1}{P}\n\n        Returns\n        -------\n        dlnphis_dP : list[float]\n            Pressure derivative of log fugacity coefficients of all components\n            in the phase, [1/Pa]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1. For\n        that case, :math:`\\frac{\\partial \\ln \\phi_i}{\\partial P}=\\frac{1}{P}`.\n        '''\n        try:\n            return self._dlnphis_dP\n        except AttributeError:\n            pass\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        try:\n            dPoyntings_dP = self._dPoyntings_dP\n        except AttributeError:\n            dPoyntings_dP = self.dPoyntings_dP()\n\n        P_inv = 1.0/self.P\n\n        self._dlnphis_dP = [dPoyntings_dP[i]/Poyntings[i] - P_inv for i in range(self.N)]\n        return self._dlnphis_dP\n\n    def gammas_at(self, T, zs):\n        if self.composition_independent:\n            return [1.0]*self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).gammas()\n\n    def dgammas_dT_at(self, T, zs):\n        if self.composition_independent:\n            return [0.0]*self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).dgammas_dT()\n\n    def gammas(self):\n        r'''Method to calculate and return the activity coefficients of the\n        phase, [-]. This is a direct call to\n        :obj:`GibbsExcess.gammas <thermo.activity.GibbsExcess.gammas>`.\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n        '''\n        try:\n            return self.GibbsExcessModel._gammas\n        except AttributeError:\n            return self.GibbsExcessModel.gammas()\n\n    def dgammas_dT(self):\n        r'''Method to calculate and return the temperature derivative of\n        activity coefficients of the phase, [-].\n\n        This is a direct call to\n        :obj:`GibbsExcess.dgammas_dT <thermo.activity.GibbsExcess.dgammas_dT>`.\n\n        Returns\n        -------\n        dgammas_dT : list[float]\n            First temperature derivative of the activity coefficients, [1/K]\n        '''\n        return self.GibbsExcessModel.dgammas_dT()\n\n    def H_old(self):\n#        try:\n#            return self._H\n#        except AttributeError:\n#            pass\n        # Untested\n        T = self.T\n        RT = R*T\n        P = self.P\n        zs, cmps = self.zs, range(self.N)\n        T_REF_IG = self.T_REF_IG\n        P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n\n        H = 0.0\n\n        if P_DEPENDENT_H_LIQ:\n            # Page 650  Chemical Thermodynamics for Process Simulation\n            # Confirmed with CoolProp via analytical integrals\n            # Not actually checked numerically until Hvap is implemented though\n            \"\"\"\n            from scipy.integrate import *\n            from CoolProp.CoolProp import PropsSI\n\n            fluid = 'decane'\n            T = 400\n            Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n            P2 = Psat*100\n            dP = P2 - Psat\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n            Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n            dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n\n            def to_int(P):\n                Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n                alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n                return Vm -alpha*T*Vm\n            quad(to_int, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dH\n            \"\"\"\n\n            if self.use_IG_Cp:\n                try:\n                    Psats = self._Psats\n                except AttributeError:\n                    Psats = self.Psats()\n                try:\n                    dPsats_dT = self._dPsats_dT\n                except AttributeError:\n                    dPsats_dT = self.dPsats_dT()\n                try:\n                    Vms_sat = self._Vms_sat\n                except AttributeError:\n                    Vms_sat = self.Vms_sat()\n                try:\n                    dVms_sat_dT = self._Vms_sat_dT\n                except AttributeError:\n                    dVms_sat_dT = self.dVms_sat_dT()\n\n                failed_dPsat_dT = False\n                try:\n                    H = 0.0\n                    for i in cmps:\n                        dV_vap = R*T/Psats[i] - Vms_sat[i]\n    #                    print( R*T/Psats[i] , Vms_sat[i])\n                        # ratio of der to value might be easier?\n                        dS_vap = dPsats_dT[i]*dV_vap\n    #                    print(dPsats_dT[i]*dV_vap)\n                        Hvap = T*dS_vap\n                        H += zs[i]*(Cpig_integrals_pure[i] - Hvap)\n                except ZeroDivisionError:\n                    failed_dPsat_dT = True\n\n                if failed_dPsat_dT or isinf(H):\n                    # Handle the case where vapor pressure reaches zero - needs special implementations\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    H = 0.0\n                    for i in cmps:\n#                        dV_vap = R*T/Psats[i] - Vms_sat[i]\n#                        dS_vap = dPsats_dT[i]*dV_vap\n                        Hvap = T*dPsats_dT_over_Psats[i]*RT\n                        H += zs[i]*(Cpig_integrals_pure[i] - Hvap)\n\n                if self.use_Tait:\n                    dH_dP_integrals_Tait = self.dH_dP_integrals_Tait()\n                    for i in cmps:\n                        H += zs[i]*dH_dP_integrals_Tait[i]\n                elif self.use_Poynting:\n                    for i in cmps:\n                        # This bit is the differential with respect to pressure\n#                        dP = max(0.0, P - Psats[i]) # Breaks thermodynamic consistency\n                        dP = P - Psats[i]\n                        H += zs[i]*dP*(Vms_sat[i] - T*dVms_sat_dT[i])\n            else:\n                Psats = self.Psats()\n                Vms_sat = self.Vms_sat()\n                dVms_sat_dT = self.dVms_sat_dT()\n                dPsats_dT = self.dPsats_dT()\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Cpl_integrals_pure = self._Cpl_integrals_pure()\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                Vms_sat_T_ref = self.Vms_sat_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n\n                Hvaps = self.Hvaps()\n\n                H = 0.0\n                for i in range(self.N):\n                    H += zs[i]*(Cpl_integrals_pure[i] - Hvaps_T_ref[i])\n                    # If we can use the liquid heat capacity and prove its consistency\n\n                    # This bit is the differential with respect to pressure\n                    dP = P - Psats_T_ref[i]\n                    H += zs[i]*dP*(Vms_sat_T_ref[i] - T_REF_IG*dVms_sat_dT_T_ref[i])\n        else:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i]*(Cpig_integrals_pure[i] - Hvaps[i])\n        H += self.GibbsExcessModel.HE()\n#        self._H = H\n        return H\n    del H_old\n\n    def H(self):\n        r'''Method to calculate the enthalpy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n             \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i\\left[-H_{vap,i}\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        Returns\n        -------\n        H : float\n            Enthalpy of the phase, [J/(mol)]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._H\n        except AttributeError:\n            pass\n        H = 0.0\n        T = self.T\n        nRT2 = -R*T*T\n        zs, cmps = self.zs, range(self.N)\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n\n        if self.use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i]*(Cpig_integrals_pure[i] - Hvaps[i])\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + Cpig_integrals_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dPsats_dT_over_Psats[i] + dphis_sat_dT[i]/phis_sat[i]) + Cpig_integrals_pure[i])\n            else:\n                for i in cmps:\n                    H += zs[i]*(nRT2*dPsats_dT_over_Psats[i] + Cpig_integrals_pure[i])\n\n        if not self.composition_independent:\n            H += self.GibbsExcessModel.HE()\n        self._H = H\n        return H\n\n    def S_old(self):\n#        try:\n#            return self._S\n#        except AttributeError:\n#            pass\n        # Untested\n        # Page 650  Chemical Thermodynamics for Process Simulation\n        '''\n        from scipy.integrate import *\n        from CoolProp.CoolProp import PropsSI\n\n        fluid = 'decane'\n        T = 400\n        Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n        P2 = Psat*100\n        dP = P2 - Psat\n        Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n        Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n        dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n        dS = PropsSI('SMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('SMOLAR', 'T', T, 'Q', 0, fluid)\n        def to_int2(P):\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n            alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n            return -alpha*Vm\n        quad(to_int2, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dS\n        '''\n        S = 0.0\n        T, P, zs, cmps = self.T, self.P, self.zs, range(self.N)\n        log_zs = self.log_zs()\n        for i in cmps:\n            S -= zs[i]*log_zs[i]\n        S *= R\n        S_base = S\n\n        T_inv = 1.0/T\n        RT = R*T\n\n        P_REF_IG_INV = self.P_REF_IG_INV\n\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._Vms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n\n        if self.P_DEPENDENT_H_LIQ:\n            if self.use_IG_Cp:\n                failed_dPsat_dT = False\n                try:\n                    for i in range(self.N):\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dVsat = R*T/Psats[i] - Vms_sat[i]\n                        dSvap = dPsats_dT[i]*dVsat\n        #                dSvap = Hvaps[i]/T # Confirmed - this line breaks everything - do not use\n                        dSi -= dSvap\n        #                dSi = Cpig_integrals_over_T_pure[i] - Hvaps[i]*T_inv # Do the transition at the temperature of the liquid\n                        # Take each component to its reference state change - saturation pressure\n        #                dSi -= R*log(P*P_REF_IG_INV)\n                        dSi -= R*log(Psats[i]*P_REF_IG_INV)\n        #                dSi -= R*log(P/101325.0)\n                        # Only include the\n                        dP = P - Psats[i]\n    #                    dP = max(0.0, P - Psats[i])\n        #                if dP > 0.0:\n                        # I believe should include effect of pressure on all components, regardless of phase\n                        dSi -= dP*dVms_sat_dT[i]\n                        S += dSi*zs[i]\n                except (ZeroDivisionError, ValueError):\n                    # Handle the zero division on Psat or the log getting two small\n                    failed_dPsat_dT = True\n\n                if failed_dPsat_dT or isinf(S):\n                    S = S_base\n                    # Handle the case where vapor pressure reaches zero - needs special implementations\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    lnPsats = self.lnPsats()\n                    LOG_P_REF_IG = self.LOG_P_REF_IG\n                    for i in cmps:\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dSvap = RT*dPsats_dT_over_Psats[i]\n                        dSi -= dSvap\n                        dSi -= R*(lnPsats[i] - LOG_P_REF_IG)#   trunc_log(Psats[i]*P_REF_IG_INV)\n                        dSi -= P*dVms_sat_dT[i]\n                        S += dSi*zs[i]\n\n                if self.use_Tait:\n                    pass\n                elif self.use_Poynting:\n                    pass\n#                for i in cmps:\n\n            else:\n                # mine\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n                T_REF_IG_INV = self.T_REF_IG_INV\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                # Vms_sat_T_ref = self.Vms_sat_T_ref()\n\n                for i in range(self.N):\n                    dSi = Cpl_integrals_over_T_pure[i]\n                    dSi -= Hvaps_T_ref[i]*T_REF_IG_INV\n                    # Take each component to its reference state change - saturation pressure\n                    dSi -= R*log(Psats_T_ref[i]*P_REF_IG_INV)\n                    # I believe should include effect of pressure on all components, regardless of phase\n\n\n                    dP = P - Psats_T_ref[i]\n                    dSi -= dP*dVms_sat_dT_T_ref[i]\n                    S += dSi*zs[i]\n#                else:\n#                    # COCO\n#                    Hvaps = self.Hvaps()\n#                    Psats_T_ref = self.Psats_T_ref()\n#                    _Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n#                    T_REF_IG_INV = self.T_REF_IG_INV\n#\n#                    for i in range(self.N):\n#                        dSi = -_Cpl_integrals_over_T_pure[i]\n#                        dSi -= Hvaps[i]/T\n#                        # Take each component to its reference state change - saturation pressure\n#                        dSi -= R*log(Psats[i]*P_REF_IG_INV)\n#\n#                        dP = P - Psats[i]\n#                        # I believe should include effect of pressure on all components, regardless of phase\n#                        dSi -= dP*dVms_sat_dT[i]\n#                        S += dSi*zs[i]\n        else:\n            Hvaps = self.Hvaps()\n            for i in cmps:\n                Sg298_to_T = Cpig_integrals_over_T_pure[i]\n                Svap = -Hvaps[i]*T_inv # Do the transition at the temperature of the liquid\n                S += zs[i]*(Sg298_to_T + Svap - R*log(P*P_REF_IG_INV))\n#        self._S =\n        S = S + self.GibbsExcessModel.SE()\n        return S\n\n    def S(self):\n        r'''Method to calculate the entropy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}\\cdot\\phi_{\\text{sat},i}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\phi_{\\text{sat},i}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{1}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\\ln P_{\\text{sat},i} + \\ln\\left(\\frac{1}{P}\\right)\\right)\n            + \\frac{H_{vap,i}}{T}\n            - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        Returns\n        -------\n        S : float\n            Entropy of the phase, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._S\n        except AttributeError:\n            pass\n        T, P = self.T, self.P\n        P_inv = 1.0/P\n        zs, cmps = self.zs, range(self.N)\n\n        log_zs = self.log_zs()\n        S_comp = 0.0\n        for i in cmps:\n            S_comp -= zs[i]*log_zs[i]\n        S = S_comp - log(P*self.P_REF_IG_INV)\n        S *= R\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n\n        try:\n            lnPsats = self._lnPsats\n        except AttributeError:\n            lnPsats = self.lnPsats()\n\n        use_Poynting, use_phis_sat, use_Hvap_caloric = self.use_Poynting, self.use_phis_sat, self.use_Hvap_caloric\n\n        if use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            T_inv = 1.0/T\n            logP_inv = log(P_inv)\n            # Almost the same as no Poynting\n            for i in cmps:\n                S -= zs[i]*(R*(lnPsats[i] + logP_inv)\n                            - Cpig_integrals_over_T_pure[i] + Hvaps[i]*T_inv)\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + lnPsats[i] + log(Poyntings[i]*phis_sat[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + lnPsats[i] + log(Poyntings[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i])\n                                + lnPsats[i] + log(phis_sat[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            else:\n                logP_inv = log(P_inv)\n                for i in cmps:\n                    S -= zs[i]*(R*(T*dPsats_dT_over_Psats[i] + lnPsats[i] + logP_inv)\n                                - Cpig_integrals_over_T_pure[i])\n\n        if not self.composition_independent:\n            S += self.GibbsExcessModel.SE()\n        self._S = S\n        return S\n\n    def Cp_old(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        # Needs testing\n        T, P, P_DEPENDENT_H_LIQ = self.T, self.P, self.P_DEPENDENT_H_LIQ\n        Cp, zs = 0.0, self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        if P_DEPENDENT_H_LIQ:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            try:\n                dPsats_dT = self._dPsats_dT\n            except AttributeError:\n                dPsats_dT = self.dPsats_dT()\n            try:\n                d2Psats_dT2 = self._d2Psats_dT2\n            except AttributeError:\n                d2Psats_dT2 = self.d2Psats_dT2()\n            try:\n                Vms_sat = self._Vms_sat\n            except AttributeError:\n                Vms_sat = self.Vms_sat()\n            try:\n                dVms_sat_dT = self._Vms_sat_dT\n            except AttributeError:\n                dVms_sat_dT = self.dVms_sat_dT()\n            try:\n                d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n            except AttributeError:\n                d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n\n            failed_dPsat_dT = False\n            try:\n                for i in range(self.N):\n                    x0 = Psats[i]\n                    Psat_inv = 1.0/x0\n                    x1 = Vms_sat[i]\n                    x2 = dPsats_dT[i]\n                    x3 = R*Psat_inv\n                    x4 = T*x3\n                    x5 = -x1\n                    x6 = dVms_sat_dT[i]\n                    x7 = T*x2\n    #                print(#-T*(P - x0)*d2Vms_sat_dT2[i],\n    #                       - T*(x4 + x5)*d2Psats_dT2[i], T, x4, x5, d2Psats_dT2[i],\n                           #x2*(x1 - x4) + x2*(T*x6 + x5) - x7*(-R*x7*Psat_inv*Psat_inv + x3 - x6),\n                           #Cpigs_pure[i]\n    #                       )\n                    Cp += zs[i]*(-T*(P - x0)*d2Vms_sat_dT2[i] - T*(x4 + x5)*d2Psats_dT2[i]\n                    + x2*(x1 - x4) + x2*(T*x6 + x5) - x7*(-R*x7*Psat_inv*Psat_inv + x3 - x6) + Cpigs_pure[i])\n                    # The second derivative of volume is zero when extrapolating, which causes zero issues, discontinuous derivative\n                \"\"\"\n                from sympy import *\n                T, P, R, zi = symbols('T, P, R, zi')\n                Psat, Cpig_int, Vmsat = symbols('Psat, Cpig_int, Vmsat', cls=Function)\n                dVmsatdT = diff(Vmsat(T), T)\n                dPsatdT = diff(Psat(T), T)\n                dV_vap = R*T/Psat(T) - Vmsat(T)\n                dS_vap = dPsatdT*dV_vap\n                Hvap = T*dS_vap\n                H = zi*(Cpig_int(T) - Hvap)\n\n                dP = P - Psat(T)\n                H += zi*dP*(Vmsat(T) - T*dVmsatdT)\n\n                (cse(diff(H, T), optimizations='basic'))\n                \"\"\"\n            except (ZeroDivisionError, ValueError):\n                # Handle the zero division on Psat or the log getting two small\n                failed_dPsat_dT = True\n\n            if failed_dPsat_dT or isinf(Cp) or isnan(Cp):\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                Cp = 0.0\n                for i in range(self.N):\n                    Cp += zs[i]*(Cpigs_pure[i] - P*T*d2Vms_sat_dT2[i] - R*T*T*d2lnPsats_dT2[i]\n                    - 2.0*R*T*dlnPsats_dT[i])\n                    \"\"\"\n                    from sympy import *\n                    T, P, R, zi = symbols('T, P, R, zi')\n                    lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\n                    dVmsatdT = diff(Vmsat(T), T)\n                    dPsatdT = diff(exp(lnPsat(T)), T)\n                    dV_vap = R*T/exp(lnPsat(T)) - Vmsat(T)\n                    dS_vap = dPsatdT*dV_vap\n                    Hvap = T*dS_vap\n                    H = zi*(Cpig_int(T) - Hvap)\n                    dP = P\n                    H += zi*dP*(Vmsat(T) - T*dVmsatdT)\n                    print(simplify(expand(diff(H, T)).subs(exp(lnPsat(T)), 0)/zi))\n                    \"\"\"\n#                Cp += zs[i]*(Cpigs_pure[i] - dHvaps_dT[i])\n#                Cp += zs[i]*(-T*(P - Psats[i])*d2Vms_sat_dT2[i] + (T*dVms_sat_dT[i] - Vms_sat[i])*dPsats_dT[i])\n\n        else:\n            dHvaps_dT = self.dHvaps_dT()\n            for i in range(self.N):\n                Cp += zs[i]*(Cpigs_pure[i] - dHvaps_dT[i])\n\n        Cp += self.GibbsExcessModel.CpE()\n        return Cp\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, zs, cmps = self.T, self.zs, range(self.N)\n        Cpigs_pure = self.Cpigs_pure()\n        use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n\n        RT = R*T\n        RT2 = RT*T\n        RT2_2 = RT + RT\n\n        Cp = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                phi_inv = 1.0/phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0/phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        else:\n            for i in cmps:\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dPsats_dT_over_Psats[i]\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        if not self.composition_independent:\n            Cp += self.GibbsExcessModel.CpE()\n        self._Cp = Cp\n        return Cp\n\n    dH_dT = Cp\n\n    def dS_dT_old(self):\n        # Needs testing\n        T, P, P_DEPENDENT_H_LIQ = self.T, self.P, self.P_DEPENDENT_H_LIQ\n        RT = R*T\n        zs = self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        dS_dT = 0.0\n        T_inv = 1.0/T\n        if P_DEPENDENT_H_LIQ:\n            d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            dVms_sat_dT = self.dVms_sat_dT()\n            Vms_sat = self.Vms_sat()\n            Psats = self.Psats()\n            dPsats_dT = self.dPsats_dT()\n            d2Psats_dT2 = self.d2Psats_dT2()\n            failed_dPsat_dT = False\n            for Psat in Psats:\n                if Psat < 1e-40:\n                    failed_dPsat_dT = True\n            if not failed_dPsat_dT:\n                try:\n                    \"\"\"\n                    from sympy import *\n                    T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\n\n                    Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\n                    dVmsatdT = diff(Vmsat(T), T)\n                    dPsatdT = diff(Psat(T), T)\n\n                    S = 0\n                    dSi = Cpig_T_int(T)\n                    dVsat = R*T/Psat(T) - Vmsat(T)\n                    dSvap = dPsatdT*dVsat\n                    dSi -= dSvap\n                    dSi -= R*log(Psat(T)/P_REF_IG)\n                    dP = P - Psat(T)\n                    dSi -= dP*dVmsatdT\n                    S += dSi*zi\n                    # cse(diff(S, T), optimizations='basic')\n                    \"\"\"\n                    for i in range(self.N):\n                        x0 = Psats[i]\n                        x1 = dPsats_dT[i]\n                        x2 = R/x0\n                        x3 = Vms_sat[i]\n                        x4 = dVms_sat_dT[i]\n                        dS_dT -= zs[i]*(x1*x2 - x1*x4 - x1*(RT*x1/x0**2 - x2 + x4) + (P - x0)*d2Vms_sat_dT2[i]\n                        + (T*x2 - x3)*d2Psats_dT2[i] - Cpigs_pure[i]*T_inv)\n                except (ZeroDivisionError, ValueError):\n                    # Handle the zero division on Psat or the log getting two small\n                    failed_dPsat_dT = True\n\n            if failed_dPsat_dT:\n                # lnPsats = self.lnPsats()\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n#                P*Derivative(Vmsat(T), (T, 2))\n#                R*T*Derivative(lnPsat(T), (T, 2))\n#                 2*R*Derivative(lnPsat(T), T) + Derivative(Cpig_T_int(T), T)\n                \"\"\"\n                from sympy import *\n                T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\n\n                lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\n                # Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\n                dVmsatdT = diff(Vmsat(T), T)\n                dPsatdT = diff(exp(lnPsat(T)), T)\n\n                S = 0\n                dSi = Cpig_T_int(T)\n                dVsat = R*T/exp(lnPsat(T)) - Vmsat(T)\n                dSvap = dPsatdT*dVsat\n                dSi -= dSvap\n                # dSi -= R*log(Psat(T)/P_REF_IG)\n                dSi -= R*(lnPsat(T) - log(P_REF_IG))\n                dP = P - exp(lnPsat(T))\n                dSi -= dP*dVmsatdT\n                S += dSi*zi\n                # cse(diff(S, T), optimizations='basic')\n                print(simplify(expand(diff(S, T)).subs(exp(lnPsat(T)), 0)/zi))\n\n\n                \"\"\"\n                dS_dT = 0.0\n                for i in range(self.N):\n                    dS_dT -= zs[i]*(P*d2Vms_sat_dT2[i] + RT*d2lnPsats_dT2[i]\n                    + 2.0*R*dlnPsats_dT[i]- Cpigs_pure[i]*T_inv)\n\n        dS_dT += self.GibbsExcessModel.dSE_dT()\n        return dS_dT\n\n    def dS_dT(self):\n        try:\n            return self._dS_dT\n        except AttributeError:\n            pass\n        T, zs, cmps = self.T, self.zs, range(self.N)\n        use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        Cpigs_pure = self.Cpigs_pure()\n\n        T_inv = 1.0/T\n        RT = R*T\n        R_2 = R + R\n\n        dS_dT = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                phi_inv = 1.0/phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0/phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        else:\n            for i in cmps:\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        if not self.composition_independent:\n            dS_dT += self.GibbsExcessModel.dSE_dT()\n        self._dS_dT = dS_dT\n        return dS_dT\n\n    def dH_dP(self):\n        try:\n            return self._dH_dP\n        except AttributeError:\n            pass\n        T = self.T\n        zs = self.zs\n        dH_dP = 0.0\n        if self.use_Poynting:\n            nRT2 = -R*T*T\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0/Poyntings[i]\n                dH_dP += nRT2*zs[i]*Poy_inv*(d2Poyntings_dPdT[i] - dPoyntings_dP[i]*dPoyntings_dT[i]*Poy_inv)\n\n#        if self.P_DEPENDENT_H_LIQ:\n#            if self.use_IG_Cp:\n#                Vms_sat = self.Vms_sat()\n#                dVms_sat_dT = self.dVms_sat_dT()\n#                Psats = self.Psats()\n#                for i in range(self.N):\n#                    if P > Psats[i]:\n#                        dH_dP += zs[i]*(-T*dVms_sat_dT[i] + Vms_sat[i])\n        self._dH_dP = dH_dP\n        return dH_dP\n\n\n    def dS_dP(self):\n        try:\n            return self._dS_dP\n        except AttributeError:\n            pass\n        T = self.T\n        P = self.P\n        P_inv = 1.0/P\n        zs = self.zs\n        if self.use_Poynting:\n            dS_dP = -R*P_inv\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0/Poyntings[i]\n                dS_dP -= zs[i]*R*Poy_inv*(dPoyntings_dP[i] - Poyntings[i]*P_inv\n                        +T*(d2Poyntings_dPdT[i] - dPoyntings_dP[i]*dPoyntings_dT[i]*Poy_inv))\n        else:\n            dS_dP = 0.0\n#        if self.P_DEPENDENT_H_LIQ:\n#            if self.use_IG_Cp:\n#                dVms_sat_dT = self.dVms_sat_dT()\n#                Psats = self.Psats()\n#                for i in range(self.N):\n#                    if P > Psats[i]:\n#                        dS_dP -= zs[i]*(dVms_sat_dT[i])\n        self._dS_dP = dS_dP\n        return dS_dP\n\n    def H_dep(self):\n        return self.H() - self.H_ideal_gas()\n\n    def S_dep(self):\n        return self.S() - self.S_ideal_gas()\n\n    def Cp_dep(self):\n        return self.Cp() - self.Cp_ideal_gas()\n\n    ### Volumetric properties\n    def V(self):\n        try:\n            return self._V\n        except AttributeError:\n            pass\n        zs = self.zs\n        Vms = self.Vms()\n        \"\"\"To make a fugacity-volume identity consistent, cannot use pressure\n        correction unless the Poynting factor is calculated with quadrature/\n        integration.\n        \"\"\"\n        V = 0.0\n        for i in range(self.N):\n            V += zs[i]*Vms[i]\n        self._V = V\n        return V\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except AttributeError:\n            pass\n        zs = self.zs\n        dVms_sat_dT = self.dVms_sat_dT()\n        dV_dT = 0.0\n        for i in range(self.N):\n            dV_dT += zs[i]*dVms_sat_dT[i]\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def d2V_dT2(self):\n        try:\n            return self._d2V_dT2\n        except AttributeError:\n            pass\n        zs = self.zs\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        d2V_dT2 = 0.0\n        for i in range(self.N):\n            d2V_dT2 += zs[i]*d2Vms_sat_dT2[i]\n        self._d2V_dT2 = d2V_dT2\n        return d2V_dT2\n\n    # Main needed volume derivatives\n    def dP_dV(self):\n        try:\n            return self._dP_dV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._dP_dV = self.INCOMPRESSIBLE_CONST #1.0/self.VolumeLiquidMixture.property_derivative_P(self.T, self.P, self.zs, order=1)\n\n        return self._dP_dV\n\n    def d2P_dV2(self):\n        try:\n            return self._d2P_dV2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dV2 = self.INCOMPRESSIBLE_CONST #self.d2V_dP2()/-(self.dP_dV())**-3\n        return self._d2P_dV2\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except AttributeError:\n            pass\n        self._dP_dT = self.dV_dT()/-self.dP_dV()\n        return self._dP_dT\n\n    def d2P_dTdV(self):\n        try:\n            return self._d2P_dTdV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dTdV = 0.0\n        else:\n            P = self.P\n            def dP_dV_for_diff(T):\n                return 1.0/self.VolumeLiquidMixture.property_derivative_P(T, P, self.zs, order=1)\n\n            self._d2P_dTdV = derivative(dP_dV_for_diff, self.T)\n        return self._d2P_dTdV\n\n    def d2P_dT2(self):\n        try:\n            return self._d2P_dT2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dT2 = -self.d2V_dT2()/self.INCOMPRESSIBLE_CONST\n        else:\n            P, zs = self.P, self.zs\n            def dP_dT_for_diff(T):\n                dV_dT = self.VolumeLiquidMixture.property_derivative_T(T, P, zs, order=1)\n                dP_dV = 1.0/self.VolumeLiquidMixture.property_derivative_P(T, P, zs, order=1)\n                dP_dT = dV_dT/-dP_dV\n                return dP_dT\n\n            self._d2P_dT2 = derivative(dP_dT_for_diff, self.T)\n        return self._d2P_dT2\n\n    # Volume derivatives which needed to be implemented for the main ones\n    def d2V_dP2(self):\n        try:\n            return self._d2V_dP2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2V_dP2 = 0.0\n        return self._d2V_dP2\n\n    def Tait_Bs(self):\n        try:\n            return self._Tait_Bs\n        except:\n            pass\n\n        self._Tait_Bs = evaluate_linear_fits(self._Tait_B_data, self.T)\n        return self._Tait_Bs\n\n    def dTait_B_dTs(self):\n        try:\n            return self._dTait_B_dTs\n        except:\n            pass\n\n        self._dTait_B_dTs = evaluate_linear_fits_d(self._Tait_B_data, self.T)\n        return self._dTait_B_dTs\n\n    def d2Tait_B_dT2s(self):\n        try:\n            return self._d2Tait_B_dT2s\n        except:\n            pass\n\n        self._d2Tait_B_dT2s = evaluate_linear_fits_d2(self._Tait_B_data, self.T)\n        return self._d2Tait_B_dT2s\n\n    def Tait_Cs(self):\n        try:\n            return self._Tait_Cs\n        except:\n            pass\n\n        self._Tait_Cs = evaluate_linear_fits(self._Tait_C_data, self.T)\n        return self._Tait_Cs\n\n    def dTait_C_dTs(self):\n        try:\n            return self._dTait_C_dTs\n        except:\n            pass\n\n        self._dTait_C_dTs = evaluate_linear_fits_d(self._Tait_C_data, self.T)\n        return self._dTait_C_dTs\n\n    def d2Tait_C_dT2s(self):\n        try:\n            return self._d2Tait_C_dT2s\n        except:\n            pass\n\n        self._d2Tait_C_dT2s = evaluate_linear_fits_d2(self._Tait_C_data, self.T)\n        return self._d2Tait_C_dT2s\n\n    def Tait_Vs(self):\n        Vms_sat = self.Vms_sat()\n        Psats = self.Psats()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        P = self.P\n        return [Vms_sat[i]*(1.0  - Tait_Cs[i]*log((Tait_Bs[i] + P)/(Tait_Bs[i] + Psats[i]) ))\n                for i in range(self.N)]\n\n\n    def dH_dP_integrals_Tait(self):\n        try:\n            return self._dH_dP_integrals_Tait\n        except AttributeError:\n            pass\n        Psats = self.Psats()\n        Vms_sat = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        dPsats_dT = self.dPsats_dT()\n\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        dTait_C_dTs = self.dTait_C_dTs()\n        dTait_B_dTs = self.dTait_B_dTs()\n        T, P = self.T, self.P\n\n\n        self._dH_dP_integrals_Tait = dH_dP_integrals_Tait = []\n\n#        def to_int(P, i):\n#            l = self.to_TP_zs(T, P, zs)\n##            def to_diff(T):\n##                return self.to_TP_zs(T, P, zs).Tait_Vs()[i]\n##            dV_dT = derivative(to_diff, T, dx=1e-5*T, order=11)\n#\n#            x0 = l.Vms_sat()[i]\n#            x1 = l.Tait_Cs()[i]\n#            x2 = l.Tait_Bs()[i]\n#            x3 = P + x2\n#            x4 = l.Psats()[i]\n#            x5 = x3/(x2 + x4)\n#            x6 = log(x5)\n#            x7 = l.dTait_B_dTs()[i]\n#            dV_dT = (-x0*(x1*(-x5*(x7 +l.dPsats_dT()[i]) + x7)/x3\n#                                   + x6*l.dTait_C_dTs()[i])\n#                        - (x1*x6 - 1.0)*l.dVms_sat_dT()[i])\n#\n##            print(dV_dT, dV_dT2, dV_dT/dV_dT2, T, P)\n#\n#            V = l.Tait_Vs()[i]\n#            return V - T*dV_dT\n#        from scipy.integrate import quad\n#        _dH_dP_integrals_Tait = [quad(to_int, Psats[i], P, args=i)[0]\n#                                      for i in range(self.N)]\n##        return self._dH_dP_integrals_Tait\n#        print(_dH_dP_integrals_Tait)\n#        self._dH_dP_integrals_Tait2 = _dH_dP_integrals_Tait\n#        return self._dH_dP_integrals_Tait2\n\n#        dH_dP_integrals_Tait = []\n        for i in range(self.N):\n            # Very wrong according to numerical integration. Is it an issue with\n            # the translation to code, one of the derivatives, what was integrated,\n            # or sympy's integration?\n            x0 = Tait_Bs[i]\n            x1 = P + x0\n            x2 = Psats[i]\n            x3 = x0 + x2\n            x4 = 1.0/x3\n            x5 = Tait_Cs[i]\n            x6 = Vms_sat[i]\n            x7 = x5*x6\n            x8 = T*dVms_sat_dT[i]\n            x9 = x5*x8\n            x10 = T*dTait_C_dTs[i]\n            x11 = x0*x6\n            x12 = T*x7\n            x13 = -x0*x7 + x0*x9 + x10*x11 + x12*dTait_B_dTs[i]\n            x14 = x2*x6\n            x15 = x4*(x0*x8 + x10*x14 - x11 + x12*dPsats_dT[i] + x13 - x14 - x2*x7 + x2*x8 + x2*x9)\n            val = -P*x15 + P*(x10*x6 - x7 + x9)*log(x1*x4) + x13*log(x1) - x13*log(x3) + x15*x2\n            dH_dP_integrals_Tait.append(val)\n#        print(dH_dP_integrals_Tait, self._dH_dP_integrals_Tait2)\n        return dH_dP_integrals_Tait\n\n    def mu(self):\n        try:\n            return self._mu\n        except AttributeError:\n            pass\n        mu = self._mu = self.correlations.ViscosityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return mu\n\n    def k(self):\n        try:\n            return self._k\n        except AttributeError:\n            pass\n        self._k = k = self.correlations.ThermalConductivityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return k\n\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases','SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n\n\n    model_attributes = ('Hfs', 'Gfs', 'Sfs','GibbsExcessModel',\n                        'eos_pure_instances', 'use_Poynting', 'use_phis_sat',\n                        'use_eos_volume', 'henry_components',\n                        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs',\n                         'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None,\n                 GibbsExcessModel=IdealSolution,\n                 eos_pure_instances=None,\n                 VolumeLiquidMixture=None,\n                 HeatCapacityGases=None,\n                 EnthalpySublimations=None,\n                 use_Poynting=False,\n                 use_phis_sat=False,\n                 Hfs=None, Gfs=None, Sfs=None,\n                 T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None,\n                 ):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids,\n              HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations,\n              use_Poynting=use_Poynting,\n              Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\n"
  },
  "GT_src_dict": {
    "thermo/activity.py": {
      "GibbsExcess.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Method for comparing two instances of the `GibbsExcess` class for equality.\n\nParameters\n----------\nother : object\n    The object to compare with the current instance. Typically another `GibbsExcess` object.\n\nReturns\n-------\nbool\n    Returns `True` if the hash of the current instance is equal to the hash of the `other` object, indicating that they are considered equal based on their internal state and attributes. Returns `False` otherwise.\n\nNotes\n-----\nThis method relies on the `__hash__()` method, which computes a hash value based on the model parameters of the `GibbsExcess` instance. Thus, the equality comparison is dependent on the proper implementation of the `__hash__()` method, ensuring that two theoretically equivalent models yield the same hash value.\"\"\"\n        return self.__hash__() == hash(other)",
        "docstring": "Method for comparing two instances of the `GibbsExcess` class for equality.\n\nParameters\n----------\nother : object\n    The object to compare with the current instance. Typically another `GibbsExcess` object.\n\nReturns\n-------\nbool\n    Returns `True` if the hash of the current instance is equal to the hash of the `other` object, indicating that they are considered equal based on their internal state and attributes. Returns `False` otherwise.\n\nNotes\n-----\nThis method relies on the `__hash__()` method, which computes a hash value based on the model parameters of the `GibbsExcess` instance. Thus, the equality comparison is dependent on the proper implementation of the `__hash__()` method, ensuring that two theoretically equivalent models yield the same hash value.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.model_hash": {
        "code": "    def model_hash(self):\n        \"\"\"Basic method to calculate a hash of the model's non-state parameters for comparison between different instances of the GibbsExcess class. This is useful for determining if two models are identical, particularly in scenarios where the same underlying liquid phase behavior is being represented (e.g., in a VLL flash calculation). The hash is derived from the class name, the number of components (N), and the model's parameters, allowing for a consistent and unique identifier for the model's configuration.\n\nReturns\n-------\nmodel_hash : int\n    A hash value representing the non-state parameters of the model, used for object comparison in the same process context.\n\nNotes\n-----\nThe method relies on the attribute `_model_hash` to cache the result for efficiency. If this attribute is not already set, a list `to_hash` is constructed, which includes the class name and parameter values retrieved from `_model_attributes`. If any parameter is an ndarray (from the numpy package), it is converted to a list for hashing. The function `hash_any_primitive`, which is not defined within this context but is imported from another module, is used to compute the hash from the `to_hash` list.\"\"\"\n        \"Basic method to calculate a hash of the non-state parts of the model\\n        This is useful for comparing to models to\\n        determine if they are the same, i.e. in a VLL flash it is important to\\n        know if both liquids have the same model.\\n\\n        Note that the hashes should only be compared on the same system running\\n        in the same process!\\n\\n        Returns\\n        -------\\n        model_hash : int\\n            Hash of the object's model parameters, [-]\\n        \"\n        try:\n            return self._model_hash\n        except AttributeError:\n            pass\n        to_hash = [self.__class__.__name__, self.N]\n        for k in self._model_attributes:\n            v = getattr(self, k)\n            if type(v) is ndarray:\n                v = v.tolist()\n            to_hash.append(v)\n        self._model_hash = hash_any_primitive(to_hash)\n        return self._model_hash",
        "docstring": "Basic method to calculate a hash of the model's non-state parameters for comparison between different instances of the GibbsExcess class. This is useful for determining if two models are identical, particularly in scenarios where the same underlying liquid phase behavior is being represented (e.g., in a VLL flash calculation). The hash is derived from the class name, the number of components (N), and the model's parameters, allowing for a consistent and unique identifier for the model's configuration.\n\nReturns\n-------\nmodel_hash : int\n    A hash value representing the non-state parameters of the model, used for object comparison in the same process context.\n\nNotes\n-----\nThe method relies on the attribute `_model_hash` to cache the result for efficiency. If this attribute is not already set, a list `to_hash` is constructed, which includes the class name and parameter values retrieved from `_model_attributes`. If any parameter is an ndarray (from the numpy package), it is converted to a list for hashing. The function `hash_any_primitive`, which is not defined within this context but is imported from another module, is used to compute the hash from the `to_hash` list.",
        "signature": "def model_hash(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.as_json": {
        "code": "    def as_json(self, cache=None, option=0):\n        \"\"\"Create a JSON-friendly representation of the GibbsExcess model for storage and later retrieval. This method utilizes the `JsonOptEncodable` class to ensure compatibility with JSON serialization.\n\nParameters\n----------\ncache : dict, optional\n    A cache to optimize serialization, if provided.\noption : int, optional\n    An option flag to customize serialization behavior (default is 0).\n\nReturns\n-------\njson_repr : dict\n    A dictionary containing the JSON-friendly representation of the GibbsExcess model.\n\nNotes\n-----\nThis method is crucial for saving and reloading the state of an object. It is typically used alongside the `from_json` method to reconstruct the model from the serialized data. The method ensures that all essential parameters and attributes of the GibbsExcess instance are included in the JSON output.\"\"\"\n        'Method to create a JSON-friendly representation of the Gibbs Excess\\n        model which can be stored, and reloaded later.\\n\\n        Returns\\n        -------\\n        json_repr : dict\\n            JSON-friendly representation, [-]\\n\\n        Notes\\n        -----\\n\\n        Examples\\n        --------\\n        >>> import json\\n        >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\\n        >>> json_view = model.as_json()\\n        >>> json_str = json.dumps(json_view)\\n        >>> assert type(json_str) is str\\n        >>> model_copy = IdealSolution.from_json(json.loads(json_str))\\n        >>> assert model_copy == model\\n        '\n        return JsonOptEncodable.as_json(self, cache, option)",
        "docstring": "Create a JSON-friendly representation of the GibbsExcess model for storage and later retrieval. This method utilizes the `JsonOptEncodable` class to ensure compatibility with JSON serialization.\n\nParameters\n----------\ncache : dict, optional\n    A cache to optimize serialization, if provided.\noption : int, optional\n    An option flag to customize serialization behavior (default is 0).\n\nReturns\n-------\njson_repr : dict\n    A dictionary containing the JSON-friendly representation of the GibbsExcess model.\n\nNotes\n-----\nThis method is crucial for saving and reloading the state of an object. It is typically used alongside the `from_json` method to reconstruct the model from the serialized data. The method ensures that all essential parameters and attributes of the GibbsExcess instance are included in the JSON output.",
        "signature": "def as_json(self, cache=None, option=0):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.from_json": {
        "code": "    def from_json(cls, json_repr, cache=None):\n        \"\"\"Method to create a GibbsExcess model instance from a JSON-friendly representation. This method is essential for reconstructing a GibbsExcess object from saved data, ensuring the model can be reinitialized with the same parameters used during its creation.\n\nParameters\n----------\njson_repr : dict\n    A dictionary representation of a GibbsExcess model as produced by the `GibbsExcess.as_json()` method.\n\ncache : optional\n    A caching mechanism that may be utilized when reconstructing the model.\n\nReturns\n-------\nmodel : :obj:`GibbsExcess`\n    A new GibbsExcess object with parameters and state derived from the provided JSON representation.\n\nNotes\n-----\nIt is critical that the input dictionary conforms to the structure outlined by `GibbsExcess.as_json()` for successful reconstruction. The method relies on `JsonOptEncodable.from_json`, which handles the specifics of reading the JSON data and creating the equivalent instance of GibbsExcess or its subclasses.\"\"\"\n        'Method to create a Gibbs Excess model from a JSON-friendly\\n        serialization of another Gibbs Excess model.\\n\\n        Parameters\\n        ----------\\n        json_repr : dict\\n            JSON-friendly representation, [-]\\n\\n        Returns\\n        -------\\n        model : :obj:`GibbsExcess`\\n            Newly created object from the json serialization, [-]\\n\\n        Notes\\n        -----\\n        It is important that the input string be in the same format as that\\n        created by :obj:`GibbsExcess.as_json`.\\n\\n        Examples\\n        --------\\n        >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\\n        >>> json_view = model.as_json()\\n        >>> new_model = IdealSolution.from_json(json_view)\\n        >>> assert model == new_model\\n        '\n        return JsonOptEncodable.from_json(json_repr, cache)",
        "docstring": "Method to create a GibbsExcess model instance from a JSON-friendly representation. This method is essential for reconstructing a GibbsExcess object from saved data, ensuring the model can be reinitialized with the same parameters used during its creation.\n\nParameters\n----------\njson_repr : dict\n    A dictionary representation of a GibbsExcess model as produced by the `GibbsExcess.as_json()` method.\n\ncache : optional\n    A caching mechanism that may be utilized when reconstructing the model.\n\nReturns\n-------\nmodel : :obj:`GibbsExcess`\n    A new GibbsExcess object with parameters and state derived from the provided JSON representation.\n\nNotes\n-----\nIt is critical that the input dictionary conforms to the structure outlined by `GibbsExcess.as_json()` for successful reconstruction. The method relies on `JsonOptEncodable.from_json`, which handles the specifics of reading the JSON data and creating the equivalent instance of GibbsExcess or its subclasses.",
        "signature": "def from_json(cls, json_repr, cache=None):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.HE": {
        "code": "    def HE(self):\n        \"\"\"Calculate and return the excess enthalpy of a liquid phase using an activity coefficient model. The excess enthalpy, \\\\( h^E \\\\), is computed using the formula:\n\n.. math::\n    h^E = -T \\\\frac{\\\\partial g^E}{\\\\partial T} + g^E\n\nwhere \\\\( T \\\\) is the temperature and \\\\( g^E \\\\) is the excess Gibbs energy calculated by the `GE` method.\n\nReturns\n-------\nHE : float\n    The excess enthalpy of the liquid phase, measured in joules per mole [J/mol].\n\nNotes\n-----\nThis method relies on the `dGE_dT` method to compute the temperature derivative of excess Gibbs energy, which is part of the broader framework of activity coefficient models represented by the `GibbsExcess` class. Ensure that the model parameters and state (temperature and composition) are properly initialized for accurate results.\"\"\"\n        'Calculate and return the excess entropy of a liquid phase using an\\n        activity coefficient model.\\n\\n        .. math::\\n            h^E = -T \\\\frac{\\\\partial g^E}{\\\\partial T} + g^E\\n\\n        Returns\\n        -------\\n        HE : float\\n            Excess enthalpy of the liquid phase, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        \"f = symbols('f', cls=Function)\\n        T = symbols('T')\\n        simplify(-T**2*diff(f(T)/T, T))\\n        \"\n        return -self.T * self.dGE_dT() + self.GE()",
        "docstring": "Calculate and return the excess enthalpy of a liquid phase using an activity coefficient model. The excess enthalpy, \\( h^E \\), is computed using the formula:\n\n.. math::\n    h^E = -T \\frac{\\partial g^E}{\\partial T} + g^E\n\nwhere \\( T \\) is the temperature and \\( g^E \\) is the excess Gibbs energy calculated by the `GE` method.\n\nReturns\n-------\nHE : float\n    The excess enthalpy of the liquid phase, measured in joules per mole [J/mol].\n\nNotes\n-----\nThis method relies on the `dGE_dT` method to compute the temperature derivative of excess Gibbs energy, which is part of the broader framework of activity coefficient models represented by the `GibbsExcess` class. Ensure that the model parameters and state (temperature and composition) are properly initialized for accurate results.",
        "signature": "def HE(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dHE_dT": {
        "code": "    def dHE_dT(self):\n        \"\"\"Calculate and return the first temperature derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature change in excess enthalpy (h^E) based on the excess Gibbs energy (g^E) derived from the activity coefficient model, following the relationship \\\\(\\\\frac{\\\\partial h^E}{\\\\partial T} = -T \\\\frac{\\\\partial^2 g^E}{\\\\partial T^2}\\\\). The temperature \\\\(T\\\\) is an instance attribute, while the second derivative of the Gibbs energy, obtained through the `d2GE_dT2` method, is used in the computation.\n\nReturns\n-------\ndHE_dT : float\n    The first temperature derivative of excess enthalpy, measured in [J/mol/K].\n\nNotes\n-----\nThis method relies on the `d2GE_dT2` method from the GibbsExcess class to accurately calculate the required second derivative of the excess Gibbs energy.\"\"\"\n        'Calculate and return the first temperature derivative of excess\\n        enthalpy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial h^E}{\\\\partial T} = -T \\\\frac{\\\\partial^2 g^E}\\n            {\\\\partial T^2}\\n\\n        Returns\\n        -------\\n        dHE_dT : float\\n            First temperature derivative of excess enthalpy of the liquid\\n            phase, [J/mol/K]\\n\\n        Notes\\n        -----\\n        '\n        return -self.T * self.d2GE_dT2()",
        "docstring": "Calculate and return the first temperature derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature change in excess enthalpy (h^E) based on the excess Gibbs energy (g^E) derived from the activity coefficient model, following the relationship \\(\\frac{\\partial h^E}{\\partial T} = -T \\frac{\\partial^2 g^E}{\\partial T^2}\\). The temperature \\(T\\) is an instance attribute, while the second derivative of the Gibbs energy, obtained through the `d2GE_dT2` method, is used in the computation.\n\nReturns\n-------\ndHE_dT : float\n    The first temperature derivative of excess enthalpy, measured in [J/mol/K].\n\nNotes\n-----\nThis method relies on the `d2GE_dT2` method from the GibbsExcess class to accurately calculate the required second derivative of the excess Gibbs energy.",
        "signature": "def dHE_dT(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dHE_dxs": {
        "code": "    def dHE_dxs(self):\n        \"\"\"Calculate and return the mole fraction derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of excess enthalpy (\\\\( h^E \\\\)) with respect to the mole fraction (\\\\( x_i \\\\)). The calculation is based on the equation:\n\n.. math::\n    \\\\frac{\\\\partial h^E}{\\\\partial x_i} = -T \\\\frac{\\\\partial^2 g^E}{\\\\partial T \\\\partial x_i} + \\\\frac{\\\\partial g^E}{\\\\partial x_i}\n\nwhere:\n- \\\\( T \\\\) is the temperature of the system.\n- \\\\( g^E \\\\) represents the excess Gibbs energy, which is computed using the model.\n\nReturns\n-------\ndHE_dxs : list[float]\n    First mole fraction derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nThis method relies on two other methods, `d2GE_dTdxs` and `dGE_dxs`, for calculating the second temperature derivative of excess Gibbs energy and the mole fraction derivatives of excess Gibbs energy, respectively. It uses a cached value `_dHE_dxs` to optimize performance by avoiding redundant calculations.\"\"\"\n        'Calculate and return the mole fraction derivative of excess\\n        enthalpy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial h^E}{\\\\partial x_i} = -T \\\\frac{\\\\partial^2 g^E}\\n            {\\\\partial T \\\\partial x_i} + \\\\frac{\\\\partial g^E}{\\\\partial x_i}\\n\\n        Returns\\n        -------\\n        dHE_dxs : list[float]\\n            First mole fraction derivative of excess enthalpy of the liquid\\n            phase, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        try:\n            return self._dHE_dxs\n        except:\n            pass\n        d2GE_dTdxs = self.d2GE_dTdxs()\n        try:\n            dGE_dxs = self._dGE_dxs\n        except:\n            dGE_dxs = self.dGE_dxs()\n        dHE_dxs = gibbs_excess_dHE_dxs(dGE_dxs, d2GE_dTdxs, self.N, self.T)\n        if self.vectorized and type(dHE_dxs) is list:\n            dHE_dxs = array(dHE_dxs)\n        self._dHE_dxs = dHE_dxs\n        return dHE_dxs",
        "docstring": "Calculate and return the mole fraction derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of excess enthalpy (\\( h^E \\)) with respect to the mole fraction (\\( x_i \\)). The calculation is based on the equation:\n\n.. math::\n    \\frac{\\partial h^E}{\\partial x_i} = -T \\frac{\\partial^2 g^E}{\\partial T \\partial x_i} + \\frac{\\partial g^E}{\\partial x_i}\n\nwhere:\n- \\( T \\) is the temperature of the system.\n- \\( g^E \\) represents the excess Gibbs energy, which is computed using the model.\n\nReturns\n-------\ndHE_dxs : list[float]\n    First mole fraction derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nThis method relies on two other methods, `d2GE_dTdxs` and `dGE_dxs`, for calculating the second temperature derivative of excess Gibbs energy and the mole fraction derivatives of excess Gibbs energy, respectively. It uses a cached value `_dHE_dxs` to optimize performance by avoiding redundant calculations.",
        "signature": "def dHE_dxs(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dHE_dns": {
        "code": "    def dHE_dns(self):\n        \"\"\"Calculate and return the mole number derivative of excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of the excess enthalpy (h^E) with respect to the number of moles (n_i) for each component in the mixture. The calculation uses the mole fraction derivatives of excess enthalpy (dHE_dxs) and the current mole fractions (xs) through the helper function `dxs_to_dns`, which translates mole fraction derivatives to mole number derivatives. \n\nReturns\n-------\ndHE_dns : list[float]\n    A list containing the first mole number derivative of excess enthalpy for each component, expressed in Joules per square mole (J/mol^2).\n\nNotes\n-----\nThe `dHE_dxs` method, which is invoked within this function, calculates the mole fraction derivatives of excess enthalpy. The `xs` attribute holds the current composition of the system and is defined in the `GibbsExcess` class. The `out` variable is initialized to handle the output format, ensuring appropriate sizing according to whether the object is vectorized or not.\"\"\"\n        'Calculate and return the mole number derivative of excess\\n        enthalpy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial h^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dHE_dns : list[float]\\n            First mole number derivative of excess enthalpy of the liquid\\n            phase, [J/mol^2]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dHE_dns = dxs_to_dns(self.dHE_dxs(), self.xs, out)\n        return dHE_dns",
        "docstring": "Calculate and return the mole number derivative of excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of the excess enthalpy (h^E) with respect to the number of moles (n_i) for each component in the mixture. The calculation uses the mole fraction derivatives of excess enthalpy (dHE_dxs) and the current mole fractions (xs) through the helper function `dxs_to_dns`, which translates mole fraction derivatives to mole number derivatives. \n\nReturns\n-------\ndHE_dns : list[float]\n    A list containing the first mole number derivative of excess enthalpy for each component, expressed in Joules per square mole (J/mol^2).\n\nNotes\n-----\nThe `dHE_dxs` method, which is invoked within this function, calculates the mole fraction derivatives of excess enthalpy. The `xs` attribute holds the current composition of the system and is defined in the `GibbsExcess` class. The `out` variable is initialized to handle the output format, ensuring appropriate sizing according to whether the object is vectorized or not.",
        "signature": "def dHE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dnHE_dns": {
        "code": "    def dnHE_dns(self):\n        \"\"\"Calculate and return the partial mole number derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the derivative of the excess enthalpy (\\\\( h^E \\\\)) with respect to the mole number (\\\\( n_i \\\\)) of each component defined in the system. It uses the mole fraction derivatives of excess enthalpy, obtained from the `dHE_dxs()` method, and applies the `dxs_to_dn_partials` function to convert these to mole number derivatives using the current mole fractions (`self.xs`) and the excess enthalpy (`self.HE()`). The output will be a list of partial derivatives representing how the excess enthalpy changes as the number of moles of each component changes.\n\nReturns\n-------\ndnHE_dns : list[float]\n    First partial mole number derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nDependencies\n------------\n- `dxs_to_dn_partials`: A utility function for converting mole fraction derivatives to mole number derivatives.\n- `self.dHE_dxs()`: Returns the mole fraction derivatives of excess enthalpy.\n- `self.xs`: The current mole fractions of the components.\n- `self.HE()`: Calculates the excess enthalpy of the liquid phase.\"\"\"\n        'Calculate and return the partial mole number derivative of excess\\n        enthalpy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial n h^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dnHE_dns : list[float]\\n            First partial mole number derivative of excess enthalpy of the\\n            liquid phase, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dnHE_dns = dxs_to_dn_partials(self.dHE_dxs(), self.xs, self.HE(), out)\n        return dnHE_dns",
        "docstring": "Calculate and return the partial mole number derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the derivative of the excess enthalpy (\\( h^E \\)) with respect to the mole number (\\( n_i \\)) of each component defined in the system. It uses the mole fraction derivatives of excess enthalpy, obtained from the `dHE_dxs()` method, and applies the `dxs_to_dn_partials` function to convert these to mole number derivatives using the current mole fractions (`self.xs`) and the excess enthalpy (`self.HE()`). The output will be a list of partial derivatives representing how the excess enthalpy changes as the number of moles of each component changes.\n\nReturns\n-------\ndnHE_dns : list[float]\n    First partial mole number derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nDependencies\n------------\n- `dxs_to_dn_partials`: A utility function for converting mole fraction derivatives to mole number derivatives.\n- `self.dHE_dxs()`: Returns the mole fraction derivatives of excess enthalpy.\n- `self.xs`: The current mole fractions of the components.\n- `self.HE()`: Calculates the excess enthalpy of the liquid phase.",
        "signature": "def dnHE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.SE": {
        "code": "    def SE(self):\n        \"\"\"Calculates the excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the excess entropy \\\\( s^E \\\\) based on the relationship between excess enthalpy \\\\( h^E \\\\) and excess Gibbs energy \\\\( g^E \\\\) at a given temperature \\\\( T \\\\). The calculation is given by the formula:\n\n.. math::\n    s^E = \\\\frac{h^E - g^E}{T}\n\nReturns\n-------\nSE : float\n    The excess entropy of the liquid phase in units of [J/mol/K].\n\nNotes\n-----\nThis method caches the computed value in the instance variable `_SE` for efficiency, allowing subsequent calls to return the cached value instead of recalculating. The methods `HE()` and `GE()` are called to obtain the excess enthalpy and Gibbs energy, respectively, which are essential for this calculation. This method relies on the attribute `T` (temperature), which is a fundamental attribute of the `GibbsExcess` class.\"\"\"\n        'Calculates the excess entropy of a liquid phase using an\\n        activity coefficient model.\\n\\n        .. math::\\n            s^E = \\\\frac{h^E - g^E}{T}\\n\\n        Returns\\n        -------\\n        SE : float\\n            Excess entropy of the liquid phase, [J/mol/K]\\n\\n        Notes\\n        -----\\n        Note also the relationship of the expressions for partial excess\\n        entropy:\\n\\n        .. math::\\n            S_i^E = -R\\\\left(T \\\\frac{\\\\partial \\\\ln \\\\gamma_i}{\\\\partial T}\\n            + \\\\ln \\\\gamma_i\\\\right)\\n\\n\\n        '\n        try:\n            return self._SE\n        except:\n            self._SE = (self.HE() - self.GE()) / self.T\n        return self._SE",
        "docstring": "Calculates the excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the excess entropy \\( s^E \\) based on the relationship between excess enthalpy \\( h^E \\) and excess Gibbs energy \\( g^E \\) at a given temperature \\( T \\). The calculation is given by the formula:\n\n.. math::\n    s^E = \\frac{h^E - g^E}{T}\n\nReturns\n-------\nSE : float\n    The excess entropy of the liquid phase in units of [J/mol/K].\n\nNotes\n-----\nThis method caches the computed value in the instance variable `_SE` for efficiency, allowing subsequent calls to return the cached value instead of recalculating. The methods `HE()` and `GE()` are called to obtain the excess enthalpy and Gibbs energy, respectively, which are essential for this calculation. This method relies on the attribute `T` (temperature), which is a fundamental attribute of the `GibbsExcess` class.",
        "signature": "def SE(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dSE_dT": {
        "code": "    def dSE_dT(self):\n        \"\"\"Calculate and return the first temperature derivative of the excess entropy of a liquid phase using an activity coefficient model.\n\nThe derivative is computed based on the relationship between the excess Gibbs energy (GE) and excess enthalpy (HE) as well as their temperature derivatives. The formula used is:\n\n.. math::\n    \\\\frac{\\\\partial s^E}{\\\\partial T} = \\\\frac{1}{T}\n    \\\\left(\\\\frac{-\\\\partial g^E}{\\\\partial T} + \\\\frac{\\\\partial h^E}{\\\\partial T}\n    - \\\\frac{(G + H)}{T}\\\\right)\n\nReturns\n-------\ndSE_dT : float\n    The first temperature derivative of excess entropy of the liquid phase, expressed in [J/mol/K].\n\nNotes\n-----\nThis method relies on other methods within the class, specifically `dHE_dT()`, `dGE_dT()`, and `HE()`, to compute the temperature derivatives of enthalpy and Gibbs energy, as well as their values at the current state. `self.T` represents the temperature of the system and is defined in the `GibbsExcess` class.\"\"\"\n        'Calculate and return the first temperature derivative of excess\\n        entropy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial s^E}{\\\\partial T} = \\\\frac{1}{T}\\n            \\\\left(\\\\frac{-\\\\partial g^E}{\\\\partial T} + \\\\frac{\\\\partial h^E}{\\\\partial T}\\n            - \\\\frac{(G + H)}{T}\\\\right)\\n\\n        Returns\\n        -------\\n        dSE_dT : float\\n            First temperature derivative of excess entropy of the liquid\\n            phase, [J/mol/K]\\n\\n        Notes\\n        -----\\n\\n        '\n        \"from sympy import *\\n        T = symbols('T')\\n        G, H = symbols('G, H', cls=Function)\\n        S = (H(T) - G(T))/T\\n        print(diff(S, T))\\n        # (-Derivative(G(T), T) + Derivative(H(T), T))/T - (-G(T) + H(T))/T**2\\n        \"\n        dHE_dT = self.dHE_dT()\n        try:\n            HE = self._HE\n        except:\n            HE = self.HE()\n        try:\n            dGE_dT = self._dGE_dT\n        except:\n            dGE_dT = self.dGE_dT()\n        try:\n            GE = self._GE\n        except:\n            GE = self.GE()\n        T_inv = 1.0 / self.T\n        return T_inv * (-dGE_dT + dHE_dT - (HE - GE) * T_inv)",
        "docstring": "Calculate and return the first temperature derivative of the excess entropy of a liquid phase using an activity coefficient model.\n\nThe derivative is computed based on the relationship between the excess Gibbs energy (GE) and excess enthalpy (HE) as well as their temperature derivatives. The formula used is:\n\n.. math::\n    \\frac{\\partial s^E}{\\partial T} = \\frac{1}{T}\n    \\left(\\frac{-\\partial g^E}{\\partial T} + \\frac{\\partial h^E}{\\partial T}\n    - \\frac{(G + H)}{T}\\right)\n\nReturns\n-------\ndSE_dT : float\n    The first temperature derivative of excess entropy of the liquid phase, expressed in [J/mol/K].\n\nNotes\n-----\nThis method relies on other methods within the class, specifically `dHE_dT()`, `dGE_dT()`, and `HE()`, to compute the temperature derivatives of enthalpy and Gibbs energy, as well as their values at the current state. `self.T` represents the temperature of the system and is defined in the `GibbsExcess` class.",
        "signature": "def dSE_dT(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dSE_dxs": {
        "code": "    def dSE_dxs(self):\n        \"\"\"Calculate and return the mole fraction derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first mole fraction derivative of excess entropy \\\\( S^E \\\\) based on the relation between excess enthalpy \\\\( h^E \\\\) and excess Gibbs energy \\\\( g^E \\\\). It retrieves the temperature derivatives of the second excess Gibbs energy with respect to mole fractions from the internal method `d2GE_dTdxs` and uses them to compute the result. The output is negated in accordance with the formula for \\\\( \\\\frac{\\\\partial S^E}{\\\\partial x_i} \\\\).\n\nReturns\n-------\ndSE_dxs : list[float]\n    List of first mole fraction derivatives of excess entropy of the liquid phase, measured in [J/(mol*K)].\n\nDependencies\n------------\n- This method depends on the `d2GE_dTdxs` method, which calculates the second temperature derivative of excess Gibbs energy with respect to mole fractions.\n- The attribute `_dSE_dxs` is used for caching results to avoid redundant calculations.\n\nNotes\n-----\nThe method effectively handles two scenarios: vectorized and non-vectorized calculations, where it adapts the output structure accordingly.\"\"\"\n        'Calculate and return the mole fraction derivative of excess\\n        entropy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial S^E}{\\\\partial x_i} = \\\\frac{1}{T}\\\\left( \\\\frac{\\\\partial h^E}\\n            {\\\\partial x_i} - \\\\frac{\\\\partial g^E}{\\\\partial x_i}\\\\right)\\n            = -\\\\frac{\\\\partial^2 g^E}{\\\\partial x_i \\\\partial T}\\n\\n        Returns\\n        -------\\n        dSE_dxs : list[float]\\n            First mole fraction derivative of excess entropy of the liquid\\n            phase, [J/(mol*K)]\\n\\n        Notes\\n        -----\\n        '\n        try:\n            return self._dSE_dxs\n        except:\n            pass\n        try:\n            d2GE_dTdxs = self._d2GE_dTdxs\n        except:\n            d2GE_dTdxs = self.d2GE_dTdxs()\n        if not self.vectorized:\n            dSE_dxs = [-v for v in d2GE_dTdxs]\n        else:\n            dSE_dxs = -d2GE_dTdxs\n        self._dSE_dxs = dSE_dxs\n        return dSE_dxs",
        "docstring": "Calculate and return the mole fraction derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first mole fraction derivative of excess entropy \\( S^E \\) based on the relation between excess enthalpy \\( h^E \\) and excess Gibbs energy \\( g^E \\). It retrieves the temperature derivatives of the second excess Gibbs energy with respect to mole fractions from the internal method `d2GE_dTdxs` and uses them to compute the result. The output is negated in accordance with the formula for \\( \\frac{\\partial S^E}{\\partial x_i} \\).\n\nReturns\n-------\ndSE_dxs : list[float]\n    List of first mole fraction derivatives of excess entropy of the liquid phase, measured in [J/(mol*K)].\n\nDependencies\n------------\n- This method depends on the `d2GE_dTdxs` method, which calculates the second temperature derivative of excess Gibbs energy with respect to mole fractions.\n- The attribute `_dSE_dxs` is used for caching results to avoid redundant calculations.\n\nNotes\n-----\nThe method effectively handles two scenarios: vectorized and non-vectorized calculations, where it adapts the output structure accordingly.",
        "signature": "def dSE_dxs(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dSE_dns": {
        "code": "    def dSE_dns(self):\n        \"\"\"Calculate and return the mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of excess entropy \\\\(S^E\\\\) with respect to the mole number \\\\(n_i\\\\) of each component in the mixture. The calculation uses the mole fraction derivatives of excess entropy, which are obtained through the `dSE_dxs()` method, and transforms them into mole number derivatives using the `dxs_to_dns` utility function.\n\nReturns\n-------\ndSE_dns : list[float]\n    First mole number derivative of excess entropy of the liquid phase, expressed in [J/(mol\u00b2*K)].\n\nNotes\n-----\nThe `output` array is initialized with zeros and its size is based on the number of components `N` in the system, which is defined as an attribute in the `GibbsExcess` class. The `vectorized` attribute determines the format of the output, ensuring compatibility with different data types.\"\"\"\n        'Calculate and return the mole number derivative of excess\\n        entropy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial S^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dSE_dns : list[float]\\n            First mole number derivative of excess entropy of the liquid\\n            phase, [J/(mol^2*K)]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dSE_dns = dxs_to_dns(self.dSE_dxs(), self.xs, out)\n        return dSE_dns",
        "docstring": "Calculate and return the mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of excess entropy \\(S^E\\) with respect to the mole number \\(n_i\\) of each component in the mixture. The calculation uses the mole fraction derivatives of excess entropy, which are obtained through the `dSE_dxs()` method, and transforms them into mole number derivatives using the `dxs_to_dns` utility function.\n\nReturns\n-------\ndSE_dns : list[float]\n    First mole number derivative of excess entropy of the liquid phase, expressed in [J/(mol\u00b2*K)].\n\nNotes\n-----\nThe `output` array is initialized with zeros and its size is based on the number of components `N` in the system, which is defined as an attribute in the `GibbsExcess` class. The `vectorized` attribute determines the format of the output, ensuring compatibility with different data types.",
        "signature": "def dSE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dnSE_dns": {
        "code": "    def dnSE_dns(self):\n        \"\"\"Calculate and return the partial mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the change in excess entropy with respect to the number of moles of component \\\\(i\\\\). It utilizes the first mole fraction derivative of excess entropy obtained from the `dSE_dxs` method and normalizes it using the current mole fractions stored in `self.xs` and the total excess entropy from `self.SE()`. The output is a list of floats representing the first partial mole number derivative of excess entropy, measured in J/(mol\u00b7K).\n\nReturns\n-------\ndnSE_dns : list[float]\n    First partial mole number derivative of excess entropy of the liquid phase, [J/(mol*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dn_partials`, which transforms the mole fraction derivative into the mole number derivative using the current mole fractions. The `self.N` attribute represents the number of components, while `self.vectorized` determines whether to use a numeric array or a Python list for output.\"\"\"\n        'Calculate and return the partial mole number derivative of excess\\n        entropy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial n S^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dnSE_dns : list[float]\\n            First partial mole number derivative of excess entropy of the liquid\\n            phase, [J/(mol*K)]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dnSE_dns = dxs_to_dn_partials(self.dSE_dxs(), self.xs, self.SE(), out)\n        return dnSE_dns",
        "docstring": "Calculate and return the partial mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the change in excess entropy with respect to the number of moles of component \\(i\\). It utilizes the first mole fraction derivative of excess entropy obtained from the `dSE_dxs` method and normalizes it using the current mole fractions stored in `self.xs` and the total excess entropy from `self.SE()`. The output is a list of floats representing the first partial mole number derivative of excess entropy, measured in J/(mol\u00b7K).\n\nReturns\n-------\ndnSE_dns : list[float]\n    First partial mole number derivative of excess entropy of the liquid phase, [J/(mol*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dn_partials`, which transforms the mole fraction derivative into the mole number derivative using the current mole fractions. The `self.N` attribute represents the number of components, while `self.vectorized` determines whether to use a numeric array or a Python list for output.",
        "signature": "def dnSE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dGE_dns": {
        "code": "    def dGE_dns(self):\n        \"\"\"Calculate and return the mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the partial derivative of the excess Gibbs energy \\\\( G^E \\\\) with respect to the mole number \\\\( n_i \\\\) for each component in the mixture. The calculation utilizes the method `dGE_dxs` to obtain the mole fraction derivatives of excess Gibbs energy, and it applies the function `dxs_to_dns` to convert these derivatives into mole number derivatives based on the current composition \\\\( xs \\\\) of the system.\n\nReturns\n-------\ndGE_dns : list[float]\n    A list containing the first mole number derivatives of excess Gibbs energy for each component, measured in [J/(mol^2*K)].\n\nNotes\n-----\n- The method relies on the attribute `xs`, which represents the current mole fractions of the components, and `N`, which is the total number of components in the mixture.\n- It checks the `vectorized` attribute to decide whether to create a list or a NumPy array of zeros for the output.\n- Dependencies: The method calls `dxs_to_dns`, imported from `chemicals.utils`, to facilitate the conversion from mole fraction derivatives to mole number derivatives.\"\"\"\n        'Calculate and return the mole number derivative of excess\\n        Gibbs energy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial G^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dGE_dns : list[float]\\n            First mole number derivative of excess Gibbs entropy of the liquid\\n            phase, [J/(mol^2*K)]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dGE_dns = dxs_to_dns(self.dGE_dxs(), self.xs, out)\n        return dGE_dns",
        "docstring": "Calculate and return the mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the partial derivative of the excess Gibbs energy \\( G^E \\) with respect to the mole number \\( n_i \\) for each component in the mixture. The calculation utilizes the method `dGE_dxs` to obtain the mole fraction derivatives of excess Gibbs energy, and it applies the function `dxs_to_dns` to convert these derivatives into mole number derivatives based on the current composition \\( xs \\) of the system.\n\nReturns\n-------\ndGE_dns : list[float]\n    A list containing the first mole number derivatives of excess Gibbs energy for each component, measured in [J/(mol^2*K)].\n\nNotes\n-----\n- The method relies on the attribute `xs`, which represents the current mole fractions of the components, and `N`, which is the total number of components in the mixture.\n- It checks the `vectorized` attribute to decide whether to create a list or a NumPy array of zeros for the output.\n- Dependencies: The method calls `dxs_to_dns`, imported from `chemicals.utils`, to facilitate the conversion from mole fraction derivatives to mole number derivatives.",
        "signature": "def dGE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dnGE_dns": {
        "code": "    def dnGE_dns(self):\n        \"\"\"Calculate and return the partial mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of the excess Gibbs energy with respect to the number of moles of each component in the mixture. It utilizes the mole fraction derivatives of excess Gibbs energy (`dGE_dxs`), the current mole fractions (`xs`), and the total excess Gibbs energy (`GE`) to perform the calculation. The output is a list of floats representing the derivatives in units of J/(mol).\n\nReturns\n-------\ndnGE_dns : list[float]\n    The first partial mole number derivatives of excess Gibbs energy for each component, with respect to its mole number.\n\nNotes\n-----\nThis method leverages the utility function `dxs_to_dn_partials`, which converts derivatives with respect to mole fractions to those with respect to mole numbers. The method ensures that the output format is suitable for both vectorized and non-vectorized scenarios, initializing the output list as `[0.0]*self.N` for non-vectorized or using `zeros(self.N)` for vectorized calculations.\"\"\"\n        'Calculate and return the partial mole number derivative of excess\\n        Gibbs energy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial n G^E}{\\\\partial n_i}\\n\\n        Returns\\n        -------\\n        dnGE_dns : list[float]\\n            First partial mole number derivative of excess Gibbs entropy of the\\n            liquid phase, [J/(mol)]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        dnGE_dns = dxs_to_dn_partials(self.dGE_dxs(), self.xs, self.GE(), out)\n        return dnGE_dns",
        "docstring": "Calculate and return the partial mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of the excess Gibbs energy with respect to the number of moles of each component in the mixture. It utilizes the mole fraction derivatives of excess Gibbs energy (`dGE_dxs`), the current mole fractions (`xs`), and the total excess Gibbs energy (`GE`) to perform the calculation. The output is a list of floats representing the derivatives in units of J/(mol).\n\nReturns\n-------\ndnGE_dns : list[float]\n    The first partial mole number derivatives of excess Gibbs energy for each component, with respect to its mole number.\n\nNotes\n-----\nThis method leverages the utility function `dxs_to_dn_partials`, which converts derivatives with respect to mole fractions to those with respect to mole numbers. The method ensures that the output format is suitable for both vectorized and non-vectorized scenarios, initializing the output list as `[0.0]*self.N` for non-vectorized or using `zeros(self.N)` for vectorized calculations.",
        "signature": "def dnGE_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.d2GE_dTdns": {
        "code": "    def d2GE_dTdns(self):\n        \"\"\"Calculate and return the mole number derivative of the first temperature derivative of excess Gibbs energy (\\\\(G^E\\\\)) of a liquid phase using an activity coefficient model. This method utilizes the mole fraction derivatives of the temperature derivative of excess Gibbs energy calculated by the method `d2GE_dTdxs()`, multiplying it by the current mole fractions `xs` to compute the result.\n\nReturns\n-------\nd2GE_dTdns : list[float]\n    First mole number derivative of the temperature derivative of excess Gibbs energy of the liquid phase, expressed in [J/(mol^2*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dns`, which transforms the derivatives of the Gibbs energy with respect to mole fractions into their corresponding mole number derivatives. The variable `out` is initialized as a list or NumPy array of zeros, depending on whether the instance is vectorized, and it is updated with the results of the transformation before being returned.\"\"\"\n        'Calculate and return the mole number derivative of the first\\n        temperature derivative of excess Gibbs energy of a liquid phase using\\n        an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 G^E}{\\\\partial n_i \\\\partial T}\\n\\n        Returns\\n        -------\\n        d2GE_dTdns : list[float]\\n            First mole number derivative of the temperature derivative of\\n            excess Gibbs entropy of the liquid phase, [J/(mol^2*K)]\\n\\n        Notes\\n        -----\\n        '\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        d2GE_dTdns = dxs_to_dns(self.d2GE_dTdxs(), self.xs, out)\n        return d2GE_dTdns",
        "docstring": "Calculate and return the mole number derivative of the first temperature derivative of excess Gibbs energy (\\(G^E\\)) of a liquid phase using an activity coefficient model. This method utilizes the mole fraction derivatives of the temperature derivative of excess Gibbs energy calculated by the method `d2GE_dTdxs()`, multiplying it by the current mole fractions `xs` to compute the result.\n\nReturns\n-------\nd2GE_dTdns : list[float]\n    First mole number derivative of the temperature derivative of excess Gibbs energy of the liquid phase, expressed in [J/(mol^2*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dns`, which transforms the derivatives of the Gibbs energy with respect to mole fractions into their corresponding mole number derivatives. The variable `out` is initialized as a list or NumPy array of zeros, depending on whether the instance is vectorized, and it is updated with the results of the transformation before being returned.",
        "signature": "def d2GE_dTdns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.d2nGE_dTdns": {
        "code": "    def d2nGE_dTdns(self):\n        \"\"\"Calculate and return the partial derivative of the first temperature derivative of excess Gibbs energy with respect to mole number for a liquid phase using an activity coefficient model. This method employs the mole number derivative of the first temperature derivative of excess Gibbs energy (\\\\(dGE_dT\\\\)) and the second temperature derivative of excess Gibbs energy (\\\\(d2GE_dTdns\\\\)), calculated from the respective methods in the class.\n\nReturns\n-------\nd2nGE_dTdns : list[float]\n    List of the first partial mole number derivatives of the temperature derivative of excess Gibbs energy, expressed in units of [J/(mol*K)].\n\nNotes\n-----\nThis method makes use of `dns_to_dn_partials`, which converts the temperature derivatives of excess Gibbs energy into partial mole derivatives. The internal variables `dGE_dT` and `d2GE_dTdns` are derived from the methods `dGE_dT` and `d2GE_dTdns`, respectively, ensuring the accuracy of the derivatives within the context of the activity coefficient model.\"\"\"\n        'Calculate and return the partial mole number derivative of the first\\n        temperature derivative of excess Gibbs energy of a liquid phase using\\n        an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 n G^E}{\\\\partial n_i \\\\partial T}\\n\\n        Returns\\n        -------\\n        d2nGE_dTdns : list[float]\\n            First partial mole number derivative of the temperature derivative\\n            of excess Gibbs entropy of the liquid phase, [J/(mol*K)]\\n\\n        Notes\\n        -----\\n        '\n        dGE_dT = self.dGE_dT()\n        d2GE_dTdns = self.d2GE_dTdns()\n        out = [0.0] * self.N if not self.vectorized else zeros(self.N)\n        d2nGE_dTdns = dns_to_dn_partials(d2GE_dTdns, dGE_dT, out)\n        return d2nGE_dTdns",
        "docstring": "Calculate and return the partial derivative of the first temperature derivative of excess Gibbs energy with respect to mole number for a liquid phase using an activity coefficient model. This method employs the mole number derivative of the first temperature derivative of excess Gibbs energy (\\(dGE_dT\\)) and the second temperature derivative of excess Gibbs energy (\\(d2GE_dTdns\\)), calculated from the respective methods in the class.\n\nReturns\n-------\nd2nGE_dTdns : list[float]\n    List of the first partial mole number derivatives of the temperature derivative of excess Gibbs energy, expressed in units of [J/(mol*K)].\n\nNotes\n-----\nThis method makes use of `dns_to_dn_partials`, which converts the temperature derivatives of excess Gibbs energy into partial mole derivatives. The internal variables `dGE_dT` and `d2GE_dTdns` are derived from the methods `dGE_dT` and `d2GE_dTdns`, respectively, ensuring the accuracy of the derivatives within the context of the activity coefficient model.",
        "signature": "def d2nGE_dTdns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.d2nGE_dninjs": {
        "code": "    def d2nGE_dninjs(self):\n        \"\"\"Calculate and return the second partial mole number derivative of the excess Gibbs energy for a liquid phase using the activity coefficient model. This derivative is represented mathematically as \\\\(\\\\frac{\\\\partial^2 n G^E}{\\\\partial n_i \\\\partial n_j}\\\\).\n\nReturns\n-------\nd2nGE_dninjs : list[list[float]]\n    A matrix representing the second partial mole number derivatives of excess Gibbs energy, measured in [J/(mol\u00b2)]. The output dimensions correspond to the number of components in the system.\n\nNotes\n-----\nThis method relies on the `d2GE_dxixjs()` method to obtain the second derivatives of excess Gibbs energy with respect to mole fractions, which is then converted into partial mole number derivatives using the `d2xs_to_dxdn_partials` function. The attribute `self.xs` (mole fractions) is used to perform this conversion. If the instance variable `self.vectorized` is True, the output is converted into a NumPy array for efficiency. The method is designed for use within the context of the `GibbsExcess` class, which models liquid phase behavior based on activity coefficients.\"\"\"\n        'Calculate and return the second partial mole number derivative of\\n        excess Gibbs energy of a liquid phase using\\n        an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 n G^E}{\\\\partial n_i \\\\partial n_i}\\n\\n        Returns\\n        -------\\n        d2nGE_dninjs : list[list[float]]\\n            Second partial mole number derivative of excess Gibbs energy of a\\n            liquid phase, [J/(mol^2)]\\n\\n        Notes\\n        -----\\n        '\n        d2nGE_dninjs = d2xs_to_dxdn_partials(self.d2GE_dxixjs(), self.xs)\n        if self.vectorized and type(d2nGE_dninjs) is list:\n            d2nGE_dninjs = array(d2nGE_dninjs)\n        return d2nGE_dninjs",
        "docstring": "Calculate and return the second partial mole number derivative of the excess Gibbs energy for a liquid phase using the activity coefficient model. This derivative is represented mathematically as \\(\\frac{\\partial^2 n G^E}{\\partial n_i \\partial n_j}\\).\n\nReturns\n-------\nd2nGE_dninjs : list[list[float]]\n    A matrix representing the second partial mole number derivatives of excess Gibbs energy, measured in [J/(mol\u00b2)]. The output dimensions correspond to the number of components in the system.\n\nNotes\n-----\nThis method relies on the `d2GE_dxixjs()` method to obtain the second derivatives of excess Gibbs energy with respect to mole fractions, which is then converted into partial mole number derivatives using the `d2xs_to_dxdn_partials` function. The attribute `self.xs` (mole fractions) is used to perform this conversion. If the instance variable `self.vectorized` is True, the output is converted into a NumPy array for efficiency. The method is designed for use within the context of the `GibbsExcess` class, which models liquid phase behavior based on activity coefficients.",
        "signature": "def d2nGE_dninjs(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dgammas_dns": {
        "code": "    def dgammas_dns(self):\n        \"\"\"Calculate and return the mole number derivative of activity coefficients for a liquid phase using an activity coefficient model.\n\nThis method computes the mole number derivatives of activity coefficients, denoted as \\\\(\\\\frac{\\\\partial \\\\gamma_i}{\\\\partial n_i}\\\\), utilizing the second partial derivatives of the excess Gibbs energy, \\\\(G^E\\\\). The calculation depends on the components' mole fractions (`xs`), the current activity coefficients (`gammas`), and the second derivatives of excess Gibbs energy with respect to mole fractions (`d2GE_dxixjs`).\n\nReturns\n-------\ndgammas_dns : list[list[float]]\n    A two-dimensional list representing the mole number derivatives of activity coefficients, expressed in units of [1/mol].\n\nNotes\n-----\nThis method utilizes the `gammas()` method to retrieve the current activity coefficients and the `d2GE_dxixjs()` method to compute the necessary second derivatives of \\\\(G^E\\\\). The output is cached in the `_dgammas_dns` attribute for efficiency, ensuring that future calls do not recompute the value unnecessarily.\"\"\"\n        'Calculate and return the mole number derivative of activity\\n        coefficients of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial \\\\gamma_i}{\\\\partial n_i} = \\\\gamma_i\\n            \\\\left(\\\\frac{\\\\frac{\\\\partial^2 G^E}{\\\\partial x_i \\\\partial x_j}}{RT}\\\\right)\\n\\n        Returns\\n        -------\\n        dgammas_dns : list[list[float]]\\n            Mole number derivatives of activity coefficients, [1/mol]\\n\\n        Notes\\n        -----\\n        '\n        try:\n            return self._dgammas_dns\n        except AttributeError:\n            pass\n        gammas = self.gammas()\n        N = self.N\n        xs = self.xs\n        d2GE_dxixjs = self.d2GE_dxixjs()\n        dgammas_dns = [[0.0] * N for _ in range(N)] if not self.vectorized else zeros((N, N))\n        dgammas_dns = gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, self.T, dgammas_dns)\n        if self.vectorized and type(dgammas_dns) is list:\n            dgammas_dns = array(dgammas_dns)\n        self._dgammas_dns = dgammas_dns\n        return dgammas_dns",
        "docstring": "Calculate and return the mole number derivative of activity coefficients for a liquid phase using an activity coefficient model.\n\nThis method computes the mole number derivatives of activity coefficients, denoted as \\(\\frac{\\partial \\gamma_i}{\\partial n_i}\\), utilizing the second partial derivatives of the excess Gibbs energy, \\(G^E\\). The calculation depends on the components' mole fractions (`xs`), the current activity coefficients (`gammas`), and the second derivatives of excess Gibbs energy with respect to mole fractions (`d2GE_dxixjs`).\n\nReturns\n-------\ndgammas_dns : list[list[float]]\n    A two-dimensional list representing the mole number derivatives of activity coefficients, expressed in units of [1/mol].\n\nNotes\n-----\nThis method utilizes the `gammas()` method to retrieve the current activity coefficients and the `d2GE_dxixjs()` method to compute the necessary second derivatives of \\(G^E\\). The output is cached in the `_dgammas_dns` attribute for efficiency, ensuring that future calls do not recompute the value unnecessarily.",
        "signature": "def dgammas_dns(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "GibbsExcess.dgammas_dT": {
        "code": "    def dgammas_dT(self):\n        \"\"\"Calculate and return the temperature derivatives of activity coefficients of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature derivatives of the activity coefficients (\\\\(\\\\gamma_i\\\\)) based on the excess Gibbs energy (\\\\(G^E\\\\)). The equation utilized is:\n\n\\\\[\n\\\\frac{\\\\partial \\\\gamma_i}{\\\\partial T} =\n\\\\left(\\\\frac{\\\\frac{\\\\partial^2 n G^E}{\\\\partial T \\\\partial n_i}}{RT} -\n\\\\frac{{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}}{RT^2}\\\\right)\n\\\\exp\\\\left(\\\\frac{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}{RT}\\\\right)\n\\\\]\n\nwhere:\n- \\\\(R\\\\) is the universal gas constant from the `fluids.constants` module.\n- \\\\(T\\\\) is the temperature of the system.\n- \\\\(xs\\\\) are the mole fractions of the components in the liquid phase.\n- \\\\(dGE_dT\\\\) is the first temperature derivative of excess Gibbs energy, computed by calling `self.dGE_dT()`.\n- \\\\(GE\\\\) is the excess Gibbs energy, obtained from `self.GE()`.\n- \\\\(dG_dxs\\\\) and \\\\(d2GE_dTdxs\\\\) are obtained through methods `self.dGE_dxs()` and `self.d2GE_dTdxs()`, respectively.\n\nReturns\n-------\ndgammas_dT : list[float]\n    The temperature derivatives of activity coefficients, measured in \\\\(1/K\\\\).\n\nThis method utilizes memoization with the attribute `_dgammas_dT` to cache results for efficiency. It interacts with the overall GibbsExcess class, relying on its methods to compute the required derivatives of the Gibbs energy.\"\"\"\n        'Calculate and return the temperature derivatives of activity\\n        coefficients of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial \\\\gamma_i}{\\\\partial T} =\\n            \\\\left(\\\\frac{\\\\frac{\\\\partial^2 n G^E}{\\\\partial T \\\\partial n_i}}{RT} -\\n            \\\\frac{{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}}{RT^2}\\\\right)\\n             \\\\exp\\\\left(\\\\frac{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}{RT}\\\\right)\\n\\n        Returns\\n        -------\\n        dgammas_dT : list[float]\\n            Temperature derivatives of activity coefficients, [1/K]\\n\\n        Notes\\n        -----\\n        '\n        \"\\n        from sympy import *\\n        R, T = symbols('R, T')\\n        f = symbols('f', cls=Function)\\n        diff(exp(f(T)/(R*T)), T)\\n        \"\n        try:\n            return self._dgammas_dT\n        except AttributeError:\n            pass\n        N, T, xs = (self.N, self.T, self.xs)\n        dGE_dT = self.dGE_dT()\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        d2GE_dTdxs = self.d2GE_dTdxs()\n        dgammas_dT = gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T)\n        if self.vectorized and type(dgammas_dT) is list:\n            dgammas_dT = array(dgammas_dT)\n        self._dgammas_dT = dgammas_dT\n        return dgammas_dT",
        "docstring": "Calculate and return the temperature derivatives of activity coefficients of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature derivatives of the activity coefficients (\\(\\gamma_i\\)) based on the excess Gibbs energy (\\(G^E\\)). The equation utilized is:\n\n\\[\n\\frac{\\partial \\gamma_i}{\\partial T} =\n\\left(\\frac{\\frac{\\partial^2 n G^E}{\\partial T \\partial n_i}}{RT} -\n\\frac{{\\frac{\\partial n_i G^E}{\\partial n_i }}}{RT^2}\\right)\n\\exp\\left(\\frac{\\frac{\\partial n_i G^E}{\\partial n_i }}{RT}\\right)\n\\]\n\nwhere:\n- \\(R\\) is the universal gas constant from the `fluids.constants` module.\n- \\(T\\) is the temperature of the system.\n- \\(xs\\) are the mole fractions of the components in the liquid phase.\n- \\(dGE_dT\\) is the first temperature derivative of excess Gibbs energy, computed by calling `self.dGE_dT()`.\n- \\(GE\\) is the excess Gibbs energy, obtained from `self.GE()`.\n- \\(dG_dxs\\) and \\(d2GE_dTdxs\\) are obtained through methods `self.dGE_dxs()` and `self.d2GE_dTdxs()`, respectively.\n\nReturns\n-------\ndgammas_dT : list[float]\n    The temperature derivatives of activity coefficients, measured in \\(1/K\\).\n\nThis method utilizes memoization with the attribute `_dgammas_dT` to cache results for efficiency. It interacts with the overall GibbsExcess class, relying on its methods to compute the required derivatives of the Gibbs energy.",
        "signature": "def dgammas_dT(self):",
        "type": "Method",
        "class_signature": "class GibbsExcess:"
      },
      "IdealSolution.__init__": {
        "code": "    def __init__(self, *, xs, T=GibbsExcess.T_DEFAULT):\n        \"\"\"Initialize an IdealSolution instance, representing an ideal liquid with no excess Gibbs energy and activity coefficients equal to one.\n\nParameters\n----------\nT : float, optional\n    Temperature of the solution in Kelvin. Defaults to GibbsExcess.T_DEFAULT, which is 298.15 K.\nxs : list[float]\n    List of mole fractions of the components in the solution. The length of this list defines the number of components (N).\n\nAttributes\n----------\nT : float\n    The temperature of the mixture.\nxs : list[float]\n    The mole fractions of the components.\nN : int\n    The number of components in the mixture.\nvectorized : bool\n    A flag indicating whether the mole fractions are provided in a vectorized form (numpy array) or as a standard list.\n\nNotes\n-----\nThis constructor defines the essential properties for an ideal solution model, where the excess Gibbs energy is zero and the activity coefficients are unity. The initialization of the temperature (T) uses the constant T_DEFAULT from the GibbsExcess class, ensuring a standard default value if not specified.\"\"\"\n        self.T = T\n        self.xs = xs\n        self.N = len(xs)\n        self.vectorized = type(xs) is not list",
        "docstring": "Initialize an IdealSolution instance, representing an ideal liquid with no excess Gibbs energy and activity coefficients equal to one.\n\nParameters\n----------\nT : float, optional\n    Temperature of the solution in Kelvin. Defaults to GibbsExcess.T_DEFAULT, which is 298.15 K.\nxs : list[float]\n    List of mole fractions of the components in the solution. The length of this list defines the number of components (N).\n\nAttributes\n----------\nT : float\n    The temperature of the mixture.\nxs : list[float]\n    The mole fractions of the components.\nN : int\n    The number of components in the mixture.\nvectorized : bool\n    A flag indicating whether the mole fractions are provided in a vectorized form (numpy array) or as a standard list.\n\nNotes\n-----\nThis constructor defines the essential properties for an ideal solution model, where the excess Gibbs energy is zero and the activity coefficients are unity. The initialization of the temperature (T) uses the constant T_DEFAULT from the GibbsExcess class, ensuring a standard default value if not specified.",
        "signature": "def __init__(self, *, xs, T=GibbsExcess.T_DEFAULT):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.to_T_xs": {
        "code": "    def to_T_xs(self, T, xs):\n        \"\"\"Method to create a new instance of the `IdealSolution` class at a specified temperature and mole fractions, preserving the original object's parameters.\n\nParameters\n----------\nT : float\n    The new temperature of the solution, specified in Kelvin [K].\nxs : list[float]\n    A list of the new mole fractions for each component, where each value is in the range [0, 1] and their sum equals 1.\n\nReturns\n-------\nobj : IdealSolution\n    A new `IdealSolution` object initialized with the provided temperature and mole fractions.\n\nNotes\n-----\nThis method facilitates the construction of a `IdealSolution` object that retains the characteristics of the existing instance while adapting to new operating conditions. The `vectorized` attribute is carried over to maintain computational efficiency when using numpy arrays, ensuring consistent array behavior. It is assumed that the list of mole fractions (`xs`) has a length consistent with the number of components denoted by `self.N`, which is determined at the time of the object\u2019s instantiation.\"\"\"\n        'Method to construct a new :obj:`IdealSolution` instance at\\n        temperature `T`, and mole fractions `xs`\\n        with the same parameters as the existing object.\\n\\n        Parameters\\n        ----------\\n        T : float\\n            Temperature, [K]\\n        xs : list[float]\\n            Mole fractions of each component, [-]\\n\\n        Returns\\n        -------\\n        obj : IdealSolution\\n            New :obj:`IdealSolution` object at the specified conditions [-]\\n\\n        Notes\\n        -----\\n\\n        Examples\\n        --------\\n        >>> p = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\\n        >>> p.to_T_xs(T=500.0, xs=[.25, .25, .25, .25])\\n        IdealSolution(T=500.0, xs=[0.25, 0.25, 0.25, 0.25])\\n        '\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.xs = xs\n        new.vectorized = self.vectorized\n        new.N = len(xs)\n        return new",
        "docstring": "Method to create a new instance of the `IdealSolution` class at a specified temperature and mole fractions, preserving the original object's parameters.\n\nParameters\n----------\nT : float\n    The new temperature of the solution, specified in Kelvin [K].\nxs : list[float]\n    A list of the new mole fractions for each component, where each value is in the range [0, 1] and their sum equals 1.\n\nReturns\n-------\nobj : IdealSolution\n    A new `IdealSolution` object initialized with the provided temperature and mole fractions.\n\nNotes\n-----\nThis method facilitates the construction of a `IdealSolution` object that retains the characteristics of the existing instance while adapting to new operating conditions. The `vectorized` attribute is carried over to maintain computational efficiency when using numpy arrays, ensuring consistent array behavior. It is assumed that the list of mole fractions (`xs`) has a length consistent with the number of components denoted by `self.N`, which is determined at the time of the object\u2019s instantiation.",
        "signature": "def to_T_xs(self, T, xs):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.GE": {
        "code": "    def GE(self):\n        \"\"\"Calculate and return the excess Gibbs energy of an ideal liquid phase, which is defined as zero due to the absence of interactions between components.\n\nThis method implements the characteristic behavior of an ideal solution where there are no excess energies contributing to the Gibbs energy, thus returning a constant value of 0.0 J/mol.\n\nReturns\n-------\nGE : float\n    Excess Gibbs energy of an ideal liquid, which is always 0.0 J/mol.\n\nNotes\n-----\nThis functionality is part of the `IdealSolution` class, which represents an ideal liquid solution, and is based on the idea that there are no additional energetic contributions from molecular interactions.\"\"\"\n        'Calculate and return the excess Gibbs energy of a liquid phase\\n        using an activity coefficient model.\\n\\n        .. math::\\n            g^E = 0\\n\\n        Returns\\n        -------\\n        GE : float\\n            Excess Gibbs energy of an ideal liquid, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        return 0.0",
        "docstring": "Calculate and return the excess Gibbs energy of an ideal liquid phase, which is defined as zero due to the absence of interactions between components.\n\nThis method implements the characteristic behavior of an ideal solution where there are no excess energies contributing to the Gibbs energy, thus returning a constant value of 0.0 J/mol.\n\nReturns\n-------\nGE : float\n    Excess Gibbs energy of an ideal liquid, which is always 0.0 J/mol.\n\nNotes\n-----\nThis functionality is part of the `IdealSolution` class, which represents an ideal liquid solution, and is based on the idea that there are no additional energetic contributions from molecular interactions.",
        "signature": "def GE(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.dGE_dT": {
        "code": "    def dGE_dT(self):\n        \"\"\"Calculate and return the temperature derivative of the excess Gibbs energy of an ideal liquid phase, which is defined as having no excess Gibbs energy. \n\nReturns\n-------\ndGE_dT : float\n    The first temperature derivative of excess Gibbs energy, which is always 0.0 J/(mol*K) for an ideal liquid.\n\nNotes\n-----\nThis method reflects the characteristics of an ideal solution where the excess Gibbs energy does not depend on temperature, indicating that the energy exchange is ideal in nature without any non-ideality. It is a part of the IdealSolution class, which extends the GibbsExcess class, specifically modeling behavior where activity coefficients are uniform and set to 1.\"\"\"\n        'Calculate and return the temperature derivative of excess Gibbs\\n        energy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial g^E}{\\\\partial T} = 0\\n\\n        Returns\\n        -------\\n        dGE_dT : float\\n            First temperature derivative of excess Gibbs energy of an\\n            ideal liquid, [J/(mol*K)]\\n\\n        Notes\\n        -----\\n        '\n        return 0.0",
        "docstring": "Calculate and return the temperature derivative of the excess Gibbs energy of an ideal liquid phase, which is defined as having no excess Gibbs energy. \n\nReturns\n-------\ndGE_dT : float\n    The first temperature derivative of excess Gibbs energy, which is always 0.0 J/(mol*K) for an ideal liquid.\n\nNotes\n-----\nThis method reflects the characteristics of an ideal solution where the excess Gibbs energy does not depend on temperature, indicating that the energy exchange is ideal in nature without any non-ideality. It is a part of the IdealSolution class, which extends the GibbsExcess class, specifically modeling behavior where activity coefficients are uniform and set to 1.",
        "signature": "def dGE_dT(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.d2GE_dT2": {
        "code": "    def d2GE_dT2(self):\n        \"\"\"Calculate and return the second derivative of the excess Gibbs energy (\\\\(g^E\\\\)) with respect to temperature for an ideal liquid phase. In an ideal solution, this derivative is always zero due to the absence of excess Gibbs energy contributions, indicating that the excess properties are independent of temperature. \n\nReturns\n-------\nd2GE_dT2 : float\n    The second temperature derivative of excess Gibbs energy of an ideal liquid, always equal to 0, expressed in units of [J/(mol*K^2)].\"\"\"\n        'Calculate and return the second temperature derivative of excess\\n        Gibbs energy of a liquid phase using an activity coefficient model.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 g^E}{\\\\partial T^2} = 0\\n\\n        Returns\\n        -------\\n        d2GE_dT2 : float\\n            Second temperature derivative of excess Gibbs energy of an\\n            ideal liquid, [J/(mol*K^2)]\\n\\n        Notes\\n        -----\\n        '\n        return 0.0",
        "docstring": "Calculate and return the second derivative of the excess Gibbs energy (\\(g^E\\)) with respect to temperature for an ideal liquid phase. In an ideal solution, this derivative is always zero due to the absence of excess Gibbs energy contributions, indicating that the excess properties are independent of temperature. \n\nReturns\n-------\nd2GE_dT2 : float\n    The second temperature derivative of excess Gibbs energy of an ideal liquid, always equal to 0, expressed in units of [J/(mol*K^2)].",
        "signature": "def d2GE_dT2(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.d2GE_dTdxs": {
        "code": "    def d2GE_dTdxs(self):\n        \"\"\"Calculate and return the second temperature derivative of the excess Gibbs energy with respect to mole fractions for an ideal liquid solution.\n\nThis method returns the derivative of the mole fraction derivatives of excess Gibbs energy, which is zero for an ideal liquid. The output is a list of zeros reflecting the nature of ideal behavior.\n\nReturns\n-------\nd2GE_dTdxs : list[float]\n    A list containing zero values for each component, representing the second temperature derivatives of excess Gibbs energy of an ideal liquid, [J/(mol*K)].\n\nNotes\n-----\nThis method leverages the class attribute `N` to determine the number of components and checks if the instance is vectorized. If not, a list of zeros is returned; otherwise, a NumPy array of zeros is returned. The `zeros` function is used from the NumPy library, ensuring that the output maintains the appropriate data type for further calculations in thermodynamic analyses.\"\"\"\n        'Calculate and return the temperature derivative of mole fraction\\n        derivatives of excess Gibbs energy of an ideal liquid.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 g^E}{\\\\partial x_i \\\\partial T} = 0\\n\\n        Returns\\n        -------\\n        d2GE_dTdxs : list[float]\\n            Temperature derivative of mole fraction derivatives of excess Gibbs\\n            energy of an ideal liquid, [J/(mol*K)]\\n\\n        Notes\\n        -----\\n        '\n        if not self.vectorized:\n            return [0.0] * self.N\n        return zeros(self.N)",
        "docstring": "Calculate and return the second temperature derivative of the excess Gibbs energy with respect to mole fractions for an ideal liquid solution.\n\nThis method returns the derivative of the mole fraction derivatives of excess Gibbs energy, which is zero for an ideal liquid. The output is a list of zeros reflecting the nature of ideal behavior.\n\nReturns\n-------\nd2GE_dTdxs : list[float]\n    A list containing zero values for each component, representing the second temperature derivatives of excess Gibbs energy of an ideal liquid, [J/(mol*K)].\n\nNotes\n-----\nThis method leverages the class attribute `N` to determine the number of components and checks if the instance is vectorized. If not, a list of zeros is returned; otherwise, a NumPy array of zeros is returned. The `zeros` function is used from the NumPy library, ensuring that the output maintains the appropriate data type for further calculations in thermodynamic analyses.",
        "signature": "def d2GE_dTdxs(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.dGE_dxs": {
        "code": "    def dGE_dxs(self):\n        \"\"\"Calculate and return the mole fraction derivatives of excess Gibbs energy of an ideal liquid, where the excess Gibbs energy is defined to be zero. This method reflects the characteristics of an ideal solution, indicating that the change in excess Gibbs energy with respect to the mole fraction of any component is zero.\n\nReturns\n-------\ndGE_dxs : list[float]\n    A list of zeroes corresponding to each component's mole fraction derivative of excess Gibbs energy, [J/mol]. The length of the list equals the number of components (self.N).\n\nNotes\n-----\nThe method checks if the `self.vectorized` attribute, which determines if the calculations are vectorized for performance. If the calculation is not vectorized, a list of zeroes is returned, while if it is vectorized, a NumPy array of zeroes of length self.N is created and returned.\"\"\"\n        'Calculate and return the mole fraction derivatives of excess Gibbs\\n        energy of an ideal liquid.\\n\\n        .. math::\\n            \\\\frac{\\\\partial g^E}{\\\\partial x_i} = 0\\n\\n        Returns\\n        -------\\n        dGE_dxs : list[float]\\n            Mole fraction derivatives of excess Gibbs energy of an ideal\\n            liquid, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        if not self.vectorized:\n            return [0.0] * self.N\n        return zeros(self.N)",
        "docstring": "Calculate and return the mole fraction derivatives of excess Gibbs energy of an ideal liquid, where the excess Gibbs energy is defined to be zero. This method reflects the characteristics of an ideal solution, indicating that the change in excess Gibbs energy with respect to the mole fraction of any component is zero.\n\nReturns\n-------\ndGE_dxs : list[float]\n    A list of zeroes corresponding to each component's mole fraction derivative of excess Gibbs energy, [J/mol]. The length of the list equals the number of components (self.N).\n\nNotes\n-----\nThe method checks if the `self.vectorized` attribute, which determines if the calculations are vectorized for performance. If the calculation is not vectorized, a list of zeroes is returned, while if it is vectorized, a NumPy array of zeroes of length self.N is created and returned.",
        "signature": "def dGE_dxs(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.d2GE_dxixjs": {
        "code": "    def d2GE_dxixjs(self):\n        \"\"\"Calculate and return the second mole fraction derivatives of excess Gibbs energy for an ideal liquid.\n\nThis method computes the second partial derivative of the excess Gibbs energy \\\\( g^E \\\\) with respect to the mole fractions \\\\( x_i \\\\) and \\\\( x_j \\\\) of the components in a liquid mixture. For an ideal solution, this derivative is always zero, indicating that the Gibbs energy does not change with variations in the composition.\n\nReturns\n-------\nd2GE_dxixjs : list[list[float]]\n    A 2D list (matrix) of zeros, where each entry represents the second derivatives of excess Gibbs energy with respect to mole fractions, shaped as \\\\( N \\\\times N \\\\), where \\\\( N \\\\) is the number of components in the liquid phase.\n\nNotes\n-----\nThe method relies on the attribute `N`, which is the number of mole fractions defined in the class, and `vectorized`, which determines if the calculations should leverage NumPy for efficient computation. If not vectorized, a nested list of zeros is generated. The NumPy `zeros` function is used to create the output in a vectorized context, improving performance for larger systems.\"\"\"\n        'Calculate and return the second mole fraction derivatives of excess\\n        Gibbs energy of an ideal liquid.\\n\\n        .. math::\\n            \\\\frac{\\\\partial^2 g^E}{\\\\partial x_i \\\\partial x_j} = 0\\n\\n        Returns\\n        -------\\n        d2GE_dxixjs : list[list[float]]\\n            Second mole fraction derivatives of excess Gibbs energy of an ideal\\n            liquid, [J/mol]\\n\\n        Notes\\n        -----\\n        '\n        N = self.N\n        if not self.vectorized:\n            return [[0.0] * N for i in range(self.N)]\n        return zeros((N, N))",
        "docstring": "Calculate and return the second mole fraction derivatives of excess Gibbs energy for an ideal liquid.\n\nThis method computes the second partial derivative of the excess Gibbs energy \\( g^E \\) with respect to the mole fractions \\( x_i \\) and \\( x_j \\) of the components in a liquid mixture. For an ideal solution, this derivative is always zero, indicating that the Gibbs energy does not change with variations in the composition.\n\nReturns\n-------\nd2GE_dxixjs : list[list[float]]\n    A 2D list (matrix) of zeros, where each entry represents the second derivatives of excess Gibbs energy with respect to mole fractions, shaped as \\( N \\times N \\), where \\( N \\) is the number of components in the liquid phase.\n\nNotes\n-----\nThe method relies on the attribute `N`, which is the number of mole fractions defined in the class, and `vectorized`, which determines if the calculations should leverage NumPy for efficient computation. If not vectorized, a nested list of zeros is generated. The NumPy `zeros` function is used to create the output in a vectorized context, improving performance for larger systems.",
        "signature": "def d2GE_dxixjs(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      },
      "IdealSolution.gammas": {
        "code": "    def gammas(self):\n        \"\"\"Calculate and return the activity coefficients of a liquid phase for an ideal solution. In an ideal solution, the activity coefficients for all components are equal to 1, indicating no deviation from ideal behavior.\n\nReturns\n-------\ngammas : list[float]\n    Activity coefficients for each component, which are always 1.0 for an ideal solution.\n\nNotes\n-----\nThis method checks if the instance is vectorized (i.e., if the mole fractions are stored in a NumPy array). If not, it returns a list of 1.0 for each component. If vectorized, it returns a NumPy array of ones with a length equal to the number of components, self.N, which is determined during initialization of the IdealSolution instance.\"\"\"\n        if not self.vectorized:\n            return [1.0] * self.N\n        else:\n            return ones(self.N)",
        "docstring": "Calculate and return the activity coefficients of a liquid phase for an ideal solution. In an ideal solution, the activity coefficients for all components are equal to 1, indicating no deviation from ideal behavior.\n\nReturns\n-------\ngammas : list[float]\n    Activity coefficients for each component, which are always 1.0 for an ideal solution.\n\nNotes\n-----\nThis method checks if the instance is vectorized (i.e., if the mole fractions are stored in a NumPy array). If not, it returns a list of 1.0 for each component. If vectorized, it returns a NumPy array of ones with a length equal to the number of components, self.N, which is determined during initialization of the IdealSolution instance.",
        "signature": "def gammas(self):",
        "type": "Method",
        "class_signature": "class IdealSolution(GibbsExcess):"
      }
    },
    "thermo/phases/iapws_phase.py": {},
    "thermo/test_utils.py": {
      "check_np_output_activity": {
        "code": "def check_np_output_activity(model, modelnp, modelnp2):\n    \"\"\"Checks the output of activity-related calculations from various model types to ensure consistency between a scalar list-based model and its NumPy and NumPy-based variants. \n\nParameters:\n- model: An instance of a scalar, list-based model that calculates various thermodynamic properties.\n- modelnp: A NumPy-optimized model instance, often created using Numba for performance.\n- modelnp2: Another NumPy-based model instance created from `modelnp` at a different composition, allowing for validation of output consistency across different states.\n\nThe function tests several attributes, including scalar, vector, and matrix outputs, comparing results with a specified relative tolerance (`rtol`) to assert close proximity of results using the `assert_close`, `assert_close1d`, `assert_close2d`, and `assert_close3d` functions imported from the `fluids.numerics` module. It also checks the types of the returned values to ensure they are as expected: floats, lists, and NumPy arrays. \n\nConstants:\n- rtol: Relative tolerance values defined within the function (2e-13 and 1e-12) to determine acceptable levels of numerical accuracy when comparing outputs.\n- GibbsExcess: A class from the `thermo.activity` module used to handle calculations of excess Gibbs energy and its derivatives, providing necessary functionality for certain attributes checked.\"\"\"\n    scalar_attrs = ['d3GE_dT3', 'd2GE_dT2', 'GE', 'dGE_dT']\n    for attr in scalar_attrs:\n        if hasattr(model, attr):\n            assert_close(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n            assert_close(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n            assert type(getattr(model, attr)()) is float\n    vec_attrs = ['dGE_dxs', 'gammas', 'gammas_dGE_dxs', 'd2GE_dTdxs', 'dHE_dxs', 'gammas_infinite_dilution', 'dHE_dns', 'dnHE_dns', 'dSE_dxs', 'dSE_dns', 'dnSE_dns', 'dGE_dns', 'dnGE_dns', 'd2GE_dTdns', 'd2nGE_dTdns', 'dgammas_dT']\n    for attr in vec_attrs:\n        assert_close1d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n        assert_close1d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=2e-13)\n        assert type(getattr(model, attr)()) is list\n        assert type(getattr(modelnp, attr)()) is np.ndarray\n        assert type(getattr(modelnp2, attr)()) is np.ndarray\n    mat_attrs = ['d2GE_dxixjs', 'd2nGE_dninjs', 'dgammas_dns']\n    for attr in mat_attrs:\n        if model.__class__.d2GE_dxixjs is GibbsExcess.d2GE_dxixjs_numerical:\n            continue\n        assert_close2d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=1e-12)\n        assert_close2d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=1e-12)\n        assert type(getattr(model, attr)()) is list\n        assert type(getattr(modelnp, attr)()) is np.ndarray\n        assert type(getattr(modelnp2, attr)()) is np.ndarray\n    attrs_3d = ['d3GE_dxixjxks']\n    for attr in attrs_3d:\n        if hasattr(model, attr):\n            assert_close3d(getattr(model, attr)(), getattr(modelnp, attr)(), rtol=1e-13)\n            assert_close3d(getattr(modelnp2, attr)(), getattr(modelnp, attr)(), rtol=1e-13)\n            assert type(getattr(model, attr)()) is list\n            assert type(getattr(modelnp, attr)()) is np.ndarray\n            assert type(getattr(modelnp2, attr)()) is np.ndarray",
        "docstring": "Checks the output of activity-related calculations from various model types to ensure consistency between a scalar list-based model and its NumPy and NumPy-based variants. \n\nParameters:\n- model: An instance of a scalar, list-based model that calculates various thermodynamic properties.\n- modelnp: A NumPy-optimized model instance, often created using Numba for performance.\n- modelnp2: Another NumPy-based model instance created from `modelnp` at a different composition, allowing for validation of output consistency across different states.\n\nThe function tests several attributes, including scalar, vector, and matrix outputs, comparing results with a specified relative tolerance (`rtol`) to assert close proximity of results using the `assert_close`, `assert_close1d`, `assert_close2d`, and `assert_close3d` functions imported from the `fluids.numerics` module. It also checks the types of the returned values to ensure they are as expected: floats, lists, and NumPy arrays. \n\nConstants:\n- rtol: Relative tolerance values defined within the function (2e-13 and 1e-12) to determine acceptable levels of numerical accuracy when comparing outputs.\n- GibbsExcess: A class from the `thermo.activity` module used to handle calculations of excess Gibbs energy and its derivatives, providing necessary functionality for certain attributes checked.",
        "signature": "def check_np_output_activity(model, modelnp, modelnp2):",
        "type": "Function",
        "class_signature": null
      }
    },
    "thermo/phases/gibbs_excess.py": {}
  },
  "dependency_dict": {
    "thermo/activity.py:GibbsExcess:dHE_dT": {},
    "thermo/activity.py:GibbsExcess:HE": {},
    "thermo/activity.py:GibbsExcess:SE": {},
    "thermo/activity.py:GibbsExcess:d2GE_dTdns": {},
    "thermo/activity.py:GibbsExcess:d2nGE_dTdns": {},
    "thermo/activity.py:GibbsExcess:d2nGE_dninjs": {},
    "thermo/activity.py:GibbsExcess:dGE_dns": {},
    "thermo/activity.py:GibbsExcess:dHE_dns": {},
    "thermo/activity.py:GibbsExcess:dSE_dT": {},
    "thermo/activity.py:GibbsExcess:dSE_dns": {},
    "thermo/activity.py:GibbsExcess:dgammas_dT": {
      "thermo/activity.py": {
        "gibbs_excess_dgammas_dT": {
          "code": "def gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T, dgammas_dT=None):\n    if dgammas_dT is None:\n        dgammas_dT = [0.0] * N\n    xdx_totF0 = dGE_dT\n    for j in range(N):\n        xdx_totF0 -= xs[j] * d2GE_dTdxs[j]\n    xdx_totF1 = GE\n    for j in range(N):\n        xdx_totF1 -= xs[j] * dG_dxs[j]\n    T_inv = 1.0 / T\n    RT_inv = R_inv * T_inv\n    for i in range(N):\n        dG_dni = xdx_totF1 + dG_dxs[i]\n        dgammas_dT[i] = RT_inv * (d2GE_dTdxs[i] - dG_dni * T_inv + xdx_totF0) * exp(dG_dni * RT_inv)\n    return dgammas_dT",
          "docstring": "",
          "signature": "def gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T, dgammas_dT=None):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "thermo/activity.py:GibbsExcess:dgammas_dns": {
      "thermo/activity.py": {
        "gibbs_excess_dgammas_dns": {
          "code": "def gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, T, dgammas_dns=None, vec0=None):\n    if vec0 is None:\n        vec0 = [0.0] * N\n    if dgammas_dns is None:\n        dgammas_dns = [[0.0] * N for _ in range(N)]\n    for j in range(N):\n        tot = 0.0\n        row = d2GE_dxixjs[j]\n        for k in range(N):\n            tot += xs[k] * row[k]\n        vec0[j] = tot\n    RT_inv = R_inv / T\n    for i in range(N):\n        gammai_RT = gammas[i] * RT_inv\n        for j in range(N):\n            dgammas_dns[i][j] = gammai_RT * (d2GE_dxixjs[i][j] - vec0[j])\n    return dgammas_dns",
          "docstring": "",
          "signature": "def gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, T, dgammas_dns=None, vec0=None):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "thermo/activity.py:GibbsExcess:dnGE_dns": {},
    "thermo/activity.py:GibbsExcess:dnHE_dns": {},
    "thermo/activity.py:GibbsExcess:dnSE_dns": {},
    "thermo/test_utils.py:check_np_output_activity": {
      "thermo/activity.py": {
        "GibbsExcess.gammas_infinite_dilution": {
          "code": "    def gammas_infinite_dilution(self):\n        \"\"\"Calculate and return the infinite dilution activity coefficients\n        of each component.\n\n        Returns\n        -------\n        gammas_infinite : list[float]\n            Infinite dilution activity coefficients, [-]\n\n        Notes\n        -----\n        The algorithm is as follows. For each component, set its composition to\n        zero. Normalize the remaining compositions to 1. Create a new object\n        with that composition, and calculate the activity coefficient of the\n        component whose concentration was set to zero.\n        \"\"\"\n        T, N = (self.T, self.N)\n        xs_base = self.xs\n        x_infinite_dilution = self._x_infinite_dilution\n        if not self.vectorized:\n            gammas_inf = [0.0] * N\n            copy_fun = list\n        else:\n            gammas_inf = zeros(N)\n            copy_fun = array\n        for i in range(N):\n            xs = copy_fun(xs_base)\n            xs[i] = x_infinite_dilution\n            xs = normalize(xs)\n            gammas_inf[i] = self.to_T_xs(T, xs=xs).gammas()[i]\n        return gammas_inf",
          "docstring": "Calculate and return the infinite dilution activity coefficients\nof each component.\n\nReturns\n-------\ngammas_infinite : list[float]\n    Infinite dilution activity coefficients, [-]\n\nNotes\n-----\nThe algorithm is as follows. For each component, set its composition to\nzero. Normalize the remaining compositions to 1. Create a new object\nwith that composition, and calculate the activity coefficient of the\ncomponent whose concentration was set to zero.",
          "signature": "def gammas_infinite_dilution(self):",
          "type": "Method",
          "class_signature": "class GibbsExcess:"
        },
        "GibbsExcess.gammas_dGE_dxs": {
          "code": "    def gammas_dGE_dxs(self):\n        try:\n            del self._gammas\n        except:\n            pass\n        return GibbsExcess.gammas(self)",
          "docstring": "",
          "signature": "def gammas_dGE_dxs(self):",
          "type": "Method",
          "class_signature": "class GibbsExcess:"
        },
        "IdealSolution.d3GE_dT3": {
          "code": "    def d3GE_dT3(self):\n        \"\"\"Calculate and return the third temperature derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\\\frac{\\\\partial^3 g^E}{\\\\partial T^3} = 0\n\n        Returns\n        -------\n        d3GE_dT3 : float\n            Third temperature derivative of excess Gibbs energy of an ideal\n            liquid, [J/(mol*K^3)]\n\n        Notes\n        -----\n        \"\"\"\n        return 0.0",
          "docstring": "Calculate and return the third temperature derivative of excess\nGibbs energy of a liquid phase using an activity coefficient model.\n\n.. math::\n    \\frac{\\partial^3 g^E}{\\partial T^3} = 0\n\nReturns\n-------\nd3GE_dT3 : float\n    Third temperature derivative of excess Gibbs energy of an ideal\n    liquid, [J/(mol*K^3)]\n\nNotes\n-----",
          "signature": "def d3GE_dT3(self):",
          "type": "Method",
          "class_signature": "class IdealSolution(GibbsExcess):"
        },
        "IdealSolution.d3GE_dxixjxks": {
          "code": "    def d3GE_dxixjxks(self):\n        \"\"\"Calculate and return the third mole fraction derivatives of excess\n        Gibbs energy of an ideal liquid.\n\n        .. math::\n            \\\\frac{\\\\partial^3 g^E}{\\\\partial x_i \\\\partial x_j \\\\partial x_k} = 0\n\n        Returns\n        -------\n        d3GE_dxixjxks : list[list[list[float]]]\n            Third mole fraction derivatives of excess Gibbs energy of an ideal\n            liquid, [J/mol]\n\n        Notes\n        -----\n        \"\"\"\n        N = self.N\n        if not self.vectorized:\n            return [[[0.0] * N for i in range(N)] for j in range(N)]\n        return zeros((N, N, N))",
          "docstring": "Calculate and return the third mole fraction derivatives of excess\nGibbs energy of an ideal liquid.\n\n.. math::\n    \\frac{\\partial^3 g^E}{\\partial x_i \\partial x_j \\partial x_k} = 0\n\nReturns\n-------\nd3GE_dxixjxks : list[list[list[float]]]\n    Third mole fraction derivatives of excess Gibbs energy of an ideal\n    liquid, [J/mol]\n\nNotes\n-----",
          "signature": "def d3GE_dxixjxks(self):",
          "type": "Method",
          "class_signature": "class IdealSolution(GibbsExcess):"
        }
      }
    },
    "thermo/activity.py:GibbsExcess:as_json": {
      "thermo/serialize.py": {
        "JsonOptEncodable.as_json": {
          "code": "    def as_json(self, cache=None, option=0):\n        # id_to_num_str: id: \"pyid_{num}\" where num is the length of the array plus 1 at the time of creation\n        # I also want another dict, num_to_object, which contains num: object_serialization\n        # When encountering an object, add it to id_to_num_str. Store the string reference to it.\n        # Also add it to num_to_object.\n        # Hope this works!\n\n        base_serializer = cache is None\n        if base_serializer:\n            num_to_object = {\"pyid_0\": None} # will get replaced, this contains the output dictionary\n            id_to_num_str = {id(self): \"pyid_0\"}\n            cache = (num_to_object, id_to_num_str)\n        else:\n            num_to_object, id_to_num_str = cache\n\n        d = object_data(self)\n        for attr in self.non_json_attributes:\n            try:\n                del d[attr]\n            except:\n                pass\n        if option & JSON_DROP_RECALCULABLE:\n            try:\n                for attr in self.recalculable_attributes:\n                    try:\n                        del d[attr]\n                    except:\n                        pass\n            except:\n                pass\n\n\n        search_recurse = self.obj_references if self.obj_references is not None else list(d.keys())\n        # search_recurse = set(self.obj_references).intersection(d)\n\n        for obj_name in search_recurse:\n            try:\n                o = d[obj_name]\n            except:\n                continue\n            t = type(o)\n            if t in primitive_serialization_types_no_containers:\n                continue\n            # We support recursing into lists of expected object references but no further\n            if t is list:\n                # print(obj_name, o)\n                json_obj_list = []\n                for v in o:\n                    if id(v) in id_to_num_str:\n                        num_str = id_to_num_str[id(v)]\n                    else:\n                        num = len(id_to_num_str) # May change as we do as_json so we must re-check the length\n                        num_str = f'pyid_{num}'\n                        id_to_num_str[id(v)] = num_str # we must claim the number first\n                        num_to_object[num_str] = v.as_json(cache)\n                    json_obj_list.append(num_str)\n                d[obj_name] = json_obj_list\n            elif t is dict:\n                json_obj_dict = {}\n                for k, v in o.items():\n                    if id(v) in id_to_num_str:\n                        num_str = id_to_num_str[id(v)]\n                    else:\n                        num = len(id_to_num_str) # May change as we do as_json so we must re-check the length\n                        num_str = f'pyid_{num}'\n                        id_to_num_str[id(v)] = num_str # we must claim the number first\n                        num_to_object[num_str] = v.as_json(cache)\n                    json_obj_dict[k] = num_str\n                d[obj_name] = json_obj_dict\n            else:\n                # Assume it's one item for performance, only other type is tuple and that's not json-able\n                if id(o) in id_to_num_str:\n                    num_str = id_to_num_str[id(o)]\n                else:\n                    num = len(id_to_num_str) # May change as we do as_json so we must re-check the length\n                    num_str = f'pyid_{num}'\n                    id_to_num_str[id(o)] = num_str\n                    num_to_object[num_str] = o.as_json(cache)\n                d[obj_name] = num_str\n\n        if self.vectorized:\n            d = arrays_to_lists(d)\n        d[\"py/object\"] = self.__full_path__\n        d['json_version'] = self.json_version\n\n        if hasattr(self, '_custom_as_json'):\n            self._custom_as_json(d, cache)\n\n        if base_serializer:\n            num_to_object[\"pyid_0\"] = d\n            return num_to_object\n        return d",
          "docstring": "",
          "signature": "def as_json(self, cache=None, option=0):",
          "type": "Method",
          "class_signature": "class JsonOptEncodable:"
        }
      }
    },
    "thermo/activity.py:GibbsExcess:from_json": {
      "thermo/serialize.py": {
        "JsonOptEncodable.from_json": {
          "code": "    def from_json(cls, json_repr, cache=None, ref_name='pyid_0'):\n        if cache is None:\n            cache = {}\n        d = json_repr[ref_name]\n        num_to_object = json_repr\n        class_name = d['py/object']\n        json_version = d['json_version']\n        del d['py/object']\n        del d['json_version']\n        original_obj = object_lookups[class_name]\n        try:\n            new = original_obj.__new__(original_obj)\n            cache[ref_name] = new\n        except:\n            new = original_obj.from_json(d)\n            cache[ref_name] = new\n            return new\n        search_recurse = new.obj_references if new.obj_references is not None else list(d.keys())\n        if d.get('vectorized'):\n            d = naive_lists_to_arrays(d)\n\n        for obj_name in search_recurse:\n            try:\n                o = d[obj_name]\n            except:\n                continue\n            t = type(o)\n            if t is str and o.startswith('pyid_'):\n                if o not in cache:\n                    JsonOptEncodable.from_json(json_repr, cache, ref_name=o)\n                d[obj_name] = cache[o]\n            elif t is list and len(o):\n                initial_list_item = o[0]\n                if type(initial_list_item) is str and initial_list_item.startswith('pyid_'):\n                    created_objs = []\n                    for v in o:\n                        if v not in cache:\n                            JsonOptEncodable.from_json(json_repr, cache, ref_name=v)\n                        created_objs.append(cache[v])\n                    d[obj_name] = created_objs\n            elif t is dict and len(o):\n                initial_list_item = next(iter(o.values()))\n                if type(initial_list_item) is str and initial_list_item.startswith('pyid_'):\n                    created_objs = {}\n                    for k, v in o.items():\n                        if v not in cache:\n                            JsonOptEncodable.from_json(json_repr, cache, ref_name=v)\n                        created_objs[k] = cache[v]\n                    d[obj_name] = created_objs\n\n        # Cannot use dict update because of slots\n        for k, v in d.items():\n            setattr(new, k, v)\n        if hasattr(new, '_custom_from_json'):\n            new._custom_from_json(num_to_object)\n        return new",
          "docstring": "",
          "signature": "def from_json(cls, json_repr, cache=None, ref_name='pyid_0'):",
          "type": "Method",
          "class_signature": "class JsonOptEncodable:"
        }
      }
    },
    "thermo/activity.py:GibbsExcess:__eq__": {
      "thermo/activity.py": {
        "GibbsExcess.state_hash": {
          "code": "    def state_hash(self):\n        \"\"\"Basic method to calculate a hash of the state of the model and its\n        model parameters.\n\n        Note that the hashes should only be compared on the same system running\n        in the same process!\n\n        Returns\n        -------\n        state_hash : int\n            Hash of the object's model parameters and state, [-]\n        \"\"\"\n        xs = self.xs if not self.vectorized else self.xs.tolist()\n        return hash_any_primitive((self.model_hash(), float(self.T), xs))",
          "docstring": "Basic method to calculate a hash of the state of the model and its\nmodel parameters.\n\nNote that the hashes should only be compared on the same system running\nin the same process!\n\nReturns\n-------\nstate_hash : int\n    Hash of the object's model parameters and state, [-]",
          "signature": "def state_hash(self):",
          "type": "Method",
          "class_signature": "class GibbsExcess:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_activity.py:test_IdealSolution": {
      "thermo/activity.py:IdealSolution:__init__": {},
      "thermo/activity.py:GibbsExcess:dHE_dT": {
        "thermo/activity.py:IdealSolution:d2GE_dT2": {}
      },
      "thermo/activity.py:IdealSolution:GE": {},
      "thermo/activity.py:GibbsExcess:HE": {
        "thermo/activity.py:IdealSolution:dGE_dT": {},
        "thermo/activity.py:IdealSolution:GE": {}
      },
      "thermo/activity.py:GibbsExcess:SE": {
        "thermo/activity.py:GibbsExcess:HE": {
          "thermo/activity.py:IdealSolution:dGE_dT": {},
          "thermo/activity.py:IdealSolution:GE": {}
        },
        "thermo/activity.py:IdealSolution:GE": {}
      },
      "thermo/activity.py:IdealSolution:d2GE_dT2": {},
      "thermo/activity.py:GibbsExcess:d2GE_dTdns": {
        "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
      },
      "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
      "thermo/activity.py:IdealSolution:d2GE_dxixjs": {},
      "thermo/activity.py:GibbsExcess:d2nGE_dTdns": {
        "thermo/activity.py:IdealSolution:dGE_dT": {},
        "thermo/activity.py:GibbsExcess:d2GE_dTdns": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
        }
      },
      "thermo/activity.py:GibbsExcess:d2nGE_dninjs": {
        "thermo/activity.py:IdealSolution:d2GE_dxixjs": {}
      },
      "thermo/activity.py:IdealSolution:dGE_dT": {},
      "thermo/activity.py:GibbsExcess:dGE_dns": {
        "thermo/activity.py:IdealSolution:dGE_dxs": {}
      },
      "thermo/activity.py:IdealSolution:dGE_dxs": {},
      "thermo/activity.py:GibbsExcess:dHE_dns": {
        "thermo/activity.py:GibbsExcess:dHE_dxs": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
          "thermo/activity.py:IdealSolution:dGE_dxs": {},
          "thermo/activity.py:gibbs_excess_dHE_dxs": {}
        }
      },
      "thermo/activity.py:GibbsExcess:dHE_dxs": {},
      "thermo/activity.py:GibbsExcess:dSE_dT": {
        "thermo/activity.py:GibbsExcess:dHE_dT": {
          "thermo/activity.py:IdealSolution:d2GE_dT2": {}
        },
        "thermo/activity.py:GibbsExcess:HE": {
          "thermo/activity.py:IdealSolution:dGE_dT": {},
          "thermo/activity.py:IdealSolution:GE": {}
        },
        "thermo/activity.py:IdealSolution:dGE_dT": {},
        "thermo/activity.py:IdealSolution:GE": {}
      },
      "thermo/activity.py:GibbsExcess:dSE_dns": {
        "thermo/activity.py:GibbsExcess:dSE_dxs": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
        }
      },
      "thermo/activity.py:GibbsExcess:dSE_dxs": {},
      "thermo/activity.py:GibbsExcess:dgammas_dT": {
        "thermo/activity.py:IdealSolution:dGE_dT": {},
        "thermo/activity.py:IdealSolution:GE": {},
        "thermo/activity.py:IdealSolution:dGE_dxs": {},
        "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
        "thermo/activity.py:gibbs_excess_dgammas_dT": {}
      },
      "thermo/activity.py:GibbsExcess:dgammas_dns": {
        "thermo/activity.py:IdealSolution:gammas": {},
        "thermo/activity.py:IdealSolution:d2GE_dxixjs": {},
        "thermo/activity.py:gibbs_excess_dgammas_dns": {}
      },
      "thermo/activity.py:GibbsExcess:dnGE_dns": {
        "thermo/activity.py:IdealSolution:dGE_dxs": {},
        "thermo/activity.py:IdealSolution:GE": {}
      },
      "thermo/activity.py:GibbsExcess:dnHE_dns": {
        "thermo/activity.py:GibbsExcess:dHE_dxs": {},
        "thermo/activity.py:GibbsExcess:HE": {
          "thermo/activity.py:IdealSolution:dGE_dT": {},
          "thermo/activity.py:IdealSolution:GE": {}
        }
      },
      "thermo/activity.py:GibbsExcess:dnSE_dns": {
        "thermo/activity.py:GibbsExcess:dSE_dxs": {},
        "thermo/activity.py:GibbsExcess:SE": {}
      },
      "thermo/activity.py:IdealSolution:gammas": {}
    },
    "tests/test_activity.py:test_IdealSolution_numpy_output": {
      "thermo/activity.py:IdealSolution:__init__": {},
      "thermo/activity.py:IdealSolution:to_T_xs": {},
      "thermo/test_utils.py:check_np_output_activity": {
        "thermo/activity.py:IdealSolution:d3GE_dT3": {},
        "thermo/activity.py:IdealSolution:d2GE_dT2": {},
        "thermo/activity.py:IdealSolution:GE": {},
        "thermo/activity.py:IdealSolution:dGE_dT": {},
        "thermo/activity.py:IdealSolution:dGE_dxs": {},
        "thermo/activity.py:IdealSolution:gammas": {},
        "thermo/activity.py:GibbsExcess:gammas_dGE_dxs": {
          "thermo/activity.py:GibbsExcess:gammas": {
            "thermo/activity.py:IdealSolution:GE": {},
            "thermo/activity.py:IdealSolution:dGE_dxs": {},
            "thermo/activity.py:gibbs_excess_gammas": {}
          }
        },
        "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
        "thermo/activity.py:GibbsExcess:dHE_dxs": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
          "thermo/activity.py:IdealSolution:dGE_dxs": {},
          "thermo/activity.py:gibbs_excess_dHE_dxs": {}
        },
        "thermo/activity.py:GibbsExcess:gammas_infinite_dilution": {
          "thermo/activity.py:IdealSolution:to_T_xs": {},
          "thermo/activity.py:IdealSolution:gammas": {}
        },
        "thermo/activity.py:GibbsExcess:dHE_dns": {
          "thermo/activity.py:GibbsExcess:dHE_dxs": {}
        },
        "thermo/activity.py:GibbsExcess:dnHE_dns": {
          "thermo/activity.py:GibbsExcess:dHE_dxs": {},
          "thermo/activity.py:GibbsExcess:HE": {
            "thermo/activity.py:IdealSolution:dGE_dT": {},
            "thermo/activity.py:IdealSolution:GE": {}
          }
        },
        "thermo/activity.py:GibbsExcess:dSE_dxs": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
        },
        "thermo/activity.py:GibbsExcess:dSE_dns": {
          "thermo/activity.py:GibbsExcess:dSE_dxs": {}
        },
        "thermo/activity.py:GibbsExcess:dnSE_dns": {
          "thermo/activity.py:GibbsExcess:dSE_dxs": {},
          "thermo/activity.py:GibbsExcess:SE": {
            "thermo/activity.py:GibbsExcess:HE": {
              "thermo/activity.py:IdealSolution:dGE_dT": {},
              "thermo/activity.py:IdealSolution:GE": {}
            },
            "thermo/activity.py:IdealSolution:GE": {}
          }
        },
        "thermo/activity.py:GibbsExcess:dGE_dns": {
          "thermo/activity.py:IdealSolution:dGE_dxs": {}
        },
        "thermo/activity.py:GibbsExcess:dnGE_dns": {
          "thermo/activity.py:IdealSolution:dGE_dxs": {},
          "thermo/activity.py:IdealSolution:GE": {}
        },
        "thermo/activity.py:GibbsExcess:d2GE_dTdns": {
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
        },
        "thermo/activity.py:GibbsExcess:d2nGE_dTdns": {
          "thermo/activity.py:IdealSolution:dGE_dT": {},
          "thermo/activity.py:GibbsExcess:d2GE_dTdns": {
            "thermo/activity.py:IdealSolution:d2GE_dTdxs": {}
          }
        },
        "thermo/activity.py:GibbsExcess:dgammas_dT": {
          "thermo/activity.py:IdealSolution:dGE_dT": {},
          "thermo/activity.py:IdealSolution:GE": {},
          "thermo/activity.py:IdealSolution:dGE_dxs": {},
          "thermo/activity.py:IdealSolution:d2GE_dTdxs": {},
          "thermo/activity.py:gibbs_excess_dgammas_dT": {}
        },
        "thermo/activity.py:IdealSolution:d2GE_dxixjs": {},
        "thermo/activity.py:GibbsExcess:d2nGE_dninjs": {
          "thermo/activity.py:IdealSolution:d2GE_dxixjs": {}
        },
        "thermo/activity.py:GibbsExcess:dgammas_dns": {
          "thermo/activity.py:IdealSolution:gammas": {},
          "thermo/activity.py:IdealSolution:d2GE_dxixjs": {},
          "thermo/activity.py:gibbs_excess_dgammas_dns": {}
        },
        "thermo/activity.py:IdealSolution:d3GE_dxixjxks": {}
      },
      "thermo/activity.py:GibbsExcess:as_json": {
        "thermo/serialize.py:JsonOptEncodable:as_json": {
          "thermo/serialize.py:arrays_to_lists": {
            "thermo/serialize.py:arrays_to_lists": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "thermo/activity.py:GibbsExcess:from_json": {
        "thermo/serialize.py:JsonOptEncodable:from_json": {
          "thermo/serialize.py:naive_lists_to_arrays": {
            "thermo/serialize.py:naive_lists_to_arrays": {
              "[ignored_or_cut_off]": "..."
            }
          },
          "thermo/activity.py:GibbsExcess:_custom_from_json": {}
        }
      },
      "thermo/activity.py:GibbsExcess:__eq__": {
        "thermo/activity.py:GibbsExcess:state_hash": {
          "thermo/activity.py:GibbsExcess:model_hash": {}
        }
      },
      "thermo/activity.py:GibbsExcess:model_hash": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/thermo-image-test_activity/thermo-test_activity/tests/test_flash_vl.py:test_issue106_Michelson_stability_test_log_zero": {
      "thermo/phases/gibbs_excess.py:GibbsExcessLiquid:GibbsExcessLiquid": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/thermo-image-test_activity/thermo-test_activity/tests/test_flash_iapws.py:test_iapws95_basic_flash": {
      "thermo/phases/iapws_phase.py:IAPWS95Liquid:IAPWS95Liquid": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/thermo-image-test_activity/thermo-test_activity/modified_testcases/test_flash_vl.py:test_issue106_Michelson_stability_test_log_zero": {
      "thermo/phases/gibbs_excess.py:GibbsExcessLiquid:GibbsExcessLiquid": {}
    }
  },
  "PRD": "# PROJECT NAME: thermo-test_activity\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 thermo/\n    \u251c\u2500\u2500 activity.py\n    \u2502   \u251c\u2500\u2500 GibbsExcess.HE\n    \u2502   \u251c\u2500\u2500 GibbsExcess.SE\n    \u2502   \u251c\u2500\u2500 GibbsExcess.__eq__\n    \u2502   \u251c\u2500\u2500 GibbsExcess.as_json\n    \u2502   \u251c\u2500\u2500 GibbsExcess.d2GE_dTdns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.d2nGE_dTdns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.d2nGE_dninjs\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dGE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dHE_dT\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dHE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dHE_dxs\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dSE_dT\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dSE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dSE_dxs\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dgammas_dT\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dgammas_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dnGE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dnHE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.dnSE_dns\n    \u2502   \u251c\u2500\u2500 GibbsExcess.from_json\n    \u2502   \u251c\u2500\u2500 GibbsExcess.model_hash\n    \u2502   \u251c\u2500\u2500 IdealSolution.GE\n    \u2502   \u251c\u2500\u2500 IdealSolution.__init__\n    \u2502   \u251c\u2500\u2500 IdealSolution.d2GE_dT2\n    \u2502   \u251c\u2500\u2500 IdealSolution.d2GE_dTdxs\n    \u2502   \u251c\u2500\u2500 IdealSolution.d2GE_dxixjs\n    \u2502   \u251c\u2500\u2500 IdealSolution.dGE_dT\n    \u2502   \u251c\u2500\u2500 IdealSolution.dGE_dxs\n    \u2502   \u251c\u2500\u2500 IdealSolution.gammas\n    \u2502   \u2514\u2500\u2500 IdealSolution.to_T_xs\n    \u251c\u2500\u2500 phases/\n    \u2502   \u251c\u2500\u2500 gibbs_excess.py\n    \u2502   \u2502   \u2514\u2500\u2500 GibbsExcessLiquid.GibbsExcessLiquid\n    \u2502   \u2514\u2500\u2500 iapws_phase.py\n    \u2502       \u2514\u2500\u2500 IAPWS95Liquid.IAPWS95Liquid\n    \u2514\u2500\u2500 test_utils.py\n        \u2514\u2500\u2500 check_np_output_activity\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe Chemical Engineering Design Library (ChEDL) module facilitates advanced thermodynamic calculations for process modeling in chemical engineering. Its primary purpose is to implement and validate models for calculating the excess Gibbs energy and related thermodynamic properties of ideal solutions, providing analytic and numerical outputs for parameters such as activity coefficients, derivatives, and solution behaviors under various conditions. This module supports features like JSON serialization/deserialization, numpy-based computation, and consistency checks for numerical results, enhancing compatibility and usability across different platforms and workflows. By automating and standardizing critical thermodynamic evaluations, the module simplifies complex engineering analyses, reducing development time and potential for human error in modeling processes.\n\n## FILE 1: thermo/activity.py\n\n- CLASS METHOD: GibbsExcess.dSE_dT\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dSE_dT(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the first temperature derivative of the excess entropy of a liquid phase using an activity coefficient model.\n\nThe derivative is computed based on the relationship between the excess Gibbs energy (GE) and excess enthalpy (HE) as well as their temperature derivatives. The formula used is:\n\n.. math::\n    \\frac{\\partial s^E}{\\partial T} = \\frac{1}{T}\n    \\left(\\frac{-\\partial g^E}{\\partial T} + \\frac{\\partial h^E}{\\partial T}\n    - \\frac{(G + H)}{T}\\right)\n\nReturns\n-------\ndSE_dT : float\n    The first temperature derivative of excess entropy of the liquid phase, expressed in [J/mol/K].\n\nNotes\n-----\nThis method relies on other methods within the class, specifically `dHE_dT()`, `dGE_dT()`, and `HE()`, to compute the temperature derivatives of enthalpy and Gibbs energy, as well as their values at the current state. `self.T` represents the temperature of the system and is defined in the `GibbsExcess` class.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dHE_dT\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dHE_dT(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the first temperature derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature change in excess enthalpy (h^E) based on the excess Gibbs energy (g^E) derived from the activity coefficient model, following the relationship \\(\\frac{\\partial h^E}{\\partial T} = -T \\frac{\\partial^2 g^E}{\\partial T^2}\\). The temperature \\(T\\) is an instance attribute, while the second derivative of the Gibbs energy, obtained through the `d2GE_dT2` method, is used in the computation.\n\nReturns\n-------\ndHE_dT : float\n    The first temperature derivative of excess enthalpy, measured in [J/mol/K].\n\nNotes\n-----\nThis method relies on the `d2GE_dT2` method from the GibbsExcess class to accurately calculate the required second derivative of the excess Gibbs energy.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.dGE_dT\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def dGE_dT(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the temperature derivative of the excess Gibbs energy of an ideal liquid phase, which is defined as having no excess Gibbs energy. \n\nReturns\n-------\ndGE_dT : float\n    The first temperature derivative of excess Gibbs energy, which is always 0.0 J/(mol*K) for an ideal liquid.\n\nNotes\n-----\nThis method reflects the characteristics of an ideal solution where the excess Gibbs energy does not depend on temperature, indicating that the energy exchange is ideal in nature without any non-ideality. It is a part of the IdealSolution class, which extends the GibbsExcess class, specifically modeling behavior where activity coefficients are uniform and set to 1.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.GE\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def GE(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the excess Gibbs energy of an ideal liquid phase, which is defined as zero due to the absence of interactions between components.\n\nThis method implements the characteristic behavior of an ideal solution where there are no excess energies contributing to the Gibbs energy, thus returning a constant value of 0.0 J/mol.\n\nReturns\n-------\nGE : float\n    Excess Gibbs energy of an ideal liquid, which is always 0.0 J/mol.\n\nNotes\n-----\nThis functionality is part of the `IdealSolution` class, which represents an ideal liquid solution, and is based on the idea that there are no additional energetic contributions from molecular interactions.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.d2GE_dxixjs\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def d2GE_dxixjs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the second mole fraction derivatives of excess Gibbs energy for an ideal liquid.\n\nThis method computes the second partial derivative of the excess Gibbs energy \\( g^E \\) with respect to the mole fractions \\( x_i \\) and \\( x_j \\) of the components in a liquid mixture. For an ideal solution, this derivative is always zero, indicating that the Gibbs energy does not change with variations in the composition.\n\nReturns\n-------\nd2GE_dxixjs : list[list[float]]\n    A 2D list (matrix) of zeros, where each entry represents the second derivatives of excess Gibbs energy with respect to mole fractions, shaped as \\( N \\times N \\), where \\( N \\) is the number of components in the liquid phase.\n\nNotes\n-----\nThe method relies on the attribute `N`, which is the number of mole fractions defined in the class, and `vectorized`, which determines if the calculations should leverage NumPy for efficient computation. If not vectorized, a nested list of zeros is generated. The NumPy `zeros` function is used to create the output in a vectorized context, improving performance for larger systems.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.d2nGE_dninjs\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def d2nGE_dninjs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the second partial mole number derivative of the excess Gibbs energy for a liquid phase using the activity coefficient model. This derivative is represented mathematically as \\(\\frac{\\partial^2 n G^E}{\\partial n_i \\partial n_j}\\).\n\nReturns\n-------\nd2nGE_dninjs : list[list[float]]\n    A matrix representing the second partial mole number derivatives of excess Gibbs energy, measured in [J/(mol\u00b2)]. The output dimensions correspond to the number of components in the system.\n\nNotes\n-----\nThis method relies on the `d2GE_dxixjs()` method to obtain the second derivatives of excess Gibbs energy with respect to mole fractions, which is then converted into partial mole number derivatives using the `d2xs_to_dxdn_partials` function. The attribute `self.xs` (mole fractions) is used to perform this conversion. If the instance variable `self.vectorized` is True, the output is converted into a NumPy array for efficiency. The method is designed for use within the context of the `GibbsExcess` class, which models liquid phase behavior based on activity coefficients.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dnSE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dnSE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the partial mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the change in excess entropy with respect to the number of moles of component \\(i\\). It utilizes the first mole fraction derivative of excess entropy obtained from the `dSE_dxs` method and normalizes it using the current mole fractions stored in `self.xs` and the total excess entropy from `self.SE()`. The output is a list of floats representing the first partial mole number derivative of excess entropy, measured in J/(mol\u00b7K).\n\nReturns\n-------\ndnSE_dns : list[float]\n    First partial mole number derivative of excess entropy of the liquid phase, [J/(mol*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dn_partials`, which transforms the mole fraction derivative into the mole number derivative using the current mole fractions. The `self.N` attribute represents the number of components, while `self.vectorized` determines whether to use a numeric array or a Python list for output.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dgammas_dT\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dgammas_dT(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the temperature derivatives of activity coefficients of a liquid phase using an activity coefficient model.\n\nThis method computes the temperature derivatives of the activity coefficients (\\(\\gamma_i\\)) based on the excess Gibbs energy (\\(G^E\\)). The equation utilized is:\n\n\\[\n\\frac{\\partial \\gamma_i}{\\partial T} =\n\\left(\\frac{\\frac{\\partial^2 n G^E}{\\partial T \\partial n_i}}{RT} -\n\\frac{{\\frac{\\partial n_i G^E}{\\partial n_i }}}{RT^2}\\right)\n\\exp\\left(\\frac{\\frac{\\partial n_i G^E}{\\partial n_i }}{RT}\\right)\n\\]\n\nwhere:\n- \\(R\\) is the universal gas constant from the `fluids.constants` module.\n- \\(T\\) is the temperature of the system.\n- \\(xs\\) are the mole fractions of the components in the liquid phase.\n- \\(dGE_dT\\) is the first temperature derivative of excess Gibbs energy, computed by calling `self.dGE_dT()`.\n- \\(GE\\) is the excess Gibbs energy, obtained from `self.GE()`.\n- \\(dG_dxs\\) and \\(d2GE_dTdxs\\) are obtained through methods `self.dGE_dxs()` and `self.d2GE_dTdxs()`, respectively.\n\nReturns\n-------\ndgammas_dT : list[float]\n    The temperature derivatives of activity coefficients, measured in \\(1/K\\).\n\nThis method utilizes memoization with the attribute `_dgammas_dT` to cache results for efficiency. It interacts with the overall GibbsExcess class, relying on its methods to compute the required derivatives of the Gibbs energy.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dGE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dGE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the partial derivative of the excess Gibbs energy \\( G^E \\) with respect to the mole number \\( n_i \\) for each component in the mixture. The calculation utilizes the method `dGE_dxs` to obtain the mole fraction derivatives of excess Gibbs energy, and it applies the function `dxs_to_dns` to convert these derivatives into mole number derivatives based on the current composition \\( xs \\) of the system.\n\nReturns\n-------\ndGE_dns : list[float]\n    A list containing the first mole number derivatives of excess Gibbs energy for each component, measured in [J/(mol^2*K)].\n\nNotes\n-----\n- The method relies on the attribute `xs`, which represents the current mole fractions of the components, and `N`, which is the total number of components in the mixture.\n- It checks the `vectorized` attribute to decide whether to create a list or a NumPy array of zeros for the output.\n- Dependencies: The method calls `dxs_to_dns`, imported from `chemicals.utils`, to facilitate the conversion from mole fraction derivatives to mole number derivatives.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.__init__\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def __init__(self, *, xs, T=GibbsExcess.T_DEFAULT):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an IdealSolution instance, representing an ideal liquid with no excess Gibbs energy and activity coefficients equal to one.\n\nParameters\n----------\nT : float, optional\n    Temperature of the solution in Kelvin. Defaults to GibbsExcess.T_DEFAULT, which is 298.15 K.\nxs : list[float]\n    List of mole fractions of the components in the solution. The length of this list defines the number of components (N).\n\nAttributes\n----------\nT : float\n    The temperature of the mixture.\nxs : list[float]\n    The mole fractions of the components.\nN : int\n    The number of components in the mixture.\nvectorized : bool\n    A flag indicating whether the mole fractions are provided in a vectorized form (numpy array) or as a standard list.\n\nNotes\n-----\nThis constructor defines the essential properties for an ideal solution model, where the excess Gibbs energy is zero and the activity coefficients are unity. The initialization of the temperature (T) uses the constant T_DEFAULT from the GibbsExcess class, ensuring a standard default value if not specified.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.to_T_xs\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def to_T_xs(self, T, xs):\n  - DOCSTRING: \n```python\n\"\"\"\nMethod to create a new instance of the `IdealSolution` class at a specified temperature and mole fractions, preserving the original object's parameters.\n\nParameters\n----------\nT : float\n    The new temperature of the solution, specified in Kelvin [K].\nxs : list[float]\n    A list of the new mole fractions for each component, where each value is in the range [0, 1] and their sum equals 1.\n\nReturns\n-------\nobj : IdealSolution\n    A new `IdealSolution` object initialized with the provided temperature and mole fractions.\n\nNotes\n-----\nThis method facilitates the construction of a `IdealSolution` object that retains the characteristics of the existing instance while adapting to new operating conditions. The `vectorized` attribute is carried over to maintain computational efficiency when using numpy arrays, ensuring consistent array behavior. It is assumed that the list of mole fractions (`xs`) has a length consistent with the number of components denoted by `self.N`, which is determined at the time of the object\u2019s instantiation.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.__eq__\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nMethod for comparing two instances of the `GibbsExcess` class for equality.\n\nParameters\n----------\nother : object\n    The object to compare with the current instance. Typically another `GibbsExcess` object.\n\nReturns\n-------\nbool\n    Returns `True` if the hash of the current instance is equal to the hash of the `other` object, indicating that they are considered equal based on their internal state and attributes. Returns `False` otherwise.\n\nNotes\n-----\nThis method relies on the `__hash__()` method, which computes a hash value based on the model parameters of the `GibbsExcess` instance. Thus, the equality comparison is dependent on the proper implementation of the `__hash__()` method, ensuring that two theoretically equivalent models yield the same hash value.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dSE_dxs\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dSE_dxs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole fraction derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first mole fraction derivative of excess entropy \\( S^E \\) based on the relation between excess enthalpy \\( h^E \\) and excess Gibbs energy \\( g^E \\). It retrieves the temperature derivatives of the second excess Gibbs energy with respect to mole fractions from the internal method `d2GE_dTdxs` and uses them to compute the result. The output is negated in accordance with the formula for \\( \\frac{\\partial S^E}{\\partial x_i} \\).\n\nReturns\n-------\ndSE_dxs : list[float]\n    List of first mole fraction derivatives of excess entropy of the liquid phase, measured in [J/(mol*K)].\n\nDependencies\n------------\n- This method depends on the `d2GE_dTdxs` method, which calculates the second temperature derivative of excess Gibbs energy with respect to mole fractions.\n- The attribute `_dSE_dxs` is used for caching results to avoid redundant calculations.\n\nNotes\n-----\nThe method effectively handles two scenarios: vectorized and non-vectorized calculations, where it adapts the output structure accordingly.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.as_json\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def as_json(self, cache=None, option=0):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a JSON-friendly representation of the GibbsExcess model for storage and later retrieval. This method utilizes the `JsonOptEncodable` class to ensure compatibility with JSON serialization.\n\nParameters\n----------\ncache : dict, optional\n    A cache to optimize serialization, if provided.\noption : int, optional\n    An option flag to customize serialization behavior (default is 0).\n\nReturns\n-------\njson_repr : dict\n    A dictionary containing the JSON-friendly representation of the GibbsExcess model.\n\nNotes\n-----\nThis method is crucial for saving and reloading the state of an object. It is typically used alongside the `from_json` method to reconstruct the model from the serialized data. The method ensures that all essential parameters and attributes of the GibbsExcess instance are included in the JSON output.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.d2GE_dTdns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def d2GE_dTdns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole number derivative of the first temperature derivative of excess Gibbs energy (\\(G^E\\)) of a liquid phase using an activity coefficient model. This method utilizes the mole fraction derivatives of the temperature derivative of excess Gibbs energy calculated by the method `d2GE_dTdxs()`, multiplying it by the current mole fractions `xs` to compute the result.\n\nReturns\n-------\nd2GE_dTdns : list[float]\n    First mole number derivative of the temperature derivative of excess Gibbs energy of the liquid phase, expressed in [J/(mol^2*K)].\n\nNotes\n-----\nThe calculation relies on the utility function `dxs_to_dns`, which transforms the derivatives of the Gibbs energy with respect to mole fractions into their corresponding mole number derivatives. The variable `out` is initialized as a list or NumPy array of zeros, depending on whether the instance is vectorized, and it is updated with the results of the transformation before being returned.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dnHE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dnHE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the partial mole number derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the derivative of the excess enthalpy (\\( h^E \\)) with respect to the mole number (\\( n_i \\)) of each component defined in the system. It uses the mole fraction derivatives of excess enthalpy, obtained from the `dHE_dxs()` method, and applies the `dxs_to_dn_partials` function to convert these to mole number derivatives using the current mole fractions (`self.xs`) and the excess enthalpy (`self.HE()`). The output will be a list of partial derivatives representing how the excess enthalpy changes as the number of moles of each component changes.\n\nReturns\n-------\ndnHE_dns : list[float]\n    First partial mole number derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nDependencies\n------------\n- `dxs_to_dn_partials`: A utility function for converting mole fraction derivatives to mole number derivatives.\n- `self.dHE_dxs()`: Returns the mole fraction derivatives of excess enthalpy.\n- `self.xs`: The current mole fractions of the components.\n- `self.HE()`: Calculates the excess enthalpy of the liquid phase.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.d2GE_dT2\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def d2GE_dT2(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the second derivative of the excess Gibbs energy (\\(g^E\\)) with respect to temperature for an ideal liquid phase. In an ideal solution, this derivative is always zero due to the absence of excess Gibbs energy contributions, indicating that the excess properties are independent of temperature. \n\nReturns\n-------\nd2GE_dT2 : float\n    The second temperature derivative of excess Gibbs energy of an ideal liquid, always equal to 0, expressed in units of [J/(mol*K^2)].\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dgammas_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dgammas_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole number derivative of activity coefficients for a liquid phase using an activity coefficient model.\n\nThis method computes the mole number derivatives of activity coefficients, denoted as \\(\\frac{\\partial \\gamma_i}{\\partial n_i}\\), utilizing the second partial derivatives of the excess Gibbs energy, \\(G^E\\). The calculation depends on the components' mole fractions (`xs`), the current activity coefficients (`gammas`), and the second derivatives of excess Gibbs energy with respect to mole fractions (`d2GE_dxixjs`).\n\nReturns\n-------\ndgammas_dns : list[list[float]]\n    A two-dimensional list representing the mole number derivatives of activity coefficients, expressed in units of [1/mol].\n\nNotes\n-----\nThis method utilizes the `gammas()` method to retrieve the current activity coefficients and the `d2GE_dxixjs()` method to compute the necessary second derivatives of \\(G^E\\). The output is cached in the `_dgammas_dns` attribute for efficiency, ensuring that future calls do not recompute the value unnecessarily.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.gammas\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def gammas(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the activity coefficients of a liquid phase for an ideal solution. In an ideal solution, the activity coefficients for all components are equal to 1, indicating no deviation from ideal behavior.\n\nReturns\n-------\ngammas : list[float]\n    Activity coefficients for each component, which are always 1.0 for an ideal solution.\n\nNotes\n-----\nThis method checks if the instance is vectorized (i.e., if the mole fractions are stored in a NumPy array). If not, it returns a list of 1.0 for each component. If vectorized, it returns a NumPy array of ones with a length equal to the number of components, self.N, which is determined during initialization of the IdealSolution instance.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dnGE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dnGE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the partial mole number derivative of the excess Gibbs energy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of the excess Gibbs energy with respect to the number of moles of each component in the mixture. It utilizes the mole fraction derivatives of excess Gibbs energy (`dGE_dxs`), the current mole fractions (`xs`), and the total excess Gibbs energy (`GE`) to perform the calculation. The output is a list of floats representing the derivatives in units of J/(mol).\n\nReturns\n-------\ndnGE_dns : list[float]\n    The first partial mole number derivatives of excess Gibbs energy for each component, with respect to its mole number.\n\nNotes\n-----\nThis method leverages the utility function `dxs_to_dn_partials`, which converts derivatives with respect to mole fractions to those with respect to mole numbers. The method ensures that the output format is suitable for both vectorized and non-vectorized scenarios, initializing the output list as `[0.0]*self.N` for non-vectorized or using `zeros(self.N)` for vectorized calculations.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dSE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dSE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole number derivative of excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the first partial derivative of excess entropy \\(S^E\\) with respect to the mole number \\(n_i\\) of each component in the mixture. The calculation uses the mole fraction derivatives of excess entropy, which are obtained through the `dSE_dxs()` method, and transforms them into mole number derivatives using the `dxs_to_dns` utility function.\n\nReturns\n-------\ndSE_dns : list[float]\n    First mole number derivative of excess entropy of the liquid phase, expressed in [J/(mol\u00b2*K)].\n\nNotes\n-----\nThe `output` array is initialized with zeros and its size is based on the number of components `N` in the system, which is defined as an attribute in the `GibbsExcess` class. The `vectorized` attribute determines the format of the output, ensuring compatibility with different data types.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.d2nGE_dTdns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def d2nGE_dTdns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the partial derivative of the first temperature derivative of excess Gibbs energy with respect to mole number for a liquid phase using an activity coefficient model. This method employs the mole number derivative of the first temperature derivative of excess Gibbs energy (\\(dGE_dT\\)) and the second temperature derivative of excess Gibbs energy (\\(d2GE_dTdns\\)), calculated from the respective methods in the class.\n\nReturns\n-------\nd2nGE_dTdns : list[float]\n    List of the first partial mole number derivatives of the temperature derivative of excess Gibbs energy, expressed in units of [J/(mol*K)].\n\nNotes\n-----\nThis method makes use of `dns_to_dn_partials`, which converts the temperature derivatives of excess Gibbs energy into partial mole derivatives. The internal variables `dGE_dT` and `d2GE_dTdns` are derived from the methods `dGE_dT` and `d2GE_dTdns`, respectively, ensuring the accuracy of the derivatives within the context of the activity coefficient model.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.model_hash\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def model_hash(self):\n  - DOCSTRING: \n```python\n\"\"\"\nBasic method to calculate a hash of the model's non-state parameters for comparison between different instances of the GibbsExcess class. This is useful for determining if two models are identical, particularly in scenarios where the same underlying liquid phase behavior is being represented (e.g., in a VLL flash calculation). The hash is derived from the class name, the number of components (N), and the model's parameters, allowing for a consistent and unique identifier for the model's configuration.\n\nReturns\n-------\nmodel_hash : int\n    A hash value representing the non-state parameters of the model, used for object comparison in the same process context.\n\nNotes\n-----\nThe method relies on the attribute `_model_hash` to cache the result for efficiency. If this attribute is not already set, a list `to_hash` is constructed, which includes the class name and parameter values retrieved from `_model_attributes`. If any parameter is an ndarray (from the numpy package), it is converted to a list for hashing. The function `hash_any_primitive`, which is not defined within this context but is imported from another module, is used to compute the hash from the `to_hash` list.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dHE_dxs\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dHE_dxs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole fraction derivative of the excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of excess enthalpy (\\( h^E \\)) with respect to the mole fraction (\\( x_i \\)). The calculation is based on the equation:\n\n.. math::\n    \\frac{\\partial h^E}{\\partial x_i} = -T \\frac{\\partial^2 g^E}{\\partial T \\partial x_i} + \\frac{\\partial g^E}{\\partial x_i}\n\nwhere:\n- \\( T \\) is the temperature of the system.\n- \\( g^E \\) represents the excess Gibbs energy, which is computed using the model.\n\nReturns\n-------\ndHE_dxs : list[float]\n    First mole fraction derivative of excess enthalpy of the liquid phase, measured in [J/mol].\n\nThis method relies on two other methods, `d2GE_dTdxs` and `dGE_dxs`, for calculating the second temperature derivative of excess Gibbs energy and the mole fraction derivatives of excess Gibbs energy, respectively. It uses a cached value `_dHE_dxs` to optimize performance by avoiding redundant calculations.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.d2GE_dTdxs\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def d2GE_dTdxs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the second temperature derivative of the excess Gibbs energy with respect to mole fractions for an ideal liquid solution.\n\nThis method returns the derivative of the mole fraction derivatives of excess Gibbs energy, which is zero for an ideal liquid. The output is a list of zeros reflecting the nature of ideal behavior.\n\nReturns\n-------\nd2GE_dTdxs : list[float]\n    A list containing zero values for each component, representing the second temperature derivatives of excess Gibbs energy of an ideal liquid, [J/(mol*K)].\n\nNotes\n-----\nThis method leverages the class attribute `N` to determine the number of components and checks if the instance is vectorized. If not, a list of zeros is returned; otherwise, a NumPy array of zeros is returned. The `zeros` function is used from the NumPy library, ensuring that the output maintains the appropriate data type for further calculations in thermodynamic analyses.\n\"\"\"\n```\n\n- CLASS METHOD: IdealSolution.dGE_dxs\n  - CLASS SIGNATURE: class IdealSolution(GibbsExcess):\n  - SIGNATURE: def dGE_dxs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole fraction derivatives of excess Gibbs energy of an ideal liquid, where the excess Gibbs energy is defined to be zero. This method reflects the characteristics of an ideal solution, indicating that the change in excess Gibbs energy with respect to the mole fraction of any component is zero.\n\nReturns\n-------\ndGE_dxs : list[float]\n    A list of zeroes corresponding to each component's mole fraction derivative of excess Gibbs energy, [J/mol]. The length of the list equals the number of components (self.N).\n\nNotes\n-----\nThe method checks if the `self.vectorized` attribute, which determines if the calculations are vectorized for performance. If the calculation is not vectorized, a list of zeroes is returned, while if it is vectorized, a NumPy array of zeroes of length self.N is created and returned.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.HE\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def HE(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the excess enthalpy of a liquid phase using an activity coefficient model. The excess enthalpy, \\( h^E \\), is computed using the formula:\n\n.. math::\n    h^E = -T \\frac{\\partial g^E}{\\partial T} + g^E\n\nwhere \\( T \\) is the temperature and \\( g^E \\) is the excess Gibbs energy calculated by the `GE` method.\n\nReturns\n-------\nHE : float\n    The excess enthalpy of the liquid phase, measured in joules per mole [J/mol].\n\nNotes\n-----\nThis method relies on the `dGE_dT` method to compute the temperature derivative of excess Gibbs energy, which is part of the broader framework of activity coefficient models represented by the `GibbsExcess` class. Ensure that the model parameters and state (temperature and composition) are properly initialized for accurate results.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.dHE_dns\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def dHE_dns(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate and return the mole number derivative of excess enthalpy of a liquid phase using an activity coefficient model.\n\nThis method computes the first derivative of the excess enthalpy (h^E) with respect to the number of moles (n_i) for each component in the mixture. The calculation uses the mole fraction derivatives of excess enthalpy (dHE_dxs) and the current mole fractions (xs) through the helper function `dxs_to_dns`, which translates mole fraction derivatives to mole number derivatives. \n\nReturns\n-------\ndHE_dns : list[float]\n    A list containing the first mole number derivative of excess enthalpy for each component, expressed in Joules per square mole (J/mol^2).\n\nNotes\n-----\nThe `dHE_dxs` method, which is invoked within this function, calculates the mole fraction derivatives of excess enthalpy. The `xs` attribute holds the current composition of the system and is defined in the `GibbsExcess` class. The `out` variable is initialized to handle the output format, ensuring appropriate sizing according to whether the object is vectorized or not.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.from_json\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def from_json(cls, json_repr, cache=None):\n  - DOCSTRING: \n```python\n\"\"\"\nMethod to create a GibbsExcess model instance from a JSON-friendly representation. This method is essential for reconstructing a GibbsExcess object from saved data, ensuring the model can be reinitialized with the same parameters used during its creation.\n\nParameters\n----------\njson_repr : dict\n    A dictionary representation of a GibbsExcess model as produced by the `GibbsExcess.as_json()` method.\n\ncache : optional\n    A caching mechanism that may be utilized when reconstructing the model.\n\nReturns\n-------\nmodel : :obj:`GibbsExcess`\n    A new GibbsExcess object with parameters and state derived from the provided JSON representation.\n\nNotes\n-----\nIt is critical that the input dictionary conforms to the structure outlined by `GibbsExcess.as_json()` for successful reconstruction. The method relies on `JsonOptEncodable.from_json`, which handles the specifics of reading the JSON data and creating the equivalent instance of GibbsExcess or its subclasses.\n\"\"\"\n```\n\n- CLASS METHOD: GibbsExcess.SE\n  - CLASS SIGNATURE: class GibbsExcess:\n  - SIGNATURE: def SE(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculates the excess entropy of a liquid phase using an activity coefficient model.\n\nThis method computes the excess entropy \\( s^E \\) based on the relationship between excess enthalpy \\( h^E \\) and excess Gibbs energy \\( g^E \\) at a given temperature \\( T \\). The calculation is given by the formula:\n\n.. math::\n    s^E = \\frac{h^E - g^E}{T}\n\nReturns\n-------\nSE : float\n    The excess entropy of the liquid phase in units of [J/mol/K].\n\nNotes\n-----\nThis method caches the computed value in the instance variable `_SE` for efficiency, allowing subsequent calls to return the cached value instead of recalculating. The methods `HE()` and `GE()` are called to obtain the excess enthalpy and Gibbs energy, respectively, which are essential for this calculation. This method relies on the attribute `T` (temperature), which is a fundamental attribute of the `GibbsExcess` class.\n\"\"\"\n```\n\n## FILE 2: thermo/phases/iapws_phase.py\n\n## FILE 3: thermo/test_utils.py\n\n- FUNCTION NAME: check_np_output_activity\n  - SIGNATURE: def check_np_output_activity(model, modelnp, modelnp2):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks the output of activity-related calculations from various model types to ensure consistency between a scalar list-based model and its NumPy and NumPy-based variants. \n\nParameters:\n- model: An instance of a scalar, list-based model that calculates various thermodynamic properties.\n- modelnp: A NumPy-optimized model instance, often created using Numba for performance.\n- modelnp2: Another NumPy-based model instance created from `modelnp` at a different composition, allowing for validation of output consistency across different states.\n\nThe function tests several attributes, including scalar, vector, and matrix outputs, comparing results with a specified relative tolerance (`rtol`) to assert close proximity of results using the `assert_close`, `assert_close1d`, `assert_close2d`, and `assert_close3d` functions imported from the `fluids.numerics` module. It also checks the types of the returned values to ensure they are as expected: floats, lists, and NumPy arrays. \n\nConstants:\n- rtol: Relative tolerance values defined within the function (2e-13 and 1e-12) to determine acceptable levels of numerical accuracy when comparing outputs.\n- GibbsExcess: A class from the `thermo.activity` module used to handle calculations of excess Gibbs energy and its derivatives, providing necessary functionality for certain attributes checked.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - thermo/activity.py:IdealSolution:d3GE_dxixjxks\n    - thermo/activity.py:IdealSolution:dGE_dT\n    - thermo/activity.py:IdealSolution:GE\n    - thermo/activity.py:IdealSolution:d2GE_dxixjs\n    - thermo/activity.py:GibbsExcess:d2nGE_dninjs\n    - thermo/activity.py:GibbsExcess:dnSE_dns\n    - thermo/activity.py:GibbsExcess:dgammas_dT\n    - thermo/activity.py:GibbsExcess:dGE_dns\n    - thermo/activity.py:GibbsExcess:dSE_dxs\n    - thermo/activity.py:GibbsExcess:d2GE_dTdns\n    - thermo/activity.py:GibbsExcess:dnHE_dns\n    - thermo/activity.py:IdealSolution:d2GE_dT2\n    - thermo/activity.py:GibbsExcess:dgammas_dns\n    - thermo/activity.py:IdealSolution:gammas\n    - thermo/activity.py:IdealSolution:d3GE_dT3\n    - thermo/activity.py:GibbsExcess:dnGE_dns\n    - thermo/activity.py:GibbsExcess:dSE_dns\n    - thermo/activity.py:GibbsExcess:d2nGE_dTdns\n    - thermo/activity.py:GibbsExcess:dHE_dxs\n    - thermo/activity.py:IdealSolution:d2GE_dTdxs\n    - thermo/activity.py:IdealSolution:dGE_dxs\n    - thermo/activity.py:GibbsExcess:dHE_dns\n    - thermo/activity.py:GibbsExcess:gammas_infinite_dilution\n    - thermo/activity.py:GibbsExcess:gammas_dGE_dxs\n\n## FILE 4: thermo/phases/gibbs_excess.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "thermo/activity.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2016, 2017, 2018, 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nThis module contains a base class :obj:`GibbsExcess` for handling activity\ncoefficient based\nmodels. The design is for a sub-class to provide the minimum possible number of\nderivatives of Gibbs energy, and for this base class to provide the rest of the\nmethods.  An ideal-liquid class with no excess Gibbs energy\n:obj:`IdealSolution` is also available.\n\nFor reporting bugs, adding feature requests, or submitting pull requests,\nplease use the `GitHub issue tracker <https://github.com/CalebBell/thermo/>`_.\n\n.. contents:: :local:\n\nBase Class\n==========\n\n.. autoclass:: GibbsExcess\n    :members:\n    :undoc-members:\n    :show-inheritance:\n    :exclude-members: d2GE_dT2_numerical, d2GE_dTdxs_numerical, d2GE_dxixjs_numerical, d3GE_dT3_numerical, dGE_dT_numerical, dGE_dxs_numerical\n    :special-members: __hash__, __eq__, __repr__\n\nIdeal Liquid Class\n==================\n\n.. autoclass:: IdealSolution\n    :members: to_T_xs, GE, dGE_dT, d2GE_dT2, d3GE_dT3, d2GE_dTdxs, dGE_dxs, d2GE_dxixjs, d3GE_dxixjxks\n    :undoc-members:\n    :show-inheritance:\n    :exclude-members: gammas\n\nNotes\n-----\n=====\nExcellent references for working with activity coefficient models are [1]_ and\n[2]_.\n\nReferences\n----------\n.. [1] Walas, Stanley M. Phase Equilibria in Chemical Engineering.\n   Butterworth-Heinemann, 1985.\n.. [2] Gmehling, Jurgen. Chemical Thermodynamics: For Process\n   Simulation. Weinheim, Germany: Wiley-VCH, 2012.\n\n\"\"\"\n__all__ = ['GibbsExcess', 'IdealSolution']\nfrom chemicals.utils import d2xs_to_dxdn_partials, dns_to_dn_partials, dxs_to_dn_partials, dxs_to_dns, hash_any_primitive, normalize, object_data\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, exp, hessian, jacobian, log, trunc_exp\nfrom fluids.numerics import numpy as np\nfrom thermo.fitting import fit_customized\nfrom thermo.serialize import JsonOptEncodable\ntry:\n    npexp, ones, zeros, array, ndarray = (np.exp, np.ones, np.zeros, np.array, np.ndarray)\nexcept:\n    pass\n\ndef gibbs_excess_gammas(xs, dG_dxs, GE, T, gammas=None):\n    xdx_totF = GE\n    N = len(xs)\n    for i in range(N):\n        xdx_totF -= xs[i] * dG_dxs[i]\n    RT_inv = R_inv / T\n    if gammas is None:\n        gammas = [0.0] * N\n    for i in range(N):\n        gammas[i] = exp((dG_dxs[i] + xdx_totF) * RT_inv)\n    return gammas\n\ndef gibbs_excess_dHE_dxs(dGE_dxs, d2GE_dTdxs, N, T, dHE_dxs=None):\n    if dHE_dxs is None:\n        dHE_dxs = [0.0] * N\n    for i in range(N):\n        dHE_dxs[i] = -T * d2GE_dTdxs[i] + dGE_dxs[i]\n    return dHE_dxs\n\ndef gibbs_excess_dgammas_dns(xs, gammas, d2GE_dxixjs, N, T, dgammas_dns=None, vec0=None):\n    if vec0 is None:\n        vec0 = [0.0] * N\n    if dgammas_dns is None:\n        dgammas_dns = [[0.0] * N for _ in range(N)]\n    for j in range(N):\n        tot = 0.0\n        row = d2GE_dxixjs[j]\n        for k in range(N):\n            tot += xs[k] * row[k]\n        vec0[j] = tot\n    RT_inv = R_inv / T\n    for i in range(N):\n        gammai_RT = gammas[i] * RT_inv\n        for j in range(N):\n            dgammas_dns[i][j] = gammai_RT * (d2GE_dxixjs[i][j] - vec0[j])\n    return dgammas_dns\n\ndef gibbs_excess_dgammas_dT(xs, GE, dGE_dT, dG_dxs, d2GE_dTdxs, N, T, dgammas_dT=None):\n    if dgammas_dT is None:\n        dgammas_dT = [0.0] * N\n    xdx_totF0 = dGE_dT\n    for j in range(N):\n        xdx_totF0 -= xs[j] * d2GE_dTdxs[j]\n    xdx_totF1 = GE\n    for j in range(N):\n        xdx_totF1 -= xs[j] * dG_dxs[j]\n    T_inv = 1.0 / T\n    RT_inv = R_inv * T_inv\n    for i in range(N):\n        dG_dni = xdx_totF1 + dG_dxs[i]\n        dgammas_dT[i] = RT_inv * (d2GE_dTdxs[i] - dG_dni * T_inv + xdx_totF0) * exp(dG_dni * RT_inv)\n    return dgammas_dT\n\ndef interaction_exp(T, N, A, B, C, D, E, F, lambdas=None):\n    if lambdas is None:\n        lambdas = [[0.0] * N for i in range(N)]\n    T2 = T * T\n    Tinv = 1.0 / T\n    T2inv = Tinv * Tinv\n    logT = log(T)\n    for i in range(N):\n        Ai = A[i]\n        Bi = B[i]\n        Ci = C[i]\n        Di = D[i]\n        Ei = E[i]\n        Fi = F[i]\n        lambdais = lambdas[i]\n        for j in range(N):\n            lambdais[j] = exp(Ai[j] + Bi[j] * Tinv + Ci[j] * logT + Di[j] * T + Ei[j] * T2inv + Fi[j] * T2)\n    return lambdas\n\ndef dinteraction_exp_dT(T, N, B, C, D, E, F, lambdas, dlambdas_dT=None):\n    if dlambdas_dT is None:\n        dlambdas_dT = [[0.0] * N for i in range(N)]\n    T2 = T + T\n    Tinv = 1.0 / T\n    nT2inv = -Tinv * Tinv\n    nT3inv2 = 2.0 * nT2inv * Tinv\n    for i in range(N):\n        lambdasi = lambdas[i]\n        Bi = B[i]\n        Ci = C[i]\n        Di = D[i]\n        Ei = E[i]\n        Fi = F[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        for j in range(N):\n            dlambdas_dTi[j] = (T2 * Fi[j] + Di[j] + Ci[j] * Tinv + Bi[j] * nT2inv + Ei[j] * nT3inv2) * lambdasi[j]\n    return dlambdas_dT\n\ndef d2interaction_exp_dT2(T, N, B, C, E, F, lambdas, dlambdas_dT, d2lambdas_dT2=None):\n    if d2lambdas_dT2 is None:\n        d2lambdas_dT2 = [[0.0] * N for i in range(N)]\n    Tinv = 1.0 / T\n    nT2inv = -Tinv * Tinv\n    T3inv2 = -2.0 * nT2inv * Tinv\n    T4inv6 = 3.0 * T3inv2 * Tinv\n    for i in range(N):\n        lambdasi = lambdas[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        Bi = B[i]\n        Ci = C[i]\n        Ei = E[i]\n        Fi = F[i]\n        d2lambdas_dT2i = d2lambdas_dT2[i]\n        for j in range(N):\n            d2lambdas_dT2i[j] = (2.0 * Fi[j] + nT2inv * Ci[j] + T3inv2 * Bi[j] + T4inv6 * Ei[j]) * lambdasi[j] + dlambdas_dTi[j] * dlambdas_dTi[j] / lambdasi[j]\n    return d2lambdas_dT2\n\ndef d3interaction_exp_dT3(T, N, B, C, E, F, lambdas, dlambdas_dT, d3lambdas_dT3=None):\n    if d3lambdas_dT3 is None:\n        d3lambdas_dT3 = [[0.0] * N for i in range(N)]\n    Tinv = 1.0 / T\n    Tinv3 = 3.0 * Tinv\n    nT2inv = -Tinv * Tinv\n    nT2inv05 = 0.5 * nT2inv\n    T3inv = -nT2inv * Tinv\n    T3inv2 = T3inv + T3inv\n    T4inv3 = 1.5 * T3inv2 * Tinv\n    T2_12 = -12.0 * nT2inv\n    for i in range(N):\n        lambdasi = lambdas[i]\n        dlambdas_dTi = dlambdas_dT[i]\n        Bi = B[i]\n        Ci = C[i]\n        Ei = E[i]\n        Fi = F[i]\n        d3lambdas_dT3i = d3lambdas_dT3[i]\n        for j in range(N):\n            term2 = Fi[j] + nT2inv05 * Ci[j] + T3inv * Bi[j] + T4inv3 * Ei[j]\n            term3 = dlambdas_dTi[j] / lambdasi[j]\n            term4 = T3inv2 * (Ci[j] - Tinv3 * Bi[j] - T2_12 * Ei[j])\n            d3lambdas_dT3i[j] = (term3 * (6.0 * term2 + term3 * term3) + term4) * lambdasi[j]\n    return d3lambdas_dT3\n\nclass GibbsExcess:\n    \"\"\"Class for representing an activity coefficient model.\n    While these are typically presented as tools to compute activity\n    coefficients, in truth they are excess Gibbs energy models and activity\n    coefficients are just one derived aspect of them.\n\n    This class does not implement any activity coefficient models itself; it\n    must be subclassed by another model. All properties are\n    derived with the CAS SymPy, not relying on any derivations previously\n    published, and checked numerically for consistency.\n\n    Different subclasses have different parameter requirements for\n    initialization; :obj:`IdealSolution` is\n    available as a simplest model with activity coefficients of 1 to show\n    what needs to be implemented in subclasses. It is also intended subclasses\n    implement the method `to_T_xs`, which creates a new object at the\n    specified temperature and composition but with the same parameters.\n\n    These objects are intended to lazy-calculate properties as much as\n    possible, and for the temperature and composition of an object to be\n    immutable.\n\n    \"\"\"\n    T_DEFAULT = 298.15\n    _x_infinite_dilution = 0.0\n    'When set, this will be the limiting mole fraction used to approximate\\n    the :obj:`gammas_infinite_dilution` calculation. This is important\\n    as not all models can mathematically be evaluated at zero mole-fraction.'\n    __slots__ = ('T', 'N', 'xs', 'vectorized', '_GE', '_dGE_dT', '_SE', '_d2GE_dT2', '_d2GE_dTdxs', '_dGE_dxs', '_gammas', '_dgammas_dns', '_dgammas_dT', '_d2GE_dxixjs', '_dHE_dxs', '_dSE_dxs', '_model_hash')\n    recalculable_attributes = ('_GE', '_dGE_dT', '_SE', '_d2GE_dT2', '_d2GE_dTdxs', '_dGE_dxs', '_gammas', '_dgammas_dns', '_dgammas_dT', '_d2GE_dxixjs', '_dHE_dxs', '_dSE_dxs')\n    _point_properties = ('CpE', 'GE', 'HE', 'SE', 'd2GE_dT2', 'd2GE_dTdns', 'd2GE_dTdxs', 'd2GE_dxixjs', 'd2nGE_dTdns', 'd2nGE_dninjs', 'dGE_dT', 'dGE_dns', 'dGE_dxs', 'dHE_dT', 'dHE_dns', 'dHE_dxs', 'dSE_dT', 'dSE_dns', 'dSE_dxs', 'dgammas_dT', 'dgammas_dns', 'dnGE_dns', 'dnHE_dns', 'dnSE_dns', 'gammas')\n    'These are all methods which take no arguments. For use in testing.'\n\n    def __init_subclass__(cls):\n        cls.__full_path__ = f'{cls.__module__}.{cls.__qualname__}'\n    json_version = 1\n    obj_references = []\n    non_json_attributes = ['_model_hash']\n\n    def __repr__(self):\n        \"\"\"Method to create a string representation of the state of the model.\n        Included is `T`, `xs`, and all constants necessary to create the model.\n        This can be passed into :py:func:`exec` to re-create the\n        model. Note that parsing strings like this can be slow.\n\n        Returns\n        -------\n        repr : str\n            String representation of the object, [-]\n\n        Examples\n        --------\n        >>> IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n        \"\"\"\n        s = f'{self.__class__.__name__}(T={self.T!r}, xs={self.xs!r})'\n        return s\n\n    def state_hash(self):\n        \"\"\"Basic method to calculate a hash of the state of the model and its\n        model parameters.\n\n        Note that the hashes should only be compared on the same system running\n        in the same process!\n\n        Returns\n        -------\n        state_hash : int\n            Hash of the object's model parameters and state, [-]\n        \"\"\"\n        xs = self.xs if not self.vectorized else self.xs.tolist()\n        return hash_any_primitive((self.model_hash(), float(self.T), xs))\n    __hash__ = state_hash\n\n    def exact_hash(self):\n        \"\"\"Method to calculate and return a hash representing the exact state\n        of the object. This includes `T`, `xs`,\n        the model class, and which values have already been calculated.\n\n        Returns\n        -------\n        hash : int\n            Hash of the object, [-]\n        \"\"\"\n        d = object_data(self)\n        ans = hash_any_primitive((self.__class__.__name__, d))\n        return ans\n\n    def _custom_from_json(self, *args):\n        vectorized = self.vectorized\n        if vectorized and hasattr(self, 'cmp_group_idx'):\n            self.cmp_group_idx = tuple((array(v) for v in self.cmp_group_idx))\n        if vectorized and hasattr(self, 'group_cmp_idx'):\n            self.group_cmp_idx = tuple((array(v) for v in self.group_cmp_idx))\n    CpE = dHE_dT\n\n    def gammas_infinite_dilution(self):\n        \"\"\"Calculate and return the infinite dilution activity coefficients\n        of each component.\n\n        Returns\n        -------\n        gammas_infinite : list[float]\n            Infinite dilution activity coefficients, [-]\n\n        Notes\n        -----\n        The algorithm is as follows. For each component, set its composition to\n        zero. Normalize the remaining compositions to 1. Create a new object\n        with that composition, and calculate the activity coefficient of the\n        component whose concentration was set to zero.\n        \"\"\"\n        T, N = (self.T, self.N)\n        xs_base = self.xs\n        x_infinite_dilution = self._x_infinite_dilution\n        if not self.vectorized:\n            gammas_inf = [0.0] * N\n            copy_fun = list\n        else:\n            gammas_inf = zeros(N)\n            copy_fun = array\n        for i in range(N):\n            xs = copy_fun(xs_base)\n            xs[i] = x_infinite_dilution\n            xs = normalize(xs)\n            gammas_inf[i] = self.to_T_xs(T, xs=xs).gammas()[i]\n        return gammas_inf\n\n    def gammas(self):\n        \"\"\"Calculate and return the activity coefficients of a liquid phase\n        using an activity coefficient model.\n\n        .. math::\n            \\\\gamma_i = \\\\exp\\\\left(\\\\frac{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}{RT}\\\\right)\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._gammas\n        except:\n            pass\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        if not self.vectorized:\n            dG_dns = dxs_to_dn_partials(dG_dxs, self.xs, GE)\n            RT_inv = 1.0 / (R * self.T)\n            gammas = [trunc_exp(i * RT_inv) for i in dG_dns]\n        else:\n            gammas = gibbs_excess_gammas(self.xs, dG_dxs, GE, self.T)\n            if type(gammas) is list:\n                gammas = array(gammas)\n        self._gammas = gammas\n        return gammas\n\n    def gammas_dGE_dxs(self):\n        try:\n            del self._gammas\n        except:\n            pass\n        return GibbsExcess.gammas(self)\n\n    def gammas_numerical(self):\n\n        def nGE_func(ns):\n            total_n = sum(ns)\n            xs = [n / total_n for n in ns]\n            return total_n * self.to_T_xs(T=self.T, xs=xs).GE()\n        dnGE_dns = jacobian(nGE_func, self.xs, perturbation=1e-07)\n        RT_inv = 1.0 / (self.T * R)\n        gammas = np.exp(np.array(dnGE_dns) * RT_inv) if self.vectorized else [exp(v * RT_inv) for v in dnGE_dns]\n        return gammas\n\n    def lngammas(self):\n        \"\"\"Calculate and return the natural logarithm of the activity coefficients\n        of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\\\ln \\\\gamma_i = \\\\frac{\\\\frac{\\\\partial n_i G^E}{\\\\partial n_i }}{RT}\n\n        Returns\n        -------\n        log_gammas : list[float]\n            Natural logarithm of activity coefficients, [-]\n\n        Notes\n        -----\n        \"\"\"\n        GE = self.GE()\n        dG_dxs = self.dGE_dxs()\n        dG_dns = dxs_to_dn_partials(dG_dxs, self.xs, GE)\n        RT_inv = 1.0 / (R * self.T)\n        if not self.vectorized:\n            return [dG_dn * RT_inv for dG_dn in dG_dns]\n        else:\n            return array(dG_dns) * RT_inv\n\n    def dlngammas_dT(self):\n        \"\"\"Calculate and return the temperature derivatives of the natural logarithm\n        of activity coefficients of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\\\frac{\\\\partial \\\\ln \\\\gamma_i}{\\\\partial T} = \\\\frac{1}{\\\\gamma_i} \\\\frac{\\\\partial \\\\gamma_i}{\\\\partial T}\n\n        Returns\n        -------\n        dlog_gammas_dT : list[float]\n            Temperature derivatives of the natural logarithm of activity coefficients, [1/K]\n\n        Notes\n        -----\n        This method uses the chain rule to calculate the temperature derivative\n        of log activity coefficients.\n        \"\"\"\n        gammas = self.gammas()\n        dgammas_dT = self.dgammas_dT()\n        if not self.vectorized:\n            return [dgamma_dT / gamma for gamma, dgamma_dT in zip(gammas, dgammas_dT)]\n        else:\n            return dgammas_dT / gammas\n\n    @classmethod\n    def _regress_binary_parameters(cls, gammas, xs, fitting_func, fit_parameters, use_fit_parameters, initial_guesses=None, analytical_jac=None, **kwargs):\n        fit_kwargs = dict(fit_method='lm', objective='MeanSquareErr', multiple_tries_max_objective='MeanRelErr', initial_guesses=initial_guesses, analytical_jac=analytical_jac, solver_kwargs=None, use_numba=False, multiple_tries=False, do_statistics=True, multiple_tries_max_err=1e-05)\n        fit_kwargs.update(kwargs)\n        res = fit_customized(xs, data=gammas, fitting_func=fitting_func, fit_parameters=fit_parameters, use_fit_parameters=use_fit_parameters, **fit_kwargs)\n        return res\nderivatives_added = [('dGE_dT', 'GE', 1), ('d2GE_dT2', 'GE', 2), ('d3GE_dT3', 'GE', 3), ('d4GE_dT4', 'GE', 4)]\nfor create_derivative, derive_attr, order in derivatives_added:\n\n    def numerical_derivative(self, derive_attr=derive_attr, n=order):\n        order = 2 * n + 1\n        perturbation = 1e-07\n        xs = self.xs\n\n        def func(T):\n            if T == self.T:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=T)\n            return getattr(obj, derive_attr)()\n        return derivative(func, x0=self.T, dx=self.T * perturbation, lower_limit=0.0, n=n, order=order)\n    setattr(GibbsExcess, create_derivative + '_numerical', numerical_derivative)\nfirst_comp_derivatives = [('dGE_dxs', 'GE'), ('d2GE_dTdxs', 'dGE_dT'), ('d3GE_dT2dxs', 'd2GE_dT2'), ('d4GE_dT3dxs', 'd3GE_dT3')]\nfor create_derivative, derive_attr in first_comp_derivatives:\n\n    def numerical_derivative(self, derive_attr=derive_attr):\n        perturbation = 1e-07\n\n        def func(xs):\n            if not self.vectorized and xs == self.xs:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=self.T)\n            return getattr(obj, derive_attr)()\n        return jacobian(func, self.xs, perturbation=perturbation)\n    setattr(GibbsExcess, create_derivative + '_numerical', numerical_derivative)\nsecond_comp_derivatives = [('d2GE_dxixjs', 'GE'), ('d3GE_dTdxixjs', 'dGE_dT'), ('d4GE_dT2dxixjs', 'd2GE_dT2'), ('d5GE_dT3dxixjs', 'd3GE_dT3')]\nfor create_derivative, derive_attr in second_comp_derivatives:\n\n    def numerical_derivative(self, derive_attr=derive_attr):\n        perturbation = 1e-05\n\n        def func(xs):\n            if not self.vectorized and xs == self.xs:\n                obj = self\n            else:\n                obj = self.to_T_xs(xs=xs, T=self.T)\n            return getattr(obj, derive_attr)()\n        return hessian(func, self.xs, perturbation=perturbation)\n    setattr(GibbsExcess, create_derivative + '_numerical', numerical_derivative)\n\nclass IdealSolution(GibbsExcess):\n    \"\"\"Class for  representing an ideal liquid, with no excess gibbs energy\n    and thus activity coefficients of 1.\n\n    Parameters\n    ----------\n    T : float\n        Temperature, [K]\n    xs : list[float]\n        Mole fractions, [-]\n\n    Attributes\n    ----------\n    T : float\n        Temperature, [K]\n    xs : list[float]\n        Mole fractions, [-]\n\n    Examples\n    --------\n    >>> model = IdealSolution(T=300.0, xs=[.1, .2, .3, .4])\n    >>> model.GE()\n    0.0\n    >>> model.gammas()\n    [1.0, 1.0, 1.0, 1.0]\n    >>> model.dgammas_dT()\n    [0.0, 0.0, 0.0, 0.0]\n    \"\"\"\n    _model_attributes = ()\n    model_id = 0\n    __slots__ = GibbsExcess.__slots__\n\n    def gammas_args(self, T=None):\n        N = self.N\n        return (N,)\n\n    def d3GE_dT3(self):\n        \"\"\"Calculate and return the third temperature derivative of excess\n        Gibbs energy of a liquid phase using an activity coefficient model.\n\n        .. math::\n            \\\\frac{\\\\partial^3 g^E}{\\\\partial T^3} = 0\n\n        Returns\n        -------\n        d3GE_dT3 : float\n            Third temperature derivative of excess Gibbs energy of an ideal\n            liquid, [J/(mol*K^3)]\n\n        Notes\n        -----\n        \"\"\"\n        return 0.0\n\n    def d3GE_dxixjxks(self):\n        \"\"\"Calculate and return the third mole fraction derivatives of excess\n        Gibbs energy of an ideal liquid.\n\n        .. math::\n            \\\\frac{\\\\partial^3 g^E}{\\\\partial x_i \\\\partial x_j \\\\partial x_k} = 0\n\n        Returns\n        -------\n        d3GE_dxixjxks : list[list[list[float]]]\n            Third mole fraction derivatives of excess Gibbs energy of an ideal\n            liquid, [J/mol]\n\n        Notes\n        -----\n        \"\"\"\n        N = self.N\n        if not self.vectorized:\n            return [[[0.0] * N for i in range(N)] for j in range(N)]\n        return zeros((N, N, N))\n    try:\n        gammas.__doc__ = GibbsExcess.__doc__\n    except:\n        pass",
    "thermo/phases/iapws_phase.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n__all__ = ['IAPWS95', 'IAPWS95Gas', 'IAPWS95Liquid', 'IAPWS97', 'IAPWS06']\nfrom cmath import log as logc\nfrom math import exp\nfrom chemicals import iapws\nfrom chemicals.interface import sigma_IAPWS\nfrom chemicals.thermal_conductivity import k_IAPWS\nfrom chemicals.utils import Vm_to_rho, rho_to_Vm\nfrom chemicals.viscosity import mu_IAPWS\nfrom fluids.numerics import secant\nfrom thermo.phases.gibbs_eos import GibbsEOS\nfrom thermo.phases.helmholtz_eos import HelmholtzEOS\nfrom thermo.phases.phase import Phase\n\nclass IAPWS95(HelmholtzEOS):\n    model_name = 'iapws95'\n    _MW = iapws.iapws95_MW\n    Tc = iapws.iapws95_Tc\n    Pc = iapws.iapws95_Pc\n    rhoc_mass = iapws.iapws95_rhoc\n    rhoc_mass_inv = 1.0 / rhoc_mass\n    Hfs = [-241822.0]\n    Sfs = [-44.5]\n    Gfs = [-228554.325]\n    N = 1\n    rhoc_inv = rho_to_Vm(rhoc_mass, _MW)\n    rhoc = 1.0 / rhoc_inv\n    rho_red = rhoc\n    rho_red_inv = rhoc_inv\n    T_red = Tc\n    T_fixed_transport = 1.5 * T_red\n    _MW_kg = _MW * 0.001\n    R = _MW_kg * iapws.iapws95_R\n    R_inv = 1.0 / R\n    R2 = R * R\n    zs = [1.0]\n    cmps = [0]\n    T_MAX_FLASH = T_MAX_FIXED = 5000.0\n    T_MIN_FLASH = T_MIN_FIXED = 243.0\n    _d4Ar_ddelta2dtau2_func = staticmethod(iapws.iapws95_d4Ar_ddelta2dtau2)\n    _d3Ar_ddeltadtau2_func = staticmethod(iapws.iapws95_d3Ar_ddeltadtau2)\n    _d3Ar_ddelta2dtau_func = staticmethod(iapws.iapws95_d3Ar_ddelta2dtau)\n    _d2Ar_ddeltadtau_func = staticmethod(iapws.iapws95_d2Ar_ddeltadtau)\n    _d2Ar_dtau2_func = staticmethod(iapws.iapws95_d2Ar_dtau2)\n    _dAr_dtau_func = staticmethod(iapws.iapws95_dAr_dtau)\n    _d3Ar_ddelta3_func = staticmethod(iapws.iapws95_d3Ar_ddelta3)\n    _d2Ar_ddelta2_func = staticmethod(iapws.iapws95_d2Ar_ddelta2)\n    _dAr_ddelta_func = staticmethod(iapws.iapws95_dAr_ddelta)\n    _Ar_func = staticmethod(iapws.iapws95_Ar)\n\n    def __init__(self, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        self.tau = tau = self.Tc / T\n        self.delta = delta = rho_mass * self.rhoc_mass_inv\n        self.A0, self.dA0_dtau, self.d2A0_dtau2, self.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n    def to_TP_zs(self, T, P, zs):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.T = T\n        new.P = P\n        new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        new.tau = tau = new.Tc / T\n        new.delta = delta = rho_mass * new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None and P is not None:\n            new.T = T\n            new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n            new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n            new.P = P\n        elif T is not None and V is not None:\n            new.T = T\n            new._rho_mass = rho_mass = 0.001 * self._MW / V\n            P = iapws.iapws95_P(T, rho_mass)\n            new._V = V\n            new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws95_T(P, rho_mass)\n            new._V = V\n            new.P = P\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.P = P\n        new.T = T\n        new.tau = tau = new.Tc / T\n        new.delta = delta = rho_mass * new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def mu(self):\n        \"\"\"Calculate and return the viscosity of water according to the IAPWS.\n        For details, see :obj:`chemicals.viscosity.mu_IAPWS`.\n\n        Returns\n        -------\n        mu : float\n            Viscosity of water, [Pa*s]\n        \"\"\"\n        try:\n            return self._mu\n        except:\n            pass\n        self.__mu_k()\n        return self._mu\n\n    def k(self):\n        \"\"\"Calculate and return the thermal conductivity of water according to the IAPWS.\n        For details, see :obj:`chemicals.thermal_conductivity.k_IAPWS`.\n\n        Returns\n        -------\n        k : float\n            Thermal conductivity of water, [W/m/K]\n        \"\"\"\n        try:\n            return self._k\n        except:\n            pass\n        self.__mu_k()\n        return self._k\n\n    def __mu_k(self):\n        drho_mass_dP = self.drho_mass_dP()\n        drho_dP_Tr = self.to(T=self.T_fixed_transport, V=self._V, zs=self.zs).drho_mass_dP()\n        self._mu = mu_IAPWS(T=self.T, rho=self._rho_mass, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n        self._k = k_IAPWS(T=self.T, rho=self._rho_mass, Cp=self.Cp_mass(), Cv=self.Cv_mass(), mu=self._mu, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n\nclass IAPWS95Gas(IAPWS95):\n    is_gas = True\n    is_liquid = False\n    force_phase = 'g'\n\nclass IAPWS95Liquid(IAPWS95):\n    force_phase = 'l'\n    is_gas = False\n    is_liquid = True\n\n    def sigma(self):\n        try:\n            return self._sigma\n        except:\n            pass\n        self._sigma = sigma_IAPWS(self.T)\n        return self._sigma\n\nclass IAPWS97(Phase):\n    model_name = 'iapws97'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    R = 461.526\n    Tc = 647.096\n    Pc = 22064000.0\n    rhoc = 322.0\n    zs = [1.0]\n    cmps = [0]\n\n    def mu(self):\n        return mu_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def k(self):\n        return k_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def G(self):\n        try:\n            return self._G\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            G = iapws.iapws97_G_region1(tau, pi)\n        elif region == 2:\n            G = iapws.iapws97_Gr_region2(tau, pi) + iapws.iapws97_G0_region2(tau, pi)\n        elif region == 5:\n            G = iapws.iapws97_Gr_region5(tau, pi) + iapws.iapws97_G0_region5(tau, pi)\n        elif region == 4:\n            G = self.H() - self.T * self.S()\n        self._G = G\n        return G\n\n    def dG_dpi(self):\n        try:\n            return self._dG_dpi\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            dG_dpi = iapws.iapws97_dG_dpi_region1(tau, pi)\n        elif region == 2:\n            dG_dpi = 1.0 / pi + iapws.iapws97_dGr_dpi_region2(tau, pi)\n        elif region == 5:\n            dG_dpi = 1.0 / pi + iapws.iapws97_dGr_dpi_region5(tau, pi)\n        self._dG_dpi = dG_dpi\n        return dG_dpi\n\n    def d2G_d2pi(self):\n        try:\n            return self._d2G_d2pi\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_d2pi = iapws.iapws97_d2G_dpi2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2pi = -1.0 / (pi * pi) + iapws.iapws97_d2Gr_dpi2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2pi = -1.0 / (pi * pi) + iapws.iapws97_d2Gr_dpi2_region5(tau, pi)\n        self._d2G_d2pi = d2G_d2pi\n        return d2G_d2pi\n\n    def dG_dtau(self):\n        try:\n            return self._dG_dtau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            dG_dtau = iapws.iapws97_dG_dtau_region1(tau, pi)\n        elif region == 2:\n            dG_dtau = iapws.iapws97_dG0_dtau_region2(tau, pi) + iapws.iapws97_dGr_dtau_region2(tau, pi)\n        elif region == 5:\n            dG_dtau = iapws.iapws97_dG0_dtau_region5(tau, pi) + iapws.iapws97_dGr_dtau_region5(tau, pi)\n        self._dG_dtau = dG_dtau\n        return dG_dtau\n\n    def d2G_d2tau(self):\n        try:\n            return self._d2G_d2tau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_d2tau = iapws.iapws97_d2G_dtau2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2tau = iapws.iapws97_d2Gr_dtau2_region2(tau, pi) + iapws.iapws97_d2G0_dtau2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2tau = iapws.iapws97_d2Gr_dtau2_region5(tau, pi) + iapws.iapws97_d2G0_dtau2_region5(tau, pi)\n        self._d2G_d2tau = d2G_d2tau\n        return d2G_d2tau\n\n    def d2G_dpidtau(self):\n        try:\n            return self._d2G_dpidtau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_dpidtau = iapws.iapws97_d2G_dpidtau_region1(tau, pi)\n        elif region == 2:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region2(tau, pi)\n        elif region == 5:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region5(tau, pi)\n        self._d2G_dpidtau = d2G_dpidtau\n        return d2G_dpidtau\n\n    def A_region3(self):\n        try:\n            return self._A_region3\n        except:\n            pass\n        self._A_region3 = A_region3 = iapws.iapws97_A_region3_region3(self.tau, self.delta)\n        return A_region3\n\n    def dA_ddelta(self):\n        try:\n            return self._dA_ddelta\n        except:\n            pass\n        self._dA_ddelta = dA_ddelta = iapws.iapws97_dA_ddelta_region3(self.tau, self.delta)\n        return dA_ddelta\n\n    def d2A_d2delta(self):\n        try:\n            return self._d2A_d2delta\n        except:\n            pass\n        self._d2A_d2delta = d2A_d2delta = iapws.iapws97_d2A_d2delta_region3(self.tau, self.delta)\n        return d2A_d2delta\n\n    def dA_dtau(self):\n        try:\n            return self._dA_dtau\n        except:\n            pass\n        self._dA_dtau = dA_dtau = iapws.iapws97_dA_dtau_region3(self.tau, self.delta)\n        return dA_dtau\n\n    def d2A_d2tau(self):\n        try:\n            return self._d2A_d2tau\n        except:\n            pass\n        self._d2A_d2tau = d2A_d2tau = iapws.iapws97_d2A_d2tau_region3(self.tau, self.delta)\n        return d2A_d2tau\n\n    def d2A_ddeltadtau(self):\n        try:\n            return self._d2A_ddeltadtau\n        except:\n            pass\n        self._d2A_ddeltadtau = d2A_ddeltadtau = iapws.iapws97_d2A_ddeltadtau_region3(self.tau, self.delta)\n        return d2A_ddeltadtau\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P * 6.049606775559589e-08\n            self.tau = 1386.0 / T\n            self.Pref = 16530000.0\n            self.Tref = 1386.0\n        elif region == 2:\n            self.pi = P * 1e-06\n            self.tau = 540.0 / T\n            self.Pref = 1000000.0\n            self.Tref = 540.0\n        elif region == 3:\n            self.tau = self.Tc / T\n            self.Tref = self.Tc\n            self.delta = self._rho_mass * 0.003105590062111801\n            self.rhoref = 322.0\n        elif region == 5:\n            self.pi = P * 1e-06\n            self.tau = 1000.0 / T\n            self.Tref = 1000.0\n            self.Pref = 1000000.0\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P * 6.049606775559589e-08\n            self.tau = 1386.0 / T\n        elif region == 2:\n            self.pi = P * 1e-06\n            self.tau = 540.0 / T\n        elif region == 3:\n            self.tau = self.Tc / T\n            self.delta = self._rho_mass * 0.003105590062111801\n        elif region == 5:\n            self.pi = P * 1e-06\n            self.tau = 1000.0 / T\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new._rho_mass = rho_mass = iapws.iapws97_rho(T, P)\n                new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n                new.P = P\n            elif V is not None:\n                new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n                P = iapws.iapws97_P(T, rho_mass)\n                new.V = V\n                new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws97_T(P, rho_mass)\n            new.V = V\n            new.P = P\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.region = region = iapws.iapws97_identify_region_TP(new.T, new.P)\n        if region == 1:\n            new.pi = P * 6.049606775559589e-08\n            new.tau = 1386.0 / T\n            new.Pref = 16530000.0\n            new.Tref = 1386.0\n        elif region == 2:\n            new.pi = P * 1e-06\n            new.tau = 540.0 / T\n            new.Pref = 1000000.0\n            new.Tref = 540.0\n        elif region == 3:\n            new.tau = new.Tc / T\n            new.Tref = new.Tc\n            new.delta = new._rho_mass * 0.003105590062111801\n            new.rhoref = 322.0\n        elif region == 5:\n            new.pi = P * 1e-06\n            new.tau = 1000.0 / T\n            new.Tref = 1000.0\n            new.Pref = 1000000.0\n        new.P = P\n        new.T = T\n        return new\n\n    def V(self):\n        return self._V\n\n    def U(self):\n        try:\n            return self._U\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            U = self.R * self.T(*self.tau * dG_dtau - self.pi * dG_dpi)\n        self._U = U\n        return U\n\n    def S(self):\n        try:\n            return self._S\n        except:\n            pass\n        if self.region != 3:\n            try:\n                G = self._G\n            except:\n                G = self.G()\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            S = self.R * (self.tau * dG_dtau - G)\n        self._S = S\n        return S\n\n    def H(self):\n        try:\n            return self._H\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            H = self.R * self.T * self.tau * dG_dtau\n        self._H = H\n        return H\n\n    def Cv(self):\n        try:\n            return self._Cv\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2tau = self._d2G_d2tau\n            except:\n                d2G_d2tau = self.d2G_d2tau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            tau = self.tau\n            x0 = dG_dpi - tau * d2G_dpidtau\n            Cv = self.R * (-tau * tau * d2G_d2tau + x0 * x0 / d2G_d2pi)\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except:\n            pass\n        if self.region == 3:\n            tau, delta = (self.tau, self.delta)\n            try:\n                dA_ddelta = self._dA_ddelta\n            except:\n                dA_ddelta = self.dA_ddelta()\n            try:\n                d2A_ddeltadtau = self._d2A_ddeltadtau\n            except:\n                d2A_ddeltadtau = self.d2A_ddeltadtau()\n            try:\n                d2A_d2delta = self._d2A_d2delta\n            except:\n                d2A_d2delta = self.d2A_d2delta()\n            try:\n                d2A_d2tau = self._d2A_d2tau\n            except:\n                d2A_d2tau = self.d2A_d2tau()\n            x0 = delta * dA_ddelta - delta * tau * d2A_ddeltadtau\n            Cp = self.R * (-tau * tau * d2A_d2tau + x0 * x0 / (delta * (2.0 * dA_ddelta + delta * d2A_d2delta)))\n        else:\n            tau = self.tau\n            Cp = -self.R * tau * tau * self.d2G_d2tau()\n        Cp *= self._MW * 0.001\n        self._Cp = Cp\n        return Cp\n    dH_dT = dH_dT_P = Cp\n\n    def dV_dP(self):\n        \"\"\"\n        from sympy import *\n        R, T, MW, P, Pref, Tref = symbols('R, T, MW, P, Pref, Tref')\n        dG_dpif = symbols('dG_dpi', cls=Function)\n        pi = P/Pref\n        tau = Tref/T\n        dG_dpi = dG_dpif(tau, pi)\n        V = (R*T*pi*dG_dpi*MW)/(1000*P)\n        print(diff(V, P))\n\n        MW*R*T*Subs(Derivative(dG_dpi(Tref/T, _xi_2), _xi_2), _xi_2, P/Pref)/(1000*Pref**2)\n        \"\"\"\n        try:\n            return self._dV_dP\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            dV_dP = self._MW * self.R * self.T * d2G_d2pi / (1000.0 * self.Pref * self.Pref)\n        self._dV_dP = dV_dP\n        return dV_dP\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            dV_dT = self._MW * self.R * dG_dpi / (1000 * self.Pref) - self._MW * self.R * self.Tref * d2G_dpidtau / (1000 * self.Pref * self.T)\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except:\n            pass\n        if self.region != 3:\n            dP_dT = -self.dV_dT() / self.dV_dP()\n        self._dP_dT = dP_dT\n        return dP_dT\n\n    def dP_dV(self):\n        return 1.0 / self.dV_dP()\n\nclass IAPWS06(GibbsEOS):\n    T_MAX_FLASH = T_MAX_FIXED = 273.16\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    model_name = 'iapws06'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    zs = [1.0]\n    cmps = [0]\n    R06 = iapws.iapws95_R\n    R06_inv = 1.0 / R06\n    _MW_kg = _MW * 0.001\n    R = _MW_kg * iapws.iapws95_R\n    R_inv = 1.0 / R\n    R2 = R * R\n    Tt = 273.16\n    Tt_inv = 1.0 / Tt\n    p0 = 101325.0\n    pt = 611.657\n    pt_inv = 1.0 / pt\n    pi0 = p0 / pt\n    g0n = [-632020.233335886, 0.655022213658955, -1.89369929326131e-08, 3.39746123271053e-15, -5.56464869058991e-22]\n    g0n_rev = g0n[::-1]\n    s0 = -3327.33756492168\n    t1 = 0.0368017112855051 + 0.0510878114959572j\n    r1 = 44.7050716285388 + 65.6876847463481j\n    t2 = 0.337315741065416 + 0.335449415919309j\n    r2n = [-72.597457432922 - 78.100842711287j, -5.57107698030123e-05 + 4.64578634580806e-05j, 2.34801409215913e-11 - 2.85651142904972e-11j]\n    r2n_rev = r2n[::-1]\n    r2np_rev = [7.677551608692879e-14 - 9.340239477516712e-14j, -9.108171704568459e-08 + 7.595411065038183e-08j]\n    g0p_coeffs = [-3.6390648292032365e-24, 1.666356094695489e-17, -6.192030151739651e-11, 0.0010708979275295713]\n    g0pp_coeffs = [-1.7848556441943294e-26, 5.44866189611331e-20, -1.0123370045204503e-13]\n    r2pp = r2n[2] * 2.0 / (pt * pt)\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._set_core()\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new._set_core()\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new.P = P\n                new._set_core()\n            elif V is not None:\n\n                def V_err(P):\n                    new.P = P\n                    new._set_core()\n                    return new._V - V\n                P = secant(V_err, 100000.0, xtol=1e-12, bisection=True)\n                new.P = P\n                new._set_core()\n        elif P is not None and V is not None:\n            new.P = P\n\n            def V_err(T):\n                new.T = T\n                new._set_core()\n                return new._V - V\n            T = secant(V_err, 250.0, xtol=1e-12, bisection=True)\n            new.T = T\n            new._set_core()\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.P = P\n        new.T = T\n        return new\n\n    def _set_core(self):\n        T, P = (self.T, self.P)\n        self.tau = T * self.Tt_inv\n        self.pi = P * self.pt_inv\n        pi, tau = (self.pi, self.tau)\n        R06_inv = self.R06_inv\n        t1, t2, pi0 = (self.t1, self.t2, self.pi0)\n        s0, Tt, r1 = (self.s0, self.Tt, self.r1)\n        tau2 = tau * tau\n        v0 = pi - pi0\n        r2 = v0 * (v0 * (2.34801409215913e-11 - 2.85651142904972e-11j) + (-5.57107698030123e-05 + 4.64578634580806e-05j)) + (-72.597457432922 - 78.100842711287j)\n        r2p = v0 * (7.677551608692879e-14 - 9.340239477516712e-14j) + (-9.108171704568459e-08 + 7.595411065038183e-08j)\n        g0 = v0 * (v0 * (v0 * (-5.56464869058991e-22 * v0 + 3.39746123271053e-15) - 1.89369929326131e-08) + 0.655022213658955) - 632020.233335886\n        g0p = v0 * (v0 * (-3.6390648292032365e-24 * v0 + 1.666356094695489e-17) - 6.192030151739651e-11) + 0.0010708979275295713\n        g0pp = (-1.7848556441943294e-26 * v0 + 5.44866189611331e-20) * v0 - 1.0123370045204503e-13\n        log_t1_tau = logc(t1 + tau)\n        log_t1_n_tau = logc(t1 - tau)\n        log_t2_tau = logc(t2 + tau)\n        log_t2_n_tau = logc(t2 - tau)\n        log_t1 = logc(t1)\n        log_t2 = logc(t2)\n        t2_inv = 1.0 / t2\n        t1_inv = 1.0 / t1\n        tau_t2inv = tau * t2_inv\n        t2_log_t2 = t2 * log_t2\n        t2_log_t2_2 = t2_log_t2 + t2_log_t2\n        g_real_sum = (r1 * ((t1 - tau) * log_t1_n_tau + (t1 + tau) * log_t1_tau - 2.0 * t1 * log_t1 - tau2 * t1_inv) + r2 * ((t2 - tau) * log_t2_n_tau + (t2 + tau) * log_t2_tau - t2_log_t2_2 - tau2 * t2_inv)).real\n        g = g0 - s0 * Tt * tau + Tt * g_real_sum\n        g_T_real_sum = (r1 * (-log_t1_n_tau + log_t1_tau - 2.0 * tau * t1_inv) + r2 * (-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_T = -s0 + g_T_real_sum\n        g_TT_real_sum = (r1 * (1.0 / (t1 - tau) + 1.0 / (t1 + tau) - t1_inv - t1_inv) + r2 * (1.0 / (t2 - tau) + 1.0 / (t2 + tau) - t2_inv - t2_inv)).real\n        g_TT = 0.0036608581051398447 * g_TT_real_sum\n        x0 = (t2 - tau) * log_t2_n_tau + (t2 + tau) * log_t2_tau - t2_log_t2_2 - tau2 * t2_inv\n        g_P_real_sum = (r2p * x0).real\n        g_P = g0p + Tt * g_P_real_sum\n        g_PP_real_sum = (self.r2pp * x0).real\n        g_PP = g0pp + Tt * g_PP_real_sum\n        g_TP_real_sum = (r2p * (-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_TP = g_TP_real_sum\n        self._rho_mass = rho_mass = 1.0 / g_P\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        fact = self._MW_kg\n        self._G = g * fact\n        self._dG_dT = g_T * fact\n        self._d2G_dT2 = g_TT * fact\n        self._dG_dP = g_P * fact\n        self._d2G_dP2 = g_PP * fact\n        self._d2G_dTdP = g_TP * fact\n\n    def G(self):\n        return self._G\n\n    def dG_dT(self):\n        return self._dG_dT\n\n    def d2G_dT2(self):\n        return self._d2G_dT2\n\n    def dG_dP(self):\n        return self._dG_dP\n\n    def d2G_dP2(self):\n        return self._d2G_dP2\n\n    def d2G_dTdP(self):\n        return self._d2G_dTdP\n    d2G_dPdT = d2G_dTdP\n\n    def P_sub(self):\n        return iapws.iapws11_Psub(self.T)\n\n    def vapor_fugacity_coefficient(self):\n        return 1.0\n\n    def fugacities(self):\n        P_sub = self.P_sub()\n        phi = self.vapor_fugacity_coefficient()\n        fugacity = phi * P_sub * exp(self.V() / (self.R * self.T) * (self.P - P_sub))\n        return [fugacity]",
    "thermo/test_utils.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\nfrom math import log10\nimport numpy as np\nfrom fluids.numerics import assert_close, assert_close1d, assert_close2d, assert_close3d\nfrom thermo.activity import GibbsExcess\n\ndef plot_unsupported(reason, color='r'):\n    \"\"\"Helper function - draw a plot with an `x` over it displaying a message\n    why that plot is not supported.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    fig, ax = plt.subplots()\n    xlims = ax.get_xlim()\n    ylims = ax.get_ylim()\n    ax.plot([0, 1], [0, 1], lw=5, c=color)\n    ax.plot([0, 1], [1, 0], lw=5, c=color)\n    ax.text(0.5, 0.5, reason, ha='center', va='center', bbox=dict(fc='white'))\n    return fig\n\ndef mark_plot_unsupported(plot_fig, reason, color='r'):\n    ax = plot_fig.axes[0]\n    xlims = ax.get_xlim()\n    ylims = ax.get_ylim()\n    xmid = 10 ** (0.5 * (log10(xlims[0]) + log10(xlims[1])))\n    ymid = 10 ** (0.5 * (log10(ylims[0]) + log10(ylims[1])))\n    ax.text(xmid, ymid, reason, ha='center', va='center', bbox=dict(fc='white'))\n    color = 'r'\n    ax.plot(xlims, ylims, lw=5, c=color)\n    ax.plot(xlims, ylims[::-1], lw=5, c=color)\n\ndef flash_rounding(x):\n    if isinstance(x, float):\n        return float(f'{x:.10e}')\n    return x",
    "thermo/phases/gibbs_excess.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\"\"\"\n__all__ = ['GibbsExcessLiquid', 'GibbsExcessSolid']\nfrom math import isinf, isnan\nfrom chemicals.solubility import Henry_constants, d2Henry_constants_dT2, dHenry_constants_dT\nfrom chemicals.utils import phase_identification_parameter\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, evaluate_linear_fits, evaluate_linear_fits_d, evaluate_linear_fits_d2, exp, horner_and_der2, log, secant, trunc_exp\nfrom fluids.numerics import numpy as np\nfrom thermo.activity import IdealSolution\nfrom thermo.heat_capacity import HeatCapacityGas, HeatCapacityLiquid\nfrom thermo.nrtl import nrtl_d2taus_dT2 as d2ln_henries_dT2\nfrom thermo.nrtl import nrtl_dtaus_dT as dln_henries_dT\nfrom thermo.nrtl import nrtl_taus as ln_henries\nfrom thermo.phase_change import EnthalpySublimation, EnthalpyVaporization\nfrom thermo.phases.phase import Phase\nfrom thermo.utils import POLY_FIT, TRANSFORM_SECOND_DERIVATIVE_RATIO, TRANSFORM_SECOND_LOG_DERIVATIVE, TRANSFORM_DERIVATIVE_RATIO, TRANSFORM_LOG_DERIVATIVE, TRANSFORM_LOG\nfrom thermo.vapor_pressure import SublimationPressure, VaporPressure\nfrom thermo.volume import VolumeLiquid, VolumeSolid\ntry:\n    zeros, array = (np.zeros, np.array)\nexcept:\n    pass\n\nclass GibbsExcessLiquid(Phase):\n    \"\"\"Phase based on combining Raoult's law with a\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model, optionally\n    including saturation fugacity coefficient corrections (if the vapor phase\n    is a cubic equation of state) and Poynting correction factors (if more\n    accuracy is desired).\n\n    The equilibrium equation options (controlled by `equilibrium_basis`)\n    are as follows:\n\n    * 'Psat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}}{P}`\n    * 'Poynting&PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}{P}`\n    * 'Poynting': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}\\\\text{Poynting}_i}{P}`\n    * 'PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat}}{P}`\n\n    In all cases, the activity coefficient is derived from the\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model specified as\n    input; use the :obj:`IdealSolution <thermo.activity.IdealSolution>`\n    class as an input to set the activity coefficients to one.\n\n    The enthalpy `H` and entropy `S` (and other caloric properties `U`, `G`, `A`)\n    equation options are similar to the equilibrium ones. If the same option\n    is selected for `equilibrium_basis` and `caloric_basis`, the phase will be\n    `thermodynamically consistent`. This is recommended for many reasons.\n    The full 'Poynting&PhiSat' equations for `H` and `S` are as follows; see\n    :obj:`GibbsExcessLiquid.H` and :obj:`GibbsExcessLiquid.S` for all of the\n    other equations:\n\n    .. math::\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n        \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n        + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n        + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n    .. math::\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n        - \\\\sum_i z_i\\\\left[R\\\\left(\n        T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n        + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n        + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n        + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n        \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n    An additional caloric mode is `Hvap`, which uses enthalpy of vaporization;\n    this mode can never be thermodynamically consistent, but is still widely\n    used.\n\n    .. math::\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i\\\\left[-H_{vap,i}\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n    .. math::\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n        - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\n        + \\\\frac{H_{vap,i}}{T}\n        - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n\n    .. warning::\n        Note that above the critical point, there is no definition for what vapor\n        pressure is. The vapor pressure also tends to reach zero at temperatures\n        in the 4-20 K range. These aspects mean extrapolation in the supercritical and\n        very low temperature region is critical to ensure the equations will still\n        converge. Extrapolation can be performed using either the equation\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A - \\\\frac{B}{T}\\\\right)` or\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A + \\\\frac{B}{T} + C\\\\cdot \\\\ln T\\\\right)` by\n        setting `Psat_extrpolation` to either 'AB' or 'ABC' respectively.\n        The extremely low temperature region's issue is solved by calculating the\n        logarithm of vapor pressures instead of the actual value. While floating\n        point values in Python (doubles) can reach a minimum value of around\n        1e-308, if only the logarithm of that number is computed no issues arise.\n        Both of these features only work when the vapor pressure correlations are\n        polynomials.\n\n    .. warning::\n        When using 'PhiSat' as an option, note that the factor cannot be\n        calculated when a compound is supercritical,\n        as there is no longer any vapor-liquid pure-component equilibrium\n        (by definition).\n\n    Parameters\n    ----------\n    VaporPressures : list[:obj:`thermo.vapor_pressure.VaporPressure`]\n        Objects holding vapor pressure data and methods, [-]\n    VolumeLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods; required for Poynting\n        factors and volumetric properties, [-]\n    HeatCapacityGases : list[:obj:`thermo.heat_capacity.HeatCapacityGas`], optional\n        Objects proiding pure-component heat capacity correlations; required\n        for caloric properties, [-]\n    GibbsExcessModel : :obj:`GibbsExcess <thermo.activity.GibbsExcess>`, optional\n        Configured instance for calculating activity coefficients and excess properties;\n        set to :obj:`IdealSolution <thermo.activity.IdealSolution>` if not provided, [-]\n    eos_pure_instances : list[:obj:`thermo.eos.GCEOS`], optional\n        Cubic equation of state object instances for each pure component, [-]\n    EnthalpyVaporizations : list[:obj:`thermo.phase_change.EnthalpyVaporization`], optional\n        Objects holding enthalpy of vaporization data and methods; used only\n        with the 'Hvap' optional, [-]\n    HeatCapacityLiquids : list[:obj:`thermo.heat_capacity.HeatCapacityLiquid`], optional\n        Objects holding liquid heat capacity data and methods; not used at\n        present, [-]\n    VolumeSupercriticalLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods but that are used for\n        supercritical temperatures on a per-component basis only; required for\n        Poynting factors and volumetric properties at supercritical conditions;\n        `VolumeLiquids` is used if not provided, [-]\n    Hfs : list[float], optional\n        Molar ideal-gas standard heats of formation at 298.15 K and 1 atm,\n        [J/mol]\n    Gfs : list[float], optional\n        Molar ideal-gas standard Gibbs energies of formation at 298.15 K and\n        1 atm, [J/mol]\n    T : float, optional\n        Temperature, [K]\n    P : float, optional\n        Pressure, [Pa]\n    zs : list[float], optional\n        Mole fractions of each component, [-]\n    equilibrium_basis : str, optional\n        Which set of equilibrium equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', [-]\n    caloric_basis : str, optional\n        Which set of caloric equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', 'Hvap' [-]\n    Psat_extrpolation : str, optional\n        One of 'AB' or 'ABC'; configures extrapolation for vapor pressure, [-]\n    henry_abcdef : tuple[list[list[float]], 6], optional\n        Contains the parameters used for henry's law constant, [-]\n    henry_as : list[list[float]], optional\n        `a` parameters used in calculating henry's law constant, [-]\n    henry_bs : list[list[float]], optional\n        `b` parameters used in calculating henry's law constant, [K]\n    henry_cs : list[list[float]], optional\n        `c` parameters used in calculating henry's law constant, [-]\n    henry_ds : list[list[float]], optional\n        `d` paraemeters used in calculating henry's law constant, [1/K]\n    henry_es : list[list[float]], optional\n        `e` parameters used in calculating henry's law constant, [K^2]\n    henry_fs : list[list[float]], optional\n        `f` parameters used in calculating henry's law constant, [1/K^2]\n    henry_mode : str\n        The setting for henry's law. 'solvents' to consider all\n        components set not to be henry's law components a solvent (if\n        any parameters are missing this will not make sense at all);\n        'solvents_with_parameters' to consider only the solvents with\n        parameters (vapor pressures will be used if a component has\n        no solvents whatsoever)\n\n    use_Hvap_caloric : bool, optional\n        If True, enthalpy and entropy will be calculated using ideal-gas\n        heat capacity and the heat of vaporization of the fluid only. This\n        forces enthalpy to be pressure-independent. This supersedes other\n        options which would otherwise impact these properties. The molar volume\n        of the fluid has no impact on enthalpy or entropy if this option is\n        True. This option is not thermodynamically consistent, but is still\n        often an assumption that is made.\n\n    \"\"\"\n    PIP_INCALCULABLE_VALUE = 2\n    force_phase = 'l'\n    phase = 'l'\n    is_gas = False\n    is_liquid = True\n    P_DEPENDENT_H_LIQ = True\n    PHI_SAT_IDEAL_TR = 0.1\n    _Psats_data = None\n    _Vms_sat_data = None\n    _Hvap_data = None\n    use_IG_Cp = True\n    ideal_gas_basis = True\n    supercritical_volumes = False\n    Cpls_poly_fit = False\n    _Cpls_data = None\n    _Tait_B_data = None\n    _Tait_C_data = None\n    pure_references = ('HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\n    pure_reference_types = (HeatCapacityGas, VolumeLiquid, VaporPressure, HeatCapacityLiquid, EnthalpyVaporization)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_Tait', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'Psat_extrpolation') + pure_references\n    obj_references = ('GibbsExcessModel', 'eos_pure_instances', 'result', 'constants', 'correlations', 'HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\n    __slots__ = ('VaporPressures', 'Psats_poly_fit', 'Psat_extrpolation', 'N', 'HeatCapacityGases', 'Cpgs_poly_fit', '_Cpgs_data', 'HeatCapacityLiquids', 'use_eos_volume', 'VolumeLiquids', 'Vms_sat_poly_fit', 'VolumeSupercriticalLiquids', 'Vms_supercritical_poly_fit', 'incompressible', 'use_Tait', 'EnthalpyVaporizations', 'Hvap_poly_fit', 'GibbsExcessModel', 'eos_pure_instances', 'equilibrium_basis', 'caloric_basis', 'use_phis_sat', 'use_Poynting', 'use_phis_sat_caloric', 'use_Poynting_caloric', 'use_Hvap_caloric', 'has_henry_components', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'composition_independent', 'Hfs', 'Gfs', 'Sfs', 'model_id', 'T', 'P', 'zs', '_model_hash_ignore_phase', '_model_hash')\n\n    def __repr__(self):\n        \"\"\"Method to create a string representation of the phase object, with\n        the goal of making it easy to obtain standalone code which reproduces\n        the current state of the phase. This is extremely helpful in creating\n        new test cases.\n\n        Returns\n        -------\n        recreation : str\n            String which is valid Python and recreates the current state of\n            the object if ran, [-]\n\n        \"\"\"\n        pure_strs = ''\n        for k in self.pure_references:\n            v = getattr(self, k)\n            if v is not None:\n                try:\n                    s = '[' + ', '.join((str(o) for o in v)) + ']'\n                except:\n                    continue\n                pure_strs += f'{k}={s}, '\n        base = f'{self.__class__.__name__}(GibbsExcessModel={self.GibbsExcessModel},\\n               equilibrium_basis={self.equilibrium_basis}, caloric_basis={self.caloric_basis},\\n               eos_pure_instances={self.eos_pure_instances}, {pure_strs}'\n        for s in ('Hfs', 'Gfs', 'Sfs', 'T', 'P', 'zs'):\n            if hasattr(self, s) and getattr(self, s) is not None:\n                base += f'{s}={getattr(self, s)}, '\n        if base[-2:] == ', ':\n            base = base[:-2]\n        base += ')'\n        return base\n\n    def __init__(self, VaporPressures, VolumeLiquids=None, HeatCapacityGases=None, GibbsExcessModel=None, eos_pure_instances=None, EnthalpyVaporizations=None, HeatCapacityLiquids=None, VolumeSupercriticalLiquids=None, use_Hvap_caloric=False, use_Poynting=False, use_phis_sat=False, use_Tait=False, use_eos_volume=False, Hfs=None, Gfs=None, Sfs=None, henry_components=None, henry_abcdef=None, henry_as=None, henry_bs=None, henry_cs=None, henry_ds=None, henry_es=None, henry_fs=None, henry_mode='solvents_with_parameters', T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None, Psat_extrpolation='AB', equilibrium_basis=None, caloric_basis=None):\n        \"\"\"It is quite possible to introduce a PVT relation ship for liquid\n        density and remain thermodynamically consistent. However, must be\n        applied on a per-component basis! This class cannot have an\n        equation-of-state or VolumeLiquidMixture for a liquid MIXTURE!\n\n        (it might still be nice to generalize the handling; maybe even allow)\n        pure EOSs to be used too, and as a form/template for which functions to\n        use).\n\n        In conclusion, you have\n        1) The standard H/S model\n        2) The H/S model with all pressure correction happening at P\n        3) The inconsistent model which has no pressure dependence whatsover in H/S\n           This model is required due to its popularity, not its consistency (but still volume dependency)\n\n        All mixture volumetric properties have to be averages of the pure\n        components properties and derivatives. A Multiphase will be needed to\n        allow flashes with different properties from different phases.\n        \"\"\"\n        self.N = N = len(VaporPressures)\n        if zs is None:\n            zs = [1.0 / N] * N\n        if henry_components is None:\n            henry_components = [False] * self.N\n        self.has_henry_components = any(henry_components)\n        self.henry_components = henry_components\n        self.VaporPressures = VaporPressures\n        self.Psats_poly_fit = all((i.method == POLY_FIT for i in VaporPressures)) and (not self.has_henry_components) if VaporPressures is not None else False\n        self.Psat_extrpolation = Psat_extrpolation\n        if self.Psats_poly_fit:\n            Psats_data = [[i.poly_fit_Tmin for i in VaporPressures], [i.poly_fit_Tmin_slope for i in VaporPressures], [i.poly_fit_Tmin_value for i in VaporPressures], [i.poly_fit_Tmax for i in VaporPressures], [i.poly_fit_Tmax_slope for i in VaporPressures], [i.poly_fit_Tmax_value for i in VaporPressures], [i.poly_fit_coeffs for i in VaporPressures], [i.poly_fit_d_coeffs for i in VaporPressures], [i.poly_fit_d2_coeffs for i in VaporPressures], [i.DIPPR101_ABC for i in VaporPressures]]\n            if Psat_extrpolation == 'AB':\n                Psats_data.append([i.poly_fit_AB_high_ABC_compat + [0.0] for i in VaporPressures])\n            elif Psat_extrpolation == 'ABC':\n                Psats_data.append([i.DIPPR101_ABC_high for i in VaporPressures])\n            self._Psats_data = Psats_data\n        if self.vectorized:\n            zero_coeffs = zeros((N, N))\n        else:\n            zero_coeffs = [[0.0] * N for _ in range(N)]\n        self.HeatCapacityGases = HeatCapacityGases\n        self.Cpgs_poly_fit, self._Cpgs_data = self._setup_Cpigs(HeatCapacityGases)\n        self.HeatCapacityLiquids = HeatCapacityLiquids\n        if HeatCapacityLiquids is not None:\n            self.Cpls_poly_fit, self._Cpls_data = self._setup_Cpigs(HeatCapacityLiquids)\n            T_REF_IG = self.T_REF_IG\n            T_REF_IG_INV = 1.0 / T_REF_IG\n            self.Hvaps_T_ref = [obj(T_REF_IG) for obj in EnthalpyVaporizations]\n            self.dSvaps_T_ref = [T_REF_IG_INV * dH for dH in self.Hvaps_T_ref]\n        self.use_eos_volume = use_eos_volume\n        self.VolumeLiquids = VolumeLiquids\n        self.Vms_sat_poly_fit = not use_eos_volume and all((i.method == POLY_FIT for i in VolumeLiquids)) if VolumeLiquids is not None else False\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_data = [[i.poly_fit_Tmin for i in VolumeLiquids], [i.poly_fit_Tmin_slope for i in VolumeLiquids], [i.poly_fit_Tmin_value for i in VolumeLiquids], [i.poly_fit_Tmax for i in VolumeLiquids], [i.poly_fit_Tmax_slope for i in VolumeLiquids], [i.poly_fit_Tmax_value for i in VolumeLiquids], [i.poly_fit_coeffs for i in VolumeLiquids], [i.poly_fit_d_coeffs for i in VolumeLiquids], [i.poly_fit_d2_coeffs for i in VolumeLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeLiquids]]\n        self.VolumeSupercriticalLiquids = VolumeSupercriticalLiquids\n        self.Vms_supercritical_poly_fit = all((i.method == POLY_FIT for i in VolumeSupercriticalLiquids)) if VolumeSupercriticalLiquids is not None else False\n        if self.Vms_supercritical_poly_fit:\n            self.Vms_supercritical_data = [[i.poly_fit_Tmin for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_value for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_value for i in VolumeSupercriticalLiquids], [i.poly_fit_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d2_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeSupercriticalLiquids]]\n        self.incompressible = not use_Tait\n        self.use_Tait = use_Tait\n        if self.use_Tait:\n            Tait_B_data, Tait_C_data = ([[] for i in range(9)], [[] for i in range(9)])\n            for v in VolumeLiquids:\n                for d, store in zip(v.Tait_data(), [Tait_B_data, Tait_C_data]):\n                    for i in range(len(d)):\n                        store[i].append(d[i])\n            self._Tait_B_data = Tait_B_data\n            self._Tait_C_data = Tait_C_data\n        self.EnthalpyVaporizations = EnthalpyVaporizations\n        self.Hvap_poly_fit = all((i.method == POLY_FIT for i in EnthalpyVaporizations)) if EnthalpyVaporizations is not None else False\n        if self.Hvap_poly_fit:\n            self._Hvap_data = [[i.poly_fit_Tmin for i in EnthalpyVaporizations], [i.poly_fit_Tmax for i in EnthalpyVaporizations], [i.poly_fit_Tc for i in EnthalpyVaporizations], [1.0 / i.poly_fit_Tc for i in EnthalpyVaporizations], [i.poly_fit_coeffs for i in EnthalpyVaporizations]]\n        if GibbsExcessModel is None:\n            GibbsExcessModel = IdealSolution(T=T, xs=zs)\n        self.GibbsExcessModel = GibbsExcessModel\n        self.eos_pure_instances = eos_pure_instances\n        self.equilibrium_basis = equilibrium_basis\n        self.caloric_basis = caloric_basis\n        if equilibrium_basis is not None:\n            if equilibrium_basis == 'Poynting':\n                self.use_Poynting = True\n                self.use_phis_sat = False\n            elif equilibrium_basis == 'Poynting&PhiSat':\n                self.use_Poynting = True\n                self.use_phis_sat = True\n            elif equilibrium_basis == 'PhiSat':\n                self.use_phis_sat = True\n                self.use_Poynting = False\n            elif equilibrium_basis == 'Psat':\n                self.use_phis_sat = False\n                self.use_Poynting = False\n        else:\n            self.use_Poynting = use_Poynting\n            self.use_phis_sat = use_phis_sat\n        if caloric_basis is not None:\n            if caloric_basis == 'Poynting':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Poynting&PhiSat':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = True\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'PhiSat':\n                self.use_phis_sat_caloric = True\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Psat':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Hvap':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = True\n        else:\n            self.use_Poynting_caloric = use_Poynting\n            self.use_phis_sat_caloric = use_phis_sat\n            self.use_Hvap_caloric = use_Hvap_caloric\n        if henry_mode not in ('solvents', 'solvents_with_parameters'):\n            raise ValueError(\"Henry's law model setting not recognized\")\n        self.henry_mode = henry_mode\n        multiple_henry_inputs = (henry_as, henry_bs, henry_cs, henry_ds, henry_es, henry_fs)\n        input_count_henry = (henry_abcdef is not None) + any((i is not None for i in multiple_henry_inputs))\n        if input_count_henry > 1:\n            raise ValueError('Input only one of henry_abcdef, or (henry_as...henry_fs)')\n        if henry_abcdef is not None:\n            if self.vectorized:\n                self.henry_as = array(henry_abcdef[:, :, 0], order='C', copy=True)\n                self.henry_bs = array(henry_abcdef[:, :, 1], order='C', copy=True)\n                self.henry_cs = array(henry_abcdef[:, :, 2], order='C', copy=True)\n                self.henry_ds = array(henry_abcdef[:, :, 3], order='C', copy=True)\n                self.henry_es = array(henry_abcdef[:, :, 4], order='C', copy=True)\n                self.henry_fs = array(henry_abcdef[:, :, 5], order='C', copy=True)\n            else:\n                self.henry_as = [[i[0] for i in l] for l in henry_abcdef]\n                self.henry_bs = [[i[1] for i in l] for l in henry_abcdef]\n                self.henry_cs = [[i[2] for i in l] for l in henry_abcdef]\n                self.henry_ds = [[i[3] for i in l] for l in henry_abcdef]\n                self.henry_es = [[i[4] for i in l] for l in henry_abcdef]\n                self.henry_fs = [[i[5] for i in l] for l in henry_abcdef]\n        else:\n            if henry_abcdef is None:\n                henry_abcdef = multiple_henry_inputs\n            henry_abcdef_len = 0 if henry_abcdef is None else len(henry_abcdef)\n            if not henry_abcdef_len or henry_abcdef[0] is None:\n                self.henry_as = zero_coeffs\n            else:\n                self.henry_as = henry_abcdef[0]\n            if not henry_abcdef_len or henry_abcdef[1] is None:\n                self.henry_bs = zero_coeffs\n            else:\n                self.henry_bs = henry_abcdef[1]\n            if not henry_abcdef_len or henry_abcdef[2] is None:\n                self.henry_cs = zero_coeffs\n            else:\n                self.henry_cs = henry_abcdef[2]\n            if not henry_abcdef_len or henry_abcdef[3] is None:\n                self.henry_ds = zero_coeffs\n            else:\n                self.henry_ds = henry_abcdef[3]\n            if not henry_abcdef_len or henry_abcdef[4] is None:\n                self.henry_es = zero_coeffs\n            else:\n                self.henry_es = henry_abcdef[4]\n            if not henry_abcdef_len or henry_abcdef[5] is None:\n                self.henry_fs = zero_coeffs\n            else:\n                self.henry_fs = henry_abcdef[5]\n        self.composition_independent = isinstance(GibbsExcessModel, IdealSolution) and (not self.has_henry_components)\n        self.Hfs = Hfs\n        self.Gfs = Gfs\n        self.Sfs = Sfs\n        self.model_id = 20000 + GibbsExcessModel.model_id\n        if T is not None and P is not None and (zs is not None):\n            self.T = T\n            self.P = P\n            self.zs = zs\n\n    def to_TP_zs(self, T, P, zs):\n        T_equal = hasattr(self, 'T') and T == self.T\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new.N = self.N\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        try:\n            T_equal = T == self.T\n        except:\n            T_equal = False\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.N = self.N\n        if T is not None:\n            if P is not None:\n                new.T = T\n                new.P = P\n            elif V is not None:\n\n                def to_solve(P):\n                    return self.to_TP_zs(T, P, zs).V() - V\n                P = secant(to_solve, 0.0002, xtol=1e-08, ytol=1e-10)\n                new.P = P\n        elif P is not None and V is not None:\n\n            def to_solve(T):\n                return self.to_TP_zs(T, P, zs).V() - V\n            T = secant(to_solve, 300, xtol=1e-09, ytol=1e-05)\n            new.T = T\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def transfer_data(self, new, zs, T, T_equal):\n        new.VaporPressures = self.VaporPressures\n        new.VolumeLiquids = self.VolumeLiquids\n        new.eos_pure_instances = self.eos_pure_instances\n        new.HeatCapacityGases = self.HeatCapacityGases\n        new.EnthalpyVaporizations = self.EnthalpyVaporizations\n        new.HeatCapacityLiquids = self.HeatCapacityLiquids\n        new.Psats_poly_fit = self.Psats_poly_fit\n        new._Psats_data = self._Psats_data\n        new.Psat_extrpolation = self.Psat_extrpolation\n        new.Cpgs_poly_fit = self.Cpgs_poly_fit\n        new._Cpgs_data = self._Cpgs_data\n        new.Cpls_poly_fit = self.Cpls_poly_fit\n        new._Cpls_data = self._Cpls_data\n        new.Vms_sat_poly_fit = self.Vms_sat_poly_fit\n        new._Vms_sat_data = self._Vms_sat_data\n        new._Hvap_data = self._Hvap_data\n        new.Hvap_poly_fit = self.Hvap_poly_fit\n        new.incompressible = self.incompressible\n        new.equilibrium_basis = self.equilibrium_basis\n        new.caloric_basis = self.caloric_basis\n        new.use_phis_sat = self.use_phis_sat\n        new.use_Poynting = self.use_Poynting\n        new.P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        new.use_eos_volume = self.use_eos_volume\n        new.use_Hvap_caloric = self.use_Hvap_caloric\n        new.Hfs = self.Hfs\n        new.Gfs = self.Gfs\n        new.Sfs = self.Sfs\n        new.henry_as = self.henry_as\n        new.henry_bs = self.henry_bs\n        new.henry_cs = self.henry_cs\n        new.henry_ds = self.henry_ds\n        new.henry_es = self.henry_es\n        new.henry_fs = self.henry_fs\n        new.henry_components = self.henry_components\n        new.has_henry_components = self.has_henry_components\n        new.henry_mode = self.henry_mode\n        new.composition_independent = self.composition_independent\n        new.model_id = self.model_id\n        new.use_Tait = self.use_Tait\n        new._Tait_B_data = self._Tait_B_data\n        new._Tait_C_data = self._Tait_C_data\n        if T_equal and (self.composition_independent or self.zs is zs):\n            new.GibbsExcessModel = self.GibbsExcessModel\n        else:\n            new.GibbsExcessModel = self.GibbsExcessModel.to_T_xs(T=T, xs=zs)\n        try:\n            if T_equal:\n                if not self.has_henry_components:\n                    try:\n                        new._Psats = self._Psats\n                        new._dPsats_dT = self._dPsats_dT\n                        new._d2Psats_dT2 = self._d2Psats_dT2\n                    except:\n                        pass\n                    try:\n                        new._lnPsats = self._lnPsats\n                        new._dPsats_dT_over_Psats = self._dPsats_dT_over_Psats\n                    except:\n                        pass\n                else:\n                    try:\n                        new._lnHenry_matrix = self._lnHenry_matrix\n                        new._dlnHenry_matrix_dT = self._dlnHenry_matrix_dT\n                        new._d2lnHenry_matrix_dT2 = self._d2lnHenry_matrix_dT2\n                    except:\n                        pass\n                try:\n                    new._Vms_sat = self._Vms_sat\n                    new._Vms_sat_dT = self._Vms_sat_dT\n                    new._d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n                except:\n                    pass\n                try:\n                    new._Cpigs = self._Cpigs\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_pure = self._Cpig_integrals_pure\n                except:\n                    pass\n        except:\n            pass\n        return new\n    supports_lnphis_args = False\n\n    def lnphis_args(self):\n        try:\n            return self._lnphis_args\n        except:\n            pass\n        lnPsats = self.lnPsats()\n        Poyntings = self.Poyntings()\n        phis_sat = self.phis_sat()\n        activity_args = self.GibbsExcessModel.gammas_args()\n        lnphis = zeros(self.N) if self.vectorized else [0.0] * self.N\n        self._lnphis_args = (self.model_id, self.T, self.P, self.N, lnPsats, Poyntings, phis_sat) + activity_args + (lnphis,)\n        return self._lnphis_args\n\n    def lnHenry_matrix(self):\n        \"\"\"Method to calculate and return the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        .. math::\n            \\\\ln \\\\text{H}_{i,j} = A_{ij}+\\\\frac{B_{ij}}{T}+C_{ij}\\\\ln T + D_{ij}T\n            + \\\\frac{E_{ij}}{T^2} + F_{ij}{T^2}\n\n        Returns\n        -------\n        lnHenry_matrix : list[list[float]]\n            Henry's law interaction parameters, [log(Pa)]\n\n        Notes\n        -----\n        Solvent/solvent and gas/gas values are all 0.\n        \"\"\"\n        try:\n            return self._lnHenry_matrix\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            lnHenry_matrix = zeros((N, N))\n        else:\n            lnHenry_matrix = [[0.0] * N for _ in range(N)]\n        lnHenry_matrix = ln_henries(self.T, N, self.henry_as, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, lnHenry_matrix)\n        self._lnHenry_matrix = lnHenry_matrix\n        return lnHenry_matrix\n\n    def dlnHenry_matrix_dT(self):\n        \"\"\"Method to calculate and return the first temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        dlnHenry_matrix_dT : list[list[float]]\n            First temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._dlnHenry_matrix_dT\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            dlnHenry_matrix_dT = zeros((N, N))\n        else:\n            dlnHenry_matrix_dT = [[0.0] * N for _ in range(N)]\n        dlnHenry_matrix_dT = dln_henries_dT(self.T, N, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, dlnHenry_matrix_dT)\n        self._dlnHenry_matrix_dT = dlnHenry_matrix_dT\n        return dlnHenry_matrix_dT\n\n    def d2lnHenry_matrix_dT2(self):\n        \"\"\"Method to calculate and return the second temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        d2lnHenry_matrix_dT2 : list[list[float]]\n            Second temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._d2lnHenry_matrix_dT2\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            d2lnHenry_matrix_dT2 = zeros((N, N))\n        else:\n            d2lnHenry_matrix_dT2 = [[0.0] * N for _ in range(N)]\n        d2lnHenry_matrix_dT2 = d2ln_henries_dT2(self.T, N, self.henry_bs, self.henry_cs, self.henry_es, self.henry_fs, d2lnHenry_matrix_dT2)\n        self._d2lnHenry_matrix_dT2 = d2lnHenry_matrix_dT2\n        return d2lnHenry_matrix_dT2\n\n    def Henry_constants(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        Hs = zeros(N) if vectorized else [0.0] * N\n        Henry_constants(lnHenry_matrix, zs, henry_components, solvents_with_parameters, Hs)\n        return Hs\n        dHenry_constants_dT\n\n    def dHenry_constants_dT(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        dHs = zeros(N) if vectorized else [0.0] * N\n        dHenry_constants_dT(lnHenry_matrix, dlnHenry_matrix_dT, zs, henry_components, solvents_with_parameters, dHs)\n        return dHs\n\n    def d2Henry_constants_dT2(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        d2lnHenry_matrix_dT2 = self.d2lnHenry_matrix_dT2()\n        d2Hs = zeros(N) if vectorized else [0.0] * N\n        d2Henry_constants_dT2(lnHenry_matrix, dlnHenry_matrix_dT, d2lnHenry_matrix_dT2, zs, henry_components, solvents_with_parameters, d2Hs)\n        return d2Hs\n\n    def Psats_T_ref(self):\n        try:\n            return self._Psats_T_ref\n        except AttributeError:\n            pass\n        VaporPressures, N = (self.VaporPressures, self.N)\n        T_REF_IG = self.T_REF_IG\n        if self.has_henry_components:\n            self._Psats_T_ref = self.to(T=T_REF_IG, P=self.P, zs=self.zs).Psats()\n        else:\n            self._Psats_T_ref = [VaporPressures[i](T_REF_IG) for i in range(N)]\n        return self._Psats_T_ref\n\n    def Psats_at(self, T):\n        if self.Psats_poly_fit:\n            return self._Psats_at_poly_fit(T, self._Psats_data, range(self.N))\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).Psats()\n        VaporPressures = self.VaporPressures\n        return [VaporPressures[i](T) for i in range(self.N)]\n\n    @staticmethod\n    def _Psats_at_poly_fit(T, Psats_data, cmps):\n        Psats = []\n        T_inv = 1.0 / T\n        logT = log(T)\n        Tmins, Tmaxes, coeffs = (Psats_data[0], Psats_data[3], Psats_data[6])\n        for i in cmps:\n            if T < Tmins[i]:\n                A, B, C = Psats_data[9][i]\n                Psat = A + B * T_inv + C * logT\n            elif T > Tmaxes[i]:\n                A, B, C = Psats_data[10][i]\n                Psat = A + B * T_inv + C * logT\n            else:\n                Psat = 0.0\n                for c in coeffs[i]:\n                    Psat = Psat * T + c\n            try:\n                Psats.append(exp(Psat))\n            except:\n                Psats.append(1.6549840276802644e+300)\n        return Psats\n\n    def Psats(self):\n        try:\n            return self._Psats\n        except AttributeError:\n            pass\n        N = self.N\n        T, cmps = (self.T, range(N))\n        if self.Psats_poly_fit:\n            self._Psats = Psats = self._Psats_at_poly_fit(T, self._Psats_data, cmps)\n        else:\n            self._Psats = Psats = []\n            for i in self.VaporPressures:\n                Psats.append(i.T_dependent_property(T))\n        if self.has_henry_components:\n            Hs, henry_components = (self.Henry_constants(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    Psats[i] = Hs[i]\n        return Psats\n\n    def PIP(self):\n        dP_dT = self.dP_dT()\n        if dP_dT == 0:\n            return self.PIP_INCALCULABLE_VALUE\n        return phase_identification_parameter(self.V(), self.dP_dT(), self.dP_dV(), self.d2P_dV2(), self.d2P_dTdV())\n\n    @staticmethod\n    def _dPsats_dT_at_poly_fit(T, Psats_data, cmps, Psats):\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        dPsats_dT = []\n        Tmins, Tmaxes, dcoeffs, coeffs_low, coeffs_high = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n        for i in cmps:\n            if T < Tmins[i]:\n                dPsat_dT = Psats[i] * (-coeffs_low[i][1] * Tinv2 + coeffs_low[i][2] * T_inv)\n            elif T > Tmaxes[i]:\n                dPsat_dT = Psats[i] * (-coeffs_high[i][1] * Tinv2 + coeffs_high[i][2] * T_inv)\n            else:\n                dPsat_dT = 0.0\n                for c in dcoeffs[i]:\n                    dPsat_dT = dPsat_dT * T + c\n                dPsat_dT *= Psats[i]\n            dPsats_dT.append(dPsat_dT)\n        return dPsats_dT\n\n    def dPsats_dT_at(self, T, Psats=None):\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if self.Psats_poly_fit:\n            return self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(self.N), Psats)\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).dPsats_dT()\n        return [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\n\n    def dPsats_dT(self):\n        try:\n            return self._dPsats_dTT_dependent_property_derivative\n        except:\n            pass\n        T, N = (self.T, self.N)\n        if self.Psats_poly_fit:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            self._dPsats_dT = dPsats_dT = self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(N), Psats)\n            return dPsats_dT\n        self._dPsats_dT = dPsats_dT = [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            dHs, henry_components = (self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dPsats_dT[i] = dHs[i]\n        return dPsats_dT\n\n    def d2Psats_dT2(self):\n        try:\n            return self._d2Psats_dT2\n        except:\n            pass\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        T_inv2 = T_inv * T_inv\n        self._d2Psats_dT2 = d2Psats_dT2 = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = (Psats_data[0], Psats_data[3], Psats_data[8])\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    x0 = B * T_inv - C\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    x0 = B * T_inv - C\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\n                else:\n                    d2Psat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2Psat_dT2 = d2Psat_dT2 * T + c\n                    d2Psat_dT2 = dPsats_dT[i] * dPsats_dT[i] / Psats[i] + Psats[i] * d2Psat_dT2\n                d2Psats_dT2.append(d2Psat_dT2)\n            return d2Psats_dT2\n        self._d2Psats_dT2 = d2Psats_dT2 = [VaporPressure.T_dependent_property_derivative(T=T, order=2) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            d2Hs, henry_components = (self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psats_dT2[i] = d2Hs[i]\n        return d2Psats_dT2\n\n    def lnPsats(self):\n        try:\n            return self._lnPsats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        logT = log(T)\n        lnPsats = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, coeffs = (Psats_data[0], Psats_data[3], Psats_data[6])\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    Psat = A + B * T_inv + C * logT\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    Psat = A + B * T_inv + C * logT\n                else:\n                    Psat = 0.0\n                    for c in coeffs[i]:\n                        Psat = Psat * T + c\n                lnPsats.append(Psat)\n            self._lnPsats = lnPsats\n            return lnPsats\n        self._lnPsats = lnPsats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, henry_components = (self.Henry_constants(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    lnPsats[i] = log(Hs[i])\n        return lnPsats\n\n    def dlnPsats_dT(self):\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs = (Psats_data[0], Psats_data[3], Psats_data[7])\n            dlnPsats_dT = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    dPsat_dT = -B * Tinv2 + C * T_inv\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    dPsat_dT = -B * Tinv2 + C * T_inv\n                else:\n                    dPsat_dT = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT = dPsat_dT * T + c\n                dlnPsats_dT.append(dPsat_dT)\n            return dlnPsats_dT\n        dlnPsats_dT = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dlnPsats_dT[i] = dHs[i] / Hs[i]\n        return dlnPsats_dT\n\n    def d2lnPsats_dT2(self):\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        T_inv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = (Psats_data[0], Psats_data[3], Psats_data[8])\n            d2lnPsats_dT2 = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\n                else:\n                    d2lnPsat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2lnPsat_dT2 = d2lnPsat_dT2 * T + c\n                d2lnPsats_dT2.append(d2lnPsat_dT2)\n            return d2lnPsats_dT2\n        d2lnPsats_dT2 = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, d2Hs, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2lnPsats_dT2[i] = (d2Hs[i] - dHs[i] * dHs[i] / Hs[i]) / Hs[i]\n        return d2lnPsats_dT2\n\n    def dPsats_dT_over_Psats(self):\n        try:\n            return self._dPsats_dT_over_Psats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            dPsat_dT_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n            for i in range(N):\n                if T < Tmins[i]:\n                    dPsat_dT_over_Psat = -low_coeffs[i][1] * Tinv2 + low_coeffs[i][2] * T_inv\n                elif T > Tmaxes[i]:\n                    dPsat_dT_over_Psat = -high_coeffs[i][1] * Tinv2 + high_coeffs[i][2] * T_inv\n                else:\n                    dPsat_dT_over_Psat = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT_over_Psat = dPsat_dT_over_Psat * T + c\n                dPsat_dT_over_Psats.append(dPsat_dT_over_Psat)\n            self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n            return dPsat_dT_over_Psats\n        dPsat_dT_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHenry_constants_dT, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dPsat_dT_over_Psats[i] = dHenry_constants_dT[i] / Hs[i]\n        self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n        return dPsat_dT_over_Psats\n\n    def d2Psats_dT2_over_Psats(self):\n        try:\n            return self._d2Psats_dT2_over_Psats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        Tinv4 = Tinv2 * Tinv2\n        c0 = (T + T) * Tinv4\n        if self.Psats_poly_fit:\n            d2Psat_dT2_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n            for i in range(N):\n                if T < Tmins[i]:\n                    B, C = (low_coeffs[i][1], low_coeffs[i][2])\n                    x0 = B - C * T\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\n                elif T > Tmaxes[i]:\n                    B, C = (high_coeffs[i][1], high_coeffs[i][2])\n                    x0 = B - C * T\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\n                else:\n                    dPsat_dT = 0.0\n                    d2Psat_dT2 = 0.0\n                    for a in dcoeffs[i]:\n                        d2Psat_dT2 = T * d2Psat_dT2 + dPsat_dT\n                        dPsat_dT = T * dPsat_dT + a\n                    d2Psat_dT2_over_Psat = dPsat_dT * dPsat_dT + d2Psat_dT2\n                d2Psat_dT2_over_Psats.append(d2Psat_dT2_over_Psat)\n            self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n            return d2Psat_dT2_over_Psats\n        d2Psat_dT2_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, d2Henry_constants_dT2, henry_components = (self.Henry_constants(), self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psat_dT2_over_Psats[i] = d2Henry_constants_dT2[i] / Hs[i]\n        self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n        return d2Psat_dT2_over_Psats\n\n    @staticmethod\n    def _Vms_sat_at(T, Vms_sat_data, cmps):\n        Tmins, Tmaxes, coeffs, coeffs_Tmin = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[6], Vms_sat_data[9])\n        Vms_sat = []\n        for i in cmps:\n            if T < Tmins[i]:\n                Vm = 0.0\n                for c in coeffs_Tmin[i]:\n                    Vm = Vm * T + c\n            elif T > Tmaxes[i]:\n                Vm = (T - Tmaxes[i]) * Vms_sat_data[4][i] + Vms_sat_data[5][i]\n            else:\n                Vm = 0.0\n                for c in coeffs[i]:\n                    Vm = Vm * T + c\n            Vms_sat.append(Vm)\n        return Vms_sat\n\n    def Vms_sat_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n        VolumeLiquids = self.VolumeLiquids\n        return [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n\n    def Vms_sat(self):\n        try:\n            return self._Vms_sat\n        except AttributeError:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat = Vms_sat = self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n            return Vms_sat\n        elif self.use_eos_volume:\n            Vms = []\n            eoss = self.eos_pure_instances\n            Psats = self.Psats()\n            for i, e in enumerate(eoss):\n                if T < e.Tc:\n                    Vms.append(e.V_l_sat(T))\n                else:\n                    e = e.to(T=T, P=Psats[i])\n                    try:\n                        Vms.append(e.V_l)\n                    except:\n                        Vms.append(e.V_g)\n            self._Vms_sat = Vms\n            return Vms\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat = [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n        return self._Vms_sat\n\n    @staticmethod\n    def _dVms_sat_dT_at(T, Vms_sat_data, cmps):\n        Vms_sat_dT = []\n        Tmins, Tmaxes, dcoeffs = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[7])\n        for i in cmps:\n            if T < Tmins[i]:\n                dVm = horner_and_der2(Vms_sat_data[9][i], T)[1]\n            elif T > Tmaxes[i]:\n                dVm = Vms_sat_data[4][i]\n            else:\n                dVm = 0.0\n                for c in dcoeffs[i]:\n                    dVm = dVm * T + c\n            Vms_sat_dT.append(dVm)\n        return Vms_sat_dT\n\n    def dVms_sat_dT_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n        return [obj.T_dependent_property_derivative(T=T) for obj in self.VolumeLiquids]\n\n    def dVms_sat_dT(self):\n        try:\n            return self._Vms_sat_dT\n        except:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_dT = self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n            return self._Vms_sat_dT\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat_dT = Vms_sat_dT = [obj.T_dependent_property_derivative(T=T) for obj in VolumeLiquids]\n        return Vms_sat_dT\n\n    def d2Vms_sat_dT2(self):\n        try:\n            return self._d2Vms_sat_dT2\n        except:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            d2Vms_sat_dT2 = self._d2Vms_sat_dT2 = []\n            Vms_sat_data = self._Vms_sat_data\n            Tmins, Tmaxes, d2coeffs = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[8])\n            for i in range(self.N):\n                d2Vm = 0.0\n                if Tmins[i] < T < Tmaxes[i]:\n                    for c in d2coeffs[i]:\n                        d2Vm = d2Vm * T + c\n                elif T < Tmins[i]:\n                    d2Vm = horner_and_der2(Vms_sat_data[9][i], T)[2]\n                d2Vms_sat_dT2.append(d2Vm)\n            return d2Vms_sat_dT2\n        VolumeLiquids = self.VolumeLiquids\n        self._d2Vms_sat_dT2 = [obj.T_dependent_property_derivative(T=T, order=2) for obj in VolumeLiquids]\n        return self._d2Vms_sat_dT2\n\n    def Vms_sat_T_ref(self):\n        try:\n            return self._Vms_sat_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_T_ref = evaluate_linear_fits(self._Vms_sat_data, T_REF_IG)\n        else:\n            VolumeLiquids, cmps = (self.VolumeLiquids, range(self.N))\n            self._Vms_sat_T_ref = [VolumeLiquids[i].T_dependent_property(T_REF_IG) for i in cmps]\n        return self._Vms_sat_T_ref\n\n    def dVms_sat_dT_T_ref(self):\n        try:\n            return self._dVms_sat_dT_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._dVms_sat_dT_T_ref = evaluate_linear_fits_d(self._Vms_sat_data, self.T)\n        else:\n            VolumeLiquids, cmps = (self.VolumeLiquids, range(self.N))\n            self._dVms_sat_dT_T_ref = [VolumeLiquids[i].T_dependent_property_derivative(T_REF_IG) for i in cmps]\n        return self._dVms_sat_dT_T_ref\n\n    def Vms(self):\n        return self.Vms_sat()\n\n    def dVms_dT(self):\n        return self.dVms_sat_dT()\n\n    def d2Vms_dT2(self):\n        return self.d2Vms_sat_dT2()\n\n    def dVms_dP(self):\n        return [0.0] * self.N\n\n    def d2Vms_dP2(self):\n        return [0.0] * self.N\n\n    def d2Vms_dPdT(self):\n        return [0.0] * self.N\n\n    def Hvaps(self):\n        try:\n            return self._Hvaps\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = (self.T, self.EnthalpyVaporizations, range(self.N))\n        self._Hvaps = Hvaps = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\n            for i in cmps:\n                Hvap = 0.0\n                if T < Tcs[i]:\n                    x = log(1.0 - T * Tcs_inv[i])\n                    for c in coeffs[i]:\n                        Hvap = Hvap * x + c\n                Hvaps.append(Hvap)\n            return Hvaps\n        self._Hvaps = Hvaps = [EnthalpyVaporizations[i](T) for i in cmps]\n        for i in cmps:\n            if Hvaps[i] is None:\n                Hvaps[i] = 0.0\n        return Hvaps\n\n    def dHvaps_dT(self):\n        try:\n            return self._dHvaps_dT\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = (self.T, self.EnthalpyVaporizations, range(self.N))\n        self._dHvaps_dT = dHvaps_dT = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\n            for i in cmps:\n                dHvap_dT = 0.0\n                if T < Tcs[i]:\n                    p = log((Tcs[i] - T) * Tcs_inv[i])\n                    x = 1.0\n                    a = 1.0\n                    for c in coeffs[i][-2::-1]:\n                        dHvap_dT += a * c * x\n                        x *= p\n                        a += 1.0\n                    dHvap_dT /= T - Tcs[i]\n                dHvaps_dT.append(dHvap_dT)\n            return dHvaps_dT\n        self._dHvaps_dT = dHvaps_dT = [EnthalpyVaporizations[i].T_dependent_property_derivative(T) for i in cmps]\n        for i in cmps:\n            if dHvaps_dT[i] is None:\n                dHvaps_dT[i] = 0.0\n        return dHvaps_dT\n\n    def Hvaps_T_ref(self):\n        try:\n            return self._Hvaps_T_ref\n        except AttributeError:\n            pass\n        EnthalpyVaporizations, cmps = (self.EnthalpyVaporizations, range(self.N))\n        T_REF_IG = self.T_REF_IG\n        self._Hvaps_T_ref = [EnthalpyVaporizations[i](T_REF_IG) for i in cmps]\n        return self._Hvaps_T_ref\n\n    def Poyntings_at(self, T, P, Psats=None, Vms=None):\n        if not self.use_Poynting:\n            return [1.0] * self.N\n        cmps = range(self.N)\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        RT_inv = 1.0 / (R * T)\n        return [exp(Vms[i] * (P - Psats[i]) * RT_inv) for i in cmps]\n\n    def Poyntings(self):\n        \"\"\"Method to calculate and return the Poynting pressure correction\n        factors of the phase, [-].\n\n        .. math::\n            \\\\text{Poynting}_i = \\\\exp\\\\left(\\\\frac{V_{m,i}(P-P_{sat})}{RT}\\\\right)\n\n        Returns\n        -------\n        Poyntings : list[float]\n            Poynting pressure correction factors, [-]\n\n        Notes\n        -----\n        The above formula is correct for pressure-independent molar volumes.\n        When the volume does depend on pressure, the full expression is:\n\n        .. math::\n            \\\\text{Poynting} = \\\\exp\\\\left[\\\\frac{\\\\int_{P_i^{sat}}^P V_i^l dP}{RT}\\\\right]\n\n        When a specified model e.g. the Tait equation is used, an analytical\n        integral of this term is normally available.\n\n        \"\"\"\n        try:\n            return self._Poyntings\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._Poyntings = [1.0] * self.N\n            return self._Poyntings\n        T, P = (self.T, self.P)\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        RT_inv = 1.0 / (R * T)\n        self._Poyntings = [trunc_exp(Vml * (P - Psat) * RT_inv) for Psat, Vml in zip(Psats, Vms_sat)]\n        return self._Poyntings\n\n    def dPoyntings_dT(self):\n        try:\n            return self._dPoyntings_dT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dT = [0.0] * self.N\n            return self._dPoyntings_dT\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        x0 = 1.0 / R\n        x1 = 1.0 / T\n        RT_inv = x0 * x1\n        self._dPoyntings_dT = dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = Psats[i]\n            x4 = P - x3\n            x5 = x1 * x2 * x4\n            dPoyntings_dTi = -RT_inv * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * trunc_exp(x0 * x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def dPoyntings_dT_at(self, T, P, Psats=None, Vms=None, dPsats_dT=None, dVms_sat_dT=None):\n        if not self.use_Poynting:\n            return [0.0] * self.N\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if dPsats_dT is None:\n            dPsats_dT = self.dPsats_dT_at(T, Psats)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        if dVms_sat_dT is None:\n            dVms_sat_dT = self.dVms_sat_dT_at(T)\n        x0 = 1.0 / R\n        x1 = 1.0 / T\n        dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x4 = P - Psats[i]\n            x5 = x1 * x2 * x4\n            dPoyntings_dTi = -x0 * x1 * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * exp(x0 * x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def d2Poyntings_dT2(self):\n        try:\n            return self._d2Poyntings_dT2\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dT2 = [0.0] * self.N\n            return self._d2Poyntings_dT2\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        d2Psats_dT2 = self.d2Psats_dT2()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        x6 = 1.0 / T\n        x7 = x6 + x6\n        x11 = 1.0 / R\n        x12 = x11 * x6\n        c0 = 2.0 * x6 * x6\n        self._d2Poyntings_dT2 = d2Poyntings_dT2 = []\n        \"\\n        from sympy import *\\n        R, T, P = symbols('R, T, P')\\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\\n        RT_inv = 1/(R*T)\\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\\n        cse(diff(Poy, T, 2), optimizations='basic')\\n        \"\n        for i in range(self.N):\n            x0 = Vms[i]\n            x1 = Psats[i]\n            x2 = P - x1\n            x3 = x0 * x2\n            x4 = dPsats_dT[i]\n            x5 = x0 * x4\n            x8 = dVms_sat_dT[i]\n            x9 = x2 * x8\n            x10 = x3 * x6\n            x50 = x10 + x5 - x9\n            d2Poyntings_dT2i = x12 * (-x0 * d2Psats_dT2[i] + x12 * x50 * x50 + x2 * d2Vms_sat_dT2[i] - 2.0 * x4 * x8 + x5 * x7 - x7 * x9 + x3 * c0) * exp(x10 * x11)\n            d2Poyntings_dT2.append(d2Poyntings_dT2i)\n        return d2Poyntings_dT2\n\n    def dPoyntings_dP(self):\n        \"\"\"from sympy import *\n        R, T, P, zi = symbols('R, T, P, zi')\n        Vml = symbols('Vml', cls=Function)\n        cse(diff(exp(Vml(T)*(P - Psati(T))/(R*T)), P), optimizations='basic')\n        \"\"\"\n        try:\n            return self._dPoyntings_dP\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dP = [0.0] * self.N\n            return self._dPoyntings_dP\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        Vms = self.Vms_sat()\n        self._dPoyntings_dP = dPoyntings_dPs = []\n        for i in range(self.N):\n            x0 = Vms[i] / (R * T)\n            dPoyntings_dPs.append(x0 * exp(x0 * (P - Psats[i])))\n        return dPoyntings_dPs\n\n    def d2Poyntings_dPdT(self):\n        \"\"\"\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        Poyf = symbols('Poyf')\n        cse(diff(Poy, T, P).subs(Poy, Poyf), optimizations='basic')\n        \"\"\"\n        try:\n            return self._d2Poyntings_dPdT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dPdT = [0.0] * self.N\n            return self._d2Poyntings_dPdT\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms = self._Vms_sat\n        except AttributeError:\n            Vms = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._dVms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        x0 = R_inv\n        x1 = 1.0 / self.T\n        P = self.P\n        nRT_inv = -x0 * x1\n        self._d2Poyntings_dPdT = d2Poyntings_dPdT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = x1 * x2\n            x4 = dVms_sat_dT[i]\n            x5 = Psats[i]\n            x6 = P - x5\n            v = Poyntings[i] * nRT_inv * (x0 * x3 * (x2 * dPsats_dT[i] + x3 * x6 - x4 * x6) + x3 - x4)\n            d2Poyntings_dPdT.append(v)\n        return d2Poyntings_dPdT\n    d2Poyntings_dTdP = d2Poyntings_dPdT\n\n    def phis_sat_at(self, T):\n        if not self.use_phis_sat:\n            return [1.0] * self.N\n        phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def phis_sat(self):\n        \"\"\"Method to calculate and return the saturation fugacity coefficient\n        correction factors of the phase, [-].\n\n        These are calculated from the\n        provided pure-component equations of state. This term should only be\n        used with a consistent vapor-phase cubic equation of state.\n\n        Returns\n        -------\n        phis_sat : list[float]\n            Saturation fugacity coefficient correction factors, [-]\n\n        Notes\n        -----\n        .. warning::\n            This factor cannot be calculated when a compound is supercritical,\n            as there is no longer any vapor-liquid pure-component equilibrium\n            (by definition).\n\n        \"\"\"\n        try:\n            return self._phis_sat\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._phis_sat = [1.0] * self.N\n            return self._phis_sat\n        T = self.T\n        self._phis_sat = phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def dphis_sat_dT_at(self, T):\n        if not self.use_phis_sat:\n            return [0.0] * self.N\n        dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def dphis_sat_dT(self):\n        try:\n            return self._dphis_sat_dT\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._dphis_sat_dT = [0.0] * self.N\n            return self._dphis_sat_dT\n        T = self.T\n        self._dphis_sat_dT = dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def d2phis_sat_dT2(self):\n        try:\n            return self._d2phis_sat_dT2\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._d2phis_sat_dT2 = [0.0] * self.N\n            return self._d2phis_sat_dT2\n        T = self.T\n        self._d2phis_sat_dT2 = d2phis_sat_dT2 = []\n        for i in self.eos_pure_instances:\n            try:\n                d2phis_sat_dT2.append(i.d2phi_sat_dT2(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    d2phis_sat_dT2.append(0.0)\n                else:\n                    raise e\n        return d2phis_sat_dT2\n\n    def phis_at(self, T, P, zs, Psats=None, gammas=None, phis_sat=None, Poyntings=None):\n        P_inv = 1.0 / P\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if gammas is None:\n            gammas = self.gammas_at(T, zs)\n        if phis_sat is None:\n            phis_sat = self.phis_sat_at(T)\n        if Poyntings is None:\n            Poyntings = self.Poyntings_at(T, P, Psats=Psats)\n        return [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n\n    def phis(self):\n        \"\"\"Method to calculate the fugacity coefficients of the\n        GibbsExcessLiquid phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}\n            {P}\n\n        Returns\n        -------\n        phis : list[float]\n            Fugacity coefficients of all components in the phase, [-]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1.\n        \"\"\"\n        try:\n            return self._phis\n        except AttributeError:\n            pass\n        P = self.P\n        try:\n            gammas = self._gammas\n        except AttributeError:\n            gammas = self.gammas()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            phis_sat = self._phis_sat\n        except AttributeError:\n            phis_sat = self.phis_sat()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        P_inv = 1.0 / P\n        self._phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n        return self._phis\n\n    def lnphis(self):\n        try:\n            return self._lnphis\n        except AttributeError:\n            pass\n        try:\n            self._lnphis = [log(i) for i in self.phis()]\n        except:\n            P = self.P\n            try:\n                gammas = self._gammas\n            except AttributeError:\n                gammas = self.gammas()\n            try:\n                lnPsats = self._lnPsats\n            except AttributeError:\n                lnPsats = self.lnPsats()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n            P_inv = 1.0 / P\n            self._lnphis = [log(gammas[i] * Poyntings[i] * phis_sat[i] * P_inv) + lnPsats[i] for i in range(self.N)]\n        return self._lnphis\n    lnphis_G_min = lnphis\n    lnphis_lowest_Gibbs = lnphis\n\n    def dphis_dT(self):\n        try:\n            return self._dphis_dT\n        except AttributeError:\n            pass\n        P = self.P\n        Psats = self.Psats()\n        gammas = self.gammas()\n        if self.use_Poynting:\n            dPoyntings_dT = self.dPoyntings_dT()\n            Poyntings = self.Poyntings()\n        else:\n            dPoyntings_dT = [0.0] * self.N\n            Poyntings = [1.0] * self.N\n        dPsats_dT = self.dPsats_dT()\n        dgammas_dT = self.GibbsExcessModel.dgammas_dT()\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT()\n            phis_sat = self.phis_sat()\n        else:\n            dphis_sat_dT = [0.0] * self.N\n            phis_sat = [1.0] * self.N\n        self._dphis_dT = dphis_dTl = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2 * x3\n            x5 = x0 * x1\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\n            dphis_dTl.append(v)\n        return dphis_dTl\n\n    def dphis_dT_at(self, T, P, zs, phis_also=False):\n        Psats = self.Psats_at(T)\n        dPsats_dT = self.dPsats_dT_at(T, Psats)\n        Vms = self.Vms_sat_at(T)\n        dVms_sat_dT = self.dVms_sat_dT_at(T)\n        gammas = self.gammas_at(T, zs)\n        dgammas_dT = self.dgammas_dT_at(T, zs)\n        if self.use_Poynting:\n            Poyntings = self.Poyntings_at(T, P, Psats, Vms)\n            dPoyntings_dT = self.dPoyntings_dT_at(T, P, Psats=Psats, Vms=Vms, dPsats_dT=dPsats_dT, dVms_sat_dT=dVms_sat_dT)\n        else:\n            Poyntings = [1.0] * self.N\n            dPoyntings_dT = [0.0] * self.N\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT_at(T)\n            phis_sat = self.phis_sat_at(T)\n        else:\n            dphis_sat_dT = [0.0] * self.N\n            phis_sat = [1.0] * self.N\n        dphis_dT = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2 * x3\n            x5 = x0 * x1\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\n            dphis_dT.append(v)\n        if phis_also:\n            P_inv = 1.0 / P\n            phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n            return (dphis_dT, phis)\n        return dphis_dT\n\n    def dlnphis_dT(self):\n        try:\n            return self._dlnphis_dT\n        except AttributeError:\n            pass\n        dphis_dT = self.dphis_dT()\n        phis = self.phis()\n        self._dlnphis_dT = [i / j for i, j in zip(dphis_dT, phis)]\n        return self._dlnphis_dT\n\n    def dlnphis_dP(self):\n        \"\"\"Method to calculate the pressure derivative of log fugacity\n        coefficients of the phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P} =\n            \\\\frac{\\\\frac{\\\\partial \\\\text{Poynting}_i}{\\\\partial P}}\n            {\\\\text{Poynting}_i} - \\\\frac{1}{P}\n\n        Returns\n        -------\n        dlnphis_dP : list[float]\n            Pressure derivative of log fugacity coefficients of all components\n            in the phase, [1/Pa]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1. For\n        that case, :math:`\\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P}=\\\\frac{1}{P}`.\n        \"\"\"\n        try:\n            return self._dlnphis_dP\n        except AttributeError:\n            pass\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        try:\n            dPoyntings_dP = self._dPoyntings_dP\n        except AttributeError:\n            dPoyntings_dP = self.dPoyntings_dP()\n        P_inv = 1.0 / self.P\n        self._dlnphis_dP = [dPoyntings_dP[i] / Poyntings[i] - P_inv for i in range(self.N)]\n        return self._dlnphis_dP\n\n    def gammas_at(self, T, zs):\n        if self.composition_independent:\n            return [1.0] * self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).gammas()\n\n    def dgammas_dT_at(self, T, zs):\n        if self.composition_independent:\n            return [0.0] * self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).dgammas_dT()\n\n    def gammas(self):\n        \"\"\"Method to calculate and return the activity coefficients of the\n        phase, [-]. This is a direct call to\n        :obj:`GibbsExcess.gammas <thermo.activity.GibbsExcess.gammas>`.\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n        \"\"\"\n        try:\n            return self.GibbsExcessModel._gammas\n        except AttributeError:\n            return self.GibbsExcessModel.gammas()\n\n    def dgammas_dT(self):\n        \"\"\"Method to calculate and return the temperature derivative of\n        activity coefficients of the phase, [-].\n\n        This is a direct call to\n        :obj:`GibbsExcess.dgammas_dT <thermo.activity.GibbsExcess.dgammas_dT>`.\n\n        Returns\n        -------\n        dgammas_dT : list[float]\n            First temperature derivative of the activity coefficients, [1/K]\n        \"\"\"\n        return self.GibbsExcessModel.dgammas_dT()\n\n    def H_old(self):\n        T = self.T\n        RT = R * T\n        P = self.P\n        zs, cmps = (self.zs, range(self.N))\n        T_REF_IG = self.T_REF_IG\n        P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n        H = 0.0\n        if P_DEPENDENT_H_LIQ:\n            \"\\n            from scipy.integrate import *\\n            from CoolProp.CoolProp import PropsSI\\n\\n            fluid = 'decane'\\n            T = 400\\n            Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\\n            P2 = Psat*100\\n            dP = P2 - Psat\\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\\n            Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\\n            dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\\n\\n            def to_int(P):\\n                Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\\n                alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\\n                return Vm -alpha*T*Vm\\n            quad(to_int, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dH\\n            \"\n            if self.use_IG_Cp:\n                try:\n                    Psats = self._Psats\n                except AttributeError:\n                    Psats = self.Psats()\n                try:\n                    dPsats_dT = self._dPsats_dT\n                except AttributeError:\n                    dPsats_dT = self.dPsats_dT()\n                try:\n                    Vms_sat = self._Vms_sat\n                except AttributeError:\n                    Vms_sat = self.Vms_sat()\n                try:\n                    dVms_sat_dT = self._Vms_sat_dT\n                except AttributeError:\n                    dVms_sat_dT = self.dVms_sat_dT()\n                failed_dPsat_dT = False\n                try:\n                    H = 0.0\n                    for i in cmps:\n                        dV_vap = R * T / Psats[i] - Vms_sat[i]\n                        dS_vap = dPsats_dT[i] * dV_vap\n                        Hvap = T * dS_vap\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\n                except ZeroDivisionError:\n                    failed_dPsat_dT = True\n                if failed_dPsat_dT or isinf(H):\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    H = 0.0\n                    for i in cmps:\n                        Hvap = T * dPsats_dT_over_Psats[i] * RT\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\n                if self.use_Tait:\n                    dH_dP_integrals_Tait = self.dH_dP_integrals_Tait()\n                    for i in cmps:\n                        H += zs[i] * dH_dP_integrals_Tait[i]\n                elif self.use_Poynting:\n                    for i in cmps:\n                        dP = P - Psats[i]\n                        H += zs[i] * dP * (Vms_sat[i] - T * dVms_sat_dT[i])\n            else:\n                Psats = self.Psats()\n                Vms_sat = self.Vms_sat()\n                dVms_sat_dT = self.dVms_sat_dT()\n                dPsats_dT = self.dPsats_dT()\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Cpl_integrals_pure = self._Cpl_integrals_pure()\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                Vms_sat_T_ref = self.Vms_sat_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Hvaps = self.Hvaps()\n                H = 0.0\n                for i in range(self.N):\n                    H += zs[i] * (Cpl_integrals_pure[i] - Hvaps_T_ref[i])\n                    dP = P - Psats_T_ref[i]\n                    H += zs[i] * dP * (Vms_sat_T_ref[i] - T_REF_IG * dVms_sat_dT_T_ref[i])\n        else:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i] * (Cpig_integrals_pure[i] - Hvaps[i])\n        H += self.GibbsExcessModel.HE()\n        return H\n    del H_old\n\n    def H(self):\n        \"\"\"Method to calculate the enthalpy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n             \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i\\\\left[-H_{vap,i}\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        Returns\n        -------\n        H : float\n            Enthalpy of the phase, [J/(mol)]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._H\n        except AttributeError:\n            pass\n        H = 0.0\n        T = self.T\n        nRT2 = -R * T * T\n        zs, cmps = (self.zs, range(self.N))\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n        if self.use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i] * (Cpig_integrals_pure[i] - Hvaps[i])\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dPsats_dT_over_Psats[i] + dphis_sat_dT[i] / phis_sat[i]) + Cpig_integrals_pure[i])\n            else:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * dPsats_dT_over_Psats[i] + Cpig_integrals_pure[i])\n        if not self.composition_independent:\n            H += self.GibbsExcessModel.HE()\n        self._H = H\n        return H\n\n    def S_old(self):\n        \"\"\"\n        from scipy.integrate import *\n        from CoolProp.CoolProp import PropsSI\n\n        fluid = 'decane'\n        T = 400\n        Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n        P2 = Psat*100\n        dP = P2 - Psat\n        Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n        Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n        dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n        dS = PropsSI('SMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('SMOLAR', 'T', T, 'Q', 0, fluid)\n        def to_int2(P):\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n            alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n            return -alpha*Vm\n        quad(to_int2, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dS\n        \"\"\"\n        S = 0.0\n        T, P, zs, cmps = (self.T, self.P, self.zs, range(self.N))\n        log_zs = self.log_zs()\n        for i in cmps:\n            S -= zs[i] * log_zs[i]\n        S *= R\n        S_base = S\n        T_inv = 1.0 / T\n        RT = R * T\n        P_REF_IG_INV = self.P_REF_IG_INV\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._Vms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        if self.P_DEPENDENT_H_LIQ:\n            if self.use_IG_Cp:\n                failed_dPsat_dT = False\n                try:\n                    for i in range(self.N):\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dVsat = R * T / Psats[i] - Vms_sat[i]\n                        dSvap = dPsats_dT[i] * dVsat\n                        dSi -= dSvap\n                        dSi -= R * log(Psats[i] * P_REF_IG_INV)\n                        dP = P - Psats[i]\n                        dSi -= dP * dVms_sat_dT[i]\n                        S += dSi * zs[i]\n                except (ZeroDivisionError, ValueError):\n                    failed_dPsat_dT = True\n                if failed_dPsat_dT or isinf(S):\n                    S = S_base\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    lnPsats = self.lnPsats()\n                    LOG_P_REF_IG = self.LOG_P_REF_IG\n                    for i in cmps:\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dSvap = RT * dPsats_dT_over_Psats[i]\n                        dSi -= dSvap\n                        dSi -= R * (lnPsats[i] - LOG_P_REF_IG)\n                        dSi -= P * dVms_sat_dT[i]\n                        S += dSi * zs[i]\n                if self.use_Tait:\n                    pass\n                elif self.use_Poynting:\n                    pass\n            else:\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n                T_REF_IG_INV = self.T_REF_IG_INV\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                for i in range(self.N):\n                    dSi = Cpl_integrals_over_T_pure[i]\n                    dSi -= Hvaps_T_ref[i] * T_REF_IG_INV\n                    dSi -= R * log(Psats_T_ref[i] * P_REF_IG_INV)\n                    dP = P - Psats_T_ref[i]\n                    dSi -= dP * dVms_sat_dT_T_ref[i]\n                    S += dSi * zs[i]\n        else:\n            Hvaps = self.Hvaps()\n            for i in cmps:\n                Sg298_to_T = Cpig_integrals_over_T_pure[i]\n                Svap = -Hvaps[i] * T_inv\n                S += zs[i] * (Sg298_to_T + Svap - R * log(P * P_REF_IG_INV))\n        S = S + self.GibbsExcessModel.SE()\n        return S\n\n    def S(self):\n        \"\"\"Method to calculate the entropy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\n            + \\\\frac{H_{vap,i}}{T}\n            - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        Returns\n        -------\n        S : float\n            Entropy of the phase, [J/(mol*K)]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._S\n        except AttributeError:\n            pass\n        T, P = (self.T, self.P)\n        P_inv = 1.0 / P\n        zs, cmps = (self.zs, range(self.N))\n        log_zs = self.log_zs()\n        S_comp = 0.0\n        for i in cmps:\n            S_comp -= zs[i] * log_zs[i]\n        S = S_comp - log(P * self.P_REF_IG_INV)\n        S *= R\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            lnPsats = self._lnPsats\n        except AttributeError:\n            lnPsats = self.lnPsats()\n        use_Poynting, use_phis_sat, use_Hvap_caloric = (self.use_Poynting, self.use_phis_sat, self.use_Hvap_caloric)\n        if use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            T_inv = 1.0 / T\n            logP_inv = log(P_inv)\n            for i in cmps:\n                S -= zs[i] * (R * (lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i] + Hvaps[i] * T_inv)\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i]) + lnPsats[i] + log(phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            else:\n                logP_inv = log(P_inv)\n                for i in cmps:\n                    S -= zs[i] * (R * (T * dPsats_dT_over_Psats[i] + lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i])\n        if not self.composition_independent:\n            S += self.GibbsExcessModel.SE()\n        self._S = S\n        return S\n\n    def Cp_old(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, P, P_DEPENDENT_H_LIQ = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\n        Cp, zs = (0.0, self.zs)\n        Cpigs_pure = self.Cpigs_pure()\n        if P_DEPENDENT_H_LIQ:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            try:\n                dPsats_dT = self._dPsats_dT\n            except AttributeError:\n                dPsats_dT = self.dPsats_dT()\n            try:\n                d2Psats_dT2 = self._d2Psats_dT2\n            except AttributeError:\n                d2Psats_dT2 = self.d2Psats_dT2()\n            try:\n                Vms_sat = self._Vms_sat\n            except AttributeError:\n                Vms_sat = self.Vms_sat()\n            try:\n                dVms_sat_dT = self._Vms_sat_dT\n            except AttributeError:\n                dVms_sat_dT = self.dVms_sat_dT()\n            try:\n                d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n            except AttributeError:\n                d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            failed_dPsat_dT = False\n            try:\n                for i in range(self.N):\n                    x0 = Psats[i]\n                    Psat_inv = 1.0 / x0\n                    x1 = Vms_sat[i]\n                    x2 = dPsats_dT[i]\n                    x3 = R * Psat_inv\n                    x4 = T * x3\n                    x5 = -x1\n                    x6 = dVms_sat_dT[i]\n                    x7 = T * x2\n                    Cp += zs[i] * (-T * (P - x0) * d2Vms_sat_dT2[i] - T * (x4 + x5) * d2Psats_dT2[i] + x2 * (x1 - x4) + x2 * (T * x6 + x5) - x7 * (-R * x7 * Psat_inv * Psat_inv + x3 - x6) + Cpigs_pure[i])\n                \"\\n                from sympy import *\\n                T, P, R, zi = symbols('T, P, R, zi')\\n                Psat, Cpig_int, Vmsat = symbols('Psat, Cpig_int, Vmsat', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(Psat(T), T)\\n                dV_vap = R*T/Psat(T) - Vmsat(T)\\n                dS_vap = dPsatdT*dV_vap\\n                Hvap = T*dS_vap\\n                H = zi*(Cpig_int(T) - Hvap)\\n\\n                dP = P - Psat(T)\\n                H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n\\n                (cse(diff(H, T), optimizations='basic'))\\n                \"\n            except (ZeroDivisionError, ValueError):\n                failed_dPsat_dT = True\n            if failed_dPsat_dT or isinf(Cp) or isnan(Cp):\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                Cp = 0.0\n                for i in range(self.N):\n                    Cp += zs[i] * (Cpigs_pure[i] - P * T * d2Vms_sat_dT2[i] - R * T * T * d2lnPsats_dT2[i] - 2.0 * R * T * dlnPsats_dT[i])\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi = symbols('T, P, R, zi')\\n                    lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(exp(lnPsat(T)), T)\\n                    dV_vap = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                    dS_vap = dPsatdT*dV_vap\\n                    Hvap = T*dS_vap\\n                    H = zi*(Cpig_int(T) - Hvap)\\n                    dP = P\\n                    H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n                    print(simplify(expand(diff(H, T)).subs(exp(lnPsat(T)), 0)/zi))\\n                    \"\n        else:\n            dHvaps_dT = self.dHvaps_dT()\n            for i in range(self.N):\n                Cp += zs[i] * (Cpigs_pure[i] - dHvaps_dT[i])\n        Cp += self.GibbsExcessModel.CpE()\n        return Cp\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, zs, cmps = (self.T, self.zs, range(self.N))\n        Cpigs_pure = self.Cpigs_pure()\n        use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        RT = R * T\n        RT2 = RT * T\n        RT2_2 = RT + RT\n        Cp = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                phi_inv = 1.0 / phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0 / phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        else:\n            for i in cmps:\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dPsats_dT_over_Psats[i]\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        if not self.composition_independent:\n            Cp += self.GibbsExcessModel.CpE()\n        self._Cp = Cp\n        return Cp\n    dH_dT = Cp\n\n    def dS_dT_old(self):\n        T, P, P_DEPENDENT_H_LIQ = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\n        RT = R * T\n        zs = self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        dS_dT = 0.0\n        T_inv = 1.0 / T\n        if P_DEPENDENT_H_LIQ:\n            d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            dVms_sat_dT = self.dVms_sat_dT()\n            Vms_sat = self.Vms_sat()\n            Psats = self.Psats()\n            dPsats_dT = self.dPsats_dT()\n            d2Psats_dT2 = self.d2Psats_dT2()\n            failed_dPsat_dT = False\n            for Psat in Psats:\n                if Psat < 1e-40:\n                    failed_dPsat_dT = True\n            if not failed_dPsat_dT:\n                try:\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                    Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(Psat(T), T)\\n\\n                    S = 0\\n                    dSi = Cpig_T_int(T)\\n                    dVsat = R*T/Psat(T) - Vmsat(T)\\n                    dSvap = dPsatdT*dVsat\\n                    dSi -= dSvap\\n                    dSi -= R*log(Psat(T)/P_REF_IG)\\n                    dP = P - Psat(T)\\n                    dSi -= dP*dVmsatdT\\n                    S += dSi*zi\\n                    # cse(diff(S, T), optimizations='basic')\\n                    \"\n                    for i in range(self.N):\n                        x0 = Psats[i]\n                        x1 = dPsats_dT[i]\n                        x2 = R / x0\n                        x3 = Vms_sat[i]\n                        x4 = dVms_sat_dT[i]\n                        dS_dT -= zs[i] * (x1 * x2 - x1 * x4 - x1 * (RT * x1 / x0 ** 2 - x2 + x4) + (P - x0) * d2Vms_sat_dT2[i] + (T * x2 - x3) * d2Psats_dT2[i] - Cpigs_pure[i] * T_inv)\n                except (ZeroDivisionError, ValueError):\n                    failed_dPsat_dT = True\n            if failed_dPsat_dT:\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                \"\\n                from sympy import *\\n                T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                # Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(exp(lnPsat(T)), T)\\n\\n                S = 0\\n                dSi = Cpig_T_int(T)\\n                dVsat = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                dSvap = dPsatdT*dVsat\\n                dSi -= dSvap\\n                # dSi -= R*log(Psat(T)/P_REF_IG)\\n                dSi -= R*(lnPsat(T) - log(P_REF_IG))\\n                dP = P - exp(lnPsat(T))\\n                dSi -= dP*dVmsatdT\\n                S += dSi*zi\\n                # cse(diff(S, T), optimizations='basic')\\n                print(simplify(expand(diff(S, T)).subs(exp(lnPsat(T)), 0)/zi))\\n\\n\\n                \"\n                dS_dT = 0.0\n                for i in range(self.N):\n                    dS_dT -= zs[i] * (P * d2Vms_sat_dT2[i] + RT * d2lnPsats_dT2[i] + 2.0 * R * dlnPsats_dT[i] - Cpigs_pure[i] * T_inv)\n        dS_dT += self.GibbsExcessModel.dSE_dT()\n        return dS_dT\n\n    def dS_dT(self):\n        try:\n            return self._dS_dT\n        except AttributeError:\n            pass\n        T, zs, cmps = (self.T, self.zs, range(self.N))\n        use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        Cpigs_pure = self.Cpigs_pure()\n        T_inv = 1.0 / T\n        RT = R * T\n        R_2 = R + R\n        dS_dT = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                phi_inv = 1.0 / phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0 / phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        else:\n            for i in cmps:\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        if not self.composition_independent:\n            dS_dT += self.GibbsExcessModel.dSE_dT()\n        self._dS_dT = dS_dT\n        return dS_dT\n\n    def dH_dP(self):\n        try:\n            return self._dH_dP\n        except AttributeError:\n            pass\n        T = self.T\n        zs = self.zs\n        dH_dP = 0.0\n        if self.use_Poynting:\n            nRT2 = -R * T * T\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0 / Poyntings[i]\n                dH_dP += nRT2 * zs[i] * Poy_inv * (d2Poyntings_dPdT[i] - dPoyntings_dP[i] * dPoyntings_dT[i] * Poy_inv)\n        self._dH_dP = dH_dP\n        return dH_dP\n\n    def dS_dP(self):\n        try:\n            return self._dS_dP\n        except AttributeError:\n            pass\n        T = self.T\n        P = self.P\n        P_inv = 1.0 / P\n        zs = self.zs\n        if self.use_Poynting:\n            dS_dP = -R * P_inv\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0 / Poyntings[i]\n                dS_dP -= zs[i] * R * Poy_inv * (dPoyntings_dP[i] - Poyntings[i] * P_inv + T * (d2Poyntings_dPdT[i] - dPoyntings_dP[i] * dPoyntings_dT[i] * Poy_inv))\n        else:\n            dS_dP = 0.0\n        self._dS_dP = dS_dP\n        return dS_dP\n\n    def H_dep(self):\n        return self.H() - self.H_ideal_gas()\n\n    def S_dep(self):\n        return self.S() - self.S_ideal_gas()\n\n    def Cp_dep(self):\n        return self.Cp() - self.Cp_ideal_gas()\n\n    def V(self):\n        try:\n            return self._V\n        except AttributeError:\n            pass\n        zs = self.zs\n        Vms = self.Vms()\n        'To make a fugacity-volume identity consistent, cannot use pressure\\n        correction unless the Poynting factor is calculated with quadrature/\\n        integration.\\n        '\n        V = 0.0\n        for i in range(self.N):\n            V += zs[i] * Vms[i]\n        self._V = V\n        return V\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except AttributeError:\n            pass\n        zs = self.zs\n        dVms_sat_dT = self.dVms_sat_dT()\n        dV_dT = 0.0\n        for i in range(self.N):\n            dV_dT += zs[i] * dVms_sat_dT[i]\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def d2V_dT2(self):\n        try:\n            return self._d2V_dT2\n        except AttributeError:\n            pass\n        zs = self.zs\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        d2V_dT2 = 0.0\n        for i in range(self.N):\n            d2V_dT2 += zs[i] * d2Vms_sat_dT2[i]\n        self._d2V_dT2 = d2V_dT2\n        return d2V_dT2\n\n    def dP_dV(self):\n        try:\n            return self._dP_dV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._dP_dV = self.INCOMPRESSIBLE_CONST\n        return self._dP_dV\n\n    def d2P_dV2(self):\n        try:\n            return self._d2P_dV2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dV2 = self.INCOMPRESSIBLE_CONST\n        return self._d2P_dV2\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except AttributeError:\n            pass\n        self._dP_dT = self.dV_dT() / -self.dP_dV()\n        return self._dP_dT\n\n    def d2P_dTdV(self):\n        try:\n            return self._d2P_dTdV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dTdV = 0.0\n        else:\n            P = self.P\n\n            def dP_dV_for_diff(T):\n                return 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, self.zs, order=1)\n            self._d2P_dTdV = derivative(dP_dV_for_diff, self.T)\n        return self._d2P_dTdV\n\n    def d2P_dT2(self):\n        try:\n            return self._d2P_dT2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dT2 = -self.d2V_dT2() / self.INCOMPRESSIBLE_CONST\n        else:\n            P, zs = (self.P, self.zs)\n\n            def dP_dT_for_diff(T):\n                dV_dT = self.VolumeLiquidMixture.property_derivative_T(T, P, zs, order=1)\n                dP_dV = 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, zs, order=1)\n                dP_dT = dV_dT / -dP_dV\n                return dP_dT\n            self._d2P_dT2 = derivative(dP_dT_for_diff, self.T)\n        return self._d2P_dT2\n\n    def d2V_dP2(self):\n        try:\n            return self._d2V_dP2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2V_dP2 = 0.0\n        return self._d2V_dP2\n\n    def Tait_Bs(self):\n        try:\n            return self._Tait_Bs\n        except:\n            pass\n        self._Tait_Bs = evaluate_linear_fits(self._Tait_B_data, self.T)\n        return self._Tait_Bs\n\n    def dTait_B_dTs(self):\n        try:\n            return self._dTait_B_dTs\n        except:\n            pass\n        self._dTait_B_dTs = evaluate_linear_fits_d(self._Tait_B_data, self.T)\n        return self._dTait_B_dTs\n\n    def d2Tait_B_dT2s(self):\n        try:\n            return self._d2Tait_B_dT2s\n        except:\n            pass\n        self._d2Tait_B_dT2s = evaluate_linear_fits_d2(self._Tait_B_data, self.T)\n        return self._d2Tait_B_dT2s\n\n    def Tait_Cs(self):\n        try:\n            return self._Tait_Cs\n        except:\n            pass\n        self._Tait_Cs = evaluate_linear_fits(self._Tait_C_data, self.T)\n        return self._Tait_Cs\n\n    def dTait_C_dTs(self):\n        try:\n            return self._dTait_C_dTs\n        except:\n            pass\n        self._dTait_C_dTs = evaluate_linear_fits_d(self._Tait_C_data, self.T)\n        return self._dTait_C_dTs\n\n    def d2Tait_C_dT2s(self):\n        try:\n            return self._d2Tait_C_dT2s\n        except:\n            pass\n        self._d2Tait_C_dT2s = evaluate_linear_fits_d2(self._Tait_C_data, self.T)\n        return self._d2Tait_C_dT2s\n\n    def Tait_Vs(self):\n        Vms_sat = self.Vms_sat()\n        Psats = self.Psats()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        P = self.P\n        return [Vms_sat[i] * (1.0 - Tait_Cs[i] * log((Tait_Bs[i] + P) / (Tait_Bs[i] + Psats[i]))) for i in range(self.N)]\n\n    def dH_dP_integrals_Tait(self):\n        try:\n            return self._dH_dP_integrals_Tait\n        except AttributeError:\n            pass\n        Psats = self.Psats()\n        Vms_sat = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        dPsats_dT = self.dPsats_dT()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        dTait_C_dTs = self.dTait_C_dTs()\n        dTait_B_dTs = self.dTait_B_dTs()\n        T, P = (self.T, self.P)\n        self._dH_dP_integrals_Tait = dH_dP_integrals_Tait = []\n        for i in range(self.N):\n            x0 = Tait_Bs[i]\n            x1 = P + x0\n            x2 = Psats[i]\n            x3 = x0 + x2\n            x4 = 1.0 / x3\n            x5 = Tait_Cs[i]\n            x6 = Vms_sat[i]\n            x7 = x5 * x6\n            x8 = T * dVms_sat_dT[i]\n            x9 = x5 * x8\n            x10 = T * dTait_C_dTs[i]\n            x11 = x0 * x6\n            x12 = T * x7\n            x13 = -x0 * x7 + x0 * x9 + x10 * x11 + x12 * dTait_B_dTs[i]\n            x14 = x2 * x6\n            x15 = x4 * (x0 * x8 + x10 * x14 - x11 + x12 * dPsats_dT[i] + x13 - x14 - x2 * x7 + x2 * x8 + x2 * x9)\n            val = -P * x15 + P * (x10 * x6 - x7 + x9) * log(x1 * x4) + x13 * log(x1) - x13 * log(x3) + x15 * x2\n            dH_dP_integrals_Tait.append(val)\n        return dH_dP_integrals_Tait\n\n    def mu(self):\n        try:\n            return self._mu\n        except AttributeError:\n            pass\n        mu = self._mu = self.correlations.ViscosityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return mu\n\n    def k(self):\n        try:\n            return self._k\n        except AttributeError:\n            pass\n        self._k = k = self.correlations.ThermalConductivityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return k\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)"
  }
}