{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_path",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/utils/test_path.py",
  "test_code": "import tempfile\nfrom pathlib import Path\nfrom unittest.mock import patch\n\nfrom mypy_boto3_builder.utils.path import print_path, walk_path\n\n\nclass TestPath:\n    def test_print_path(self) -> None:\n        with patch.object(Path, \"cwd\") as cwd_mock:\n            cwd_mock.return_value = Path(\"/absolute/\")\n            assert print_path(Path(\"./relative\")) == \"./relative\"\n            assert print_path(Path(\"/absolute/path/test\")) == \"path/test\"\n            assert print_path(Path(\"/absolute/path\")) == \"./path\"\n            assert print_path(Path(\"/absolute\")) == \"/absolute\"\n            assert print_path(Path(\"/\")) == \"/\"\n            assert print_path(Path(\".\")) == \".\"  # noqa: PTH201\n\n    def test_walk_path(self) -> None:\n        with tempfile.TemporaryDirectory() as output_dir:\n            output_path = Path(output_dir)\n            (output_path / \"one.txt\").touch()\n            (output_path / \"two.txt\").touch()\n            result = sorted(walk_path(output_path))\n            assert result == [output_path / \"one.txt\", output_path / \"two.txt\"]\n            result = list(walk_path(output_path, [output_path / \"one.txt\"]))\n            assert result == [output_path / \"two.txt\"]\n",
  "GT_file_code": {
    "mypy_boto3_builder/utils/path.py": "\"\"\"\nPath utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Generator, Iterable\nfrom pathlib import Path\n\n\ndef print_path(path: Path) -> str:\n    \"\"\"\n    Get path as a string relative to current workdir.\n    \"\"\"\n    if path.is_absolute():\n        cwd = Path.cwd()\n        if path == cwd or path.parts <= cwd.parts:\n            return path.as_posix()\n\n        try:\n            path = path.relative_to(cwd)\n        except ValueError:\n            return str(path)\n\n    if len(path.parts) == 1:\n        return f\"./{path.as_posix()}\"\n\n    return path.as_posix()\n\n\ndef walk_path(\n    parent: Path,\n    exclude: Iterable[Path] = (),\n    glob_pattern: str = \"**/*\",\n) -> Generator[Path, None, None]:\n    \"\"\"\n    Walk files except for `exclude`.\n\n    Yields:\n        Existing Path.\n    \"\"\"\n    exclude_strs = {Path(i).as_posix() for i in exclude}\n    for path in parent.glob(glob_pattern):\n        if not path.is_file():\n            continue\n\n        if path.as_posix() in exclude_strs:\n            continue\n\n        yield path\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/utils/path.py": {
      "print_path": {
        "code": "def print_path(path: Path) -> str:\n    \"\"\"Get the string representation of a given filesystem path relative to the current working directory (cwd). \n\nParameters:\n- path (Path): A Path object representing the path to convert.\n\nReturns:\n- str: The string representation of the path, formatted relative to the cwd if it is an absolute path. If the path is the same as the cwd or is within the cwd, it returns the path as is. If the path has one part, it prefixes it with './'.\n\nDependencies: \n- Utilizes the `Path` class from the `pathlib` module to manage filesystem paths.\n- `Path.cwd()` is used to obtain the current working directory for comparison purposes.\n- The method `relative_to()` is employed to calculate the relative path based on the cwd.\"\"\"\n    '\\n    Get path as a string relative to current workdir.\\n    '\n    if path.is_absolute():\n        cwd = Path.cwd()\n        if path == cwd or path.parts <= cwd.parts:\n            return path.as_posix()\n        try:\n            path = path.relative_to(cwd)\n        except ValueError:\n            return str(path)\n    if len(path.parts) == 1:\n        return f'./{path.as_posix()}'\n    return path.as_posix()",
        "docstring": "Get the string representation of a given filesystem path relative to the current working directory (cwd). \n\nParameters:\n- path (Path): A Path object representing the path to convert.\n\nReturns:\n- str: The string representation of the path, formatted relative to the cwd if it is an absolute path. If the path is the same as the cwd or is within the cwd, it returns the path as is. If the path has one part, it prefixes it with './'.\n\nDependencies: \n- Utilizes the `Path` class from the `pathlib` module to manage filesystem paths.\n- `Path.cwd()` is used to obtain the current working directory for comparison purposes.\n- The method `relative_to()` is employed to calculate the relative path based on the cwd.",
        "signature": "def print_path(path: Path) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "walk_path": {
        "code": "def walk_path(parent: Path, exclude: Iterable[Path]=(), glob_pattern: str='**/*') -> Generator[Path, None, None]:\n    \"\"\"Walks through files under the specified parent directory, yielding paths of files that do not match any in the exclude list.\n\nParameters:\n- parent (Path): The directory path to start the walk from.\n- exclude (Iterable[Path], optional): A collection of Path objects to be excluded from the results.\n- glob_pattern (str, optional): A glob pattern to match the files, defaults to \"**/*\".\n\nYields:\n- Generator[Path, None, None]: Yields existing file paths that are not in the exclude list.\n\nThe function creates a set of excluded paths by converting each Path in the `exclude` argument to its POSIX string representation. It walks through the directory structure using the provided glob pattern, yielding only files that are not in the exclusion set. Paths are checked for existence using the `is_file` method.\"\"\"\n    '\\n    Walk files except for `exclude`.\\n\\n    Yields:\\n        Existing Path.\\n    '\n    exclude_strs = {Path(i).as_posix() for i in exclude}\n    for path in parent.glob(glob_pattern):\n        if not path.is_file():\n            continue\n        if path.as_posix() in exclude_strs:\n            continue\n        yield path",
        "docstring": "Walks through files under the specified parent directory, yielding paths of files that do not match any in the exclude list.\n\nParameters:\n- parent (Path): The directory path to start the walk from.\n- exclude (Iterable[Path], optional): A collection of Path objects to be excluded from the results.\n- glob_pattern (str, optional): A glob pattern to match the files, defaults to \"**/*\".\n\nYields:\n- Generator[Path, None, None]: Yields existing file paths that are not in the exclude list.\n\nThe function creates a set of excluded paths by converting each Path in the `exclude` argument to its POSIX string representation. It walks through the directory structure using the provided glob pattern, yielding only files that are not in the exclusion set. Paths are checked for existence using the `is_file` method.",
        "signature": "def walk_path(parent: Path, exclude: Iterable[Path]=(), glob_pattern: str='**/*') -> Generator[Path, None, None]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_path\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 path.py\n            \u251c\u2500\u2500 print_path\n            \u2514\u2500\u2500 walk_path\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to facilitate filesystem path manipulation and traversal operations, providing utility functions to streamline handling of relative and absolute paths. Its core functionalities include converting paths into user-friendly, context-aware representations and recursively enumerating files in a directory with optional filtering capabilities. By abstracting common path-related tasks, the module enhances code readability and reduces error-prone manual handling of filesystem operations. This ensures that developers can efficiently interact with directory structures and file paths, particularly in environments where clear and consistent path representation is critical.\n\n## FILE 1: mypy_boto3_builder/utils/path.py\n\n- FUNCTION NAME: walk_path\n  - SIGNATURE: def walk_path(parent: Path, exclude: Iterable[Path]=(), glob_pattern: str='**/*') -> Generator[Path, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nWalks through files under the specified parent directory, yielding paths of files that do not match any in the exclude list.\n\nParameters:\n- parent (Path): The directory path to start the walk from.\n- exclude (Iterable[Path], optional): A collection of Path objects to be excluded from the results.\n- glob_pattern (str, optional): A glob pattern to match the files, defaults to \"**/*\".\n\nYields:\n- Generator[Path, None, None]: Yields existing file paths that are not in the exclude list.\n\nThe function creates a set of excluded paths by converting each Path in the `exclude` argument to its POSIX string representation. It walks through the directory structure using the provided glob pattern, yielding only files that are not in the exclusion set. Paths are checked for existence using the `is_file` method.\n\"\"\"\n```\n\n- FUNCTION NAME: print_path\n  - SIGNATURE: def print_path(path: Path) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the string representation of a given filesystem path relative to the current working directory (cwd). \n\nParameters:\n- path (Path): A Path object representing the path to convert.\n\nReturns:\n- str: The string representation of the path, formatted relative to the cwd if it is an absolute path. If the path is the same as the cwd or is within the cwd, it returns the path as is. If the path has one part, it prefixes it with './'.\n\nDependencies: \n- Utilizes the `Path` class from the `pathlib` module to manage filesystem paths.\n- `Path.cwd()` is used to obtain the current working directory for comparison purposes.\n- The method `relative_to()` is employed to calculate the relative path based on the cwd.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/utils/path.py": "\"\"\"\nPath utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Generator, Iterable\nfrom pathlib import Path"
  },
  "call_tree": {
    "tests/utils/test_path.py:TestPath:test_print_path": {
      "mypy_boto3_builder/utils/path.py:print_path": {}
    },
    "tests/utils/test_path.py:TestPath:test_walk_path": {
      "mypy_boto3_builder/utils/path.py:walk_path": {}
    }
  }
}