{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_linter",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "tests/test_linter.py",
  "test_code": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport unittest\n\nfrom yamllint import linter\nfrom yamllint.config import YamlLintConfig\n\n\nclass LinterTestCase(unittest.TestCase):\n    def fake_config(self):\n        return YamlLintConfig('extends: default')\n\n    def test_run_on_string(self):\n        linter.run('test: document', self.fake_config())\n\n    def test_run_on_bytes(self):\n        linter.run(b'test: document', self.fake_config())\n\n    def test_run_on_unicode(self):\n        linter.run('test: document', self.fake_config())\n\n    def test_run_on_stream(self):\n        linter.run(io.StringIO('hello'), self.fake_config())\n\n    def test_run_on_int(self):\n        self.assertRaises(TypeError, linter.run, 42, self.fake_config())\n\n    def test_run_on_list(self):\n        self.assertRaises(TypeError, linter.run,\n                          ['h', 'e', 'l', 'l', 'o'], self.fake_config())\n\n    def test_run_on_non_ascii_chars(self):\n        s = ('- h\u00e9t\u00e9rog\u00e9n\u00e9it\u00e9\\n'\n             '# 19.99 \u20ac\\n')\n        linter.run(s, self.fake_config())\n        linter.run(s.encode('utf-8'), self.fake_config())\n        linter.run(s.encode('iso-8859-15'), self.fake_config())\n\n        s = ('- \u304a\u65e9\u3046\u5fa1\u5ea7\u3044\u307e\u3059\u3002\\n'\n             '# \u0627\u0644\u0623\u064e\u0628\u0652\u062c\u064e\u062f\u0650\u064a\u064e\u0651\u0629 \u0627\u0644\u0639\u064e\u0631\u064e\u0628\u0650\u064a\u064e\u0651\u0629\\n')\n        linter.run(s, self.fake_config())\n        linter.run(s.encode('utf-8'), self.fake_config())\n\n    def test_linter_problem_repr_without_rule(self):\n        problem = linter.LintProblem(1, 2, 'problem')\n\n        self.assertEqual(str(problem), '1:2: problem')\n\n    def test_linter_problem_repr_with_rule(self):\n        problem = linter.LintProblem(1, 2, 'problem', 'rule-id')\n\n        self.assertEqual(str(problem), '1:2: problem (rule-id)')\n",
  "GT_file_code": {
    "yamllint/config.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport fileinput\nimport os.path\n\nimport pathspec\nimport yaml\n\nimport yamllint.rules\n\n\nclass YamlLintConfigError(Exception):\n    pass\n\n\nclass YamlLintConfig:\n    def __init__(self, content=None, file=None):\n        assert (content is None) ^ (file is None)\n\n        self.ignore = None\n\n        self.yaml_files = pathspec.PathSpec.from_lines(\n            'gitwildmatch', ['*.yaml', '*.yml', '.yamllint'])\n\n        self.locale = None\n\n        if file is not None:\n            with open(file) as f:\n                content = f.read()\n\n        self.parse(content)\n        self.validate()\n\n    def is_file_ignored(self, filepath):\n        return self.ignore and self.ignore.match_file(filepath)\n\n    def is_yaml_file(self, filepath):\n        return self.yaml_files.match_file(os.path.basename(filepath))\n\n    def enabled_rules(self, filepath):\n        return [yamllint.rules.get(id) for id, val in self.rules.items()\n                if val is not False and (\n                    filepath is None or 'ignore' not in val or\n                    not val['ignore'].match_file(filepath))]\n\n    def extend(self, base_config):\n        assert isinstance(base_config, YamlLintConfig)\n\n        for rule in self.rules:\n            if (isinstance(self.rules[rule], dict) and\n                    rule in base_config.rules and\n                    base_config.rules[rule] is not False):\n                base_config.rules[rule].update(self.rules[rule])\n            else:\n                base_config.rules[rule] = self.rules[rule]\n\n        self.rules = base_config.rules\n\n        if base_config.ignore is not None:\n            self.ignore = base_config.ignore\n\n    def parse(self, raw_content):\n        try:\n            conf = yaml.safe_load(raw_content)\n        except Exception as e:\n            raise YamlLintConfigError(f'invalid config: {e}') from e\n\n        if not isinstance(conf, dict):\n            raise YamlLintConfigError('invalid config: not a dict')\n\n        self.rules = conf.get('rules', {})\n        for rule in self.rules:\n            if self.rules[rule] == 'enable':\n                self.rules[rule] = {}\n            elif self.rules[rule] == 'disable':\n                self.rules[rule] = False\n\n        # Does this conf override another conf that we need to load?\n        if 'extends' in conf:\n            path = get_extended_config_file(conf['extends'])\n            base = YamlLintConfig(file=path)\n            try:\n                self.extend(base)\n            except Exception as e:\n                raise YamlLintConfigError(f'invalid config: {e}') from e\n\n        if 'ignore' in conf and 'ignore-from-file' in conf:\n            raise YamlLintConfigError(\n                'invalid config: ignore and ignore-from-file keys cannot be '\n                'used together')\n        elif 'ignore-from-file' in conf:\n            if isinstance(conf['ignore-from-file'], str):\n                conf['ignore-from-file'] = [conf['ignore-from-file']]\n            if not (isinstance(conf['ignore-from-file'], list) and all(\n                    isinstance(ln, str) for ln in conf['ignore-from-file'])):\n                raise YamlLintConfigError(\n                    'invalid config: ignore-from-file should contain '\n                    'filename(s), either as a list or string')\n            with fileinput.input(conf['ignore-from-file']) as f:\n                self.ignore = pathspec.PathSpec.from_lines('gitwildmatch', f)\n        elif 'ignore' in conf:\n            if isinstance(conf['ignore'], str):\n                self.ignore = pathspec.PathSpec.from_lines(\n                    'gitwildmatch', conf['ignore'].splitlines())\n            elif (isinstance(conf['ignore'], list) and\n                    all(isinstance(line, str) for line in conf['ignore'])):\n                self.ignore = pathspec.PathSpec.from_lines(\n                    'gitwildmatch', conf['ignore'])\n            else:\n                raise YamlLintConfigError(\n                    'invalid config: ignore should contain file patterns')\n\n        if 'yaml-files' in conf:\n            if not (isinstance(conf['yaml-files'], list)\n                    and all(isinstance(i, str) for i in conf['yaml-files'])):\n                raise YamlLintConfigError(\n                    'invalid config: yaml-files '\n                    'should be a list of file patterns')\n            self.yaml_files = pathspec.PathSpec.from_lines('gitwildmatch',\n                                                           conf['yaml-files'])\n\n        if 'locale' in conf:\n            if not isinstance(conf['locale'], str):\n                raise YamlLintConfigError(\n                    'invalid config: locale should be a string')\n            self.locale = conf['locale']\n\n    def validate(self):\n        for id in self.rules:\n            try:\n                rule = yamllint.rules.get(id)\n            except Exception as e:\n                raise YamlLintConfigError(f'invalid config: {e}') from e\n\n            self.rules[id] = validate_rule_conf(rule, self.rules[id])\n\n\ndef validate_rule_conf(rule, conf):\n    if conf is False:  # disable\n        return False\n\n    if isinstance(conf, dict):\n        if ('ignore-from-file' in conf and not isinstance(\n                conf['ignore-from-file'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore-from-file'], str):\n                conf['ignore-from-file'] = [conf['ignore-from-file']]\n            if not (isinstance(conf['ignore-from-file'], list)\n                    and all(isinstance(line, str)\n                            for line in conf['ignore-from-file'])):\n                raise YamlLintConfigError(\n                    'invalid config: ignore-from-file should contain '\n                    'valid filename(s), either as a list or string')\n            with fileinput.input(conf['ignore-from-file']) as f:\n                conf['ignore'] = pathspec.PathSpec.from_lines(\n                    'gitwildmatch', f)\n        elif ('ignore' in conf and not isinstance(\n                conf['ignore'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore'], str):\n                conf['ignore'] = pathspec.PathSpec.from_lines(\n                    'gitwildmatch', conf['ignore'].splitlines())\n            elif (isinstance(conf['ignore'], list) and\n                    all(isinstance(line, str) for line in conf['ignore'])):\n                conf['ignore'] = pathspec.PathSpec.from_lines(\n                    'gitwildmatch', conf['ignore'])\n            else:\n                raise YamlLintConfigError(\n                    'invalid config: ignore should contain file patterns')\n\n        if 'level' not in conf:\n            conf['level'] = 'error'\n        elif conf['level'] not in ('error', 'warning'):\n            raise YamlLintConfigError(\n                'invalid config: level should be \"error\" or \"warning\"')\n\n        options = getattr(rule, 'CONF', {})\n        options_default = getattr(rule, 'DEFAULT', {})\n        for optkey in conf:\n            if optkey in ('ignore', 'ignore-from-file', 'level'):\n                continue\n            if optkey not in options:\n                raise YamlLintConfigError(\n                    f'invalid config: unknown option \"{optkey}\" for rule '\n                    f'\"{rule.ID}\"')\n            # Example: CONF = {option: (bool, 'mixed')}\n            #          \u2192 {option: true}         \u2192 {option: mixed}\n            if isinstance(options[optkey], tuple):\n                if (conf[optkey] not in options[optkey] and\n                        type(conf[optkey]) not in options[optkey]):\n                    raise YamlLintConfigError(\n                        f'invalid config: option \"{optkey}\" of \"{rule.ID}\" '\n                        f'should be in {options[optkey]}')\n            # Example: CONF = {option: ['flag1', 'flag2', int]}\n            #          \u2192 {option: [flag1]}      \u2192 {option: [42, flag1, flag2]}\n            elif isinstance(options[optkey], list):\n                if (not isinstance(conf[optkey], list) or\n                        any(flag not in options[optkey] and\n                            type(flag) not in options[optkey]\n                            for flag in conf[optkey])):\n                    raise YamlLintConfigError(\n                        f'invalid config: option \"{optkey}\" of \"{rule.ID}\" '\n                        f'should only contain values in {options[optkey]}')\n            # Example: CONF = {option: int}\n            #          \u2192 {option: 42}\n            else:\n                if not isinstance(conf[optkey], options[optkey]):\n                    raise YamlLintConfigError(\n                        f'invalid config: option \"{optkey}\" of \"{rule.ID}\" '\n                        f'should be {options[optkey].__name__}')\n        for optkey in options:\n            if optkey not in conf:\n                conf[optkey] = options_default[optkey]\n\n        if hasattr(rule, 'VALIDATE'):\n            res = rule.VALIDATE(conf)\n            if res:\n                raise YamlLintConfigError(f'invalid config: {rule.ID}: {res}')\n    else:\n        raise YamlLintConfigError(\n            f'invalid config: rule \"{rule.ID}\": should be either \"enable\", '\n            f'\"disable\" or a dict')\n\n    return conf\n\n\ndef get_extended_config_file(name):\n    # Is it a standard conf shipped with yamllint...\n    if '/' not in name:\n        std_conf = os.path.join(os.path.dirname(os.path.realpath(__file__)),\n                                'conf', f'{name}.yaml')\n\n        if os.path.isfile(std_conf):\n            return std_conf\n\n    # or a custom conf on filesystem?\n    return name\n",
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/config.py": {
      "YamlLintConfig.__init__": {
        "code": "    def __init__(self, content=None, file=None):\n        \"\"\"Initializes a YamlLintConfig object which represents the configuration for linting YAML files.\n\nParameters:\n- content (str, optional): A string containing the configuration content.\n- file (str, optional): A path to a file containing the configuration. Only one of `content` or `file` should be provided (asserted by XOR condition).\n\nAttributes:\n- ignore (PathSpec, optional): Patterns for files to be ignored, initialized to None.\n- yaml_files (PathSpec): A PathSpec object defining the patterns for YAML files, initialized to match file extensions '.yaml', '.yml', and files named '.yamllint'.\n- locale (str, optional): A string representing the locale, initialized to None.\n\nSide Effects:\n- If a `file` is provided, its content is read and parsed.\n- Calls `parse(content)` to load and validate configuration details.\n- Calls `validate()` to ensure rules are correctly configured based on the loaded YAML content.\n\nDependencies:\n- The method relies on the `pathspec` module for pattern matching, and the `yaml` module for parsing YAML content.\n- Raises a `YamlLintConfigError` if the configuration is invalid in any way during parsing or validation.\"\"\"\n        assert (content is None) ^ (file is None)\n        self.ignore = None\n        self.yaml_files = pathspec.PathSpec.from_lines('gitwildmatch', ['*.yaml', '*.yml', '.yamllint'])\n        self.locale = None\n        if file is not None:\n            with open(file) as f:\n                content = f.read()\n        self.parse(content)\n        self.validate()",
        "docstring": "Initializes a YamlLintConfig object which represents the configuration for linting YAML files.\n\nParameters:\n- content (str, optional): A string containing the configuration content.\n- file (str, optional): A path to a file containing the configuration. Only one of `content` or `file` should be provided (asserted by XOR condition).\n\nAttributes:\n- ignore (PathSpec, optional): Patterns for files to be ignored, initialized to None.\n- yaml_files (PathSpec): A PathSpec object defining the patterns for YAML files, initialized to match file extensions '.yaml', '.yml', and files named '.yamllint'.\n- locale (str, optional): A string representing the locale, initialized to None.\n\nSide Effects:\n- If a `file` is provided, its content is read and parsed.\n- Calls `parse(content)` to load and validate configuration details.\n- Calls `validate()` to ensure rules are correctly configured based on the loaded YAML content.\n\nDependencies:\n- The method relies on the `pathspec` module for pattern matching, and the `yaml` module for parsing YAML content.\n- Raises a `YamlLintConfigError` if the configuration is invalid in any way during parsing or validation.",
        "signature": "def __init__(self, content=None, file=None):",
        "type": "Method",
        "class_signature": "class YamlLintConfig:"
      },
      "YamlLintConfig.parse": {
        "code": "    def parse(self, raw_content):\n        \"\"\"Parses the given YAML configuration content and initializes the YamlLintConfig instance with the specified rules, ignore patterns, file specifications, and locale settings. The method handles exceptions and validates the format of the configuration, ensuring that it conforms to the expected structure. It can also extend the configuration from a base file if specified.\n\n    Parameters:\n        raw_content (str): The YAML formatted string content representing the configuration for YamlLint, expected to be a dictionary structure containing keys like 'rules', 'ignore', 'ignore-from-file', 'yaml-files', and 'locale'.\n\n    Raises:\n        YamlLintConfigError: If the provided configuration content is invalid, not a dictionary, or if there are conflicting or incorrect values.\n\n    Side Effects:\n        Modifies the instance attributes `rules`, `ignore`, `yaml_files`, and `locale` based on the parsed content.\n\n    Dependencies:\n        Utilizes the `yaml.safe_load` function to parse YAML content and `pathspec.PathSpec.from_lines` to create ignore patterns based on file specifications.\"\"\"\n        try:\n            conf = yaml.safe_load(raw_content)\n        except Exception as e:\n            raise YamlLintConfigError(f'invalid config: {e}') from e\n        if not isinstance(conf, dict):\n            raise YamlLintConfigError('invalid config: not a dict')\n        self.rules = conf.get('rules', {})\n        for rule in self.rules:\n            if self.rules[rule] == 'enable':\n                self.rules[rule] = {}\n            elif self.rules[rule] == 'disable':\n                self.rules[rule] = False\n        if 'extends' in conf:\n            path = get_extended_config_file(conf['extends'])\n            base = YamlLintConfig(file=path)\n            try:\n                self.extend(base)\n            except Exception as e:\n                raise YamlLintConfigError(f'invalid config: {e}') from e\n        if 'ignore' in conf and 'ignore-from-file' in conf:\n            raise YamlLintConfigError('invalid config: ignore and ignore-from-file keys cannot be used together')\n        elif 'ignore-from-file' in conf:\n            if isinstance(conf['ignore-from-file'], str):\n                conf['ignore-from-file'] = [conf['ignore-from-file']]\n            if not (isinstance(conf['ignore-from-file'], list) and all((isinstance(ln, str) for ln in conf['ignore-from-file']))):\n                raise YamlLintConfigError('invalid config: ignore-from-file should contain filename(s), either as a list or string')\n            with fileinput.input(conf['ignore-from-file']) as f:\n                self.ignore = pathspec.PathSpec.from_lines('gitwildmatch', f)\n        elif 'ignore' in conf:\n            if isinstance(conf['ignore'], str):\n                self.ignore = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'].splitlines())\n            elif isinstance(conf['ignore'], list) and all((isinstance(line, str) for line in conf['ignore'])):\n                self.ignore = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'])\n            else:\n                raise YamlLintConfigError('invalid config: ignore should contain file patterns')\n        if 'yaml-files' in conf:\n            if not (isinstance(conf['yaml-files'], list) and all((isinstance(i, str) for i in conf['yaml-files']))):\n                raise YamlLintConfigError('invalid config: yaml-files should be a list of file patterns')\n            self.yaml_files = pathspec.PathSpec.from_lines('gitwildmatch', conf['yaml-files'])\n        if 'locale' in conf:\n            if not isinstance(conf['locale'], str):\n                raise YamlLintConfigError('invalid config: locale should be a string')\n            self.locale = conf['locale']",
        "docstring": "Parses the given YAML configuration content and initializes the YamlLintConfig instance with the specified rules, ignore patterns, file specifications, and locale settings. The method handles exceptions and validates the format of the configuration, ensuring that it conforms to the expected structure. It can also extend the configuration from a base file if specified.\n\nParameters:\n    raw_content (str): The YAML formatted string content representing the configuration for YamlLint, expected to be a dictionary structure containing keys like 'rules', 'ignore', 'ignore-from-file', 'yaml-files', and 'locale'.\n\nRaises:\n    YamlLintConfigError: If the provided configuration content is invalid, not a dictionary, or if there are conflicting or incorrect values.\n\nSide Effects:\n    Modifies the instance attributes `rules`, `ignore`, `yaml_files`, and `locale` based on the parsed content.\n\nDependencies:\n    Utilizes the `yaml.safe_load` function to parse YAML content and `pathspec.PathSpec.from_lines` to create ignore patterns based on file specifications.",
        "signature": "def parse(self, raw_content):",
        "type": "Method",
        "class_signature": "class YamlLintConfig:"
      },
      "YamlLintConfig.validate": {
        "code": "    def validate(self):\n        \"\"\"Validates the rules defined in the YamlLintConfig instance.\n\nThis method iterates over the `rules` attribute, which is expected to be a dictionary where keys are rule IDs. It attempts to retrieve each rule using `yamllint.rules.get(id)`. If the rule is not valid, it raises a `YamlLintConfigError`. Each rule's configuration is then validated by calling the `validate_rule_conf` function, which takes the rule object and its corresponding configuration as arguments and ensures they conform to the expected structure and types.\n\nNo parameters are accepted, and the method does not return a value. However, it modifies the `self.rules` attribute with validated configurations. The method interacts closely with the `yamllint.rules` module, utilizing its `get` function to fetch rule definitions and `validate_rule_conf` to enforce specific validation requirements.\n\nRaises:\n    - YamlLintConfigError: If any rule is invalid or its configuration does not meet the validation criteria.\"\"\"\n        for id in self.rules:\n            try:\n                rule = yamllint.rules.get(id)\n            except Exception as e:\n                raise YamlLintConfigError(f'invalid config: {e}') from e\n            self.rules[id] = validate_rule_conf(rule, self.rules[id])",
        "docstring": "Validates the rules defined in the YamlLintConfig instance.\n\nThis method iterates over the `rules` attribute, which is expected to be a dictionary where keys are rule IDs. It attempts to retrieve each rule using `yamllint.rules.get(id)`. If the rule is not valid, it raises a `YamlLintConfigError`. Each rule's configuration is then validated by calling the `validate_rule_conf` function, which takes the rule object and its corresponding configuration as arguments and ensures they conform to the expected structure and types.\n\nNo parameters are accepted, and the method does not return a value. However, it modifies the `self.rules` attribute with validated configurations. The method interacts closely with the `yamllint.rules` module, utilizing its `get` function to fetch rule definitions and `validate_rule_conf` to enforce specific validation requirements.\n\nRaises:\n    - YamlLintConfigError: If any rule is invalid or its configuration does not meet the validation criteria.",
        "signature": "def validate(self):",
        "type": "Method",
        "class_signature": "class YamlLintConfig:"
      }
    },
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem instance to represent a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the linting problem is detected (starting from 1).\n- column (int): The column number where the linting problem occurs (starting from 1).\n- desc (str): A human-readable description of the problem; defaults to '<no description>' if not provided.\n- rule (str or None): An optional identifier for the specific rule that detected the problem.\n\nAttributes:\n- level: Set to None initially; will hold the severity level of the linting problem, which can be 'warning' or 'error' as defined by the PROBLEM_LEVELS constant located at the start of the code. This constant maps severity levels to corresponding values and is utilized in other parts of the code to categorize the linting issues.\n\nThe LintProblem class is integral to tracking and reporting linting issues detected by the yamllint parser, aiding in YAML syntax and style conformance.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem instance to represent a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the linting problem is detected (starting from 1).\n- column (int): The column number where the linting problem occurs (starting from 1).\n- desc (str): A human-readable description of the problem; defaults to '<no description>' if not provided.\n- rule (str or None): An optional identifier for the specific rule that detected the problem.\n\nAttributes:\n- level: Set to None initially; will hold the severity level of the linting problem, which can be 'warning' or 'error' as defined by the PROBLEM_LEVELS constant located at the start of the code. This constant maps severity levels to corresponding values and is utilized in other parts of the code to categorize the linting issues.\n\nThe LintProblem class is integral to tracking and reporting linting issues detected by the yamllint parser, aiding in YAML syntax and style conformance.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.message": {
        "code": "    def message(self):\n        \"\"\"Returns a human-readable message representing the linting problem.\n\nIf a rule is associated with the problem (indicated by the `rule` attribute), the message includes both the description of the problem (`desc` attribute) and the rule identifier in parentheses. If no rule is associated, it simply returns the description. This method is essential for providing informative output for users when linting YAML files, helping them understand the nature of the issues identified in their YAML structure.\n\nAttributes:\n- `desc` (str): A description of the linting problem.\n- `rule` (str or None): An identifier for the rule that detected the problem.\n\nReturns:\n- (str): A formatted string detailing the linting problem, either including the rule ID if applicable or just the description.\"\"\"\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc",
        "docstring": "Returns a human-readable message representing the linting problem.\n\nIf a rule is associated with the problem (indicated by the `rule` attribute), the message includes both the description of the problem (`desc` attribute) and the rule identifier in parentheses. If no rule is associated, it simply returns the description. This method is essential for providing informative output for users when linting YAML files, helping them understand the nature of the issues identified in their YAML structure.\n\nAttributes:\n- `desc` (str): A description of the linting problem.\n- `rule` (str or None): An identifier for the rule that detected the problem.\n\nReturns:\n- (str): A formatted string detailing the linting problem, either including the rule ID if applicable or just the description.",
        "signature": "def message(self):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__repr__": {
        "code": "    def __repr__(self):\n        \"\"\"Returns a string representation of the LintProblem instance, formatted as 'line:column: message'.\n\nThis method constructs a concise summary of the linting problem identified, including the line and column numbers where the problem was detected and the associated message. The message property provides a human-readable description of the issue, potentially including the rule that triggered it, and is utilized here for the output formatting.\n\nNo input parameters are required for this method, and it does not produce side effects. It relies on the attributes `line`, `column`, and `message` of the LintProblem instance, which store the respective line number, column number, and description of the linting issue.\"\"\"\n        return f'{self.line}:{self.column}: {self.message}'",
        "docstring": "Returns a string representation of the LintProblem instance, formatted as 'line:column: message'.\n\nThis method constructs a concise summary of the linting problem identified, including the line and column numbers where the problem was detected and the associated message. The message property provides a human-readable description of the issue, potentially including the rule that triggered it, and is utilized here for the output formatting.\n\nNo input parameters are required for this method, and it does not produce side effects. It relies on the attributes `line`, `column`, and `message` of the LintProblem instance, which store the respective line number, column number, and description of the linting issue.",
        "signature": "def __repr__(self):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source and returns a generator of LintProblem objects, which represent any linting issues found.\n\nParameters:\n- input (str, bytes, or stream): The YAML source to lint, which can be a string, bytes, or a file-like stream.\n- conf: A yamllint configuration object that dictates which rules are enabled and how they are applied.\n- filepath (str, optional): The file path of the YAML document, used to check if the file is ignored as per the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects that report problems found during linting, or nothing if no problems are found or if the file is ignored.\n\nDependencies:\n- This function interacts with the `parser` module for tokenizing and analyzing the YAML content and utilizes `get_cosmetic_problems` and `_run` for the actual linting process. Additionally, it uses the `io` module to handle input streams. It checks if the file is ignored using the `is_file_ignored` method of the configuration object.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source and returns a generator of LintProblem objects, which represent any linting issues found.\n\nParameters:\n- input (str, bytes, or stream): The YAML source to lint, which can be a string, bytes, or a file-like stream.\n- conf: A yamllint configuration object that dictates which rules are enabled and how they are applied.\n- filepath (str, optional): The file path of the YAML document, used to check if the file is ignored as per the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects that report problems found during linting, or nothing if no problems are found or if the file is ignored.\n\nDependencies:\n- This function interacts with the `parser` module for tokenizing and analyzing the YAML content and utilizes `get_cosmetic_problems` and `_run` for the actual linting process. Additionally, it uses the `io` module to handle input streams. It checks if the file is ignored using the `is_file_ignored` method of the configuration object.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:LintProblem:__repr__": {},
    "yamllint/linter.py:LintProblem:message": {},
    "yamllint/config.py:YamlLintConfig:__init__": {},
    "yamllint/config.py:YamlLintConfig:parse": {
      "yamllint/config.py": {
        "YamlLintConfig.extend": {
          "code": "    def extend(self, base_config):\n        assert isinstance(base_config, YamlLintConfig)\n        for rule in self.rules:\n            if isinstance(self.rules[rule], dict) and rule in base_config.rules and (base_config.rules[rule] is not False):\n                base_config.rules[rule].update(self.rules[rule])\n            else:\n                base_config.rules[rule] = self.rules[rule]\n        self.rules = base_config.rules\n        if base_config.ignore is not None:\n            self.ignore = base_config.ignore",
          "docstring": "",
          "signature": "def extend(self, base_config):",
          "type": "Method",
          "class_signature": "class YamlLintConfig:"
        },
        "get_extended_config_file": {
          "code": "def get_extended_config_file(name):\n    if '/' not in name:\n        std_conf = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'conf', f'{name}.yaml')\n        if os.path.isfile(std_conf):\n            return std_conf\n    return name",
          "docstring": "",
          "signature": "def get_extended_config_file(name):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/config.py:YamlLintConfig:validate": {
      "yamllint/config.py": {
        "validate_rule_conf": {
          "code": "def validate_rule_conf(rule, conf):\n    if conf is False:\n        return False\n    if isinstance(conf, dict):\n        if 'ignore-from-file' in conf and (not isinstance(conf['ignore-from-file'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore-from-file'], str):\n                conf['ignore-from-file'] = [conf['ignore-from-file']]\n            if not (isinstance(conf['ignore-from-file'], list) and all((isinstance(line, str) for line in conf['ignore-from-file']))):\n                raise YamlLintConfigError('invalid config: ignore-from-file should contain valid filename(s), either as a list or string')\n            with fileinput.input(conf['ignore-from-file']) as f:\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', f)\n        elif 'ignore' in conf and (not isinstance(conf['ignore'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore'], str):\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'].splitlines())\n            elif isinstance(conf['ignore'], list) and all((isinstance(line, str) for line in conf['ignore'])):\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'])\n            else:\n                raise YamlLintConfigError('invalid config: ignore should contain file patterns')\n        if 'level' not in conf:\n            conf['level'] = 'error'\n        elif conf['level'] not in ('error', 'warning'):\n            raise YamlLintConfigError('invalid config: level should be \"error\" or \"warning\"')\n        options = getattr(rule, 'CONF', {})\n        options_default = getattr(rule, 'DEFAULT', {})\n        for optkey in conf:\n            if optkey in ('ignore', 'ignore-from-file', 'level'):\n                continue\n            if optkey not in options:\n                raise YamlLintConfigError(f'invalid config: unknown option \"{optkey}\" for rule \"{rule.ID}\"')\n            if isinstance(options[optkey], tuple):\n                if conf[optkey] not in options[optkey] and type(conf[optkey]) not in options[optkey]:\n                    raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should be in {options[optkey]}')\n            elif isinstance(options[optkey], list):\n                if not isinstance(conf[optkey], list) or any((flag not in options[optkey] and type(flag) not in options[optkey] for flag in conf[optkey])):\n                    raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should only contain values in {options[optkey]}')\n            elif not isinstance(conf[optkey], options[optkey]):\n                raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should be {options[optkey].__name__}')\n        for optkey in options:\n            if optkey not in conf:\n                conf[optkey] = options_default[optkey]\n        if hasattr(rule, 'VALIDATE'):\n            res = rule.VALIDATE(conf)\n            if res:\n                raise YamlLintConfigError(f'invalid config: {rule.ID}: {res}')\n    else:\n        raise YamlLintConfigError(f'invalid config: rule \"{rule.ID}\": should be either \"enable\", \"disable\" or a dict')\n    return conf",
          "docstring": "",
          "signature": "def validate_rule_conf(rule, conf):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/rules/__init__.py": {
        "get": {
          "code": "def get(id):\n    if id not in _RULES:\n        raise ValueError(f'no such rule: \"{id}\"')\n\n    return _RULES[id]",
          "docstring": "",
          "signature": "def get(id):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "tests/test_linter.py:LinterTestCase:test_linter_problem_repr_with_rule": {
      "yamllint/linter.py:LintProblem:__init__": {},
      "yamllint/linter.py:LintProblem:__repr__": {
        "yamllint/linter.py:LintProblem:message": {}
      }
    },
    "tests/test_linter.py:LinterTestCase:test_linter_problem_repr_without_rule": {
      "yamllint/linter.py:LintProblem:__init__": {},
      "yamllint/linter.py:LintProblem:__repr__": {
        "yamllint/linter.py:LintProblem:message": {}
      }
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_bytes": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {
              "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
            }
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_int": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_list": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_non_ascii_chars": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_stream": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_string": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "tests/test_linter.py:LinterTestCase:test_run_on_unicode": {
      "tests/test_linter.py:LinterTestCase:fake_config": {
        "yamllint/config.py:YamlLintConfig:__init__": {
          "yamllint/config.py:YamlLintConfig:parse": {
            "yamllint/config.py:get_extended_config_file": {},
            "yamllint/config.py:YamlLintConfig:__init__": {
              "[ignored_or_cut_off]": "..."
            },
            "yamllint/config.py:YamlLintConfig:extend": {}
          },
          "yamllint/config.py:YamlLintConfig:validate": {
            "yamllint/rules/__init__.py:get": {},
            "yamllint/config.py:validate_rule_conf": {}
          }
        }
      },
      "yamllint/linter.py:run": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_linter/yamllint-test_linter/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_linter/yamllint-test_linter/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_linter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 config.py\n    \u2502   \u251c\u2500\u2500 YamlLintConfig.__init__\n    \u2502   \u251c\u2500\u2500 YamlLintConfig.parse\n    \u2502   \u2514\u2500\u2500 YamlLintConfig.validate\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 LintProblem.__repr__\n    \u2502   \u251c\u2500\u2500 LintProblem.message\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module serves as a testing suite for validating the functionality and robustness of the YAMLLint linter, a tool designed for analyzing and ensuring the correctness of YAML documents. It provides comprehensive coverage for the linter's core capabilities, including the ability to process inputs in various formats, such as strings, bytes, Unicode, and streams, while effectively identifying improper input types and handling diverse character encodings, including non-ASCII characters. The module ensures reliable detection and reporting of potential YAML syntax or structural issues, enabling developers to confidently use the linter in a variety of scenarios. By automating these validation tasks, it ensures the linter performs as expected, streamlining the debugging process and minimizing the risk of errors in YAML configurations.\n\n## FILE 1: yamllint/config.py\n\n- CLASS METHOD: YamlLintConfig.validate\n  - CLASS SIGNATURE: class YamlLintConfig:\n  - SIGNATURE: def validate(self):\n  - DOCSTRING: \n```python\n\"\"\"\nValidates the rules defined in the YamlLintConfig instance.\n\nThis method iterates over the `rules` attribute, which is expected to be a dictionary where keys are rule IDs. It attempts to retrieve each rule using `yamllint.rules.get(id)`. If the rule is not valid, it raises a `YamlLintConfigError`. Each rule's configuration is then validated by calling the `validate_rule_conf` function, which takes the rule object and its corresponding configuration as arguments and ensures they conform to the expected structure and types.\n\nNo parameters are accepted, and the method does not return a value. However, it modifies the `self.rules` attribute with validated configurations. The method interacts closely with the `yamllint.rules` module, utilizing its `get` function to fetch rule definitions and `validate_rule_conf` to enforce specific validation requirements.\n\nRaises:\n    - YamlLintConfigError: If any rule is invalid or its configuration does not meet the validation criteria.\n\"\"\"\n```\n\n- CLASS METHOD: YamlLintConfig.parse\n  - CLASS SIGNATURE: class YamlLintConfig:\n  - SIGNATURE: def parse(self, raw_content):\n  - DOCSTRING: \n```python\n\"\"\"\nParses the given YAML configuration content and initializes the YamlLintConfig instance with the specified rules, ignore patterns, file specifications, and locale settings. The method handles exceptions and validates the format of the configuration, ensuring that it conforms to the expected structure. It can also extend the configuration from a base file if specified.\n\nParameters:\n    raw_content (str): The YAML formatted string content representing the configuration for YamlLint, expected to be a dictionary structure containing keys like 'rules', 'ignore', 'ignore-from-file', 'yaml-files', and 'locale'.\n\nRaises:\n    YamlLintConfigError: If the provided configuration content is invalid, not a dictionary, or if there are conflicting or incorrect values.\n\nSide Effects:\n    Modifies the instance attributes `rules`, `ignore`, `yaml_files`, and `locale` based on the parsed content.\n\nDependencies:\n    Utilizes the `yaml.safe_load` function to parse YAML content and `pathspec.PathSpec.from_lines` to create ignore patterns based on file specifications.\n\"\"\"\n```\n\n- CLASS METHOD: YamlLintConfig.__init__\n  - CLASS SIGNATURE: class YamlLintConfig:\n  - SIGNATURE: def __init__(self, content=None, file=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a YamlLintConfig object which represents the configuration for linting YAML files.\n\nParameters:\n- content (str, optional): A string containing the configuration content.\n- file (str, optional): A path to a file containing the configuration. Only one of `content` or `file` should be provided (asserted by XOR condition).\n\nAttributes:\n- ignore (PathSpec, optional): Patterns for files to be ignored, initialized to None.\n- yaml_files (PathSpec): A PathSpec object defining the patterns for YAML files, initialized to match file extensions '.yaml', '.yml', and files named '.yamllint'.\n- locale (str, optional): A string representing the locale, initialized to None.\n\nSide Effects:\n- If a `file` is provided, its content is read and parsed.\n- Calls `parse(content)` to load and validate configuration details.\n- Calls `validate()` to ensure rules are correctly configured based on the loaded YAML content.\n\nDependencies:\n- The method relies on the `pathspec` module for pattern matching, and the `yaml` module for parsing YAML content.\n- Raises a `YamlLintConfigError` if the configuration is invalid in any way during parsing or validation.\n\"\"\"\n```\n\n## FILE 2: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source and returns a generator of LintProblem objects, which represent any linting issues found.\n\nParameters:\n- input (str, bytes, or stream): The YAML source to lint, which can be a string, bytes, or a file-like stream.\n- conf: A yamllint configuration object that dictates which rules are enabled and how they are applied.\n- filepath (str, optional): The file path of the YAML document, used to check if the file is ignored as per the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects that report problems found during linting, or nothing if no problems are found or if the file is ignored.\n\nDependencies:\n- This function interacts with the `parser` module for tokenizing and analyzing the YAML content and utilizes `get_cosmetic_problems` and `_run` for the actual linting process. Additionally, it uses the `io` module to handle input streams. It checks if the file is ignored using the `is_file_ignored` method of the configuration object.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem instance to represent a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the linting problem is detected (starting from 1).\n- column (int): The column number where the linting problem occurs (starting from 1).\n- desc (str): A human-readable description of the problem; defaults to '<no description>' if not provided.\n- rule (str or None): An optional identifier for the specific rule that detected the problem.\n\nAttributes:\n- level: Set to None initially; will hold the severity level of the linting problem, which can be 'warning' or 'error' as defined by the PROBLEM_LEVELS constant located at the start of the code. This constant maps severity levels to corresponding values and is utilized in other parts of the code to categorize the linting issues.\n\nThe LintProblem class is integral to tracking and reporting linting issues detected by the yamllint parser, aiding in YAML syntax and style conformance.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.message\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def message(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a human-readable message representing the linting problem.\n\nIf a rule is associated with the problem (indicated by the `rule` attribute), the message includes both the description of the problem (`desc` attribute) and the rule identifier in parentheses. If no rule is associated, it simply returns the description. This method is essential for providing informative output for users when linting YAML files, helping them understand the nature of the issues identified in their YAML structure.\n\nAttributes:\n- `desc` (str): A description of the linting problem.\n- `rule` (str or None): An identifier for the rule that detected the problem.\n\nReturns:\n- (str): A formatted string detailing the linting problem, either including the rule ID if applicable or just the description.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__repr__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __repr__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the LintProblem instance, formatted as 'line:column: message'.\n\nThis method constructs a concise summary of the linting problem identified, including the line and column numbers where the problem was detected and the associated message. The message property provides a human-readable description of the issue, potentially including the rule that triggered it, and is utilized here for the output formatting.\n\nNo input parameters are required for this method, and it does not produce side effects. It relies on the attributes `line`, `column`, and `message` of the LintProblem instance, which store the respective line number, column number, and description of the linting issue.\n\"\"\"\n```\n\n## FILE 3: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/config.py": "import fileinput\nimport os.path\nimport pathspec\nimport yaml\nimport yamllint.rules\n\nclass YamlLintConfigError(Exception):\n    pass\n\nclass YamlLintConfig:\n\n    def is_file_ignored(self, filepath):\n        return self.ignore and self.ignore.match_file(filepath)\n\n    def is_yaml_file(self, filepath):\n        return self.yaml_files.match_file(os.path.basename(filepath))\n\n    def enabled_rules(self, filepath):\n        return [yamllint.rules.get(id) for id, val in self.rules.items() if val is not False and (filepath is None or 'ignore' not in val or (not val['ignore'].match_file(filepath)))]\n\n    def extend(self, base_config):\n        assert isinstance(base_config, YamlLintConfig)\n        for rule in self.rules:\n            if isinstance(self.rules[rule], dict) and rule in base_config.rules and (base_config.rules[rule] is not False):\n                base_config.rules[rule].update(self.rules[rule])\n            else:\n                base_config.rules[rule] = self.rules[rule]\n        self.rules = base_config.rules\n        if base_config.ignore is not None:\n            self.ignore = base_config.ignore\n\ndef validate_rule_conf(rule, conf):\n    if conf is False:\n        return False\n    if isinstance(conf, dict):\n        if 'ignore-from-file' in conf and (not isinstance(conf['ignore-from-file'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore-from-file'], str):\n                conf['ignore-from-file'] = [conf['ignore-from-file']]\n            if not (isinstance(conf['ignore-from-file'], list) and all((isinstance(line, str) for line in conf['ignore-from-file']))):\n                raise YamlLintConfigError('invalid config: ignore-from-file should contain valid filename(s), either as a list or string')\n            with fileinput.input(conf['ignore-from-file']) as f:\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', f)\n        elif 'ignore' in conf and (not isinstance(conf['ignore'], pathspec.pathspec.PathSpec)):\n            if isinstance(conf['ignore'], str):\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'].splitlines())\n            elif isinstance(conf['ignore'], list) and all((isinstance(line, str) for line in conf['ignore'])):\n                conf['ignore'] = pathspec.PathSpec.from_lines('gitwildmatch', conf['ignore'])\n            else:\n                raise YamlLintConfigError('invalid config: ignore should contain file patterns')\n        if 'level' not in conf:\n            conf['level'] = 'error'\n        elif conf['level'] not in ('error', 'warning'):\n            raise YamlLintConfigError('invalid config: level should be \"error\" or \"warning\"')\n        options = getattr(rule, 'CONF', {})\n        options_default = getattr(rule, 'DEFAULT', {})\n        for optkey in conf:\n            if optkey in ('ignore', 'ignore-from-file', 'level'):\n                continue\n            if optkey not in options:\n                raise YamlLintConfigError(f'invalid config: unknown option \"{optkey}\" for rule \"{rule.ID}\"')\n            if isinstance(options[optkey], tuple):\n                if conf[optkey] not in options[optkey] and type(conf[optkey]) not in options[optkey]:\n                    raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should be in {options[optkey]}')\n            elif isinstance(options[optkey], list):\n                if not isinstance(conf[optkey], list) or any((flag not in options[optkey] and type(flag) not in options[optkey] for flag in conf[optkey])):\n                    raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should only contain values in {options[optkey]}')\n            elif not isinstance(conf[optkey], options[optkey]):\n                raise YamlLintConfigError(f'invalid config: option \"{optkey}\" of \"{rule.ID}\" should be {options[optkey].__name__}')\n        for optkey in options:\n            if optkey not in conf:\n                conf[optkey] = options_default[optkey]\n        if hasattr(rule, 'VALIDATE'):\n            res = rule.VALIDATE(conf)\n            if res:\n                raise YamlLintConfigError(f'invalid config: {rule.ID}: {res}')\n    else:\n        raise YamlLintConfigError(f'invalid config: rule \"{rule.ID}\": should be either \"enable\", \"disable\" or a dict')\n    return conf\n\ndef get_extended_config_file(name):\n    if '/' not in name:\n        std_conf = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'conf', f'{name}.yaml')\n        if os.path.isfile(std_conf):\n            return std_conf\n    return name",
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    def __eq__(self, other):\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)\n\n    def __lt__(self, other):\n        return self.line < other.line or (self.line == other.line and self.column < other.column)\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}