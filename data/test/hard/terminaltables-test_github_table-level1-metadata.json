{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_github_table",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_all_tables_e2e/test_github_table.py",
  "test_code": "\"\"\"GithubFlavoredMarkdownTable end to end testing.\"\"\"\n\nfrom terminaltables3 import GithubFlavoredMarkdownTable\n\n\ndef test_single_line():\n    \"\"\"Test single-lined cells.\"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n        [\"Watermelon\", \"green\"],\n        [],\n    ]\n    table = GithubFlavoredMarkdownTable(table_data)\n    table.inner_footing_row_border = True\n    table.justify_columns[0] = \"left\"\n    table.justify_columns[1] = \"center\"\n    table.justify_columns[2] = \"right\"\n    actual = table.table\n\n    expected = (\n        \"| Name       | Color |      Type |\\n\"\n        \"|:-----------|:-----:|----------:|\\n\"\n        \"| Avocado    | green |       nut |\\n\"\n        \"| Tomato     |  red  |     fruit |\\n\"\n        \"| Lettuce    | green | vegetable |\\n\"\n        \"| Watermelon | green |           |\\n\"\n        \"|            |       |           |\"\n    )\n    assert actual == expected\n\n\ndef test_multi_line():\n    \"\"\"Test multi-lined cells.\"\"\"\n    table_data = [\n        [\"Show\", \"Characters\"],\n        [\n            \"Rugrats\",\n            \"Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille, Angelica Pickles,\\nDil Pickles\",\n        ],\n        [\"South Park\", \"Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick\"],\n    ]\n    table = GithubFlavoredMarkdownTable(table_data)\n\n    # Test defaults.\n    actual = table.table\n    expected = (\n        \"| Show       | Characters                                                                          |\\n\"\n        \"|------------|-------------------------------------------------------------------------------------|\\n\"\n        \"| Rugrats    | Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille, Angelica Pickles, |\\n\"\n        \"|            | Dil Pickles                                                                         |\\n\"\n        \"| South Park | Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick                          |\"\n    )\n    assert actual == expected\n\n    # Test inner row border.\n    table.inner_row_border = True\n    actual = table.table\n    expected = (\n        \"| Show       | Characters                                                                          |\\n\"\n        \"|------------|-------------------------------------------------------------------------------------|\\n\"\n        \"| Rugrats    | Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille, Angelica Pickles, |\\n\"\n        \"|            | Dil Pickles                                                                         |\\n\"\n        \"| South Park | Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick                          |\"\n    )\n    assert actual == expected\n\n    # Justify right.\n    table.justify_columns = {1: \"right\"}\n    actual = table.table\n    expected = (\n        \"| Show       |                                                                          Characters |\\n\"\n        \"|------------|------------------------------------------------------------------------------------:|\\n\"\n        \"| Rugrats    | Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille, Angelica Pickles, |\\n\"\n        \"|            |                                                                         Dil Pickles |\\n\"\n        \"| South Park |                          Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick |\"\n    )\n    assert actual == expected\n",
  "GT_file_code": {
    "terminaltables3/github_table.py": "\"\"\"GithubFlavoredMarkdownTable class.\"\"\"\n\nfrom typing import Sequence\n\nfrom terminaltables3.ascii_table import AsciiTable\nfrom terminaltables3.build import combine\n\n\nclass GithubFlavoredMarkdownTable(AsciiTable):\n    \"\"\"Github flavored markdown table.\n\n    https://help.github.com/articles/github-flavored-markdown/#tables\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    \"\"\"\n\n    def __init__(self, table_data: Sequence[Sequence[str]]):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        \"\"\"\n        # Github flavored markdown table won't support title.\n        super().__init__(table_data)\n\n    def horizontal_border(self, _, outer_widths):\n        \"\"\"Handle the GitHub heading border.\n\n        E.g.:\n        |:---|:---:|---:|----|\n\n        :param _: Unused.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border strings in a generator.\n        :rtype: iter\n        \"\"\"\n        horizontal = str(self.CHAR_INNER_HORIZONTAL)\n        left = self.CHAR_OUTER_LEFT_VERTICAL\n        intersect = self.CHAR_INNER_VERTICAL\n        right = self.CHAR_OUTER_RIGHT_VERTICAL\n\n        columns = []\n        for i, width in enumerate(outer_widths):\n            justify = self.justify_columns.get(i)\n            width = max(\n                3, width\n            )  # Width should be at least 3 so justification can be applied.\n            if justify == \"left\":\n                columns.append(\":\" + horizontal * (width - 1))\n            elif justify == \"right\":\n                columns.append(horizontal * (width - 1) + \":\")\n            elif justify == \"center\":\n                columns.append(\":\" + horizontal * (width - 2) + \":\")\n            else:\n                columns.append(horizontal * width)\n\n        return combine(columns, left, intersect, right)\n\n    def gen_table(self, inner_widths, inner_heights, outer_widths):\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            yield from self.gen_row_lines(row, \"row\", inner_widths, inner_heights[i])\n            # Yield heading separator.\n            if i == 0:\n                yield self.horizontal_border(None, outer_widths)\n",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\n\nfrom typing import Generator, Optional, Sequence, Tuple\n\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"-\"\n    CHAR_F_INNER_INTERSECT = \"+\"\n    CHAR_F_INNER_VERTICAL = \"|\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_H_INNER_HORIZONTAL = \"-\"\n    CHAR_H_INNER_INTERSECT = \"+\"\n    CHAR_H_INNER_VERTICAL = \"|\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_INNER_HORIZONTAL = \"-\"\n    CHAR_INNER_INTERSECT = \"+\"\n    CHAR_INNER_VERTICAL = \"|\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"-\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"+\"\n    CHAR_OUTER_BOTTOM_LEFT = \"+\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"+\"\n    CHAR_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"-\"\n    CHAR_OUTER_TOP_INTERSECT = \"+\"\n    CHAR_OUTER_TOP_LEFT = \"+\"\n    CHAR_OUTER_TOP_RIGHT = \"+\"\n\n    def __init__(\n        self, table_data: Sequence[Sequence[str]], title: Optional[str] = None\n    ):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n\n        self.justify_columns = {}  # {0: 'right', 1: 'left', 2: 'center'}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(\n        self, style: str, outer_widths: Sequence[int]\n    ) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == \"top\":\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = (\n                self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == \"bottom\":\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = (\n                self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == \"heading\":\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        elif style == \"footing\":\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(\n        self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int\n    ) -> Generator[Tuple[str, ...], None, None]:\n        r\"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n\n        # Resize row if it doesn't have enough cells.\n        if len(row) != len(inner_widths):\n            row = row + [\"\"] * (len(inner_widths) - len(row))\n\n        # Pad and align each cell. Split each cell into lines to support multi-line cells.\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(\n                align_and_pad_cell(cell, align, inner_dimensions, padding)\n            )\n\n        # Determine border characters.\n        if style == \"heading\":\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        elif style == \"footing\":\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n\n        # Yield each line.\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(\n        self,\n        inner_widths: Sequence[int],\n        inner_heights: Sequence[int],\n        outer_widths: Sequence[int],\n    ) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        # Yield top border.\n        if self.outer_border:\n            yield self.horizontal_border(\"top\", outer_widths)\n\n        # Yield table body.\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = row_count - 1, row_count - 2\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            if self.inner_heading_row_border and i == 0:\n                style = \"heading\"\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = \"footing\"\n            else:\n                style = \"row\"\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            # If this is the last row then break. No separator needed.\n            if i == last_row_index:\n                break\n            # Yield heading separator.\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border(\"heading\", outer_widths)\n            # Yield footing separator.\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border(\"footing\", outer_widths)\n            # Yield row separator.\n            elif self.inner_row_border:\n                yield self.horizontal_border(\"row\", outer_widths)\n\n        # Yield bottom border.\n        if self.outer_border:\n            yield self.horizontal_border(\"bottom\", outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(\n            self.table_data, self.padding_left, self.padding_right\n        )[:3]\n        return flatten(self.gen_table(*dimensions))\n"
  },
  "GT_src_dict": {
    "terminaltables3/github_table.py": {
      "GithubFlavoredMarkdownTable.__init__": {
        "code": "    def __init__(self, table_data: Sequence[Sequence[str]]):\n        \"\"\"Initialize a GithubFlavoredMarkdownTable instance.\n\nThis constructor accepts table data structured as a list of lists of strings, representing the rows and columns of the table. It calls the superclass (AsciiTable) constructor to set up the base table without a title, since Github flavored markdown tables do not support titles.\n\n:param table_data: A sequence of sequences (e.g., list of lists) containing strings that represent the table content.\n:type table_data: Sequence[Sequence[str]]\"\"\"\n        'Constructor.\\n\\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\\n        '\n        super().__init__(table_data)",
        "docstring": "Initialize a GithubFlavoredMarkdownTable instance.\n\nThis constructor accepts table data structured as a list of lists of strings, representing the rows and columns of the table. It calls the superclass (AsciiTable) constructor to set up the base table without a title, since Github flavored markdown tables do not support titles.\n\n:param table_data: A sequence of sequences (e.g., list of lists) containing strings that represent the table content.\n:type table_data: Sequence[Sequence[str]]",
        "signature": "def __init__(self, table_data: Sequence[Sequence[str]]):",
        "type": "Method",
        "class_signature": "class GithubFlavoredMarkdownTable(AsciiTable):"
      }
    },
    "terminaltables3/base_table.py": {
      "BaseTable.table": {
        "code": "    def table(self) -> str:\n        \"\"\"Return the complete string representation of the table, formatted for terminal display.\n\nThis method calculates the maximum dimensions for the table using the `max_dimensions` function, taking into account the left and right padding specified by the `padding_left` and `padding_right` attributes. It then generates the table lines using the `gen_table` method with these dimensions. The result is a single string, ready for output to the terminal.\n\nReturns:\n    str: A formatted string representing the entire table, including borders and cell contents.\n\nDependencies:\n    - `max_dimensions`: Calculates maximum column widths and heights based on the table data and padding.\n    - `gen_table`: Generates the structured lines of the table based on calculated dimensions.\"\"\"\n        'Return a large string of the entire table ready to be printed to the terminal.'\n        dimensions = max_dimensions(self.table_data, self.padding_left, self.padding_right)[:3]\n        return flatten(self.gen_table(*dimensions))",
        "docstring": "Return the complete string representation of the table, formatted for terminal display.\n\nThis method calculates the maximum dimensions for the table using the `max_dimensions` function, taking into account the left and right padding specified by the `padding_left` and `padding_right` attributes. It then generates the table lines using the `gen_table` method with these dimensions. The result is a single string, ready for output to the terminal.\n\nReturns:\n    str: A formatted string representing the entire table, including borders and cell contents.\n\nDependencies:\n    - `max_dimensions`: Calculates maximum column widths and heights based on the table data and padding.\n    - `gen_table`: Generates the structured lines of the table based on calculated dimensions.",
        "signature": "def table(self) -> str:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      }
    }
  },
  "dependency_dict": {
    "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:__init__": {
      "terminaltables3/base_table.py": {
        "BaseTable.__init__": {
          "code": "    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1",
          "docstring": "Constructor.\n\n:param iter table_data: List (empty or list of lists of strings) representing the table.\n:param title: Optional title to show within the top border of the table.",
          "signature": "def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):",
          "type": "Method",
          "class_signature": "class BaseTable:"
        }
      }
    },
    "terminaltables3/base_table.py:BaseTable:table": {
      "terminaltables3/width_and_alignment.py": {
        "max_dimensions": {
          "code": "def max_dimensions(\n    table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0\n):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max(len(r) for r in table_data) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n\n    # Find max width and heights.\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, \"count\") or not hasattr(cell, \"splitlines\"):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count(\"\\n\") + 1)\n            inner_widths[i] = max(\n                inner_widths[i],\n                *[visible_width(the_line) for the_line in cell.splitlines()],\n            )\n\n    # Calculate with padding.\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n\n    return inner_widths, inner_heights, outer_widths, outer_heights",
          "docstring": "Get maximum widths of each column and maximum height of each row.\n\n:param iter table_data: List of list of strings (unmodified table data).\n:param int padding_left: Number of space chars on left side of cell.\n:param int padding_right: Number of space chars on right side of cell.\n:param int padding_top: Number of empty lines on top side of cell.\n:param int padding_bottom: Number of empty lines on bottom side of cell.\n\n:return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n:rtype: tuple",
          "signature": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):",
          "type": "Function",
          "class_signature": null
        }
      },
      "terminaltables3/build.py": {
        "flatten": {
          "code": "def flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)",
          "docstring": "Flatten table data into a single string with newlines.\n\n:param iter table: Padded and bordered table data.\n\n:return: Joined rows/cells.\n:rtype: str",
          "signature": "def flatten(table):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: terminaltables-test_github_table\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u251c\u2500\u2500 base_table.py\n    \u2502   \u2514\u2500\u2500 BaseTable.table\n    \u2514\u2500\u2500 github_table.py\n        \u2514\u2500\u2500 GithubFlavoredMarkdownTable.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the rendering of tables in the GitHub-flavored Markdown (GFM) format by providing a structured, programmatic interface for defining and styling table content. It supports features such as cell alignment, multi-line cell content, and customizable row borders, allowing users to generate aesthetically consistent and readable Markdown tables directly from data arrays. This functionality streamlines the process of creating Markdown-compliant tables for developers and content creators, eliminating the need for manual formatting and ensuring compatibility with Markdown parsers. By addressing the challenges of generating correctly formatted tables with proper column alignment and multiline handling, the module simplifies table generation tasks and improves efficiency for users working in Markdown-based environments.\n\n## FILE 1: terminaltables3/github_table.py\n\n- CLASS METHOD: GithubFlavoredMarkdownTable.__init__\n  - CLASS SIGNATURE: class GithubFlavoredMarkdownTable(AsciiTable):\n  - SIGNATURE: def __init__(self, table_data: Sequence[Sequence[str]]):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a GithubFlavoredMarkdownTable instance.\n\nThis constructor accepts table data structured as a list of lists of strings, representing the rows and columns of the table. It calls the superclass (AsciiTable) constructor to set up the base table without a title, since Github flavored markdown tables do not support titles.\n\n:param table_data: A sequence of sequences (e.g., list of lists) containing strings that represent the table content.\n:type table_data: Sequence[Sequence[str]]\n\"\"\"\n```\n\n## FILE 2: terminaltables3/base_table.py\n\n- CLASS METHOD: BaseTable.table\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def table(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the complete string representation of the table, formatted for terminal display.\n\nThis method calculates the maximum dimensions for the table using the `max_dimensions` function, taking into account the left and right padding specified by the `padding_left` and `padding_right` attributes. It then generates the table lines using the `gen_table` method with these dimensions. The result is a single string, ready for output to the terminal.\n\nReturns:\n    str: A formatted string representing the entire table, including borders and cell contents.\n\nDependencies:\n    - `max_dimensions`: Calculates maximum column widths and heights based on the table data and padding.\n    - `gen_table`: Generates the structured lines of the table based on calculated dimensions.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/github_table.py": "\"\"\"GithubFlavoredMarkdownTable class.\"\"\"\nfrom typing import Sequence\nfrom terminaltables3.ascii_table import AsciiTable\nfrom terminaltables3.build import combine\n\nclass GithubFlavoredMarkdownTable(AsciiTable):\n    \"\"\"Github flavored markdown table.\n\n    https://help.github.com/articles/github-flavored-markdown/#tables\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    \"\"\"\n\n    def horizontal_border(self, _, outer_widths):\n        \"\"\"Handle the GitHub heading border.\n\n        E.g.:\n        |:---|:---:|---:|----|\n\n        :param _: Unused.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border strings in a generator.\n        :rtype: iter\n        \"\"\"\n        horizontal = str(self.CHAR_INNER_HORIZONTAL)\n        left = self.CHAR_OUTER_LEFT_VERTICAL\n        intersect = self.CHAR_INNER_VERTICAL\n        right = self.CHAR_OUTER_RIGHT_VERTICAL\n        columns = []\n        for i, width in enumerate(outer_widths):\n            justify = self.justify_columns.get(i)\n            width = max(3, width)\n            if justify == 'left':\n                columns.append(':' + horizontal * (width - 1))\n            elif justify == 'right':\n                columns.append(horizontal * (width - 1) + ':')\n            elif justify == 'center':\n                columns.append(':' + horizontal * (width - 2) + ':')\n            else:\n                columns.append(horizontal * width)\n        return combine(columns, left, intersect, right)\n\n    def gen_table(self, inner_widths, inner_heights, outer_widths):\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        for i, row in enumerate(self.table_data):\n            yield from self.gen_row_lines(row, 'row', inner_widths, inner_heights[i])\n            if i == 0:\n                yield self.horizontal_border(None, outer_widths)",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\nfrom typing import Generator, Optional, Sequence, Tuple\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '-'\n    CHAR_F_INNER_INTERSECT = '+'\n    CHAR_F_INNER_VERTICAL = '|'\n    CHAR_F_OUTER_LEFT_INTERSECT = '+'\n    CHAR_F_OUTER_LEFT_VERTICAL = '|'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_H_INNER_HORIZONTAL = '-'\n    CHAR_H_INNER_INTERSECT = '+'\n    CHAR_H_INNER_VERTICAL = '|'\n    CHAR_H_OUTER_LEFT_INTERSECT = '+'\n    CHAR_H_OUTER_LEFT_VERTICAL = '|'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_INNER_HORIZONTAL = '-'\n    CHAR_INNER_INTERSECT = '+'\n    CHAR_INNER_VERTICAL = '|'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '-'\n    CHAR_OUTER_BOTTOM_INTERSECT = '+'\n    CHAR_OUTER_BOTTOM_LEFT = '+'\n    CHAR_OUTER_BOTTOM_RIGHT = '+'\n    CHAR_OUTER_LEFT_INTERSECT = '+'\n    CHAR_OUTER_LEFT_VERTICAL = '|'\n    CHAR_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_OUTER_TOP_HORIZONTAL = '-'\n    CHAR_OUTER_TOP_INTERSECT = '+'\n    CHAR_OUTER_TOP_LEFT = '+'\n    CHAR_OUTER_TOP_RIGHT = '+'\n\n    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        if self.outer_border:\n            yield self.horizontal_border('top', outer_widths)\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = (row_count - 1, row_count - 2)\n        for i, row in enumerate(self.table_data):\n            if self.inner_heading_row_border and i == 0:\n                style = 'heading'\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = 'footing'\n            else:\n                style = 'row'\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            if i == last_row_index:\n                break\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border('heading', outer_widths)\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border('footing', outer_widths)\n            elif self.inner_row_border:\n                yield self.horizontal_border('row', outer_widths)\n        if self.outer_border:\n            yield self.horizontal_border('bottom', outer_widths)"
  },
  "call_tree": {
    "tests/test_all_tables_e2e/test_github_table.py:test_single_line": {
      "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:__init__": {
        "terminaltables3/base_table.py:BaseTable:__init__": {}
      },
      "terminaltables3/base_table.py:BaseTable:table": {
        "terminaltables3/width_and_alignment.py:max_dimensions": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:flatten": {
          "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:gen_table": {
            "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
              "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
                "terminaltables3/width_and_alignment.py:visible_width": {}
              },
              "terminaltables3/build.py:build_row": {}
            },
            "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:horizontal_border": {}
          },
          "terminaltables3/build.py:combine": {}
        }
      }
    },
    "tests/test_all_tables_e2e/test_github_table.py:test_multi_line": {
      "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:__init__": {
        "terminaltables3/base_table.py:BaseTable:__init__": {}
      },
      "terminaltables3/base_table.py:BaseTable:table": {
        "terminaltables3/width_and_alignment.py:max_dimensions": {
          "terminaltables3/width_and_alignment.py:visible_width": {}
        },
        "terminaltables3/build.py:flatten": {
          "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:gen_table": {
            "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
              "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
                "terminaltables3/width_and_alignment.py:visible_width": {}
              },
              "terminaltables3/build.py:build_row": {}
            },
            "terminaltables3/github_table.py:GithubFlavoredMarkdownTable:horizontal_border": {}
          },
          "terminaltables3/build.py:combine": {}
        }
      }
    }
  }
}