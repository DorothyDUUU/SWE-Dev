{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_shape_parser",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/parsers/test_shape_parser.py",
  "test_code": "from unittest.mock import MagicMock, Mock, patch\n\nfrom botocore.exceptions import UnknownServiceError\n\nfrom mypy_boto3_builder.parsers.shape_parser import ShapeParser, TypedDictMap\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypedDictAttribute, TypeTypedDict\n\n\nclass TestShapeParser:\n    shape_parser: ShapeParser\n    session_mock: MagicMock\n    service_name: ServiceName\n\n    def setup_method(self) -> None:\n        session_mock = MagicMock()\n        self.session_mock = session_mock\n        self.service_name = ServiceNameCatalog.s3\n        self.shape_parser = ShapeParser(session_mock, ServiceNameCatalog.s3)\n\n    def test_init(self) -> None:\n        assert self.shape_parser.service_name == self.service_name\n\n        self.session_mock._loader.load_service_model.side_effect = UnknownServiceError(\n            service_name=\"service_name\",\n            known_service_names=\"known_service_names\",\n        )\n        ShapeParser(self.session_mock, self.service_name)\n\n    def test_get_paginator_names(self) -> None:\n        self.session_mock._loader.load_service_model.return_value = {\"pagination\": [\"c\", \"a\", \"b\"]}\n        shape_parser = ShapeParser(self.session_mock, self.service_name)\n        assert shape_parser.get_paginator_names() == [\"a\", \"b\", \"c\"]\n\n        self.session_mock._loader.load_service_model.return_value = {\"paginations\": [\"c\", \"a\", \"b\"]}\n        shape_parser = ShapeParser(self.session_mock, self.service_name)\n        assert shape_parser.get_paginator_names() == []\n\n    @patch(\"mypy_boto3_builder.parsers.shape_parser.ServiceModel\")\n    def test_get_client_method_map(self, ServiceModelMock: MagicMock) -> None:\n        session_mock = MagicMock()\n        service_name_mock = MagicMock()\n        operation_model_mock = MagicMock()\n        operation_model_mock.output_shape.serialization = {}\n        ServiceModelMock().operation_names = [\"my_operation\"]\n        ServiceModelMock().operation_model.return_value = operation_model_mock\n        session_mock._loader.load_service_model.return_value = {\n            \"resources\": {\"c\": None, \"a\": None, \"b\": None},\n        }\n        shape_parser = ShapeParser(session_mock, service_name_mock)\n        result = shape_parser.get_client_method_map()\n        assert \"can_paginate\" in result\n        assert \"generate_presigned_url\" in result\n\n    @patch(\"mypy_boto3_builder.parsers.shape_parser.ServiceModel\")\n    def test_get_paginate_method(self, ServiceModelMock: MagicMock) -> None:\n        session_mock = MagicMock()\n        service_name_mock = MagicMock()\n        operation_model_mock = MagicMock()\n        required_arg_shape_mock = MagicMock()\n        optional_arg_shape_mock = MagicMock()\n        required_arg_shape_mock.serialization = {}\n        optional_arg_shape_mock.serialization = {}\n        operation_model_mock.output_shape.serialization = {}\n        operation_model_mock.input_shape.serialization = {}\n        operation_model_mock.input_shape.members.items.return_value = [\n            (\n                \"required_arg\",\n                required_arg_shape_mock,\n            ),\n            (\n                \"optional_arg\",\n                optional_arg_shape_mock,\n            ),\n            (\n                \"InputToken\",\n                optional_arg_shape_mock,\n            ),\n            (\n                \"skip_arg\",\n                optional_arg_shape_mock,\n            ),\n        ]\n        ServiceModelMock().operation_names = [\"my_paginator\"]\n        ServiceModelMock().operation_model.return_value = operation_model_mock\n        session_mock._loader.load_service_model.return_value = {\n            \"pagination\": {\"my_paginator\": {\"input_token\": \"InputToken\", \"limit_key\": \"skip_arg\"}},\n            \"resources\": {},\n        }\n        shape_parser = ShapeParser(session_mock, service_name_mock)\n        result = shape_parser.get_paginate_method(\"my_paginator\")\n        assert result.name == \"paginate\"\n        assert len(result.arguments) == 5\n        assert result.arguments[0].name == \"self\"\n        assert result.arguments[1].is_kwflag()\n        assert result.arguments[2].name == \"required_arg\"\n        assert result.arguments[3].name == \"optional_arg\"\n        assert result.arguments[4].name == \"PaginationConfig\"\n\n    @patch(\"mypy_boto3_builder.parsers.shape_parser.ServiceModel\")\n    def test_get_collection_filter_method(self, ServiceModelMock: MagicMock) -> None:\n        session_mock = MagicMock()\n        service_name_mock = MagicMock()\n        operation_model_mock = MagicMock()\n        required_arg_shape_mock = MagicMock()\n        optional_arg_shape_mock = MagicMock()\n        required_arg_shape_mock.serialization = {}\n        optional_arg_shape_mock.serialization = {}\n        operation_model_mock.output_shape.serialization = {}\n        operation_model_mock.input_shape.serialization = {}\n        operation_model_mock.input_shape.required_members = [\"required_arg\"]\n        operation_model_mock.input_shape.members.items.return_value = [\n            (\n                \"required_arg\",\n                required_arg_shape_mock,\n            ),\n            (\n                \"optional_arg\",\n                optional_arg_shape_mock,\n            ),\n            (\n                \"InputToken\",\n                optional_arg_shape_mock,\n            ),\n        ]\n        ServiceModelMock().operation_names = [\"my_operation\"]\n        ServiceModelMock().operation_model.return_value = operation_model_mock\n        collection_mock = MagicMock()\n        collection_mock.request.operation = \"my_operation\"\n        shape_parser = ShapeParser(session_mock, service_name_mock)\n        result = shape_parser.get_collection_filter_method(\n            \"MyCollection\",\n            collection_mock,\n            Type.Any,\n        )\n        assert result.name == \"filter\"\n        assert len(result.decorators) == 0\n        assert len(result.arguments) == 4\n        assert result.arguments[0].name == \"self\"\n        assert result.arguments[1].is_kwflag()\n        assert result.arguments[2].name == \"optional_arg\"\n        assert result.arguments[3].name == \"InputToken\"\n\n    def test_fix_typed_dict_names(self) -> None:\n        session_mock = MagicMock()\n        service_name_mock = MagicMock()\n        shape_parser = ShapeParser(session_mock, service_name_mock)\n        shape_parser._typed_dict_map = TypedDictMap(\n            {\n                \"TestTypeDef\": TypeTypedDict(\n                    \"TestTypeDef\",\n                    [\n                        TypedDictAttribute(\"Test\", Type.Any, required=False),\n                    ],\n                ),\n                \"Test2TypeDef\": TypeTypedDict(\n                    \"Test2TypeDef\",\n                    [\n                        TypedDictAttribute(\"Test2\", Type.Any, required=False),\n                    ],\n                ),\n                \"Test3TypeDef\": TypeTypedDict(\n                    \"Test3TypeDef\",\n                    [\n                        TypedDictAttribute(\"Test3\", Type.Any, required=True),\n                    ],\n                ),\n                \"Test2ResponseTypeDef\": TypeTypedDict(\n                    \"Test2ResponseTypeDef\",\n                    [\n                        TypedDictAttribute(\"ResponseMetadata\", Type.Any, required=False),\n                    ],\n                ),\n            },\n        )\n        shape_parser._output_typed_dict_map = TypedDictMap(\n            {\n                \"TestTypeDef\": TypeTypedDict(\n                    \"TestTypeDef\",\n                    [\n                        TypedDictAttribute(\"Test\", Type.Any, required=True),\n                    ],\n                ),\n            },\n        )\n        shape_parser._response_typed_dict_map = TypedDictMap(\n            {\n                \"Test2TypeDef\": TypeTypedDict(\n                    \"Test2TypeDef\",\n                    [\n                        TypedDictAttribute(\"Test2\", Type.Any, required=True),\n                    ],\n                ),\n            },\n        )\n        shape_parser.fix_typed_dict_names()\n        assert len(shape_parser._typed_dict_map) == 4\n        assert len(shape_parser._output_typed_dict_map) == 1\n        assert len(shape_parser._response_typed_dict_map) == 1\n        assert shape_parser._output_typed_dict_map[\"TestOutputTypeDef\"].name == \"TestOutputTypeDef\"\n        assert shape_parser._output_typed_dict_map[\"TestOutputTypeDef\"].has_optional() is False\n        assert (\n            shape_parser._response_typed_dict_map[\"Test2ExtraResponseTypeDef\"].has_optional()\n            is False\n        )\n\n    def test_get_literal_name(self) -> None:\n        session_mock = MagicMock()\n        service_name_mock = MagicMock()\n        shape_parser = ShapeParser(session_mock, service_name_mock)\n\n        shape = MagicMock()\n        shape.enum = [\"as\", \"b\"]\n        shape.name = \"Type\"\n        assert shape_parser._get_literal_name(shape) == \"TypeType\"\n\n        shape.name = \"_Type\"\n        assert shape_parser._get_literal_name(shape) == \"TypeType\"\n\n        shape.name = \"__Type\"\n        assert shape_parser._get_literal_name(shape) == \"TypeType\"\n\n        shape.name = \"__string\"\n        assert shape_parser._get_literal_name(shape) == \"AsBType\"\n\n        shape.name = \"Protocol\"\n        assert shape_parser._get_literal_name(shape) == \"ProtocolType\"\n\n        shape.name = \"Other\"\n        assert shape_parser._get_literal_name(shape) == \"OtherType\"\n\n    def test_parse_shape_string(self) -> None:\n        shape_parser = ShapeParser(Mock(), Mock())\n        shape = Mock()\n        shape.name = \"MyShape\"\n        shape.enum = []\n        shape.metadata = {\"pattern\": \"any\"}\n        assert shape_parser._parse_shape_string(shape).render() == \"str\"\n\n        shape.enum = [\"a\", \"b\"]\n        assert shape_parser._parse_shape_string(shape).render() == \"MyShapeType\"\n        assert shape_parser._parse_shape_string(shape).render() == \"MyShapeType\"\n        assert shape_parser._parse_shape_string(shape).children == {\"a\", \"b\"}\n\n    def test_get_resource_method_map(self) -> None:\n        self.session_mock._loader.load_service_model.return_value = {\n            \"resources\": {\n                \"c\": {\n                    \"actions\": {\n                        \"MyAction\": {\n                            \"resource\": {\"type\": \"str\"},\n                            \"request\": {\n                                \"operation\": \"extract\",\n                                \"params\": [\n                                    {\n                                        \"source\": \"identifier\",\n                                        \"target\": \"list.new[0]\",\n                                        \"name\": \"param1\",\n                                        \"type\": \"bool\",\n                                    },\n                                    {\n                                        \"source\": \"string\",\n                                        \"target\": \"list.new[0]\",\n                                        \"name\": \"param2\",\n                                        \"type\": \"str\",\n                                    },\n                                ],\n                            },\n                        },\n                    },\n                    \"waiters\": {\"MyWaiter\": {\"operation\": \"MyOperation\"}},\n                    \"has\": {\n                        \"SubResource\": {\n                            \"resource\": {\n                                \"identifiers\": [\n                                    {\"source\": \"input\", \"name\": \"ident\", \"type\": \"bool\"},\n                                    {\"source\": \"noinput\", \"name\": \"ident\", \"type\": \"bool\"},\n                                ],\n                                \"type\": \"str\",\n                            },\n                        },\n                        \"NoSubResource\": {},\n                    },\n                },\n            },\n        }\n        shape_parser = ShapeParser(self.session_mock, self.service_name)\n        result = shape_parser.get_resource_method_map(\"c\")\n        assert len(result.keys()) == 6\n",
  "GT_file_code": {
    "mypy_boto3_builder/parsers/shape_parser.py": "\"\"\"\nParser for botocore shape files.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport contextlib\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING\n\nfrom boto3.resources.model import Collection\nfrom boto3.session import Session\nfrom botocore.eventstream import EventStream\nfrom botocore.exceptions import UnknownServiceError\nfrom botocore.model import (\n    ListShape,\n    MapShape,\n    OperationModel,\n    ServiceModel,\n    Shape,\n    StringShape,\n    StructureShape,\n)\n\nfrom mypy_boto3_builder.constants import (\n    ATTRIBUTES,\n    CLIENT,\n    SERVICE_RESOURCE,\n)\nfrom mypy_boto3_builder.exceptions import ShapeParserError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.parsers.shape_parser_types import (\n    ActionShape,\n    IdentifierShape,\n    PaginatorShape,\n    PaginatorsShape,\n    ResourceShape,\n    ResourcesShape,\n    WaitersShape,\n)\nfrom mypy_boto3_builder.parsers.typed_dict_map import TypedDictMap\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion\nfrom mypy_boto3_builder.type_maps.argument_alias_map import get_argument_alias\nfrom mypy_boto3_builder.type_maps.literal_type_map import get_type_literal_stub\nfrom mypy_boto3_builder.type_maps.method_type_map import (\n    get_default_value_stub,\n    get_method_type_stub,\n)\nfrom mypy_boto3_builder.type_maps.required_attribute_map import is_required\nfrom mypy_boto3_builder.type_maps.shape_type_map import (\n    get_output_shape_type_stub,\n    get_shape_type_stub,\n)\nfrom mypy_boto3_builder.type_maps.typed_dicts import (\n    EmptyResponseMetadataTypeDef,\n    PaginatorConfigTypeDef,\n    ResponseMetadataTypeDef,\n    WaiterConfigTypeDef,\n)\nfrom mypy_boto3_builder.utils.boto3_utils import get_botocore_session\nfrom mypy_boto3_builder.utils.strings import capitalize, get_type_def_name, xform_name\n\nif TYPE_CHECKING:\n    from botocore.session import Session as BotocoreSession\n\n\nclass ShapeParser:\n    \"\"\"\n    Parser for botocore shape files.\n\n    Arguments:\n        session -- Boto3 session.\n        service_name -- ServiceName.\n    \"\"\"\n\n    def __init__(self, session: Session, service_name: ServiceName) -> None:\n        loader = session._loader\n        botocore_session: BotocoreSession = get_botocore_session(session)\n        service_data = botocore_session.get_service_data(service_name.boto3_name)\n        self.service_name = service_name\n        self.service_model = ServiceModel(service_data, service_name.boto3_name)\n        self._resource_name: str = \"\"\n        self._type_literal_map: dict[str, TypeLiteral] = {}\n        self._typed_dict_map = TypedDictMap()\n        self._output_typed_dict_map = TypedDictMap()\n        self._response_typed_dict_map = TypedDictMap()\n        self._fixed_typed_dict_map: dict[TypeTypedDict, TypeTypedDict] = {}\n\n        self._waiters_shape: WaitersShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._waiters_shape = loader.load_service_model(service_name.boto3_name, \"waiters-2\")\n\n        self._paginators_shape: PaginatorsShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._paginators_shape = loader.load_service_model(\n                service_name.boto3_name,\n                \"paginators-1\",\n            )\n\n        self._resources_shape: ResourcesShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._resources_shape = loader.load_service_model(\n                service_name.boto3_name,\n                \"resources-1\",\n            )\n\n        self.logger = get_logger()\n\n    @property\n    def resource_name(self) -> str:\n        \"\"\"\n        Parsed resource name.\n        \"\"\"\n        return self._resource_name\n\n    def _get_operation(self, name: str) -> OperationModel:\n        return self.service_model.operation_model(name)\n\n    def _get_paginator(self, name: str) -> PaginatorShape:\n        if not self._paginators_shape:\n            raise ShapeParserError(f\"Unknown paginator: {name}\")\n        try:\n            return self._paginators_shape[\"pagination\"][name]\n        except KeyError as e:\n            raise ShapeParserError(f\"Unknown paginator: {name}\") from e\n\n    def _get_service_resource(self) -> ResourceShape:\n        if not self._resources_shape:\n            raise ShapeParserError(\"Resource shape not found\")\n        return self._resources_shape[\"service\"]\n\n    def _get_resource_names(self) -> list[str]:\n        if not self._resources_shape:\n            return []\n        if \"resources\" not in self._resources_shape:\n            return []\n\n        return list(self._resources_shape[\"resources\"].keys())\n\n    def _get_resource_shape(self, name: str) -> ResourceShape:\n        if name == SERVICE_RESOURCE:\n            return self._get_service_resource()\n\n        if not self._resources_shape or \"resources\" not in self._resources_shape:\n            raise ShapeParserError(\"Resource shape not found\")\n\n        try:\n            return self._resources_shape[\"resources\"][name]\n        except KeyError as e:\n            raise ShapeParserError(f\"Unknown resource: {name}\") from e\n\n    def get_paginator_names(self) -> list[str]:\n        \"\"\"\n        Get available paginator names.\n\n        Returns:\n            A list of paginator names.\n        \"\"\"\n        if not self._paginators_shape or not self._paginators_shape.get(\"pagination\"):\n            return []\n        result = list(self._paginators_shape[\"pagination\"])\n        result.sort()\n        return result\n\n    def _parse_arguments(\n        self,\n        *,\n        class_name: str,\n        method_name: str,\n        operation_name: str,\n        shape: StructureShape,\n        exclude_names: Iterable[str] = (),\n        optional_only: bool = False,\n    ) -> list[Argument]:\n        result: list[Argument] = []\n        required = shape.required_members\n        for argument_name, argument_shape in shape.members.items():\n            if argument_name in exclude_names:\n                continue\n            argument_alias = get_argument_alias(self.service_name, operation_name, argument_name)\n            if argument_alias is None:\n                continue\n\n            argument_type_stub = get_method_type_stub(\n                self.service_name,\n                class_name,\n                method_name,\n                argument_name,\n            )\n            if argument_type_stub is Type.RemoveArgument:\n                continue\n            if argument_type_stub is not None:\n                argument_type = argument_type_stub\n            else:\n                argument_type = self.parse_shape(argument_shape)\n            argument = Argument(argument_alias, argument_type)\n            if argument_name not in required:\n                argument.default = Type.Ellipsis\n            default_value_stub = get_default_value_stub(\n                self.service_name,\n                class_name,\n                method_name,\n                argument_name,\n            )\n            if default_value_stub is not None:\n                argument.default = default_value_stub\n            if optional_only and argument.required:\n                continue\n\n            # FIXME: https://github.com/boto/boto3/issues/2813\n            # if not argument.required and argument.type_annotation:\n            #     argument.type_annotation = get_optional(argument.type_annotation)\n\n            result.append(argument)\n\n        result.sort(key=lambda x: not x.required)\n        return result\n\n    def _parse_return_type(\n        self,\n        class_name: str,\n        method_name: str,\n        shape: Shape | None,\n    ) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(\n            self.service_name,\n            class_name,\n            method_name,\n            \"return\",\n        )\n        if argument_type_stub is not None:\n            return argument_type_stub\n\n        if shape:\n            return self.parse_shape(shape, is_output=True)\n\n        return Type.none\n\n    @staticmethod\n    def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:\n        if len(arguments) and not method_name[0].isupper():\n            return [Argument.kwflag()]\n\n        return []\n\n    def get_client_method_map(self) -> dict[str, Method]:\n        \"\"\"\n        Get client methods from shape.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        self._resource_name = CLIENT\n        result: dict[str, Method] = {\n            \"can_paginate\": Method(\n                name=\"can_paginate\",\n                arguments=(Argument.self(), Argument(\"operation_name\", Type.str)),\n                return_type=Type.bool,\n            ),\n            \"generate_presigned_url\": Method(\n                name=\"generate_presigned_url\",\n                arguments=(\n                    Argument.self(),\n                    Argument(\"ClientMethod\", Type.str),\n                    Argument(\"Params\", Type.MappingStrAny, Type.Ellipsis),\n                    Argument(\"ExpiresIn\", Type.int, TypeConstant(3600)),\n                    Argument(\"HttpMethod\", Type.str, Type.Ellipsis),\n                ),\n                return_type=Type.str,\n            ),\n            \"close\": Method(\n                name=\"close\",\n                arguments=(Argument.self(),),\n                return_type=Type.none,\n            ),\n        }\n        for operation_name in self.service_model.operation_names:\n            operation_model = self._get_operation(operation_name)\n            arguments: list[Argument] = [Argument.self()]\n            method_name = xform_name(operation_name)\n\n            if operation_model.input_shape is not None:\n                shape_arguments = self._parse_arguments(\n                    class_name=self._resource_name,\n                    method_name=method_name,\n                    operation_name=operation_name,\n                    shape=operation_model.input_shape,\n                )\n                arguments.extend(self._get_kw_flags(method_name, shape_arguments))\n                arguments.extend(shape_arguments)\n\n            return_type = self._parse_return_type(\n                self._resource_name,\n                method_name,\n                operation_model.output_shape,\n            )\n            if return_type is Type.none:\n                return_type = EmptyResponseMetadataTypeDef\n\n            method = Method(name=method_name, arguments=arguments, return_type=return_type)\n            if operation_model.input_shape:\n                method.create_request_type_annotation(\n                    self._get_typed_dict_name(operation_model.input_shape, postfix=\"Request\"),\n                )\n            result[method.name] = method\n        return result\n\n    @staticmethod\n    def _get_typed_dict_name(shape: Shape, postfix: str = \"\") -> str:\n        return get_type_def_name(shape.name, postfix)\n\n    @staticmethod\n    def _get_literal_name(shape: StringShape) -> str:\n        # FIXME: hack for apigatewayv2\n        if shape.name == \"__string\":\n            children_name = \"\".join(sorted(capitalize(i) for i in shape.enum))\n            return f\"{children_name}Type\"\n\n        name = capitalize(shape.name.lstrip(\"_\"))\n        return f\"{name}Type\"\n\n    def _parse_shape_string(self, shape: StringShape) -> FakeAnnotation:\n        if shape.enum:\n            literal_name = self._get_literal_name(shape)\n            type_literal_stub = get_type_literal_stub(self.service_name, literal_name)\n            type_literal = type_literal_stub or TypeLiteral(literal_name, set(shape.enum))\n            if literal_name in self._type_literal_map:\n                old_type_literal = self._type_literal_map[literal_name]\n                if not type_literal.is_same(old_type_literal):\n                    raise ShapeParserError(\n                        f\"Literal {literal_name} has different values:\"\n                        f\" {old_type_literal.children} vs {type_literal.children}\",\n                    )\n                return old_type_literal\n\n            self._type_literal_map[literal_name] = type_literal\n            return type_literal\n\n        # FIXME: botocore does not always try to parse response as JSON\n        # pattern = shape.metadata.get(\"pattern\", \"\")\n        # if pattern in (\n        #     \"[\\\\u0009\\\\u000A\\\\u000D\\\\u0020-\\\\u00FF]+\",\n        #     \"^[\\\\u0009\\\\u000A\\\\u000D\\\\u0020-\\\\u00FF]+$\",\n        # ):\n        #     if output_child:\n        #         return Type.DictStrAny\n        #     else:\n        #         return DictOrStrTypeDef\n\n        return Type.str\n\n    def _parse_shape_map(\n        self,\n        shape: MapShape,\n        *,\n        is_output_child: bool = False,\n        is_streaming: bool = False,\n    ) -> FakeAnnotation:\n        type_subscript = (\n            TypeSubscript(Type.Dict) if is_output_child else TypeSubscript(Type.Mapping)\n        )\n        if shape.key:\n            type_subscript.add_child(\n                self.parse_shape(\n                    shape.key,\n                    is_output_child=is_output_child,\n                    is_streaming=is_streaming,\n                ),\n            )\n        else:\n            type_subscript.add_child(Type.str)\n        if shape.value:\n            type_subscript.add_child(\n                self.parse_shape(\n                    shape.value,\n                    is_output_child=is_output_child,\n                    is_streaming=is_streaming,\n                ),\n            )\n        else:\n            type_subscript.add_child(Type.Any)\n        return type_subscript\n\n    def _get_typed_dict_map(self, *, output: bool, output_child: bool) -> TypedDictMap:\n        if output:\n            return self._response_typed_dict_map\n        if output_child:\n            return self._output_typed_dict_map\n        return self._typed_dict_map\n\n    def _parse_shape_structure(\n        self,\n        shape: StructureShape,\n        *,\n        output: bool = False,\n        output_child: bool = False,\n        is_streaming: bool = False,\n    ) -> FakeAnnotation:\n        if not shape.members.items():\n            return Type.DictStrAny if output_child else Type.MappingStrAny\n\n        required = shape.required_members\n        is_output_or_child = output or output_child\n        typed_dict_name = self._get_shape_type_name(shape)\n        typed_dict = TypeTypedDict(typed_dict_name)\n\n        typed_dict_map = self._get_typed_dict_map(output=output, output_child=output_child)\n        resource_typed_dict_name = self._get_typed_dict_name(shape, postfix=self.resource_name)\n        found_typed_dict = typed_dict_map.get(typed_dict.name)\n        found_resource_typed_dict = typed_dict_map.get(resource_typed_dict_name)\n\n        if found_resource_typed_dict:\n            return found_resource_typed_dict\n\n        typed_dict_map[resource_typed_dict_name] = typed_dict\n\n        for attr_name, attr_shape in shape.members.items():\n            typed_dict.add_attribute(\n                attr_name,\n                self.parse_shape(\n                    attr_shape,\n                    is_output=False,\n                    is_output_child=is_output_or_child,\n                    is_streaming=is_streaming,\n                ),\n                required=attr_name in required,\n            )\n        if output:\n            self._mark_typed_dict_as_total(typed_dict)\n            self._add_response_metadata(typed_dict)\n\n        if found_typed_dict and not typed_dict.is_same(found_typed_dict):\n            self.logger.debug(\n                f\"Renaming conflicting {typed_dict.name} to {resource_typed_dict_name}\",\n            )\n            typed_dict.name = resource_typed_dict_name\n        typed_dict_map[typed_dict.name] = typed_dict\n        return typed_dict\n\n    def _mark_typed_dict_as_total(self, typed_dict: TypeTypedDict) -> None:\n        for attribute in typed_dict.children:\n            if is_required(self.service_name, typed_dict.name, attribute.name):\n                attribute.mark_as_required()\n            else:\n                self.logger.debug(\n                    f\"Leaving output {typed_dict.name}.{attribute.name}\"\n                    f\" as {attribute.get_type_annotation().render()}\",\n                )\n\n    def _add_response_metadata(self, typed_dict: TypeTypedDict) -> None:\n        child_names = {i.name for i in typed_dict.children}\n        if \"ResponseMetadata\" not in child_names:\n            typed_dict.add_attribute(\n                \"ResponseMetadata\",\n                ResponseMetadataTypeDef,\n                required=True,\n            )\n\n    def _parse_shape_list(\n        self,\n        shape: ListShape,\n        *,\n        is_output_child: bool = False,\n    ) -> FakeAnnotation:\n        type_subscript = (\n            TypeSubscript(Type.List) if is_output_child else TypeSubscript(Type.Sequence)\n        )\n        if shape.member:\n            type_subscript.add_child(\n                self.parse_shape(shape.member, is_output_child=is_output_child),\n            )\n        else:\n            type_subscript.add_child(Type.Any)\n        return type_subscript\n\n    def _get_shape_type_name(self, shape: Shape) -> str:\n        if isinstance(shape, StructureShape):\n            return self._get_typed_dict_name(shape)\n\n        if isinstance(shape, StringShape):\n            return shape.name\n\n        return shape.type_name\n\n    @staticmethod\n    def _get_streaming_body(shape: Shape) -> Shape | None:\n        \"\"\"\n        Get the streaming member's shape if any; or None otherwise.\n        \"\"\"\n        if not isinstance(shape, StructureShape):\n            return None\n        payload = shape.serialization.get(\"payload\")\n        if payload is not None:\n            payload_shape = shape.members.get(payload)\n            if isinstance(payload_shape, Shape) and payload_shape.type_name == \"blob\":\n                return payload_shape\n        return None\n\n    def _parse_shape_by_type(\n        self,\n        shape: Shape,\n        *,\n        is_output_or_child: bool,\n        output: bool,\n        is_streaming: bool,\n    ) -> FakeAnnotation:\n        match shape:\n            case StringShape():\n                return self._parse_shape_string(shape)\n            case MapShape():\n                return self._parse_shape_map(\n                    shape,\n                    is_output_child=is_output_or_child,\n                    is_streaming=is_streaming,\n                )\n            case StructureShape():\n                return self._parse_shape_structure(\n                    shape,\n                    output=output,\n                    output_child=is_output_or_child,\n                    is_streaming=is_streaming,\n                )\n            case ListShape():\n                return self._parse_shape_list(shape, is_output_child=is_output_or_child)\n            case _:\n                pass\n\n        if shape.type_name in self._get_resource_names():\n            return InternalImport(shape.type_name, use_alias=True)\n\n        self.logger.warning(f\"Unknown shape: {shape} {shape.type_name}\")\n        return Type.Any\n\n    def parse_shape(\n        self,\n        shape: Shape,\n        *,\n        is_output: bool = False,\n        is_output_child: bool = False,\n        is_streaming: bool = False,\n    ) -> FakeAnnotation:\n        \"\"\"\n        Parse any botocore shape to TypeAnnotation.\n\n        Arguments:\n            shape -- Botocore shape.\n            output -- Whether shape should use strict output types.\n            output_child -- Whether shape parent is marked as output.\n            is_streaming -- Whether shape should be streaming.\n\n        Returns:\n            TypeAnnotation or similar class.\n        \"\"\"\n        if shape.serialization.get(\"eventstream\"):\n            shape.serialization[\"eventstream\"] = False\n            return TypeSubscript(\n                ExternalImport.from_class(EventStream),\n                [\n                    self.parse_shape(\n                        shape,\n                        is_output=is_output,\n                        is_output_child=is_output_child,\n                        is_streaming=is_streaming,\n                    ),\n                ],\n                stringify=True,\n            )\n        is_output_or_child = is_output or is_output_child\n        if not is_streaming:\n            is_streaming = \"streaming\" in shape.serialization and shape.serialization[\"streaming\"]\n            if is_output_or_child:\n                is_streaming = self._get_streaming_body(shape) is not None\n\n        type_name = self._get_shape_type_name(shape)\n        if is_streaming and shape.type_name == \"blob\":\n            type_name = \"blob_streaming\"\n\n        if is_output_or_child:\n            shape_type_stub = get_output_shape_type_stub(\n                self.service_name,\n                self._resource_name,\n                type_name,\n            )\n        else:\n            shape_type_stub = get_shape_type_stub(self.service_name, self._resource_name, type_name)\n\n        if shape_type_stub:\n            return shape_type_stub\n\n        result = self._parse_shape_by_type(\n            shape,\n            is_output_or_child=is_output_or_child,\n            output=is_output,\n            is_streaming=is_streaming,\n        )\n        if isinstance(result, TypeTypedDict):\n            replacement = Type.DictStrAny if is_output_or_child else Type.MappingStrAny\n            mutated_parents = result.replace_self_references(replacement)\n            for mutated_parent in sorted(mutated_parents):\n                self.logger.debug(\n                    f\"Replaced self reference for {result.render()} in {mutated_parent.render()}\",\n                )\n\n        return result\n\n    def get_paginate_method(self, paginator_name: str) -> Method:\n        \"\"\"\n        Get Paginator `paginate` method.\n\n        Arguments:\n            paginator_name -- Paginator name.\n\n        Returns:\n            Method.\n        \"\"\"\n        self._resource_name = \"Paginator\"\n        operation_name = paginator_name\n        paginator_shape = self._get_paginator(paginator_name)\n        operation_shape = self._get_operation(operation_name)\n        skip_argument_names: list[str] = []\n        input_token: list[str] | str = paginator_shape[\"input_token\"]\n        if isinstance(input_token, list):\n            skip_argument_names.extend(input_token)\n        else:\n            skip_argument_names.append(input_token)\n        if \"limit_key\" in paginator_shape:\n            skip_argument_names.append(paginator_shape[\"limit_key\"])\n\n        arguments: list[Argument] = [Argument.self()]\n\n        if operation_shape.input_shape is not None:\n            shape_arguments = self._parse_arguments(\n                class_name=\"Paginator\",\n                method_name=\"paginate\",\n                operation_name=operation_name,\n                shape=operation_shape.input_shape,\n                exclude_names=skip_argument_names,\n            )\n            shape_arguments.append(\n                Argument(\"PaginationConfig\", PaginatorConfigTypeDef, Type.Ellipsis),\n            )\n            arguments.extend(self._get_kw_flags(\"paginate\", shape_arguments))\n            arguments.extend(shape_arguments)\n\n        return_type: FakeAnnotation = Type.none\n        if operation_shape.output_shape is not None:\n            page_iterator_import = InternalImport(\"_PageIterator\", stringify=False)\n            return_item = self._parse_return_type(\n                \"Paginator\",\n                \"paginate\",\n                operation_shape.output_shape,\n            )\n            return_type = TypeSubscript(page_iterator_import, [return_item])\n\n        method = Method(name=\"paginate\", arguments=arguments, return_type=return_type)\n        if operation_shape.input_shape is not None:\n            method.create_request_type_annotation(\n                self._get_typed_dict_name(\n                    operation_shape.input_shape,\n                    postfix=f\"{paginator_name}Paginate\",\n                ),\n            )\n        return method\n\n    def get_wait_method(self, waiter_name: str) -> Method:\n        \"\"\"\n        Get Waiter `wait` method.\n\n        Arguments:\n            waiter_name -- Waiter name.\n\n        Returns:\n            Method.\n        \"\"\"\n        self._resource_name = \"Waiter\"\n        if not self._waiters_shape:\n            raise ShapeParserError(\"Waiter not found\")\n        operation_name = self._waiters_shape[\"waiters\"][waiter_name][\"operation\"]\n        operation_shape = self._get_operation(operation_name)\n\n        arguments: list[Argument] = [Argument.self()]\n\n        if operation_shape.input_shape is not None:\n            shape_arguments = self._parse_arguments(\n                class_name=\"Waiter\",\n                method_name=\"wait\",\n                operation_name=operation_name,\n                shape=operation_shape.input_shape,\n            )\n            shape_arguments.append(Argument(\"WaiterConfig\", WaiterConfigTypeDef, Type.Ellipsis))\n            arguments.extend(self._get_kw_flags(\"wait\", shape_arguments))\n            arguments.extend(shape_arguments)\n\n        method = Method(name=\"wait\", arguments=arguments, return_type=Type.none)\n        if operation_shape.input_shape is not None:\n            method.create_request_type_annotation(\n                self._get_typed_dict_name(\n                    operation_shape.input_shape,\n                    postfix=f\"{waiter_name}Wait\",\n                ),\n            )\n        return method\n\n    def _get_identifier_type(\n        self,\n        resource_name: str,\n        method_name: str,\n        identifier_name: str,\n        identifier: IdentifierShape,\n    ) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(\n            self.service_name,\n            resource_name,\n            method_name,\n            identifier_name,\n        )\n        if argument_type_stub:\n            return argument_type_stub\n        identifier_type = identifier.get(\"type\")\n        if identifier_type:\n            argument_type_stub = get_shape_type_stub(\n                self.service_name,\n                resource_name,\n                identifier_type,\n            )\n            if argument_type_stub:\n                return argument_type_stub\n\n        return Type.str\n\n    @staticmethod\n    def _get_identifier_xform_name(identifier: IdentifierShape) -> str:\n        return xform_name(identifier.get(\"name\") or identifier.get(\"target\") or \"unknown\")\n\n    def _get_identifier_argument(\n        self,\n        resource_name: str,\n        method_name: str,\n        identifier: IdentifierShape,\n    ) -> Argument:\n        argument_name = self._get_identifier_xform_name(identifier)\n        argument_type = self._get_identifier_type(\n            resource_name,\n            method_name,\n            argument_name,\n            identifier,\n        )\n        return Argument(argument_name, argument_type)\n\n    def _get_identifier_attribute(\n        self,\n        resource_name: str,\n        identifier: IdentifierShape,\n    ) -> Attribute:\n        attribute_name = self._get_identifier_xform_name(identifier)\n        attribute_type = self._get_identifier_type(\n            resource_name,\n            ATTRIBUTES,\n            attribute_name,\n            identifier,\n        )\n        return Attribute(name=attribute_name, type_annotation=attribute_type, is_identifier=True)\n\n    def get_service_resource_method_map(self) -> dict[str, Method]:\n        \"\"\"\n        Get methods for ServiceResource.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        result: dict[str, Method] = {\n            \"get_available_subresources\": Method(\n                name=\"get_available_subresources\",\n                arguments=[Argument.self()],\n                return_type=TypeSubscript(Type.Sequence, [Type.str]),\n            ),\n        }\n        self._resource_name = SERVICE_RESOURCE\n        service_resource_shape = self._get_resource_shape(self._resource_name)\n        for action_name, action_shape in service_resource_shape.get(\"actions\", {}).items():\n            method = self._get_resource_method(action_name, action_shape)\n            result[method.name] = method\n\n        for sub_resource_name in self._get_resource_names():\n            resource_shape = self._get_resource_shape(sub_resource_name)\n            arguments = [Argument.self()]\n            identifiers = resource_shape.get(\"identifiers\", [])\n            for identifier in identifiers:\n                argument = self._get_identifier_argument(\n                    self._resource_name,\n                    sub_resource_name,\n                    identifier,\n                )\n                arguments.append(argument)\n            method = Method(\n                name=sub_resource_name,\n                arguments=arguments,\n                return_type=InternalImport(sub_resource_name, use_alias=True),\n            )\n            result[method.name] = method\n\n        return result\n\n    def get_resource_identifier_attributes(self, resource_name: str) -> list[Attribute]:\n        \"\"\"\n        Get attributes for Resource identifiers.\n\n        Arguments:\n            resource_name -- Resource name.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        self._resource_name = resource_name\n        resource_shape = self._get_resource_shape(resource_name)\n        identifiers = resource_shape.get(\"identifiers\", [])\n        return [\n            self._get_identifier_attribute(resource_name, identifier) for identifier in identifiers\n        ]\n\n    def get_resource_method_map(self, resource_name: str) -> dict[str, Method]:\n        \"\"\"\n        Get methods for Resource.\n\n        Arguments:\n            resource_name -- Resource name.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        self._resource_name = resource_name\n        resource_shape = self._get_resource_shape(resource_name)\n        result: dict[str, Method] = {\n            \"get_available_subresources\": Method(\n                name=\"get_available_subresources\",\n                arguments=[Argument.self()],\n                return_type=TypeSubscript(Type.Sequence, [Type.str]),\n            ),\n            \"load\": Method(name=\"load\", arguments=[Argument.self()], return_type=Type.none),\n            \"reload\": Method(name=\"reload\", arguments=[Argument.self()], return_type=Type.none),\n        }\n\n        if \"actions\" in resource_shape:\n            for action_name, action_shape in resource_shape[\"actions\"].items():\n                method = self._get_resource_method(action_name, action_shape)\n                result[method.name] = method\n\n        if \"waiters\" in resource_shape:\n            for waiter_name in resource_shape[\"waiters\"]:\n                method = Method(\n                    name=f\"wait_until_{xform_name(waiter_name)}\",\n                    arguments=[Argument.self()],\n                    return_type=Type.none,\n                )\n                result[method.name] = method\n\n        if \"has\" in resource_shape:\n            for sub_resource_name, sub_resource in resource_shape[\"has\"].items():\n                if \"resource\" not in sub_resource:\n                    continue\n                data = sub_resource[\"resource\"]\n                arguments = [Argument.self()]\n                identifiers = data.get(\"identifiers\", [])\n                for identifier in identifiers:\n                    if identifier.get(\"source\") != \"input\":\n                        continue\n                    argument = self._get_identifier_argument(\n                        resource_name,\n                        sub_resource_name,\n                        identifier,\n                    )\n                    arguments.append(argument)\n\n                method = Method(\n                    name=sub_resource_name,\n                    arguments=arguments,\n                    return_type=InternalImport(data[\"type\"], use_alias=True),\n                )\n                result[method.name] = method\n\n        return result\n\n    @staticmethod\n    def _get_arg_from_target(target: str) -> str:\n        if \"[\" in target:\n            target = target.split(\"[\")[0]\n        if \".\" in target:\n            target = target.split(\".\")[0]\n        return target\n\n    def _get_skip_argument_names(self, action_shape: ActionShape) -> set[str]:\n        result: set[str] = set()\n        params = action_shape[\"request\"].get(\"params\", [])\n        for param in params:\n            target = param[\"target\"]\n            source = param[\"source\"]\n            if source == \"identifier\":\n                result.add(self._get_arg_from_target(target))\n                continue\n            if source == \"string\" and \".\" in target:\n                result.add(self._get_arg_from_target(target))\n                continue\n\n        return result\n\n    def _enrich_arguments_defaults(\n        self,\n        arguments: list[Argument],\n        action_shape: ActionShape,\n    ) -> None:\n        request = action_shape[\"request\"]\n        arguments_map = {a.name: a for a in arguments}\n        if \"params\" in request:\n            for param in request[\"params\"]:\n                target = param[\"target\"]\n                source = param[\"source\"]\n                if source == \"string\" and target in arguments_map:\n                    arguments_map[target].default = TypeConstant(param[\"value\"])\n\n    def _get_resource_method(self, action_name: str, action_shape: ActionShape) -> Method:\n        return_type: FakeAnnotation = Type.none\n        method_name = xform_name(action_name)\n        arguments: list[Argument] = [Argument.self()]\n        if \"resource\" in action_shape:\n            return_type = self._parse_return_type(\n                self.resource_name,\n                method_name,\n                Shape(\"resource\", action_shape[\"resource\"]),\n            )\n            path = action_shape[\"resource\"].get(\"path\", \"\")\n            if path.endswith(\"[]\"):\n                return_type = TypeSubscript(Type.List, [return_type])\n\n        operation_shape = None\n        if \"request\" in action_shape:\n            operation_name = action_shape[\"request\"][\"operation\"]\n            operation_shape = self._get_operation(operation_name)\n            skip_argument_names = self._get_skip_argument_names(action_shape)\n            if operation_shape.input_shape is not None:\n                shape_arguments = self._parse_arguments(\n                    class_name=self.resource_name,\n                    method_name=method_name,\n                    operation_name=operation_name,\n                    shape=operation_shape.input_shape,\n                    exclude_names=skip_argument_names,\n                )\n                arguments.extend(self._get_kw_flags(method_name, shape_arguments))\n                arguments.extend(shape_arguments)\n\n            self._enrich_arguments_defaults(arguments, action_shape)\n            arguments.sort(key=lambda x: not x.required)\n\n            if operation_shape.output_shape is not None and return_type is Type.none:\n                operation_return_type = self.parse_shape(\n                    operation_shape.output_shape,\n                    is_output=True,\n                )\n                return_type = operation_return_type\n\n        method = Method(name=method_name, arguments=arguments, return_type=return_type)\n        if operation_shape and operation_shape.input_shape is not None:\n            method.create_request_type_annotation(\n                self._get_typed_dict_name(\n                    operation_shape.input_shape,\n                    postfix=f\"{self.resource_name}{action_name}\",\n                ),\n            )\n        return method\n\n    def get_collection_filter_method(\n        self,\n        name: str,\n        collection: Collection,\n        self_type: FakeAnnotation,\n    ) -> Method:\n        \"\"\"\n        Get `filter` classmethod for Resource collection.\n\n        Arguments:\n            name -- Collection record name.\n            collection -- Boto3 Collection.\n            class_type -- Collection class type annotation.\n\n        Returns:\n            Filter Method record.\n        \"\"\"\n        result = Method(\n            name=\"filter\",\n            arguments=[Argument.self()],\n            return_type=self_type,\n        )\n        if not collection.request:\n            return result\n\n        operation_name = collection.request.operation\n        operation_model = self._get_operation(operation_name)\n\n        if operation_model.input_shape is not None:\n            shape_arguments = self._parse_arguments(\n                class_name=name,\n                method_name=result.name,\n                operation_name=operation_name,\n                shape=operation_model.input_shape,\n                optional_only=True,\n            )\n            result.arguments.extend(self._get_kw_flags(result.name, shape_arguments))\n            result.arguments.extend(shape_arguments)\n\n        return result\n\n    def get_collection_batch_methods(self, name: str, collection: Collection) -> list[Method]:\n        \"\"\"\n        Get batch operations for Resource collection.\n\n        Arguments:\n            name -- Collection record name.\n            collection -- Boto3 Collection.\n            class_type -- Collection self type annotation.\n\n        Returns:\n            List of Method records.\n        \"\"\"\n        result: list[Method] = []\n        for batch_action in collection.batch_actions:\n            method = Method(\n                name=batch_action.name,\n                arguments=[Argument.self()],\n                return_type=Type.none,\n            )\n            result.append(method)\n            if batch_action.request:\n                operation_name = batch_action.request.operation\n                operation_model = self._get_operation(operation_name)\n                if operation_model.input_shape is not None:\n                    shape_arguments = self._parse_arguments(\n                        class_name=name,\n                        method_name=batch_action.name,\n                        operation_name=operation_name,\n                        shape=operation_model.input_shape,\n                        optional_only=True,\n                    )\n                    method.arguments.extend(self._get_kw_flags(batch_action.name, shape_arguments))\n                    method.arguments.extend(shape_arguments)\n                if operation_model.output_shape is not None:\n                    item_return_type = self.parse_shape(\n                        operation_model.output_shape,\n                        is_output=True,\n                    )\n                    return_type = TypeSubscript(Type.List, [item_return_type])\n                    method.return_type = return_type\n\n        return result\n\n    @staticmethod\n    def _get_typed_dict_name_prefix(name: str) -> str:\n        if name.endswith(\"OutputTypeDef\"):\n            return name[: -len(\"OutputTypeDef\")]\n        if name.endswith(\"TypeDef\"):\n            return name[: -len(\"TypeDef\")]\n\n        raise ShapeParserError(f\"Unknown typed dict name format: {name}\")\n\n    def _get_typed_dict(\n        self,\n        name: str,\n        maps: Sequence[dict[str, TypeTypedDict]],\n    ) -> TypeTypedDict | None:\n        for typed_dict_map in maps:\n            if name in typed_dict_map:\n                return typed_dict_map[name]\n        return None\n\n    def _get_non_clashing_typed_dict_name(self, typed_dict: TypeTypedDict, postfix: str) -> str:\n        new_typed_dict_name = get_type_def_name(\n            self._get_typed_dict_name_prefix(typed_dict.name),\n            postfix,\n        )\n        clashing_typed_dict = self._get_typed_dict(\n            new_typed_dict_name,\n            (\n                self._typed_dict_map,\n                self._output_typed_dict_map,\n                self._response_typed_dict_map,\n            ),\n        )\n        if not clashing_typed_dict:\n            return new_typed_dict_name\n\n        temp_typed_dict = typed_dict.copy()\n        temp_typed_dict.name = new_typed_dict_name\n        if clashing_typed_dict.is_same(temp_typed_dict):\n            return new_typed_dict_name\n\n        self.logger.debug(f\"Clashing typed dict name found: {new_typed_dict_name}\")\n        return self._get_non_clashing_typed_dict_name(typed_dict, \"Extra\" + postfix)\n\n    def fix_typed_dict_names(self) -> None:\n        \"\"\"\n        Fix typed dict names to avoid duplicates.\n        \"\"\"\n        output_typed_dict_names = self._output_typed_dict_map.get_sorted_names()\n        for name in output_typed_dict_names:\n            typed_dict = self._get_typed_dict(\n                name,\n                (self._typed_dict_map,),\n            )\n            if typed_dict is None:\n                continue\n\n            for output_typed_dict in self._output_typed_dict_map.iterate_by_name(name):\n                if typed_dict.is_same(output_typed_dict):\n                    continue\n\n                old_typed_dict_name = output_typed_dict.name\n                new_typed_dict_name = self._get_non_clashing_typed_dict_name(\n                    output_typed_dict,\n                    \"Output\",\n                )\n                self._fixed_typed_dict_map[typed_dict] = output_typed_dict\n                self.logger.debug(\n                    \"Fixing output TypedDict name clash\"\n                    f\" {old_typed_dict_name} -> {new_typed_dict_name}\",\n                )\n\n                self._output_typed_dict_map.rename(output_typed_dict, new_typed_dict_name)\n\n                if old_typed_dict_name in self._response_typed_dict_map:\n                    del self._response_typed_dict_map[old_typed_dict_name]\n                    self._response_typed_dict_map.add(output_typed_dict)\n\n        response_typed_dict_names = self._response_typed_dict_map.get_sorted_names()\n        for name in response_typed_dict_names:\n            typed_dict = self._get_typed_dict(\n                name,\n                (\n                    self._typed_dict_map,\n                    self._output_typed_dict_map,\n                ),\n            )\n            if typed_dict is None:\n                continue\n\n            for response_typed_dict in self._response_typed_dict_map.iterate_by_name(name):\n                if typed_dict.is_same(response_typed_dict):\n                    continue\n\n                old_typed_dict_name = response_typed_dict.name\n                new_typed_dict_name = self._get_non_clashing_typed_dict_name(\n                    response_typed_dict,\n                    \"Response\",\n                )\n                self.logger.debug(\n                    \"Fixing response TypedDict name clash\"\n                    f\" {old_typed_dict_name} -> {new_typed_dict_name}\",\n                )\n\n                self._response_typed_dict_map.rename(response_typed_dict, new_typed_dict_name)\n\n    @staticmethod\n    def _get_parent_type_annotations(\n        methods: Sequence[Method],\n    ) -> set[TypeParent]:\n        result: set[TypeParent] = set()\n        for method in methods:\n            for argument in method.arguments:\n                if isinstance(argument.type_annotation, TypeParent):\n                    result.add(argument.type_annotation)\n        return result\n\n    def convert_input_arguments_to_unions(self, methods: Sequence[Method]) -> None:\n        \"\"\"\n        Accept both input and output shapes in method arguments.\n\n        mypy does not compare TypedDicts, so we need to accept both input and output shapes.\n        https://github.com/youtype/mypy_boto3_builder/issues/209\n        \"\"\"\n        parent_type_annotations = list(self._get_parent_type_annotations(methods))\n        for input_typed_dict, output_typed_dict in self._fixed_typed_dict_map.items():\n            union_name = self._get_non_clashing_typed_dict_name(input_typed_dict, \"Union\")\n            union_type_annotation = TypeUnion(\n                name=union_name,\n                children=[input_typed_dict, output_typed_dict],\n            )\n            for type_annotation in parent_type_annotations:\n                parents = type_annotation.find_type_annotation_parents(input_typed_dict)\n                for parent in sorted(parents):\n                    if parent is union_type_annotation:\n                        continue\n                    self.logger.debug(\n                        f\"Adding output shape to {parent.render()} type:\"\n                        f\" {input_typed_dict.name} | {output_typed_dict.name}\",\n                    )\n                    parent.replace_child(input_typed_dict, union_type_annotation)\n",
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render(self) -> str:\n        \"\"\"\n        Render attribute to use in function-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f\"{self.name}: {self.get_type_annotation().render()}\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\n    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required\n\n    def mark_as_required(self) -> None:\n        \"\"\"\n        Mark attribute as required.\n        \"\"\"\n        self.required = True\n\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        children: Iterable[TypedDictAttribute] = (),\n        docstring: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether TypedDict usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render TypedDict usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n\n        return self.name\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        template = (\n            Path(\"common/typed_dict_class.py.jinja2\")\n            if self.is_safe_as_class\n            else Path(\"common/typed_dict.py.jinja2\")\n        )\n        return render_jinja2_template(template, {\"type_def\": self})\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return True\n\n    def has_optional(self) -> bool:\n        \"\"\"\n        Whether TypedDict has optional keys.\n        \"\"\"\n        return any(not child.is_required() for child in self.children)\n\n    def has_required(self) -> bool:\n        \"\"\"\n        Whether TypedDict has required keys.\n        \"\"\"\n        return any(child.is_required() for child in self.children)\n\n    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of required attributes.\n        \"\"\"\n        return tuple(child for child in self.children if child.is_required())\n\n    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of optional attributes.\n        \"\"\"\n        return tuple(child for child in self.children if not child.is_required())\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            self.name,\n            list(self.children),\n            docstring=self.docstring,\n            stringify=self.is_stringified(),\n        )\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def get_children_literals(self, processed: Iterable[str] = ()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [\n            child.type_annotation\n            for child in self.children\n            if child.type_annotation.get_local_types()\n        ]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f\"Child not found: {child}\")\n\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n\n        return self\n",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n\n    SELF_NAME: Final = \"self\"\n    CLS_NAME: Final = \"cls\"\n    KW_NAME: Final = \"*\"\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def __init__(\n        self,\n        name: str,\n        type_annotation: FakeAnnotation | None,\n        default: TypeConstant | None = None,\n        prefix: Literal[\"*\", \"**\", \"\"] = \"\",\n    ) -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal[\"*\", \"**\", \"\"] = prefix\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f\" = {self.default.render()}\" if self.default is not None else \"\"\n        if not self.type_annotation:\n            return f\"{self.name}{default_suffix}\"\n\n        return f\"{self.name}: {self.type_annotation.render()}{default_suffix}\"\n\n    @classmethod\n    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)\n\n    @classmethod\n    def kwflag(cls) -> Self:\n        \"\"\"\n        Create `*` keywords separator.\n        \"\"\"\n        return cls(name=cls.KW_NAME, type_annotation=None)\n\n    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == \"*\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(\n            name=self.name,\n            type_annotation=self.type_annotation.copy() if self.type_annotation else None,\n            default=self.default.copy() if self.default else None,\n            prefix=self.prefix,\n        )\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError(\"Literal should have children\")\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = \", \".join([repr(i) for i in sorted(self.children)])\n            return f\"Literal[{children}]\"\n\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation(\"Literal\").get_import_records()\n\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation(\"Literal\").get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError(\"Use add_literal_child function.\")\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path(\"common/literal.py.jinja2\"), {\"literal\": self})\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/parsers/shape_parser.py": {
      "ShapeParser.__init__": {
        "code": "    def __init__(self, session: Session, service_name: ServiceName) -> None:\n        \"\"\"Initializes the ShapeParser class, which is responsible for parsing botocore shape files to generate type annotations for AWS service models.\n\n    Parameters:\n        session (Session): A boto3 Session object that provides context for the AWS service interactions.\n        service_name (ServiceName): An instance of ServiceName that specifies the AWS service to be parsed.\n\n    Attributes:\n        service_name (ServiceName): Stores the service name for later reference.\n        service_model (ServiceModel): Represents the parsed service model data from botocore.\n        _resource_name (str): Internal storage for the resource name, initialized to an empty string.\n        _type_literal_map (dict[str, TypeLiteral]): Maps type literal names to their TypeLiteral definitions.\n        _typed_dict_map (TypedDictMap): Maps defined TypedDicts for service inputs and outputs.\n        _output_typed_dict_map (TypedDictMap): Maps output-specific TypedDicts for service responses.\n        _response_typed_dict_map (TypedDictMap): Maps TypedDicts used specifically for response metadata.\n        _fixed_typed_dict_map (dict[TypeTypedDict, TypeTypedDict]): Holds distinct TypedDicts to avoid naming collisions.\n\n    Side Effects:\n        - Attempts to load waiter, paginator, and resource shape models for the specified service name. If any of these are not found, it silently ignores the exceptions.\n        - Logs messages through the logger obtained from the get_logger() utility function, providing visibility into class operations and state changes.\"\"\"\n        loader = session._loader\n        botocore_session: BotocoreSession = get_botocore_session(session)\n        service_data = botocore_session.get_service_data(service_name.boto3_name)\n        self.service_name = service_name\n        self.service_model = ServiceModel(service_data, service_name.boto3_name)\n        self._resource_name: str = ''\n        self._type_literal_map: dict[str, TypeLiteral] = {}\n        self._typed_dict_map = TypedDictMap()\n        self._output_typed_dict_map = TypedDictMap()\n        self._response_typed_dict_map = TypedDictMap()\n        self._fixed_typed_dict_map: dict[TypeTypedDict, TypeTypedDict] = {}\n        self._waiters_shape: WaitersShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._waiters_shape = loader.load_service_model(service_name.boto3_name, 'waiters-2')\n        self._paginators_shape: PaginatorsShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._paginators_shape = loader.load_service_model(service_name.boto3_name, 'paginators-1')\n        self._resources_shape: ResourcesShape | None = None\n        with contextlib.suppress(UnknownServiceError):\n            self._resources_shape = loader.load_service_model(service_name.boto3_name, 'resources-1')\n        self.logger = get_logger()",
        "docstring": "Initializes the ShapeParser class, which is responsible for parsing botocore shape files to generate type annotations for AWS service models.\n\nParameters:\n    session (Session): A boto3 Session object that provides context for the AWS service interactions.\n    service_name (ServiceName): An instance of ServiceName that specifies the AWS service to be parsed.\n\nAttributes:\n    service_name (ServiceName): Stores the service name for later reference.\n    service_model (ServiceModel): Represents the parsed service model data from botocore.\n    _resource_name (str): Internal storage for the resource name, initialized to an empty string.\n    _type_literal_map (dict[str, TypeLiteral]): Maps type literal names to their TypeLiteral definitions.\n    _typed_dict_map (TypedDictMap): Maps defined TypedDicts for service inputs and outputs.\n    _output_typed_dict_map (TypedDictMap): Maps output-specific TypedDicts for service responses.\n    _response_typed_dict_map (TypedDictMap): Maps TypedDicts used specifically for response metadata.\n    _fixed_typed_dict_map (dict[TypeTypedDict, TypeTypedDict]): Holds distinct TypedDicts to avoid naming collisions.\n\nSide Effects:\n    - Attempts to load waiter, paginator, and resource shape models for the specified service name. If any of these are not found, it silently ignores the exceptions.\n    - Logs messages through the logger obtained from the get_logger() utility function, providing visibility into class operations and state changes.",
        "signature": "def __init__(self, session: Session, service_name: ServiceName) -> None:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.get_paginator_names": {
        "code": "    def get_paginator_names(self) -> list[str]:\n        \"\"\"Retrieve a sorted list of paginator names available for the service.\n\nThis method accesses the paginators shape stored in the instance, which is initialized during the \nclass's instantiation. If the paginators shape is not present or doesn't contain any pagination \ninformation, an empty list is returned.\n\nReturns:\n    A sorted list of paginator names if available, otherwise an empty list.\n\nDependencies:\n    - `self._paginators_shape`: This attribute is set during the initialization of the class \n      and is loaded from the service model data. It contains the pagination configurations \n      for the service, allowing this method to extract and return the paginator names.\"\"\"\n        '\\n        Get available paginator names.\\n\\n        Returns:\\n            A list of paginator names.\\n        '\n        if not self._paginators_shape or not self._paginators_shape.get('pagination'):\n            return []\n        result = list(self._paginators_shape['pagination'])\n        result.sort()\n        return result",
        "docstring": "Retrieve a sorted list of paginator names available for the service.\n\nThis method accesses the paginators shape stored in the instance, which is initialized during the \nclass's instantiation. If the paginators shape is not present or doesn't contain any pagination \ninformation, an empty list is returned.\n\nReturns:\n    A sorted list of paginator names if available, otherwise an empty list.\n\nDependencies:\n    - `self._paginators_shape`: This attribute is set during the initialization of the class \n      and is loaded from the service model data. It contains the pagination configurations \n      for the service, allowing this method to extract and return the paginator names.",
        "signature": "def get_paginator_names(self) -> list[str]:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.get_client_method_map": {
        "code": "    def get_client_method_map(self) -> dict[str, Method]:\n        \"\"\"Get client methods based on the shape of the service model.\n\nThis method constructs a dictionary mapping method names to `Method` instances representing client methods available for the specified service. It includes methods such as \"can_paginate\", \"generate_presigned_url\", and \"close\", which are predefined, and dynamically generates methods for all defined operations in the service model. Each method includes relevant arguments parsed from the operation's input shape and determines the return type based on the operation's output shape.\n\nReturns:\n    A dictionary where keys are method names and values are `Method` instances that encapsulate method details.\n\nConstants:\n    CLIENT: This constant identifies the resource name as \"client\" within the method. It is defined in the module `mypy_boto3_builder.constants` and signifies that the methods generated are associated with the client interface of the AWS service.\"\"\"\n        '\\n        Get client methods from shape.\\n\\n        Returns:\\n            A map of method name to Method.\\n        '\n        self._resource_name = CLIENT\n        result: dict[str, Method] = {'can_paginate': Method(name='can_paginate', arguments=(Argument.self(), Argument('operation_name', Type.str)), return_type=Type.bool), 'generate_presigned_url': Method(name='generate_presigned_url', arguments=(Argument.self(), Argument('ClientMethod', Type.str), Argument('Params', Type.MappingStrAny, Type.Ellipsis), Argument('ExpiresIn', Type.int, TypeConstant(3600)), Argument('HttpMethod', Type.str, Type.Ellipsis)), return_type=Type.str), 'close': Method(name='close', arguments=(Argument.self(),), return_type=Type.none)}\n        for operation_name in self.service_model.operation_names:\n            operation_model = self._get_operation(operation_name)\n            arguments: list[Argument] = [Argument.self()]\n            method_name = xform_name(operation_name)\n            if operation_model.input_shape is not None:\n                shape_arguments = self._parse_arguments(class_name=self._resource_name, method_name=method_name, operation_name=operation_name, shape=operation_model.input_shape)\n                arguments.extend(self._get_kw_flags(method_name, shape_arguments))\n                arguments.extend(shape_arguments)\n            return_type = self._parse_return_type(self._resource_name, method_name, operation_model.output_shape)\n            if return_type is Type.none:\n                return_type = EmptyResponseMetadataTypeDef\n            method = Method(name=method_name, arguments=arguments, return_type=return_type)\n            if operation_model.input_shape:\n                method.create_request_type_annotation(self._get_typed_dict_name(operation_model.input_shape, postfix='Request'))\n            result[method.name] = method\n        return result",
        "docstring": "Get client methods based on the shape of the service model.\n\nThis method constructs a dictionary mapping method names to `Method` instances representing client methods available for the specified service. It includes methods such as \"can_paginate\", \"generate_presigned_url\", and \"close\", which are predefined, and dynamically generates methods for all defined operations in the service model. Each method includes relevant arguments parsed from the operation's input shape and determines the return type based on the operation's output shape.\n\nReturns:\n    A dictionary where keys are method names and values are `Method` instances that encapsulate method details.\n\nConstants:\n    CLIENT: This constant identifies the resource name as \"client\" within the method. It is defined in the module `mypy_boto3_builder.constants` and signifies that the methods generated are associated with the client interface of the AWS service.",
        "signature": "def get_client_method_map(self) -> dict[str, Method]:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser._get_literal_name": {
        "code": "    def _get_literal_name(shape: StringShape) -> str:\n        \"\"\"Generate the literal type name for a given StringShape.\n\nArgs:\n    shape (StringShape): An instance of StringShape which represents the shape of a string type, potentially containing an enumeration (`enum`).\n\nReturns:\n    str: A capitalized string representing the type name derived from the shape's name. If the shape name is \"__string\", the method combines and capitalizes the names of the enum members to form the literal type name, appending \"Type\" at the end. Otherwise, it simply capitalizes the shape name, removing any leading underscores and appending \"Type\".\n\nNotes:\n    The method relies on the `capitalize` function to format the string correctly. The function is associated with ensuring type safety when using botocore shapes in contexts where enumeration values are involved.\"\"\"\n        if shape.name == '__string':\n            children_name = ''.join(sorted((capitalize(i) for i in shape.enum)))\n            return f'{children_name}Type'\n        name = capitalize(shape.name.lstrip('_'))\n        return f'{name}Type'",
        "docstring": "Generate the literal type name for a given StringShape.\n\nArgs:\n    shape (StringShape): An instance of StringShape which represents the shape of a string type, potentially containing an enumeration (`enum`).\n\nReturns:\n    str: A capitalized string representing the type name derived from the shape's name. If the shape name is \"__string\", the method combines and capitalizes the names of the enum members to form the literal type name, appending \"Type\" at the end. Otherwise, it simply capitalizes the shape name, removing any leading underscores and appending \"Type\".\n\nNotes:\n    The method relies on the `capitalize` function to format the string correctly. The function is associated with ensuring type safety when using botocore shapes in contexts where enumeration values are involved.",
        "signature": "def _get_literal_name(shape: StringShape) -> str:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser._parse_shape_string": {
        "code": "    def _parse_shape_string(self, shape: StringShape) -> FakeAnnotation:\n        \"\"\"Parse a botocore StringShape and convert it into a corresponding FakeAnnotation.\n\nParameters:\n    shape (StringShape): The StringShape to parse, which may include an enum attribute representing possible string values.\n\nReturns:\n    FakeAnnotation: A TypeLiteral if the shape has an enum, representing the valid string literals; otherwise, it returns a generic string type (Type.str).\n\nRaises:\n    ShapeParserError: If a literal name derived from the enum already exists in the type literal map with different values.\n\nThis method interacts with constants and functions such as `get_type_literal_stub`, which retrieves type litteral definitions based on the service name and the literal name, and `self._get_literal_name`, which generates a standardized name for the type literal based on the shape's enum. The method also utilizes `self._type_literal_map` to track previously defined type literals for duplicates.\"\"\"\n        if shape.enum:\n            literal_name = self._get_literal_name(shape)\n            type_literal_stub = get_type_literal_stub(self.service_name, literal_name)\n            type_literal = type_literal_stub or TypeLiteral(literal_name, set(shape.enum))\n            if literal_name in self._type_literal_map:\n                old_type_literal = self._type_literal_map[literal_name]\n                if not type_literal.is_same(old_type_literal):\n                    raise ShapeParserError(f'Literal {literal_name} has different values: {old_type_literal.children} vs {type_literal.children}')\n                return old_type_literal\n            self._type_literal_map[literal_name] = type_literal\n            return type_literal\n        return Type.str",
        "docstring": "Parse a botocore StringShape and convert it into a corresponding FakeAnnotation.\n\nParameters:\n    shape (StringShape): The StringShape to parse, which may include an enum attribute representing possible string values.\n\nReturns:\n    FakeAnnotation: A TypeLiteral if the shape has an enum, representing the valid string literals; otherwise, it returns a generic string type (Type.str).\n\nRaises:\n    ShapeParserError: If a literal name derived from the enum already exists in the type literal map with different values.\n\nThis method interacts with constants and functions such as `get_type_literal_stub`, which retrieves type litteral definitions based on the service name and the literal name, and `self._get_literal_name`, which generates a standardized name for the type literal based on the shape's enum. The method also utilizes `self._type_literal_map` to track previously defined type literals for duplicates.",
        "signature": "def _parse_shape_string(self, shape: StringShape) -> FakeAnnotation:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.get_paginate_method": {
        "code": "    def get_paginate_method(self, paginator_name: str) -> Method:\n        \"\"\"Get the Paginator `paginate` method based on the specified paginator name.\n\nArguments:\n    paginator_name -- The name of the paginator to retrieve.\n\nReturns:\n    Method: An instance of the Method class representing the `paginate` method.\n\nThis method constructs a `paginate` method for a specified paginator by retrieving its shape and corresponding operation details. It constructs required arguments for the `paginate` method while excluding any identifiers specified in the paginator's input token. The return type of the method is a paginated item wrapped in a subscripted type. If the operation has input shapes, they are parsed into corresponding arguments, appended with a `PaginationConfig` argument.\n\nThe method utilizes constants and types such as `PaginatorConfigTypeDef` and `TypeSubscript`, which define type annotations for pagination configurations and the expected return type structure. Additionally, it interacts with class methods like `_get_paginator` to fetch paginator shape details and `_get_operation` to retrieve operation models.\"\"\"\n        '\\n        Get Paginator `paginate` method.\\n\\n        Arguments:\\n            paginator_name -- Paginator name.\\n\\n        Returns:\\n            Method.\\n        '\n        self._resource_name = 'Paginator'\n        operation_name = paginator_name\n        paginator_shape = self._get_paginator(paginator_name)\n        operation_shape = self._get_operation(operation_name)\n        skip_argument_names: list[str] = []\n        input_token: list[str] | str = paginator_shape['input_token']\n        if isinstance(input_token, list):\n            skip_argument_names.extend(input_token)\n        else:\n            skip_argument_names.append(input_token)\n        if 'limit_key' in paginator_shape:\n            skip_argument_names.append(paginator_shape['limit_key'])\n        arguments: list[Argument] = [Argument.self()]\n        if operation_shape.input_shape is not None:\n            shape_arguments = self._parse_arguments(class_name='Paginator', method_name='paginate', operation_name=operation_name, shape=operation_shape.input_shape, exclude_names=skip_argument_names)\n            shape_arguments.append(Argument('PaginationConfig', PaginatorConfigTypeDef, Type.Ellipsis))\n            arguments.extend(self._get_kw_flags('paginate', shape_arguments))\n            arguments.extend(shape_arguments)\n        return_type: FakeAnnotation = Type.none\n        if operation_shape.output_shape is not None:\n            page_iterator_import = InternalImport('_PageIterator', stringify=False)\n            return_item = self._parse_return_type('Paginator', 'paginate', operation_shape.output_shape)\n            return_type = TypeSubscript(page_iterator_import, [return_item])\n        method = Method(name='paginate', arguments=arguments, return_type=return_type)\n        if operation_shape.input_shape is not None:\n            method.create_request_type_annotation(self._get_typed_dict_name(operation_shape.input_shape, postfix=f'{paginator_name}Paginate'))\n        return method",
        "docstring": "Get the Paginator `paginate` method based on the specified paginator name.\n\nArguments:\n    paginator_name -- The name of the paginator to retrieve.\n\nReturns:\n    Method: An instance of the Method class representing the `paginate` method.\n\nThis method constructs a `paginate` method for a specified paginator by retrieving its shape and corresponding operation details. It constructs required arguments for the `paginate` method while excluding any identifiers specified in the paginator's input token. The return type of the method is a paginated item wrapped in a subscripted type. If the operation has input shapes, they are parsed into corresponding arguments, appended with a `PaginationConfig` argument.\n\nThe method utilizes constants and types such as `PaginatorConfigTypeDef` and `TypeSubscript`, which define type annotations for pagination configurations and the expected return type structure. Additionally, it interacts with class methods like `_get_paginator` to fetch paginator shape details and `_get_operation` to retrieve operation models.",
        "signature": "def get_paginate_method(self, paginator_name: str) -> Method:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.get_resource_method_map": {
        "code": "    def get_resource_method_map(self, resource_name: str) -> dict[str, Method]:\n        \"\"\"Get methods for a specified AWS resource, including actions, waiters, and subresources.\n\nArgs:\n    resource_name (str): The name of the resource for which to retrieve the methods.\n\nReturns:\n    dict[str, Method]: A mapping of method names to Method instances associated with the specified resource.\n\nThe method interacts with the resource shape obtained through `self._get_resource_shape`, which extracts information about available actions, waiters, and subresources. The method initializes with standard operations such as `get_available_subresources`, `load`, and `reload`, and dynamically adds any actions defined in the resource shape. If subresources are present, it generates methods for each, utilizing identifiers defined in the resource shape's structure. Constants such as `InternalImport` are used to define return types for subresource methods based on the resource structure.\"\"\"\n        '\\n        Get methods for Resource.\\n\\n        Arguments:\\n            resource_name -- Resource name.\\n\\n        Returns:\\n            A map of method name to Method.\\n        '\n        self._resource_name = resource_name\n        resource_shape = self._get_resource_shape(resource_name)\n        result: dict[str, Method] = {'get_available_subresources': Method(name='get_available_subresources', arguments=[Argument.self()], return_type=TypeSubscript(Type.Sequence, [Type.str])), 'load': Method(name='load', arguments=[Argument.self()], return_type=Type.none), 'reload': Method(name='reload', arguments=[Argument.self()], return_type=Type.none)}\n        if 'actions' in resource_shape:\n            for action_name, action_shape in resource_shape['actions'].items():\n                method = self._get_resource_method(action_name, action_shape)\n                result[method.name] = method\n        if 'waiters' in resource_shape:\n            for waiter_name in resource_shape['waiters']:\n                method = Method(name=f'wait_until_{xform_name(waiter_name)}', arguments=[Argument.self()], return_type=Type.none)\n                result[method.name] = method\n        if 'has' in resource_shape:\n            for sub_resource_name, sub_resource in resource_shape['has'].items():\n                if 'resource' not in sub_resource:\n                    continue\n                data = sub_resource['resource']\n                arguments = [Argument.self()]\n                identifiers = data.get('identifiers', [])\n                for identifier in identifiers:\n                    if identifier.get('source') != 'input':\n                        continue\n                    argument = self._get_identifier_argument(resource_name, sub_resource_name, identifier)\n                    arguments.append(argument)\n                method = Method(name=sub_resource_name, arguments=arguments, return_type=InternalImport(data['type'], use_alias=True))\n                result[method.name] = method\n        return result",
        "docstring": "Get methods for a specified AWS resource, including actions, waiters, and subresources.\n\nArgs:\n    resource_name (str): The name of the resource for which to retrieve the methods.\n\nReturns:\n    dict[str, Method]: A mapping of method names to Method instances associated with the specified resource.\n\nThe method interacts with the resource shape obtained through `self._get_resource_shape`, which extracts information about available actions, waiters, and subresources. The method initializes with standard operations such as `get_available_subresources`, `load`, and `reload`, and dynamically adds any actions defined in the resource shape. If subresources are present, it generates methods for each, utilizing identifiers defined in the resource shape's structure. Constants such as `InternalImport` are used to define return types for subresource methods based on the resource structure.",
        "signature": "def get_resource_method_map(self, resource_name: str) -> dict[str, Method]:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.get_collection_filter_method": {
        "code": "    def get_collection_filter_method(self, name: str, collection: Collection, self_type: FakeAnnotation) -> Method:\n        \"\"\"Generate a `filter` classmethod for a Boto3 Collection resource.\n\n    This method constructs a filter method that allows users to filter items in a collection\n    based on specific parameters. It retrieves the operation model for the corresponding request\n    and parses the input arguments required for the operation, adding them to the filter method.\n\n    Parameters:\n        name (str): The name of the collection record.\n        collection (Collection): A Boto3 Collection object representing the resource collection.\n        self_type (FakeAnnotation): The type annotation for the collection's instance.\n\n    Returns:\n        Method: A Method instance representing the filter method with parsed arguments.\n\n    Notes:\n        If the collection does not define a request, the method returns a filter method\n        with only the \"self\" argument. The `operation_name` is extracted from the collection's\n        request, and if the operation model has an input shape, the arguments are parsed \n        accordingly using the `_parse_arguments` method.\"\"\"\n        '\\n        Get `filter` classmethod for Resource collection.\\n\\n        Arguments:\\n            name -- Collection record name.\\n            collection -- Boto3 Collection.\\n            class_type -- Collection class type annotation.\\n\\n        Returns:\\n            Filter Method record.\\n        '\n        result = Method(name='filter', arguments=[Argument.self()], return_type=self_type)\n        if not collection.request:\n            return result\n        operation_name = collection.request.operation\n        operation_model = self._get_operation(operation_name)\n        if operation_model.input_shape is not None:\n            shape_arguments = self._parse_arguments(class_name=name, method_name=result.name, operation_name=operation_name, shape=operation_model.input_shape, optional_only=True)\n            result.arguments.extend(self._get_kw_flags(result.name, shape_arguments))\n            result.arguments.extend(shape_arguments)\n        return result",
        "docstring": "Generate a `filter` classmethod for a Boto3 Collection resource.\n\nThis method constructs a filter method that allows users to filter items in a collection\nbased on specific parameters. It retrieves the operation model for the corresponding request\nand parses the input arguments required for the operation, adding them to the filter method.\n\nParameters:\n    name (str): The name of the collection record.\n    collection (Collection): A Boto3 Collection object representing the resource collection.\n    self_type (FakeAnnotation): The type annotation for the collection's instance.\n\nReturns:\n    Method: A Method instance representing the filter method with parsed arguments.\n\nNotes:\n    If the collection does not define a request, the method returns a filter method\n    with only the \"self\" argument. The `operation_name` is extracted from the collection's\n    request, and if the operation model has an input shape, the arguments are parsed \n    accordingly using the `_parse_arguments` method.",
        "signature": "def get_collection_filter_method(self, name: str, collection: Collection, self_type: FakeAnnotation) -> Method:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      },
      "ShapeParser.fix_typed_dict_names": {
        "code": "    def fix_typed_dict_names(self) -> None:\n        \"\"\"Fixes TypedDict names to avoid duplicates in the mapped typed dictionaries. \n\nThe method first retrieves sorted names from the output typed dictionary map, checking for potential name clashes between output TypedDicts and pre-existing Type mappings. When a conflict is detected, it renames the output TypedDict to a non-clashing name using the `_get_non_clashing_typed_dict_name` method, which ensures unique naming by appending a postfix. Conflicting TypedDicts are tracked in the `_fixed_typed_dict_map` for further processing. Also, any previously existing response TypedDicts with the old name are removed and re-added with the new name.\n\nAdditionally, it interacts with the following attributes of the class:\n- `_output_typed_dict_map`: A map holding output TypedDict definitions.\n- `_typed_dict_map`: A map holding the regular TypedDict definitions.\n- `_response_typed_dict_map`: A map holding response-specific TypedDict definitions.\n- `_fixed_typed_dict_map`: A dictionary that maintains a record of renamed TypedDicts to ensure proper references.\n\nThis method modifies the state of the involved TypedDict maps but does not return any value.\"\"\"\n        '\\n        Fix typed dict names to avoid duplicates.\\n        '\n        output_typed_dict_names = self._output_typed_dict_map.get_sorted_names()\n        for name in output_typed_dict_names:\n            typed_dict = self._get_typed_dict(name, (self._typed_dict_map,))\n            if typed_dict is None:\n                continue\n            for output_typed_dict in self._output_typed_dict_map.iterate_by_name(name):\n                if typed_dict.is_same(output_typed_dict):\n                    continue\n                old_typed_dict_name = output_typed_dict.name\n                new_typed_dict_name = self._get_non_clashing_typed_dict_name(output_typed_dict, 'Output')\n                self._fixed_typed_dict_map[typed_dict] = output_typed_dict\n                self.logger.debug(f'Fixing output TypedDict name clash {old_typed_dict_name} -> {new_typed_dict_name}')\n                self._output_typed_dict_map.rename(output_typed_dict, new_typed_dict_name)\n                if old_typed_dict_name in self._response_typed_dict_map:\n                    del self._response_typed_dict_map[old_typed_dict_name]\n                    self._response_typed_dict_map.add(output_typed_dict)\n        response_typed_dict_names = self._response_typed_dict_map.get_sorted_names()\n        for name in response_typed_dict_names:\n            typed_dict = self._get_typed_dict(name, (self._typed_dict_map, self._output_typed_dict_map))\n            if typed_dict is None:\n                continue\n            for response_typed_dict in self._response_typed_dict_map.iterate_by_name(name):\n                if typed_dict.is_same(response_typed_dict):\n                    continue\n                old_typed_dict_name = response_typed_dict.name\n                new_typed_dict_name = self._get_non_clashing_typed_dict_name(response_typed_dict, 'Response')\n                self.logger.debug(f'Fixing response TypedDict name clash {old_typed_dict_name} -> {new_typed_dict_name}')\n                self._response_typed_dict_map.rename(response_typed_dict, new_typed_dict_name)",
        "docstring": "Fixes TypedDict names to avoid duplicates in the mapped typed dictionaries. \n\nThe method first retrieves sorted names from the output typed dictionary map, checking for potential name clashes between output TypedDicts and pre-existing Type mappings. When a conflict is detected, it renames the output TypedDict to a non-clashing name using the `_get_non_clashing_typed_dict_name` method, which ensures unique naming by appending a postfix. Conflicting TypedDicts are tracked in the `_fixed_typed_dict_map` for further processing. Also, any previously existing response TypedDicts with the old name are removed and re-added with the new name.\n\nAdditionally, it interacts with the following attributes of the class:\n- `_output_typed_dict_map`: A map holding output TypedDict definitions.\n- `_typed_dict_map`: A map holding the regular TypedDict definitions.\n- `_response_typed_dict_map`: A map holding response-specific TypedDict definitions.\n- `_fixed_typed_dict_map`: A dictionary that maintains a record of renamed TypedDicts to ensure proper references.\n\nThis method modifies the state of the involved TypedDict maps but does not return any value.",
        "signature": "def fix_typed_dict_names(self) -> None:",
        "type": "Method",
        "class_signature": "class ShapeParser:"
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
      "TypedDictAttribute.__init__": {
        "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"Initializes a TypedDictAttribute instance, which acts as a wrapper for attributes of a TypedDict.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation for the attribute, expected to be an instance of FakeAnnotation, which is defined elsewhere in the code and used to represent various type annotations.\n- required (bool): Indicates whether the attribute is mandatory (True) or optional (False).\n\nReturns:\nNone. The initialization sets up the instance with the given properties.\n\nThis constructor interacts with the type annotation system, allowing attributes to be defined in TypedDict classes. The 'type_annotation' parameter is particularly significant as it determines how the attribute is treated and enforced in type checks.\"\"\"\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation",
        "docstring": "Initializes a TypedDictAttribute instance, which acts as a wrapper for attributes of a TypedDict.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation for the attribute, expected to be an instance of FakeAnnotation, which is defined elsewhere in the code and used to represent various type annotations.\n- required (bool): Indicates whether the attribute is mandatory (True) or optional (False).\n\nReturns:\nNone. The initialization sets up the instance with the given properties.\n\nThis constructor interacts with the type annotation system, allowing attributes to be defined in TypedDict classes. The 'type_annotation' parameter is particularly significant as it determines how the attribute is treated and enforced in type checks.",
        "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypeTypedDict.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n        \"\"\"Initialize a TypeTypedDict instance, which wraps type annotations for TypedDicts.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute]): An optional collection of TypedDictAttribute instances representing the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str): An optional docstring that describes the purpose of the TypedDict.\n- stringify (bool): An optional flag that indicates whether the TypedDict usage should be rendered as a string. Defaults to False.\n\nThis constructor initializes the attributes of the TypeTypedDict instance, including the name, attributes (children), docstring, and stringify flag. The 'children' parameter is converted into a list for internal management. The 'is_safe_as_class' attribute is set to True, indicating that this TypedDict can be safely used as a class. This class interacts closely with various types of annotations and helpers, such as TypedDictAttribute, which defines individual attributes for the TypedDict.\"\"\"\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True",
        "docstring": "Initialize a TypeTypedDict instance, which wraps type annotations for TypedDicts.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute]): An optional collection of TypedDictAttribute instances representing the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str): An optional docstring that describes the purpose of the TypedDict.\n- stringify (bool): An optional flag that indicates whether the TypedDict usage should be rendered as a string. Defaults to False.\n\nThis constructor initializes the attributes of the TypeTypedDict instance, including the name, attributes (children), docstring, and stringify flag. The 'children' parameter is converted into a list for internal management. The 'is_safe_as_class' attribute is set to True, indicating that this TypedDict can be safely used as a class. This class interacts closely with various types of annotations and helpers, such as TypedDictAttribute, which defines individual attributes for the TypedDict.",
        "signature": "def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.has_optional": {
        "code": "    def has_optional(self) -> bool:\n        \"\"\"Checks if the TypedDict instance contains any optional keys. An optional key is defined as an attribute whose requirement status is not marked as required. This method iterates through the `children` attributes of the TypedDict, each represented by a `TypedDictAttribute` instance, which holds the required status of each attribute. If at least one child attribute is not required, the method returns True; otherwise, it returns False.\"\"\"\n        '\\n        Whether TypedDict has optional keys.\\n        '\n        return any((not child.is_required() for child in self.children))",
        "docstring": "Checks if the TypedDict instance contains any optional keys. An optional key is defined as an attribute whose requirement status is not marked as required. This method iterates through the `children` attributes of the TypedDict, each represented by a `TypedDictAttribute` instance, which holds the required status of each attribute. If at least one child attribute is not required, the method returns True; otherwise, it returns False.",
        "signature": "def has_optional(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      }
    },
    "mypy_boto3_builder/structures/argument.py": {
      "Argument.is_kwflag": {
        "code": "    def is_kwflag(self) -> bool:\n        \"\"\"Determine if the argument is a keyword flag separator.\n\nThis method checks whether the `name` attribute of the `Argument` instance is equal to the string `*`. The `*` serves as a keyword flag separator in Python function definitions, indicating that subsequent parameters must be specified as keyword arguments. \n\nReturns:\n    bool: True if the argument is a `*` keywords separator, otherwise False.\"\"\"\n        '\\n        Whether argument is a `*` keywords separator.\\n        '\n        return self.name == '*'",
        "docstring": "Determine if the argument is a keyword flag separator.\n\nThis method checks whether the `name` attribute of the `Argument` instance is equal to the string `*`. The `*` serves as a keyword flag separator in Python function definitions, indicating that subsequent parameters must be specified as keyword arguments. \n\nReturns:\n    bool: True if the argument is a `*` keywords separator, otherwise False.",
        "signature": "def is_kwflag(self) -> bool:",
        "type": "Method",
        "class_signature": "class Argument:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get the local name for the imported type annotation.\n\nThis method retrieves the local name associated with the import record, which is created in the `import_record` property. The local name can be used when referencing the type annotation in code. The method does not take any parameters and interacts with the `ImportRecord` class to obtain the local name through its `get_local_name()` method.\n\nReturns:\n    str: The local name of the import record.\"\"\"\n        '\\n        Get string with local name to use.\\n\\n        Returns:\\n            Import record local name.\\n        '\n        return self.import_record.get_local_name()",
        "docstring": "Get the local name for the imported type annotation.\n\nThis method retrieves the local name associated with the import record, which is created in the `import_record` property. The local name can be used when referencing the type annotation in code. The method does not take any parameters and interacts with the `ImportRecord` class to obtain the local name through its `get_local_name()` method.\n\nReturns:\n    str: The local name of the import record.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_literal.py": {
      "TypeLiteral.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render a type annotation to valid Python code for local usage.\n\nThis method generates a string representation of the type annotation based on the `children` of the `TypeLiteral` instance. If the `children` contains only one element (determined by the `inline` property), it returns an inline `Literal` format. Otherwise, it returns the name of the `TypeLiteral`. The method requires that `children` be a non-empty set of literal values initialized in the constructor.\n\nReturns:\n    str: A string containing a valid type annotation, either in inline `Literal[...]` format or just the name of the `TypeLiteral`.\n\nDependencies:\n- The `inline` property is used to decide the rendering format.\n- The `children` attribute represents the literal values and must be initialized in the constructor.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if self.inline:\n            children = ', '.join([repr(i) for i in sorted(self.children)])\n            return f'Literal[{children}]'\n        return self.name",
        "docstring": "Render a type annotation to valid Python code for local usage.\n\nThis method generates a string representation of the type annotation based on the `children` of the `TypeLiteral` instance. If the `children` contains only one element (determined by the `inline` property), it returns an inline `Literal` format. Otherwise, it returns the name of the `TypeLiteral`. The method requires that `children` be a non-empty set of literal values initialized in the constructor.\n\nReturns:\n    str: A string containing a valid type annotation, either in inline `Literal[...]` format or just the name of the `TypeLiteral`.\n\nDependencies:\n- The `inline` property is used to decide the rendering format.\n- The `children` attribute represents the literal values and must be initialized in the constructor.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeLiteral(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
      "mypy_boto3_builder/utils/boto3_utils.py": {
        "get_botocore_session": {
          "code": "def get_botocore_session(session: Session) -> BotocoreSession:\n    \"\"\"\n    Get botocore session from boto3 session.\n    \"\"\"\n    return session._session  # type: ignore",
          "docstring": "Get botocore session from boto3 session.",
          "signature": "def get_botocore_session(session: Session) -> BotocoreSession:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/service_name.py": {
        "ServiceName.boto3_name": {
          "code": "    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name",
          "docstring": "Boto3 package name.",
          "signature": "def boto3_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ServiceName:"
        }
      },
      "mypy_boto3_builder/logger.py": {
        "get_logger": {
          "code": "def get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger",
          "docstring": "Get Logger instance.\n\nArguments:\n    level -- Log level.\n\nReturns:\n    Overriden Logger.",
          "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_client_method_map": {
      "mypy_boto3_builder/parsers/shape_parser.py": {
        "ShapeParser._get_operation": {
          "code": "    def _get_operation(self, name: str) -> OperationModel:\n        return self.service_model.operation_model(name)",
          "docstring": "",
          "signature": "def _get_operation(self, name: str) -> OperationModel:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._parse_arguments": {
          "code": "    def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:\n        result: list[Argument] = []\n        required = shape.required_members\n        for argument_name, argument_shape in shape.members.items():\n            if argument_name in exclude_names:\n                continue\n            argument_alias = get_argument_alias(self.service_name, operation_name, argument_name)\n            if argument_alias is None:\n                continue\n            argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, argument_name)\n            if argument_type_stub is Type.RemoveArgument:\n                continue\n            if argument_type_stub is not None:\n                argument_type = argument_type_stub\n            else:\n                argument_type = self.parse_shape(argument_shape)\n            argument = Argument(argument_alias, argument_type)\n            if argument_name not in required:\n                argument.default = Type.Ellipsis\n            default_value_stub = get_default_value_stub(self.service_name, class_name, method_name, argument_name)\n            if default_value_stub is not None:\n                argument.default = default_value_stub\n            if optional_only and argument.required:\n                continue\n            result.append(argument)\n        result.sort(key=lambda x: not x.required)\n        return result",
          "docstring": "",
          "signature": "def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._parse_return_type": {
          "code": "    def _parse_return_type(self, class_name: str, method_name: str, shape: Shape | None) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, 'return')\n        if argument_type_stub is not None:\n            return argument_type_stub\n        if shape:\n            return self.parse_shape(shape, is_output=True)\n        return Type.none",
          "docstring": "",
          "signature": "def _parse_return_type(self, class_name: str, method_name: str, shape: Shape | None) -> FakeAnnotation:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_kw_flags": {
          "code": "    def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:\n        if len(arguments) and (not method_name[0].isupper()):\n            return [Argument.kwflag()]\n        return []",
          "docstring": "",
          "signature": "def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_typed_dict_name": {
          "code": "    def _get_typed_dict_name(shape: Shape, postfix: str='') -> str:\n        return get_type_def_name(shape.name, postfix)",
          "docstring": "",
          "signature": "def _get_typed_dict_name(shape: Shape, postfix: str='') -> str:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.__init__": {
          "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal['*', '**', ''] = prefix",
          "docstring": "",
          "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:",
          "type": "Method",
          "class_signature": "class Argument:"
        },
        "Argument.self": {
          "code": "    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
          "docstring": "Create `self` argument.",
          "signature": "def self(cls) -> Self:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
          "docstring": "",
          "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        },
        "Function.create_request_type_annotation": {
          "code": "    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"\n        Create and set `request_type_annotation` TypedDict based on function arguments.\n        \"\"\"\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(\n                argument.name,\n                argument.type_annotation,\n                required=argument.required,\n            )\n\n        if not result.children:\n            return\n        self.request_type_annotation = result",
          "docstring": "Create and set `request_type_annotation` TypedDict based on function arguments.",
          "signature": "def create_request_type_annotation(self, name: str) -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/type_annotations/type_constant.py": {
        "TypeConstant.__init__": {
          "code": "    def __init__(self, value: ValueType) -> None:\n        self.value: ValueType = value",
          "docstring": "",
          "signature": "def __init__(self, value: ValueType) -> None:",
          "type": "Method",
          "class_signature": "class TypeConstant(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/utils/strings.py": {
        "xform_name": {
          "code": "def xform_name(name: str, sep: str = \"_\") -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError(\"Separator is required\")\n    return botocore_xform_name(name, sep)",
          "docstring": "Convert name to snake_case.\n\nArguments:\n    name -- Any string.\n    sep -- Separator.",
          "signature": "def xform_name(name: str, sep: str='_') -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_paginate_method": {
      "mypy_boto3_builder/parsers/shape_parser.py": {
        "ShapeParser._get_operation": {
          "code": "    def _get_operation(self, name: str) -> OperationModel:\n        return self.service_model.operation_model(name)",
          "docstring": "",
          "signature": "def _get_operation(self, name: str) -> OperationModel:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_paginator": {
          "code": "    def _get_paginator(self, name: str) -> PaginatorShape:\n        if not self._paginators_shape:\n            raise ShapeParserError(f'Unknown paginator: {name}')\n        try:\n            return self._paginators_shape['pagination'][name]\n        except KeyError as e:\n            raise ShapeParserError(f'Unknown paginator: {name}') from e",
          "docstring": "",
          "signature": "def _get_paginator(self, name: str) -> PaginatorShape:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._parse_arguments": {
          "code": "    def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:\n        result: list[Argument] = []\n        required = shape.required_members\n        for argument_name, argument_shape in shape.members.items():\n            if argument_name in exclude_names:\n                continue\n            argument_alias = get_argument_alias(self.service_name, operation_name, argument_name)\n            if argument_alias is None:\n                continue\n            argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, argument_name)\n            if argument_type_stub is Type.RemoveArgument:\n                continue\n            if argument_type_stub is not None:\n                argument_type = argument_type_stub\n            else:\n                argument_type = self.parse_shape(argument_shape)\n            argument = Argument(argument_alias, argument_type)\n            if argument_name not in required:\n                argument.default = Type.Ellipsis\n            default_value_stub = get_default_value_stub(self.service_name, class_name, method_name, argument_name)\n            if default_value_stub is not None:\n                argument.default = default_value_stub\n            if optional_only and argument.required:\n                continue\n            result.append(argument)\n        result.sort(key=lambda x: not x.required)\n        return result",
          "docstring": "",
          "signature": "def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._parse_return_type": {
          "code": "    def _parse_return_type(self, class_name: str, method_name: str, shape: Shape | None) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, 'return')\n        if argument_type_stub is not None:\n            return argument_type_stub\n        if shape:\n            return self.parse_shape(shape, is_output=True)\n        return Type.none",
          "docstring": "",
          "signature": "def _parse_return_type(self, class_name: str, method_name: str, shape: Shape | None) -> FakeAnnotation:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_kw_flags": {
          "code": "    def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:\n        if len(arguments) and (not method_name[0].isupper()):\n            return [Argument.kwflag()]\n        return []",
          "docstring": "",
          "signature": "def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_typed_dict_name": {
          "code": "    def _get_typed_dict_name(shape: Shape, postfix: str='') -> str:\n        return get_type_def_name(shape.name, postfix)",
          "docstring": "",
          "signature": "def _get_typed_dict_name(shape: Shape, postfix: str='') -> str:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.__init__": {
          "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal['*', '**', ''] = prefix",
          "docstring": "",
          "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:",
          "type": "Method",
          "class_signature": "class Argument:"
        },
        "Argument.self": {
          "code": "    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
          "docstring": "Create `self` argument.",
          "signature": "def self(cls) -> Self:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
          "docstring": "",
          "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        },
        "Function.create_request_type_annotation": {
          "code": "    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"\n        Create and set `request_type_annotation` TypedDict based on function arguments.\n        \"\"\"\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(\n                argument.name,\n                argument.type_annotation,\n                required=argument.required,\n            )\n\n        if not result.children:\n            return\n        self.request_type_annotation = result",
          "docstring": "Create and set `request_type_annotation` TypedDict based on function arguments.",
          "signature": "def create_request_type_annotation(self, name: str) -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/type_annotations/internal_import.py": {
        "InternalImport.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        service_name: ServiceName | None = None,\n        module_name: ServiceModuleName = ServiceModuleName.service_resource,\n        *,\n        stringify: bool = True,\n        use_alias: bool = False,\n    ) -> None:\n        self.name: str = name\n        self.service_name: ServiceName | None = service_name\n        self.module_name: ServiceModuleName = module_name\n        self.stringify: bool = stringify\n        self.use_alias: bool = use_alias",
          "docstring": "",
          "signature": "def __init__(self, name: str, service_name: ServiceName | None=None, module_name: ServiceModuleName=ServiceModuleName.service_resource, *, stringify: bool=True, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class InternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py": {
        "TypeSubscript.__init__": {
          "code": "    def __init__(\n        self,\n        parent: FakeAnnotation,\n        children: Iterable[FakeAnnotation] = (),\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify",
          "docstring": "",
          "signature": "def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class TypeSubscript(TypeParent):"
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_collection_filter_method": {
      "mypy_boto3_builder/parsers/shape_parser.py": {
        "ShapeParser._get_operation": {
          "code": "    def _get_operation(self, name: str) -> OperationModel:\n        return self.service_model.operation_model(name)",
          "docstring": "",
          "signature": "def _get_operation(self, name: str) -> OperationModel:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._parse_arguments": {
          "code": "    def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:\n        result: list[Argument] = []\n        required = shape.required_members\n        for argument_name, argument_shape in shape.members.items():\n            if argument_name in exclude_names:\n                continue\n            argument_alias = get_argument_alias(self.service_name, operation_name, argument_name)\n            if argument_alias is None:\n                continue\n            argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, argument_name)\n            if argument_type_stub is Type.RemoveArgument:\n                continue\n            if argument_type_stub is not None:\n                argument_type = argument_type_stub\n            else:\n                argument_type = self.parse_shape(argument_shape)\n            argument = Argument(argument_alias, argument_type)\n            if argument_name not in required:\n                argument.default = Type.Ellipsis\n            default_value_stub = get_default_value_stub(self.service_name, class_name, method_name, argument_name)\n            if default_value_stub is not None:\n                argument.default = default_value_stub\n            if optional_only and argument.required:\n                continue\n            result.append(argument)\n        result.sort(key=lambda x: not x.required)\n        return result",
          "docstring": "",
          "signature": "def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_kw_flags": {
          "code": "    def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:\n        if len(arguments) and (not method_name[0].isupper()):\n            return [Argument.kwflag()]\n        return []",
          "docstring": "",
          "signature": "def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
          "docstring": "",
          "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.self": {
          "code": "    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
          "docstring": "Create `self` argument.",
          "signature": "def self(cls) -> Self:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:fix_typed_dict_names": {
      "mypy_boto3_builder/parsers/typed_dict_map.py": {
        "TypedDictMap.iterate_by_name": {
          "code": "    def iterate_by_name(self, name: str) -> Iterator[TypeTypedDict]:\n        \"\"\"\n        Iterate over items matched by real dict name.\n        \"\"\"\n        items = list(self.values())\n        for item in items:\n            if item.name == name:\n                yield item",
          "docstring": "Iterate over items matched by real dict name.",
          "signature": "def iterate_by_name(self, name: str) -> Iterator[TypeTypedDict]:",
          "type": "Method",
          "class_signature": "class TypedDictMap(dict[str, TypeTypedDict]):"
        },
        "TypedDictMap.rename": {
          "code": "    def rename(self, item: TypeTypedDict, new_name: str) -> None:\n        \"\"\"\n        Rename item and change mapping.\n        \"\"\"\n        for key, value in list(self.items()):\n            if value == item:\n                del self[key]\n\n        item.name = new_name\n        self[new_name] = item",
          "docstring": "Rename item and change mapping.",
          "signature": "def rename(self, item: TypeTypedDict, new_name: str) -> None:",
          "type": "Method",
          "class_signature": "class TypedDictMap(dict[str, TypeTypedDict]):"
        },
        "TypedDictMap.get_sorted_names": {
          "code": "    def get_sorted_names(self) -> list[str]:\n        \"\"\"\n        Get real TypedDict names topologically sorted.\n        \"\"\"\n        sorted_values = TypeDefSorter(set(self.values())).sort()\n        allowed_names = {i.name for i in self.values()}\n        return [i.name for i in sorted_values if i.name in allowed_names]",
          "docstring": "Get real TypedDict names topologically sorted.",
          "signature": "def get_sorted_names(self) -> list[str]:",
          "type": "Method",
          "class_signature": "class TypedDictMap(dict[str, TypeTypedDict]):"
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypeTypedDict.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))",
          "docstring": "Calculate hash value based on name and children.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        },
        "TypeTypedDict.is_same": {
          "code": "    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)",
          "docstring": "Check whether typed dict attributes are the same as `other`.",
          "signature": "def is_same(self: Self, other: Self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        }
      },
      "mypy_boto3_builder/parsers/shape_parser.py": {
        "ShapeParser._get_typed_dict": {
          "code": "    def _get_typed_dict(self, name: str, maps: Sequence[dict[str, TypeTypedDict]]) -> TypeTypedDict | None:\n        for typed_dict_map in maps:\n            if name in typed_dict_map:\n                return typed_dict_map[name]\n        return None",
          "docstring": "",
          "signature": "def _get_typed_dict(self, name: str, maps: Sequence[dict[str, TypeTypedDict]]) -> TypeTypedDict | None:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_non_clashing_typed_dict_name": {
          "code": "    def _get_non_clashing_typed_dict_name(self, typed_dict: TypeTypedDict, postfix: str) -> str:\n        new_typed_dict_name = get_type_def_name(self._get_typed_dict_name_prefix(typed_dict.name), postfix)\n        clashing_typed_dict = self._get_typed_dict(new_typed_dict_name, (self._typed_dict_map, self._output_typed_dict_map, self._response_typed_dict_map))\n        if not clashing_typed_dict:\n            return new_typed_dict_name\n        temp_typed_dict = typed_dict.copy()\n        temp_typed_dict.name = new_typed_dict_name\n        if clashing_typed_dict.is_same(temp_typed_dict):\n            return new_typed_dict_name\n        self.logger.debug(f'Clashing typed dict name found: {new_typed_dict_name}')\n        return self._get_non_clashing_typed_dict_name(typed_dict, 'Extra' + postfix)",
          "docstring": "",
          "signature": "def _get_non_clashing_typed_dict_name(self, typed_dict: TypeTypedDict, postfix: str) -> str:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_optional": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypedDictAttribute.is_required": {
          "code": "    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required",
          "docstring": "Whether argument is required.",
          "signature": "def is_required(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypedDictAttribute:"
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_literal_name": {
      "mypy_boto3_builder/utils/strings.py": {
        "capitalize": {
          "code": "def capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f\"{s[:1].upper()}{s[1:]}\"",
          "docstring": "Capitalize first letter of a string.",
          "signature": "def capitalize(s: str) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_string": {
      "mypy_boto3_builder/type_maps/literal_type_map.py": {
        "get_type_literal_stub": {
          "code": "def get_type_literal_stub(service_name: ServiceName, literal_name: str) -> TypeLiteral | None:\n    \"\"\"\n    Get stub type for botocore literal.\n\n    Arguments:\n        service_name -- Service name.\n        literal_name -- Target Literal name.\n\n    Returns:\n        Literal children or None.\n    \"\"\"\n    literal_children = _LOOKUP.get(service_name.name, literal_name)\n    if not literal_children:\n        return None\n\n    return TypeLiteral(literal_name, literal_children)",
          "docstring": "Get stub type for botocore literal.\n\nArguments:\n    service_name -- Service name.\n    literal_name -- Target Literal name.\n\nReturns:\n    Literal children or None.",
          "signature": "def get_type_literal_stub(service_name: ServiceName, literal_name: str) -> TypeLiteral | None:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/type_annotations/type_literal.py": {
        "TypeLiteral.__init__": {
          "code": "    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError('Literal should have children')",
          "docstring": "",
          "signature": "def __init__(self, name: str, children: Iterable[str]) -> None:",
          "type": "Method",
          "class_signature": "class TypeLiteral(FakeAnnotation):"
        },
        "TypeLiteral.is_same": {
          "code": "    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children",
          "docstring": "Check if literals have the same children.",
          "signature": "def is_same(self: Self, other: Self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeLiteral(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.import_record": {
          "code": "    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)",
          "docstring": "Get import record required for using type annotation.",
          "signature": "def import_record(self) -> ImportRecord:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.get_local_name": {
          "code": "    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()",
          "docstring": "Get local import name.",
          "signature": "def get_local_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:render": {
      "mypy_boto3_builder/type_annotations/type_literal.py": {
        "TypeLiteral.inline": {
          "code": "    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1",
          "docstring": "Whether Litereal should be rendered inline.\n\n1-value literals are rendered inline.",
          "signature": "def inline(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeLiteral(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_resource_method_map": {
      "mypy_boto3_builder/parsers/shape_parser.py": {
        "ShapeParser._get_resource_shape": {
          "code": "    def _get_resource_shape(self, name: str) -> ResourceShape:\n        if name == SERVICE_RESOURCE:\n            return self._get_service_resource()\n        if not self._resources_shape or 'resources' not in self._resources_shape:\n            raise ShapeParserError('Resource shape not found')\n        try:\n            return self._resources_shape['resources'][name]\n        except KeyError as e:\n            raise ShapeParserError(f'Unknown resource: {name}') from e",
          "docstring": "",
          "signature": "def _get_resource_shape(self, name: str) -> ResourceShape:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_identifier_argument": {
          "code": "    def _get_identifier_argument(self, resource_name: str, method_name: str, identifier: IdentifierShape) -> Argument:\n        argument_name = self._get_identifier_xform_name(identifier)\n        argument_type = self._get_identifier_type(resource_name, method_name, argument_name, identifier)\n        return Argument(argument_name, argument_type)",
          "docstring": "",
          "signature": "def _get_identifier_argument(self, resource_name: str, method_name: str, identifier: IdentifierShape) -> Argument:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        },
        "ShapeParser._get_resource_method": {
          "code": "    def _get_resource_method(self, action_name: str, action_shape: ActionShape) -> Method:\n        return_type: FakeAnnotation = Type.none\n        method_name = xform_name(action_name)\n        arguments: list[Argument] = [Argument.self()]\n        if 'resource' in action_shape:\n            return_type = self._parse_return_type(self.resource_name, method_name, Shape('resource', action_shape['resource']))\n            path = action_shape['resource'].get('path', '')\n            if path.endswith('[]'):\n                return_type = TypeSubscript(Type.List, [return_type])\n        operation_shape = None\n        if 'request' in action_shape:\n            operation_name = action_shape['request']['operation']\n            operation_shape = self._get_operation(operation_name)\n            skip_argument_names = self._get_skip_argument_names(action_shape)\n            if operation_shape.input_shape is not None:\n                shape_arguments = self._parse_arguments(class_name=self.resource_name, method_name=method_name, operation_name=operation_name, shape=operation_shape.input_shape, exclude_names=skip_argument_names)\n                arguments.extend(self._get_kw_flags(method_name, shape_arguments))\n                arguments.extend(shape_arguments)\n            self._enrich_arguments_defaults(arguments, action_shape)\n            arguments.sort(key=lambda x: not x.required)\n            if operation_shape.output_shape is not None and return_type is Type.none:\n                operation_return_type = self.parse_shape(operation_shape.output_shape, is_output=True)\n                return_type = operation_return_type\n        method = Method(name=method_name, arguments=arguments, return_type=return_type)\n        if operation_shape and operation_shape.input_shape is not None:\n            method.create_request_type_annotation(self._get_typed_dict_name(operation_shape.input_shape, postfix=f'{self.resource_name}{action_name}'))\n        return method",
          "docstring": "",
          "signature": "def _get_resource_method(self, action_name: str, action_shape: ActionShape) -> Method:",
          "type": "Method",
          "class_signature": "class ShapeParser:"
        }
      },
      "mypy_boto3_builder/structures/function.py": {
        "Function.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
          "docstring": "",
          "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
          "type": "Method",
          "class_signature": "class Function:"
        }
      },
      "mypy_boto3_builder/type_annotations/internal_import.py": {
        "InternalImport.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        service_name: ServiceName | None = None,\n        module_name: ServiceModuleName = ServiceModuleName.service_resource,\n        *,\n        stringify: bool = True,\n        use_alias: bool = False,\n    ) -> None:\n        self.name: str = name\n        self.service_name: ServiceName | None = service_name\n        self.module_name: ServiceModuleName = module_name\n        self.stringify: bool = stringify\n        self.use_alias: bool = use_alias",
          "docstring": "",
          "signature": "def __init__(self, name: str, service_name: ServiceName | None=None, module_name: ServiceModuleName=ServiceModuleName.service_resource, *, stringify: bool=True, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class InternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/utils/strings.py": {
        "xform_name": {
          "code": "def xform_name(name: str, sep: str = \"_\") -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError(\"Separator is required\")\n    return botocore_xform_name(name, sep)",
          "docstring": "Convert name to snake_case.\n\nArguments:\n    name -- Any string.\n    sep -- Separator.",
          "signature": "def xform_name(name: str, sep: str='_') -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/structures/argument.py": {
        "Argument.self": {
          "code": "    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
          "docstring": "Create `self` argument.",
          "signature": "def self(cls) -> Self:",
          "type": "Method",
          "class_signature": "class Argument:"
        }
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py": {
        "TypeSubscript.__init__": {
          "code": "    def __init__(\n        self,\n        parent: FakeAnnotation,\n        children: Iterable[FakeAnnotation] = (),\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify",
          "docstring": "",
          "signature": "def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class TypeSubscript(TypeParent):"
        }
      }
    }
  },
  "call_tree": {
    "tests/parsers/test_shape_parser.py:TestShapeParser:setup_method": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_init": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_paginator_names": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_paginator_names": {}
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_client_method_map": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_client_method_map": {
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
        "mypy_boto3_builder/structures/function.py:Function:__init__": {},
        "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_operation": {},
        "mypy_boto3_builder/utils/strings.py:xform_name": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_arguments": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_kw_flags": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_return_type": {
          "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
                }
              },
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:parse_shape": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:TypeTypedDict": {},
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_streaming_body": {},
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_shape_type_name": {},
            "mypy_boto3_builder/type_maps/shape_type_map.py:get_output_shape_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
                    "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
                  }
                },
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              },
              "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
                    "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
                    "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
                      "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
                    }
                  },
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
                }
              }
            },
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_by_type": {
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_names": {}
            }
          }
        },
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_typed_dict_name": {
          "mypy_boto3_builder/utils/strings.py:get_type_def_name": {
            "mypy_boto3_builder/utils/strings.py:get_class_prefix": {
              "mypy_boto3_builder/utils/strings.py:capitalize": {}
            }
          }
        },
        "mypy_boto3_builder/structures/function.py:Function:create_request_type_annotation": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
          "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
        }
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_paginate_method": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_paginate_method": {
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_paginator": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_operation": {},
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_arguments": {
          "mypy_boto3_builder/type_maps/argument_alias_map.py:get_argument_alias": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
                }
              },
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:parse_shape": {
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_shape_type_name": {},
            "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              }
            },
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_by_type": {
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_names": {}
            }
          },
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
          "mypy_boto3_builder/type_maps/method_type_map.py:get_default_value_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
                }
              },
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/structures/argument.py:Argument:required": {}
        },
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_kw_flags": {
          "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {
            "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
          }
        },
        "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_return_type": {
          "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:parse_shape": {
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_streaming_body": {},
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_shape_type_name": {},
            "mypy_boto3_builder/type_maps/shape_type_map.py:get_output_shape_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              },
              "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
                }
              }
            },
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_by_type": {
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_names": {}
            }
          }
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {},
        "mypy_boto3_builder/structures/function.py:Function:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_typed_dict_name": {
          "mypy_boto3_builder/utils/strings.py:get_type_def_name": {
            "mypy_boto3_builder/utils/strings.py:get_class_prefix": {
              "mypy_boto3_builder/utils/strings.py:capitalize": {}
            }
          }
        },
        "mypy_boto3_builder/structures/function.py:Function:create_request_type_annotation": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
          "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {},
          "mypy_boto3_builder/structures/argument.py:Argument:required": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
          }
        }
      },
      "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_collection_filter_method": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_collection_filter_method": {
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/structures/function.py:Function:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_operation": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_arguments": {
          "mypy_boto3_builder/type_maps/argument_alias_map.py:get_argument_alias": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:parse_shape": {
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_shape_type_name": {},
            "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              }
            },
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_by_type": {
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_names": {}
            }
          },
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
          "mypy_boto3_builder/type_maps/method_type_map.py:get_default_value_stub": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
            }
          },
          "mypy_boto3_builder/structures/argument.py:Argument:required": {}
        },
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_kw_flags": {
          "mypy_boto3_builder/structures/argument.py:Argument:kwflag": {
            "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
          }
        }
      },
      "mypy_boto3_builder/structures/argument.py:Argument:is_kwflag": {}
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_fix_typed_dict_names": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:fix_typed_dict_names": {
        "mypy_boto3_builder/parsers/typed_dict_map.py:TypedDictMap:get_sorted_names": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
                "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                    "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                  }
                }
              }
            }
          },
          "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:__init__": {
            "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:_get_type_defs_map": {
              "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:get_sortable_children": {
                "mypy_boto3_builder/type_annotations/type_def_sortable.py:TypeDefSortable:TypeDefSortable": {},
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_types": {
                  "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:iterate_types": {
                    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
                  },
                  "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
                    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
                      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {}
                    }
                  }
                }
              }
            },
            "mypy_boto3_builder/logger.py:get_logger": {}
          },
          "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:sort": {
            "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:_sort_topological": {
              "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:_create_graph": {
                "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:_get_children_names": {
                  "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:get_sortable_children": {
                    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_types": {
                      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:iterate_types": {},
                      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {}
                    }
                  }
                }
              },
              "mypy_boto3_builder/utils/type_def_sorter.py:TypeDefSorter:_get": {}
            }
          }
        },
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_typed_dict": {},
        "mypy_boto3_builder/parsers/typed_dict_map.py:TypedDictMap:iterate_by_name": {},
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_same": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
                "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                    "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                  }
                }
              }
            }
          }
        },
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_non_clashing_typed_dict_name": {
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_typed_dict_name_prefix": {},
          "mypy_boto3_builder/utils/strings.py:get_type_def_name": {
            "mypy_boto3_builder/utils/strings.py:get_class_prefix": {
              "mypy_boto3_builder/utils/strings.py:capitalize": {}
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_typed_dict": {},
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
            }
          },
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_same": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
                "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
                  "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                    "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                      "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                    }
                  }
                }
              }
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_non_clashing_typed_dict_name": {
            "[ignored_or_cut_off]": "..."
          }
        },
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                }
              }
            }
          }
        },
        "mypy_boto3_builder/parsers/typed_dict_map.py:TypedDictMap:rename": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_sort_key": {}
          }
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_optional": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_literal_name": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_literal_name": {
        "mypy_boto3_builder/utils/strings.py:capitalize": {}
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_parse_shape_string": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_string": {
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_literal_name": {
          "mypy_boto3_builder/utils/strings.py:capitalize": {}
        },
        "mypy_boto3_builder/type_maps/literal_type_map.py:get_type_literal_stub": {
          "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {}
            },
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
          }
        },
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {},
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:is_same": {}
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
      },
      "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:render": {
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:inline": {}
      }
    },
    "tests/parsers/test_shape_parser.py:TestShapeParser:test_get_resource_method_map": {
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:__init__": {
        "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
        "mypy_boto3_builder/logger.py:get_logger": {}
      },
      "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:get_resource_method_map": {
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_shape": {},
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {},
        "mypy_boto3_builder/structures/function.py:Function:__init__": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_method": {
          "mypy_boto3_builder/utils/strings.py:xform_name": {},
          "mypy_boto3_builder/structures/argument.py:Argument:self": {
            "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:resource_name": {},
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_return_type": {
            "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              }
            },
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:parse_shape": {
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_streaming_body": {},
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_shape_type_name": {},
              "mypy_boto3_builder/type_maps/shape_type_map.py:get_output_shape_type_stub": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
                },
                "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
                  "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                    "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                    "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
                  }
                }
              },
              "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_parse_shape_by_type": {
                "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_resource_names": {}
              }
            }
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_operation": {},
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_skip_argument_names": {
            "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_arg_from_target": {}
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_enrich_arguments_defaults": {},
          "mypy_boto3_builder/structures/argument.py:Argument:required": {},
          "mypy_boto3_builder/structures/function.py:Function:__init__": {}
        },
        "mypy_boto3_builder/utils/strings.py:xform_name": {},
        "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_identifier_argument": {
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_identifier_xform_name": {
            "mypy_boto3_builder/utils/strings.py:xform_name": {}
          },
          "mypy_boto3_builder/parsers/shape_parser.py:ShapeParser:_get_identifier_type": {
            "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              }
            },
            "mypy_boto3_builder/type_maps/shape_type_map.py:get_shape_type_stub": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {},
                "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
              }
            }
          },
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:__init__": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_shape_parser\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 parsers/\n    \u2502   \u2514\u2500\u2500 shape_parser.py\n    \u2502       \u251c\u2500\u2500 ShapeParser.__init__\n    \u2502       \u251c\u2500\u2500 ShapeParser._get_literal_name\n    \u2502       \u251c\u2500\u2500 ShapeParser._parse_shape_string\n    \u2502       \u251c\u2500\u2500 ShapeParser.fix_typed_dict_names\n    \u2502       \u251c\u2500\u2500 ShapeParser.get_client_method_map\n    \u2502       \u251c\u2500\u2500 ShapeParser.get_collection_filter_method\n    \u2502       \u251c\u2500\u2500 ShapeParser.get_paginate_method\n    \u2502       \u251c\u2500\u2500 ShapeParser.get_paginator_names\n    \u2502       \u2514\u2500\u2500 ShapeParser.get_resource_method_map\n    \u251c\u2500\u2500 structures/\n    \u2502   \u2514\u2500\u2500 argument.py\n    \u2502       \u2514\u2500\u2500 Argument.is_kwflag\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u2514\u2500\u2500 ExternalImport.render\n        \u251c\u2500\u2500 type_literal.py\n        \u2502   \u2514\u2500\u2500 TypeLiteral.render\n        \u2514\u2500\u2500 type_typed_dict.py\n            \u251c\u2500\u2500 TypeTypedDict.__init__\n            \u251c\u2500\u2500 TypeTypedDict.has_optional\n            \u2514\u2500\u2500 TypedDictAttribute.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to provide a structured mechanism for parsing and interpreting AWS service models within the context of the `boto3` library, enabling the generation of type-safe client interfaces and data structures. It leverages a `ShapeParser` to extract and organize key metadata from service definitions, including paginators, client methods, and resource actions, ensuring consistent, type-specific mappings. Core functionalities include identifying and sorting paginator names, constructing method maps for client and resource operations, resolving typing inconsistencies in service models, and validating method arguments for both required and optional parameters. By offering these capabilities, the module simplifies the integration of dynamic AWS service behaviors into type-safe codebases, reducing development overhead and enhancing the reliability of code that interacts with `boto3`.\n\n## FILE 1: mypy_boto3_builder/parsers/shape_parser.py\n\n- CLASS METHOD: ShapeParser._parse_shape_string\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def _parse_shape_string(self, shape: StringShape) -> FakeAnnotation:\n  - DOCSTRING: \n```python\n\"\"\"\nParse a botocore StringShape and convert it into a corresponding FakeAnnotation.\n\nParameters:\n    shape (StringShape): The StringShape to parse, which may include an enum attribute representing possible string values.\n\nReturns:\n    FakeAnnotation: A TypeLiteral if the shape has an enum, representing the valid string literals; otherwise, it returns a generic string type (Type.str).\n\nRaises:\n    ShapeParserError: If a literal name derived from the enum already exists in the type literal map with different values.\n\nThis method interacts with constants and functions such as `get_type_literal_stub`, which retrieves type litteral definitions based on the service name and the literal name, and `self._get_literal_name`, which generates a standardized name for the type literal based on the shape's enum. The method also utilizes `self._type_literal_map` to track previously defined type literals for duplicates.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.fix_typed_dict_names\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def fix_typed_dict_names(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nFixes TypedDict names to avoid duplicates in the mapped typed dictionaries. \n\nThe method first retrieves sorted names from the output typed dictionary map, checking for potential name clashes between output TypedDicts and pre-existing Type mappings. When a conflict is detected, it renames the output TypedDict to a non-clashing name using the `_get_non_clashing_typed_dict_name` method, which ensures unique naming by appending a postfix. Conflicting TypedDicts are tracked in the `_fixed_typed_dict_map` for further processing. Also, any previously existing response TypedDicts with the old name are removed and re-added with the new name.\n\nAdditionally, it interacts with the following attributes of the class:\n- `_output_typed_dict_map`: A map holding output TypedDict definitions.\n- `_typed_dict_map`: A map holding the regular TypedDict definitions.\n- `_response_typed_dict_map`: A map holding response-specific TypedDict definitions.\n- `_fixed_typed_dict_map`: A dictionary that maintains a record of renamed TypedDicts to ensure proper references.\n\nThis method modifies the state of the involved TypedDict maps but does not return any value.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.get_client_method_map\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def get_client_method_map(self) -> dict[str, Method]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet client methods based on the shape of the service model.\n\nThis method constructs a dictionary mapping method names to `Method` instances representing client methods available for the specified service. It includes methods such as \"can_paginate\", \"generate_presigned_url\", and \"close\", which are predefined, and dynamically generates methods for all defined operations in the service model. Each method includes relevant arguments parsed from the operation's input shape and determines the return type based on the operation's output shape.\n\nReturns:\n    A dictionary where keys are method names and values are `Method` instances that encapsulate method details.\n\nConstants:\n    CLIENT: This constant identifies the resource name as \"client\" within the method. It is defined in the module `mypy_boto3_builder.constants` and signifies that the methods generated are associated with the client interface of the AWS service.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.__init__\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def __init__(self, session: Session, service_name: ServiceName) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes the ShapeParser class, which is responsible for parsing botocore shape files to generate type annotations for AWS service models.\n\nParameters:\n    session (Session): A boto3 Session object that provides context for the AWS service interactions.\n    service_name (ServiceName): An instance of ServiceName that specifies the AWS service to be parsed.\n\nAttributes:\n    service_name (ServiceName): Stores the service name for later reference.\n    service_model (ServiceModel): Represents the parsed service model data from botocore.\n    _resource_name (str): Internal storage for the resource name, initialized to an empty string.\n    _type_literal_map (dict[str, TypeLiteral]): Maps type literal names to their TypeLiteral definitions.\n    _typed_dict_map (TypedDictMap): Maps defined TypedDicts for service inputs and outputs.\n    _output_typed_dict_map (TypedDictMap): Maps output-specific TypedDicts for service responses.\n    _response_typed_dict_map (TypedDictMap): Maps TypedDicts used specifically for response metadata.\n    _fixed_typed_dict_map (dict[TypeTypedDict, TypeTypedDict]): Holds distinct TypedDicts to avoid naming collisions.\n\nSide Effects:\n    - Attempts to load waiter, paginator, and resource shape models for the specified service name. If any of these are not found, it silently ignores the exceptions.\n    - Logs messages through the logger obtained from the get_logger() utility function, providing visibility into class operations and state changes.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser._get_literal_name\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def _get_literal_name(shape: StringShape) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate the literal type name for a given StringShape.\n\nArgs:\n    shape (StringShape): An instance of StringShape which represents the shape of a string type, potentially containing an enumeration (`enum`).\n\nReturns:\n    str: A capitalized string representing the type name derived from the shape's name. If the shape name is \"__string\", the method combines and capitalizes the names of the enum members to form the literal type name, appending \"Type\" at the end. Otherwise, it simply capitalizes the shape name, removing any leading underscores and appending \"Type\".\n\nNotes:\n    The method relies on the `capitalize` function to format the string correctly. The function is associated with ensuring type safety when using botocore shapes in contexts where enumeration values are involved.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.get_resource_method_map\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def get_resource_method_map(self, resource_name: str) -> dict[str, Method]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet methods for a specified AWS resource, including actions, waiters, and subresources.\n\nArgs:\n    resource_name (str): The name of the resource for which to retrieve the methods.\n\nReturns:\n    dict[str, Method]: A mapping of method names to Method instances associated with the specified resource.\n\nThe method interacts with the resource shape obtained through `self._get_resource_shape`, which extracts information about available actions, waiters, and subresources. The method initializes with standard operations such as `get_available_subresources`, `load`, and `reload`, and dynamically adds any actions defined in the resource shape. If subresources are present, it generates methods for each, utilizing identifiers defined in the resource shape's structure. Constants such as `InternalImport` are used to define return types for subresource methods based on the resource structure.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.get_paginator_names\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def get_paginator_names(self) -> list[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a sorted list of paginator names available for the service.\n\nThis method accesses the paginators shape stored in the instance, which is initialized during the \nclass's instantiation. If the paginators shape is not present or doesn't contain any pagination \ninformation, an empty list is returned.\n\nReturns:\n    A sorted list of paginator names if available, otherwise an empty list.\n\nDependencies:\n    - `self._paginators_shape`: This attribute is set during the initialization of the class \n      and is loaded from the service model data. It contains the pagination configurations \n      for the service, allowing this method to extract and return the paginator names.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.get_collection_filter_method\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def get_collection_filter_method(self, name: str, collection: Collection, self_type: FakeAnnotation) -> Method:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a `filter` classmethod for a Boto3 Collection resource.\n\nThis method constructs a filter method that allows users to filter items in a collection\nbased on specific parameters. It retrieves the operation model for the corresponding request\nand parses the input arguments required for the operation, adding them to the filter method.\n\nParameters:\n    name (str): The name of the collection record.\n    collection (Collection): A Boto3 Collection object representing the resource collection.\n    self_type (FakeAnnotation): The type annotation for the collection's instance.\n\nReturns:\n    Method: A Method instance representing the filter method with parsed arguments.\n\nNotes:\n    If the collection does not define a request, the method returns a filter method\n    with only the \"self\" argument. The `operation_name` is extracted from the collection's\n    request, and if the operation model has an input shape, the arguments are parsed \n    accordingly using the `_parse_arguments` method.\n\"\"\"\n```\n\n- CLASS METHOD: ShapeParser.get_paginate_method\n  - CLASS SIGNATURE: class ShapeParser:\n  - SIGNATURE: def get_paginate_method(self, paginator_name: str) -> Method:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the Paginator `paginate` method based on the specified paginator name.\n\nArguments:\n    paginator_name -- The name of the paginator to retrieve.\n\nReturns:\n    Method: An instance of the Method class representing the `paginate` method.\n\nThis method constructs a `paginate` method for a specified paginator by retrieving its shape and corresponding operation details. It constructs required arguments for the `paginate` method while excluding any identifiers specified in the paginator's input token. The return type of the method is a paginated item wrapped in a subscripted type. If the operation has input shapes, they are parsed into corresponding arguments, appended with a `PaginationConfig` argument.\n\nThe method utilizes constants and types such as `PaginatorConfigTypeDef` and `TypeSubscript`, which define type annotations for pagination configurations and the expected return type structure. Additionally, it interacts with class methods like `_get_paginator` to fetch paginator shape details and `_get_operation` to retrieve operation models.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/type_typed_dict.py\n\n- CLASS METHOD: TypeTypedDict.has_optional\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def has_optional(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the TypedDict instance contains any optional keys. An optional key is defined as an attribute whose requirement status is not marked as required. This method iterates through the `children` attributes of the TypedDict, each represented by a `TypedDictAttribute` instance, which holds the required status of each attribute. If at least one child attribute is not required, the method returns True; otherwise, it returns False.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.__init__\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeTypedDict instance, which wraps type annotations for TypedDicts.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute]): An optional collection of TypedDictAttribute instances representing the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str): An optional docstring that describes the purpose of the TypedDict.\n- stringify (bool): An optional flag that indicates whether the TypedDict usage should be rendered as a string. Defaults to False.\n\nThis constructor initializes the attributes of the TypeTypedDict instance, including the name, attributes (children), docstring, and stringify flag. The 'children' parameter is converted into a list for internal management. The 'is_safe_as_class' attribute is set to True, indicating that this TypedDict can be safely used as a class. This class interacts closely with various types of annotations and helpers, such as TypedDictAttribute, which defines individual attributes for the TypedDict.\n\"\"\"\n```\n\n- CLASS METHOD: TypedDictAttribute.__init__\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a TypedDictAttribute instance, which acts as a wrapper for attributes of a TypedDict.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation for the attribute, expected to be an instance of FakeAnnotation, which is defined elsewhere in the code and used to represent various type annotations.\n- required (bool): Indicates whether the attribute is mandatory (True) or optional (False).\n\nReturns:\nNone. The initialization sets up the instance with the given properties.\n\nThis constructor interacts with the type annotation system, allowing attributes to be defined in TypedDict classes. The 'type_annotation' parameter is particularly significant as it determines how the attribute is treated and enforced in type checks.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/structures/argument.py\n\n- CLASS METHOD: Argument.is_kwflag\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def is_kwflag(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the argument is a keyword flag separator.\n\nThis method checks whether the `name` attribute of the `Argument` instance is equal to the string `*`. The `*` serves as a keyword flag separator in Python function definitions, indicating that subsequent parameters must be specified as keyword arguments. \n\nReturns:\n    bool: True if the argument is a `*` keywords separator, otherwise False.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.render\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local name for the imported type annotation.\n\nThis method retrieves the local name associated with the import record, which is created in the `import_record` property. The local name can be used when referencing the type annotation in code. The method does not take any parameters and interacts with the `ImportRecord` class to obtain the local name through its `get_local_name()` method.\n\nReturns:\n    str: The local name of the import record.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/type_annotations/type_literal.py\n\n- CLASS METHOD: TypeLiteral.render\n  - CLASS SIGNATURE: class TypeLiteral(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender a type annotation to valid Python code for local usage.\n\nThis method generates a string representation of the type annotation based on the `children` of the `TypeLiteral` instance. If the `children` contains only one element (determined by the `inline` property), it returns an inline `Literal` format. Otherwise, it returns the name of the `TypeLiteral`. The method requires that `children` be a non-empty set of literal values initialized in the constructor.\n\nReturns:\n    str: A string containing a valid type annotation, either in inline `Literal[...]` format or just the name of the `TypeLiteral`.\n\nDependencies:\n- The `inline` property is used to decide the rendering format.\n- The `children` attribute represents the literal values and must be initialized in the constructor.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/parsers/shape_parser.py": "\"\"\"\nParser for botocore shape files.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport contextlib\nfrom collections.abc import Iterable, Sequence\nfrom typing import TYPE_CHECKING\nfrom boto3.resources.model import Collection\nfrom boto3.session import Session\nfrom botocore.eventstream import EventStream\nfrom botocore.exceptions import UnknownServiceError\nfrom botocore.model import ListShape, MapShape, OperationModel, ServiceModel, Shape, StringShape, StructureShape\nfrom mypy_boto3_builder.constants import ATTRIBUTES, CLIENT, SERVICE_RESOURCE\nfrom mypy_boto3_builder.exceptions import ShapeParserError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.parsers.shape_parser_types import ActionShape, IdentifierShape, PaginatorShape, PaginatorsShape, ResourceShape, ResourcesShape, WaitersShape\nfrom mypy_boto3_builder.parsers.typed_dict_map import TypedDictMap\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion\nfrom mypy_boto3_builder.type_maps.argument_alias_map import get_argument_alias\nfrom mypy_boto3_builder.type_maps.literal_type_map import get_type_literal_stub\nfrom mypy_boto3_builder.type_maps.method_type_map import get_default_value_stub, get_method_type_stub\nfrom mypy_boto3_builder.type_maps.required_attribute_map import is_required\nfrom mypy_boto3_builder.type_maps.shape_type_map import get_output_shape_type_stub, get_shape_type_stub\nfrom mypy_boto3_builder.type_maps.typed_dicts import EmptyResponseMetadataTypeDef, PaginatorConfigTypeDef, ResponseMetadataTypeDef, WaiterConfigTypeDef\nfrom mypy_boto3_builder.utils.boto3_utils import get_botocore_session\nfrom mypy_boto3_builder.utils.strings import capitalize, get_type_def_name, xform_name\nif TYPE_CHECKING:\n    from botocore.session import Session as BotocoreSession\n\nclass ShapeParser:\n    \"\"\"\n    Parser for botocore shape files.\n\n    Arguments:\n        session -- Boto3 session.\n        service_name -- ServiceName.\n    \"\"\"\n\n    @property\n    def resource_name(self) -> str:\n        \"\"\"\n        Parsed resource name.\n        \"\"\"\n        return self._resource_name\n\n    def _get_operation(self, name: str) -> OperationModel:\n        return self.service_model.operation_model(name)\n\n    def _get_paginator(self, name: str) -> PaginatorShape:\n        if not self._paginators_shape:\n            raise ShapeParserError(f'Unknown paginator: {name}')\n        try:\n            return self._paginators_shape['pagination'][name]\n        except KeyError as e:\n            raise ShapeParserError(f'Unknown paginator: {name}') from e\n\n    def _get_service_resource(self) -> ResourceShape:\n        if not self._resources_shape:\n            raise ShapeParserError('Resource shape not found')\n        return self._resources_shape['service']\n\n    def _get_resource_names(self) -> list[str]:\n        if not self._resources_shape:\n            return []\n        if 'resources' not in self._resources_shape:\n            return []\n        return list(self._resources_shape['resources'].keys())\n\n    def _get_resource_shape(self, name: str) -> ResourceShape:\n        if name == SERVICE_RESOURCE:\n            return self._get_service_resource()\n        if not self._resources_shape or 'resources' not in self._resources_shape:\n            raise ShapeParserError('Resource shape not found')\n        try:\n            return self._resources_shape['resources'][name]\n        except KeyError as e:\n            raise ShapeParserError(f'Unknown resource: {name}') from e\n\n    def _parse_arguments(self, *, class_name: str, method_name: str, operation_name: str, shape: StructureShape, exclude_names: Iterable[str]=(), optional_only: bool=False) -> list[Argument]:\n        result: list[Argument] = []\n        required = shape.required_members\n        for argument_name, argument_shape in shape.members.items():\n            if argument_name in exclude_names:\n                continue\n            argument_alias = get_argument_alias(self.service_name, operation_name, argument_name)\n            if argument_alias is None:\n                continue\n            argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, argument_name)\n            if argument_type_stub is Type.RemoveArgument:\n                continue\n            if argument_type_stub is not None:\n                argument_type = argument_type_stub\n            else:\n                argument_type = self.parse_shape(argument_shape)\n            argument = Argument(argument_alias, argument_type)\n            if argument_name not in required:\n                argument.default = Type.Ellipsis\n            default_value_stub = get_default_value_stub(self.service_name, class_name, method_name, argument_name)\n            if default_value_stub is not None:\n                argument.default = default_value_stub\n            if optional_only and argument.required:\n                continue\n            result.append(argument)\n        result.sort(key=lambda x: not x.required)\n        return result\n\n    def _parse_return_type(self, class_name: str, method_name: str, shape: Shape | None) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(self.service_name, class_name, method_name, 'return')\n        if argument_type_stub is not None:\n            return argument_type_stub\n        if shape:\n            return self.parse_shape(shape, is_output=True)\n        return Type.none\n\n    @staticmethod\n    def _get_kw_flags(method_name: str, arguments: Sequence[Argument]) -> list[Argument]:\n        if len(arguments) and (not method_name[0].isupper()):\n            return [Argument.kwflag()]\n        return []\n\n    @staticmethod\n    def _get_typed_dict_name(shape: Shape, postfix: str='') -> str:\n        return get_type_def_name(shape.name, postfix)\n\n    def _parse_shape_map(self, shape: MapShape, *, is_output_child: bool=False, is_streaming: bool=False) -> FakeAnnotation:\n        type_subscript = TypeSubscript(Type.Dict) if is_output_child else TypeSubscript(Type.Mapping)\n        if shape.key:\n            type_subscript.add_child(self.parse_shape(shape.key, is_output_child=is_output_child, is_streaming=is_streaming))\n        else:\n            type_subscript.add_child(Type.str)\n        if shape.value:\n            type_subscript.add_child(self.parse_shape(shape.value, is_output_child=is_output_child, is_streaming=is_streaming))\n        else:\n            type_subscript.add_child(Type.Any)\n        return type_subscript\n\n    def _get_typed_dict_map(self, *, output: bool, output_child: bool) -> TypedDictMap:\n        if output:\n            return self._response_typed_dict_map\n        if output_child:\n            return self._output_typed_dict_map\n        return self._typed_dict_map\n\n    def _parse_shape_structure(self, shape: StructureShape, *, output: bool=False, output_child: bool=False, is_streaming: bool=False) -> FakeAnnotation:\n        if not shape.members.items():\n            return Type.DictStrAny if output_child else Type.MappingStrAny\n        required = shape.required_members\n        is_output_or_child = output or output_child\n        typed_dict_name = self._get_shape_type_name(shape)\n        typed_dict = TypeTypedDict(typed_dict_name)\n        typed_dict_map = self._get_typed_dict_map(output=output, output_child=output_child)\n        resource_typed_dict_name = self._get_typed_dict_name(shape, postfix=self.resource_name)\n        found_typed_dict = typed_dict_map.get(typed_dict.name)\n        found_resource_typed_dict = typed_dict_map.get(resource_typed_dict_name)\n        if found_resource_typed_dict:\n            return found_resource_typed_dict\n        typed_dict_map[resource_typed_dict_name] = typed_dict\n        for attr_name, attr_shape in shape.members.items():\n            typed_dict.add_attribute(attr_name, self.parse_shape(attr_shape, is_output=False, is_output_child=is_output_or_child, is_streaming=is_streaming), required=attr_name in required)\n        if output:\n            self._mark_typed_dict_as_total(typed_dict)\n            self._add_response_metadata(typed_dict)\n        if found_typed_dict and (not typed_dict.is_same(found_typed_dict)):\n            self.logger.debug(f'Renaming conflicting {typed_dict.name} to {resource_typed_dict_name}')\n            typed_dict.name = resource_typed_dict_name\n        typed_dict_map[typed_dict.name] = typed_dict\n        return typed_dict\n\n    def _mark_typed_dict_as_total(self, typed_dict: TypeTypedDict) -> None:\n        for attribute in typed_dict.children:\n            if is_required(self.service_name, typed_dict.name, attribute.name):\n                attribute.mark_as_required()\n            else:\n                self.logger.debug(f'Leaving output {typed_dict.name}.{attribute.name} as {attribute.get_type_annotation().render()}')\n\n    def _add_response_metadata(self, typed_dict: TypeTypedDict) -> None:\n        child_names = {i.name for i in typed_dict.children}\n        if 'ResponseMetadata' not in child_names:\n            typed_dict.add_attribute('ResponseMetadata', ResponseMetadataTypeDef, required=True)\n\n    def _parse_shape_list(self, shape: ListShape, *, is_output_child: bool=False) -> FakeAnnotation:\n        type_subscript = TypeSubscript(Type.List) if is_output_child else TypeSubscript(Type.Sequence)\n        if shape.member:\n            type_subscript.add_child(self.parse_shape(shape.member, is_output_child=is_output_child))\n        else:\n            type_subscript.add_child(Type.Any)\n        return type_subscript\n\n    def _get_shape_type_name(self, shape: Shape) -> str:\n        if isinstance(shape, StructureShape):\n            return self._get_typed_dict_name(shape)\n        if isinstance(shape, StringShape):\n            return shape.name\n        return shape.type_name\n\n    @staticmethod\n    def _get_streaming_body(shape: Shape) -> Shape | None:\n        \"\"\"\n        Get the streaming member's shape if any; or None otherwise.\n        \"\"\"\n        if not isinstance(shape, StructureShape):\n            return None\n        payload = shape.serialization.get('payload')\n        if payload is not None:\n            payload_shape = shape.members.get(payload)\n            if isinstance(payload_shape, Shape) and payload_shape.type_name == 'blob':\n                return payload_shape\n        return None\n\n    def _parse_shape_by_type(self, shape: Shape, *, is_output_or_child: bool, output: bool, is_streaming: bool) -> FakeAnnotation:\n        match shape:\n            case StringShape():\n                return self._parse_shape_string(shape)\n            case MapShape():\n                return self._parse_shape_map(shape, is_output_child=is_output_or_child, is_streaming=is_streaming)\n            case StructureShape():\n                return self._parse_shape_structure(shape, output=output, output_child=is_output_or_child, is_streaming=is_streaming)\n            case ListShape():\n                return self._parse_shape_list(shape, is_output_child=is_output_or_child)\n            case _:\n                pass\n        if shape.type_name in self._get_resource_names():\n            return InternalImport(shape.type_name, use_alias=True)\n        self.logger.warning(f'Unknown shape: {shape} {shape.type_name}')\n        return Type.Any\n\n    def parse_shape(self, shape: Shape, *, is_output: bool=False, is_output_child: bool=False, is_streaming: bool=False) -> FakeAnnotation:\n        \"\"\"\n        Parse any botocore shape to TypeAnnotation.\n\n        Arguments:\n            shape -- Botocore shape.\n            output -- Whether shape should use strict output types.\n            output_child -- Whether shape parent is marked as output.\n            is_streaming -- Whether shape should be streaming.\n\n        Returns:\n            TypeAnnotation or similar class.\n        \"\"\"\n        if shape.serialization.get('eventstream'):\n            shape.serialization['eventstream'] = False\n            return TypeSubscript(ExternalImport.from_class(EventStream), [self.parse_shape(shape, is_output=is_output, is_output_child=is_output_child, is_streaming=is_streaming)], stringify=True)\n        is_output_or_child = is_output or is_output_child\n        if not is_streaming:\n            is_streaming = 'streaming' in shape.serialization and shape.serialization['streaming']\n            if is_output_or_child:\n                is_streaming = self._get_streaming_body(shape) is not None\n        type_name = self._get_shape_type_name(shape)\n        if is_streaming and shape.type_name == 'blob':\n            type_name = 'blob_streaming'\n        if is_output_or_child:\n            shape_type_stub = get_output_shape_type_stub(self.service_name, self._resource_name, type_name)\n        else:\n            shape_type_stub = get_shape_type_stub(self.service_name, self._resource_name, type_name)\n        if shape_type_stub:\n            return shape_type_stub\n        result = self._parse_shape_by_type(shape, is_output_or_child=is_output_or_child, output=is_output, is_streaming=is_streaming)\n        if isinstance(result, TypeTypedDict):\n            replacement = Type.DictStrAny if is_output_or_child else Type.MappingStrAny\n            mutated_parents = result.replace_self_references(replacement)\n            for mutated_parent in sorted(mutated_parents):\n                self.logger.debug(f'Replaced self reference for {result.render()} in {mutated_parent.render()}')\n        return result\n\n    def get_wait_method(self, waiter_name: str) -> Method:\n        \"\"\"\n        Get Waiter `wait` method.\n\n        Arguments:\n            waiter_name -- Waiter name.\n\n        Returns:\n            Method.\n        \"\"\"\n        self._resource_name = 'Waiter'\n        if not self._waiters_shape:\n            raise ShapeParserError('Waiter not found')\n        operation_name = self._waiters_shape['waiters'][waiter_name]['operation']\n        operation_shape = self._get_operation(operation_name)\n        arguments: list[Argument] = [Argument.self()]\n        if operation_shape.input_shape is not None:\n            shape_arguments = self._parse_arguments(class_name='Waiter', method_name='wait', operation_name=operation_name, shape=operation_shape.input_shape)\n            shape_arguments.append(Argument('WaiterConfig', WaiterConfigTypeDef, Type.Ellipsis))\n            arguments.extend(self._get_kw_flags('wait', shape_arguments))\n            arguments.extend(shape_arguments)\n        method = Method(name='wait', arguments=arguments, return_type=Type.none)\n        if operation_shape.input_shape is not None:\n            method.create_request_type_annotation(self._get_typed_dict_name(operation_shape.input_shape, postfix=f'{waiter_name}Wait'))\n        return method\n\n    def _get_identifier_type(self, resource_name: str, method_name: str, identifier_name: str, identifier: IdentifierShape) -> FakeAnnotation:\n        argument_type_stub = get_method_type_stub(self.service_name, resource_name, method_name, identifier_name)\n        if argument_type_stub:\n            return argument_type_stub\n        identifier_type = identifier.get('type')\n        if identifier_type:\n            argument_type_stub = get_shape_type_stub(self.service_name, resource_name, identifier_type)\n            if argument_type_stub:\n                return argument_type_stub\n        return Type.str\n\n    @staticmethod\n    def _get_identifier_xform_name(identifier: IdentifierShape) -> str:\n        return xform_name(identifier.get('name') or identifier.get('target') or 'unknown')\n\n    def _get_identifier_argument(self, resource_name: str, method_name: str, identifier: IdentifierShape) -> Argument:\n        argument_name = self._get_identifier_xform_name(identifier)\n        argument_type = self._get_identifier_type(resource_name, method_name, argument_name, identifier)\n        return Argument(argument_name, argument_type)\n\n    def _get_identifier_attribute(self, resource_name: str, identifier: IdentifierShape) -> Attribute:\n        attribute_name = self._get_identifier_xform_name(identifier)\n        attribute_type = self._get_identifier_type(resource_name, ATTRIBUTES, attribute_name, identifier)\n        return Attribute(name=attribute_name, type_annotation=attribute_type, is_identifier=True)\n\n    def get_service_resource_method_map(self) -> dict[str, Method]:\n        \"\"\"\n        Get methods for ServiceResource.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        result: dict[str, Method] = {'get_available_subresources': Method(name='get_available_subresources', arguments=[Argument.self()], return_type=TypeSubscript(Type.Sequence, [Type.str]))}\n        self._resource_name = SERVICE_RESOURCE\n        service_resource_shape = self._get_resource_shape(self._resource_name)\n        for action_name, action_shape in service_resource_shape.get('actions', {}).items():\n            method = self._get_resource_method(action_name, action_shape)\n            result[method.name] = method\n        for sub_resource_name in self._get_resource_names():\n            resource_shape = self._get_resource_shape(sub_resource_name)\n            arguments = [Argument.self()]\n            identifiers = resource_shape.get('identifiers', [])\n            for identifier in identifiers:\n                argument = self._get_identifier_argument(self._resource_name, sub_resource_name, identifier)\n                arguments.append(argument)\n            method = Method(name=sub_resource_name, arguments=arguments, return_type=InternalImport(sub_resource_name, use_alias=True))\n            result[method.name] = method\n        return result\n\n    def get_resource_identifier_attributes(self, resource_name: str) -> list[Attribute]:\n        \"\"\"\n        Get attributes for Resource identifiers.\n\n        Arguments:\n            resource_name -- Resource name.\n\n        Returns:\n            A map of method name to Method.\n        \"\"\"\n        self._resource_name = resource_name\n        resource_shape = self._get_resource_shape(resource_name)\n        identifiers = resource_shape.get('identifiers', [])\n        return [self._get_identifier_attribute(resource_name, identifier) for identifier in identifiers]\n\n    @staticmethod\n    def _get_arg_from_target(target: str) -> str:\n        if '[' in target:\n            target = target.split('[')[0]\n        if '.' in target:\n            target = target.split('.')[0]\n        return target\n\n    def _get_skip_argument_names(self, action_shape: ActionShape) -> set[str]:\n        result: set[str] = set()\n        params = action_shape['request'].get('params', [])\n        for param in params:\n            target = param['target']\n            source = param['source']\n            if source == 'identifier':\n                result.add(self._get_arg_from_target(target))\n                continue\n            if source == 'string' and '.' in target:\n                result.add(self._get_arg_from_target(target))\n                continue\n        return result\n\n    def _enrich_arguments_defaults(self, arguments: list[Argument], action_shape: ActionShape) -> None:\n        request = action_shape['request']\n        arguments_map = {a.name: a for a in arguments}\n        if 'params' in request:\n            for param in request['params']:\n                target = param['target']\n                source = param['source']\n                if source == 'string' and target in arguments_map:\n                    arguments_map[target].default = TypeConstant(param['value'])\n\n    def _get_resource_method(self, action_name: str, action_shape: ActionShape) -> Method:\n        return_type: FakeAnnotation = Type.none\n        method_name = xform_name(action_name)\n        arguments: list[Argument] = [Argument.self()]\n        if 'resource' in action_shape:\n            return_type = self._parse_return_type(self.resource_name, method_name, Shape('resource', action_shape['resource']))\n            path = action_shape['resource'].get('path', '')\n            if path.endswith('[]'):\n                return_type = TypeSubscript(Type.List, [return_type])\n        operation_shape = None\n        if 'request' in action_shape:\n            operation_name = action_shape['request']['operation']\n            operation_shape = self._get_operation(operation_name)\n            skip_argument_names = self._get_skip_argument_names(action_shape)\n            if operation_shape.input_shape is not None:\n                shape_arguments = self._parse_arguments(class_name=self.resource_name, method_name=method_name, operation_name=operation_name, shape=operation_shape.input_shape, exclude_names=skip_argument_names)\n                arguments.extend(self._get_kw_flags(method_name, shape_arguments))\n                arguments.extend(shape_arguments)\n            self._enrich_arguments_defaults(arguments, action_shape)\n            arguments.sort(key=lambda x: not x.required)\n            if operation_shape.output_shape is not None and return_type is Type.none:\n                operation_return_type = self.parse_shape(operation_shape.output_shape, is_output=True)\n                return_type = operation_return_type\n        method = Method(name=method_name, arguments=arguments, return_type=return_type)\n        if operation_shape and operation_shape.input_shape is not None:\n            method.create_request_type_annotation(self._get_typed_dict_name(operation_shape.input_shape, postfix=f'{self.resource_name}{action_name}'))\n        return method\n\n    def get_collection_batch_methods(self, name: str, collection: Collection) -> list[Method]:\n        \"\"\"\n        Get batch operations for Resource collection.\n\n        Arguments:\n            name -- Collection record name.\n            collection -- Boto3 Collection.\n            class_type -- Collection self type annotation.\n\n        Returns:\n            List of Method records.\n        \"\"\"\n        result: list[Method] = []\n        for batch_action in collection.batch_actions:\n            method = Method(name=batch_action.name, arguments=[Argument.self()], return_type=Type.none)\n            result.append(method)\n            if batch_action.request:\n                operation_name = batch_action.request.operation\n                operation_model = self._get_operation(operation_name)\n                if operation_model.input_shape is not None:\n                    shape_arguments = self._parse_arguments(class_name=name, method_name=batch_action.name, operation_name=operation_name, shape=operation_model.input_shape, optional_only=True)\n                    method.arguments.extend(self._get_kw_flags(batch_action.name, shape_arguments))\n                    method.arguments.extend(shape_arguments)\n                if operation_model.output_shape is not None:\n                    item_return_type = self.parse_shape(operation_model.output_shape, is_output=True)\n                    return_type = TypeSubscript(Type.List, [item_return_type])\n                    method.return_type = return_type\n        return result\n\n    @staticmethod\n    def _get_typed_dict_name_prefix(name: str) -> str:\n        if name.endswith('OutputTypeDef'):\n            return name[:-len('OutputTypeDef')]\n        if name.endswith('TypeDef'):\n            return name[:-len('TypeDef')]\n        raise ShapeParserError(f'Unknown typed dict name format: {name}')\n\n    def _get_typed_dict(self, name: str, maps: Sequence[dict[str, TypeTypedDict]]) -> TypeTypedDict | None:\n        for typed_dict_map in maps:\n            if name in typed_dict_map:\n                return typed_dict_map[name]\n        return None\n\n    def _get_non_clashing_typed_dict_name(self, typed_dict: TypeTypedDict, postfix: str) -> str:\n        new_typed_dict_name = get_type_def_name(self._get_typed_dict_name_prefix(typed_dict.name), postfix)\n        clashing_typed_dict = self._get_typed_dict(new_typed_dict_name, (self._typed_dict_map, self._output_typed_dict_map, self._response_typed_dict_map))\n        if not clashing_typed_dict:\n            return new_typed_dict_name\n        temp_typed_dict = typed_dict.copy()\n        temp_typed_dict.name = new_typed_dict_name\n        if clashing_typed_dict.is_same(temp_typed_dict):\n            return new_typed_dict_name\n        self.logger.debug(f'Clashing typed dict name found: {new_typed_dict_name}')\n        return self._get_non_clashing_typed_dict_name(typed_dict, 'Extra' + postfix)\n\n    @staticmethod\n    def _get_parent_type_annotations(methods: Sequence[Method]) -> set[TypeParent]:\n        result: set[TypeParent] = set()\n        for method in methods:\n            for argument in method.arguments:\n                if isinstance(argument.type_annotation, TypeParent):\n                    result.add(argument.type_annotation)\n        return result\n\n    def convert_input_arguments_to_unions(self, methods: Sequence[Method]) -> None:\n        \"\"\"\n        Accept both input and output shapes in method arguments.\n\n        mypy does not compare TypedDicts, so we need to accept both input and output shapes.\n        https://github.com/youtype/mypy_boto3_builder/issues/209\n        \"\"\"\n        parent_type_annotations = list(self._get_parent_type_annotations(methods))\n        for input_typed_dict, output_typed_dict in self._fixed_typed_dict_map.items():\n            union_name = self._get_non_clashing_typed_dict_name(input_typed_dict, 'Union')\n            union_type_annotation = TypeUnion(name=union_name, children=[input_typed_dict, output_typed_dict])\n            for type_annotation in parent_type_annotations:\n                parents = type_annotation.find_type_annotation_parents(input_typed_dict)\n                for parent in sorted(parents):\n                    if parent is union_type_annotation:\n                        continue\n                    self.logger.debug(f'Adding output shape to {parent.render()} type: {input_typed_dict.name} | {output_typed_dict.name}')\n                    parent.replace_child(input_typed_dict, union_type_annotation)",
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render(self) -> str:\n        \"\"\"\n        Render attribute to use in function-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'{self.name}: {self.get_type_annotation().render()}'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\n    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required\n\n    def mark_as_required(self) -> None:\n        \"\"\"\n        Mark attribute as required.\n        \"\"\"\n        self.required = True\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether TypedDict usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render TypedDict usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n        return self.name\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        template = Path('common/typed_dict_class.py.jinja2') if self.is_safe_as_class else Path('common/typed_dict.py.jinja2')\n        return render_jinja2_template(template, {'type_def': self})\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return True\n\n    def has_required(self) -> bool:\n        \"\"\"\n        Whether TypedDict has required keys.\n        \"\"\"\n        return any((child.is_required() for child in self.children))\n\n    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of required attributes.\n        \"\"\"\n        return tuple((child for child in self.children if child.is_required()))\n\n    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of optional attributes.\n        \"\"\"\n        return tuple((child for child in self.children if not child.is_required()))\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, list(self.children), docstring=self.docstring, stringify=self.is_stringified())\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child.type_annotation for child in self.children if child.type_annotation.get_local_types()]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n        return self",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n    SELF_NAME: Final = 'self'\n    CLS_NAME: Final = 'cls'\n    KW_NAME: Final = '*'\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal['*', '**', ''] = prefix\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f' = {self.default.render()}' if self.default is not None else ''\n        if not self.type_annotation:\n            return f'{self.name}{default_suffix}'\n        return f'{self.name}: {self.type_annotation.render()}{default_suffix}'\n\n    @classmethod\n    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)\n\n    @classmethod\n    def kwflag(cls) -> Self:\n        \"\"\"\n        Create `*` keywords separator.\n        \"\"\"\n        return cls(name=cls.KW_NAME, type_annotation=None)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(name=self.name, type_annotation=self.type_annotation.copy() if self.type_annotation else None, default=self.default.copy() if self.default else None, prefix=self.prefix)",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError('Literal should have children')\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation('Literal').get_import_records()\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation('Literal').get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError('Use add_literal_child function.')\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path('common/literal.py.jinja2'), {'literal': self})"
  }
}