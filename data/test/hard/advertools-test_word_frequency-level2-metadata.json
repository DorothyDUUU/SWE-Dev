{
  "dir_path": "/app/advertools",
  "package_name": "advertools",
  "sample_name": "advertools-test_word_frequency",
  "src_dir": "advertools/",
  "test_dir": "tests/",
  "test_file": "tests/test_word_frequency.py",
  "test_code": "from advertools.word_frequency import word_frequency\n\n\ntext_list = [\n    'one two',\n    'one two  three',\n    'one-two-three',\n    'one_two_three',\n    'four five',\n    'four five',\n    'four six'\n]\n\nnum_list = [\n    100,\n    200,\n    300,\n    400,\n    500,\n    600,\n    700\n]\n\n\ndef test_rm_words_removed():\n    result = word_frequency(text_list, num_list, rm_words=['one', 'two'])\n    assert not result['word'].eq('one').any()\n    assert not result['word'].eq('two').any()\n\n\ndef test_extra_info_not_provided():\n    result = word_frequency(text_list, num_list, extra_info=False)\n    assert set(result.columns.values) == {'word', 'abs_freq', 'wtd_freq',\n                                          'rel_value'}\n\n\ndef test_extra_info_provided():\n    result = word_frequency(text_list, num_list, extra_info=True)\n    assert set(result.columns.values) == {'word', 'abs_freq', 'abs_perc',\n                                          'abs_perc_cum', 'wtd_freq',\n                                          'wtd_freq_perc', 'wtd_freq_perc_cum',\n                                          'rel_value'}\n\n\ndef test_works_fine_with_only_stopwords_supplied():\n    result = word_frequency(['on'], [3])\n    assert result.shape == (0, 4)\n\n\ndef test_works_without_numlist_provided():\n    result = word_frequency(['Great Text in a List', 'Greater text as well'])\n    assert result['word'].eq('text').any()\n\n\ndef test_word_freq_uses_regex():\n    result = word_frequency(['pizza burger', 'pizza sandwitch'], regex='pizza')\n    assert result['word'][0] == 'pizza'\n\n\ndef test_word_freq_returns_two_cols_if_not_num_list():\n    result = word_frequency(['pizza burger', 'pizza sandwitch'])\n    assert result.shape[1] == 2\n",
  "GT_file_code": {
    "advertools/word_frequency.py": "\"\"\"\n.. _word_frequency:\n\nText Analysis\n#############\n\nAbsolute and Weighted Word Count\n================================\n\nWhen analyzing a corpus of documents (I'll simply call it a text list), one of\nthe main tasks to accomplish to start text mining is to first count the words.\nWhile there are many text mining techniques and approaches, the\n:func:`word_frequency` function works mainly by counting words in a text list.\nA \"word\" is defined as a sequence of characters split by whitespace(s), and\nstripped of non-word characters (commas, dots, quotation marks, etc.).\nA \"word\" is actually a phrase consisting of one word, but you have the option\nof getting phrases that have two words, or more. This can be done simply\nby providing a value for the :attr:`phrase_len` parameter.\n\nAbsolute vs Weighted Frequency\n------------------------------\n\nIn social media reports, analytics, keyword reports, url and page reports, we\nget more information than simply the text. We get numbers describing those\nposts or page titles, or product names, or whatever the text list might\ncontain. Numbers can be pageviews, shares, likes, retweets, sales, bounces,\nsales, etc. Since we have numbers to quantify those phrases, we can improve our\ncounting by taking into consideration the number list that comes with the text\nlist.\n\nFor example, if you have an e-commerce site that has two products, let's say\nyou have bags and shoes, then your products are split 50:50 between bags and\nshoes.\nBut what if you learn that shoes generate 80% of your sales?\nAlthough shoes form half your products, they generate 80% of your revenue. So\nthe *weighted count* of your products is 80:20.\n\nLet's say two people post two different posts on a social media platform. One\nof them says, \"It's raining\", and the other says, \"It's snowing\". As in the\nabove example, the content is split 50:50 between \"raining\" and \"snowing\", but\nwe get a much more informative picture if we get the number of followers of\neach of those accounts (or the number of shares, likes, etc.). If one of them\nhas a thousand followers, and other has a million (which is typical on social\nmedia, as well as in pageviews report, e-commerce and most other datasets),\nthen you get a completely different picture about your dataset.\n\nThese two simple examples contain two posts, and a word each. The\n:func:`word_frequency` function can provide insight on hidden trends especially\nin large datasets, and when the sentences or phrases are also longer then a\nword or two each.\n\nLet's take a look at how to use the :func:`word_frequency` function, and what\nthe available parameters and options are.\n\n\n.. glossary::\n\n    text_list\n        The list of phrases or documents that you want to analyze. Here are\n        some possible ideas that you might use this for:\n\n            * keywords, whether in a PPC or SEO report\n            * page titles in an analytics report\n            * social media posts (tweets, Facebook posts, YouTube video titles\n              or descriptions etc.)\n            * e-commerce reports (where the text would be the product names)\n\n    num_list\n        Ideally, if you have more than one column describing :attr:`text_list`\n        you should experiment with different options. Try weighting the words\n        by pageviews, then try by bounce rate and see if you get different\n        interesting findings.\n        With e-commerce reports, you can see which word appears the most, and\n        which word is associated with more revenue.\n\n    phrase_len\n        You should also experiment with different lengths of phrases. In many\n        cases, one-word phrases might not be as meaningful as two-words or\n        three.\n\n    regex\n        The default is to simply split words by whitespace, and provide phrases\n        of length :attr:`phrase_len`.\n        But you may want to count the occurrences of certain patterns of text.\n        Check out the :ref:`regex <regex>` module for the available regular\n        expressions that might be interesting. Some of the pre-defined ones are\n        hashtags, mentions, questions, emoji, currencies, and more.\n\n    rm_words\n        A list of words to remove and ignore from the count. Known as\n        stop-words these are the most frequently used words in a language,\n        the most used, but don't add much meaning to the content (a, and, of,\n        the, if, etc.). By default a set of English stopwords is provided\n        (which you can check and possibly may want to modify), or run\n        ``adv.stopwords.keys()`` to get a list of all the available stopwords\n        in the available languages.\n        In some cases (like page titles for example), you might get \"words\"\n        that need to be removed as well, like the pipe \"|\" character for\n        example.\n\n    extra_info\n        The returned DataFrame contains the default columns\n        ``[word, abs_freq, wtd_freq, rel_value]``. You can get extra\n        columns for percentages and cumulative percentages that add perspective\n        to the other columns. Set this parameter to :attr:`True` if you want\n        that.\n\nBelow are all the columns of the returned DataFrame:\n\n=========================  ================================================\n:attr:`word`               Words in the document list each on its own row.\n                           The length of these words is determined by\n                           :attr:`phrase_len`, essentially phrases if\n                           containing more than one word each.\n:attr:`abs_freq`           The number of occurrences of each word in all\n                           the documents.\n:attr:`wtd_freq`           Every occurrence of :attr:`word` multiplied by\n                           its respective value in :attr:`num_list`.\n:attr:`rel_value`          :attr:`wtd_freq` divided by :attr:`abs_freq`,\n                           showing the value per occurrence of :attr:`word`\n:attr:`abs_perc`           Absolute frequency percentage.\n:attr:`abs_perc_cum`       Cumulative absolute percentage.\n:attr:`wtd_freq_perc`      Weighted frequency percentage.\n:attr:`wtd_freq_perc_cum`  Cumulative weighted frequency percentage.\n=========================  ================================================\n\n.. thebe-button::\n    Run this code\n\n.. code-block::\n    :class: thebe, thebe-init\n\n    import advertools as adv\n    import pandas as pd\n    tweets = pd.read_csv('data/tweets.csv')\n    tweets\n\n====  ================================================================================================================================================  =================\n  ..  tweet_text                                                                                                                                          followers_count\n====  ================================================================================================================================================  =================\n   0  @AERIALMAGZC @penguinnyyyyy you won't be afraid if I give you a real reason :D                                                                                  157\n   1  Vibing in the office to #Metallica when the boss is on a coffee break                                                                                          4687\n      #TheOffice https://t.co/U5vdYevvfe\n   2  I feel like Ann says she likes coffee and then gets drinks that are 99% sugar and 1% coffee https://t.co/HfuBV4v3aY                                             104\n   3  A venti iced coffee with four pumps of white mocha, sweet cream and caramel drizzle might just be my new favorite drink. Shout out to TikTok lol                126\n   4  I was never a coffee person until I had kids. \u2615\ufe0f this cup is a life saver. https://t.co/Zo0CnVuiGj                                                             1595\n   5  Who's excited about our next Coffee Chat? We know we are!\ud83e\udd73                                                                                                    5004\n\n      We're also adding Representative John Bradford to this lineup to discuss redistricting in the area. You won't want to miss it!\n\n      RSVP: https://t.co/R3YNJjJCUG\n      Join the meeting: https://t.co/Ho4Kx7ZZ24 https://t.co/KfPdR3hupY\n   6  he paid for my coffee= husband\ud83d\udc97                                                                                                                                165\n   7  It's nipply outside, and now I side too :)                                                                                                                        0\n      That sounds like blowjob in front of a fire and visit with coffee after :)\n      I'm still out of coffee\n      I could have green tea instead\n      Hahahahahahaha\n      I want to spend the morning pampering you ...\n   8  Good morning \ud83d\ude03\ud83c\udf1e\u2600\ufe0f I hope everyone has a great Tuesday morning. Enjoy your day and coffee \u2615\ufe0f \u2665\ufe0f\u2764\ufe0f\ud83d\udc95\ud83e\udd70\ud83d\ude18                                                           189\n   9  @MarvinMilton2 I nearly choked on my coffee \ud83e\udd2a                                                                                                                 1160\n====  ================================================================================================================================================  =================\n\n\n.. thebe-button::\n    Run this code\n\n.. code-block::\n    :class: thebe, thebe-init\n\n    word_freq = adv.word_frequency(text_list=tweets['tweet_text'],\n                                   num_list=tweets['followers_count'])\n\n    # try sorting by 'abs_freq', 'wtd_freq', and 'rel_value':\n    word_freq.sort_values(by='abs_freq', ascending=False).head(25)\n\n\"\"\"  # noqa: E501\n\nimport re\nfrom collections import defaultdict\n\nimport pandas as pd\n\nimport advertools as adv\nfrom advertools.word_tokenize import word_tokenize\n\n\ndef word_frequency(\n    text_list,\n    num_list=None,\n    phrase_len=1,\n    regex=None,\n    rm_words=adv.stopwords[\"english\"],\n    extra_info=False,\n):\n    \"\"\"Count the absolute as well as the weighted frequency of words\n    in :attr:`text_list` (based on :attr:`num_list`).\n\n    Parameters\n    ----------\n    text_list : list\n      Typically short phrases, but could be any list of full blown documents. Usually,\n      you would use this to analyze tweets, book titles, URLs, etc.\n    num_list : list\n      A list of numbers with the same length as :attr:`text_list`, describing a certain\n      attribute of these 'documents'; views, retweets, sales, etc.\n    regex : str\n      The regex used to split words. Doesn't need changing in most cases.\n    phrase_len : int\n      The length in words of each token the text is split into (ngrams), defaults to 1.\n    rm_words : set\n      Words to remove from the list a.k.a 'stop-words'. The default uses. To get all\n      available languages run ``adv.stopwords.keys()``.\n    extra_info : bool\n      Whether or not to give additional metrics about the frequencies.\n\n    Returns\n    -------\n    abs_wtd_df : pandas.DataFrame\n      Absolute and weighted counts DataFrame.\n\n    Examples\n    --------\n    >>> import advertools as adv\n    >>> text_list = ['apple orange', 'apple orange banana',\n    ...              'apple kiwi', 'kiwi mango']\n    >>> num_list = [100, 100, 100, 400]\n\n    >>> adv.word_frequency(text_list, num_list)\n         word  abs_freq  wtd_freq  rel_value\n    0    kiwi         2       500      250.0\n    1   mango         1       400      400.0\n    2   apple         3       300      100.0\n    3  orange         2       200      100.0\n    4  banana         1       100      100.0\n\n    Although \"kiwi\" occurred twice :attr:`abs_freq`, and \"apple\" occurred three\n    times, the phrases in which \"kiwi\" appear have a total score of 500,\n    so it beats \"apple\" on :attr:`wtd_freq` even though \"apple\" wins on\n    :attr:`abs_freq`. You can sort by any of the columns of course.\n    :attr:`rel_value` shows the value per occurrence of each word, as you can\n    see, it is simply obtained by dividing :attr:`wtd_freq` by\n    :attr:`abs_freq`.\n\n    >>> adv.word_frequency(text_list)  # num_list values default to 1 each\n         word  abs_freq  wtd_freq  rel_value\n    0   apple         3         3        1.0\n    1  orange         2         2        1.0\n    2    kiwi         2         2        1.0\n    3  banana         1         1        1.0\n    4   mango         1         1        1.0\n\n    >>> text_list2 = ['my favorite color is blue',\n    ... 'my favorite color is green', 'the best color is green',\n    ... 'i love the color black']\n\n    Setting :attr:`phrase_len` to 2, \"words\" become two-word phrases instead.\n    Note that we are setting :attr:`rm_words` to the empty list so we can keep\n    the stopwords and see if that makes sense:\n\n    >>> word_frequency(text_list2, phrase_len=2, rm_words=[])\n                  word  abs_freq  wtd_freq  rel_value\n    0         color is         3         3        1.0\n    1      my favorite         2         2        1.0\n    2   favorite color         2         2        1.0\n    3         is green         2         2        1.0\n    4          is blue         1         1        1.0\n    5         the best         1         1        1.0\n    6       best color         1         1        1.0\n    7           i love         1         1        1.0\n    8         love the         1         1        1.0\n    9        the color         1         1        1.0\n    10     color black         1         1        1.0\n\n    The same result as above showing all possible columns by setting\n    :attr:`extra_info` to :attr:`True`:\n\n    >>> adv.word_frequency(text_list, num_list, extra_info=True)\n         word  abs_freq  abs_perc  abs_perc_cum  wtd_freq  wtd_freq_perc  wtd_freq_perc_cum  rel_value\n    0    kiwi         2  0.222222      0.222222       500       0.333333           0.333333      250.0\n    1   mango         1  0.111111      0.333333       400       0.266667           0.600000      400.0\n    2   apple         3  0.333333      0.666667       300       0.200000           0.800000      100.0\n    3  orange         2  0.222222      0.888889       200       0.133333           0.933333      100.0\n    4  banana         1  0.111111      1.000000       100       0.066667           1.000000      100.0\n    \"\"\"  # noqa: E501\n    if num_list is None:\n        num_list = [1 for _ in range(len(text_list))]\n    if isinstance(regex, str):\n        regex = re.compile(regex)\n        text_list = [\" \".join(regex.findall(text)) for text in text_list]\n\n    word_freq = defaultdict(lambda: [0, 0])\n\n    for text, num in zip(word_tokenize(text_list, phrase_len=phrase_len), num_list):\n        for word in text:\n            if word.lower() in rm_words:\n                continue\n            word_freq[word.lower()][0] += 1\n            word_freq[word.lower()][1] += num\n\n    columns = [\"abs_freq\", \"wtd_freq\"]\n\n    abs_wtd_df = (\n        pd.DataFrame.from_dict(word_freq, orient=\"index\", columns=columns)\n        .sort_values(\"wtd_freq\", ascending=False)\n        .assign(rel_value=lambda df: df[\"wtd_freq\"] / df[\"abs_freq\"])\n        .round()\n    )\n    if extra_info:\n        abs_wtd_df.insert(\n            1, \"abs_perc\", value=abs_wtd_df[\"abs_freq\"] / abs_wtd_df[\"abs_freq\"].sum()\n        )\n        abs_wtd_df.insert(2, \"abs_perc_cum\", abs_wtd_df[\"abs_perc\"].cumsum())\n        abs_wtd_df.insert(\n            4, \"wtd_freq_perc\", abs_wtd_df[\"wtd_freq\"] / abs_wtd_df[\"wtd_freq\"].sum()\n        )\n        abs_wtd_df.insert(5, \"wtd_freq_perc_cum\", abs_wtd_df[\"wtd_freq_perc\"].cumsum())\n\n    abs_wtd_df = abs_wtd_df.reset_index().rename(columns={\"index\": \"word\"})\n    if set(num_list) == {1}:\n        abs_wtd_df = abs_wtd_df.drop([\"wtd_freq\", \"rel_value\"], axis=1)\n    return abs_wtd_df\n",
    "advertools/word_tokenize.py": "\"\"\"\n.. _word_tokenize:\n\nTokenize Words (N-grams)\n========================\n\nAs word counting is an essential step in any text mining task, you first have\nto split the text into words.\n\nThe :func:`word_tokenize` function achieves that by splitting the text by\nwhitespace. Another important thing it does after splitting is to trim the\nwords of any non-word characters (commas, dots, exclamation marks, etc.).\n\nYou also have the option of specifying the length of the words that you want.\nThe default is 2, which can be set through the :attr:`phrase_len` parameter.\n\nThis function is mainly a helper function for\n:ref:`word_frequency <word_frequency>` to help with counting words and/or\nphrases.\n\"\"\"\nfrom .regex import WORD_DELIM\n\n\ndef word_tokenize(text_list, phrase_len=2):\n    \"\"\"Split ``text_list`` into phrases of length ``phrase_len`` words each.\n\n    A \"word\" is any string between white spaces (or beginning or\n    end of string) with delimiters stripped from both sides.\n    Delimiters include quotes, question marks, parentheses, etc.\n    Any delimiter contained within the string remains. See examples below.\n\n    :param text_list: List of strings.\n    :param phrase_len: Length of word tokens, defaults to 2.\n    :return tokenized: List of lists, split according to :attr:`phrase_len`.\n\n    >>> t = ['split me into length-n-words',\n    ... 'commas, (parentheses) get removed!',\n    ... 'commas within text remain $1,000, but not the trailing commas.']\n\n    >>> word_tokenize(t, 1)\n    [['split', 'me', 'into', 'length-n-words'],\n    ['commas', 'parentheses', 'get', 'removed'],\n    ['commas', 'within', 'text', 'remain', '$1,000',\n    'but', 'not', 'the', 'trailing', 'commas']]\n\n\n    The comma inside \"$1,000\" as well as the dollar sign remain, as they\n    are part of the \"word\", but the trailing comma is stripped.\n\n    >>> word_tokenize(t, 2)\n    [['split me', 'me into', 'into length-n-words'],\n    ['commas parentheses', 'parentheses get', 'get removed'],\n    ['commas within', 'within text', 'text remain', 'remain $1,000',\n    '$1,000 but', 'but not', 'not the', 'the trailing', 'trailing commas']]\n\n\n    >>> word_tokenize(t, 3)\n    [['split me into', 'me into length-n-words'],\n    ['commas parentheses get', 'parentheses get removed'],\n    ['commas within text', 'within text remain', 'text remain $1,000',\n    'remain $1,000 but', '$1,000 but not', 'but not the',\n    'not the trailing', 'the trailing commas']]\n    \"\"\"\n    if isinstance(text_list, str):\n        text_list = [text_list]\n    split = [text.lower().split() for text in text_list]\n    split = [[word.strip(WORD_DELIM) for word in text] for text in split]\n\n    return [[' '.join(s[i:i + phrase_len])\n             for i in range(len(s) - phrase_len + 1)] for s in split]\n"
  },
  "GT_src_dict": {
    "advertools/word_frequency.py": {
      "word_frequency": {
        "code": "def word_frequency(text_list, num_list=None, phrase_len=1, regex=None, rm_words=adv.stopwords['english'], extra_info=False):\n    \"\"\"Count the absolute and weighted frequency of words in a given list of texts.\n\nThis function analyzes a list of phrases or documents, computing both absolute and weighted word frequencies based on an optional numerical list that quantifies attributes like views or sales associated with those texts.\n\nParameters\n----------\ntext_list : list\n    A list of short phrases or full documents to analyze.\nnum_list : list, optional\n    A list of numerical values (same length as `text_list`), representing quantitative attributes of each document; defaults to a list of ones if None.\nphrase_len : int, optional\n    The number of words to consider as a single token (n-gram); defaults to 1 for single words.\nregex : str, optional\n    A regular expression for splitting text into words; default is None, meaning standard whitespace splitting is used.\nrm_words : set, optional\n    A set of words to exclude from the analysis, typically stopwords; defaults to English stopwords defined in `adv.stopwords`.\nextra_info : bool, optional\n    If True, returns additional calculated metrics (percentages and cumulative percentages); defaults to False.\n\nReturns\n-------\nabs_wtd_df : pandas.DataFrame\n    A DataFrame containing the absolute frequencies (`abs_freq`), weighted frequencies (`wtd_freq`), and relative values per word, along with optional extra metrics if `extra_info` is True.\n\nDependencies\n------------\nThis function relies on the `advertools` library for stopwords and the `pandas` library for DataFrame operations. The `word_tokenize` function from `advertools.word_tokenize` is used to tokenize text based on the specified phrase length. \n\nConstants\n---------\n`adv.stopwords[\"english\"]`: The default set of English stopwords used to filter commonly used words that do not contribute meaningful content to the word frequencies.\"\"\"\n    'Count the absolute as well as the weighted frequency of words\\n    in :attr:`text_list` (based on :attr:`num_list`).\\n\\n    Parameters\\n    ----------\\n    text_list : list\\n      Typically short phrases, but could be any list of full blown documents. Usually,\\n      you would use this to analyze tweets, book titles, URLs, etc.\\n    num_list : list\\n      A list of numbers with the same length as :attr:`text_list`, describing a certain\\n      attribute of these \\'documents\\'; views, retweets, sales, etc.\\n    regex : str\\n      The regex used to split words. Doesn\\'t need changing in most cases.\\n    phrase_len : int\\n      The length in words of each token the text is split into (ngrams), defaults to 1.\\n    rm_words : set\\n      Words to remove from the list a.k.a \\'stop-words\\'. The default uses. To get all\\n      available languages run ``adv.stopwords.keys()``.\\n    extra_info : bool\\n      Whether or not to give additional metrics about the frequencies.\\n\\n    Returns\\n    -------\\n    abs_wtd_df : pandas.DataFrame\\n      Absolute and weighted counts DataFrame.\\n\\n    Examples\\n    --------\\n    >>> import advertools as adv\\n    >>> text_list = [\\'apple orange\\', \\'apple orange banana\\',\\n    ...              \\'apple kiwi\\', \\'kiwi mango\\']\\n    >>> num_list = [100, 100, 100, 400]\\n\\n    >>> adv.word_frequency(text_list, num_list)\\n         word  abs_freq  wtd_freq  rel_value\\n    0    kiwi         2       500      250.0\\n    1   mango         1       400      400.0\\n    2   apple         3       300      100.0\\n    3  orange         2       200      100.0\\n    4  banana         1       100      100.0\\n\\n    Although \"kiwi\" occurred twice :attr:`abs_freq`, and \"apple\" occurred three\\n    times, the phrases in which \"kiwi\" appear have a total score of 500,\\n    so it beats \"apple\" on :attr:`wtd_freq` even though \"apple\" wins on\\n    :attr:`abs_freq`. You can sort by any of the columns of course.\\n    :attr:`rel_value` shows the value per occurrence of each word, as you can\\n    see, it is simply obtained by dividing :attr:`wtd_freq` by\\n    :attr:`abs_freq`.\\n\\n    >>> adv.word_frequency(text_list)  # num_list values default to 1 each\\n         word  abs_freq  wtd_freq  rel_value\\n    0   apple         3         3        1.0\\n    1  orange         2         2        1.0\\n    2    kiwi         2         2        1.0\\n    3  banana         1         1        1.0\\n    4   mango         1         1        1.0\\n\\n    >>> text_list2 = [\\'my favorite color is blue\\',\\n    ... \\'my favorite color is green\\', \\'the best color is green\\',\\n    ... \\'i love the color black\\']\\n\\n    Setting :attr:`phrase_len` to 2, \"words\" become two-word phrases instead.\\n    Note that we are setting :attr:`rm_words` to the empty list so we can keep\\n    the stopwords and see if that makes sense:\\n\\n    >>> word_frequency(text_list2, phrase_len=2, rm_words=[])\\n                  word  abs_freq  wtd_freq  rel_value\\n    0         color is         3         3        1.0\\n    1      my favorite         2         2        1.0\\n    2   favorite color         2         2        1.0\\n    3         is green         2         2        1.0\\n    4          is blue         1         1        1.0\\n    5         the best         1         1        1.0\\n    6       best color         1         1        1.0\\n    7           i love         1         1        1.0\\n    8         love the         1         1        1.0\\n    9        the color         1         1        1.0\\n    10     color black         1         1        1.0\\n\\n    The same result as above showing all possible columns by setting\\n    :attr:`extra_info` to :attr:`True`:\\n\\n    >>> adv.word_frequency(text_list, num_list, extra_info=True)\\n         word  abs_freq  abs_perc  abs_perc_cum  wtd_freq  wtd_freq_perc  wtd_freq_perc_cum  rel_value\\n    0    kiwi         2  0.222222      0.222222       500       0.333333           0.333333      250.0\\n    1   mango         1  0.111111      0.333333       400       0.266667           0.600000      400.0\\n    2   apple         3  0.333333      0.666667       300       0.200000           0.800000      100.0\\n    3  orange         2  0.222222      0.888889       200       0.133333           0.933333      100.0\\n    4  banana         1  0.111111      1.000000       100       0.066667           1.000000      100.0\\n    '\n    if num_list is None:\n        num_list = [1 for _ in range(len(text_list))]\n    if isinstance(regex, str):\n        regex = re.compile(regex)\n        text_list = [' '.join(regex.findall(text)) for text in text_list]\n    word_freq = defaultdict(lambda: [0, 0])\n    for text, num in zip(word_tokenize(text_list, phrase_len=phrase_len), num_list):\n        for word in text:\n            if word.lower() in rm_words:\n                continue\n            word_freq[word.lower()][0] += 1\n            word_freq[word.lower()][1] += num\n    columns = ['abs_freq', 'wtd_freq']\n    abs_wtd_df = pd.DataFrame.from_dict(word_freq, orient='index', columns=columns).sort_values('wtd_freq', ascending=False).assign(rel_value=lambda df: df['wtd_freq'] / df['abs_freq']).round()\n    if extra_info:\n        abs_wtd_df.insert(1, 'abs_perc', value=abs_wtd_df['abs_freq'] / abs_wtd_df['abs_freq'].sum())\n        abs_wtd_df.insert(2, 'abs_perc_cum', abs_wtd_df['abs_perc'].cumsum())\n        abs_wtd_df.insert(4, 'wtd_freq_perc', abs_wtd_df['wtd_freq'] / abs_wtd_df['wtd_freq'].sum())\n        abs_wtd_df.insert(5, 'wtd_freq_perc_cum', abs_wtd_df['wtd_freq_perc'].cumsum())\n    abs_wtd_df = abs_wtd_df.reset_index().rename(columns={'index': 'word'})\n    if set(num_list) == {1}:\n        abs_wtd_df = abs_wtd_df.drop(['wtd_freq', 'rel_value'], axis=1)\n    return abs_wtd_df",
        "docstring": "Count the absolute and weighted frequency of words in a given list of texts.\n\nThis function analyzes a list of phrases or documents, computing both absolute and weighted word frequencies based on an optional numerical list that quantifies attributes like views or sales associated with those texts.\n\nParameters\n----------\ntext_list : list\n    A list of short phrases or full documents to analyze.\nnum_list : list, optional\n    A list of numerical values (same length as `text_list`), representing quantitative attributes of each document; defaults to a list of ones if None.\nphrase_len : int, optional\n    The number of words to consider as a single token (n-gram); defaults to 1 for single words.\nregex : str, optional\n    A regular expression for splitting text into words; default is None, meaning standard whitespace splitting is used.\nrm_words : set, optional\n    A set of words to exclude from the analysis, typically stopwords; defaults to English stopwords defined in `adv.stopwords`.\nextra_info : bool, optional\n    If True, returns additional calculated metrics (percentages and cumulative percentages); defaults to False.\n\nReturns\n-------\nabs_wtd_df : pandas.DataFrame\n    A DataFrame containing the absolute frequencies (`abs_freq`), weighted frequencies (`wtd_freq`), and relative values per word, along with optional extra metrics if `extra_info` is True.\n\nDependencies\n------------\nThis function relies on the `advertools` library for stopwords and the `pandas` library for DataFrame operations. The `word_tokenize` function from `advertools.word_tokenize` is used to tokenize text based on the specified phrase length. \n\nConstants\n---------\n`adv.stopwords[\"english\"]`: The default set of English stopwords used to filter commonly used words that do not contribute meaningful content to the word frequencies.",
        "signature": "def word_frequency(text_list, num_list=None, phrase_len=1, regex=None, rm_words=adv.stopwords['english'], extra_info=False):",
        "type": "Function",
        "class_signature": null
      }
    },
    "advertools/word_tokenize.py": {
      "word_tokenize": {
        "code": "def word_tokenize(text_list, phrase_len=2):\n    \"\"\"Split a list of strings into phrases of specified word length, removing non-word characters.\n\nThis function tokenizes the input `text_list` by splitting each string into words, stripping leading and trailing non-word characters as defined by the constant `WORD_DELIM`, which is imported from the `regex` module. It then groups these words into phrases of length `phrase_len`, with a default value of 2. \n\nParameters:\n- `text_list` (list of str): A list of strings to be tokenized or a single string.\n- `phrase_len` (int, optional): The number of words in each phrase, defaulting to 2.\n\nReturns:\n- list of list of str: A nested list where each inner list contains phrases formed from the original input, with the specified number of words.\n\nExamples:\n- For input `['hello world', 'this is a test']` with `phrase_len=1`, the output will be `[['hello', 'world'], ['this', 'is', 'a', 'test']]`.\n- For the same input with `phrase_len=2`, the output will be `[['hello world'], ['this is', 'is a', 'a test']]`.\"\"\"\n    'Split ``text_list`` into phrases of length ``phrase_len`` words each.\\n\\n    A \"word\" is any string between white spaces (or beginning or\\n    end of string) with delimiters stripped from both sides.\\n    Delimiters include quotes, question marks, parentheses, etc.\\n    Any delimiter contained within the string remains. See examples below.\\n\\n    :param text_list: List of strings.\\n    :param phrase_len: Length of word tokens, defaults to 2.\\n    :return tokenized: List of lists, split according to :attr:`phrase_len`.\\n\\n    >>> t = [\\'split me into length-n-words\\',\\n    ... \\'commas, (parentheses) get removed!\\',\\n    ... \\'commas within text remain $1,000, but not the trailing commas.\\']\\n\\n    >>> word_tokenize(t, 1)\\n    [[\\'split\\', \\'me\\', \\'into\\', \\'length-n-words\\'],\\n    [\\'commas\\', \\'parentheses\\', \\'get\\', \\'removed\\'],\\n    [\\'commas\\', \\'within\\', \\'text\\', \\'remain\\', \\'$1,000\\',\\n    \\'but\\', \\'not\\', \\'the\\', \\'trailing\\', \\'commas\\']]\\n\\n\\n    The comma inside \"$1,000\" as well as the dollar sign remain, as they\\n    are part of the \"word\", but the trailing comma is stripped.\\n\\n    >>> word_tokenize(t, 2)\\n    [[\\'split me\\', \\'me into\\', \\'into length-n-words\\'],\\n    [\\'commas parentheses\\', \\'parentheses get\\', \\'get removed\\'],\\n    [\\'commas within\\', \\'within text\\', \\'text remain\\', \\'remain $1,000\\',\\n    \\'$1,000 but\\', \\'but not\\', \\'not the\\', \\'the trailing\\', \\'trailing commas\\']]\\n\\n\\n    >>> word_tokenize(t, 3)\\n    [[\\'split me into\\', \\'me into length-n-words\\'],\\n    [\\'commas parentheses get\\', \\'parentheses get removed\\'],\\n    [\\'commas within text\\', \\'within text remain\\', \\'text remain $1,000\\',\\n    \\'remain $1,000 but\\', \\'$1,000 but not\\', \\'but not the\\',\\n    \\'not the trailing\\', \\'the trailing commas\\']]\\n    '\n    if isinstance(text_list, str):\n        text_list = [text_list]\n    split = [text.lower().split() for text in text_list]\n    split = [[word.strip(WORD_DELIM) for word in text] for text in split]\n    return [[' '.join(s[i:i + phrase_len]) for i in range(len(s) - phrase_len + 1)] for s in split]",
        "docstring": "Split a list of strings into phrases of specified word length, removing non-word characters.\n\nThis function tokenizes the input `text_list` by splitting each string into words, stripping leading and trailing non-word characters as defined by the constant `WORD_DELIM`, which is imported from the `regex` module. It then groups these words into phrases of length `phrase_len`, with a default value of 2. \n\nParameters:\n- `text_list` (list of str): A list of strings to be tokenized or a single string.\n- `phrase_len` (int, optional): The number of words in each phrase, defaulting to 2.\n\nReturns:\n- list of list of str: A nested list where each inner list contains phrases formed from the original input, with the specified number of words.\n\nExamples:\n- For input `['hello world', 'this is a test']` with `phrase_len=1`, the output will be `[['hello', 'world'], ['this', 'is', 'a', 'test']]`.\n- For the same input with `phrase_len=2`, the output will be `[['hello world'], ['this is', 'is a', 'a test']]`.",
        "signature": "def word_tokenize(text_list, phrase_len=2):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: advertools-test_word_frequency\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 advertools/\n    \u251c\u2500\u2500 word_frequency.py\n    \u2502   \u2514\u2500\u2500 word_frequency\n    \u2514\u2500\u2500 word_tokenize.py\n        \u2514\u2500\u2500 word_tokenize\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for generating and analyzing word frequency data from textual inputs, with optional numerical weights to influence frequency calculations. It enables users to process and clean text data by removing specific words, applying regular expressions for targeted analysis, and working with or without associated numerical values. The module calculates absolute and weighted frequencies, as well as additional statistical metrics when requested, offering flexibility and detailed insights into text. This tool addresses the need for efficient text analysis by simplifying the extraction of word frequencies and related metrics, making it valuable for tasks such as natural language processing, text mining, and data-driven linguistic analysis.\n\n## FILE 1: advertools/word_frequency.py\n\n- FUNCTION NAME: word_frequency\n  - SIGNATURE: def word_frequency(text_list, num_list=None, phrase_len=1, regex=None, rm_words=adv.stopwords['english'], extra_info=False):\n  - DOCSTRING: \n```python\n\"\"\"\nCount the absolute and weighted frequency of words in a given list of texts.\n\nThis function analyzes a list of phrases or documents, computing both absolute and weighted word frequencies based on an optional numerical list that quantifies attributes like views or sales associated with those texts.\n\nParameters\n----------\ntext_list : list\n    A list of short phrases or full documents to analyze.\nnum_list : list, optional\n    A list of numerical values (same length as `text_list`), representing quantitative attributes of each document; defaults to a list of ones if None.\nphrase_len : int, optional\n    The number of words to consider as a single token (n-gram); defaults to 1 for single words.\nregex : str, optional\n    A regular expression for splitting text into words; default is None, meaning standard whitespace splitting is used.\nrm_words : set, optional\n    A set of words to exclude from the analysis, typically stopwords; defaults to English stopwords defined in `adv.stopwords`.\nextra_info : bool, optional\n    If True, returns additional calculated metrics (percentages and cumulative percentages); defaults to False.\n\nReturns\n-------\nabs_wtd_df : pandas.DataFrame\n    A DataFrame containing the absolute frequencies (`abs_freq`), weighted frequencies (`wtd_freq`), and relative values per word, along with optional extra metrics if `extra_info` is True.\n\nDependencies\n------------\nThis function relies on the `advertools` library for stopwords and the `pandas` library for DataFrame operations. The `word_tokenize` function from `advertools.word_tokenize` is used to tokenize text based on the specified phrase length. \n\nConstants\n---------\n`adv.stopwords[\"english\"]`: The default set of English stopwords used to filter commonly used words that do not contribute meaningful content to the word frequencies.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - advertools/word_tokenize.py:word_tokenize\n\n## FILE 2: advertools/word_tokenize.py\n\n- FUNCTION NAME: word_tokenize\n  - SIGNATURE: def word_tokenize(text_list, phrase_len=2):\n  - DOCSTRING: \n```python\n\"\"\"\nSplit a list of strings into phrases of specified word length, removing non-word characters.\n\nThis function tokenizes the input `text_list` by splitting each string into words, stripping leading and trailing non-word characters as defined by the constant `WORD_DELIM`, which is imported from the `regex` module. It then groups these words into phrases of length `phrase_len`, with a default value of 2. \n\nParameters:\n- `text_list` (list of str): A list of strings to be tokenized or a single string.\n- `phrase_len` (int, optional): The number of words in each phrase, defaulting to 2.\n\nReturns:\n- list of list of str: A nested list where each inner list contains phrases formed from the original input, with the specified number of words.\n\nExamples:\n- For input `['hello world', 'this is a test']` with `phrase_len=1`, the output will be `[['hello', 'world'], ['this', 'is', 'a', 'test']]`.\n- For the same input with `phrase_len=2`, the output will be `[['hello world'], ['this is', 'is a', 'a test']]`.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - advertools/word_frequency.py:word_frequency\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "advertools/word_frequency.py": "\"\"\"\n.. _word_frequency:\n\nText Analysis\n#############\n\nAbsolute and Weighted Word Count\n================================\n\nWhen analyzing a corpus of documents (I'll simply call it a text list), one of\nthe main tasks to accomplish to start text mining is to first count the words.\nWhile there are many text mining techniques and approaches, the\n:func:`word_frequency` function works mainly by counting words in a text list.\nA \"word\" is defined as a sequence of characters split by whitespace(s), and\nstripped of non-word characters (commas, dots, quotation marks, etc.).\nA \"word\" is actually a phrase consisting of one word, but you have the option\nof getting phrases that have two words, or more. This can be done simply\nby providing a value for the :attr:`phrase_len` parameter.\n\nAbsolute vs Weighted Frequency\n------------------------------\n\nIn social media reports, analytics, keyword reports, url and page reports, we\nget more information than simply the text. We get numbers describing those\nposts or page titles, or product names, or whatever the text list might\ncontain. Numbers can be pageviews, shares, likes, retweets, sales, bounces,\nsales, etc. Since we have numbers to quantify those phrases, we can improve our\ncounting by taking into consideration the number list that comes with the text\nlist.\n\nFor example, if you have an e-commerce site that has two products, let's say\nyou have bags and shoes, then your products are split 50:50 between bags and\nshoes.\nBut what if you learn that shoes generate 80% of your sales?\nAlthough shoes form half your products, they generate 80% of your revenue. So\nthe *weighted count* of your products is 80:20.\n\nLet's say two people post two different posts on a social media platform. One\nof them says, \"It's raining\", and the other says, \"It's snowing\". As in the\nabove example, the content is split 50:50 between \"raining\" and \"snowing\", but\nwe get a much more informative picture if we get the number of followers of\neach of those accounts (or the number of shares, likes, etc.). If one of them\nhas a thousand followers, and other has a million (which is typical on social\nmedia, as well as in pageviews report, e-commerce and most other datasets),\nthen you get a completely different picture about your dataset.\n\nThese two simple examples contain two posts, and a word each. The\n:func:`word_frequency` function can provide insight on hidden trends especially\nin large datasets, and when the sentences or phrases are also longer then a\nword or two each.\n\nLet's take a look at how to use the :func:`word_frequency` function, and what\nthe available parameters and options are.\n\n\n.. glossary::\n\n    text_list\n        The list of phrases or documents that you want to analyze. Here are\n        some possible ideas that you might use this for:\n\n            * keywords, whether in a PPC or SEO report\n            * page titles in an analytics report\n            * social media posts (tweets, Facebook posts, YouTube video titles\n              or descriptions etc.)\n            * e-commerce reports (where the text would be the product names)\n\n    num_list\n        Ideally, if you have more than one column describing :attr:`text_list`\n        you should experiment with different options. Try weighting the words\n        by pageviews, then try by bounce rate and see if you get different\n        interesting findings.\n        With e-commerce reports, you can see which word appears the most, and\n        which word is associated with more revenue.\n\n    phrase_len\n        You should also experiment with different lengths of phrases. In many\n        cases, one-word phrases might not be as meaningful as two-words or\n        three.\n\n    regex\n        The default is to simply split words by whitespace, and provide phrases\n        of length :attr:`phrase_len`.\n        But you may want to count the occurrences of certain patterns of text.\n        Check out the :ref:`regex <regex>` module for the available regular\n        expressions that might be interesting. Some of the pre-defined ones are\n        hashtags, mentions, questions, emoji, currencies, and more.\n\n    rm_words\n        A list of words to remove and ignore from the count. Known as\n        stop-words these are the most frequently used words in a language,\n        the most used, but don't add much meaning to the content (a, and, of,\n        the, if, etc.). By default a set of English stopwords is provided\n        (which you can check and possibly may want to modify), or run\n        ``adv.stopwords.keys()`` to get a list of all the available stopwords\n        in the available languages.\n        In some cases (like page titles for example), you might get \"words\"\n        that need to be removed as well, like the pipe \"|\" character for\n        example.\n\n    extra_info\n        The returned DataFrame contains the default columns\n        ``[word, abs_freq, wtd_freq, rel_value]``. You can get extra\n        columns for percentages and cumulative percentages that add perspective\n        to the other columns. Set this parameter to :attr:`True` if you want\n        that.\n\nBelow are all the columns of the returned DataFrame:\n\n=========================  ================================================\n:attr:`word`               Words in the document list each on its own row.\n                           The length of these words is determined by\n                           :attr:`phrase_len`, essentially phrases if\n                           containing more than one word each.\n:attr:`abs_freq`           The number of occurrences of each word in all\n                           the documents.\n:attr:`wtd_freq`           Every occurrence of :attr:`word` multiplied by\n                           its respective value in :attr:`num_list`.\n:attr:`rel_value`          :attr:`wtd_freq` divided by :attr:`abs_freq`,\n                           showing the value per occurrence of :attr:`word`\n:attr:`abs_perc`           Absolute frequency percentage.\n:attr:`abs_perc_cum`       Cumulative absolute percentage.\n:attr:`wtd_freq_perc`      Weighted frequency percentage.\n:attr:`wtd_freq_perc_cum`  Cumulative weighted frequency percentage.\n=========================  ================================================\n\n.. thebe-button::\n    Run this code\n\n.. code-block::\n    :class: thebe, thebe-init\n\n    import advertools as adv\n    import pandas as pd\n    tweets = pd.read_csv('data/tweets.csv')\n    tweets\n\n====  ================================================================================================================================================  =================\n  ..  tweet_text                                                                                                                                          followers_count\n====  ================================================================================================================================================  =================\n   0  @AERIALMAGZC @penguinnyyyyy you won't be afraid if I give you a real reason :D                                                                                  157\n   1  Vibing in the office to #Metallica when the boss is on a coffee break                                                                                          4687\n      #TheOffice https://t.co/U5vdYevvfe\n   2  I feel like Ann says she likes coffee and then gets drinks that are 99% sugar and 1% coffee https://t.co/HfuBV4v3aY                                             104\n   3  A venti iced coffee with four pumps of white mocha, sweet cream and caramel drizzle might just be my new favorite drink. Shout out to TikTok lol                126\n   4  I was never a coffee person until I had kids. \u2615\ufe0f this cup is a life saver. https://t.co/Zo0CnVuiGj                                                             1595\n   5  Who's excited about our next Coffee Chat? We know we are!\ud83e\udd73                                                                                                    5004\n\n      We're also adding Representative John Bradford to this lineup to discuss redistricting in the area. You won't want to miss it!\n\n      RSVP: https://t.co/R3YNJjJCUG\n      Join the meeting: https://t.co/Ho4Kx7ZZ24 https://t.co/KfPdR3hupY\n   6  he paid for my coffee= husband\ud83d\udc97                                                                                                                                165\n   7  It's nipply outside, and now I side too :)                                                                                                                        0\n      That sounds like blowjob in front of a fire and visit with coffee after :)\n      I'm still out of coffee\n      I could have green tea instead\n      Hahahahahahaha\n      I want to spend the morning pampering you ...\n   8  Good morning \ud83d\ude03\ud83c\udf1e\u2600\ufe0f I hope everyone has a great Tuesday morning. Enjoy your day and coffee \u2615\ufe0f \u2665\ufe0f\u2764\ufe0f\ud83d\udc95\ud83e\udd70\ud83d\ude18                                                           189\n   9  @MarvinMilton2 I nearly choked on my coffee \ud83e\udd2a                                                                                                                 1160\n====  ================================================================================================================================================  =================\n\n\n.. thebe-button::\n    Run this code\n\n.. code-block::\n    :class: thebe, thebe-init\n\n    word_freq = adv.word_frequency(text_list=tweets['tweet_text'],\n                                   num_list=tweets['followers_count'])\n\n    # try sorting by 'abs_freq', 'wtd_freq', and 'rel_value':\n    word_freq.sort_values(by='abs_freq', ascending=False).head(25)\n\n\"\"\"\nimport re\nfrom collections import defaultdict\nimport pandas as pd\nimport advertools as adv\nfrom advertools.word_tokenize import word_tokenize",
    "advertools/word_tokenize.py": "\"\"\"\n.. _word_tokenize:\n\nTokenize Words (N-grams)\n========================\n\nAs word counting is an essential step in any text mining task, you first have\nto split the text into words.\n\nThe :func:`word_tokenize` function achieves that by splitting the text by\nwhitespace. Another important thing it does after splitting is to trim the\nwords of any non-word characters (commas, dots, exclamation marks, etc.).\n\nYou also have the option of specifying the length of the words that you want.\nThe default is 2, which can be set through the :attr:`phrase_len` parameter.\n\nThis function is mainly a helper function for\n:ref:`word_frequency <word_frequency>` to help with counting words and/or\nphrases.\n\"\"\"\nfrom .regex import WORD_DELIM"
  },
  "call_tree": {
    "tests/test_word_frequency.py:test_rm_words_removed": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_extra_info_not_provided": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_extra_info_provided": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_works_fine_with_only_stopwords_supplied": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_works_without_numlist_provided": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_word_freq_uses_regex": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    },
    "tests/test_word_frequency.py:test_word_freq_returns_two_cols_if_not_num_list": {
      "advertools/word_frequency.py:word_frequency": {
        "advertools/word_tokenize.py:word_tokenize": {}
      }
    }
  }
}