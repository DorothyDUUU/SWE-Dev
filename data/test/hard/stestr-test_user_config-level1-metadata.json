{
  "dir_path": "/app/stestr",
  "package_name": "stestr",
  "sample_name": "stestr-test_user_config",
  "src_dir": "stestr/",
  "test_dir": "stestr/tests/",
  "test_file": "modified_testcases/test_user_config.py",
  "test_code": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport io\nimport os\nfrom unittest import mock\n\nfrom stestr.tests import base\nfrom stestr import user_config\n\nFULL_YAML = \"\"\"\nrun:\n  concurrency: 42 # This can be any integer value\n  random: True\n  no-subunit-trace: True\n  color: True\n  abbreviate: True\n  slowest: True\n  suppress-attachments: True\n  all-attachments: True\nfailing:\n  list: True\nlast:\n  no-subunit-trace: True\n  color: True\n  suppress-attachments: True\n  all-attachments: True\nload:\n  force-init: True\n  subunit-trace: True\n  color: True\n  abbreviate: True\n  suppress-attachments: True\n  all-attachments: True\nhistory-list:\n  show-metadata: True\nhistory-show:\n  no-subunit-trace: True\n  color: True\n  suppress-attachments: True\n  all-attachments: True\n\"\"\"\n\nINVALID_YAML_FIELD = \"\"\"\nrun:\n  color: True,\n\"\"\"\n\nYAML_NOT_INT = \"\"\"\nrun:\n  concurrency: Two\n\"\"\"\n\n\nclass TestUserConfig(base.TestCase):\n    def setUp(self):\n        super().setUp()\n        home_dir = os.path.expanduser(\"~\")\n        self.xdg_path = os.path.join(os.path.join(home_dir, \".config\"), \"stestr.yaml\")\n        self.home_path = os.path.join(home_dir, \".stestr.yaml\")\n\n    @mock.patch(\"sys.exit\")\n    @mock.patch(\"stestr.user_config.UserConfig\")\n    def test_get_user_config_invalid_path(self, user_mock, exit_mock):\n        user_config.get_user_config(\"/i_am_an_invalid_path\")\n        msg = \"The specified stestr user config is not a valid path\"\n        exit_mock.assert_called_once_with(msg)\n\n    @mock.patch(\"os.path.isfile\")\n    @mock.patch(\"stestr.user_config.UserConfig\")\n    def test_get_user_config_xdg_file(self, user_mock, path_mock):\n        def fake_isfile(path):\n            if path == self.xdg_path:\n                return True\n            else:\n                return False\n\n        path_mock.side_effect = fake_isfile\n        user_config.get_user_config()\n        user_mock.assert_called_once_with(self.xdg_path)\n\n    @mock.patch(\"os.path.isfile\")\n    @mock.patch(\"stestr.user_config.UserConfig\")\n    def test_get_default_user_config_file(self, user_mock, path_mock):\n        def fake_isfile(path):\n            if path == self.home_path:\n                return True\n            else:\n                return False\n\n        path_mock.side_effect = fake_isfile\n        user_config.get_user_config()\n        user_mock.assert_called_once_with(self.home_path)\n\n    @mock.patch(\"yaml.safe_load\", return_value={})\n    @mock.patch(\"builtins.open\", mock.mock_open())\n    def test_user_config_empty_schema(self, yaml_mock):\n        user_conf = user_config.UserConfig(\"/path\")\n        self.assertEqual({}, user_conf.config)\n\n    @mock.patch(\"yaml.safe_load\", return_value={\"init\": {\"subunit-trace\": True}})\n    @mock.patch(\"sys.exit\")\n    @mock.patch(\"builtins.open\", mock.mock_open())\n    def test_user_config_invalid_command(self, exit_mock, yaml_mock):\n        user_config.UserConfig(\"/path\")\n        error_string = (\n            \"Provided user config file /path is invalid because:\\n\"\n            \"extra keys not allowed @ data['init']\"\n        )\n        exit_mock.assert_called_once_with(error_string)\n\n    @mock.patch(\"yaml.safe_load\", return_value={\"run\": {\"subunit-trace\": True}})\n    @mock.patch(\"sys.exit\")\n    @mock.patch(\"builtins.open\", mock.mock_open())\n    def test_user_config_invalid_option(self, exit_mock, yaml_mock):\n        user_config.UserConfig(\"/path\")\n        error_string = (\n            \"Provided user config file /path is invalid because:\\n\"\n            \"extra keys not allowed @ \"\n            \"data['run']['subunit-trace']\"\n        )\n        exit_mock.assert_called_once_with(error_string)\n\n    @mock.patch(\"builtins.open\", return_value=io.BytesIO(FULL_YAML.encode(\"utf-8\")))\n    def test_user_config_full_config(self, open_mock):\n        user_conf = user_config.UserConfig(\"/path\")\n        full_dict = {\n            \"run\": {\n                \"concurrency\": 42,\n                \"random\": True,\n                \"no-subunit-trace\": True,\n                \"color\": True,\n                \"abbreviate\": True,\n                \"slowest\": True,\n                \"suppress-attachments\": True,\n                \"all-attachments\": True,\n            },\n            \"failing\": {\"list\": True},\n            \"last\": {\n                \"no-subunit-trace\": True,\n                \"color\": True,\n                \"suppress-attachments\": True,\n                \"all-attachments\": True,\n            },\n            \"load\": {\n                \"force-init\": True,\n                \"subunit-trace\": True,\n                \"color\": True,\n                \"abbreviate\": True,\n                \"suppress-attachments\": True,\n                \"all-attachments\": True,\n            },\n            \"history-list\": {\"show-metadata\": True},\n            \"history-show\": {\n                \"no-subunit-trace\": True,\n                \"color\": True,\n                \"suppress-attachments\": True,\n                \"all-attachments\": True,\n            },\n        }\n        self.assertEqual(full_dict, user_conf.config)\n\n    @mock.patch(\"sys.exit\")\n    @mock.patch(\n        \"builtins.open\", return_value=io.BytesIO(INVALID_YAML_FIELD.encode(\"utf-8\"))\n    )\n    def test_user_config_invalid_value_type(self, open_mock, exit_mock):\n        user_config.UserConfig(\"/path\")\n        error_string = (\n            \"Provided user config file /path is invalid because:\\n\"\n            \"expected bool for dictionary value @ \"\n            \"data['run']['color']\"\n        )\n        exit_mock.assert_called_once_with(error_string)\n\n    @mock.patch(\"sys.exit\")\n    @mock.patch(\"builtins.open\", return_value=io.BytesIO(YAML_NOT_INT.encode(\"utf-8\")))\n    def test_user_config_invalid_integer(self, open_mock, exit_mock):\n        user_config.UserConfig(\"/path\")\n        error_string = (\n            \"Provided user config file /path is invalid because:\\n\"\n            \"expected int for dictionary value @ \"\n            \"data['run']['concurrency']\"\n        )\n        exit_mock.assert_called_once_with(error_string)\n",
  "GT_file_code": {
    "stestr/user_config.py": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport os\nimport sys\n\nimport voluptuous as vp\nimport yaml\n\n\ndef get_user_config(path=None):\n    if not path:\n        home_dir = os.path.expanduser(\"~\")\n        path = os.path.join(home_dir, \".stestr.yaml\")\n        if not os.path.isfile(path):\n            path = os.path.join(os.path.join(home_dir, \".config\"), \"stestr.yaml\")\n            if not os.path.isfile(path):\n                path = None\n        if not path:\n            return None\n    else:\n        if not os.path.isfile(path):\n            msg = \"The specified stestr user config is not a valid path\"\n            sys.exit(msg)\n\n    return UserConfig(path)\n\n\nclass UserConfig:\n    def __init__(self, path):\n        self.schema = vp.Schema(\n            {\n                vp.Optional(\"run\"): {\n                    vp.Optional(\"concurrency\"): int,\n                    vp.Optional(\"random\"): bool,\n                    vp.Optional(\"no-subunit-trace\"): bool,\n                    vp.Optional(\"color\"): bool,\n                    vp.Optional(\"abbreviate\"): bool,\n                    vp.Optional(\"slowest\"): bool,\n                    vp.Optional(\"suppress-attachments\"): bool,\n                    vp.Optional(\"all-attachments\"): bool,\n                },\n                vp.Optional(\"failing\"): {\n                    vp.Optional(\"list\"): bool,\n                },\n                vp.Optional(\"last\"): {\n                    vp.Optional(\"no-subunit-trace\"): bool,\n                    vp.Optional(\"color\"): bool,\n                    vp.Optional(\"suppress-attachments\"): bool,\n                    vp.Optional(\"all-attachments\"): bool,\n                },\n                vp.Optional(\"load\"): {\n                    vp.Optional(\"force-init\"): bool,\n                    vp.Optional(\"subunit-trace\"): bool,\n                    vp.Optional(\"color\"): bool,\n                    vp.Optional(\"abbreviate\"): bool,\n                    vp.Optional(\"suppress-attachments\"): bool,\n                    vp.Optional(\"all-attachments\"): bool,\n                },\n                vp.Optional(\"history-list\"): {\n                    vp.Optional(\"show-metadata\"): bool,\n                },\n                vp.Optional(\"history-show\"): {\n                    vp.Optional(\"no-subunit-trace\"): bool,\n                    vp.Optional(\"color\"): bool,\n                    vp.Optional(\"suppress-attachments\"): bool,\n                    vp.Optional(\"all-attachments\"): bool,\n                },\n            }\n        )\n        with open(path) as fd:\n            self.config = yaml.safe_load(fd.read())\n        if self.config is None:\n            self.config = {}\n        try:\n            self.schema(self.config)\n        except vp.MultipleInvalid as e:\n            msg = \"Provided user config file {} is invalid \" \"because:\\n{}\".format(\n                path, str(e)\n            )\n            sys.exit(msg)\n\n    @property\n    def run(self):\n        return self.config.get(\"run\")\n\n    @property\n    def failing(self):\n        return self.config.get(\"failing\")\n\n    @property\n    def last(self):\n        return self.config.get(\"last\")\n\n    @property\n    def load(self):\n        return self.config.get(\"load\")\n\n    @property\n    def history_list(self):\n        return self.config.get(\"history-list\")\n\n    @property\n    def history_show(self):\n        return self.config.get(\"history-show\")\n"
  },
  "GT_src_dict": {
    "stestr/user_config.py": {
      "get_user_config": {
        "code": "def get_user_config(path=None):\n    \"\"\"Retrieve the user configuration for 'stestr' from a specified path or default locations.\n\nParameters:\n    path (str, optional): The file path to the user config YAML file. If not provided, the function checks for default paths\n                          in the user's home directory. The first preferred path is ~/.stestr.yaml, followed by\n                          ~/.config/stestr.yaml.\n\nReturns:\n    UserConfig: An instance of the UserConfig class initialized with the configuration from the specified path.\n\nRaises:\n    SystemExit: If the specified path is invalid or if no configuration file is found at the default locations.\n\nDependencies:\n    This function relies on the 'UserConfig' class which validates and parses the YAML configuration file using the \n    'voluptuous' library for schema validation and the 'yaml' library for YAML parsing. If the configuration schema is \n    invalid, an error message will be displayed, and the program will exit.\"\"\"\n    if not path:\n        home_dir = os.path.expanduser('~')\n        path = os.path.join(home_dir, '.stestr.yaml')\n        if not os.path.isfile(path):\n            path = os.path.join(os.path.join(home_dir, '.config'), 'stestr.yaml')\n            if not os.path.isfile(path):\n                path = None\n        if not path:\n            return None\n    elif not os.path.isfile(path):\n        msg = 'The specified stestr user config is not a valid path'\n        sys.exit(msg)\n    return UserConfig(path)",
        "docstring": "Retrieve the user configuration for 'stestr' from a specified path or default locations.\n\nParameters:\n    path (str, optional): The file path to the user config YAML file. If not provided, the function checks for default paths\n                          in the user's home directory. The first preferred path is ~/.stestr.yaml, followed by\n                          ~/.config/stestr.yaml.\n\nReturns:\n    UserConfig: An instance of the UserConfig class initialized with the configuration from the specified path.\n\nRaises:\n    SystemExit: If the specified path is invalid or if no configuration file is found at the default locations.\n\nDependencies:\n    This function relies on the 'UserConfig' class which validates and parses the YAML configuration file using the \n    'voluptuous' library for schema validation and the 'yaml' library for YAML parsing. If the configuration schema is \n    invalid, an error message will be displayed, and the program will exit.",
        "signature": "def get_user_config(path=None):",
        "type": "Function",
        "class_signature": null
      },
      "UserConfig.__init__": {
        "code": "    def __init__(self, path):\n        \"\"\"Initializes a UserConfig instance by loading the configuration from a specified YAML file path.\n\nParameters:\n- path (str): The file system path to the user configuration YAML file. If the path is invalid or the file does not exist, the program will terminate with an error message.\n\nAttributes:\n- schema (Schema): A Voluptuous schema that defines the expected structure and types of the configuration options.\n- config (dict): A dictionary containing the loaded configuration values. If the file is empty or invalid, this will default to an empty dictionary.\n\nSide Effects:\n- The constructor validates the loaded configuration against the defined schema. If the configuration is invalid, the program will output an error message and exit.\n\nDependencies:\n- Requires the 'voluptuous' library for schema validation.\n- Requires the 'yaml' library for loading .yaml files.\"\"\"\n        self.schema = vp.Schema({vp.Optional('run'): {vp.Optional('concurrency'): int, vp.Optional('random'): bool, vp.Optional('no-subunit-trace'): bool, vp.Optional('color'): bool, vp.Optional('abbreviate'): bool, vp.Optional('slowest'): bool, vp.Optional('suppress-attachments'): bool, vp.Optional('all-attachments'): bool}, vp.Optional('failing'): {vp.Optional('list'): bool}, vp.Optional('last'): {vp.Optional('no-subunit-trace'): bool, vp.Optional('color'): bool, vp.Optional('suppress-attachments'): bool, vp.Optional('all-attachments'): bool}, vp.Optional('load'): {vp.Optional('force-init'): bool, vp.Optional('subunit-trace'): bool, vp.Optional('color'): bool, vp.Optional('abbreviate'): bool, vp.Optional('suppress-attachments'): bool, vp.Optional('all-attachments'): bool}, vp.Optional('history-list'): {vp.Optional('show-metadata'): bool}, vp.Optional('history-show'): {vp.Optional('no-subunit-trace'): bool, vp.Optional('color'): bool, vp.Optional('suppress-attachments'): bool, vp.Optional('all-attachments'): bool}})\n        with open(path) as fd:\n            self.config = yaml.safe_load(fd.read())\n        if self.config is None:\n            self.config = {}\n        try:\n            self.schema(self.config)\n        except vp.MultipleInvalid as e:\n            msg = 'Provided user config file {} is invalid because:\\n{}'.format(path, str(e))\n            sys.exit(msg)",
        "docstring": "Initializes a UserConfig instance by loading the configuration from a specified YAML file path.\n\nParameters:\n- path (str): The file system path to the user configuration YAML file. If the path is invalid or the file does not exist, the program will terminate with an error message.\n\nAttributes:\n- schema (Schema): A Voluptuous schema that defines the expected structure and types of the configuration options.\n- config (dict): A dictionary containing the loaded configuration values. If the file is empty or invalid, this will default to an empty dictionary.\n\nSide Effects:\n- The constructor validates the loaded configuration against the defined schema. If the configuration is invalid, the program will output an error message and exit.\n\nDependencies:\n- Requires the 'voluptuous' library for schema validation.\n- Requires the 'yaml' library for loading .yaml files.",
        "signature": "def __init__(self, path):",
        "type": "Method",
        "class_signature": "class UserConfig:"
      }
    }
  },
  "dependency_dict": {
    "stestr/user_config.py:get_user_config": {}
  },
  "PRD": "# PROJECT NAME: stestr-test_user_config\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 stestr/\n    \u2514\u2500\u2500 user_config.py\n        \u251c\u2500\u2500 UserConfig.__init__\n        \u2514\u2500\u2500 get_user_config\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is responsible for managing and validating user configuration files for the `stestr` testing framework. It provides functionality to locate and load user configuration files from predefined paths, parse and validate the YAML-based configuration schema, and expose the structured configuration data for use within the application. Additionally, the module identifies and reports invalid configurations, such as incorrect data types or unsupported fields, to ensure users provide syntactically and semantically correct settings. This addresses the problem of managing complex test execution settings in a consistent and user-friendly manner, reducing errors and enabling greater customization of the testing process.\n\n## FILE 1: stestr/user_config.py\n\n- CLASS METHOD: UserConfig.__init__\n  - CLASS SIGNATURE: class UserConfig:\n  - SIGNATURE: def __init__(self, path):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a UserConfig instance by loading the configuration from a specified YAML file path.\n\nParameters:\n- path (str): The file system path to the user configuration YAML file. If the path is invalid or the file does not exist, the program will terminate with an error message.\n\nAttributes:\n- schema (Schema): A Voluptuous schema that defines the expected structure and types of the configuration options.\n- config (dict): A dictionary containing the loaded configuration values. If the file is empty or invalid, this will default to an empty dictionary.\n\nSide Effects:\n- The constructor validates the loaded configuration against the defined schema. If the configuration is invalid, the program will output an error message and exit.\n\nDependencies:\n- Requires the 'voluptuous' library for schema validation.\n- Requires the 'yaml' library for loading .yaml files.\n\"\"\"\n```\n\n- FUNCTION NAME: get_user_config\n  - SIGNATURE: def get_user_config(path=None):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the user configuration for 'stestr' from a specified path or default locations.\n\nParameters:\n    path (str, optional): The file path to the user config YAML file. If not provided, the function checks for default paths\n                          in the user's home directory. The first preferred path is ~/.stestr.yaml, followed by\n                          ~/.config/stestr.yaml.\n\nReturns:\n    UserConfig: An instance of the UserConfig class initialized with the configuration from the specified path.\n\nRaises:\n    SystemExit: If the specified path is invalid or if no configuration file is found at the default locations.\n\nDependencies:\n    This function relies on the 'UserConfig' class which validates and parses the YAML configuration file using the \n    'voluptuous' library for schema validation and the 'yaml' library for YAML parsing. If the configuration schema is \n    invalid, an error message will be displayed, and the program will exit.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - modified_testcases/test_user_config.py:TestUserConfig:fake_isfile\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "stestr/user_config.py": "import os\nimport sys\nimport voluptuous as vp\nimport yaml\n\nclass UserConfig:\n\n    @property\n    def run(self):\n        return self.config.get('run')\n\n    @property\n    def failing(self):\n        return self.config.get('failing')\n\n    @property\n    def last(self):\n        return self.config.get('last')\n\n    @property\n    def load(self):\n        return self.config.get('load')\n\n    @property\n    def history_list(self):\n        return self.config.get('history-list')\n\n    @property\n    def history_show(self):\n        return self.config.get('history-show')"
  },
  "call_tree": {
    "modified_testcases/test_user_config.py:TestUserConfig:setUp": {
      "stestr/tests/base.py:TestCase:setUp": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_get_default_user_config_file": {
      "stestr/user_config.py:get_user_config": {
        "modified_testcases/test_user_config.py:TestUserConfig:fake_isfile": {}
      }
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_get_user_config_invalid_path": {
      "stestr/user_config.py:get_user_config": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_get_user_config_xdg_file": {
      "stestr/user_config.py:get_user_config": {
        "modified_testcases/test_user_config.py:TestUserConfig:fake_isfile": {}
      }
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_empty_schema": {
      "stestr/user_config.py:UserConfig:__init__": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_full_config": {
      "stestr/user_config.py:UserConfig:__init__": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_invalid_command": {
      "stestr/user_config.py:UserConfig:__init__": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_invalid_integer": {
      "stestr/user_config.py:UserConfig:__init__": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_invalid_option": {
      "stestr/user_config.py:UserConfig:__init__": {}
    },
    "modified_testcases/test_user_config.py:TestUserConfig:test_user_config_invalid_value_type": {
      "stestr/user_config.py:UserConfig:__init__": {}
    }
  }
}