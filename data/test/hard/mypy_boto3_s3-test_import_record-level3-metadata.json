{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_record",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_record.py",
  "test_code": "from mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportRecord:\n    def test_str(self) -> None:\n        source = ImportString(\"source\")\n        assert str(ImportRecord(source, \"name\", \"alias\")) == \"from source import name as alias\"\n        assert str(ImportRecord(source, alias=\"alias\")) == \"import source as alias\"\n        assert str(ImportRecord(source, \"name\")) == \"from source import name\"\n        assert str(ImportRecord(source)) == \"import source\"\n\n    def test_operations(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source, \"name\", \"alias\")\n        assert hash(ImportRecord(source, \"name\")) == hash(ImportRecord(source, \"name\"))\n        assert hash(ImportRecord(source, \"name\")) != hash(ImportRecord(source, \"name2\"))\n        assert ImportRecord(source, \"name\") == ImportRecord(source, \"name\")\n        assert ImportRecord(source, \"name\") != ImportRecord(source, \"name2\")\n        assert ImportRecord(source, \"name\") != \"test\"\n\n    def test_comparison(self) -> None:\n        local_source = ImportString(\"mypy_boto3_s3\")\n        third_party_source = ImportString(\"boto3\")\n        other_source = ImportString(\"other\")\n        assert ImportRecord(local_source, \"test\") > ImportRecord(local_source, \"name\")\n        assert ImportRecord(third_party_source, \"test\") < ImportRecord(local_source, \"name\")\n        assert ImportRecord(other_source, \"test\") < ImportRecord(third_party_source, \"name\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(third_party_source, \"test\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(third_party_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(ImportString(\"zzz\")) > ImportRecord(ImportString(\"aaa\"))\n        assert ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n        ) > ImportRecord(local_source, \"name\")\n        assert not (\n            ImportRecord(local_source, \"name\")\n            > ImportRecord(local_source, \"test\", fallback=ImportRecord(local_source, \"test2\"))\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            third_party_source,\n            \"test\",\n            fallback=ImportRecord(third_party_source, \"test2\"),\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n            min_version=(2, 11),\n        )\n\n    def test_get_local_name(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source).get_local_name() == \"source\"\n        assert ImportRecord(source, \"name\").get_local_name() == \"name\"\n        assert ImportRecord(source, \"name\", \"alias\").get_local_name() == \"alias\"\n        assert ImportRecord(source, alias=\"alias\").get_local_name() == \"alias\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initialize an ImportString instance.\n\nThis constructor takes a master module name (parent) and any number of additional parts\nto form a valid Python import string. It checks for valid structure, ensuring there are no \nempty parts or improperly formatted names (i.e., names containing a dot). If the provided \ninput is invalid, it raises a StructureError with a descriptive message.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts of the import string, which must not be empty or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, \n                    or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of strings representing the complete import string.\n\nConstants:\n    BUILTINS (Final[str]): Indicates the standard library module name, \"builtins\".\n    Used to determine if the import string originates from built-in modules in \n    the `is_builtins` method.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initialize an ImportString instance.\n\nThis constructor takes a master module name (parent) and any number of additional parts\nto form a valid Python import string. It checks for valid structure, ensuring there are no \nempty parts or improperly formatted names (i.e., names containing a dot). If the provided \ninput is invalid, it raises a StructureError with a descriptive message.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts of the import string, which must not be empty or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, \n                    or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of strings representing the complete import string.\n\nConstants:\n    BUILTINS (Final[str]): Indicates the standard library module name, \"builtins\".\n    Used to determine if the import string originates from built-in modules in \n    the `is_builtins` method.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Render the ImportString as a valid Python import statement. This method implements the `__str__` method, which returns the output of the `render()` method, effectively providing a string representation of the import string. The `render()` method concatenates the parts of the import string using the `.` character, producing a format suitable for Python imports.\n\nReturns:\n    str: A string representation of the import statement, generated by joining all parts of the ImportString instance.\n\nUsage of Constants:\n    None directly, but the method leverages the class's ability to manage and structure import strings, primarily using the `parts` attribute defined in the constructor.\"\"\"\n        '\\n        Render as a part of a valid Python import statement.\\n        '\n        return self.render()",
        "docstring": "Render the ImportString as a valid Python import statement. This method implements the `__str__` method, which returns the output of the `render()` method, effectively providing a string representation of the import string. The `render()` method concatenates the parts of the import string using the `.` character, producing a format suitable for Python imports.\n\nReturns:\n    str: A string representation of the import statement, generated by joining all parts of the ImportString instance.\n\nUsage of Constants:\n    None directly, but the method leverages the class's ability to manage and structure import strings, primarily using the `parts` attribute defined in the constructor.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the ImportString instance based on its components.\n\nThis method returns an integer hash value derived from the `parts` attribute, which is a tuple containing the string components that represent the import string. This allows instances of ImportString to be used in hash-based collections such as sets or as keys in dictionaries.\n\nNo parameters are required for this method, and it does not have side effects. It relies on the built-in `hash()` function to compute the hash based on the content of `self.parts`, which is defined during the initialization of an ImportString instance.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate the hash value for the ImportString instance based on its components.\n\nThis method returns an integer hash value derived from the `parts` attribute, which is a tuple containing the string components that represent the import string. This allows instances of ImportString to be used in hash-based collections such as sets or as keys in dictionaries.\n\nNo parameters are required for this method, and it does not have side effects. It relies on the built-in `hash()` function to compute the hash based on the content of `self.parts`, which is defined during the initialization of an ImportString instance.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determine if two `ImportString` instances are equal based on their rendered import string.\n\nParameters:\n- `other` (object): The object to compare against. This must be an instance of `ImportString`; otherwise, it raises a `BuildInternalError`.\n\nReturns:\n- bool: True if both `ImportString` instances represent the same import string when rendered, otherwise False.\n\nRaises:\n- `BuildInternalError`: If `other` is not an instance of `ImportString`, indicating the type mismatch.\n\nThis method leverages the `parts` attribute, which is a tuple of the import string parts initialized in the constructor. Equality is determined by comparing these `parts`, ensuring instances with the same structure and content are considered equal.\"\"\"\n        '\\n        Whether import strings produce the same render.\\n        '\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
        "docstring": "Determine if two `ImportString` instances are equal based on their rendered import string.\n\nParameters:\n- `other` (object): The object to compare against. This must be an instance of `ImportString`; otherwise, it raises a `BuildInternalError`.\n\nReturns:\n- bool: True if both `ImportString` instances represent the same import string when rendered, otherwise False.\n\nRaises:\n- `BuildInternalError`: If `other` is not an instance of `ImportString`, indicating the type mismatch.\n\nThis method leverages the `parts` attribute, which is a tuple of the import string parts initialized in the constructor. Equality is determined by comparing these `parts`, ensuring instances with the same structure and content are considered equal.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__gt__": {
        "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"Compare two `ImportString` instances for sorting.\n\nParameters:\n    other (Self): Another `ImportString` instance to compare against.\n\nReturns:\n    bool: True if the current instance is greater than the other; False otherwise.\n\nThe comparison logic emulates the behavior of the `isort` tool. It first checks for equality, returning False if they are the same. Then, it determines sort order based on whether the import strings are local or third-party, categorized by methods `is_local()` and `is_third_party()`, respectively. Finally, if they are of the same category, it compares their parts lexicographically. The comparison relies on constants defined in the `ImportString` class, specifically `_THIRD_PARTY`, which contains a set of recognized third-party module names.\"\"\"\n        '\\n        Compare import strings for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
        "docstring": "Compare two `ImportString` instances for sorting.\n\nParameters:\n    other (Self): Another `ImportString` instance to compare against.\n\nReturns:\n    bool: True if the current instance is greater than the other; False otherwise.\n\nThe comparison logic emulates the behavior of the `isort` tool. It first checks for equality, returning False if they are the same. Then, it determines sort order based on whether the import strings are local or third-party, categorized by methods `is_local()` and `is_third_party()`, respectively. Finally, if they are of the same category, it compares their parts lexicographically. The comparison relies on constants defined in the `ImportString` class, specifically `_THIRD_PARTY`, which contains a set of recognized third-party module names.",
        "signature": "def __gt__(self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string as a valid Python import statement.\n\nThis method concatenates all parts of the ImportString instance, separating them with dots (.). It returns a single string that represents the complete import path. The parts are stored in the `self.parts` attribute, which is defined during the instance initialization.\n\nReturns:\n    str: The fully rendered import string.\n\nNo input parameters are required, and there are no side effects. The method interacts solely with the `self.parts` attribute, ensuring the integrity of the import structure defined by the class.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string as a valid Python import statement.\n\nThis method concatenates all parts of the ImportString instance, separating them with dots (.). It returns a single string that represents the complete import path. The parts are stored in the `self.parts` attribute, which is defined during the instance initialization.\n\nReturns:\n    str: The fully rendered import string.\n\nNo input parameters are required, and there are no side effects. The method interacts solely with the `self.parts` attribute, ensuring the integrity of the import structure defined by the class.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.parent": {
        "code": "    def parent(self) -> str:\n        \"\"\"Get the first part of the import string, which is the parent module name. If the import string is constructed with multiple parts, this method retrieves the first segment; if no parts are defined, it returns the `builtins` constant, which represents Python's built-in module namespace.\n\nReturns:\n    str: The parent module name.\n\nNotes:\n    - The `parts` attribute holds the components of the import string, defined during the initialization of the `ImportString` instance.\n    - The `BUILTINS` constant is used to indicate the built-in module when no other parent is specified.\"\"\"\n        '\\n        Get first import string part or `builtins`.\\n        '\n        return self.parts[0]",
        "docstring": "Get the first part of the import string, which is the parent module name. If the import string is constructed with multiple parts, this method retrieves the first segment; if no parts are defined, it returns the `builtins` constant, which represents Python's built-in module namespace.\n\nReturns:\n    str: The parent module name.\n\nNotes:\n    - The `parts` attribute holds the components of the import string, defined during the initialization of the `ImportString` instance.\n    - The `BUILTINS` constant is used to indicate the built-in module when no other parent is specified.",
        "signature": "def parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_local": {
        "code": "    def is_local(self) -> bool:\n        \"\"\"Determine whether the import string refers to a local module.\n\nThis method checks if the import string's parent part starts with specific prefixes that indicate it belongs to local modules, defined by `Boto3StubsPackageData.SERVICE_PREFIX` and `TypesAioBotocorePackageData.SERVICE_PREFIX`. It also verifies if the last part of the import string is a `type_defs` module by invoking the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import string is local, otherwise False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local Boto3 stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local AioBotocore types.\n- `is_type_defs()`: A method call to check if the import string corresponds to a type definitions module.\"\"\"\n        '\\n        Whether import is from local module.\\n        '\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()",
        "docstring": "Determine whether the import string refers to a local module.\n\nThis method checks if the import string's parent part starts with specific prefixes that indicate it belongs to local modules, defined by `Boto3StubsPackageData.SERVICE_PREFIX` and `TypesAioBotocorePackageData.SERVICE_PREFIX`. It also verifies if the last part of the import string is a `type_defs` module by invoking the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import string is local, otherwise False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local Boto3 stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local AioBotocore types.\n- `is_type_defs()`: A method call to check if the import string corresponds to a type definitions module.",
        "signature": "def is_local(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_type_defs": {
        "code": "    def is_type_defs(self) -> bool:\n        \"\"\"Check if the import string is from the `type_defs` module.\n\nThis method inspects the last part of the import string (stored in `self.parts`) to determine if it matches the value defined in `ServiceModuleName.type_defs`. If the last part of the import string is equal to `ServiceModuleName.type_defs.value`, it indicates that the import string refers to a type definitions module.\n\nReturns:\n    bool: True if the import string is from the `type_defs` module, False otherwise.\n\nDependencies:\n- `ServiceModuleName` is imported from `mypy_boto3_builder.enums.service_module_name` and provides an enumerated type for the various service module names, including `type_defs`.\"\"\"\n        '\\n        Whether import is from `type_defs` module.\\n        '\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value",
        "docstring": "Check if the import string is from the `type_defs` module.\n\nThis method inspects the last part of the import string (stored in `self.parts`) to determine if it matches the value defined in `ServiceModuleName.type_defs`. If the last part of the import string is equal to `ServiceModuleName.type_defs.value`, it indicates that the import string refers to a type definitions module.\n\nReturns:\n    bool: True if the import string is from the `type_defs` module, False otherwise.\n\nDependencies:\n- `ServiceModuleName` is imported from `mypy_boto3_builder.enums.service_module_name` and provides an enumerated type for the various service module names, including `type_defs`.",
        "signature": "def is_type_defs(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_third_party": {
        "code": "    def is_third_party(self) -> bool:\n        \"\"\"Determines if the import string belongs to a third-party module.\n\nReturns:\n    bool: `True` if the module name (parent part of the import string) matches one of the predefined third-party module names, which are stored in the class constant `_THIRD_PARTY` and include modules like \"boto3\", \"botocore\", and others. Otherwise, returns `False`.\n\nDependencies:\n- `_THIRD_PARTY`: This constant is a set of strings defined in the `ImportString` class that contains names of known third-party modules. It is used to check if the parent part of the import string is part of these modules.\"\"\"\n        '\\n        Whether import is from 3rd party module.\\n        '\n        return self.parent in self._THIRD_PARTY",
        "docstring": "Determines if the import string belongs to a third-party module.\n\nReturns:\n    bool: `True` if the module name (parent part of the import string) matches one of the predefined third-party module names, which are stored in the class constant `_THIRD_PARTY` and include modules like \"boto3\", \"botocore\", and others. Otherwise, returns `False`.\n\nDependencies:\n- `_THIRD_PARTY`: This constant is a set of strings defined in the `ImportString` class that contains names of known third-party modules. It is used to check if the parent part of the import string is part of these modules.",
        "signature": "def is_third_party(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        \"\"\"Initialize an ImportRecord instance representing a Python import statement.\n\nParameters:\n- source (ImportString): The source of the import, represented as an ImportString instance.\n- name (str, optional): The name of the import. Default is an empty string.\n- alias (str, optional): The local alias for the import. Default is an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for the import, or None if not applicable. This helps in determining if a fallback is necessary.\n- fallback (Self | None, optional): An optional fallback ImportRecord to use if the primary import fails.\n\nAttributes:\n- self.source: Holds the source ImportString of the import.\n- self.name: Stores the name of the import.\n- self.alias: Keeps the alias for the import.\n- self.min_version: Represents the minimum required Python version for this import.\n- self.fallback: Optionally links to another ImportRecord as a fallback for import resolution.\"\"\"\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback",
        "docstring": "Initialize an ImportRecord instance representing a Python import statement.\n\nParameters:\n- source (ImportString): The source of the import, represented as an ImportString instance.\n- name (str, optional): The name of the import. Default is an empty string.\n- alias (str, optional): The local alias for the import. Default is an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for the import, or None if not applicable. This helps in determining if a fallback is necessary.\n- fallback (Self | None, optional): An optional fallback ImportRecord to use if the primary import fails.\n\nAttributes:\n- self.source: Holds the source ImportString of the import.\n- self.name: Stores the name of the import.\n- self.alias: Keeps the alias for the import.\n- self.min_version: Represents the minimum required Python version for this import.\n- self.fallback: Optionally links to another ImportRecord as a fallback for import resolution.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.render_name": {
        "code": "    def render_name(self) -> str:\n        \"\"\"Get the rendered import name for this ImportRecord instance.\n\nRaises a StructureError if the import name is not defined. If an alias is provided, the function returns the name formatted as 'name as alias', otherwise, it returns just the name. The function only relies on the `name` and `alias` attributes of the ImportRecord class, which are initialized in the constructor. This method is essential for generating valid import statements during the import string rendering process.\"\"\"\n        '\\n        Get rendered import name.\\n        '\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name",
        "docstring": "Get the rendered import name for this ImportRecord instance.\n\nRaises a StructureError if the import name is not defined. If an alias is provided, the function returns the name formatted as 'name as alias', otherwise, it returns just the name. The function only relies on the `name` and `alias` attributes of the ImportRecord class, which are initialized in the constructor. This method is essential for generating valid import statements during the import string rendering process.",
        "signature": "def render_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get the rendered import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs the import string using the source and either the name or alias of the import. \n- If the `name` attribute is set, it generates a string of the format \"from {source} import {name}\".\n- If only the `alias` is set, it produces a string in the format \"import {source} as {alias}\".\n- If neither is provided, it defaults to \"import {source}\".\n\nReturns:\n    str: The constructed import statement as a string.\n\nThe method relies on the `self.source`, `self.name`, and `self.alias` attributes, which are initialized in the class constructor. The `render_name` method is used to determine the effective import name when both `name` and `alias` are present.\"\"\"\n        '\\n        Get rendered string.\\n        '\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
        "docstring": "Get the rendered import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs the import string using the source and either the name or alias of the import. \n- If the `name` attribute is set, it generates a string of the format \"from {source} import {name}\".\n- If only the `alias` is set, it produces a string in the format \"import {source} as {alias}\".\n- If neither is provided, it defaults to \"import {source}\".\n\nReturns:\n    str: The constructed import statement as a string.\n\nThe method relies on the `self.source`, `self.name`, and `self.alias` attributes, which are initialized in the class constructor. The `render_name` method is used to determine the effective import name when both `name` and `alias` are present.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Render the ImportRecord instance as a valid Python import statement.\n\nThis method overrides the default string representation to return the string produced by the `render` method, which composes an import statement based on the instance's attributes. The output string will vary depending on whether the `name` and `alias` attributes are defined, allowing it to correctly represent different import scenarios.\n\nReturns:\n    str: A formatted Python import statement generated from the instance's attributes.\n\nDependencies:\n    This method interacts with the `render` method, which is responsible for constructing the actual import statement based on the instance attributes `source`, `name`, and `alias`.\"\"\"\n        '\\n        Render as a valid Python import statement.\\n        '\n        return self.render()",
        "docstring": "Render the ImportRecord instance as a valid Python import statement.\n\nThis method overrides the default string representation to return the string produced by the `render` method, which composes an import statement based on the instance's attributes. The output string will vary depending on whether the `name` and `alias` attributes are defined, allowing it to correctly represent different import scenarios.\n\nReturns:\n    str: A formatted Python import statement generated from the instance's attributes.\n\nDependencies:\n    This method interacts with the `render` method, which is responsible for constructing the actual import statement based on the instance attributes `source`, `name`, and `alias`.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ImportRecord instance based on its attributes: source, name, alias, min_version, and fallback. This method enables instances of ImportRecord to be used as keys in dictionaries or in sets, ensuring that instances with identical attributes yield the same hash value. The attributes utilized are defined within the class constructor, with 'source' representing the import source, 'name' as the import name, 'alias' for any local name used, 'min_version' specifying the minimum Python version requirement, and 'fallback' indicating an optional fallback ImportRecord.\"\"\"\n        '\\n        Calculate hash value based on source, name and alias.\\n        '\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))",
        "docstring": "Calculate a hash value for the ImportRecord instance based on its attributes: source, name, alias, min_version, and fallback. This method enables instances of ImportRecord to be used as keys in dictionaries or in sets, ensuring that instances with identical attributes yield the same hash value. The attributes utilized are defined within the class constructor, with 'source' representing the import source, 'name' as the import name, 'alias' for any local name used, 'min_version' specifying the minimum Python version requirement, and 'fallback' indicating an optional fallback ImportRecord.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determine equality between two ImportRecord instances.\n\nParameters:\n    other (object): The object to compare with the current ImportRecord instance.\n\nReturns:\n    bool: True if the rendered string representation of both ImportRecord instances is the same; otherwise, False.\n\nThe comparison is based on the string representation generated by the __str__ method, which constructs a valid Python import statement using the instance's attributes: source, name, and alias. This method relies on the full implementation of the ImportRecord class, specifically the render method for generating the string output.\"\"\"\n        '\\n        Whether two import records produce the same render.\\n        '\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)",
        "docstring": "Determine equality between two ImportRecord instances.\n\nParameters:\n    other (object): The object to compare with the current ImportRecord instance.\n\nReturns:\n    bool: True if the rendered string representation of both ImportRecord instances is the same; otherwise, False.\n\nThe comparison is based on the string representation generated by the __str__ method, which constructs a valid Python import statement using the instance's attributes: source, name, and alias. This method relies on the full implementation of the ImportRecord class, specifically the render method for generating the string output.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__gt__": {
        "code": "    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"Compare two ImportRecord instances for sorting purposes, mimicking the logic used by the `isort` tool. This method first checks if the instances are equal and returns False if they are. It then compares the `min_version` attributes to determine precedence, treating unset versions as empty tuples. Next, it evaluates the presence of the `fallback` attribute, where records with a fallback are prioritized over those without. If both records have the same fallback status, the `source` attributes are compared, followed by the `name` attributes to establish the sort order.\n\nParameters:\n- other (Self): An instance of ImportRecord to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the `other` instance based on the specified criteria; otherwise, False.\n\nDependencies:\n- `min_version`: A tuple representing the minimum Python version required for the import, which influences the sorting logic.\n- `fallback`: An optional ImportRecord that provides fallback options, affecting sorting precedence.\n- `source`: An instance of ImportString, which represents the source of the import, influencing the order.\n\nThis method supports the proper organization of import statements based on specified sorting rules, enhancing code readability and consistency.\"\"\"\n        '\\n        Compare two import records for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name",
        "docstring": "Compare two ImportRecord instances for sorting purposes, mimicking the logic used by the `isort` tool. This method first checks if the instances are equal and returns False if they are. It then compares the `min_version` attributes to determine precedence, treating unset versions as empty tuples. Next, it evaluates the presence of the `fallback` attribute, where records with a fallback are prioritized over those without. If both records have the same fallback status, the `source` attributes are compared, followed by the `name` attributes to establish the sort order.\n\nParameters:\n- other (Self): An instance of ImportRecord to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the `other` instance based on the specified criteria; otherwise, False.\n\nDependencies:\n- `min_version`: A tuple representing the minimum Python version required for the import, which influences the sorting logic.\n- `fallback`: An optional ImportRecord that provides fallback options, affecting sorting precedence.\n- `source`: An instance of ImportString, which represents the source of the import, influencing the order.\n\nThis method supports the proper organization of import statements based on specified sorting rules, enhancing code readability and consistency.",
        "signature": "def __gt__(self: Self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.get_local_name": {
        "code": "    def get_local_name(self) -> str:\n        \"\"\"Get the local name used for the import.\n\nThis method returns the alias if it exists; otherwise, it returns the import name. If neither is provided, it falls back to rendering the source as a string using the `render` method of the `ImportString` class. This functionality is essential for ensuring clarity on how an imported module or variable will be referenced within the code.\n\nReturns:\n    str: The local name for the import, which can be the alias, the name, or the rendered source.\n\nDependencies:\n    - `self.alias`: The local alias for the import, defined during initialization.\n    - `self.name`: The actual name of the import, also defined during initialization.\n    - `self.source`: An instance of `ImportString`, which provides a `render` method used when both `alias` and `name` are absent.\"\"\"\n        '\\n        Get local import name.\\n        '\n        return self.alias or self.name or self.source.render()",
        "docstring": "Get the local name used for the import.\n\nThis method returns the alias if it exists; otherwise, it returns the import name. If neither is provided, it falls back to rendering the source as a string using the `render` method of the `ImportString` class. This functionality is essential for ensuring clarity on how an imported module or variable will be referenced within the code.\n\nReturns:\n    str: The local name for the import, which can be the alias, the name, or the rendered source.\n\nDependencies:\n    - `self.alias`: The local alias for the import, defined during initialization.\n    - `self.name`: The actual name of the import, also defined during initialization.\n    - `self.source`: An instance of `ImportString`, which provides a `render` method used when both `alias` and `name` are absent.",
        "signature": "def get_local_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
  },
  "call_tree": {
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
                "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
              },
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
            }
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
          },
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_get_local_name": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_record\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u251c\u2500\u2500 import_record.py\n        \u2502   \u251c\u2500\u2500 ImportRecord\n        \u2502   \u251c\u2500\u2500 ImportRecord.__eq__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__gt__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__hash__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__init__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__str__\n        \u2502   \u251c\u2500\u2500 ImportRecord.get_local_name\n        \u2502   \u251c\u2500\u2500 ImportRecord.render\n        \u2502   \u2514\u2500\u2500 ImportRecord.render_name\n        \u2514\u2500\u2500 import_string.py\n            \u251c\u2500\u2500 ImportString\n            \u251c\u2500\u2500 ImportString.__eq__\n            \u251c\u2500\u2500 ImportString.__gt__\n            \u251c\u2500\u2500 ImportString.__hash__\n            \u251c\u2500\u2500 ImportString.__init__\n            \u251c\u2500\u2500 ImportString.__str__\n            \u251c\u2500\u2500 ImportString.is_local\n            \u251c\u2500\u2500 ImportString.is_third_party\n            \u251c\u2500\u2500 ImportString.is_type_defs\n            \u251c\u2500\u2500 ImportString.parent\n            \u2514\u2500\u2500 ImportString.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the creation and management of standardized import statements in Python code, focusing on providing a structured and programmatic approach to defining import records. It supports generating import strings, managing aliases, and handling version-specific or fallback imports to ensure compatibility and maintainability across different scenarios. The module also includes advanced comparison capabilities, enabling prioritization or organization of import statements based on custom criteria, such as source type or versioning. By abstracting the complexity of handling imports, it reduces developer effort, promotes code readability, and ensures consistency in dynamic or large-scale codebases.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.is_local\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_local(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine whether the import string refers to a local module.\n\nThis method checks if the import string's parent part starts with specific prefixes that indicate it belongs to local modules, defined by `Boto3StubsPackageData.SERVICE_PREFIX` and `TypesAioBotocorePackageData.SERVICE_PREFIX`. It also verifies if the last part of the import string is a `type_defs` module by invoking the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import string is local, otherwise False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local Boto3 stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the prefix for local AioBotocore types.\n- `is_type_defs()`: A method call to check if the import string corresponds to a type definitions module.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.parent\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the first part of the import string, which is the parent module name. If the import string is constructed with multiple parts, this method retrieves the first segment; if no parts are defined, it returns the `builtins` constant, which represents Python's built-in module namespace.\n\nReturns:\n    str: The parent module name.\n\nNotes:\n    - The `parts` attribute holds the components of the import string, defined during the initialization of the `ImportString` instance.\n    - The `BUILTINS` constant is used to indicate the built-in module when no other parent is specified.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportString instance.\n\nThis constructor takes a master module name (parent) and any number of additional parts\nto form a valid Python import string. It checks for valid structure, ensuring there are no \nempty parts or improperly formatted names (i.e., names containing a dot). If the provided \ninput is invalid, it raises a StructureError with a descriptive message.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts of the import string, which must not be empty or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, \n                    or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of strings representing the complete import string.\n\nConstants:\n    BUILTINS (Final[str]): Indicates the standard library module name, \"builtins\".\n    Used to determine if the import string originates from built-in modules in \n    the `is_builtins` method.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__gt__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __gt__(self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two `ImportString` instances for sorting.\n\nParameters:\n    other (Self): Another `ImportString` instance to compare against.\n\nReturns:\n    bool: True if the current instance is greater than the other; False otherwise.\n\nThe comparison logic emulates the behavior of the `isort` tool. It first checks for equality, returning False if they are the same. Then, it determines sort order based on whether the import strings are local or third-party, categorized by methods `is_local()` and `is_third_party()`, respectively. Finally, if they are of the same category, it compares their parts lexicographically. The comparison relies on constants defined in the `ImportString` class, specifically `_THIRD_PARTY`, which contains a set of recognized third-party module names.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string as a valid Python import statement.\n\nThis method concatenates all parts of the ImportString instance, separating them with dots (.). It returns a single string that represents the complete import path. The parts are stored in the `self.parts` attribute, which is defined during the instance initialization.\n\nReturns:\n    str: The fully rendered import string.\n\nNo input parameters are required, and there are no side effects. The method interacts solely with the `self.parts` attribute, ensuring the integrity of the import structure defined by the class.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__eq__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if two `ImportString` instances are equal based on their rendered import string.\n\nParameters:\n- `other` (object): The object to compare against. This must be an instance of `ImportString`; otherwise, it raises a `BuildInternalError`.\n\nReturns:\n- bool: True if both `ImportString` instances represent the same import string when rendered, otherwise False.\n\nRaises:\n- `BuildInternalError`: If `other` is not an instance of `ImportString`, indicating the type mismatch.\n\nThis method leverages the `parts` attribute, which is a tuple of the import string parts initialized in the constructor. Equality is determined by comparing these `parts`, ensuring instances with the same structure and content are considered equal.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_third_party\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_third_party(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the import string belongs to a third-party module.\n\nReturns:\n    bool: `True` if the module name (parent part of the import string) matches one of the predefined third-party module names, which are stored in the class constant `_THIRD_PARTY` and include modules like \"boto3\", \"botocore\", and others. Otherwise, returns `False`.\n\nDependencies:\n- `_THIRD_PARTY`: This constant is a set of strings defined in the `ImportString` class that contains names of known third-party modules. It is used to check if the parent part of the import string is part of these modules.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the ImportString instance based on its components.\n\nThis method returns an integer hash value derived from the `parts` attribute, which is a tuple containing the string components that represent the import string. This allows instances of ImportString to be used in hash-based collections such as sets or as keys in dictionaries.\n\nNo parameters are required for this method, and it does not have side effects. It relies on the built-in `hash()` function to compute the hash based on the content of `self.parts`, which is defined during the initialization of an ImportString instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_type_defs\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_type_defs(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the import string is from the `type_defs` module.\n\nThis method inspects the last part of the import string (stored in `self.parts`) to determine if it matches the value defined in `ServiceModuleName.type_defs`. If the last part of the import string is equal to `ServiceModuleName.type_defs.value`, it indicates that the import string refers to a type definitions module.\n\nReturns:\n    bool: True if the import string is from the `type_defs` module, False otherwise.\n\nDependencies:\n- `ServiceModuleName` is imported from `mypy_boto3_builder.enums.service_module_name` and provides an enumerated type for the various service module names, including `type_defs`.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__str__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the ImportString as a valid Python import statement. This method implements the `__str__` method, which returns the output of the `render()` method, effectively providing a string representation of the import string. The `render()` method concatenates the parts of the import string using the `.` character, producing a format suitable for Python imports.\n\nReturns:\n    str: A string representation of the import statement, generated by joining all parts of the ImportString instance.\n\nUsage of Constants:\n    None directly, but the method leverages the class's ability to manage and structure import strings, primarily using the `parts` attribute defined in the constructor.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.get_local_name\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def get_local_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local name used for the import.\n\nThis method returns the alias if it exists; otherwise, it returns the import name. If neither is provided, it falls back to rendering the source as a string using the `render` method of the `ImportString` class. This functionality is essential for ensuring clarity on how an imported module or variable will be referenced within the code.\n\nReturns:\n    str: The local name for the import, which can be the alias, the name, or the rendered source.\n\nDependencies:\n    - `self.alias`: The local alias for the import, defined during initialization.\n    - `self.name`: The actual name of the import, also defined during initialization.\n    - `self.source`: An instance of `ImportString`, which provides a `render` method used when both `alias` and `name` are absent.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.render_name\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the rendered import name for this ImportRecord instance.\n\nRaises a StructureError if the import name is not defined. If an alias is provided, the function returns the name formatted as 'name as alias', otherwise, it returns just the name. The function only relies on the `name` and `alias` attributes of the ImportRecord class, which are initialized in the constructor. This method is essential for generating valid import statements during the import string rendering process.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__eq__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine equality between two ImportRecord instances.\n\nParameters:\n    other (object): The object to compare with the current ImportRecord instance.\n\nReturns:\n    bool: True if the rendered string representation of both ImportRecord instances is the same; otherwise, False.\n\nThe comparison is based on the string representation generated by the __str__ method, which constructs a valid Python import statement using the instance's attributes: source, name, and alias. This method relies on the full implementation of the ImportRecord class, specifically the render method for generating the string output.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__hash__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ImportRecord instance based on its attributes: source, name, alias, min_version, and fallback. This method enables instances of ImportRecord to be used as keys in dictionaries or in sets, ensuring that instances with identical attributes yield the same hash value. The attributes utilized are defined within the class constructor, with 'source' representing the import source, 'name' as the import name, 'alias' for any local name used, 'min_version' specifying the minimum Python version requirement, and 'fallback' indicating an optional fallback ImportRecord.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__init__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportRecord instance representing a Python import statement.\n\nParameters:\n- source (ImportString): The source of the import, represented as an ImportString instance.\n- name (str, optional): The name of the import. Default is an empty string.\n- alias (str, optional): The local alias for the import. Default is an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for the import, or None if not applicable. This helps in determining if a fallback is necessary.\n- fallback (Self | None, optional): An optional fallback ImportRecord to use if the primary import fails.\n\nAttributes:\n- self.source: Holds the source ImportString of the import.\n- self.name: Stores the name of the import.\n- self.alias: Keeps the alias for the import.\n- self.min_version: Represents the minimum required Python version for this import.\n- self.fallback: Optionally links to another ImportRecord as a fallback for import resolution.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__gt__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __gt__(self: Self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two ImportRecord instances for sorting purposes, mimicking the logic used by the `isort` tool. This method first checks if the instances are equal and returns False if they are. It then compares the `min_version` attributes to determine precedence, treating unset versions as empty tuples. Next, it evaluates the presence of the `fallback` attribute, where records with a fallback are prioritized over those without. If both records have the same fallback status, the `source` attributes are compared, followed by the `name` attributes to establish the sort order.\n\nParameters:\n- other (Self): An instance of ImportRecord to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the `other` instance based on the specified criteria; otherwise, False.\n\nDependencies:\n- `min_version`: A tuple representing the minimum Python version required for the import, which influences the sorting logic.\n- `fallback`: An optional ImportRecord that provides fallback options, affecting sorting precedence.\n- `source`: An instance of ImportString, which represents the source of the import, influencing the order.\n\nThis method supports the proper organization of import statements based on specified sorting rules, enhancing code readability and consistency.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.render\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the rendered import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs the import string using the source and either the name or alias of the import. \n- If the `name` attribute is set, it generates a string of the format \"from {source} import {name}\".\n- If only the `alias` is set, it produces a string in the format \"import {source} as {alias}\".\n- If neither is provided, it defaults to \"import {source}\".\n\nReturns:\n    str: The constructed import statement as a string.\n\nThe method relies on the `self.source`, `self.name`, and `self.alias` attributes, which are initialized in the class constructor. The `render_name` method is used to determine the effective import name when both `name` and `alias` are present.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__str__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the ImportRecord instance as a valid Python import statement.\n\nThis method overrides the default string representation to return the string produced by the `render` method, which composes an import statement based on the instance's attributes. The output string will vary depending on whether the `name` and `alias` attributes are defined, allowing it to correctly represent different import scenarios.\n\nReturns:\n    str: A formatted Python import statement generated from the instance's attributes.\n\nDependencies:\n    This method interacts with the `render` method, which is responsible for constructing the actual import statement based on the instance attributes `source`, `name`, and `alias`.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)"
  }
}