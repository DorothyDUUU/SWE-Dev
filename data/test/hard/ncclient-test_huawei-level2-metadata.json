{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_huawei",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_huawei.py",
  "test_code": "import unittest\nfrom ncclient.devices.huawei import *\n\n\ncapabilities = ['urn:ietf:params:netconf:base:1.0',\n                'urn:ietf:params:netconf:base:1.1',\n                'urn:ietf:params:netconf:capability:writable-running:1.0',\n                'urn:ietf:params:netconf:capability:candidate:1.0',\n                'urn:ietf:params:netconf:capability:confirmed-commit:1.0',\n                'urn:ietf:params:netconf:capability:rollback-on-error:1.0',\n                'urn:ietf:params:netconf:capability:startup:1.0',\n                'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp',\n                'urn:ietf:params:netconf:capability:validate:1.0',\n                'urn:ietf:params:netconf:capability:xpath:1.0',\n                'urn:ietf:params:netconf:capability:notification:1.0',\n                'urn:ietf:params:netconf:capability:interleave:1.0',\n                'urn:ietf:params:netconf:capability:with-defaults:1.0',\n                'http://www.huawei.com/netconf/capability/execute-cli/1.0',\n                'http://www.huawei.com/netconf/capability/action/1.0',\n                'http://www.huawei.com/netconf/capability/active/1.0',\n                'http://www.huawei.com/netconf/capability/discard-commit/1.0',\n                'http://www.huawei.com/netconf/capability/exchange/1.0']\n\n\nclass TestHuaweiDevice(unittest.TestCase):\n\n    def setUp(self):\n        self.obj = HuaweiDeviceHandler({'name': 'huawei'})\n\n    def test_add_additional_operations(self):\n        expected = dict()\n        expected['cli'] = CLI\n        expected['action'] = Action\n        self.assertDictEqual(expected, self.obj.add_additional_operations())\n\n    def test_handle_raw_dispatch(self):\n        expected = 'hello'\n        self.assertEqual(expected, self.obj.handle_raw_dispatch('hello'))\n\n    def test_get_capabilities(self):\n        self.assertListEqual(capabilities, self.obj.get_capabilities())\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.obj.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected['nsmap'] = self.obj.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n\n    def test_perform_qualify_check(self):\n        self.assertFalse(self.obj.perform_qualify_check())\n",
  "GT_file_code": {
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/devices/huawei.py": "\"\"\"\nHandler for Huawei device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Huawei\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.operations.third_party.huawei.rpc import *\n\nfrom ncclient.xml_ import BASE_NS_1_0\n\nfrom .default import DefaultDeviceHandler\n\nclass HuaweiDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Huawei handler for device specific information.\n\n    In the device_params dictionary, which is passed to __init__, you can specify\n    the parameter \"ssh_subsystem_name\". That allows you to configure the preferred\n    SSH subsystem name that should be tried on your Huawei switch. If connecting with\n    that name fails, or you didn't specify that name, the other known subsystem names\n    will be tried. However, if you specify it then this name will be tried first.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n\n    def __init__(self, device_params):\n        super(HuaweiDeviceHandler, self).__init__(device_params)\n\n\n    def add_additional_operations(self):\n        dict = {}\n        dict[\"cli\"] = CLI\n        dict[\"action\"] = Action\n        return dict\n\n    def handle_raw_dispatch(self, raw):\n        return raw.strip('\\0')\n\n    def get_capabilities(self):\n        # Just need to replace a single value in the default capabilities\n        c = super(HuaweiDeviceHandler, self).get_capabilities()\n        c.append('http://www.huawei.com/netconf/capability/execute-cli/1.0')\n        c.append('http://www.huawei.com/netconf/capability/action/1.0')\n        c.append('http://www.huawei.com/netconf/capability/active/1.0')\n        c.append('http://www.huawei.com/netconf/capability/discard-commit/1.0')\n        c.append('http://www.huawei.com/netconf/capability/exchange/1.0')\n        \n        return c\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def perform_qualify_check(self):\n        return False\n"
  },
  "GT_src_dict": {
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initializes a DefaultDeviceHandler instance with optional device parameters.\n\nParameters:\n- device_params (dict, optional): A dictionary containing specific parameters for the device. If not provided, defaults to None.\n\nThis constructor also initializes the capabilities list and processes the exempt error messages defined in the _EXEMPT_ERRORS class variable. The exempt errors are adjusted for case insensitivity and categorized based on their matching patterns (exact match, start wildcard, end wildcard, and full wildcard). These categorizations are crucial for handling RPC error messages that should be ignored rather than raised as exceptions.\n\nThe _EXEMPT_ERRORS constant is defined in the DefaultDeviceHandler class and allows subclasses to specify device-specific error messages that should be exempt from raising exceptions during RPC interactions.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initializes a DefaultDeviceHandler instance with optional device parameters.\n\nParameters:\n- device_params (dict, optional): A dictionary containing specific parameters for the device. If not provided, defaults to None.\n\nThis constructor also initializes the capabilities list and processes the exempt error messages defined in the _EXEMPT_ERRORS class variable. The exempt errors are adjusted for case insensitivity and categorized based on their matching patterns (exact match, start wildcard, end wildcard, and full wildcard). These categorizations are crucial for handling RPC error messages that should be ignored rather than raised as exceptions.\n\nThe _EXEMPT_ERRORS constant is defined in the DefaultDeviceHandler class and allows subclasses to specify device-specific error messages that should be exempt from raising exceptions during RPC interactions.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      },
      "DefaultDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Return the list of capabilities supported by the device.\n\nThis method combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities added through the device_params during initialization or via other methods. The resulting list of URIs is used during the initial capability exchange between the client and the NETCONF server.\n\nReturns:\n    list: A list of URIs representing the capabilities of the device.\n\nConstants utilized:\n- _BASE_CAPABILITIES: A class constant that defines the default set of capabilities supported by the default device handler. It is used as the foundation for the complete capabilities list returned by this method.\"\"\"\n        \"\\n        Return the capability list.\\n\\n        A list of URI's representing the client's capabilities. This is used during\\n        the initial capability exchange. Modify (in a new device-handler subclass)\\n        as needed.\\n\\n        \"\n        return self._BASE_CAPABILITIES + self.capabilities",
        "docstring": "Return the list of capabilities supported by the device.\n\nThis method combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities added through the device_params during initialization or via other methods. The resulting list of URIs is used during the initial capability exchange between the client and the NETCONF server.\n\nReturns:\n    list: A list of URIs representing the capabilities of the device.\n\nConstants utilized:\n- _BASE_CAPABILITIES: A class constant that defines the default set of capabilities supported by the default device handler. It is used as the foundation for the complete capabilities list returned by this method.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/devices/huawei.py": {
      "HuaweiDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initializes a HuaweiDeviceHandler instance by passing device parameters to its superclass.\n\nThis constructor takes a dictionary of `device_params`, which may include parameters specific to the Huawei device, such as \"ssh_subsystem_name\" for configuring the SSH subsystem. This allows for enhanced customization when establishing a connection to the device.\n\nParameters:\n    device_params (dict): A dictionary of parameters required for the device handler, passed to the parent class DefaultDeviceHandler.\n\nReturns:\n    None: This method does not return a value. It initializes the instance of HuaweiDeviceHandler.\n\nThis method interacts with the DefaultDeviceHandler class, which is the base class for all device-specific handlers, ensuring that common initialization tasks are handled consistently.\"\"\"\n        super(HuaweiDeviceHandler, self).__init__(device_params)",
        "docstring": "Initializes a HuaweiDeviceHandler instance by passing device parameters to its superclass.\n\nThis constructor takes a dictionary of `device_params`, which may include parameters specific to the Huawei device, such as \"ssh_subsystem_name\" for configuring the SSH subsystem. This allows for enhanced customization when establishing a connection to the device.\n\nParameters:\n    device_params (dict): A dictionary of parameters required for the device handler, passed to the parent class DefaultDeviceHandler.\n\nReturns:\n    None: This method does not return a value. It initializes the instance of HuaweiDeviceHandler.\n\nThis method interacts with the DefaultDeviceHandler class, which is the base class for all device-specific handlers, ensuring that common initialization tasks are handled consistently.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Returns a dictionary of additional operations specific to Huawei devices.\n\nThis method adds Huawei-specific operations by creating a dictionary that maps \noperation names to their corresponding classes. It includes the `cli` operation mapped \nto the `CLI` class and the `action` operation mapped to the `Action` class. These \nclasses need to be imported from the `ncclient.operations.third_party.huawei.rpc` module, \nwhich enables the execution of CLI commands and action manipulations on Huawei devices.\n\nReturns:\n    dict: A dictionary containing the additional operations available for Huawei devices,\n          specifically including keys \"cli\" and \"action\".\"\"\"\n        dict = {}\n        dict['cli'] = CLI\n        dict['action'] = Action\n        return dict",
        "docstring": "Returns a dictionary of additional operations specific to Huawei devices.\n\nThis method adds Huawei-specific operations by creating a dictionary that maps \noperation names to their corresponding classes. It includes the `cli` operation mapped \nto the `CLI` class and the `action` operation mapped to the `Action` class. These \nclasses need to be imported from the `ncclient.operations.third_party.huawei.rpc` module, \nwhich enables the execution of CLI commands and action manipulations on Huawei devices.\n\nReturns:\n    dict: A dictionary containing the additional operations available for Huawei devices,\n          specifically including keys \"cli\" and \"action\".",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.handle_raw_dispatch": {
        "code": "    def handle_raw_dispatch(self, raw):\n        \"\"\"Handles raw input data for Huawei devices by stripping null characters.\n\nParameters:\n    raw (str): The raw input string from the device, which may contain unwanted null characters.\n\nReturns:\n    str: The processed string without trailing null characters.\n\nThis method is specifically designed to clean up the raw output received from Huawei devices before further processing. It ensures that the output is in a usable format by removing any extraneous null characters represented as '\\\\0'.\"\"\"\n        return raw.strip('\\x00')",
        "docstring": "Handles raw input data for Huawei devices by stripping null characters.\n\nParameters:\n    raw (str): The raw input string from the device, which may contain unwanted null characters.\n\nReturns:\n    str: The processed string without trailing null characters.\n\nThis method is specifically designed to clean up the raw output received from Huawei devices before further processing. It ensures that the output is in a usable format by removing any extraneous null characters represented as '\\0'.",
        "signature": "def handle_raw_dispatch(self, raw):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Retrieves the capabilities of the Huawei device handler by extending the default capabilities defined in the superclass.\n\nThis method calls the parent class's `get_capabilities()` method to obtain a list of default capabilities and appends several Huawei-specific capabilities, such as support for executing CLI commands and action execution. The added capabilities include:\n\n- `http://www.huawei.com/netconf/capability/execute-cli/1.0`\n- `http://www.huawei.com/netconf/capability/action/1.0`\n- `http://www.huawei.com/netconf/capability/active/1.0`\n- `http://www.huawei.com/netconf/capability/discard-commit/1.0`\n- `http://www.huawei.com/netconf/capability/exchange/1.0`\n\nReturns:\n    list: A list of capabilities that includes both the default capabilities inherited from `DefaultDeviceHandler` and the specific Huawei capabilities.\n\nDependencies:\n    - The method relies on the `get_capabilities()` implementation of the superclass, `DefaultDeviceHandler`, for the initial list of capabilities.\"\"\"\n        c = super(HuaweiDeviceHandler, self).get_capabilities()\n        c.append('http://www.huawei.com/netconf/capability/execute-cli/1.0')\n        c.append('http://www.huawei.com/netconf/capability/action/1.0')\n        c.append('http://www.huawei.com/netconf/capability/active/1.0')\n        c.append('http://www.huawei.com/netconf/capability/discard-commit/1.0')\n        c.append('http://www.huawei.com/netconf/capability/exchange/1.0')\n        return c",
        "docstring": "Retrieves the capabilities of the Huawei device handler by extending the default capabilities defined in the superclass.\n\nThis method calls the parent class's `get_capabilities()` method to obtain a list of default capabilities and appends several Huawei-specific capabilities, such as support for executing CLI commands and action execution. The added capabilities include:\n\n- `http://www.huawei.com/netconf/capability/execute-cli/1.0`\n- `http://www.huawei.com/netconf/capability/action/1.0`\n- `http://www.huawei.com/netconf/capability/active/1.0`\n- `http://www.huawei.com/netconf/capability/discard-commit/1.0`\n- `http://www.huawei.com/netconf/capability/exchange/1.0`\n\nReturns:\n    list: A list of capabilities that includes both the default capabilities inherited from `DefaultDeviceHandler` and the specific Huawei capabilities.\n\nDependencies:\n    - The method relies on the `get_capabilities()` implementation of the superclass, `DefaultDeviceHandler`, for the initial list of capabilities.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary mapping XML namespaces used in Huawei-specific NETCONF operations.\n\nThis method constructs a dictionary with a single entry where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from the `ncclient.xml_` module, represents the base XML namespace for NETCONF operations, ensuring compliance with the NETCONF protocol standards. This method is utilized when forming XML requests or responses that require proper namespace declarations.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary mapping XML namespaces used in Huawei-specific NETCONF operations.\n\nThis method constructs a dictionary with a single entry where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from the `ncclient.xml_` module, represents the base XML namespace for NETCONF operations, ensuring compliance with the NETCONF protocol standards. This method is utilized when forming XML requests or responses that require proper namespace declarations.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing additional XML namespace mapping information \nfor use in XML operations specific to Huawei devices.\n\nThis method gathers the base XML namespace dictionary by calling \n`get_xml_base_namespace_dict()` and returns it wrapped in another dictionary \nwith the key \"nsmap\". The returned dictionary is particularly useful when \nforming XML requests that require specific name-spacing conventions dictated \nby Huawei's NETCONF capabilities.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" mapping to the base XML namespaces.\n\nDependencies:\n    - BASE_NS_1_0: This constant is imported from `ncclient.xml_` and represents \n      the base namespace for XML operations. It ensures that the XML structures \n      comply with the expected standards for Huawei device interaction.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing additional XML namespace mapping information \nfor use in XML operations specific to Huawei devices.\n\nThis method gathers the base XML namespace dictionary by calling \n`get_xml_base_namespace_dict()` and returns it wrapped in another dictionary \nwith the key \"nsmap\". The returned dictionary is particularly useful when \nforming XML requests that require specific name-spacing conventions dictated \nby Huawei's NETCONF capabilities.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" mapping to the base XML namespaces.\n\nDependencies:\n    - BASE_NS_1_0: This constant is imported from `ncclient.xml_` and represents \n      the base namespace for XML operations. It ensures that the XML structures \n      comply with the expected standards for Huawei device interaction.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      },
      "HuaweiDeviceHandler.perform_qualify_check": {
        "code": "    def perform_qualify_check(self):\n        \"\"\"Checks whether a qualification condition is met for the Huawei device.\n\nThis method is a placeholder implementation that always returns False, indicating that no qualification checks are necessary or applicable for the device's current context. It overrides the same method from the parent class, DefaultDeviceHandler.\n\nReturns:\n    bool: Always returns False.\n\nDependencies:\n    This method does not use any external constants or variables and relies solely on its implementation to determine qualification.\"\"\"\n        return False",
        "docstring": "Checks whether a qualification condition is met for the Huawei device.\n\nThis method is a placeholder implementation that always returns False, indicating that no qualification checks are necessary or applicable for the device's current context. It overrides the same method from the parent class, DefaultDeviceHandler.\n\nReturns:\n    bool: Always returns False.\n\nDependencies:\n    This method does not use any external constants or variables and relies solely on its implementation to determine qualification.",
        "signature": "def perform_qualify_check(self):",
        "type": "Method",
        "class_signature": "class HuaweiDeviceHandler(DefaultDeviceHandler):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/huawei.py:HuaweiDeviceHandler:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {},
    "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_capabilities": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {},
    "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_extra_prefix_kwargs": {},
    "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_base_namespace_dict": {}
  },
  "PRD": "# PROJECT NAME: ncclient-test_huawei\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 default.py\n    \u2502   \u2502   \u251c\u2500\u2500 DefaultDeviceHandler.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultDeviceHandler.get_capabilities\n    \u2502   \u2514\u2500\u2500 huawei.py\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.get_capabilities\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2502       \u251c\u2500\u2500 HuaweiDeviceHandler.handle_raw_dispatch\n    \u2502       \u2514\u2500\u2500 HuaweiDeviceHandler.perform_qualify_check\n    \u2514\u2500\u2500 transport/\n        \u2514\u2500\u2500 errors.py\n            \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the integration and communication with Huawei network devices using the NETCONF protocol by leveraging the `ncclient` library. It provides capabilities to handle a wide range of NETCONF features, including session management, enhanced operations like CLI execution and custom action commands, and support for various NETCONF capabilities such as writable running configurations, candidate configuration modes, and validated commits. The module abstracts the complexities of interacting with Huawei devices, offering methods for managing XML namespaces, retrieving supported device capabilities, and dispatching raw commands. By providing a robust handler for Huawei devices, the module streamlines network configuration and management tasks, addressing the need for efficient and standardized device communication for developers and operators.\n\n## FILE 1: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the list of capabilities supported by the device.\n\nThis method combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities added through the device_params during initialization or via other methods. The resulting list of URIs is used during the initial capability exchange between the client and the NETCONF server.\n\nReturns:\n    list: A list of URIs representing the capabilities of the device.\n\nConstants utilized:\n- _BASE_CAPABILITIES: A class constant that defines the default set of capabilities supported by the default device handler. It is used as the foundation for the complete capabilities list returned by this method.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DefaultDeviceHandler instance with optional device parameters.\n\nParameters:\n- device_params (dict, optional): A dictionary containing specific parameters for the device. If not provided, defaults to None.\n\nThis constructor also initializes the capabilities list and processes the exempt error messages defined in the _EXEMPT_ERRORS class variable. The exempt errors are adjusted for case insensitivity and categorized based on their matching patterns (exact match, start wildcard, end wildcard, and full wildcard). These categorizations are crucial for handling RPC error messages that should be ignored rather than raised as exceptions.\n\nThe _EXEMPT_ERRORS constant is defined in the DefaultDeviceHandler class and allows subclasses to specify device-specific error messages that should be exempt from raising exceptions during RPC interactions.\n\"\"\"\n```\n\n## FILE 2: ncclient/transport/errors.py\n\n## FILE 3: ncclient/devices/huawei.py\n\n- CLASS METHOD: HuaweiDeviceHandler.__init__\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a HuaweiDeviceHandler instance by passing device parameters to its superclass.\n\nThis constructor takes a dictionary of `device_params`, which may include parameters specific to the Huawei device, such as \"ssh_subsystem_name\" for configuring the SSH subsystem. This allows for enhanced customization when establishing a connection to the device.\n\nParameters:\n    device_params (dict): A dictionary of parameters required for the device handler, passed to the parent class DefaultDeviceHandler.\n\nReturns:\n    None: This method does not return a value. It initializes the instance of HuaweiDeviceHandler.\n\nThis method interacts with the DefaultDeviceHandler class, which is the base class for all device-specific handlers, ensuring that common initialization tasks are handled consistently.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.perform_qualify_check\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def perform_qualify_check(self):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks whether a qualification condition is met for the Huawei device.\n\nThis method is a placeholder implementation that always returns False, indicating that no qualification checks are necessary or applicable for the device's current context. It overrides the same method from the parent class, DefaultDeviceHandler.\n\nReturns:\n    bool: Always returns False.\n\nDependencies:\n    This method does not use any external constants or variables and relies solely on its implementation to determine qualification.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.handle_raw_dispatch\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def handle_raw_dispatch(self, raw):\n  - DOCSTRING: \n```python\n\"\"\"\nHandles raw input data for Huawei devices by stripping null characters.\n\nParameters:\n    raw (str): The raw input string from the device, which may contain unwanted null characters.\n\nReturns:\n    str: The processed string without trailing null characters.\n\nThis method is specifically designed to clean up the raw output received from Huawei devices before further processing. It ensures that the output is in a usable format by removing any extraneous null characters represented as '\\0'.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary mapping XML namespaces used in Huawei-specific NETCONF operations.\n\nThis method constructs a dictionary with a single entry where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from the `ncclient.xml_` module, represents the base XML namespace for NETCONF operations, ensuring compliance with the NETCONF protocol standards. This method is utilized when forming XML requests or responses that require proper namespace declarations.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing additional XML namespace mapping information \nfor use in XML operations specific to Huawei devices.\n\nThis method gathers the base XML namespace dictionary by calling \n`get_xml_base_namespace_dict()` and returns it wrapped in another dictionary \nwith the key \"nsmap\". The returned dictionary is particularly useful when \nforming XML requests that require specific name-spacing conventions dictated \nby Huawei's NETCONF capabilities.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" mapping to the base XML namespaces.\n\nDependencies:\n    - BASE_NS_1_0: This constant is imported from `ncclient.xml_` and represents \n      the base namespace for XML operations. It ensures that the XML structures \n      comply with the expected standards for Huawei device interaction.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the capabilities of the Huawei device handler by extending the default capabilities defined in the superclass.\n\nThis method calls the parent class's `get_capabilities()` method to obtain a list of default capabilities and appends several Huawei-specific capabilities, such as support for executing CLI commands and action execution. The added capabilities include:\n\n- `http://www.huawei.com/netconf/capability/execute-cli/1.0`\n- `http://www.huawei.com/netconf/capability/action/1.0`\n- `http://www.huawei.com/netconf/capability/active/1.0`\n- `http://www.huawei.com/netconf/capability/discard-commit/1.0`\n- `http://www.huawei.com/netconf/capability/exchange/1.0`\n\nReturns:\n    list: A list of capabilities that includes both the default capabilities inherited from `DefaultDeviceHandler` and the specific Huawei capabilities.\n\nDependencies:\n    - The method relies on the `get_capabilities()` implementation of the superclass, `DefaultDeviceHandler`, for the initial list of capabilities.\n\"\"\"\n```\n\n- CLASS METHOD: HuaweiDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class HuaweiDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary of additional operations specific to Huawei devices.\n\nThis method adds Huawei-specific operations by creating a dictionary that maps \noperation names to their corresponding classes. It includes the `cli` operation mapped \nto the `CLI` class and the `action` operation mapped to the `Action` class. These \nclasses need to be imported from the `ncclient.operations.third_party.huawei.rpc` module, \nwhich enables the execution of CLI commands and action manipulations on Huawei devices.\n\nReturns:\n    dict: A dictionary containing the additional operations available for Huawei devices,\n          specifically including keys \"cli\" and \"action\".\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/devices/huawei.py": "\"\"\"\nHandler for Huawei device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Huawei\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.operations.third_party.huawei.rpc import *\nfrom ncclient.xml_ import BASE_NS_1_0\nfrom .default import DefaultDeviceHandler\n\nclass HuaweiDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Huawei handler for device specific information.\n\n    In the device_params dictionary, which is passed to __init__, you can specify\n    the parameter \"ssh_subsystem_name\". That allows you to configure the preferred\n    SSH subsystem name that should be tried on your Huawei switch. If connecting with\n    that name fails, or you didn't specify that name, the other known subsystem names\n    will be tried. However, if you specify it then this name will be tried first.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []"
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:setUp": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_add_additional_operations": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_get_capabilities": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_capabilities": {
        "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {}
      }
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/huawei.py:HuaweiDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_handle_raw_dispatch": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:handle_raw_dispatch": {}
    },
    "modified_testcases/unit/devices/test_huawei.py:TestHuaweiDevice:test_perform_qualify_check": {
      "ncclient/devices/huawei.py:HuaweiDeviceHandler:perform_qualify_check": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}