{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_tls",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/transport/test_tls.py",
  "test_code": "# Copyright (c) Siemens AG, 2022\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport ssl\nimport sys\nimport unittest\nimport socket\n\ntry:\n    from unittest.mock import MagicMock, patch, call\nexcept ImportError:\n    from mock import MagicMock, patch, call\n\ntry:\n    from ssl import PROTOCOL_TLS_CLIENT\n    tls_proto = PROTOCOL_TLS_CLIENT\nexcept ImportError:\n    from ssl import PROTOCOL_TLS\n    tls_proto = PROTOCOL_TLS\n\nfrom ncclient.transport.errors import TLSError\nfrom ncclient.transport.tls import TLSSession, DEFAULT_TLS_NETCONF_PORT\n\n\nHOST = '10.10.10.10'\nPORT = DEFAULT_TLS_NETCONF_PORT\nKEYFILE = 'test/unit/transport/certs/test.key'\nCERTFILE_WO_KEY = 'test/unit/transport/certs/test.crt'\nCERTFILE_WITH_KEY = 'test/unit/transport/certs/test.pem'\n\n\nclass TestTLS(unittest.TestCase):\n\n    @patch('ssl.SSLContext.wrap_socket')\n    @patch('ncclient.transport.Session._post_connect')\n    def test_connect_tls_certfile_with_key(self, mock_post_connect, mock_wrap_socket_fn):\n        session = TLSSession(MagicMock())\n        mock_wrap_socket = MagicMock()\n        mock_wrap_socket_fn.return_value = mock_wrap_socket\n        session.connect(host=HOST, certfile=CERTFILE_WITH_KEY,\n                        protocol=tls_proto)\n        mock_wrap_socket.connect.assert_called_once_with(\n            (HOST, DEFAULT_TLS_NETCONF_PORT))\n        self.assertTrue(session.connected)\n\n    @patch('ssl.SSLContext.wrap_socket')\n    @patch('ncclient.transport.Session._post_connect')\n    def test_connect_tls_certfile_without_key(self, mock_post_connect, mock_wrap_socket_fn):\n        session = TLSSession(MagicMock())\n        mock_wrap_socket = MagicMock()\n        mock_wrap_socket_fn.return_value = mock_wrap_socket\n        session.connect(host=HOST, certfile=CERTFILE_WO_KEY, keyfile=KEYFILE,\n                        protocol=tls_proto)\n        mock_wrap_socket.connect.assert_called_once_with(\n            (HOST, DEFAULT_TLS_NETCONF_PORT))\n        self.assertTrue(session.connected)\n\n    @unittest.skipIf(sys.version_info < (3, 6), \"test not supported < Python3.6\")\n    @patch('ssl.SSLContext.wrap_socket')\n    @patch('ncclient.transport.Session._post_connect')\n    def test_tls_handshake(self, mock_post_connect, mock_wrap_socket_fn):\n        session = TLSSession(MagicMock())\n        mock_wrap_socket = MagicMock()\n        mock_wrap_socket_fn.return_value = mock_wrap_socket\n        session.connect(host=HOST, certfile=CERTFILE_WITH_KEY,\n                        protocol=tls_proto)\n        mock_wrap_socket.do_handshake.assert_called_once()\n\n    @patch('ssl.SSLContext.wrap_socket')\n    def test_tls_unsuccessul_handshake(self, mock_wrap_socket_fn):\n        session = TLSSession(MagicMock())\n        mock_wrap_socket = MagicMock()\n        mock_wrap_socket.do_handshake = MagicMock(side_effect=ssl.SSLError)\n        mock_wrap_socket_fn.return_value = mock_wrap_socket\n        with self.assertRaises(TLSError):\n            session.connect(host=HOST, certfile=CERTFILE_WITH_KEY,\n                            protocol=tls_proto)\n\n    def test_connect_tls_missing_hostname(self):\n        session = TLSSession(MagicMock())\n        with self.assertRaises(TLSError):\n            session.connect(host=None, certfile=CERTFILE_WITH_KEY,\n                            protocol=tls_proto)\n\n    def test_connect_tls_missing_certfile(self):\n        session = TLSSession(MagicMock())\n        with self.assertRaises(TLSError):\n            session.connect(host=HOST, certfile=None,\n                            protocol=tls_proto)\n\n    def test_connect_tls_missing_private_key(self):\n        session = TLSSession(MagicMock())\n        with self.assertRaises(TLSError):\n            session.connect(host=HOST, certfile=CERTFILE_WO_KEY,\n                            protocol=tls_proto)\n\n    def test_connect_tls_missing_ca_file(self):\n        session = TLSSession(MagicMock())\n        with self.assertRaises(TLSError):\n            # Use arbitrary string to point to non-existing key location.\n            session.connect(host=HOST, certfile=CERTFILE_WITH_KEY,\n                            ca_certs='-', protocol=tls_proto)\n\n    @patch('socket.socket.close')\n    def test_close_tls(self, mock_sock_close_fn):\n        session = TLSSession(MagicMock())\n        session._socket = socket.socket()\n        session._connected = True\n        session.close()\n        mock_sock_close_fn.assert_called_once_with()\n        self.assertFalse(session._connected)\n",
  "GT_file_code": {
    "ncclient/transport/tls.py": "# Copyright (c) Siemens AG, 2022\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport socket\nimport sys\nimport threading\n\nfrom socket import AF_INET, SOCK_STREAM\nfrom ssl import CERT_REQUIRED, SSLContext, SSLError\n\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\n\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TLSError\nfrom ncclient.transport.session import Session\nfrom ncclient.transport.parser import DefaultXMLParser\n\nlogger = logging.getLogger(\"ncclient.transport.tls\")\n\nDEFAULT_TLS_NETCONF_PORT = 6513\nDEFAULT_TLS_TIMEOUT = 120\n\nBUF_SIZE = 4096\n\n\nclass TLSSession(Session):\n\n    def __init__(self, device_handler):\n        capabilities = Capabilities(device_handler.get_capabilities())\n        Session.__init__(self, capabilities)\n        self._host = None\n        self._connected = False\n        self._socket = None\n        self._buffer = StringIO()\n        self._device_handler = device_handler\n        self._message_list = []\n        self._closing = threading.Event()\n        self.parser = DefaultXMLParser(self)\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n\n    def _dispatch_message(self, raw):\n        self.logger.info(\"Received message from host\")\n        self.logger.debug(\"Received:\\n%s\", raw)\n        return super(TLSSession, self)._dispatch_message(raw)\n\n    def close(self):\n        self._closing.set()\n        self._socket.close()\n        self._connected = False\n\n    def connect(self, host=None, port=DEFAULT_TLS_NETCONF_PORT,\n                keyfile=None, certfile=None, ca_certs=None,\n                protocol=None, check_hostname=True, server_hostname=None,\n                timeout=DEFAULT_TLS_TIMEOUT):\n        \"\"\"Establish NETCONF session via TLS.\n\n        :param host: Hostname or IP address to connect to.\n        :param port: Port number which would be used for connection, the\n            default value is 6513 (`DEFAULT_TLS_NETCONF_PORT`).\n        :param certfile: Points to file in PEM format with client's certificate\n            and optionally with client's private key.\n        :param keyfile: Points to file with client's private key in PEM format,\n            if the latter is not in certfile.\n        :param ca_certs: Points to file containing a list of certificates,\n            which should be used to verify server certificate.\n        :param protocol: Protocol version to use. Should be either\n            ssl.PROTOCOL_TLS_CLIENT for Python 3.6+, or ssl.PROTOCOL_TLS\n            for older versions.\n        :param check_hostname: If set to True, perform verification of the\n            hostname during the handshake.\n        :param server_hostname: If set, is used upon hostname checking instead\n            of the `host` parameter.\n        :param timeout: Specifies the connection timeout, defaults to\n            120 seconds (`DEFAULT_TLS_TIMEOUT`).\n\n        :raise TLSError if the connection can not be established.\n        \"\"\"\n        if host is None:\n            raise TLSError('Missing host')\n        if certfile is None:\n            raise TLSError('Missing client certificate file')\n        if protocol is None:\n            raise TLSError('Missing TLS protocol')\n\n        ssl_context = SSLContext(protocol)\n        ssl_context.verify_mode = CERT_REQUIRED\n        ssl_context.check_hostname = check_hostname\n        try:\n            ssl_context.load_cert_chain(certfile=certfile, keyfile=keyfile)\n        except SSLError:\n            raise TLSError('Bad client private key / certificate pair')\n        except IOError:\n            raise TLSError('Private key / certificate pair not found')\n\n        if ca_certs:\n            try:\n                ssl_context.load_verify_locations(cafile=ca_certs)\n            except SSLError:\n                raise TLSError('Bad Certification Authority file')\n            except IOError:\n                raise TLSError('CA certificate file not found')\n\n        sock = socket.socket(AF_INET, SOCK_STREAM)\n        ssl_sock = ssl_context.wrap_socket(\n            sock, do_handshake_on_connect=False,\n            server_hostname=server_hostname or host)\n        ssl_sock.settimeout(timeout)\n\n        try:\n            ssl_sock.connect((host, port))\n        except Exception:\n            raise TLSError(\"Could not connect to %s:%s\" % (host, port))\n\n        try:\n            ssl_sock.do_handshake()\n        except Exception:\n            raise TLSError(\"Unsuccessful TLS handshake with %s:%s\" % (host, port))\n\n        self._host = host\n        self._socket = ssl_sock\n        self._connected = True\n        self._post_connect()\n\n    def _transport_read(self):\n        return self._socket.recv(BUF_SIZE)\n\n    def _transport_write(self, data):\n        return self._socket.send(data)\n\n    def _transport_register(self, selector, event):\n        selector.register(self._socket, event)\n\n    def _send_ready(self):\n        # In contrast to Paramiko's `Channel`, pure python sockets do not\n        # expose `send_ready()` function.\n        return True\n\n    @property\n    def host(self):\n        \"\"\"Host this session is connected to, or None if not connected.\"\"\"\n        if hasattr(self, '_host'):\n            return self._host\n        return None\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/transport/session.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport logging\nfrom threading import Thread, Lock, Event\ntry:\n    from Queue import Queue, Empty\nexcept ImportError:\n    from queue import Queue, Empty\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\n\nimport ncclient.transport\nfrom ncclient.xml_ import *\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TransportError, SessionError, SessionCloseError\nfrom ncclient.transport.notify import Notification\n\nlogger = logging.getLogger('ncclient.transport.session')\n\n# v1.0: RFC 4742\nMSG_DELIM = b\"]]>]]>\"\n# v1.1: RFC 6242\nEND_DELIM = b'\\n##\\n'\n\nTICK = 0.1\n\n\nclass NetconfBase(object):\n    '''Netconf Base protocol version'''\n    BASE_10 = 1\n    BASE_11 = 2\n\n\nclass Session(Thread):\n\n    \"Base class for use by transport protocol implementations.\"\n\n    def __init__(self, capabilities):\n        Thread.__init__(self, daemon=True, name='session')\n        self._listeners = set()\n        self._lock = Lock()\n        self._q = Queue()\n        self._notification_q = Queue()\n        self._client_capabilities = capabilities\n        self._server_capabilities = None # yet\n        self._base = NetconfBase.BASE_10\n        self._id = None # session-id\n        self._connected = False # to be set/cleared by subclass implementation\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n        self.logger.debug('%r created: client_capabilities=%r',\n                          self, self._client_capabilities)\n        self._device_handler = None # Should be set by child class\n\n    def _dispatch_message(self, raw):\n        try:\n            root = parse_root(raw)\n        except Exception as e:\n            device_handled_raw=self._device_handler.handle_raw_dispatch(raw)\n            if isinstance(device_handled_raw, str):\n                root = parse_root(device_handled_raw)\n            elif isinstance(device_handled_raw, Exception):\n                self._dispatch_error(device_handled_raw)\n                return\n            else:\n                self.logger.error('error parsing dispatch message: %s', e)\n                return\n        self.logger.debug('dispatching message to different listeners: %s',\n                          raw)\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching message to listener: %r', l)\n            l.callback(root, raw) # no try-except; fail loudly if you must!\n\n    def _dispatch_error(self, err):\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching error to %r', l)\n            try: # here we can be more considerate with catching exceptions\n                l.errback(err)\n            except Exception as e:\n                self.logger.warning('error dispatching to %r: %r', l, e)\n\n    def _post_connect(self, timeout=60):\n        \"Greeting stuff\"\n        init_event = Event()\n        error = [None] # so that err_cb can bind error[0]. just how it is.\n        # callbacks\n        def ok_cb(id, capabilities):\n            self._id = id\n            self._server_capabilities = capabilities\n            init_event.set()\n        def err_cb(err):\n            error[0] = err\n            init_event.set()\n        self.add_listener(NotificationHandler(self._notification_q))\n        listener = HelloHandler(ok_cb, err_cb)\n        self.add_listener(listener)\n        self.send(HelloHandler.build(self._client_capabilities, self._device_handler))\n        self.logger.debug('starting main loop')\n        self.start()\n        # we expect server's hello message, if server doesn't responds in 60 seconds raise exception\n        init_event.wait(timeout)\n        if not init_event.is_set():\n            raise SessionError(\"Capability exchange timed out\")\n        # received hello message or an error happened\n        self.remove_listener(listener)\n        if error[0]:\n            raise error[0]\n        #if ':base:1.0' not in self.server_capabilities:\n        #    raise MissingCapabilityError(':base:1.0')\n        if 'urn:ietf:params:netconf:base:1.1' in self._server_capabilities and 'urn:ietf:params:netconf:base:1.1' in self._client_capabilities:\n            self.logger.debug(\"After 'hello' message selecting netconf:base:1.1 for encoding\")\n            self._base = NetconfBase.BASE_11\n        self.logger.info('initialized: session-id=%s | server_capabilities=%s',\n                         self._id, self._server_capabilities)\n\n    def add_listener(self, listener):\n        \"\"\"Register a listener that will be notified of incoming messages and\n        errors.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('installing listener %r', listener)\n        if not isinstance(listener, SessionListener):\n            raise SessionError(\"Listener must be a SessionListener type\")\n        with self._lock:\n            self._listeners.add(listener)\n\n    def remove_listener(self, listener):\n        \"\"\"Unregister some listener; ignore if the listener was never\n        registered.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('discarding listener %r', listener)\n        with self._lock:\n            self._listeners.discard(listener)\n\n    def get_listener_instance(self, cls):\n        \"\"\"If a listener of the specified type is registered, returns the\n        instance.\n\n        :type cls: :class:`SessionListener`\n        \"\"\"\n        with self._lock:\n            for listener in self._listeners:\n                if isinstance(listener, cls):\n                    return listener\n\n    def connect(self, *args, **kwds): # subclass implements\n        raise NotImplementedError\n\n    def _transport_read(self):\n        \"\"\"\n        Read data from underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :return: Byte string read from Transport, or None if nothing was read.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_write(self, data):\n        \"\"\"\n        Write data into underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :param data: Byte string to write.\n        :return: Number of bytes sent, or 0 if the stream is closed.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_register(self, selector, event):\n        \"\"\"\n        Register the channel/socket of Transport layer for selection.\n        Implemented in a subclass.\n\n        :param selector: Selector to register with.\n        :param event: Type of event for selection.\n        \"\"\"\n        raise NotImplementedError\n\n    def _send_ready(self):\n        \"\"\"\n        Check if Transport layer is ready to send the data. Implemented\n        in a subclass.\n\n        :return: True if the layer is ready, False otherwise.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self):\n        q = self._q\n\n        def start_delim(data_len):\n            return b'\\n#%i\\n' % data_len\n\n        try:\n            s = selectors.DefaultSelector()\n            self._transport_register(s, selectors.EVENT_READ)\n            self.logger.debug('selector type = %s', s.__class__.__name__)\n            while True:\n                \n                if not q.empty() and self._send_ready():\n                    self.logger.debug(\"Sending message\")\n                    data = q.get().encode()\n                    if self._base == NetconfBase.BASE_11:\n                        data = b\"%s%s%s\" % (start_delim(len(data)), data, END_DELIM)\n                    else:\n                        data = b\"%s%s\" % (data, MSG_DELIM)\n                    self.logger.info(\"Sending:\\n%s\", data)\n                    while data:\n                        n = self._transport_write(data)\n                        if n <= 0:\n                            raise SessionCloseError(self._buffer.getvalue(), data)\n                        data = data[n:]\n                        \n                events = s.select(timeout=TICK)\n                if events:\n                    data = self._transport_read()\n                    if data:\n                        try:\n                            self.parser.parse(data)\n                        except ncclient.transport.parser.SAXFilterXMLNotFoundError:\n                            self.logger.debug('switching from sax to dom parsing')\n                            self.parser = ncclient.transport.parser.DefaultXMLParser(self)\n                            self.parser.parse(data)\n                    elif self._closing.is_set():\n                        # End of session, expected\n                        break\n                    else:\n                        # End of session, unexpected\n                        raise SessionCloseError(self._buffer.getvalue())\n        except Exception as e:\n            self.logger.debug(\"Broke out of main loop, error=%r\", e)\n            self._dispatch_error(e)\n            self.close()\n\n    def send(self, message):\n        \"\"\"Send the supplied *message* (xml string) to NETCONF server.\"\"\"\n        if not self.connected:\n            raise TransportError('Not connected to NETCONF server')\n        self.logger.debug('queueing %s', message)\n        self._q.put(message)\n\n    def scp(self):\n        raise NotImplementedError\n    ### Properties\n\n    def take_notification(self, block, timeout):\n        try:\n            return self._notification_q.get(block, timeout)\n        except Empty:\n            return None\n\n    @property\n    def connected(self):\n        \"Connection status of the session.\"\n        return self._connected\n\n    @property\n    def client_capabilities(self):\n        \"Client's :class:`Capabilities`\"\n        return self._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"Server's :class:`Capabilities`\"\n        return self._server_capabilities\n\n    @property\n    def id(self):\n        \"\"\"A string representing the `session-id`. If the session has not been initialized it will be `None`\"\"\"\n        return self._id\n\n\nclass SessionListener(object):\n\n    \"\"\"Base class for :class:`Session` listeners, which are notified when a new\n    NETCONF message is received or an error occurs.\n\n    .. note::\n        Avoid time-intensive tasks in a callback's context.\n    \"\"\"\n\n    def callback(self, root, raw):\n        \"\"\"Called when a new XML document is received. The *root* argument allows the callback to determine whether it wants to further process the document.\n\n        Here, *root* is a tuple of *(tag, attributes)* where *tag* is the qualified name of the root element and *attributes* is a dictionary of its attributes (also qualified names).\n\n        *raw* will contain the XML document as a string.\n        \"\"\"\n        raise NotImplementedError\n\n    def errback(self, ex):\n        \"\"\"Called when an error occurs.\n\n        :type ex: :exc:`Exception`\n        \"\"\"\n        raise NotImplementedError\n\n\nclass HelloHandler(SessionListener):\n\n    def __init__(self, init_cb, error_cb):\n        self._init_cb = init_cb\n        self._error_cb = error_cb\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if (tag == qualify(\"hello\")) or (tag == \"hello\"):\n            try:\n                id, capabilities = HelloHandler.parse(raw)\n            except Exception as e:\n                self._error_cb(e)\n            else:\n                self._init_cb(id, capabilities)\n\n    def errback(self, err):\n        self._error_cb(err)\n\n    @staticmethod\n    def build(capabilities, device_handler):\n        \"Given a list of capability URI's returns <hello> message XML string\"\n        if device_handler:\n            # This is used as kwargs dictionary for lxml's Element() function.\n            # Therefore the arg-name (\"nsmap\") is used as key here.\n            xml_namespace_kwargs = { \"nsmap\" : device_handler.get_xml_base_namespace_dict() }\n        else:\n            xml_namespace_kwargs = {}\n        hello = new_ele(\"hello\", **xml_namespace_kwargs)\n        caps = sub_ele(hello, \"capabilities\")\n        def fun(uri): sub_ele(caps, \"capability\").text = uri\n        #python3 changes\n        if sys.version < '3':\n            map(fun, capabilities)\n        else:\n            list(map(fun, capabilities))\n        return to_xml(hello)\n\n    @staticmethod\n    def parse(raw):\n        \"Returns tuple of (session-id (str), capabilities (Capabilities)\"\n        sid, capabilities = 0, []\n        root = to_ele(raw)\n        for child in root.getchildren():\n            if child.tag == qualify(\"session-id\") or child.tag == \"session-id\":\n                sid = child.text\n            elif child.tag == qualify(\"capabilities\") or child.tag == \"capabilities\" :\n                for cap in child.getchildren():\n                    if cap.tag == qualify(\"capability\") or cap.tag == \"capability\":\n                        capabilities.append(cap.text)\n        return sid, Capabilities(capabilities)\n\n\nclass NotificationHandler(SessionListener):\n    def __init__(self, notification_q):\n        self._notification_q = notification_q\n\n    def callback(self, root, raw):\n        tag, _ = root\n        if tag == qualify('notification', NETCONF_NOTIFICATION_NS):\n            self._notification_q.put(Notification(raw))\n\n    def errback(self, _):\n        pass\n"
  },
  "GT_src_dict": {
    "ncclient/transport/tls.py": {
      "TLSSession.__init__": {
        "code": "    def __init__(self, device_handler):\n        \"\"\"Initialize a new TLSSession instance.\n\nThis constructor sets up a TLS session for NETCONF communication by initializing various attributes related to the connection state and message handling. It accepts a `device_handler` that provides capabilities for the session.\n\nParameters:\n- device_handler: An object that implements a method `get_capabilities()` to retrieve the NETCONF capabilities for the device being managed.\n\nAttributes initialized:\n- `_host`: Stores the hostname or IP address of the connected device, defaulting to None.\n- `_connected`: Boolean indicator of the connection state, initially set to False.\n- `_socket`: A socket object for the TLS connection, initially set to None.\n- `_buffer`: A StringIO buffer for temporarily holding data, allowing for efficient string manipulation.\n- `_device_handler`: The provided device handler instance for managing device-specific capabilities.\n- `_message_list`: A list for storing messages, initialized as empty.\n- `_closing`: A threading.Event object for signaling when the session is being closed.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML messages.\n- `logger`: A logging adapter to handle session-specific logging.\n\nDependencies:\n- `Capabilities`: A class for managing NETCONF capabilities, sourced from the `ncclient.capabilities` module.\n- `Session`: The parent class from which TLSSession inherits, providing core session functionality.\n- `StringIO`: Used for memory-efficient string manipulation, imported based on Python version compatibility.\"\"\"\n        capabilities = Capabilities(device_handler.get_capabilities())\n        Session.__init__(self, capabilities)\n        self._host = None\n        self._connected = False\n        self._socket = None\n        self._buffer = StringIO()\n        self._device_handler = device_handler\n        self._message_list = []\n        self._closing = threading.Event()\n        self.parser = DefaultXMLParser(self)\n        self.logger = SessionLoggerAdapter(logger, {'session': self})",
        "docstring": "Initialize a new TLSSession instance.\n\nThis constructor sets up a TLS session for NETCONF communication by initializing various attributes related to the connection state and message handling. It accepts a `device_handler` that provides capabilities for the session.\n\nParameters:\n- device_handler: An object that implements a method `get_capabilities()` to retrieve the NETCONF capabilities for the device being managed.\n\nAttributes initialized:\n- `_host`: Stores the hostname or IP address of the connected device, defaulting to None.\n- `_connected`: Boolean indicator of the connection state, initially set to False.\n- `_socket`: A socket object for the TLS connection, initially set to None.\n- `_buffer`: A StringIO buffer for temporarily holding data, allowing for efficient string manipulation.\n- `_device_handler`: The provided device handler instance for managing device-specific capabilities.\n- `_message_list`: A list for storing messages, initialized as empty.\n- `_closing`: A threading.Event object for signaling when the session is being closed.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML messages.\n- `logger`: A logging adapter to handle session-specific logging.\n\nDependencies:\n- `Capabilities`: A class for managing NETCONF capabilities, sourced from the `ncclient.capabilities` module.\n- `Session`: The parent class from which TLSSession inherits, providing core session functionality.\n- `StringIO`: Used for memory-efficient string manipulation, imported based on Python version compatibility.",
        "signature": "def __init__(self, device_handler):",
        "type": "Method",
        "class_signature": "class TLSSession(Session):"
      },
      "TLSSession.close": {
        "code": "    def close(self):\n        \"\"\"Closes the TLS session, ensuring that resources are properly released. This method sets the internal `_closing` event, signals that the session is no longer connected, and closes the underlying socket. Once this method is called, any further communication attempts through this session will fail, as `_connected` is set to `False`.\n\nNo parameters are required. The method updates two internal attributes: \n- `_closing`: a threading event indicating that the session is in the process of closing.\n- `_connected`: a boolean flag that reflects the state of the connection.\"\"\"\n        self._closing.set()\n        self._socket.close()\n        self._connected = False",
        "docstring": "Closes the TLS session, ensuring that resources are properly released. This method sets the internal `_closing` event, signals that the session is no longer connected, and closes the underlying socket. Once this method is called, any further communication attempts through this session will fail, as `_connected` is set to `False`.\n\nNo parameters are required. The method updates two internal attributes: \n- `_closing`: a threading event indicating that the session is in the process of closing.\n- `_connected`: a boolean flag that reflects the state of the connection.",
        "signature": "def close(self):",
        "type": "Method",
        "class_signature": "class TLSSession(Session):"
      },
      "TLSSession.connect": {
        "code": "    def connect(self, host=None, port=DEFAULT_TLS_NETCONF_PORT, keyfile=None, certfile=None, ca_certs=None, protocol=None, check_hostname=True, server_hostname=None, timeout=DEFAULT_TLS_TIMEOUT):\n        \"\"\"Establishes a NETCONF session over TLS with a specified host. This method creates a secure connection using the TLS protocol, ensuring that the client's credentials and server certificate are validated. \n\nParameters:\n- host (str): Hostname or IP address to connect to (mandatory).\n- port (int): Port number for connection, defaulting to 6513 (DEFAULT_TLS_NETCONF_PORT).\n- keyfile (str): Path to the client's private key file in PEM format (optional).\n- certfile (str): Path to the client's certificate file in PEM format (mandatory).\n- ca_certs (str): Path to a CA certificates file for server verification (optional).\n- protocol (ssl.PROTOCOL_TLS_*): Specifies the TLS protocol version to use (mandatory).\n- check_hostname (bool): If True, verifies the server's hostname during the handshake (default is True).\n- server_hostname (str): Overrides the hostname check with this value if specified (optional).\n- timeout (int): Connection timeout in seconds, defaulting to 120 (DEFAULT_TLS_TIMEOUT).\n\nRaises:\n- TLSError: If the connection cannot be established due to missing parameters, failed certificate loading, or failed handshake.\n\nNotes:\n- The DEFAULT_TLS_NETCONF_PORT is defined outside this method and is used as the default port for NETCONF over TLS.\n- The DEFAULT_TLS_TIMEOUT constant specifies the default value for connection timeouts.\n- SSLContext is used from the `ssl` module to configure TLS settings and handle certificate verification.\"\"\"\n        \"Establish NETCONF session via TLS.\\n\\n        :param host: Hostname or IP address to connect to.\\n        :param port: Port number which would be used for connection, the\\n            default value is 6513 (`DEFAULT_TLS_NETCONF_PORT`).\\n        :param certfile: Points to file in PEM format with client's certificate\\n            and optionally with client's private key.\\n        :param keyfile: Points to file with client's private key in PEM format,\\n            if the latter is not in certfile.\\n        :param ca_certs: Points to file containing a list of certificates,\\n            which should be used to verify server certificate.\\n        :param protocol: Protocol version to use. Should be either\\n            ssl.PROTOCOL_TLS_CLIENT for Python 3.6+, or ssl.PROTOCOL_TLS\\n            for older versions.\\n        :param check_hostname: If set to True, perform verification of the\\n            hostname during the handshake.\\n        :param server_hostname: If set, is used upon hostname checking instead\\n            of the `host` parameter.\\n        :param timeout: Specifies the connection timeout, defaults to\\n            120 seconds (`DEFAULT_TLS_TIMEOUT`).\\n\\n        :raise TLSError if the connection can not be established.\\n        \"\n        if host is None:\n            raise TLSError('Missing host')\n        if certfile is None:\n            raise TLSError('Missing client certificate file')\n        if protocol is None:\n            raise TLSError('Missing TLS protocol')\n        ssl_context = SSLContext(protocol)\n        ssl_context.verify_mode = CERT_REQUIRED\n        ssl_context.check_hostname = check_hostname\n        try:\n            ssl_context.load_cert_chain(certfile=certfile, keyfile=keyfile)\n        except SSLError:\n            raise TLSError('Bad client private key / certificate pair')\n        except IOError:\n            raise TLSError('Private key / certificate pair not found')\n        if ca_certs:\n            try:\n                ssl_context.load_verify_locations(cafile=ca_certs)\n            except SSLError:\n                raise TLSError('Bad Certification Authority file')\n            except IOError:\n                raise TLSError('CA certificate file not found')\n        sock = socket.socket(AF_INET, SOCK_STREAM)\n        ssl_sock = ssl_context.wrap_socket(sock, do_handshake_on_connect=False, server_hostname=server_hostname or host)\n        ssl_sock.settimeout(timeout)\n        try:\n            ssl_sock.connect((host, port))\n        except Exception:\n            raise TLSError('Could not connect to %s:%s' % (host, port))\n        try:\n            ssl_sock.do_handshake()\n        except Exception:\n            raise TLSError('Unsuccessful TLS handshake with %s:%s' % (host, port))\n        self._host = host\n        self._socket = ssl_sock\n        self._connected = True\n        self._post_connect()",
        "docstring": "Establishes a NETCONF session over TLS with a specified host. This method creates a secure connection using the TLS protocol, ensuring that the client's credentials and server certificate are validated. \n\nParameters:\n- host (str): Hostname or IP address to connect to (mandatory).\n- port (int): Port number for connection, defaulting to 6513 (DEFAULT_TLS_NETCONF_PORT).\n- keyfile (str): Path to the client's private key file in PEM format (optional).\n- certfile (str): Path to the client's certificate file in PEM format (mandatory).\n- ca_certs (str): Path to a CA certificates file for server verification (optional).\n- protocol (ssl.PROTOCOL_TLS_*): Specifies the TLS protocol version to use (mandatory).\n- check_hostname (bool): If True, verifies the server's hostname during the handshake (default is True).\n- server_hostname (str): Overrides the hostname check with this value if specified (optional).\n- timeout (int): Connection timeout in seconds, defaulting to 120 (DEFAULT_TLS_TIMEOUT).\n\nRaises:\n- TLSError: If the connection cannot be established due to missing parameters, failed certificate loading, or failed handshake.\n\nNotes:\n- The DEFAULT_TLS_NETCONF_PORT is defined outside this method and is used as the default port for NETCONF over TLS.\n- The DEFAULT_TLS_TIMEOUT constant specifies the default value for connection timeouts.\n- SSLContext is used from the `ssl` module to configure TLS settings and handle certificate verification.",
        "signature": "def connect(self, host=None, port=DEFAULT_TLS_NETCONF_PORT, keyfile=None, certfile=None, ca_certs=None, protocol=None, check_hostname=True, server_hostname=None, timeout=DEFAULT_TLS_TIMEOUT):",
        "type": "Method",
        "class_signature": "class TLSSession(Session):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/transport/session.py": {
      "Session.connected": {
        "code": "    def connected(self):\n        \"\"\"@property\ndef connected(self):\"\"\"\n        'Connection status of the session.'\n        return self._connected",
        "docstring": "@property\ndef connected(self):",
        "signature": "def connected(self):",
        "type": "Method",
        "class_signature": "class Session(Thread):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/transport/tls.py:TLSSession:__init__": {
      "ncclient/capabilities.py": {
        "Capabilities.__init__": {
          "code": "    def __init__(self, capabilities):\n        self._dict = {}\n        for uri in capabilities:\n            self.add(uri)",
          "docstring": "",
          "signature": "def __init__(self, capabilities):",
          "type": "Method",
          "class_signature": "class Capabilities(object):"
        }
      },
      "ncclient/transport/session.py": {
        "Session.__init__": {
          "code": "    def __init__(self, capabilities):\n        Thread.__init__(self, daemon=True, name='session')\n        self._listeners = set()\n        self._lock = Lock()\n        self._q = Queue()\n        self._notification_q = Queue()\n        self._client_capabilities = capabilities\n        self._server_capabilities = None\n        self._base = NetconfBase.BASE_10\n        self._id = None\n        self._connected = False\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n        self.logger.debug('%r created: client_capabilities=%r', self, self._client_capabilities)\n        self._device_handler = None",
          "docstring": "",
          "signature": "def __init__(self, capabilities):",
          "type": "Method",
          "class_signature": "class Session(Thread):"
        }
      },
      "ncclient/transport/parser.py": {
        "DefaultXMLParser.__init__": {
          "code": "    def __init__(self, session):\n        \"\"\"\n        DOM Parser\n\n        :param session: ssh session object\n        \"\"\"\n        self._session = session\n        self._parsing_pos10 = 0\n        self.logger = SessionLoggerAdapter(logger, {'session': self._session})",
          "docstring": "DOM Parser\n\n:param session: ssh session object",
          "signature": "def __init__(self, session):",
          "type": "Method",
          "class_signature": "class DefaultXMLParser(object):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_close_tls": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:close": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_certfile_with_key": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {},
      "ncclient/transport/session.py:Session:connected": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_certfile_without_key": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {},
      "ncclient/transport/session.py:Session:connected": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_missing_ca_file": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_missing_certfile": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_missing_hostname": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_connect_tls_missing_private_key": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_tls_handshake": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "modified_testcases/unit/transport/test_tls.py:TestTLS:test_tls_unsuccessul_handshake": {
      "ncclient/transport/tls.py:TLSSession:__init__": {
        "ncclient/capabilities.py:Capabilities:__init__": {},
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/transport/tls.py:TLSSession:connect": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_tls/ncclient-test_tls/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_tls\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u2514\u2500\u2500 transport/\n        \u251c\u2500\u2500 errors.py\n        \u2502   \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n        \u251c\u2500\u2500 session.py\n        \u2502   \u2514\u2500\u2500 Session.connected\n        \u2514\u2500\u2500 tls.py\n            \u251c\u2500\u2500 TLSSession.__init__\n            \u251c\u2500\u2500 TLSSession.close\n            \u2514\u2500\u2500 TLSSession.connect\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the testing and validation of Transport Layer Security (TLS) connections for NETCONF communication sessions in network management applications. It provides functionality to establish, verify, and manage secure TLS connections using client-provided certificates, keys, and protocols, ensuring compliance with secure communication standards. The module includes capabilities to test certificate validity, proper handshake execution, error handling for missing or invalid credentials, and session closure. By simulating various TLS scenarios and edge cases, it ensures robust implementation and error resilience in secure NETCONF transports, simplifying the development and debugging for engineers working with secure network configurations.\n\n## FILE 1: ncclient/transport/tls.py\n\n- CLASS METHOD: TLSSession.close\n  - CLASS SIGNATURE: class TLSSession(Session):\n  - SIGNATURE: def close(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCloses the TLS session, ensuring that resources are properly released. This method sets the internal `_closing` event, signals that the session is no longer connected, and closes the underlying socket. Once this method is called, any further communication attempts through this session will fail, as `_connected` is set to `False`.\n\nNo parameters are required. The method updates two internal attributes: \n- `_closing`: a threading event indicating that the session is in the process of closing.\n- `_connected`: a boolean flag that reflects the state of the connection.\n\"\"\"\n```\n\n- CLASS METHOD: TLSSession.__init__\n  - CLASS SIGNATURE: class TLSSession(Session):\n  - SIGNATURE: def __init__(self, device_handler):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new TLSSession instance.\n\nThis constructor sets up a TLS session for NETCONF communication by initializing various attributes related to the connection state and message handling. It accepts a `device_handler` that provides capabilities for the session.\n\nParameters:\n- device_handler: An object that implements a method `get_capabilities()` to retrieve the NETCONF capabilities for the device being managed.\n\nAttributes initialized:\n- `_host`: Stores the hostname or IP address of the connected device, defaulting to None.\n- `_connected`: Boolean indicator of the connection state, initially set to False.\n- `_socket`: A socket object for the TLS connection, initially set to None.\n- `_buffer`: A StringIO buffer for temporarily holding data, allowing for efficient string manipulation.\n- `_device_handler`: The provided device handler instance for managing device-specific capabilities.\n- `_message_list`: A list for storing messages, initialized as empty.\n- `_closing`: A threading.Event object for signaling when the session is being closed.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML messages.\n- `logger`: A logging adapter to handle session-specific logging.\n\nDependencies:\n- `Capabilities`: A class for managing NETCONF capabilities, sourced from the `ncclient.capabilities` module.\n- `Session`: The parent class from which TLSSession inherits, providing core session functionality.\n- `StringIO`: Used for memory-efficient string manipulation, imported based on Python version compatibility.\n\"\"\"\n```\n\n- CLASS METHOD: TLSSession.connect\n  - CLASS SIGNATURE: class TLSSession(Session):\n  - SIGNATURE: def connect(self, host=None, port=DEFAULT_TLS_NETCONF_PORT, keyfile=None, certfile=None, ca_certs=None, protocol=None, check_hostname=True, server_hostname=None, timeout=DEFAULT_TLS_TIMEOUT):\n  - DOCSTRING: \n```python\n\"\"\"\nEstablishes a NETCONF session over TLS with a specified host. This method creates a secure connection using the TLS protocol, ensuring that the client's credentials and server certificate are validated. \n\nParameters:\n- host (str): Hostname or IP address to connect to (mandatory).\n- port (int): Port number for connection, defaulting to 6513 (DEFAULT_TLS_NETCONF_PORT).\n- keyfile (str): Path to the client's private key file in PEM format (optional).\n- certfile (str): Path to the client's certificate file in PEM format (mandatory).\n- ca_certs (str): Path to a CA certificates file for server verification (optional).\n- protocol (ssl.PROTOCOL_TLS_*): Specifies the TLS protocol version to use (mandatory).\n- check_hostname (bool): If True, verifies the server's hostname during the handshake (default is True).\n- server_hostname (str): Overrides the hostname check with this value if specified (optional).\n- timeout (int): Connection timeout in seconds, defaulting to 120 (DEFAULT_TLS_TIMEOUT).\n\nRaises:\n- TLSError: If the connection cannot be established due to missing parameters, failed certificate loading, or failed handshake.\n\nNotes:\n- The DEFAULT_TLS_NETCONF_PORT is defined outside this method and is used as the default port for NETCONF over TLS.\n- The DEFAULT_TLS_TIMEOUT constant specifies the default value for connection timeouts.\n- SSLContext is used from the `ssl` module to configure TLS settings and handle certificate verification.\n\"\"\"\n```\n\n## FILE 2: ncclient/transport/errors.py\n\n## FILE 3: ncclient/transport/session.py\n\n- CLASS METHOD: Session.connected\n  - CLASS SIGNATURE: class Session(Thread):\n  - SIGNATURE: def connected(self):\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef connected(self):\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/transport/tls.py": "import logging\nimport socket\nimport sys\nimport threading\nfrom socket import AF_INET, SOCK_STREAM\nfrom ssl import CERT_REQUIRED, SSLContext, SSLError\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TLSError\nfrom ncclient.transport.session import Session\nfrom ncclient.transport.parser import DefaultXMLParser\nlogger = logging.getLogger('ncclient.transport.tls')\nDEFAULT_TLS_NETCONF_PORT = 6513\nDEFAULT_TLS_TIMEOUT = 120\nBUF_SIZE = 4096\n\nclass TLSSession(Session):\n\n    def _dispatch_message(self, raw):\n        self.logger.info('Received message from host')\n        self.logger.debug('Received:\\n%s', raw)\n        return super(TLSSession, self)._dispatch_message(raw)\n\n    def _transport_read(self):\n        return self._socket.recv(BUF_SIZE)\n\n    def _transport_write(self, data):\n        return self._socket.send(data)\n\n    def _transport_register(self, selector, event):\n        selector.register(self._socket, event)\n\n    def _send_ready(self):\n        return True\n\n    @property\n    def host(self):\n        \"\"\"Host this session is connected to, or None if not connected.\"\"\"\n        if hasattr(self, '_host'):\n            return self._host\n        return None",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/transport/session.py": "import logging\nfrom threading import Thread, Lock, Event\ntry:\n    from Queue import Queue, Empty\nexcept ImportError:\n    from queue import Queue, Empty\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\nimport ncclient.transport\nfrom ncclient.xml_ import *\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TransportError, SessionError, SessionCloseError\nfrom ncclient.transport.notify import Notification\nlogger = logging.getLogger('ncclient.transport.session')\nMSG_DELIM = b']]>]]>'\nEND_DELIM = b'\\n##\\n'\nTICK = 0.1\n\nclass NetconfBase(object):\n    \"\"\"Netconf Base protocol version\"\"\"\n    BASE_10 = 1\n    BASE_11 = 2\n\nclass Session(Thread):\n    \"\"\"Base class for use by transport protocol implementations.\"\"\"\n\n    def __init__(self, capabilities):\n        Thread.__init__(self, daemon=True, name='session')\n        self._listeners = set()\n        self._lock = Lock()\n        self._q = Queue()\n        self._notification_q = Queue()\n        self._client_capabilities = capabilities\n        self._server_capabilities = None\n        self._base = NetconfBase.BASE_10\n        self._id = None\n        self._connected = False\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n        self.logger.debug('%r created: client_capabilities=%r', self, self._client_capabilities)\n        self._device_handler = None\n\n    def _dispatch_message(self, raw):\n        try:\n            root = parse_root(raw)\n        except Exception as e:\n            device_handled_raw = self._device_handler.handle_raw_dispatch(raw)\n            if isinstance(device_handled_raw, str):\n                root = parse_root(device_handled_raw)\n            elif isinstance(device_handled_raw, Exception):\n                self._dispatch_error(device_handled_raw)\n                return\n            else:\n                self.logger.error('error parsing dispatch message: %s', e)\n                return\n        self.logger.debug('dispatching message to different listeners: %s', raw)\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching message to listener: %r', l)\n            l.callback(root, raw)\n\n    def _dispatch_error(self, err):\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching error to %r', l)\n            try:\n                l.errback(err)\n            except Exception as e:\n                self.logger.warning('error dispatching to %r: %r', l, e)\n\n    def _post_connect(self, timeout=60):\n        \"\"\"Greeting stuff\"\"\"\n        init_event = Event()\n        error = [None]\n\n        def ok_cb(id, capabilities):\n            self._id = id\n            self._server_capabilities = capabilities\n            init_event.set()\n\n        def err_cb(err):\n            error[0] = err\n            init_event.set()\n        self.add_listener(NotificationHandler(self._notification_q))\n        listener = HelloHandler(ok_cb, err_cb)\n        self.add_listener(listener)\n        self.send(HelloHandler.build(self._client_capabilities, self._device_handler))\n        self.logger.debug('starting main loop')\n        self.start()\n        init_event.wait(timeout)\n        if not init_event.is_set():\n            raise SessionError('Capability exchange timed out')\n        self.remove_listener(listener)\n        if error[0]:\n            raise error[0]\n        if 'urn:ietf:params:netconf:base:1.1' in self._server_capabilities and 'urn:ietf:params:netconf:base:1.1' in self._client_capabilities:\n            self.logger.debug(\"After 'hello' message selecting netconf:base:1.1 for encoding\")\n            self._base = NetconfBase.BASE_11\n        self.logger.info('initialized: session-id=%s | server_capabilities=%s', self._id, self._server_capabilities)\n\n    def add_listener(self, listener):\n        \"\"\"Register a listener that will be notified of incoming messages and\n        errors.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('installing listener %r', listener)\n        if not isinstance(listener, SessionListener):\n            raise SessionError('Listener must be a SessionListener type')\n        with self._lock:\n            self._listeners.add(listener)\n\n    def remove_listener(self, listener):\n        \"\"\"Unregister some listener; ignore if the listener was never\n        registered.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('discarding listener %r', listener)\n        with self._lock:\n            self._listeners.discard(listener)\n\n    def get_listener_instance(self, cls):\n        \"\"\"If a listener of the specified type is registered, returns the\n        instance.\n\n        :type cls: :class:`SessionListener`\n        \"\"\"\n        with self._lock:\n            for listener in self._listeners:\n                if isinstance(listener, cls):\n                    return listener\n\n    def connect(self, *args, **kwds):\n        raise NotImplementedError\n\n    def _transport_read(self):\n        \"\"\"\n        Read data from underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :return: Byte string read from Transport, or None if nothing was read.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_write(self, data):\n        \"\"\"\n        Write data into underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :param data: Byte string to write.\n        :return: Number of bytes sent, or 0 if the stream is closed.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_register(self, selector, event):\n        \"\"\"\n        Register the channel/socket of Transport layer for selection.\n        Implemented in a subclass.\n\n        :param selector: Selector to register with.\n        :param event: Type of event for selection.\n        \"\"\"\n        raise NotImplementedError\n\n    def _send_ready(self):\n        \"\"\"\n        Check if Transport layer is ready to send the data. Implemented\n        in a subclass.\n\n        :return: True if the layer is ready, False otherwise.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self):\n        q = self._q\n\n        def start_delim(data_len):\n            return b'\\n#%i\\n' % data_len\n        try:\n            s = selectors.DefaultSelector()\n            self._transport_register(s, selectors.EVENT_READ)\n            self.logger.debug('selector type = %s', s.__class__.__name__)\n            while True:\n                if not q.empty() and self._send_ready():\n                    self.logger.debug('Sending message')\n                    data = q.get().encode()\n                    if self._base == NetconfBase.BASE_11:\n                        data = b'%s%s%s' % (start_delim(len(data)), data, END_DELIM)\n                    else:\n                        data = b'%s%s' % (data, MSG_DELIM)\n                    self.logger.info('Sending:\\n%s', data)\n                    while data:\n                        n = self._transport_write(data)\n                        if n <= 0:\n                            raise SessionCloseError(self._buffer.getvalue(), data)\n                        data = data[n:]\n                events = s.select(timeout=TICK)\n                if events:\n                    data = self._transport_read()\n                    if data:\n                        try:\n                            self.parser.parse(data)\n                        except ncclient.transport.parser.SAXFilterXMLNotFoundError:\n                            self.logger.debug('switching from sax to dom parsing')\n                            self.parser = ncclient.transport.parser.DefaultXMLParser(self)\n                            self.parser.parse(data)\n                    elif self._closing.is_set():\n                        break\n                    else:\n                        raise SessionCloseError(self._buffer.getvalue())\n        except Exception as e:\n            self.logger.debug('Broke out of main loop, error=%r', e)\n            self._dispatch_error(e)\n            self.close()\n\n    def send(self, message):\n        \"\"\"Send the supplied *message* (xml string) to NETCONF server.\"\"\"\n        if not self.connected:\n            raise TransportError('Not connected to NETCONF server')\n        self.logger.debug('queueing %s', message)\n        self._q.put(message)\n\n    def scp(self):\n        raise NotImplementedError\n\n    def take_notification(self, block, timeout):\n        try:\n            return self._notification_q.get(block, timeout)\n        except Empty:\n            return None\n\n    @property\n    def client_capabilities(self):\n        \"\"\"Client's :class:`Capabilities`\"\"\"\n        return self._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"\"\"Server's :class:`Capabilities`\"\"\"\n        return self._server_capabilities\n\n    @property\n    def id(self):\n        \"\"\"A string representing the `session-id`. If the session has not been initialized it will be `None`\"\"\"\n        return self._id\n\nclass SessionListener(object):\n    \"\"\"Base class for :class:`Session` listeners, which are notified when a new\n    NETCONF message is received or an error occurs.\n\n    .. note::\n        Avoid time-intensive tasks in a callback's context.\n    \"\"\"\n\n    def callback(self, root, raw):\n        \"\"\"Called when a new XML document is received. The *root* argument allows the callback to determine whether it wants to further process the document.\n\n        Here, *root* is a tuple of *(tag, attributes)* where *tag* is the qualified name of the root element and *attributes* is a dictionary of its attributes (also qualified names).\n\n        *raw* will contain the XML document as a string.\n        \"\"\"\n        raise NotImplementedError\n\n    def errback(self, ex):\n        \"\"\"Called when an error occurs.\n\n        :type ex: :exc:`Exception`\n        \"\"\"\n        raise NotImplementedError\n\nclass HelloHandler(SessionListener):\n\n    def __init__(self, init_cb, error_cb):\n        self._init_cb = init_cb\n        self._error_cb = error_cb\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if tag == qualify('hello') or tag == 'hello':\n            try:\n                id, capabilities = HelloHandler.parse(raw)\n            except Exception as e:\n                self._error_cb(e)\n            else:\n                self._init_cb(id, capabilities)\n\n    def errback(self, err):\n        self._error_cb(err)\n\n    @staticmethod\n    def build(capabilities, device_handler):\n        \"\"\"Given a list of capability URI's returns <hello> message XML string\"\"\"\n        if device_handler:\n            xml_namespace_kwargs = {'nsmap': device_handler.get_xml_base_namespace_dict()}\n        else:\n            xml_namespace_kwargs = {}\n        hello = new_ele('hello', **xml_namespace_kwargs)\n        caps = sub_ele(hello, 'capabilities')\n\n        def fun(uri):\n            sub_ele(caps, 'capability').text = uri\n        if sys.version < '3':\n            map(fun, capabilities)\n        else:\n            list(map(fun, capabilities))\n        return to_xml(hello)\n\n    @staticmethod\n    def parse(raw):\n        \"\"\"Returns tuple of (session-id (str), capabilities (Capabilities)\"\"\"\n        sid, capabilities = (0, [])\n        root = to_ele(raw)\n        for child in root.getchildren():\n            if child.tag == qualify('session-id') or child.tag == 'session-id':\n                sid = child.text\n            elif child.tag == qualify('capabilities') or child.tag == 'capabilities':\n                for cap in child.getchildren():\n                    if cap.tag == qualify('capability') or cap.tag == 'capability':\n                        capabilities.append(cap.text)\n        return (sid, Capabilities(capabilities))\n\nclass NotificationHandler(SessionListener):\n\n    def __init__(self, notification_q):\n        self._notification_q = notification_q\n\n    def callback(self, root, raw):\n        tag, _ = root\n        if tag == qualify('notification', NETCONF_NOTIFICATION_NS):\n            self._notification_q.put(Notification(raw))\n\n    def errback(self, _):\n        pass"
  }
}