{
  "dir_path": "/app/uvicorn",
  "package_name": "uvicorn",
  "sample_name": "uvicorn-test_multiprocess",
  "src_dir": "uvicorn/",
  "test_dir": "tests/",
  "test_file": "tests/supervisors/test_multiprocess.py",
  "test_code": "from __future__ import annotations\n\nimport functools\nimport os\nimport signal\nimport socket\nimport threading\nimport time\nfrom typing import Any, Callable\n\nimport pytest\n\nfrom uvicorn import Config\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\nfrom uvicorn.supervisors import Multiprocess\nfrom uvicorn.supervisors.multiprocess import Process\n\n\ndef new_console_in_windows(test_function: Callable[[], Any]) -> Callable[[], Any]:  # pragma: no cover\n    if os.name != \"nt\":\n        return test_function\n\n    @functools.wraps(test_function)\n    def new_function():\n        import subprocess\n        import sys\n\n        module = test_function.__module__\n        name = test_function.__name__\n\n        subprocess.check_call(\n            [\n                sys.executable,\n                \"-c\",\n                f\"from {module} import {name}; {name}.__wrapped__()\",\n            ],\n            creationflags=subprocess.CREATE_NO_WINDOW,  # type: ignore[attr-defined]\n        )\n\n    return new_function\n\n\nasync def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:\n    pass  # pragma: no cover\n\n\ndef run(sockets: list[socket.socket] | None) -> None:\n    while True:  # pragma: no cover\n        time.sleep(1)\n\n\ndef test_process_ping_pong() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    threading.Thread(target=process.always_pong, daemon=True).start()\n    assert process.ping()\n\n\ndef test_process_ping_pong_timeout() -> None:\n    process = Process(Config(app=app), target=lambda x: None, sockets=[])\n    assert not process.ping(0.1)\n\n\n@new_console_in_windows\ndef test_multiprocess_run() -> None:\n    \"\"\"\n    A basic sanity check.\n\n    Simply run the supervisor against a no-op server, and signal for it to\n    quit immediately.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()\n\n\n@new_console_in_windows\ndef test_multiprocess_health_check() -> None:\n    \"\"\"\n    Ensure that the health check works as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    process = supervisor.processes[0]\n    process.kill()\n    assert not process.is_alive()\n    time.sleep(1)\n    for p in supervisor.processes:\n        assert p.is_alive()\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()\n\n\n@new_console_in_windows\ndef test_multiprocess_sigterm() -> None:\n    \"\"\"\n    Ensure that the SIGTERM signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(signal.SIGTERM)\n    supervisor.join_all()\n\n\n@pytest.mark.skipif(not hasattr(signal, \"SIGBREAK\"), reason=\"platform unsupports SIGBREAK\")\n@new_console_in_windows\ndef test_multiprocess_sigbreak() -> None:  # pragma: py-not-win32\n    \"\"\"\n    Ensure that the SIGBREAK signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    supervisor.signal_queue.append(getattr(signal, \"SIGBREAK\"))\n    supervisor.join_all()\n\n\n@pytest.mark.skipif(not hasattr(signal, \"SIGHUP\"), reason=\"platform unsupports SIGHUP\")\ndef test_multiprocess_sighup() -> None:\n    \"\"\"\n    Ensure that the SIGHUP signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    time.sleep(1)\n    pids = [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGHUP)\n    time.sleep(1)\n    assert pids != [p.pid for p in supervisor.processes]\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()\n\n\n@pytest.mark.skipif(not hasattr(signal, \"SIGTTIN\"), reason=\"platform unsupports SIGTTIN\")\ndef test_multiprocess_sigttin() -> None:\n    \"\"\"\n    Ensure that the SIGTTIN signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTIN)\n    time.sleep(1)\n    assert len(supervisor.processes) == 3\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()\n\n\n@pytest.mark.skipif(not hasattr(signal, \"SIGTTOU\"), reason=\"platform unsupports SIGTTOU\")\ndef test_multiprocess_sigttou() -> None:\n    \"\"\"\n    Ensure that the SIGTTOU signal is handled as expected.\n    \"\"\"\n    config = Config(app=app, workers=2)\n    supervisor = Multiprocess(config, target=run, sockets=[])\n    threading.Thread(target=supervisor.run, daemon=True).start()\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGTTOU)\n    time.sleep(1)\n    assert len(supervisor.processes) == 1\n    supervisor.signal_queue.append(signal.SIGINT)\n    supervisor.join_all()\n",
  "GT_file_code": {
    "uvicorn/supervisors/multiprocess.py": "from __future__ import annotations\n\nimport logging\nimport os\nimport signal\nimport threading\nfrom multiprocessing import Pipe\nfrom socket import socket\nfrom typing import Any, Callable\n\nimport click\n\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\n\nSIGNALS = {\n    getattr(signal, f\"SIG{x}\"): x\n    for x in \"INT TERM BREAK HUP QUIT TTIN TTOU USR1 USR2 WINCH\".split()\n    if hasattr(signal, f\"SIG{x}\")\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\nclass Process:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.real_target = target\n\n        self.parent_conn, self.child_conn = Pipe()\n        self.process = get_subprocess(config, self.target, sockets)\n\n    def ping(self, timeout: float = 5) -> bool:\n        self.parent_conn.send(b\"ping\")\n        if self.parent_conn.poll(timeout):\n            self.parent_conn.recv()\n            return True\n        return False\n\n    def pong(self) -> None:\n        self.child_conn.recv()\n        self.child_conn.send(b\"pong\")\n\n    def always_pong(self) -> None:\n        while True:\n            self.pong()\n\n    def target(self, sockets: list[socket] | None = None) -> Any:  # pragma: no cover\n        if os.name == \"nt\":  # pragma: py-not-win32\n            # Windows doesn't support SIGTERM, so we use SIGBREAK instead.\n            # And then we raise SIGTERM when SIGBREAK is received.\n            # https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/signal?view=msvc-170\n            signal.signal(\n                signal.SIGBREAK,  # type: ignore[attr-defined]\n                lambda sig, frame: signal.raise_signal(signal.SIGTERM),\n            )\n\n        threading.Thread(target=self.always_pong, daemon=True).start()\n        return self.real_target(sockets)\n\n    def is_alive(self, timeout: float = 5) -> bool:\n        if not self.process.is_alive():\n            return False  # pragma: full coverage\n\n        return self.ping(timeout)\n\n    def start(self) -> None:\n        self.process.start()\n\n    def terminate(self) -> None:\n        if self.process.exitcode is None:  # Process is still running\n            assert self.process.pid is not None\n            if os.name == \"nt\":  # pragma: py-not-win32\n                # Windows doesn't support SIGTERM.\n                # So send SIGBREAK, and then in process raise SIGTERM.\n                os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)  # type: ignore[attr-defined]\n            else:\n                os.kill(self.process.pid, signal.SIGTERM)\n            logger.info(f\"Terminated child process [{self.process.pid}]\")\n\n            self.parent_conn.close()\n            self.child_conn.close()\n\n    def kill(self) -> None:\n        # In Windows, the method will call `TerminateProcess` to kill the process.\n        # In Unix, the method will send SIGKILL to the process.\n        self.process.kill()\n\n    def join(self) -> None:\n        logger.info(f\"Waiting for child process [{self.process.pid}]\")\n        self.process.join()\n\n    @property\n    def pid(self) -> int | None:\n        return self.process.pid\n\n\nclass Multiprocess:\n    def __init__(\n        self,\n        config: Config,\n        target: Callable[[list[socket] | None], None],\n        sockets: list[socket],\n    ) -> None:\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n\n        self.processes_num = config.workers\n        self.processes: list[Process] = []\n\n        self.should_exit = threading.Event()\n\n        self.signal_queue: list[int] = []\n        for sig in SIGNALS:\n            signal.signal(sig, lambda sig, frame: self.signal_queue.append(sig))\n\n    def init_processes(self) -> None:\n        for _ in range(self.processes_num):\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes.append(process)\n\n    def terminate_all(self) -> None:\n        for process in self.processes:\n            process.terminate()\n\n    def join_all(self) -> None:\n        for process in self.processes:\n            process.join()\n\n    def restart_all(self) -> None:\n        for idx, process in enumerate(self.processes):\n            process.terminate()\n            process.join()\n            new_process = Process(self.config, self.target, self.sockets)\n            new_process.start()\n            self.processes[idx] = new_process\n\n    def run(self) -> None:\n        message = f\"Started parent process [{os.getpid()}]\"\n        color_message = \"Started parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n        self.init_processes()\n\n        while not self.should_exit.wait(0.5):\n            self.handle_signals()\n            self.keep_subprocess_alive()\n\n        self.terminate_all()\n        self.join_all()\n\n        message = f\"Stopping parent process [{os.getpid()}]\"\n        color_message = \"Stopping parent process [{}]\".format(click.style(str(os.getpid()), fg=\"cyan\", bold=True))\n        logger.info(message, extra={\"color_message\": color_message})\n\n    def keep_subprocess_alive(self) -> None:\n        if self.should_exit.is_set():\n            return  # parent process is exiting, no need to keep subprocess alive\n\n        for idx, process in enumerate(self.processes):\n            if process.is_alive():\n                continue\n\n            process.kill()  # process is hung, kill it\n            process.join()\n\n            if self.should_exit.is_set():\n                return  # pragma: full coverage\n\n            logger.info(f\"Child process [{process.pid}] died\")\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes[idx] = process\n\n    def handle_signals(self) -> None:\n        for sig in tuple(self.signal_queue):\n            self.signal_queue.remove(sig)\n            sig_name = SIGNALS[sig]\n            sig_handler = getattr(self, f\"handle_{sig_name.lower()}\", None)\n            if sig_handler is not None:\n                sig_handler()\n            else:  # pragma: no cover\n                logger.debug(f\"Received signal {sig_name}, but no handler is defined for it.\")\n\n    def handle_int(self) -> None:\n        logger.info(\"Received SIGINT, exiting.\")\n        self.should_exit.set()\n\n    def handle_term(self) -> None:\n        logger.info(\"Received SIGTERM, exiting.\")\n        self.should_exit.set()\n\n    def handle_break(self) -> None:  # pragma: py-not-win32\n        logger.info(\"Received SIGBREAK, exiting.\")\n        self.should_exit.set()\n\n    def handle_hup(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGHUP, restarting processes.\")\n        self.restart_all()\n\n    def handle_ttin(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTIN, increasing the number of processes.\")\n        self.processes_num += 1\n        process = Process(self.config, self.target, self.sockets)\n        process.start()\n        self.processes.append(process)\n\n    def handle_ttou(self) -> None:  # pragma: py-win32\n        logger.info(\"Received SIGTTOU, decreasing number of processes.\")\n        if self.processes_num <= 1:\n            logger.info(\"Already reached one process, cannot decrease the number of processes anymore.\")\n            return\n        self.processes_num -= 1\n        process = self.processes.pop()\n        process.terminate()\n        process.join()\n",
    "uvicorn/config.py": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Awaitable, Callable, Literal\n\nimport click\n\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware\n\nHTTPProtocolType = Literal[\"auto\", \"h11\", \"httptools\"]\nWSProtocolType = Literal[\"auto\", \"none\", \"websockets\", \"wsproto\"]\nLifespanType = Literal[\"auto\", \"on\", \"off\"]\nLoopSetupType = Literal[\"none\", \"auto\", \"asyncio\", \"uvloop\"]\nInterfaceType = Literal[\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nLOG_LEVELS: dict[str, int] = {\n    \"critical\": logging.CRITICAL,\n    \"error\": logging.ERROR,\n    \"warning\": logging.WARNING,\n    \"info\": logging.INFO,\n    \"debug\": logging.DEBUG,\n    \"trace\": TRACE_LOG_LEVEL,\n}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {\n    \"auto\": \"uvicorn.protocols.http.auto:AutoHTTPProtocol\",\n    \"h11\": \"uvicorn.protocols.http.h11_impl:H11Protocol\",\n    \"httptools\": \"uvicorn.protocols.http.httptools_impl:HttpToolsProtocol\",\n}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {\n    \"auto\": \"uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol\",\n    \"none\": None,\n    \"websockets\": \"uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol\",\n    \"wsproto\": \"uvicorn.protocols.websockets.wsproto_impl:WSProtocol\",\n}\nLIFESPAN: dict[LifespanType, str] = {\n    \"auto\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"on\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"off\": \"uvicorn.lifespan.off:LifespanOff\",\n}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {\n    \"none\": None,\n    \"auto\": \"uvicorn.loops.auto:auto_loop_setup\",\n    \"asyncio\": \"uvicorn.loops.asyncio:asyncio_setup\",\n    \"uvloop\": \"uvicorn.loops.uvloop:uvloop_setup\",\n}\nINTERFACES: list[InterfaceType] = [\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\n\nLOGGING_CONFIG: dict[str, Any] = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": \"%(levelprefix)s %(message)s\",\n            \"use_colors\": None,\n        },\n        \"access\": {\n            \"()\": \"uvicorn.logging.AccessFormatter\",\n            \"fmt\": '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n        },\n    },\n    \"handlers\": {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n        \"access\": {\n            \"formatter\": \"access\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"loggers\": {\n        \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"INFO\", \"propagate\": False},\n        \"uvicorn.error\": {\"level\": \"INFO\"},\n        \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"INFO\", \"propagate\": False},\n    },\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\ndef create_ssl_context(\n    certfile: str | os.PathLike[str],\n    keyfile: str | os.PathLike[str] | None,\n    password: str | None,\n    ssl_version: int,\n    cert_reqs: int,\n    ca_certs: str | os.PathLike[str] | None,\n    ciphers: str | None,\n) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx\n\n\ndef is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:  # pragma: full coverage\n        return False\n\n\ndef resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        # Special case for the .* pattern, otherwise this would only match\n        # hidden directories which is probably undesired\n        if pattern == \".*\":\n            continue\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):  # pragma: full coverage\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n\n    directories = list(set(directories).difference(set(children)))\n\n    return list(set(patterns)), directories\n\n\ndef _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))\n\n\nclass Config:\n    def __init__(\n        self,\n        app: ASGIApplication | Callable[..., Any] | str,\n        host: str = \"127.0.0.1\",\n        port: int = 8000,\n        uds: str | None = None,\n        fd: int | None = None,\n        loop: LoopSetupType = \"auto\",\n        http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n        ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n        ws_max_size: int = 16 * 1024 * 1024,\n        ws_max_queue: int = 32,\n        ws_ping_interval: float | None = 20.0,\n        ws_ping_timeout: float | None = 20.0,\n        ws_per_message_deflate: bool = True,\n        lifespan: LifespanType = \"auto\",\n        env_file: str | os.PathLike[str] | None = None,\n        log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n        log_level: str | int | None = None,\n        access_log: bool = True,\n        use_colors: bool | None = None,\n        interface: InterfaceType = \"auto\",\n        reload: bool = False,\n        reload_dirs: list[str] | str | None = None,\n        reload_delay: float = 0.25,\n        reload_includes: list[str] | str | None = None,\n        reload_excludes: list[str] | str | None = None,\n        workers: int | None = None,\n        proxy_headers: bool = True,\n        server_header: bool = True,\n        date_header: bool = True,\n        forwarded_allow_ips: list[str] | str | None = None,\n        root_path: str = \"\",\n        limit_concurrency: int | None = None,\n        limit_max_requests: int | None = None,\n        backlog: int = 2048,\n        timeout_keep_alive: int = 5,\n        timeout_notify: int = 30,\n        timeout_graceful_shutdown: int | None = None,\n        callback_notify: Callable[..., Awaitable[None]] | None = None,\n        ssl_keyfile: str | os.PathLike[str] | None = None,\n        ssl_certfile: str | os.PathLike[str] | None = None,\n        ssl_keyfile_password: str | None = None,\n        ssl_version: int = SSL_PROTOCOL_VERSION,\n        ssl_cert_reqs: int = ssl.CERT_NONE,\n        ssl_ca_certs: str | None = None,\n        ssl_ciphers: str = \"TLSv1\",\n        headers: list[tuple[str, str]] | None = None,\n        factory: bool = False,\n        h11_max_incomplete_event_size: int | None = None,\n    ):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n\n        self.loaded = False\n        self.configure_logging()\n\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n\n        if (reload_dirs or reload_includes or reload_excludes) and not self.should_reload:\n            logger.warning(\n                \"Current configuration will not reload as not all conditions are met, \" \"please refer to documentation.\"\n            )\n\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n\n            reload_dirs_tmp = self.reload_dirs.copy()\n\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:  # pragma: full coverage\n                            pass\n\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)  # pragma: full coverage\n\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning(\n                        \"Provided reload directories %s did not contain valid \"\n                        + \"directories, watching current working directory.\",\n                        reload_dirs,\n                    )\n                self.reload_dirs = [Path(os.getcwd())]\n\n            logger.info(\n                \"Will watch for changes in these directories: %s\",\n                sorted(list(map(str, self.reload_dirs))),\n            )\n\n        if env_file is not None:\n            from dotenv import load_dotenv\n\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n\n        if workers is None and \"WEB_CONCURRENCY\" in os.environ:\n            self.workers = int(os.environ[\"WEB_CONCURRENCY\"])\n\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1\")\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips  # pragma: full coverage\n\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')\n\n    @property\n    def asgi_version(self) -> Literal[\"2.0\", \"3.0\"]:\n        mapping: dict[str, Literal[\"2.0\", \"3.0\"]] = {\n            \"asgi2\": \"2.0\",\n            \"asgi3\": \"3.0\",\n            \"wsgi\": \"3.0\",\n        }\n        return mapping[self.interface]\n\n    @property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n\n    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, \"TRACE\")\n\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config[\"formatters\"][\"default\"][\"use_colors\"] = self.use_colors\n                    self.log_config[\"formatters\"][\"access\"][\"use_colors\"] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(\".json\"):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith((\".yaml\", \".yml\")):\n                # Install the PyYAML package or the uvicorn[standard] optional\n                # dependencies to enable this functionality.\n                import yaml\n\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                # See the note about fileConfig() here:\n                # https://docs.python.org/3/library/logging.config.html#configuration-file-format\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger(\"uvicorn.error\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.access\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.asgi\").setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger(\"uvicorn.access\").handlers = []\n            logging.getLogger(\"uvicorn.access\").propagate = False\n\n    def load(self) -> None:\n        assert not self.loaded\n\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(\n                keyfile=self.ssl_keyfile,\n                certfile=self.ssl_certfile,\n                password=self.ssl_keyfile_password,\n                ssl_version=self.ssl_version,\n                cert_reqs=self.ssl_cert_reqs,\n                ca_certs=self.ssl_ca_certs,\n                ciphers=self.ssl_ciphers,\n            )\n        else:\n            self.ssl = None\n\n        encoded_headers = [(key.lower().encode(\"latin1\"), value.encode(\"latin1\")) for key, value in self.headers]\n        self.encoded_headers = (\n            [(b\"server\", b\"uvicorn\")] + encoded_headers\n            if b\"server\" not in dict(encoded_headers) and self.server_header\n            else encoded_headers\n        )\n\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error(\"Error loading ASGI app. %s\" % exc)\n            sys.exit(1)\n\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error(\"Error loading ASGI app factory: %s\", exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning(\n                    \"ASGI app factory detected. Using it, \" \"but please consider setting the --factory flag explicitly.\"\n                )\n\n        if self.interface == \"auto\":\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, \"__await__\")\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, \"__call__\", None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = \"asgi3\" if use_asgi_3 else \"asgi2\"\n\n        if self.interface == \"wsgi\":\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == \"asgi2\":\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n\n        self.loaded = True\n\n    def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)\n\n    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:  # pragma: py-win32\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 0o666\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = \"Uvicorn running on unix socket %s (Press CTRL+C to quit)\"\n            sock_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(sock_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [self.uds]\n        elif self.fd:  # pragma: py-win32\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = \"Uvicorn running on socket %s (Press CTRL+C to quit)\"\n            fd_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(fd_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = \"%s://%s:%d\"\n\n            if self.host and \":\" in self.host:  # pragma: full coverage\n                # It's an IPv6 address.\n                family = socket.AF_INET6\n                addr_format = \"%s://[%s]:%d\"\n\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            protocol_name = \"https\" if self.is_ssl else \"http\"\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={\"color_message\": color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload\n"
  },
  "GT_src_dict": {
    "uvicorn/supervisors/multiprocess.py": {
      "Process.__init__": {
        "code": "    def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:\n        \"\"\"Initializes a new Process instance for managing a subprocess.\n\nParameters:\n- config (Config): The configuration object containing settings for the subprocess.\n- target (Callable[[list[socket] | None], None]): The callable function to run in the subprocess, taking an optional list of sockets.\n- sockets (list[socket]): A list of socket objects that the subprocess can use.\n\nThis constructor sets up inter-process communication using a Pipe that allows the parent process to send and receive messages to and from the subprocess. It retrieves the subprocess instance using the `get_subprocess` function, which is defined in the `uvicorn._subprocess` module and takes in the configuration, target function, and sockets.\n\nThe `real_target` attribute stores the provided target callable for later execution within the subprocess.\"\"\"\n        self.real_target = target\n        self.parent_conn, self.child_conn = Pipe()\n        self.process = get_subprocess(config, self.target, sockets)",
        "docstring": "Initializes a new Process instance for managing a subprocess.\n\nParameters:\n- config (Config): The configuration object containing settings for the subprocess.\n- target (Callable[[list[socket] | None], None]): The callable function to run in the subprocess, taking an optional list of sockets.\n- sockets (list[socket]): A list of socket objects that the subprocess can use.\n\nThis constructor sets up inter-process communication using a Pipe that allows the parent process to send and receive messages to and from the subprocess. It retrieves the subprocess instance using the `get_subprocess` function, which is defined in the `uvicorn._subprocess` module and takes in the configuration, target function, and sockets.\n\nThe `real_target` attribute stores the provided target callable for later execution within the subprocess.",
        "signature": "def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:",
        "type": "Method",
        "class_signature": "class Process:"
      },
      "Process.ping": {
        "code": "    def ping(self, timeout: float=5) -> bool:\n        \"\"\"Ping the child process to check if it is alive.\n\nThis method sends a \"ping\" message through the parent-child communication pipe (self.parent_conn) \nand waits for a \"pong\" response from the child process (self.child_conn). It uses the specified \ntimeout to determine how long to wait for a response.\n\nParameters:\n- timeout (float): The duration in seconds to wait for a response from the child process, \n  with a default value of 5 seconds.\n\nReturns:\n- bool: True if a \"pong\" response is received within the timeout period, otherwise False.\n\nThis method interacts with the parent-child communication established in the Process class, \nwhere pipes are used to facilitate inter-process communication. The ping mechanism serves \nas a simple way to verify whether the child process is still operational.\"\"\"\n        self.parent_conn.send(b'ping')\n        if self.parent_conn.poll(timeout):\n            self.parent_conn.recv()\n            return True\n        return False",
        "docstring": "Ping the child process to check if it is alive.\n\nThis method sends a \"ping\" message through the parent-child communication pipe (self.parent_conn) \nand waits for a \"pong\" response from the child process (self.child_conn). It uses the specified \ntimeout to determine how long to wait for a response.\n\nParameters:\n- timeout (float): The duration in seconds to wait for a response from the child process, \n  with a default value of 5 seconds.\n\nReturns:\n- bool: True if a \"pong\" response is received within the timeout period, otherwise False.\n\nThis method interacts with the parent-child communication established in the Process class, \nwhere pipes are used to facilitate inter-process communication. The ping mechanism serves \nas a simple way to verify whether the child process is still operational.",
        "signature": "def ping(self, timeout: float=5) -> bool:",
        "type": "Method",
        "class_signature": "class Process:"
      },
      "Process.is_alive": {
        "code": "    def is_alive(self, timeout: float=5) -> bool:\n        \"\"\"Checks if the child process is alive by verifying if it is still running and responding to a ping signal.\n\nParameters:\n    timeout (float): The maximum time (in seconds) to wait for the ping response; defaults to 5 seconds.\n\nReturns:\n    bool: Returns True if the process is alive and responsive, False otherwise.\n\nThis method interacts with the `self.process` attribute, which is an instance of a subprocess that is created using the `get_subprocess` function from the `uvicorn._subprocess` module. The `ping` method is called to send a signal to the child process and check its responsiveness within the specified timeout.\"\"\"\n        if not self.process.is_alive():\n            return False\n        return self.ping(timeout)",
        "docstring": "Checks if the child process is alive by verifying if it is still running and responding to a ping signal.\n\nParameters:\n    timeout (float): The maximum time (in seconds) to wait for the ping response; defaults to 5 seconds.\n\nReturns:\n    bool: Returns True if the process is alive and responsive, False otherwise.\n\nThis method interacts with the `self.process` attribute, which is an instance of a subprocess that is created using the `get_subprocess` function from the `uvicorn._subprocess` module. The `ping` method is called to send a signal to the child process and check its responsiveness within the specified timeout.",
        "signature": "def is_alive(self, timeout: float=5) -> bool:",
        "type": "Method",
        "class_signature": "class Process:"
      },
      "Process.kill": {
        "code": "    def kill(self) -> None:\n        \"\"\"Terminate the child process associated with this Process instance.\n\n        This method uses the `kill` method of the underlying process to immediately stop the process. \n        On Windows platforms, it will call `TerminateProcess` to forcefully kill the process, \n        while on Unix-like systems it sends the `SIGKILL` signal to the process to ensure it is terminated.\n\n        This operation does not take any parameters and does not return any values. \n        It is important to note that this action is abrupt and does not allow for graceful shutdown. \n        This method does not interact with other parts of the code directly but relies on the \n        `self.process` attribute, which is an instance of a process managed by the `get_subprocess` function.\n\n        After invoking this method, it is advisable to call `join()` on the process to clean up resources properly.\"\"\"\n        self.process.kill()",
        "docstring": "Terminate the child process associated with this Process instance.\n\nThis method uses the `kill` method of the underlying process to immediately stop the process. \nOn Windows platforms, it will call `TerminateProcess` to forcefully kill the process, \nwhile on Unix-like systems it sends the `SIGKILL` signal to the process to ensure it is terminated.\n\nThis operation does not take any parameters and does not return any values. \nIt is important to note that this action is abrupt and does not allow for graceful shutdown. \nThis method does not interact with other parts of the code directly but relies on the \n`self.process` attribute, which is an instance of a process managed by the `get_subprocess` function.\n\nAfter invoking this method, it is advisable to call `join()` on the process to clean up resources properly.",
        "signature": "def kill(self) -> None:",
        "type": "Method",
        "class_signature": "class Process:"
      },
      "Process.pid": {
        "code": "    def pid(self) -> int | None:\n        \"\"\"Returns the process ID (PID) of the associated child process.\n\nThis method accesses the `pid` attribute of the `Process` class's `self.process`, which is an instance of a subprocess created by the `get_subprocess` function. If the subprocess is not currently alive, this method will return `None`. The PID is essential for managing the lifecycle of the process, allowing operations such as termination or monitoring status.\n\nReturns:\n    int | None: The process ID of the child process if it is alive; otherwise, None.\"\"\"\n        return self.process.pid",
        "docstring": "Returns the process ID (PID) of the associated child process.\n\nThis method accesses the `pid` attribute of the `Process` class's `self.process`, which is an instance of a subprocess created by the `get_subprocess` function. If the subprocess is not currently alive, this method will return `None`. The PID is essential for managing the lifecycle of the process, allowing operations such as termination or monitoring status.\n\nReturns:\n    int | None: The process ID of the child process if it is alive; otherwise, None.",
        "signature": "def pid(self) -> int | None:",
        "type": "Method",
        "class_signature": "class Process:"
      },
      "Multiprocess.__init__": {
        "code": "    def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:\n        \"\"\"Initializes a Multiprocess instance, managing multiple worker processes for handling tasks concurrently.\n    \n    Parameters:\n    - config (Config): Configuration object containing settings for the worker processes, including the number of workers.\n    - target (Callable[[list[socket] | None], None]): The callable that will be executed in each subprocess, receiving a list of sockets or None.\n    - sockets (list[socket]): A list of socket objects that can be passed to the target function.\n\n    Attributes:\n    - processes_num (int): Number of worker processes to be spawned, based on the `config.workers` value.\n    - processes (list[Process]): List that holds instances of the Process class for concurrent execution of tasks.\n    - should_exit (threading.Event): Event to signal when the Multiprocess instance should terminate and exit.\n    - signal_queue (list[int]): List to store received signals for processing. Signals are managed through the SIGNALS constant, which maps signal numbers to signal names.\n\n    The constructor also sets up signal handling, enabling the Multiprocess instance to respond to specific OS signals and update its state accordingly.\"\"\"\n        self.config = config\n        self.target = target\n        self.sockets = sockets\n        self.processes_num = config.workers\n        self.processes: list[Process] = []\n        self.should_exit = threading.Event()\n        self.signal_queue: list[int] = []\n        for sig in SIGNALS:\n            signal.signal(sig, lambda sig, frame: self.signal_queue.append(sig))",
        "docstring": "Initializes a Multiprocess instance, managing multiple worker processes for handling tasks concurrently.\n\nParameters:\n- config (Config): Configuration object containing settings for the worker processes, including the number of workers.\n- target (Callable[[list[socket] | None], None]): The callable that will be executed in each subprocess, receiving a list of sockets or None.\n- sockets (list[socket]): A list of socket objects that can be passed to the target function.\n\nAttributes:\n- processes_num (int): Number of worker processes to be spawned, based on the `config.workers` value.\n- processes (list[Process]): List that holds instances of the Process class for concurrent execution of tasks.\n- should_exit (threading.Event): Event to signal when the Multiprocess instance should terminate and exit.\n- signal_queue (list[int]): List to store received signals for processing. Signals are managed through the SIGNALS constant, which maps signal numbers to signal names.\n\nThe constructor also sets up signal handling, enabling the Multiprocess instance to respond to specific OS signals and update its state accordingly.",
        "signature": "def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:",
        "type": "Method",
        "class_signature": "class Multiprocess:"
      },
      "Multiprocess.join_all": {
        "code": "    def join_all(self) -> None:\n        \"\"\"Joins all child processes managed by the Multiprocess instance.\n\nThis method waits for each child process in the `self.processes` list to terminate. It is typically called after sending termination signals to ensure proper cleanup of resources. Each process's `join` method is called, preventing further execution until the corresponding process has finished.\n\nAttributes:\n- `self.processes`: A list of `Process` instances that are currently running. Each `Process` represents a child worker created during initialization.\n\nThis method doesn't take any parameters and returns None.\"\"\"\n        for process in self.processes:\n            process.join()",
        "docstring": "Joins all child processes managed by the Multiprocess instance.\n\nThis method waits for each child process in the `self.processes` list to terminate. It is typically called after sending termination signals to ensure proper cleanup of resources. Each process's `join` method is called, preventing further execution until the corresponding process has finished.\n\nAttributes:\n- `self.processes`: A list of `Process` instances that are currently running. Each `Process` represents a child worker created during initialization.\n\nThis method doesn't take any parameters and returns None.",
        "signature": "def join_all(self) -> None:",
        "type": "Method",
        "class_signature": "class Multiprocess:"
      }
    },
    "uvicorn/config.py": {
      "Config.__init__": {
        "code": "    def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):\n        \"\"\"Initializes the Config class for Uvicorn serving an ASGI application.\n\n    This constructor sets up various parameters for running the server, including app specifics, host and port settings, WebSocket configuration, SSL parameters, logging configuration, and reloading options. It also supports loading environment variables from a specified file and addresses multi-worker settings.\n\n    Parameters:\n        app (ASGIApplication | Callable[..., Any] | str): The ASGI application to run, which can be passed as an application instance, a callable, or a string indicating a path to import.\n        host (str): The hostname to listen on (default: \"127.0.0.1\").\n        port (int): The port to listen on (default: 8000).\n        uds (str | None): Unix domain socket path (if applicable).\n        fd (int | None): File descriptor for socket binding (if applicable).\n        loop (LoopSetupType): The type of event loop setup to use (default: \"auto\").\n        http (type[asyncio.Protocol] | HTTPProtocolType): HTTP protocol to be used (default: \"auto\").\n        ws (type[asyncio.Protocol] | WSProtocolType): WebSocket protocol to be used (default: \"auto\").\n        ws_max_size (int): Maximum size in bytes for WebSocket messages (default: 16MB).\n        ws_max_queue (int): Maximum number of queued WebSocket messages (default: 32).\n        ws_ping_interval (float | None): Interval for sending pings over WebSocket (default: 20.0).\n        ws_ping_timeout (float | None): Timeout for receiving a ping response (default: 20.0).\n        ws_per_message_deflate (bool): Enable per-message deflate for WebSocket (default: True).\n        lifespan (LifespanType): Lifespan configuration for ASGI app (default: \"auto\").\n        env_file (str | os.PathLike[str] | None): Path to a file for loading environment variables.\n        log_config (dict[str, Any] | str | RawConfigParser | IO[Any] | None): Logging configuration settings (default: LOGGING_CONFIG).\n        log_level (str | int | None): Global log level (default: None).\n        access_log (bool): Enable access logging (default: True).\n        use_colors (bool | None): Enable colored logs (default: None).\n        interface (InterfaceType): Interface type for the application (default: \"auto\").\n        reload (bool): Enable auto-reloading for code changes (default: False).\n        reload_dirs (list[str] | str | None): Directories to monitor for reload (default: None).\n        reload_delay (float): Delay between checks for file changes (default: 0.25).\n        reload_includes (list[str] | str | None): Include patterns for reloading (default: None).\n        reload_excludes (list[str] | str | None): Exclude patterns for reloading (default: None).\n        workers (int | None): Number of worker processes (default: None).\n        proxy_headers (bool): Enable proxy headers handling (default: True).\n        server_header (bool): Enable server header in responses (default: True).\n        date_header (bool): Include date header in responses (default: True).\n        forwarded_allow_ips (list[str] | str | None): Allowed IPs for forwarded headers (default: None).\n        root_path (str): The root path for the application (default: \"\").\n        limit_concurrency (int | None): Limit concurrent requests.\n        limit_max_requests (int | None): Limit the maximum number of requests.\n        backlog (int): The maximum number of pending connections (default: 2048).\n        timeout_keep_alive (int): Keep-alive timeout (default: 5).\n        timeout_notify (int): Notify timeout (default: 30).\n        timeout_graceful_shutdown (int | None): Graceful shutdown timeout (default: None).\n        callback_notify (Callable[..., Awaitable[None]] | None): Callback for notification (default: None).\n        ssl_keyfile (str | os.PathLike[str] | None): SSL key file path (default: None).\n        ssl_certfile (str | os.PathLike[str] | None): SSL certificate file path (default: None).\n        ssl_keyfile_password (str | None): Password for the SSL key file (default: None).\n        ssl_version (int): SSL protocol version (default: SSL_PROTOCOL_VERSION).\n        ssl_cert_reqs (int): SSL certificate requirements (default: ssl.CERT_NONE).\n        ssl_ca_certs (str | None): CA certificates file path (default: None).\n        ssl_ciphers (str): Ciphers to use for SSL (default: \"TLSv1\").\n        headers (list[tuple[str, str]] | None): Custom headers to include (default: None).\n        factory (bool): Indicates if the app is a factory function (default: False).\n        h11_max_incomplete_event_size (int | None): Maximum size of incomplete events in h11 protocol (default: None).\n\n    Attributes:\n        app (ASGIApplication): The ASGI application to run.\n        host (str): The hostname the server will bind to.\n        port (int): The port the server will use.\n        ssl (ssl.SSLContext | None): Object for SSL configuration.\n        headers (list[tuple[str, str]]): Custom headers provided for response.\n        encoded_headers (list[tuple[bytes, bytes]]): Encoded custom headers.\n        ...\n\n    It uses constants such as LOGGING_CONFIG for default logging configuration, SSL_PROTOCOL_VERSION for the SSL version, and various types (LoopSetupType, HTTPProtocolType) to provide type hinting and validation within the parameters. The method `configure_logging()` sets up the logging based on parameters provided.\"\"\"\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n        self.loaded = False\n        self.configure_logging()\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n        if (reload_dirs or reload_includes or reload_excludes) and (not self.should_reload):\n            logger.warning('Current configuration will not reload as not all conditions are met, please refer to documentation.')\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n            reload_dirs_tmp = self.reload_dirs.copy()\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:\n                            pass\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning('Provided reload directories %s did not contain valid ' + 'directories, watching current working directory.', reload_dirs)\n                self.reload_dirs = [Path(os.getcwd())]\n            logger.info('Will watch for changes in these directories: %s', sorted(list(map(str, self.reload_dirs))))\n        if env_file is not None:\n            from dotenv import load_dotenv\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n        if workers is None and 'WEB_CONCURRENCY' in os.environ:\n            self.workers = int(os.environ['WEB_CONCURRENCY'])\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get('FORWARDED_ALLOW_IPS', '127.0.0.1')\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')",
        "docstring": "Initializes the Config class for Uvicorn serving an ASGI application.\n\nThis constructor sets up various parameters for running the server, including app specifics, host and port settings, WebSocket configuration, SSL parameters, logging configuration, and reloading options. It also supports loading environment variables from a specified file and addresses multi-worker settings.\n\nParameters:\n    app (ASGIApplication | Callable[..., Any] | str): The ASGI application to run, which can be passed as an application instance, a callable, or a string indicating a path to import.\n    host (str): The hostname to listen on (default: \"127.0.0.1\").\n    port (int): The port to listen on (default: 8000).\n    uds (str | None): Unix domain socket path (if applicable).\n    fd (int | None): File descriptor for socket binding (if applicable).\n    loop (LoopSetupType): The type of event loop setup to use (default: \"auto\").\n    http (type[asyncio.Protocol] | HTTPProtocolType): HTTP protocol to be used (default: \"auto\").\n    ws (type[asyncio.Protocol] | WSProtocolType): WebSocket protocol to be used (default: \"auto\").\n    ws_max_size (int): Maximum size in bytes for WebSocket messages (default: 16MB).\n    ws_max_queue (int): Maximum number of queued WebSocket messages (default: 32).\n    ws_ping_interval (float | None): Interval for sending pings over WebSocket (default: 20.0).\n    ws_ping_timeout (float | None): Timeout for receiving a ping response (default: 20.0).\n    ws_per_message_deflate (bool): Enable per-message deflate for WebSocket (default: True).\n    lifespan (LifespanType): Lifespan configuration for ASGI app (default: \"auto\").\n    env_file (str | os.PathLike[str] | None): Path to a file for loading environment variables.\n    log_config (dict[str, Any] | str | RawConfigParser | IO[Any] | None): Logging configuration settings (default: LOGGING_CONFIG).\n    log_level (str | int | None): Global log level (default: None).\n    access_log (bool): Enable access logging (default: True).\n    use_colors (bool | None): Enable colored logs (default: None).\n    interface (InterfaceType): Interface type for the application (default: \"auto\").\n    reload (bool): Enable auto-reloading for code changes (default: False).\n    reload_dirs (list[str] | str | None): Directories to monitor for reload (default: None).\n    reload_delay (float): Delay between checks for file changes (default: 0.25).\n    reload_includes (list[str] | str | None): Include patterns for reloading (default: None).\n    reload_excludes (list[str] | str | None): Exclude patterns for reloading (default: None).\n    workers (int | None): Number of worker processes (default: None).\n    proxy_headers (bool): Enable proxy headers handling (default: True).\n    server_header (bool): Enable server header in responses (default: True).\n    date_header (bool): Include date header in responses (default: True).\n    forwarded_allow_ips (list[str] | str | None): Allowed IPs for forwarded headers (default: None).\n    root_path (str): The root path for the application (default: \"\").\n    limit_concurrency (int | None): Limit concurrent requests.\n    limit_max_requests (int | None): Limit the maximum number of requests.\n    backlog (int): The maximum number of pending connections (default: 2048).\n    timeout_keep_alive (int): Keep-alive timeout (default: 5).\n    timeout_notify (int): Notify timeout (default: 30).\n    timeout_graceful_shutdown (int | None): Graceful shutdown timeout (default: None).\n    callback_notify (Callable[..., Awaitable[None]] | None): Callback for notification (default: None).\n    ssl_keyfile (str | os.PathLike[str] | None): SSL key file path (default: None).\n    ssl_certfile (str | os.PathLike[str] | None): SSL certificate file path (default: None).\n    ssl_keyfile_password (str | None): Password for the SSL key file (default: None).\n    ssl_version (int): SSL protocol version (default: SSL_PROTOCOL_VERSION).\n    ssl_cert_reqs (int): SSL certificate requirements (default: ssl.CERT_NONE).\n    ssl_ca_certs (str | None): CA certificates file path (default: None).\n    ssl_ciphers (str): Ciphers to use for SSL (default: \"TLSv1\").\n    headers (list[tuple[str, str]] | None): Custom headers to include (default: None).\n    factory (bool): Indicates if the app is a factory function (default: False).\n    h11_max_incomplete_event_size (int | None): Maximum size of incomplete events in h11 protocol (default: None).\n\nAttributes:\n    app (ASGIApplication): The ASGI application to run.\n    host (str): The hostname the server will bind to.\n    port (int): The port the server will use.\n    ssl (ssl.SSLContext | None): Object for SSL configuration.\n    headers (list[tuple[str, str]]): Custom headers provided for response.\n    encoded_headers (list[tuple[bytes, bytes]]): Encoded custom headers.\n    ...\n\nIt uses constants such as LOGGING_CONFIG for default logging configuration, SSL_PROTOCOL_VERSION for the SSL version, and various types (LoopSetupType, HTTPProtocolType) to provide type hinting and validation within the parameters. The method `configure_logging()` sets up the logging based on parameters provided.",
        "signature": "def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):",
        "type": "Method",
        "class_signature": "class Config:"
      }
    }
  },
  "dependency_dict": {
    "uvicorn/config.py:Config:__init__": {
      "uvicorn/config.py": {
        "Config.configure_logging": {
          "code": "    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, 'TRACE')\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config['formatters']['default']['use_colors'] = self.use_colors\n                    self.log_config['formatters']['access']['use_colors'] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith('.json'):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(('.yaml', '.yml')):\n                import yaml\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger('uvicorn.error').setLevel(log_level)\n            logging.getLogger('uvicorn.access').setLevel(log_level)\n            logging.getLogger('uvicorn.asgi').setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger('uvicorn.access').handlers = []\n            logging.getLogger('uvicorn.access').propagate = False",
          "docstring": "",
          "signature": "def configure_logging(self) -> None:",
          "type": "Method",
          "class_signature": "class Config:"
        },
        "Config.should_reload": {
          "code": "    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload",
          "docstring": "",
          "signature": "def should_reload(self) -> bool:",
          "type": "Method",
          "class_signature": "class Config:"
        }
      }
    },
    "uvicorn/supervisors/multiprocess.py:Process:__init__": {
      "uvicorn/_subprocess.py": {
        "get_subprocess": {
          "code": "def get_subprocess(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n) -> SpawnProcess:\n    \"\"\"\n    Called in the parent process, to instantiate a new child process instance.\n    The child is not yet started at this point.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    \"\"\"\n    # We pass across the stdin fileno, and reopen it in the child process.\n    # This is required for some debugging environments.\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    # The `sys.stdin` can be `None`, see https://docs.python.org/3/library/sys.html#sys.__stdin__.\n    except (AttributeError, OSError):\n        stdin_fileno = None\n\n    kwargs = {\n        \"config\": config,\n        \"target\": target,\n        \"sockets\": sockets,\n        \"stdin_fileno\": stdin_fileno,\n    }\n\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)",
          "docstring": "Called in the parent process, to instantiate a new child process instance.\nThe child is not yet started at this point.\n\n* config - The Uvicorn configuration instance.\n* target - A callable that accepts a list of sockets. In practice this will\n           be the `Server.run()` method.\n* sockets - A list of sockets to pass to the server. Sockets are bound once\n            by the parent process, and then passed to the child processes.",
          "signature": "def get_subprocess(config: Config, target: Callable[..., None], sockets: list[socket]) -> SpawnProcess:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "uvicorn/supervisors/multiprocess.py:Process:is_alive": {},
    "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
      "uvicorn/supervisors/multiprocess.py": {
        "Process.join": {
          "code": "    def join(self) -> None:\n        logger.info(f'Waiting for child process [{self.process.pid}]')\n        self.process.join()",
          "docstring": "",
          "signature": "def join(self) -> None:",
          "type": "Method",
          "class_signature": "class Process:"
        }
      }
    }
  },
  "call_tree": {
    "tests/supervisors/test_multiprocess.py:test_process_ping_pong": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Process:__init__": {
        "uvicorn/_subprocess.py:get_subprocess": {}
      },
      "uvicorn/supervisors/multiprocess.py:Process:ping": {}
    },
    "tests/supervisors/test_multiprocess.py:test_process_ping_pong_timeout": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Process:__init__": {
        "uvicorn/_subprocess.py:get_subprocess": {}
      },
      "uvicorn/supervisors/multiprocess.py:Process:ping": {}
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_run": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {}
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_health_check": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Process:kill": {},
      "uvicorn/supervisors/multiprocess.py:Process:is_alive": {
        "uvicorn/supervisors/multiprocess.py:Process:ping": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
        "uvicorn/supervisors/multiprocess.py:Process:join": {
          "uvicorn/logging.py:ColourizedFormatter:formatMessage": {}
        }
      }
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_sigterm": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
        "uvicorn/supervisors/multiprocess.py:Process:join": {
          "uvicorn/logging.py:ColourizedFormatter:formatMessage": {}
        }
      }
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_sighup": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Process:pid": {},
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
        "uvicorn/supervisors/multiprocess.py:Process:join": {
          "uvicorn/logging.py:ColourizedFormatter:formatMessage": {}
        }
      }
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_sigttin": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
        "uvicorn/supervisors/multiprocess.py:Process:join": {
          "uvicorn/logging.py:ColourizedFormatter:formatMessage": {}
        }
      }
    },
    "tests/supervisors/test_multiprocess.py:test_multiprocess_sigttou": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/supervisors/multiprocess.py:Multiprocess:__init__": {},
      "uvicorn/supervisors/multiprocess.py:Multiprocess:join_all": {
        "uvicorn/supervisors/multiprocess.py:Process:join": {
          "uvicorn/logging.py:ColourizedFormatter:formatMessage": {}
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: uvicorn-test_multiprocess\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 uvicorn/\n    \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 Config.__init__\n    \u2514\u2500\u2500 supervisors/\n        \u2514\u2500\u2500 multiprocess.py\n            \u251c\u2500\u2500 Multiprocess.__init__\n            \u251c\u2500\u2500 Multiprocess.join_all\n            \u251c\u2500\u2500 Process.__init__\n            \u251c\u2500\u2500 Process.is_alive\n            \u251c\u2500\u2500 Process.kill\n            \u251c\u2500\u2500 Process.pid\n            \u2514\u2500\u2500 Process.ping\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the testing and validation of process management and signaling behavior for a multiprocessing supervisor used in ASGI server environments, specifically with Uvicorn. It provides functionality to simulate and handle a variety of operating system signals (e.g., SIGINT, SIGTERM, SIGHUP) to ensure proper process lifecycle management, worker health checks, and scalability operations such as dynamically increasing or decreasing worker counts. This module ensures the reliable operation of supervised multiprocessing setups, addressing challenges related to signal handling, inter-process health integrity, and graceful shutdowns or restarts. By focusing on robust testing of these capabilities, the module helps developers build resilient, production-ready ASGI server systems.\n\n## FILE 1: uvicorn/supervisors/multiprocess.py\n\n- CLASS METHOD: Process.__init__\n  - CLASS SIGNATURE: class Process:\n  - SIGNATURE: def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new Process instance for managing a subprocess.\n\nParameters:\n- config (Config): The configuration object containing settings for the subprocess.\n- target (Callable[[list[socket] | None], None]): The callable function to run in the subprocess, taking an optional list of sockets.\n- sockets (list[socket]): A list of socket objects that the subprocess can use.\n\nThis constructor sets up inter-process communication using a Pipe that allows the parent process to send and receive messages to and from the subprocess. It retrieves the subprocess instance using the `get_subprocess` function, which is defined in the `uvicorn._subprocess` module and takes in the configuration, target function, and sockets.\n\nThe `real_target` attribute stores the provided target callable for later execution within the subprocess.\n\"\"\"\n```\n\n- CLASS METHOD: Process.pid\n  - CLASS SIGNATURE: class Process:\n  - SIGNATURE: def pid(self) -> int | None:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the process ID (PID) of the associated child process.\n\nThis method accesses the `pid` attribute of the `Process` class's `self.process`, which is an instance of a subprocess created by the `get_subprocess` function. If the subprocess is not currently alive, this method will return `None`. The PID is essential for managing the lifecycle of the process, allowing operations such as termination or monitoring status.\n\nReturns:\n    int | None: The process ID of the child process if it is alive; otherwise, None.\n\"\"\"\n```\n\n- CLASS METHOD: Multiprocess.join_all\n  - CLASS SIGNATURE: class Multiprocess:\n  - SIGNATURE: def join_all(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nJoins all child processes managed by the Multiprocess instance.\n\nThis method waits for each child process in the `self.processes` list to terminate. It is typically called after sending termination signals to ensure proper cleanup of resources. Each process's `join` method is called, preventing further execution until the corresponding process has finished.\n\nAttributes:\n- `self.processes`: A list of `Process` instances that are currently running. Each `Process` represents a child worker created during initialization.\n\nThis method doesn't take any parameters and returns None.\n\"\"\"\n```\n\n- CLASS METHOD: Process.ping\n  - CLASS SIGNATURE: class Process:\n  - SIGNATURE: def ping(self, timeout: float=5) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nPing the child process to check if it is alive.\n\nThis method sends a \"ping\" message through the parent-child communication pipe (self.parent_conn) \nand waits for a \"pong\" response from the child process (self.child_conn). It uses the specified \ntimeout to determine how long to wait for a response.\n\nParameters:\n- timeout (float): The duration in seconds to wait for a response from the child process, \n  with a default value of 5 seconds.\n\nReturns:\n- bool: True if a \"pong\" response is received within the timeout period, otherwise False.\n\nThis method interacts with the parent-child communication established in the Process class, \nwhere pipes are used to facilitate inter-process communication. The ping mechanism serves \nas a simple way to verify whether the child process is still operational.\n\"\"\"\n```\n\n- CLASS METHOD: Process.kill\n  - CLASS SIGNATURE: class Process:\n  - SIGNATURE: def kill(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nTerminate the child process associated with this Process instance.\n\nThis method uses the `kill` method of the underlying process to immediately stop the process. \nOn Windows platforms, it will call `TerminateProcess` to forcefully kill the process, \nwhile on Unix-like systems it sends the `SIGKILL` signal to the process to ensure it is terminated.\n\nThis operation does not take any parameters and does not return any values. \nIt is important to note that this action is abrupt and does not allow for graceful shutdown. \nThis method does not interact with other parts of the code directly but relies on the \n`self.process` attribute, which is an instance of a process managed by the `get_subprocess` function.\n\nAfter invoking this method, it is advisable to call `join()` on the process to clean up resources properly.\n\"\"\"\n```\n\n- CLASS METHOD: Process.is_alive\n  - CLASS SIGNATURE: class Process:\n  - SIGNATURE: def is_alive(self, timeout: float=5) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the child process is alive by verifying if it is still running and responding to a ping signal.\n\nParameters:\n    timeout (float): The maximum time (in seconds) to wait for the ping response; defaults to 5 seconds.\n\nReturns:\n    bool: Returns True if the process is alive and responsive, False otherwise.\n\nThis method interacts with the `self.process` attribute, which is an instance of a subprocess that is created using the `get_subprocess` function from the `uvicorn._subprocess` module. The `ping` method is called to send a signal to the child process and check its responsiveness within the specified timeout.\n\"\"\"\n```\n\n- CLASS METHOD: Multiprocess.__init__\n  - CLASS SIGNATURE: class Multiprocess:\n  - SIGNATURE: def __init__(self, config: Config, target: Callable[[list[socket] | None], None], sockets: list[socket]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Multiprocess instance, managing multiple worker processes for handling tasks concurrently.\n\nParameters:\n- config (Config): Configuration object containing settings for the worker processes, including the number of workers.\n- target (Callable[[list[socket] | None], None]): The callable that will be executed in each subprocess, receiving a list of sockets or None.\n- sockets (list[socket]): A list of socket objects that can be passed to the target function.\n\nAttributes:\n- processes_num (int): Number of worker processes to be spawned, based on the `config.workers` value.\n- processes (list[Process]): List that holds instances of the Process class for concurrent execution of tasks.\n- should_exit (threading.Event): Event to signal when the Multiprocess instance should terminate and exit.\n- signal_queue (list[int]): List to store received signals for processing. Signals are managed through the SIGNALS constant, which maps signal numbers to signal names.\n\nThe constructor also sets up signal handling, enabling the Multiprocess instance to respond to specific OS signals and update its state accordingly.\n\"\"\"\n```\n\n## FILE 2: uvicorn/config.py\n\n- CLASS METHOD: Config.__init__\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes the Config class for Uvicorn serving an ASGI application.\n\nThis constructor sets up various parameters for running the server, including app specifics, host and port settings, WebSocket configuration, SSL parameters, logging configuration, and reloading options. It also supports loading environment variables from a specified file and addresses multi-worker settings.\n\nParameters:\n    app (ASGIApplication | Callable[..., Any] | str): The ASGI application to run, which can be passed as an application instance, a callable, or a string indicating a path to import.\n    host (str): The hostname to listen on (default: \"127.0.0.1\").\n    port (int): The port to listen on (default: 8000).\n    uds (str | None): Unix domain socket path (if applicable).\n    fd (int | None): File descriptor for socket binding (if applicable).\n    loop (LoopSetupType): The type of event loop setup to use (default: \"auto\").\n    http (type[asyncio.Protocol] | HTTPProtocolType): HTTP protocol to be used (default: \"auto\").\n    ws (type[asyncio.Protocol] | WSProtocolType): WebSocket protocol to be used (default: \"auto\").\n    ws_max_size (int): Maximum size in bytes for WebSocket messages (default: 16MB).\n    ws_max_queue (int): Maximum number of queued WebSocket messages (default: 32).\n    ws_ping_interval (float | None): Interval for sending pings over WebSocket (default: 20.0).\n    ws_ping_timeout (float | None): Timeout for receiving a ping response (default: 20.0).\n    ws_per_message_deflate (bool): Enable per-message deflate for WebSocket (default: True).\n    lifespan (LifespanType): Lifespan configuration for ASGI app (default: \"auto\").\n    env_file (str | os.PathLike[str] | None): Path to a file for loading environment variables.\n    log_config (dict[str, Any] | str | RawConfigParser | IO[Any] | None): Logging configuration settings (default: LOGGING_CONFIG).\n    log_level (str | int | None): Global log level (default: None).\n    access_log (bool): Enable access logging (default: True).\n    use_colors (bool | None): Enable colored logs (default: None).\n    interface (InterfaceType): Interface type for the application (default: \"auto\").\n    reload (bool): Enable auto-reloading for code changes (default: False).\n    reload_dirs (list[str] | str | None): Directories to monitor for reload (default: None).\n    reload_delay (float): Delay between checks for file changes (default: 0.25).\n    reload_includes (list[str] | str | None): Include patterns for reloading (default: None).\n    reload_excludes (list[str] | str | None): Exclude patterns for reloading (default: None).\n    workers (int | None): Number of worker processes (default: None).\n    proxy_headers (bool): Enable proxy headers handling (default: True).\n    server_header (bool): Enable server header in responses (default: True).\n    date_header (bool): Include date header in responses (default: True).\n    forwarded_allow_ips (list[str] | str | None): Allowed IPs for forwarded headers (default: None).\n    root_path (str): The root path for the application (default: \"\").\n    limit_concurrency (int | None): Limit concurrent requests.\n    limit_max_requests (int | None): Limit the maximum number of requests.\n    backlog (int): The maximum number of pending connections (default: 2048).\n    timeout_keep_alive (int): Keep-alive timeout (default: 5).\n    timeout_notify (int): Notify timeout (default: 30).\n    timeout_graceful_shutdown (int | None): Graceful shutdown timeout (default: None).\n    callback_notify (Callable[..., Awaitable[None]] | None): Callback for notification (default: None).\n    ssl_keyfile (str | os.PathLike[str] | None): SSL key file path (default: None).\n    ssl_certfile (str | os.PathLike[str] | None): SSL certificate file path (default: None).\n    ssl_keyfile_password (str | None): Password for the SSL key file (default: None).\n    ssl_version (int): SSL protocol version (default: SSL_PROTOCOL_VERSION).\n    ssl_cert_reqs (int): SSL certificate requirements (default: ssl.CERT_NONE).\n    ssl_ca_certs (str | None): CA certificates file path (default: None).\n    ssl_ciphers (str): Ciphers to use for SSL (default: \"TLSv1\").\n    headers (list[tuple[str, str]] | None): Custom headers to include (default: None).\n    factory (bool): Indicates if the app is a factory function (default: False).\n    h11_max_incomplete_event_size (int | None): Maximum size of incomplete events in h11 protocol (default: None).\n\nAttributes:\n    app (ASGIApplication): The ASGI application to run.\n    host (str): The hostname the server will bind to.\n    port (int): The port the server will use.\n    ssl (ssl.SSLContext | None): Object for SSL configuration.\n    headers (list[tuple[str, str]]): Custom headers provided for response.\n    encoded_headers (list[tuple[bytes, bytes]]): Encoded custom headers.\n    ...\n\nIt uses constants such as LOGGING_CONFIG for default logging configuration, SSL_PROTOCOL_VERSION for the SSL version, and various types (LoopSetupType, HTTPProtocolType) to provide type hinting and validation within the parameters. The method `configure_logging()` sets up the logging based on parameters provided.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "uvicorn/supervisors/multiprocess.py": "from __future__ import annotations\nimport logging\nimport os\nimport signal\nimport threading\nfrom multiprocessing import Pipe\nfrom socket import socket\nfrom typing import Any, Callable\nimport click\nfrom uvicorn._subprocess import get_subprocess\nfrom uvicorn.config import Config\nSIGNALS = {getattr(signal, f'SIG{x}'): x for x in 'INT TERM BREAK HUP QUIT TTIN TTOU USR1 USR2 WINCH'.split() if hasattr(signal, f'SIG{x}')}\nlogger = logging.getLogger('uvicorn.error')\n\nclass Process:\n\n    def pong(self) -> None:\n        self.child_conn.recv()\n        self.child_conn.send(b'pong')\n\n    def always_pong(self) -> None:\n        while True:\n            self.pong()\n\n    def target(self, sockets: list[socket] | None=None) -> Any:\n        if os.name == 'nt':\n            signal.signal(signal.SIGBREAK, lambda sig, frame: signal.raise_signal(signal.SIGTERM))\n        threading.Thread(target=self.always_pong, daemon=True).start()\n        return self.real_target(sockets)\n\n    def start(self) -> None:\n        self.process.start()\n\n    def terminate(self) -> None:\n        if self.process.exitcode is None:\n            assert self.process.pid is not None\n            if os.name == 'nt':\n                os.kill(self.process.pid, signal.CTRL_BREAK_EVENT)\n            else:\n                os.kill(self.process.pid, signal.SIGTERM)\n            logger.info(f'Terminated child process [{self.process.pid}]')\n            self.parent_conn.close()\n            self.child_conn.close()\n\n    def join(self) -> None:\n        logger.info(f'Waiting for child process [{self.process.pid}]')\n        self.process.join()\n\nclass Multiprocess:\n\n    def init_processes(self) -> None:\n        for _ in range(self.processes_num):\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes.append(process)\n\n    def terminate_all(self) -> None:\n        for process in self.processes:\n            process.terminate()\n\n    def restart_all(self) -> None:\n        for idx, process in enumerate(self.processes):\n            process.terminate()\n            process.join()\n            new_process = Process(self.config, self.target, self.sockets)\n            new_process.start()\n            self.processes[idx] = new_process\n\n    def run(self) -> None:\n        message = f'Started parent process [{os.getpid()}]'\n        color_message = 'Started parent process [{}]'.format(click.style(str(os.getpid()), fg='cyan', bold=True))\n        logger.info(message, extra={'color_message': color_message})\n        self.init_processes()\n        while not self.should_exit.wait(0.5):\n            self.handle_signals()\n            self.keep_subprocess_alive()\n        self.terminate_all()\n        self.join_all()\n        message = f'Stopping parent process [{os.getpid()}]'\n        color_message = 'Stopping parent process [{}]'.format(click.style(str(os.getpid()), fg='cyan', bold=True))\n        logger.info(message, extra={'color_message': color_message})\n\n    def keep_subprocess_alive(self) -> None:\n        if self.should_exit.is_set():\n            return\n        for idx, process in enumerate(self.processes):\n            if process.is_alive():\n                continue\n            process.kill()\n            process.join()\n            if self.should_exit.is_set():\n                return\n            logger.info(f'Child process [{process.pid}] died')\n            process = Process(self.config, self.target, self.sockets)\n            process.start()\n            self.processes[idx] = process\n\n    def handle_signals(self) -> None:\n        for sig in tuple(self.signal_queue):\n            self.signal_queue.remove(sig)\n            sig_name = SIGNALS[sig]\n            sig_handler = getattr(self, f'handle_{sig_name.lower()}', None)\n            if sig_handler is not None:\n                sig_handler()\n            else:\n                logger.debug(f'Received signal {sig_name}, but no handler is defined for it.')\n\n    def handle_int(self) -> None:\n        logger.info('Received SIGINT, exiting.')\n        self.should_exit.set()\n\n    def handle_term(self) -> None:\n        logger.info('Received SIGTERM, exiting.')\n        self.should_exit.set()\n\n    def handle_break(self) -> None:\n        logger.info('Received SIGBREAK, exiting.')\n        self.should_exit.set()\n\n    def handle_hup(self) -> None:\n        logger.info('Received SIGHUP, restarting processes.')\n        self.restart_all()\n\n    def handle_ttin(self) -> None:\n        logger.info('Received SIGTTIN, increasing the number of processes.')\n        self.processes_num += 1\n        process = Process(self.config, self.target, self.sockets)\n        process.start()\n        self.processes.append(process)\n\n    def handle_ttou(self) -> None:\n        logger.info('Received SIGTTOU, decreasing number of processes.')\n        if self.processes_num <= 1:\n            logger.info('Already reached one process, cannot decrease the number of processes anymore.')\n            return\n        self.processes_num -= 1\n        process = self.processes.pop()\n        process.terminate()\n        process.join()",
    "uvicorn/config.py": "from __future__ import annotations\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Awaitable, Callable, Literal\nimport click\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware\nHTTPProtocolType = Literal['auto', 'h11', 'httptools']\nWSProtocolType = Literal['auto', 'none', 'websockets', 'wsproto']\nLifespanType = Literal['auto', 'on', 'off']\nLoopSetupType = Literal['none', 'auto', 'asyncio', 'uvloop']\nInterfaceType = Literal['auto', 'asgi3', 'asgi2', 'wsgi']\nLOG_LEVELS: dict[str, int] = {'critical': logging.CRITICAL, 'error': logging.ERROR, 'warning': logging.WARNING, 'info': logging.INFO, 'debug': logging.DEBUG, 'trace': TRACE_LOG_LEVEL}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {'auto': 'uvicorn.protocols.http.auto:AutoHTTPProtocol', 'h11': 'uvicorn.protocols.http.h11_impl:H11Protocol', 'httptools': 'uvicorn.protocols.http.httptools_impl:HttpToolsProtocol'}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {'auto': 'uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol', 'none': None, 'websockets': 'uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol', 'wsproto': 'uvicorn.protocols.websockets.wsproto_impl:WSProtocol'}\nLIFESPAN: dict[LifespanType, str] = {'auto': 'uvicorn.lifespan.on:LifespanOn', 'on': 'uvicorn.lifespan.on:LifespanOn', 'off': 'uvicorn.lifespan.off:LifespanOff'}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {'none': None, 'auto': 'uvicorn.loops.auto:auto_loop_setup', 'asyncio': 'uvicorn.loops.asyncio:asyncio_setup', 'uvloop': 'uvicorn.loops.uvloop:uvloop_setup'}\nINTERFACES: list[InterfaceType] = ['auto', 'asgi3', 'asgi2', 'wsgi']\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\nLOGGING_CONFIG: dict[str, Any] = {'version': 1, 'disable_existing_loggers': False, 'formatters': {'default': {'()': 'uvicorn.logging.DefaultFormatter', 'fmt': '%(levelprefix)s %(message)s', 'use_colors': None}, 'access': {'()': 'uvicorn.logging.AccessFormatter', 'fmt': '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s'}}, 'handlers': {'default': {'formatter': 'default', 'class': 'logging.StreamHandler', 'stream': 'ext://sys.stderr'}, 'access': {'formatter': 'access', 'class': 'logging.StreamHandler', 'stream': 'ext://sys.stdout'}}, 'loggers': {'uvicorn': {'handlers': ['default'], 'level': 'INFO', 'propagate': False}, 'uvicorn.error': {'level': 'INFO'}, 'uvicorn.access': {'handlers': ['access'], 'level': 'INFO', 'propagate': False}}}\nlogger = logging.getLogger('uvicorn.error')\n\ndef create_ssl_context(certfile: str | os.PathLike[str], keyfile: str | os.PathLike[str] | None, password: str | None, ssl_version: int, cert_reqs: int, ca_certs: str | os.PathLike[str] | None, ciphers: str | None) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx\n\ndef is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:\n        return False\n\ndef resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        if pattern == '.*':\n            continue\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n    directories = list(set(directories).difference(set(children)))\n    return (list(set(patterns)), directories)\n\ndef _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))\n\nclass Config:\n\n    @property\n    def asgi_version(self) -> Literal['2.0', '3.0']:\n        mapping: dict[str, Literal['2.0', '3.0']] = {'asgi2': '2.0', 'asgi3': '3.0', 'wsgi': '3.0'}\n        return mapping[self.interface]\n\n    @property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n\n    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, 'TRACE')\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config['formatters']['default']['use_colors'] = self.use_colors\n                    self.log_config['formatters']['access']['use_colors'] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith('.json'):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(('.yaml', '.yml')):\n                import yaml\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger('uvicorn.error').setLevel(log_level)\n            logging.getLogger('uvicorn.access').setLevel(log_level)\n            logging.getLogger('uvicorn.asgi').setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger('uvicorn.access').handlers = []\n            logging.getLogger('uvicorn.access').propagate = False\n\n    def load(self) -> None:\n        assert not self.loaded\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile, password=self.ssl_keyfile_password, ssl_version=self.ssl_version, cert_reqs=self.ssl_cert_reqs, ca_certs=self.ssl_ca_certs, ciphers=self.ssl_ciphers)\n        else:\n            self.ssl = None\n        encoded_headers = [(key.lower().encode('latin1'), value.encode('latin1')) for key, value in self.headers]\n        self.encoded_headers = [(b'server', b'uvicorn')] + encoded_headers if b'server' not in dict(encoded_headers) and self.server_header else encoded_headers\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error('Error loading ASGI app. %s' % exc)\n            sys.exit(1)\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error('Error loading ASGI app factory: %s', exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning('ASGI app factory detected. Using it, but please consider setting the --factory flag explicitly.')\n        if self.interface == 'auto':\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, '__await__')\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, '__call__', None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = 'asgi3' if use_asgi_3 else 'asgi2'\n        if self.interface == 'wsgi':\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == 'asgi2':\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n        self.loaded = True\n\n    def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)\n\n    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 438\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:\n                logger.error(exc)\n                sys.exit(1)\n            message = 'Uvicorn running on unix socket %s (Press CTRL+C to quit)'\n            sock_name_format = '%s'\n            color_message = 'Uvicorn running on ' + click.style(sock_name_format, bold=True) + ' (Press CTRL+C to quit)'\n            logger_args = [self.uds]\n        elif self.fd:\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = 'Uvicorn running on socket %s (Press CTRL+C to quit)'\n            fd_name_format = '%s'\n            color_message = 'Uvicorn running on ' + click.style(fd_name_format, bold=True) + ' (Press CTRL+C to quit)'\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = '%s://%s:%d'\n            if self.host and ':' in self.host:\n                family = socket.AF_INET6\n                addr_format = '%s://[%s]:%d'\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:\n                logger.error(exc)\n                sys.exit(1)\n            message = f'Uvicorn running on {addr_format} (Press CTRL+C to quit)'\n            color_message = 'Uvicorn running on ' + click.style(addr_format, bold=True) + ' (Press CTRL+C to quit)'\n            protocol_name = 'https' if self.is_ssl else 'http'\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={'color_message': color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload"
  }
}