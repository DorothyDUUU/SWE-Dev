{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_builtin_operators",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/util/test_builtin_operators.py",
  "test_code": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom unittest import TestCase\n\nfrom casbin import util\n\n\nclass TestBuiltinOperators(TestCase):\n    def test_key_match(self):\n        self.assertFalse(util.key_match_func(\"/foo\", \"/\"))\n        self.assertTrue(util.key_match_func(\"/foo\", \"/foo\"))\n        self.assertTrue(util.key_match_func(\"/foo\", \"/foo*\"))\n        self.assertFalse(util.key_match_func(\"/foo\", \"/foo/*\"))\n        self.assertFalse(util.key_match_func(\"/foo/bar\", \"/foo\"))\n        self.assertTrue(util.key_match_func(\"/foo/bar\", \"/foo*\"))\n        self.assertTrue(util.key_match_func(\"/foo/bar\", \"/foo/*\"))\n        self.assertFalse(util.key_match_func(\"/foobar\", \"/foo\"))\n        self.assertTrue(util.key_match_func(\"/foobar\", \"/foo*\"))\n        self.assertFalse(util.key_match_func(\"/foobar\", \"/foo/*\"))\n\n        self.assertFalse(util.key_match2_func(\"/alice/all\", \"/:/all\"))\n\n    def test_key_get(self):\n        self.assertEqual(util.key_get(\"/foo\", \"/foo\"), \"\")\n        self.assertEqual(util.key_get(\"/foo\", \"/foo*\"), \"\")\n        self.assertEqual(util.key_get(\"/foo\", \"/foo/*\"), \"\")\n        self.assertEqual(util.key_get(\"/foo/bar\", \"/foo\"), \"\")\n        self.assertEqual(util.key_get(\"/foo/bar\", \"/foo*\"), \"/bar\")\n        self.assertEqual(util.key_get(\"/foo/bar\", \"/foo/*\"), \"bar\")\n        self.assertEqual(util.key_get(\"/foobar\", \"/foo\"), \"\")\n        self.assertEqual(util.key_get(\"/foobar\", \"/foo*\"), \"bar\")\n        self.assertEqual(util.key_get(\"/foobar\", \"/foo/*\"), \"\")\n\n    def test_key_match2(self):\n        self.assertFalse(util.key_match2_func(\"/foo\", \"/\"))\n        self.assertTrue(util.key_match2_func(\"/foo\", \"/foo\"))\n        self.assertTrue(util.key_match2_func(\"/foo\", \"/foo*\"))\n        self.assertFalse(util.key_match2_func(\"/foo\", \"/foo/*\"))\n        self.assertFalse(util.key_match2_func(\"/foo/bar\", \"/foo\"))  # different with KeyMatch.\n        self.assertFalse(util.key_match2_func(\"/foo/bar\", \"/foo*\"))\n        self.assertTrue(util.key_match2_func(\"/foo/bar\", \"/foo/*\"))\n        self.assertFalse(util.key_match2_func(\"/foobar\", \"/foo\"))  # different with KeyMatch.\n        self.assertFalse(util.key_match2_func(\"/foobar\", \"/foo*\"))\n        self.assertFalse(util.key_match2_func(\"/foobar\", \"/foo/*\"))\n\n        self.assertFalse(util.key_match2_func(\"/\", \"/:resource\"))\n        self.assertTrue(util.key_match2_func(\"/resource1\", \"/:resource\"))\n        self.assertFalse(util.key_match2_func(\"/myid\", \"/:id/using/:resId\"))\n        self.assertTrue(util.key_match2_func(\"/myid/using/myresid\", \"/:id/using/:resId\"))\n\n        self.assertFalse(util.key_match2_func(\"/proxy/myid\", \"/proxy/:id/*\"))\n        self.assertTrue(util.key_match2_func(\"/proxy/myid/\", \"/proxy/:id/*\"))\n        self.assertTrue(util.key_match2_func(\"/proxy/myid/res\", \"/proxy/:id/*\"))\n        self.assertTrue(util.key_match2_func(\"/proxy/myid/res/res2\", \"/proxy/:id/*\"))\n        self.assertTrue(util.key_match2_func(\"/proxy/myid/res/res2/res3\", \"/proxy/:id/*\"))\n        self.assertFalse(util.key_match2_func(\"/proxy/\", \"/proxy/:id/*\"))\n\n        self.assertTrue(util.key_match2_func(\"/alice\", \"/:id\"))\n        self.assertTrue(util.key_match2_func(\"/alice/all\", \"/:id/all\"))\n        self.assertFalse(util.key_match2_func(\"/alice\", \"/:id/all\"))\n        self.assertFalse(util.key_match2_func(\"/alice/all\", \"/:id\"))\n\n        self.assertFalse(util.key_match2_func(\"/alice/all\", \"/:/all\"))\n\n    def test_key_get2(self):\n        self.assertEqual(util.key_get2(\"/foo\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foo\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foo\", \"/foo/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foo/bar\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foo/bar\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foo/bar\", \"/foo/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foobar\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foobar\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/foobar\", \"/foo/*\", \"id\"), \"\")\n\n        self.assertEqual(util.key_get2(\"/\", \"/:resource\", \"resource\"), \"\")\n        self.assertEqual(util.key_get2(\"/resource1\", \"/:resource\", \"resource\"), \"resource1\")\n        self.assertEqual(util.key_get2(\"/myid\", \"/:id/using/:resId\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/myid/using/myresid\", \"/:id/using/:resId\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/myid/using/myresid\", \"/:id/using/:resId\", \"resId\"), \"myresid\")\n\n        self.assertEqual(util.key_get2(\"/proxy/myid\", \"/proxy/:id/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/proxy/myid/\", \"/proxy/:id/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/proxy/myid/res\", \"/proxy/:id/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/proxy/myid/res/res2\", \"/proxy/:id/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/proxy/myid/res/res2/res3\", \"/proxy/:id/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/proxy/myid/res/res2/res3\", \"/proxy/:id/res/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get2(\"/proxy/\", \"/proxy/:id/*\", \"id\"), \"\")\n\n        self.assertEqual(util.key_get2(\"/alice\", \"/:id\", \"id\"), \"alice\")\n        self.assertEqual(util.key_get2(\"/alice/all\", \"/:id/all\", \"id\"), \"alice\")\n        self.assertEqual(util.key_get2(\"/alice\", \"/:id/all\", \"id\"), \"\")\n        self.assertEqual(util.key_get2(\"/alice/all\", \"/:id\", \"id\"), \"\")\n\n        self.assertEqual(util.key_get2(\"/alice/all\", \"/:/all\", \"\"), \"\")\n\n    def test_key_match3(self):\n        self.assertTrue(util.key_match3_func(\"/foo\", \"/foo\"))\n        self.assertTrue(util.key_match3_func(\"/foo\", \"/foo*\"))\n        self.assertFalse(util.key_match3_func(\"/foo\", \"/foo/*\"))\n        self.assertFalse(util.key_match3_func(\"/foo/bar\", \"/foo\"))\n        self.assertFalse(util.key_match3_func(\"/foo/bar\", \"/foo*\"))\n        self.assertTrue(util.key_match3_func(\"/foo/bar\", \"/foo/*\"))\n        self.assertFalse(util.key_match3_func(\"/foobar\", \"/foo\"))\n        self.assertFalse(util.key_match3_func(\"/foobar\", \"/foo*\"))\n        self.assertFalse(util.key_match3_func(\"/foobar\", \"/foo/*\"))\n\n        self.assertFalse(util.key_match3_func(\"/\", \"/{resource}\"))\n        self.assertTrue(util.key_match3_func(\"/resource1\", \"/{resource}\"))\n        self.assertFalse(util.key_match3_func(\"/myid\", \"/{id}/using/{resId}\"))\n        self.assertTrue(util.key_match3_func(\"/myid/using/myresid\", \"/{id}/using/{resId}\"))\n\n        self.assertFalse(util.key_match3_func(\"/proxy/myid\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match3_func(\"/proxy/myid/\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match3_func(\"/proxy/myid/res\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match3_func(\"/proxy/myid/res/res2\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match3_func(\"/proxy/myid/res/res2/res3\", \"/proxy/{id}/*\"))\n        self.assertFalse(util.key_match3_func(\"/proxy/\", \"/proxy/{id}/*\"))\n\n        self.assertFalse(util.key_match3_func(\"/myid/using/myresid\", \"/{id/using/{resId}\"))\n\n    def test_key_get3(self):\n        self.assertEqual(util.key_get3(\"/foo\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foo\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foo\", \"/foo/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foo/bar\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foo/bar\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foo/bar\", \"/foo/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foobar\", \"/foo\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foobar\", \"/foo*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/foobar\", \"/foo/*\", \"id\"), \"\")\n\n        self.assertEqual(util.key_get3(\"/\", \"/{resource}\", \"resource\"), \"\")\n        self.assertEqual(util.key_get3(\"/resource1\", \"/{resource}\", \"resource\"), \"resource1\")\n        self.assertEqual(util.key_get3(\"/myid\", \"/{id}/using/{resId}\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/myid/using/myresid\", \"/{id}/using/{resId}\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get3(\"/myid/using/myresid\", \"/{id}/using/{resId}\", \"resId\"), \"myresid\")\n\n        self.assertEqual(util.key_get3(\"/proxy/myid\", \"/proxy/{id}/*\", \"id\"), \"\")\n        self.assertEqual(util.key_get3(\"/proxy/myid/\", \"/proxy/{id}/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get3(\"/proxy/myid/res\", \"/proxy/{id}/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get3(\"/proxy/myid/res/res2\", \"/proxy/{id}/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get3(\"/proxy/myid/res/res2/res3\", \"/proxy/{id}/*\", \"id\"), \"myid\")\n        self.assertEqual(util.key_get3(\"/proxy/\", \"/proxy/{id}/*\", \"id\"), \"\")\n\n        self.assertEqual(\n            util.key_get3(\"/api/group1_group_name/project1_admin/info\", \"/api/{proj}_admin/info\", \"proj\"), \"\"\n        )\n        self.assertEqual(util.key_get3(\"/{id/using/myresid\", \"/{id/using/{resId}\", \"resId\"), \"myresid\")\n        self.assertEqual(util.key_get3(\"/{id/using/myresid/status}\", \"/{id/using/{resId}/status}\", \"resId\"), \"myresid\")\n\n        self.assertEqual(util.key_get3(\"/proxy/myid/res/res2/res3\", \"/proxy/{id}/*/{res}\", \"res\"), \"res3\")\n        self.assertEqual(util.key_get3(\"/api/project1_admin/info\", \"/api/{proj}_admin/info\", \"proj\"), \"project1\")\n        self.assertEqual(\n            util.key_get3(\"/api/group1_group_name/project1_admin/info\", \"/api/{g}_{gn}/{proj}_admin/info\", \"g\"),\n            \"group1\",\n        )\n        self.assertEqual(\n            util.key_get3(\"/api/group1_group_name/project1_admin/info\", \"/api/{g}_{gn}/{proj}_admin/info\", \"gn\"),\n            \"group_name\",\n        )\n        self.assertEqual(\n            util.key_get3(\"/api/group1_group_name/project1_admin/info\", \"/api/{g}_{gn}/{proj}_admin/info\", \"proj\"),\n            \"project1\",\n        )\n\n    def test_key_match4(self):\n        self.assertTrue(util.key_match4_func(\"/parent/123/child/123\", \"/parent/{id}/child/{id}\"))\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/456\", \"/parent/{id}/child/{id}\"))\n\n        self.assertTrue(util.key_match4_func(\"/parent/123/child/123\", \"/parent/{id}/child/{another_id}\"))\n        self.assertTrue(util.key_match4_func(\"/parent/123/child/456\", \"/parent/{id}/child/{another_id}\"))\n\n        self.assertTrue(util.key_match4_func(\"/parent/123/child/456\", \"/parent/{id}/child/{another_id}\"))\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/123/book/456\", \"/parent/{id}/child/{id}/book/{id}\"))\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/456/book/123\", \"/parent/{id}/child/{id}/book/{id}\"))\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/456/book/\", \"/parent/{id}/child/{id}/book/{id}\"))\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/456\", \"/parent/{id}/child/{id}/book/{id}\"))\n\n        self.assertFalse(util.key_match4_func(\"/parent/123/child/123\", \"/parent/{i/d}/child/{i/d}\"))\n\n    def test_key_match5_func(self):\n        self.assertTrue(util.key_match5_func(\"/parent/child?status=1&type=2\", \"/parent/child\"))\n        self.assertFalse(util.key_match5_func(\"/parent?status=1&type=2\", \"/parent/child\"))\n\n        self.assertTrue(util.key_match5_func(\"/parent/child/?status=1&type=2\", \"/parent/child/\"))\n        self.assertFalse(util.key_match5_func(\"/parent/child/?status=1&type=2\", \"/parent/child\"))\n        self.assertFalse(util.key_match5_func(\"/parent/child?status=1&type=2\", \"/parent/child/\"))\n\n        self.assertTrue(util.key_match5_func(\"/foo\", \"/foo\"))\n        self.assertTrue(util.key_match5_func(\"/foo\", \"/foo*\"))\n        self.assertFalse(util.key_match5_func(\"/foo\", \"/foo/*\"))\n        self.assertFalse(util.key_match5_func(\"/foo/bar\", \"/foo\"))\n        self.assertFalse(util.key_match5_func(\"/foo/bar\", \"/foo*\"))\n        self.assertTrue(util.key_match5_func(\"/foo/bar\", \"/foo/*\"))\n        self.assertFalse(util.key_match5_func(\"/foobar\", \"/foo\"))\n        self.assertFalse(util.key_match5_func(\"/foobar\", \"/foo*\"))\n        self.assertFalse(util.key_match5_func(\"/foobar\", \"/foo/*\"))\n\n        self.assertFalse(util.key_match5_func(\"/\", \"/{resource}\"))\n        self.assertTrue(util.key_match5_func(\"/resource1\", \"/{resource}\"))\n        self.assertFalse(util.key_match5_func(\"/myid\", \"/{id}/using/{resId}\"))\n        self.assertTrue(util.key_match5_func(\"/myid/using/myresid\", \"/{id}/using/{resId}\"))\n\n        self.assertFalse(util.key_match5_func(\"/proxy/myid\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res/res2\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res/res2/res3\", \"/proxy/{id}/*\"))\n        self.assertFalse(util.key_match5_func(\"/proxy/\", \"/proxy/{id}/*\"))\n\n        self.assertFalse(util.key_match5_func(\"/proxy/myid?status=1&type=2\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res?status=1&type=2\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res/res2?status=1&type=2\", \"/proxy/{id}/*\"))\n        self.assertTrue(util.key_match5_func(\"/proxy/myid/res/res2/res3?status=1&type=2\", \"/proxy/{id}/*\"))\n        self.assertFalse(util.key_match5_func(\"/proxy/\", \"/proxy/{id}/*\"))\n\n    def test_regex_match(self):\n        self.assertTrue(util.regex_match_func(\"/topic/create\", \"/topic/create\"))\n        self.assertTrue(util.regex_match_func(\"/topic/create/123\", \"/topic/create\"))\n        self.assertFalse(util.regex_match_func(\"/topic/delete\", \"/topic/create\"))\n        self.assertFalse(util.regex_match_func(\"/topic/edit\", \"/topic/edit/[0-9]+\"))\n        self.assertTrue(util.regex_match_func(\"/topic/edit/123\", \"/topic/edit/[0-9]+\"))\n        self.assertFalse(util.regex_match_func(\"/topic/edit/abc\", \"/topic/edit/[0-9]+\"))\n        self.assertFalse(util.regex_match_func(\"/foo/delete/123\", \"/topic/delete/[0-9]+\"))\n        self.assertTrue(util.regex_match_func(\"/topic/delete/0\", \"/topic/delete/[0-9]+\"))\n        self.assertFalse(util.regex_match_func(\"/topic/edit/123s\", \"/topic/delete/[0-9]+\"))\n\n    def test_glob_match(self):\n        self.assertTrue(util.glob_match_func(\"/foo\", \"/foo\"))\n        self.assertTrue(util.glob_match_func(\"/foo\", \"/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/foo\", \"/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/foo/bar\", \"/foo\"))\n        self.assertFalse(util.glob_match_func(\"/foo/bar\", \"/foo*\"))\n        self.assertTrue(util.glob_match_func(\"/foo/bar\", \"/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/foobar\", \"/foo\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/foobar\", \"/foo/*\"))\n        self.assertTrue(util.glob_match_func(\"/foo\", \"*/foo\"))\n        self.assertTrue(util.glob_match_func(\"/foo\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/foo\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/foo/bar\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/foo/bar\", \"*/foo*\"))\n        self.assertTrue(util.glob_match_func(\"/foo/bar\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/foobar\", \"*/foo\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/foobar\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo/bar\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo/bar\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foo/bar\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foobar\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foobar\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/foobar\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo/bar\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo/bar\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foo/bar\", \"*/foo/*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foobar\", \"*/foo\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foobar\", \"*/foo*\"))\n        self.assertFalse(util.glob_match_func(\"/prefix/subprefix/foobar\", \"*/foo/*\"))\n\n        self.assertTrue(util.glob_match_func(\"/f\", \"/?\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"/foo?ar\"))\n        self.assertFalse(util.glob_match_func(\"/fooar\", \"/foo?ar\"))\n        self.assertTrue(util.glob_match_func(\"/foobbar\", \"/foo??ar\"))\n        self.assertTrue(util.glob_match_func(\"/foobbbbar\", \"/foo????ar\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"/foo[bc]ar\"))\n        self.assertFalse(util.glob_match_func(\"/fooaar\", \"/foo[bc]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foodar\", \"/foo[bc]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"/foo[b-b]ar\"))\n        self.assertFalse(util.glob_match_func(\"/fooaar\", \"/foo[b-c]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foobar\", \"/foo[b-c]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foocar\", \"/foo[b-c]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foodar\", \"/foo[b-c]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo1ar\", \"/foo[!234]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foo3ar\", \"/foo[!234]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo5ar\", \"/foo[!234]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo1ar\", \"/foo[!2-5]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foo2ar\", \"/foo[!2-5]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo1ar\", \"/foo[^234]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foo3ar\", \"/foo[^234]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo5ar\", \"/foo[^234]ar\"))\n        self.assertTrue(util.glob_match_func(\"/foo1ar\", \"/foo[^2-5]ar\"))\n        self.assertFalse(util.glob_match_func(\"/foo2ar\", \"/foo[^2-5]ar\"))\n\n        self.assertTrue(util.glob_match_func(\"\\\\\", \"\\\\\\\\\"))\n        self.assertTrue(util.glob_match_func(\"/a\", \"/\\\\a\"))\n        self.assertTrue(util.glob_match_func(\"/*\", \"/\\\\*\"))\n        self.assertFalse(util.glob_match_func(\"a\", \"\\\\?\"))\n        self.assertTrue(util.glob_match_func(\"?\", \"\\\\?\"))\n        self.assertTrue(util.glob_match_func(\"\\n\", \"\\n\"))\n        self.assertFalse(util.glob_match_func(\"\\n\", \"\\\\n\"))\n        self.assertTrue(util.glob_match_func(\"[\", \"\\\\[\"))\n        self.assertTrue(util.glob_match_func(\"*\", \"\\\\*\"))\n        self.assertTrue(util.glob_match_func(\"\\\\*\", \"\\\\\\\\\\\\*\"))\n\n    def test_ip_match(self):\n        self.assertTrue(util.ip_match_func(\"192.168.2.123\", \"192.168.2.0/24\"))\n        self.assertFalse(util.ip_match_func(\"192.168.2.123\", \"192.168.3.0/24\"))\n        self.assertTrue(util.ip_match_func(\"192.168.2.123\", \"192.168.2.0/16\"))\n        self.assertTrue(util.ip_match_func(\"192.168.2.123\", \"192.168.2.123\"))\n        self.assertTrue(util.ip_match_func(\"192.168.2.123\", \"192.168.2.123/32\"))\n        self.assertTrue(util.ip_match_func(\"10.0.0.11\", \"10.0.0.0/8\"))\n        self.assertFalse(util.ip_match_func(\"11.0.0.123\", \"10.0.0.0/8\"))\n\n    def test_time_match(self):\n        self.assertFalse(util.time_match_func(\"0001-01-01 00:00:00\", \"0001-01-02 00:00:00\"))\n        self.assertTrue(util.time_match_func(\"0001-01-01 00:00:00\", \"9999-12-30 00:00:00\"))\n        self.assertTrue(util.time_match_func(\"_\", \"_\"))\n        self.assertTrue(util.time_match_func(\"_\", \"9999-12-30 00:00:00\"))\n        self.assertFalse(util.time_match_func(\"_\", \"0001-01-02 00:00:00\"))\n        self.assertTrue(util.time_match_func(\"0001-01-01 00:00:00\", \"_\"))\n        self.assertFalse(util.time_match_func(\"9999-12-30 00:00:00\", \"_\"))\n",
  "GT_file_code": {
    "casbin/util/builtin_operators.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport ipaddress\nimport re\nfrom datetime import datetime\n\nKEY_MATCH2_PATTERN = re.compile(r\"(.*?):[^\\/]+(.*?)\")\nKEY_MATCH3_PATTERN = re.compile(r\"(.*?){[^\\/]+?}(.*?)\")\nKEY_MATCH4_PATTERN = re.compile(r\"{([^/]+)}\")\nKEY_MATCH5_PATTERN = re.compile(r\"{[^/]+}\")\n\n\ndef key_match(key1, key2):\n    \"\"\"determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\n    For example, \"/foo/bar\" matches \"/foo/*\"\n    \"\"\"\n\n    i = key2.find(\"*\")\n    if i == -1:\n        return key1 == key2\n\n    if len(key1) > i:\n        return key1[:i] == key2[:i]\n    return key1 == key2[:i]\n\n\ndef key_match_func(*args):\n    \"\"\"The wrapper for key_match.\"\"\"\n    name1 = args[0]\n    name2 = args[1]\n\n    return key_match(name1, name2)\n\n\ndef key_get(key1, key2):\n    \"\"\"\n    key_get returns the matched part\n    For example, \"/foo/bar/foo\" matches \"/foo/*\"\n    \"bar/foo\" will been returned\n    \"\"\"\n    i = key2.find(\"*\")\n    if i == -1:\n        return \"\"\n\n    if len(key1) > i:\n        if key1[:i] == key2[:i]:\n            return key1[i:]\n    return \"\"\n\n\ndef key_match2(key1, key2):\n    \"\"\"determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\n    For example, \"/foo/bar\" matches \"/foo/*\", \"/resource1\" matches \"/:resource\"\n    \"\"\"\n\n    key2 = key2.replace(\"/*\", \"/.*\")\n    key2 = KEY_MATCH2_PATTERN.sub(r\"\\g<1>[^\\/]+\\g<2>\", key2, 0)\n\n    if key2 == \"*\":\n        key2 = \"(.*)\"\n\n    return regex_match(key1, \"^\" + key2 + \"$\")\n\n\ndef key_match2_func(*args):\n    name1 = args[0]\n    name2 = args[1]\n\n    return key_match2(name1, name2)\n\n\ndef key_get2(key1, key2, path_var):\n    \"\"\"\n    key_get2 returns value matched pattern\n    For example, \"/resource1\" matches \"/:resource\"\n    if the pathVar == \"resource\", then \"resource1\" will be returned\n    \"\"\"\n    key2 = key2.replace(\"/*\", \"/.*\")\n\n    keys = re.findall(\":[^/]+\", key2)\n    key2 = KEY_MATCH2_PATTERN.sub(r\"\\g<1>([^\\/]+)\\g<2>\", key2, 0)\n\n    if key2 == \"*\":\n        key2 = \"(.*)\"\n\n    key2 = \"^\" + key2 + \"$\"\n    values = re.match(key2, key1)\n    if values is None:\n        return \"\"\n    for i, key in enumerate(keys):\n        if path_var == key[1:]:\n            return values.groups()[i]\n    return \"\"\n\n\ndef key_match3(key1, key2):\n    \"\"\"determines determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\n    For example, \"/foo/bar\" matches \"/foo/*\", \"/resource1\" matches \"/{resource}\"\n    \"\"\"\n\n    key2 = key2.replace(\"/*\", \"/.*\")\n    key2 = KEY_MATCH3_PATTERN.sub(r\"\\g<1>[^\\/]+\\g<2>\", key2, 0)\n\n    return regex_match(key1, \"^\" + key2 + \"$\")\n\n\ndef key_match3_func(*args):\n    name1 = args[0]\n    name2 = args[1]\n\n    return key_match3(name1, name2)\n\n\ndef key_get3(key1, key2, path_var):\n    \"\"\"\n    key_get3 returns value matched pattern\n    For example, \"project/proj_project1_admin/\" matches \"project/proj_{project}_admin/\"\n    if the pathVar == \"project\", then \"project1\" will be returned\n    \"\"\"\n    key2 = key2.replace(\"/*\", \"/.*\")\n\n    keys = re.findall(r\"{[^/]+?}\", key2)\n    key2 = KEY_MATCH3_PATTERN.sub(r\"\\g<1>([^/]+?)\\g<2>\", key2, 0)\n\n    if key2 == \"*\":\n        key2 = \"(.*)\"\n\n    key2 = \"^\" + key2 + \"$\"\n    values = re.match(key2, key1)\n    if values is None:\n        return \"\"\n    for i, key in enumerate(keys):\n        if path_var == key[1 : len(key) - 1]:\n            return values.groups()[i]\n    return \"\"\n\n\ndef key_match4(key1: str, key2: str) -> bool:\n    \"\"\"\n    key_match4 determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\n    Besides what key_match3 does, key_match4 can also match repeated patterns:\n    \"/parent/123/child/123\" matches \"/parent/{id}/child/{id}\"\n    \"/parent/123/child/456\" does not match \"/parent/{id}/child/{id}\"\n    But key_match3 will match both.\n    \"\"\"\n    key2 = key2.replace(\"/*\", \"/.*\")\n\n    tokens: [str] = []\n\n    def repl(matchobj):\n        tokens.append(matchobj.group(1))\n        return \"([^/]+)\"\n\n    key2 = KEY_MATCH4_PATTERN.sub(repl, key2)\n\n    regexp = re.compile(\"^\" + key2 + \"$\")\n    matches = regexp.match(key1)\n\n    if matches is None:\n        return False\n    if len(tokens) != len(matches.groups()):\n        raise Exception(\"KeyMatch4: number of tokens is not equal to number of values\")\n\n    tokens_matches = dict()\n\n    for i in range(len(tokens)):\n        token, match = tokens[i], matches.groups()[i]\n\n        if token not in tokens_matches.keys():\n            tokens_matches[token] = match\n        else:\n            if tokens_matches[token] != match:\n                return False\n    return True\n\n\ndef key_match4_func(*args) -> bool:\n    \"\"\"\n    key_match4_func is the wrapper for key_match4.\n    \"\"\"\n    name1 = args[0]\n    name2 = args[1]\n\n    return key_match4(name1, name2)\n\n\ndef key_match5(key1: str, key2: str) -> bool:\n    \"\"\"\n    key_match5 determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *\n    For example,\n    - \"/foo/bar?status=1&type=2\" matches \"/foo/bar\"\n    - \"/parent/child1\" and \"/parent/child1\" matches \"/parent/*\"\n    - \"/parent/child1?status=1\" matches \"/parent/*\"\n    \"\"\"\n    i = key1.find(\"?\")\n    if i != -1:\n        key1 = key1[:i]\n\n    key2 = key2.replace(\"/*\", \"/.*\")\n\n    key2 = KEY_MATCH5_PATTERN.sub(r\"[^/]+\", key2, 0)\n\n    return regex_match(key1, \"^\" + key2 + \"$\")\n\n\ndef key_match5_func(*args) -> bool:\n    name1 = args[0]\n    name2 = args[1]\n\n    return key_match5(name1, name2)\n\n\ndef regex_match(key1, key2):\n    \"\"\"determines whether key1 matches the pattern of key2 in regular expression.\"\"\"\n\n    res = re.match(key2, key1)\n    if res:\n        return True\n    else:\n        return False\n\n\ndef regex_match_func(*args):\n    \"\"\"the wrapper for RegexMatch.\"\"\"\n\n    name1 = args[0]\n    name2 = args[1]\n\n    return regex_match(name1, name2)\n\n\ndef range_match(pattern, pattern_index, test):\n    \"\"\"check the if char `test` in string is match with the scope of [...] in pattern\"\"\"\n\n    pattern_len = len(pattern)\n    if pattern_index == pattern_len:\n        return -1\n    negate = pattern[pattern_index] == \"!\" or pattern[pattern_index] == \"^\"\n    if negate:\n        pattern_index += 1\n    ok = 0\n    while True:\n        if pattern_index == pattern_len:\n            break\n        c = pattern[pattern_index]\n        pattern_index += 1\n        if c == \"]\":\n            break\n        if c == \"\\\\\":\n            if pattern_index == pattern_len:\n                return -1\n            c = pattern[pattern_index]\n            pattern_index += 1\n        if (\n            pattern_index != pattern_len\n            and pattern[pattern_index] == \"-\"\n            and pattern_index + 1 != pattern_len\n            and pattern[pattern_index + 1] != \"]\"\n        ):\n            c2 = pattern[pattern_index + 1]\n            pattern_index += 2\n            if c2 == \"\\\\\":\n                if pattern_index == pattern_len:\n                    return -1\n                c2 = pattern[pattern_index]\n                pattern_index += 1\n            if c <= test <= c2:\n                ok = 1\n        elif c == test:\n            ok = 1\n\n    if ok == negate:\n        return -1\n    else:\n        return pattern_index\n\n\ndef glob_match(string, pattern):\n    \"\"\"determines whether string matches the pattern in glob expression.\"\"\"\n\n    pattern_len = len(pattern)\n    string_len = len(string)\n    if pattern_len == 0:\n        return string_len == 0\n    pattern_index = 0\n    string_index = 0\n    while True:\n        if pattern_index == pattern_len:\n            return string_len == string_index\n        c = pattern[pattern_index]\n        pattern_index += 1\n        if c == \"?\":\n            if string_index == string_len:\n                return False\n            if string[string_index] == \"/\":\n                return False\n            string_index += 1\n            continue\n        if c == \"*\":\n            while (pattern_index != pattern_len) and (c == \"*\"):\n                c = pattern[pattern_index]\n                pattern_index += 1\n            if pattern_index == pattern_len:\n                return string.find(\"/\", string_index) == -1\n            else:\n                if c == \"/\":\n                    string_index = string.find(\"/\", string_index)\n                    if string_index == -1:\n                        return False\n                    else:\n                        string_index += 1\n            # General case, use recursion.\n            while string_index != string_len:\n                if glob_match(string[string_index:], pattern[pattern_index:]):\n                    return True\n                if string[string_index] == \"/\":\n                    break\n                string_index += 1\n            continue\n        if c == \"[\":\n            if string_index == string_len:\n                return False\n            if string[string_index] == \"/\":\n                return False\n            pattern_index = range_match(pattern, pattern_index, string[string_index])\n            if pattern_index == -1:\n                return False\n            string_index += 1\n            continue\n        if c == \"\\\\\":\n            if pattern_index == pattern_len:\n                c = \"\\\\\"\n            else:\n                c = pattern[pattern_index]\n                pattern_index += 1\n            # fall through\n        # other cases and c == \"\\\\\"\n        if string_index == string_len:\n            return False\n        else:\n            if c == string[string_index]:\n                string_index += 1\n            else:\n                return False\n\n\ndef glob_match_func(*args):\n    \"\"\"the wrapper for globMatch.\"\"\"\n\n    string = args[0]\n    pattern = args[1]\n\n    return glob_match(string, pattern)\n\n\ndef ip_match(ip1, ip2):\n    \"\"\"IPMatch determines whether IP address ip1 matches the pattern of IP address ip2, ip2 can be an IP address or a CIDR pattern.\n    For example, \"192.168.2.123\" matches \"192.168.2.0/24\"\n    \"\"\"\n    ip1 = ipaddress.ip_address(ip1)\n    try:\n        network = ipaddress.ip_network(ip2, strict=False)\n        return ip1 in network\n    except ValueError:\n        return ip1 == ip2\n\n\ndef ip_match_func(*args):\n    \"\"\"the wrapper for IPMatch.\"\"\"\n\n    ip1 = args[0]\n    ip2 = args[1]\n\n    return ip_match(ip1, ip2)\n\n\ndef generate_g_function(rm):\n    \"\"\"the factory method of the g(_, _) function.\"\"\"\n\n    def f(*args):\n        name1 = args[0]\n        name2 = args[1]\n\n        if not rm:\n            return name1 == name2\n        elif 2 == len(args):\n            return rm.has_link(name1, name2)\n        else:\n            domain = str(args[2])\n            return rm.has_link(name1, name2, domain)\n\n    return f\n\n\ndef generate_conditional_g_function(crm):\n    \"\"\"the factory method of the g(_, _[, _]) function with conditions.\"\"\"\n\n    def conditional_g_function(*args):\n        name1, name2 = args[0], args[1]\n\n        if crm is None:\n            has_link = name1 == name2\n        elif len(args) == 2:\n            has_link = crm.has_link(name1, name2)\n        else:\n            domain = str(args[2])\n            has_link = crm.has_link(name1, name2, domain)\n\n        return has_link\n\n    return conditional_g_function\n\n\ndef time_match_func(*args):\n    \"\"\"the wrapper for TimeMatch.\"\"\"\n    if len(args) != 2:\n        raise RuntimeError(\"time_match requires 2 arguments\")\n\n    start_time, end_time = args[0], args[1]\n\n    try:\n        now = datetime.now()\n        if start_time != \"_\":\n            start = datetime.strptime(start_time, \"%Y-%m-%d %H:%M:%S\")\n            if not now > start:\n                return False\n\n        if end_time != \"_\":\n            end = datetime.strptime(end_time, \"%Y-%m-%d %H:%M:%S\")\n            if not now < end:\n                return False\n\n        return True\n    except Exception as e:\n        raise RuntimeError(e)\n"
  },
  "GT_src_dict": {
    "casbin/util/builtin_operators.py": {
      "key_match": {
        "code": "def key_match(key1, key2):\n    \"\"\"Determines whether `key1` matches the pattern of `key2`, which can be similar to a RESTful path where `key2` may contain a wildcard character '*'. \n\nParameters:\n- `key1` (str): The input string to be matched against the pattern defined by `key2`.\n- `key2` (str): The pattern string that may include a wildcard indicating variable path segments.\n\nReturns:\n- bool: True if `key1` matches the pattern defined by `key2`, otherwise False.\n\nThis function checks for the presence of the wildcard '*' in `key2`. If '*' is found, it compares the prefix of `key1` up to the position of '*' with the corresponding substring of `key2`. If no '*' is present, it simply checks for direct equality between `key1` and `key2`. This function interacts with the overall key matching logic used in similar functions defined throughout the code, which handle patterns in URLs and paths.\"\"\"\n    'determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\\n    For example, \"/foo/bar\" matches \"/foo/*\"\\n    '\n    i = key2.find('*')\n    if i == -1:\n        return key1 == key2\n    if len(key1) > i:\n        return key1[:i] == key2[:i]\n    return key1 == key2[:i]",
        "docstring": "Determines whether `key1` matches the pattern of `key2`, which can be similar to a RESTful path where `key2` may contain a wildcard character '*'. \n\nParameters:\n- `key1` (str): The input string to be matched against the pattern defined by `key2`.\n- `key2` (str): The pattern string that may include a wildcard indicating variable path segments.\n\nReturns:\n- bool: True if `key1` matches the pattern defined by `key2`, otherwise False.\n\nThis function checks for the presence of the wildcard '*' in `key2`. If '*' is found, it compares the prefix of `key1` up to the position of '*' with the corresponding substring of `key2`. If no '*' is present, it simply checks for direct equality between `key1` and `key2`. This function interacts with the overall key matching logic used in similar functions defined throughout the code, which handle patterns in URLs and paths.",
        "signature": "def key_match(key1, key2):",
        "type": "Function",
        "class_signature": null
      },
      "key_match_func": {
        "code": "def key_match_func(*args):\n    \"\"\"The `key_match_func` function serves as a wrapper for the `key_match` function, facilitating the matching of two keys that may represent paths, similar to RESTful API routes. \n\nParameters:\n- `*args`: A variable-length argument list where:\n  - `args[0]` (str): The first key to match (name1).\n  - `args[1]` (str): The second key to match against (name2).\n\nReturns:\n- bool: True if `name1` matches the pattern defined by `name2`, allowing `name2` to contain a wildcard (`*`), otherwise False.\n\nThis function interacts with the `key_match` function, which is responsible for the actual matching logic. It does not use any constants directly.\"\"\"\n    'The wrapper for key_match.'\n    name1 = args[0]\n    name2 = args[1]\n    return key_match(name1, name2)",
        "docstring": "The `key_match_func` function serves as a wrapper for the `key_match` function, facilitating the matching of two keys that may represent paths, similar to RESTful API routes. \n\nParameters:\n- `*args`: A variable-length argument list where:\n  - `args[0]` (str): The first key to match (name1).\n  - `args[1]` (str): The second key to match against (name2).\n\nReturns:\n- bool: True if `name1` matches the pattern defined by `name2`, allowing `name2` to contain a wildcard (`*`), otherwise False.\n\nThis function interacts with the `key_match` function, which is responsible for the actual matching logic. It does not use any constants directly.",
        "signature": "def key_match_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "key_get": {
        "code": "def key_get(key1, key2):\n    \"\"\"Returns the portion of key1 that follows the matching segment defined by key2, which may contain a wildcard '*'. \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which can contain a wildcard ('*') indicating that any segment can match in that position.\n\nReturns:\n- str: The substring of key1 that follows the matched portion, or an empty string if key1 does not match the pattern defined by key2.\n\nThe function relies on the position of the wildcard '*' in key2 to determine the matching criteria. If no wildcard is found, it returns an empty string. If a match is found, it checks if the initial segments of key1 and key2 are the same up until the wildcard and returns the unmatched part of key1 that comes after this match.\"\"\"\n    '\\n    key_get returns the matched part\\n    For example, \"/foo/bar/foo\" matches \"/foo/*\"\\n    \"bar/foo\" will been returned\\n    '\n    i = key2.find('*')\n    if i == -1:\n        return ''\n    if len(key1) > i:\n        if key1[:i] == key2[:i]:\n            return key1[i:]\n    return ''",
        "docstring": "Returns the portion of key1 that follows the matching segment defined by key2, which may contain a wildcard '*'. \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which can contain a wildcard ('*') indicating that any segment can match in that position.\n\nReturns:\n- str: The substring of key1 that follows the matched portion, or an empty string if key1 does not match the pattern defined by key2.\n\nThe function relies on the position of the wildcard '*' in key2 to determine the matching criteria. If no wildcard is found, it returns an empty string. If a match is found, it checks if the initial segments of key1 and key2 are the same up until the wildcard and returns the unmatched part of key1 that comes after this match.",
        "signature": "def key_get(key1, key2):",
        "type": "Function",
        "class_signature": null
      },
      "key_match2": {
        "code": "def key_match2(key1, key2):\n    \"\"\"Determines whether `key1` matches the pattern of `key2`, which can contain wildcard characters (specifically '*'). It is useful for matching paths in a RESTful context. For example, \"/foo/bar\" will match the pattern \"/foo/*\", and \"/resource1\" will match \"/:resource\".\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which may contain wildcards.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, False otherwise.\n\nDependencies:\n- Uses the `KEY_MATCH2_PATTERN` regular expression to replace segments in `key2` with a regex equivalent that captures variable path segments.\n- Utilizes the `regex_match` function to perform the final matching against the compiled regular expression pattern.\"\"\"\n    'determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\\n    For example, \"/foo/bar\" matches \"/foo/*\", \"/resource1\" matches \"/:resource\"\\n    '\n    key2 = key2.replace('/*', '/.*')\n    key2 = KEY_MATCH2_PATTERN.sub('\\\\g<1>[^\\\\/]+\\\\g<2>', key2, 0)\n    if key2 == '*':\n        key2 = '(.*)'\n    return regex_match(key1, '^' + key2 + '$')",
        "docstring": "Determines whether `key1` matches the pattern of `key2`, which can contain wildcard characters (specifically '*'). It is useful for matching paths in a RESTful context. For example, \"/foo/bar\" will match the pattern \"/foo/*\", and \"/resource1\" will match \"/:resource\".\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which may contain wildcards.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, False otherwise.\n\nDependencies:\n- Uses the `KEY_MATCH2_PATTERN` regular expression to replace segments in `key2` with a regex equivalent that captures variable path segments.\n- Utilizes the `regex_match` function to perform the final matching against the compiled regular expression pattern.",
        "signature": "def key_match2(key1, key2):",
        "type": "Function",
        "class_signature": null
      },
      "key_match2_func": {
        "code": "def key_match2_func(*args):\n    \"\"\"key_match2_func is a wrapper function that takes two string arguments, name1 and name2, and determines whether name1 matches the pattern specified by name2 using the key_match2 function. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first string (name1) to be matched.\n  - args[1] (str): The pattern string (name2) that may contain wildcards (e.g., '*').\n\nReturns:\n- bool: Returns True if name1 matches the pattern in name2; otherwise, False.\n\nThis function relies on the key_match2 function, which uses regular expressions, specifically the KEY_MATCH2_PATTERN defined in the context, to perform matching based on flexible patterns akin to RESTful paths. The KEY_MATCH2_PATTERN is a compiled regular expression that aids in the matching logic by substituting parts of the pattern.\"\"\"\n    name1 = args[0]\n    name2 = args[1]\n    return key_match2(name1, name2)",
        "docstring": "key_match2_func is a wrapper function that takes two string arguments, name1 and name2, and determines whether name1 matches the pattern specified by name2 using the key_match2 function. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first string (name1) to be matched.\n  - args[1] (str): The pattern string (name2) that may contain wildcards (e.g., '*').\n\nReturns:\n- bool: Returns True if name1 matches the pattern in name2; otherwise, False.\n\nThis function relies on the key_match2 function, which uses regular expressions, specifically the KEY_MATCH2_PATTERN defined in the context, to perform matching based on flexible patterns akin to RESTful paths. The KEY_MATCH2_PATTERN is a compiled regular expression that aids in the matching logic by substituting parts of the pattern.",
        "signature": "def key_match2_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "key_get2": {
        "code": "def key_get2(key1, key2, path_var):\n    \"\"\"key_get2(key1, key2, path_var) returns the value from key1 that matches the pattern defined in key2. It is commonly used to extract dynamic segments from a path-like string based on the format of key2, where key2 may contain parameterized placeholders denoted by ':' (e.g., '/:resource'). \n\nParameters:\n- key1 (str): The input string to match against key2, often a URL path.\n- key2 (str): The pattern to match key1 against, which may include placeholders for dynamic values.\n- path_var (str): The name of the variable represented in key2, which indicates what value to extract from key1 when a match is found.\n\nReturns:\n- str: The matched value corresponding to the given path_var from key1 if a match is found; otherwise, it returns an empty string.\n\nThis function uses the constant KEY_MATCH2_PATTERN, which is defined at the beginning of the code. This regex pattern is utilized to transform the key2 string by recognizing and replacing placeholder syntax (e.g., ':resource') in the pattern to facilitate a proper match comparison against key1.\"\"\"\n    '\\n    key_get2 returns value matched pattern\\n    For example, \"/resource1\" matches \"/:resource\"\\n    if the pathVar == \"resource\", then \"resource1\" will be returned\\n    '\n    key2 = key2.replace('/*', '/.*')\n    keys = re.findall(':[^/]+', key2)\n    key2 = KEY_MATCH2_PATTERN.sub('\\\\g<1>([^\\\\/]+)\\\\g<2>', key2, 0)\n    if key2 == '*':\n        key2 = '(.*)'\n    key2 = '^' + key2 + '$'\n    values = re.match(key2, key1)\n    if values is None:\n        return ''\n    for i, key in enumerate(keys):\n        if path_var == key[1:]:\n            return values.groups()[i]\n    return ''",
        "docstring": "key_get2(key1, key2, path_var) returns the value from key1 that matches the pattern defined in key2. It is commonly used to extract dynamic segments from a path-like string based on the format of key2, where key2 may contain parameterized placeholders denoted by ':' (e.g., '/:resource'). \n\nParameters:\n- key1 (str): The input string to match against key2, often a URL path.\n- key2 (str): The pattern to match key1 against, which may include placeholders for dynamic values.\n- path_var (str): The name of the variable represented in key2, which indicates what value to extract from key1 when a match is found.\n\nReturns:\n- str: The matched value corresponding to the given path_var from key1 if a match is found; otherwise, it returns an empty string.\n\nThis function uses the constant KEY_MATCH2_PATTERN, which is defined at the beginning of the code. This regex pattern is utilized to transform the key2 string by recognizing and replacing placeholder syntax (e.g., ':resource') in the pattern to facilitate a proper match comparison against key1.",
        "signature": "def key_get2(key1, key2, path_var):",
        "type": "Function",
        "class_signature": null
      },
      "key_match3": {
        "code": "def key_match3(key1, key2):\n    \"\"\"Determines whether the `key1` matches the pattern specified by `key2`, which can contain wildcards like `*`. This is useful for matching RESTful paths, where `key2` may define variable parts of the path using `{}` syntax. \n\nParameters:\n- `key1` (str): The string to be matched against the pattern.\n- `key2` (str): The pattern string which may include wildcards and variable placeholders.\n\nReturns:\n- (bool): Returns `True` if `key1` matches the pattern `key2`, otherwise returns `False`.\n\nDependencies:\n- Utilizes the `regex_match` function to perform the final matching using regular expressions.\n- Modifies `key2` to replace segments as per the `KEY_MATCH3_PATTERN` regex pattern defined globally, allowing it to translate variable placeholders in the pattern to corresponding regex parts.\"\"\"\n    'determines determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\\n    For example, \"/foo/bar\" matches \"/foo/*\", \"/resource1\" matches \"/{resource}\"\\n    '\n    key2 = key2.replace('/*', '/.*')\n    key2 = KEY_MATCH3_PATTERN.sub('\\\\g<1>[^\\\\/]+\\\\g<2>', key2, 0)\n    return regex_match(key1, '^' + key2 + '$')",
        "docstring": "Determines whether the `key1` matches the pattern specified by `key2`, which can contain wildcards like `*`. This is useful for matching RESTful paths, where `key2` may define variable parts of the path using `{}` syntax. \n\nParameters:\n- `key1` (str): The string to be matched against the pattern.\n- `key2` (str): The pattern string which may include wildcards and variable placeholders.\n\nReturns:\n- (bool): Returns `True` if `key1` matches the pattern `key2`, otherwise returns `False`.\n\nDependencies:\n- Utilizes the `regex_match` function to perform the final matching using regular expressions.\n- Modifies `key2` to replace segments as per the `KEY_MATCH3_PATTERN` regex pattern defined globally, allowing it to translate variable placeholders in the pattern to corresponding regex parts.",
        "signature": "def key_match3(key1, key2):",
        "type": "Function",
        "class_signature": null
      },
      "key_match3_func": {
        "code": "def key_match3_func(*args):\n    \"\"\"key_match3_func is a wrapper function for the key_match3 function, determining whether the first key (name1) matches the pattern of the second key (name2) using a RESTful path-like matching approach. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first key (name1) to be matched.\n  - args[1] (str): The second key (name2), which may contain special patterns such as \"*\".\n\nReturns:\n- bool: True if name1 matches the pattern specified by name2; otherwise, False.\n\nThis function relies on the key_match3 function, which uses patterns defined by the KEY_MATCH3_PATTERN constant (a regular expression) to perform the matching. If name2 contains variable segments defined by curly braces (e.g., \"{resource}\"), key_match3 will facilitate matching against these patterns.\"\"\"\n    name1 = args[0]\n    name2 = args[1]\n    return key_match3(name1, name2)",
        "docstring": "key_match3_func is a wrapper function for the key_match3 function, determining whether the first key (name1) matches the pattern of the second key (name2) using a RESTful path-like matching approach. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first key (name1) to be matched.\n  - args[1] (str): The second key (name2), which may contain special patterns such as \"*\".\n\nReturns:\n- bool: True if name1 matches the pattern specified by name2; otherwise, False.\n\nThis function relies on the key_match3 function, which uses patterns defined by the KEY_MATCH3_PATTERN constant (a regular expression) to perform the matching. If name2 contains variable segments defined by curly braces (e.g., \"{resource}\"), key_match3 will facilitate matching against these patterns.",
        "signature": "def key_match3_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "key_get3": {
        "code": "def key_get3(key1, key2, path_var):\n    \"\"\"Returns the value matched by a specified pattern in the given key string based on a defined route pattern. \n\nParameters:\n- key1 (str): The key string to match against the pattern (e.g., \"project/proj_project1_admin/\").\n- key2 (str): The pattern string containing variable placeholders (e.g., \"project/proj_{project}_admin/\").\n- path_var (str): The specific variable name to extract from the matched pattern (e.g., \"project\").\n\nReturns:\n- str: The value corresponding to the specified path_var if a match is found; otherwise, returns an empty string.\n\nThis function utilizes the regular expression defined in KEY_MATCH3_PATTERN to construct and match the pattern. The constant KEY_MATCH3_PATTERN is a compiled regex pattern that assists in transforming placeholder patterns into matchable regex patterns.\"\"\"\n    '\\n    key_get3 returns value matched pattern\\n    For example, \"project/proj_project1_admin/\" matches \"project/proj_{project}_admin/\"\\n    if the pathVar == \"project\", then \"project1\" will be returned\\n    '\n    key2 = key2.replace('/*', '/.*')\n    keys = re.findall('{[^/]+?}', key2)\n    key2 = KEY_MATCH3_PATTERN.sub('\\\\g<1>([^/]+?)\\\\g<2>', key2, 0)\n    if key2 == '*':\n        key2 = '(.*)'\n    key2 = '^' + key2 + '$'\n    values = re.match(key2, key1)\n    if values is None:\n        return ''\n    for i, key in enumerate(keys):\n        if path_var == key[1:len(key) - 1]:\n            return values.groups()[i]\n    return ''",
        "docstring": "Returns the value matched by a specified pattern in the given key string based on a defined route pattern. \n\nParameters:\n- key1 (str): The key string to match against the pattern (e.g., \"project/proj_project1_admin/\").\n- key2 (str): The pattern string containing variable placeholders (e.g., \"project/proj_{project}_admin/\").\n- path_var (str): The specific variable name to extract from the matched pattern (e.g., \"project\").\n\nReturns:\n- str: The value corresponding to the specified path_var if a match is found; otherwise, returns an empty string.\n\nThis function utilizes the regular expression defined in KEY_MATCH3_PATTERN to construct and match the pattern. The constant KEY_MATCH3_PATTERN is a compiled regex pattern that assists in transforming placeholder patterns into matchable regex patterns.",
        "signature": "def key_get3(key1, key2, path_var):",
        "type": "Function",
        "class_signature": null
      },
      "key_match4": {
        "code": "def key_match4(key1: str, key2: str) -> bool:\n    \"\"\"key_match4 determines if one string (key1) matches the pattern of another string (key2) in a RESTful path-like fashion, with support for repeated variable patterns. For instance, it can differentiate between paths with the same variable structure (e.g., \"/parent/123/child/123\" matches \"/parent/{id}/child/{id}\", but \"/parent/123/child/456\" does not). \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string, which can contain wildcards and variable placeholders in braces (e.g., {id}).\n\nReturns:\n- bool: True if key1 matches the pattern specified by key2, otherwise False. If there's an inconsistency in the number of matched tokens, an exception is raised.\n\nThe function utilizes the KEY_MATCH4_PATTERN regular expression pattern to parse and identify variable placeholders. These placeholders are represented in key2, allowing key_match4 to ensure that identical placeholders correspond to identical values in key1.\"\"\"\n    '\\n    key_match4 determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *.\\n    Besides what key_match3 does, key_match4 can also match repeated patterns:\\n    \"/parent/123/child/123\" matches \"/parent/{id}/child/{id}\"\\n    \"/parent/123/child/456\" does not match \"/parent/{id}/child/{id}\"\\n    But key_match3 will match both.\\n    '\n    key2 = key2.replace('/*', '/.*')\n    tokens: [str] = []\n\n    def repl(matchobj):\n        \"\"\"repl(matchobj) processes a regex match object to extract a token from the matching string pattern.\n\n    Parameters:\n        matchobj (re.Match): A match object returned from a regular expression match, containing information about the matched string.\n\n    Returns:\n        str: A string pattern \"([^/]+)\" that represents a capturing group matching one or more characters that are not a forward slash (\"/\"). This allows for dynamic matching of variable path segments in route patterns.\n\n    Side Effects:\n        It appends the captured group (the first parenthesis in the regex) to the `tokens` list, which is defined outside this function and used to keep track of variables matched in the corresponding route pattern.\n\n    Dependencies:\n        The function relies on the `tokens` list being defined in the scope where this `repl` function is executed, which is essential for managing the matched variable tokens during regex replacement.\"\"\"\n        tokens.append(matchobj.group(1))\n        return '([^/]+)'\n    key2 = KEY_MATCH4_PATTERN.sub(repl, key2)\n    regexp = re.compile('^' + key2 + '$')\n    matches = regexp.match(key1)\n    if matches is None:\n        return False\n    if len(tokens) != len(matches.groups()):\n        raise Exception('KeyMatch4: number of tokens is not equal to number of values')\n    tokens_matches = dict()\n    for i in range(len(tokens)):\n        token, match = (tokens[i], matches.groups()[i])\n        if token not in tokens_matches.keys():\n            tokens_matches[token] = match\n        elif tokens_matches[token] != match:\n            return False\n    return True",
        "docstring": "key_match4 determines if one string (key1) matches the pattern of another string (key2) in a RESTful path-like fashion, with support for repeated variable patterns. For instance, it can differentiate between paths with the same variable structure (e.g., \"/parent/123/child/123\" matches \"/parent/{id}/child/{id}\", but \"/parent/123/child/456\" does not). \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string, which can contain wildcards and variable placeholders in braces (e.g., {id}).\n\nReturns:\n- bool: True if key1 matches the pattern specified by key2, otherwise False. If there's an inconsistency in the number of matched tokens, an exception is raised.\n\nThe function utilizes the KEY_MATCH4_PATTERN regular expression pattern to parse and identify variable placeholders. These placeholders are represented in key2, allowing key_match4 to ensure that identical placeholders correspond to identical values in key1.",
        "signature": "def key_match4(key1: str, key2: str) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "key_match4_func": {
        "code": "def key_match4_func(*args) -> bool:\n    \"\"\"key_match4_func is a wrapper function for key_match4, designed to determine whether two keys, name1 and name2, match a specified pattern that allows for repeated segments. \n\nParameters:\n- args: A variable-length argument list where:\n  - args[0] (name1): A string representing the first key.\n  - args[1] (name2): A string representing the pattern against which name1 is being matched.\n\nReturns:\n- bool: Returns True if name1 matches the pattern defined by name2 according to the rules of key_match4; otherwise, it returns False.\n\nThis function relies on the key_match4 function, which utilizes regular expressions to match structured paths, including the ability to handle duplicate tokens. No external constants are utilized within this function.\"\"\"\n    '\\n    key_match4_func is the wrapper for key_match4.\\n    '\n    name1 = args[0]\n    name2 = args[1]\n    return key_match4(name1, name2)",
        "docstring": "key_match4_func is a wrapper function for key_match4, designed to determine whether two keys, name1 and name2, match a specified pattern that allows for repeated segments. \n\nParameters:\n- args: A variable-length argument list where:\n  - args[0] (name1): A string representing the first key.\n  - args[1] (name2): A string representing the pattern against which name1 is being matched.\n\nReturns:\n- bool: Returns True if name1 matches the pattern defined by name2 according to the rules of key_match4; otherwise, it returns False.\n\nThis function relies on the key_match4 function, which utilizes regular expressions to match structured paths, including the ability to handle duplicate tokens. No external constants are utilized within this function.",
        "signature": "def key_match4_func(*args) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "key_match5": {
        "code": "def key_match5(key1: str, key2: str) -> bool:\n    \"\"\"Determines whether the given key1 matches the pattern specified by key2, which may include wildcard characters (*). This function essentially checks if key1 adheres to the routing patterns analogous to RESTful paths, while also accommodating optional query parameters.\n\nParameters:\n- key1 (str): The string to check against the pattern (e.g., a URL).\n- key2 (str): The pattern against which key1 is compared, which may include wildcards.\n\nReturns:\n- bool: True if key1 matches the pattern described by key2; otherwise, False.\n\nThis function interacts with the constant KEY_MATCH5_PATTERN, a compiled regular expression that is used to facilitate matching of path segments within key2. The function employs regex_match to execute the final comparison, ensuring the formatted key1 string aligns with the modified version of key2.\"\"\"\n    '\\n    key_match5 determines whether key1 matches the pattern of key2 (similar to RESTful path), key2 can contain a *\\n    For example,\\n    - \"/foo/bar?status=1&type=2\" matches \"/foo/bar\"\\n    - \"/parent/child1\" and \"/parent/child1\" matches \"/parent/*\"\\n    - \"/parent/child1?status=1\" matches \"/parent/*\"\\n    '\n    i = key1.find('?')\n    if i != -1:\n        key1 = key1[:i]\n    key2 = key2.replace('/*', '/.*')\n    key2 = KEY_MATCH5_PATTERN.sub('[^/]+', key2, 0)\n    return regex_match(key1, '^' + key2 + '$')",
        "docstring": "Determines whether the given key1 matches the pattern specified by key2, which may include wildcard characters (*). This function essentially checks if key1 adheres to the routing patterns analogous to RESTful paths, while also accommodating optional query parameters.\n\nParameters:\n- key1 (str): The string to check against the pattern (e.g., a URL).\n- key2 (str): The pattern against which key1 is compared, which may include wildcards.\n\nReturns:\n- bool: True if key1 matches the pattern described by key2; otherwise, False.\n\nThis function interacts with the constant KEY_MATCH5_PATTERN, a compiled regular expression that is used to facilitate matching of path segments within key2. The function employs regex_match to execute the final comparison, ensuring the formatted key1 string aligns with the modified version of key2.",
        "signature": "def key_match5(key1: str, key2: str) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "key_match5_func": {
        "code": "def key_match5_func(*args) -> bool:\n    \"\"\"key_match5_func is a wrapper function that determines if one string (name1) matches a specified pattern (name2) according to a defined set of matching rules, which can include wildcard indicators. This function accepts two parameters:\n- name1 (str): The string to be matched against the pattern.\n- name2 (str): The pattern to match against, which may include a wildcard (*).\n\nThe function returns a boolean value: True if name1 matches the pattern defined by name2, or False otherwise. This function relies on the key_match5 function for the actual matching logic, which handles both exact matches and those that accommodate wildcards while ignoring query parameters in the input strings. No constants are directly used within this function, but it encapsulates the logic of key_match5, which is defined earlier in the code.\"\"\"\n    name1 = args[0]\n    name2 = args[1]\n    return key_match5(name1, name2)",
        "docstring": "key_match5_func is a wrapper function that determines if one string (name1) matches a specified pattern (name2) according to a defined set of matching rules, which can include wildcard indicators. This function accepts two parameters:\n- name1 (str): The string to be matched against the pattern.\n- name2 (str): The pattern to match against, which may include a wildcard (*).\n\nThe function returns a boolean value: True if name1 matches the pattern defined by name2, or False otherwise. This function relies on the key_match5 function for the actual matching logic, which handles both exact matches and those that accommodate wildcards while ignoring query parameters in the input strings. No constants are directly used within this function, but it encapsulates the logic of key_match5, which is defined earlier in the code.",
        "signature": "def key_match5_func(*args) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "regex_match": {
        "code": "def regex_match(key1, key2):\n    \"\"\"determines whether `key1` matches the pattern of `key2` using regular expressions.\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The regular expression pattern that `key1` is tested against.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, otherwise False.\n\nThis function utilizes the `re` module for regular expression matching. It is used within various key matching functions, such as `key_match2`, `key_match3`, `key_match4`, and `key_match5`, to validate if a specific string structure adheres to defined patterns within those contexts.\"\"\"\n    'determines whether key1 matches the pattern of key2 in regular expression.'\n    res = re.match(key2, key1)\n    if res:\n        return True\n    else:\n        return False",
        "docstring": "determines whether `key1` matches the pattern of `key2` using regular expressions.\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The regular expression pattern that `key1` is tested against.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, otherwise False.\n\nThis function utilizes the `re` module for regular expression matching. It is used within various key matching functions, such as `key_match2`, `key_match3`, `key_match4`, and `key_match5`, to validate if a specific string structure adheres to defined patterns within those contexts.",
        "signature": "def regex_match(key1, key2):",
        "type": "Function",
        "class_signature": null
      },
      "regex_match_func": {
        "code": "def regex_match_func(*args):\n    \"\"\"Wrapper function for `regex_match`, which checks if two strings match based on a given regular expression. \n\nParameters:\n- `*args`: A variable length argument list where `args[0]` (name1) is the first string to compare, and `args[1]` (name2) is the regex pattern to match against.\n\nReturns:\n- Returns `True` if `name1` matches the `name2` regex pattern; otherwise, it returns `False`.\n\nThis function relies on the `regex_match` function, which performs the actual matching operation. No constants are defined or used within this function.\"\"\"\n    'the wrapper for RegexMatch.'\n    name1 = args[0]\n    name2 = args[1]\n    return regex_match(name1, name2)",
        "docstring": "Wrapper function for `regex_match`, which checks if two strings match based on a given regular expression. \n\nParameters:\n- `*args`: A variable length argument list where `args[0]` (name1) is the first string to compare, and `args[1]` (name2) is the regex pattern to match against.\n\nReturns:\n- Returns `True` if `name1` matches the `name2` regex pattern; otherwise, it returns `False`.\n\nThis function relies on the `regex_match` function, which performs the actual matching operation. No constants are defined or used within this function.",
        "signature": "def regex_match_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "range_match": {
        "code": "def range_match(pattern, pattern_index, test):\n    \"\"\"check the if char `test` in string is match with the scope of [...] in pattern.\n\nParameters:\n- pattern (str): The pattern string that includes a character class (e.g., \"[abc]\") to match against.\n- pattern_index (int): The current position within the pattern string to evaluate.\n- test (str): The character being tested for a match within the specified range.\n\nReturns:\n- int: The updated index of the pattern after processing, or -1 if no match is found.\n\nThis function handles character class matching, including negation (using '!' or '^') and ranges (e.g., '[a-z]'). It interacts with the overall pattern matching functionality provided in the module, particularly within the context of glob or regex matching operations. No external constants are used within this function.\"\"\"\n    'check the if char `test` in string is match with the scope of [...] in pattern'\n    pattern_len = len(pattern)\n    if pattern_index == pattern_len:\n        return -1\n    negate = pattern[pattern_index] == '!' or pattern[pattern_index] == '^'\n    if negate:\n        pattern_index += 1\n    ok = 0\n    while True:\n        if pattern_index == pattern_len:\n            break\n        c = pattern[pattern_index]\n        pattern_index += 1\n        if c == ']':\n            break\n        if c == '\\\\':\n            if pattern_index == pattern_len:\n                return -1\n            c = pattern[pattern_index]\n            pattern_index += 1\n        if pattern_index != pattern_len and pattern[pattern_index] == '-' and (pattern_index + 1 != pattern_len) and (pattern[pattern_index + 1] != ']'):\n            c2 = pattern[pattern_index + 1]\n            pattern_index += 2\n            if c2 == '\\\\':\n                if pattern_index == pattern_len:\n                    return -1\n                c2 = pattern[pattern_index]\n                pattern_index += 1\n            if c <= test <= c2:\n                ok = 1\n        elif c == test:\n            ok = 1\n    if ok == negate:\n        return -1\n    else:\n        return pattern_index",
        "docstring": "check the if char `test` in string is match with the scope of [...] in pattern.\n\nParameters:\n- pattern (str): The pattern string that includes a character class (e.g., \"[abc]\") to match against.\n- pattern_index (int): The current position within the pattern string to evaluate.\n- test (str): The character being tested for a match within the specified range.\n\nReturns:\n- int: The updated index of the pattern after processing, or -1 if no match is found.\n\nThis function handles character class matching, including negation (using '!' or '^') and ranges (e.g., '[a-z]'). It interacts with the overall pattern matching functionality provided in the module, particularly within the context of glob or regex matching operations. No external constants are used within this function.",
        "signature": "def range_match(pattern, pattern_index, test):",
        "type": "Function",
        "class_signature": null
      },
      "glob_match": {
        "code": "def glob_match(string, pattern):\n    \"\"\"Determines whether the given string matches the specified glob pattern. The glob pattern can include wildcards, specifically `?` (which matches any single character except '/') and `*` (which matches zero or more characters). \n\nParameters:\n- string (str): The string to be matched against the pattern.\n- pattern (str): The glob pattern against which the string is tested.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nThis function utilizes a recursive approach to handle complex pattern matching scenarios, particularly for sections of the string defined by the glob syntax. It does not use any external constants, instead, it operates solely based on the input parameters.\"\"\"\n    'determines whether string matches the pattern in glob expression.'\n    pattern_len = len(pattern)\n    string_len = len(string)\n    if pattern_len == 0:\n        return string_len == 0\n    pattern_index = 0\n    string_index = 0\n    while True:\n        if pattern_index == pattern_len:\n            return string_len == string_index\n        c = pattern[pattern_index]\n        pattern_index += 1\n        if c == '?':\n            if string_index == string_len:\n                return False\n            if string[string_index] == '/':\n                return False\n            string_index += 1\n            continue\n        if c == '*':\n            while pattern_index != pattern_len and c == '*':\n                c = pattern[pattern_index]\n                pattern_index += 1\n            if pattern_index == pattern_len:\n                return string.find('/', string_index) == -1\n            elif c == '/':\n                string_index = string.find('/', string_index)\n                if string_index == -1:\n                    return False\n                else:\n                    string_index += 1\n            while string_index != string_len:\n                if glob_match(string[string_index:], pattern[pattern_index:]):\n                    return True\n                if string[string_index] == '/':\n                    break\n                string_index += 1\n            continue\n        if c == '[':\n            if string_index == string_len:\n                return False\n            if string[string_index] == '/':\n                return False\n            pattern_index = range_match(pattern, pattern_index, string[string_index])\n            if pattern_index == -1:\n                return False\n            string_index += 1\n            continue\n        if c == '\\\\':\n            if pattern_index == pattern_len:\n                c = '\\\\'\n            else:\n                c = pattern[pattern_index]\n                pattern_index += 1\n        if string_index == string_len:\n            return False\n        elif c == string[string_index]:\n            string_index += 1\n        else:\n            return False",
        "docstring": "Determines whether the given string matches the specified glob pattern. The glob pattern can include wildcards, specifically `?` (which matches any single character except '/') and `*` (which matches zero or more characters). \n\nParameters:\n- string (str): The string to be matched against the pattern.\n- pattern (str): The glob pattern against which the string is tested.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nThis function utilizes a recursive approach to handle complex pattern matching scenarios, particularly for sections of the string defined by the glob syntax. It does not use any external constants, instead, it operates solely based on the input parameters.",
        "signature": "def glob_match(string, pattern):",
        "type": "Function",
        "class_signature": null
      },
      "glob_match_func": {
        "code": "def glob_match_func(*args):\n    \"\"\"Wraps the `glob_match` function to determine if a given string matches a specified glob pattern.\n\nParameters:\n- *args: A variable number of arguments where:\n  - args[0] (str): The string to evaluate against the pattern.\n  - args[1] (str): The glob pattern to match the string against.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nDependencies:\n- This function relies on the `glob_match` function for the actual matching logic. The `glob_match` function implements the matching rules for glob expressions, such as handling wildcards and character ranges.\"\"\"\n    'the wrapper for globMatch.'\n    string = args[0]\n    pattern = args[1]\n    return glob_match(string, pattern)",
        "docstring": "Wraps the `glob_match` function to determine if a given string matches a specified glob pattern.\n\nParameters:\n- *args: A variable number of arguments where:\n  - args[0] (str): The string to evaluate against the pattern.\n  - args[1] (str): The glob pattern to match the string against.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nDependencies:\n- This function relies on the `glob_match` function for the actual matching logic. The `glob_match` function implements the matching rules for glob expressions, such as handling wildcards and character ranges.",
        "signature": "def glob_match_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "ip_match": {
        "code": "def ip_match(ip1, ip2):\n    \"\"\"Determines whether the IP address `ip1` matches the pattern of IP address `ip2`, where `ip2` can represent either a singular IP address or a CIDR notation. The function converts `ip1` to an `ip_address` object and attempts to create an `ip_network` object from `ip2`. If `ip2` is valid and of CIDR format, it checks if `ip1` is within that network; otherwise, it checks for a direct equality between `ip1` and `ip2`.\n\nParameters:\n- ip1 (str): The IP address to check, expected in standard IP format (e.g., \"192.168.2.123\").\n- ip2 (str): The pattern to match against, either a specific IP address or a CIDR pattern (e.g., \"192.168.2.0/24\").\n\nReturns:\n- bool: True if `ip1` matches the pattern specified by `ip2`, else False.\n\nDependencies:\n- `ipaddress`: This module is utilized for creating IP address and network objects and is essential for conducting address comparisons.\"\"\"\n    'IPMatch determines whether IP address ip1 matches the pattern of IP address ip2, ip2 can be an IP address or a CIDR pattern.\\n    For example, \"192.168.2.123\" matches \"192.168.2.0/24\"\\n    '\n    ip1 = ipaddress.ip_address(ip1)\n    try:\n        network = ipaddress.ip_network(ip2, strict=False)\n        return ip1 in network\n    except ValueError:\n        return ip1 == ip2",
        "docstring": "Determines whether the IP address `ip1` matches the pattern of IP address `ip2`, where `ip2` can represent either a singular IP address or a CIDR notation. The function converts `ip1` to an `ip_address` object and attempts to create an `ip_network` object from `ip2`. If `ip2` is valid and of CIDR format, it checks if `ip1` is within that network; otherwise, it checks for a direct equality between `ip1` and `ip2`.\n\nParameters:\n- ip1 (str): The IP address to check, expected in standard IP format (e.g., \"192.168.2.123\").\n- ip2 (str): The pattern to match against, either a specific IP address or a CIDR pattern (e.g., \"192.168.2.0/24\").\n\nReturns:\n- bool: True if `ip1` matches the pattern specified by `ip2`, else False.\n\nDependencies:\n- `ipaddress`: This module is utilized for creating IP address and network objects and is essential for conducting address comparisons.",
        "signature": "def ip_match(ip1, ip2):",
        "type": "Function",
        "class_signature": null
      },
      "ip_match_func": {
        "code": "def ip_match_func(*args):\n    \"\"\"Wraps the ip_match function to determine if a given IP address matches a specified pattern or CIDR notation. \n\nParameters:\n- ip1 (str): The first IP address to check.\n- ip2 (str): The second IP address or CIDR pattern to match against.\n\nReturns:\n- bool: True if ip1 matches ip2, otherwise False.\n\nThis function utilizes the ip_match function defined in the same module, which handles the actual matching logic using Python's ipaddress library. It expects the provided IP addresses to be valid strings.\"\"\"\n    'the wrapper for IPMatch.'\n    ip1 = args[0]\n    ip2 = args[1]\n    return ip_match(ip1, ip2)",
        "docstring": "Wraps the ip_match function to determine if a given IP address matches a specified pattern or CIDR notation. \n\nParameters:\n- ip1 (str): The first IP address to check.\n- ip2 (str): The second IP address or CIDR pattern to match against.\n\nReturns:\n- bool: True if ip1 matches ip2, otherwise False.\n\nThis function utilizes the ip_match function defined in the same module, which handles the actual matching logic using Python's ipaddress library. It expects the provided IP addresses to be valid strings.",
        "signature": "def ip_match_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "time_match_func": {
        "code": "def time_match_func(*args):\n    \"\"\"Checks if the current time falls within a specified time range. The function requires two arguments representing the start and end times in the format 'YYYY-MM-DD HH:MM:SS'. If either argument is the string \"_\", it is treated as an open boundary. Returns True if the current time is greater than the start time (if provided) and less than the end time (if provided); otherwise, returns False. Raises a RuntimeError if the number of arguments is not exactly two or if an invalid date format is encountered. The function uses the `datetime` module, specifically `datetime.now()` for fetching the current time and `datetime.strptime()` for parsing the provided time strings.\"\"\"\n    'the wrapper for TimeMatch.'\n    if len(args) != 2:\n        raise RuntimeError('time_match requires 2 arguments')\n    start_time, end_time = (args[0], args[1])\n    try:\n        now = datetime.now()\n        if start_time != '_':\n            start = datetime.strptime(start_time, '%Y-%m-%d %H:%M:%S')\n            if not now > start:\n                return False\n        if end_time != '_':\n            end = datetime.strptime(end_time, '%Y-%m-%d %H:%M:%S')\n            if not now < end:\n                return False\n        return True\n    except Exception as e:\n        raise RuntimeError(e)",
        "docstring": "Checks if the current time falls within a specified time range. The function requires two arguments representing the start and end times in the format 'YYYY-MM-DD HH:MM:SS'. If either argument is the string \"_\", it is treated as an open boundary. Returns True if the current time is greater than the start time (if provided) and less than the end time (if provided); otherwise, returns False. Raises a RuntimeError if the number of arguments is not exactly two or if an invalid date format is encountered. The function uses the `datetime` module, specifically `datetime.now()` for fetching the current time and `datetime.strptime()` for parsing the provided time strings.",
        "signature": "def time_match_func(*args):",
        "type": "Function",
        "class_signature": null
      },
      "repl": {
        "code": "    def repl(matchobj):\n        \"\"\"repl(matchobj) processes a regex match object to extract a token from the matching string pattern.\n\n    Parameters:\n        matchobj (re.Match): A match object returned from a regular expression match, containing information about the matched string.\n\n    Returns:\n        str: A string pattern \"([^/]+)\" that represents a capturing group matching one or more characters that are not a forward slash (\"/\"). This allows for dynamic matching of variable path segments in route patterns.\n\n    Side Effects:\n        It appends the captured group (the first parenthesis in the regex) to the `tokens` list, which is defined outside this function and used to keep track of variables matched in the corresponding route pattern.\n\n    Dependencies:\n        The function relies on the `tokens` list being defined in the scope where this `repl` function is executed, which is essential for managing the matched variable tokens during regex replacement.\"\"\"\n        tokens.append(matchobj.group(1))\n        return '([^/]+)'",
        "docstring": "repl(matchobj) processes a regex match object to extract a token from the matching string pattern.\n\nParameters:\n    matchobj (re.Match): A match object returned from a regular expression match, containing information about the matched string.\n\nReturns:\n    str: A string pattern \"([^/]+)\" that represents a capturing group matching one or more characters that are not a forward slash (\"/\"). This allows for dynamic matching of variable path segments in route patterns.\n\nSide Effects:\n    It appends the captured group (the first parenthesis in the regex) to the `tokens` list, which is defined outside this function and used to keep track of variables matched in the corresponding route pattern.\n\nDependencies:\n    The function relies on the `tokens` list being defined in the scope where this `repl` function is executed, which is essential for managing the matched variable tokens during regex replacement.",
        "signature": "def repl(matchobj):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "casbin/util/builtin_operators.py:glob_match_func": {},
    "casbin/util/builtin_operators.py:glob_match": {},
    "casbin/util/builtin_operators.py:ip_match_func": {},
    "casbin/util/builtin_operators.py:ip_match": {},
    "casbin/util/builtin_operators.py:key_match_func": {},
    "casbin/util/builtin_operators.py:key_match": {},
    "casbin/util/builtin_operators.py:key_match2_func": {},
    "casbin/util/builtin_operators.py:key_match2": {},
    "casbin/util/builtin_operators.py:key_match3_func": {},
    "casbin/util/builtin_operators.py:key_match3": {},
    "casbin/util/builtin_operators.py:key_match4_func": {},
    "casbin/util/builtin_operators.py:key_match4": {},
    "casbin/util/builtin_operators.py:key_match5_func": {},
    "casbin/util/builtin_operators.py:key_match5": {},
    "casbin/util/builtin_operators.py:regex_match_func": {},
    "casbin/util/builtin_operators.py:regex_match": {}
  },
  "call_tree": {
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_glob_match": {
      "casbin/util/builtin_operators.py:glob_match_func": {
        "casbin/util/builtin_operators.py:glob_match": {
          "casbin/util/builtin_operators.py:glob_match": {
            "[ignored_or_cut_off]": "..."
          },
          "casbin/util/builtin_operators.py:range_match": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_ip_match": {
      "casbin/util/builtin_operators.py:ip_match_func": {
        "casbin/util/builtin_operators.py:ip_match": {}
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_get": {
      "casbin/util/builtin_operators.py:key_get": {}
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_get2": {
      "casbin/util/builtin_operators.py:key_get2": {}
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_get3": {
      "casbin/util/builtin_operators.py:key_get3": {}
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_match": {
      "casbin/util/builtin_operators.py:key_match_func": {
        "casbin/util/builtin_operators.py:key_match": {}
      },
      "casbin/util/builtin_operators.py:key_match2_func": {
        "casbin/util/builtin_operators.py:key_match2": {
          "casbin/util/builtin_operators.py:regex_match": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_match2": {
      "casbin/util/builtin_operators.py:key_match2_func": {
        "casbin/util/builtin_operators.py:key_match2": {
          "casbin/util/builtin_operators.py:regex_match": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_match3": {
      "casbin/util/builtin_operators.py:key_match3_func": {
        "casbin/util/builtin_operators.py:key_match3": {
          "casbin/util/builtin_operators.py:regex_match": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_match4": {
      "casbin/util/builtin_operators.py:key_match4_func": {
        "casbin/util/builtin_operators.py:key_match4": {
          "casbin/util/builtin_operators.py:repl": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_key_match5_func": {
      "casbin/util/builtin_operators.py:key_match5_func": {
        "casbin/util/builtin_operators.py:key_match5": {
          "casbin/util/builtin_operators.py:regex_match": {}
        }
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_regex_match": {
      "casbin/util/builtin_operators.py:regex_match_func": {
        "casbin/util/builtin_operators.py:regex_match": {}
      }
    },
    "tests/util/test_builtin_operators.py:TestBuiltinOperators:test_time_match": {
      "casbin/util/builtin_operators.py:time_match_func": {}
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_builtin_operators\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u2514\u2500\u2500 util/\n        \u2514\u2500\u2500 builtin_operators.py\n            \u251c\u2500\u2500 glob_match\n            \u251c\u2500\u2500 glob_match_func\n            \u251c\u2500\u2500 ip_match\n            \u251c\u2500\u2500 ip_match_func\n            \u251c\u2500\u2500 key_get\n            \u251c\u2500\u2500 key_get2\n            \u251c\u2500\u2500 key_get3\n            \u251c\u2500\u2500 key_match\n            \u251c\u2500\u2500 key_match2\n            \u251c\u2500\u2500 key_match2_func\n            \u251c\u2500\u2500 key_match3\n            \u251c\u2500\u2500 key_match3_func\n            \u251c\u2500\u2500 key_match4\n            \u251c\u2500\u2500 key_match4_func\n            \u251c\u2500\u2500 key_match5\n            \u251c\u2500\u2500 key_match5_func\n            \u251c\u2500\u2500 key_match_func\n            \u251c\u2500\u2500 range_match\n            \u251c\u2500\u2500 regex_match\n            \u251c\u2500\u2500 regex_match_func\n            \u251c\u2500\u2500 repl\n            \u2514\u2500\u2500 time_match_func\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides core functionality for matching and extracting patterns within resource paths, enabling flexible and powerful rule-based access control capabilities in applications. It supports multiple pattern-matching methods, including basic key matching, regular expressions, glob patterns, IP matching, and time-based constraints, among others. This functionality allows developers to define and evaluate resource access policies by comparing requested paths against patterns with dynamic variables, wildcard segments, or specific conditions. By abstracting and simplifying complex path-matching logic, the module streamlines the implementation of access control mechanisms, ensuring maintainability and reducing developer overhead when building robust security layers.\n\n## FILE 1: casbin/util/builtin_operators.py\n\n- FUNCTION NAME: key_get3\n  - SIGNATURE: def key_get3(key1, key2, path_var):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the value matched by a specified pattern in the given key string based on a defined route pattern. \n\nParameters:\n- key1 (str): The key string to match against the pattern (e.g., \"project/proj_project1_admin/\").\n- key2 (str): The pattern string containing variable placeholders (e.g., \"project/proj_{project}_admin/\").\n- path_var (str): The specific variable name to extract from the matched pattern (e.g., \"project\").\n\nReturns:\n- str: The value corresponding to the specified path_var if a match is found; otherwise, returns an empty string.\n\nThis function utilizes the regular expression defined in KEY_MATCH3_PATTERN to construct and match the pattern. The constant KEY_MATCH3_PATTERN is a compiled regex pattern that assists in transforming placeholder patterns into matchable regex patterns.\n\"\"\"\n```\n\n- FUNCTION NAME: key_match5\n  - SIGNATURE: def key_match5(key1: str, key2: str) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the given key1 matches the pattern specified by key2, which may include wildcard characters (*). This function essentially checks if key1 adheres to the routing patterns analogous to RESTful paths, while also accommodating optional query parameters.\n\nParameters:\n- key1 (str): The string to check against the pattern (e.g., a URL).\n- key2 (str): The pattern against which key1 is compared, which may include wildcards.\n\nReturns:\n- bool: True if key1 matches the pattern described by key2; otherwise, False.\n\nThis function interacts with the constant KEY_MATCH5_PATTERN, a compiled regular expression that is used to facilitate matching of path segments within key2. The function employs regex_match to execute the final comparison, ensuring the formatted key1 string aligns with the modified version of key2.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match5_func\n    - casbin/util/builtin_operators.py:regex_match\n\n- FUNCTION NAME: key_match3\n  - SIGNATURE: def key_match3(key1, key2):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the `key1` matches the pattern specified by `key2`, which can contain wildcards like `*`. This is useful for matching RESTful paths, where `key2` may define variable parts of the path using `{}` syntax. \n\nParameters:\n- `key1` (str): The string to be matched against the pattern.\n- `key2` (str): The pattern string which may include wildcards and variable placeholders.\n\nReturns:\n- (bool): Returns `True` if `key1` matches the pattern `key2`, otherwise returns `False`.\n\nDependencies:\n- Utilizes the `regex_match` function to perform the final matching using regular expressions.\n- Modifies `key2` to replace segments as per the `KEY_MATCH3_PATTERN` regex pattern defined globally, allowing it to translate variable placeholders in the pattern to corresponding regex parts.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match3_func\n    - casbin/util/builtin_operators.py:regex_match\n\n- FUNCTION NAME: range_match\n  - SIGNATURE: def range_match(pattern, pattern_index, test):\n  - DOCSTRING: \n```python\n\"\"\"\ncheck the if char `test` in string is match with the scope of [...] in pattern.\n\nParameters:\n- pattern (str): The pattern string that includes a character class (e.g., \"[abc]\") to match against.\n- pattern_index (int): The current position within the pattern string to evaluate.\n- test (str): The character being tested for a match within the specified range.\n\nReturns:\n- int: The updated index of the pattern after processing, or -1 if no match is found.\n\nThis function handles character class matching, including negation (using '!' or '^') and ranges (e.g., '[a-z]'). It interacts with the overall pattern matching functionality provided in the module, particularly within the context of glob or regex matching operations. No external constants are used within this function.\n\"\"\"\n```\n\n- FUNCTION NAME: key_get2\n  - SIGNATURE: def key_get2(key1, key2, path_var):\n  - DOCSTRING: \n```python\n\"\"\"\nkey_get2(key1, key2, path_var) returns the value from key1 that matches the pattern defined in key2. It is commonly used to extract dynamic segments from a path-like string based on the format of key2, where key2 may contain parameterized placeholders denoted by ':' (e.g., '/:resource'). \n\nParameters:\n- key1 (str): The input string to match against key2, often a URL path.\n- key2 (str): The pattern to match key1 against, which may include placeholders for dynamic values.\n- path_var (str): The name of the variable represented in key2, which indicates what value to extract from key1 when a match is found.\n\nReturns:\n- str: The matched value corresponding to the given path_var from key1 if a match is found; otherwise, it returns an empty string.\n\nThis function uses the constant KEY_MATCH2_PATTERN, which is defined at the beginning of the code. This regex pattern is utilized to transform the key2 string by recognizing and replacing placeholder syntax (e.g., ':resource') in the pattern to facilitate a proper match comparison against key1.\n\"\"\"\n```\n\n- FUNCTION NAME: ip_match_func\n  - SIGNATURE: def ip_match_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nWraps the ip_match function to determine if a given IP address matches a specified pattern or CIDR notation. \n\nParameters:\n- ip1 (str): The first IP address to check.\n- ip2 (str): The second IP address or CIDR pattern to match against.\n\nReturns:\n- bool: True if ip1 matches ip2, otherwise False.\n\nThis function utilizes the ip_match function defined in the same module, which handles the actual matching logic using Python's ipaddress library. It expects the provided IP addresses to be valid strings.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:ip_match\n\n- FUNCTION NAME: glob_match\n  - SIGNATURE: def glob_match(string, pattern):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the given string matches the specified glob pattern. The glob pattern can include wildcards, specifically `?` (which matches any single character except '/') and `*` (which matches zero or more characters). \n\nParameters:\n- string (str): The string to be matched against the pattern.\n- pattern (str): The glob pattern against which the string is tested.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nThis function utilizes a recursive approach to handle complex pattern matching scenarios, particularly for sections of the string defined by the glob syntax. It does not use any external constants, instead, it operates solely based on the input parameters.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:glob_match\n    - casbin/util/builtin_operators.py:range_match\n    - casbin/util/builtin_operators.py:glob_match_func\n\n- FUNCTION NAME: key_match4_func\n  - SIGNATURE: def key_match4_func(*args) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nkey_match4_func is a wrapper function for key_match4, designed to determine whether two keys, name1 and name2, match a specified pattern that allows for repeated segments. \n\nParameters:\n- args: A variable-length argument list where:\n  - args[0] (name1): A string representing the first key.\n  - args[1] (name2): A string representing the pattern against which name1 is being matched.\n\nReturns:\n- bool: Returns True if name1 matches the pattern defined by name2 according to the rules of key_match4; otherwise, it returns False.\n\nThis function relies on the key_match4 function, which utilizes regular expressions to match structured paths, including the ability to handle duplicate tokens. No external constants are utilized within this function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match4\n\n- FUNCTION NAME: key_match4\n  - SIGNATURE: def key_match4(key1: str, key2: str) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nkey_match4 determines if one string (key1) matches the pattern of another string (key2) in a RESTful path-like fashion, with support for repeated variable patterns. For instance, it can differentiate between paths with the same variable structure (e.g., \"/parent/123/child/123\" matches \"/parent/{id}/child/{id}\", but \"/parent/123/child/456\" does not). \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string, which can contain wildcards and variable placeholders in braces (e.g., {id}).\n\nReturns:\n- bool: True if key1 matches the pattern specified by key2, otherwise False. If there's an inconsistency in the number of matched tokens, an exception is raised.\n\nThe function utilizes the KEY_MATCH4_PATTERN regular expression pattern to parse and identify variable placeholders. These placeholders are represented in key2, allowing key_match4 to ensure that identical placeholders correspond to identical values in key1.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match4_func\n    - casbin/util/builtin_operators.py:repl\n\n- FUNCTION NAME: key_match2_func\n  - SIGNATURE: def key_match2_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nkey_match2_func is a wrapper function that takes two string arguments, name1 and name2, and determines whether name1 matches the pattern specified by name2 using the key_match2 function. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first string (name1) to be matched.\n  - args[1] (str): The pattern string (name2) that may contain wildcards (e.g., '*').\n\nReturns:\n- bool: Returns True if name1 matches the pattern in name2; otherwise, False.\n\nThis function relies on the key_match2 function, which uses regular expressions, specifically the KEY_MATCH2_PATTERN defined in the context, to perform matching based on flexible patterns akin to RESTful paths. The KEY_MATCH2_PATTERN is a compiled regular expression that aids in the matching logic by substituting parts of the pattern.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match2\n\n- FUNCTION NAME: key_match_func\n  - SIGNATURE: def key_match_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nThe `key_match_func` function serves as a wrapper for the `key_match` function, facilitating the matching of two keys that may represent paths, similar to RESTful API routes. \n\nParameters:\n- `*args`: A variable-length argument list where:\n  - `args[0]` (str): The first key to match (name1).\n  - `args[1]` (str): The second key to match against (name2).\n\nReturns:\n- bool: True if `name1` matches the pattern defined by `name2`, allowing `name2` to contain a wildcard (`*`), otherwise False.\n\nThis function interacts with the `key_match` function, which is responsible for the actual matching logic. It does not use any constants directly.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match\n\n- FUNCTION NAME: regex_match_func\n  - SIGNATURE: def regex_match_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nWrapper function for `regex_match`, which checks if two strings match based on a given regular expression. \n\nParameters:\n- `*args`: A variable length argument list where `args[0]` (name1) is the first string to compare, and `args[1]` (name2) is the regex pattern to match against.\n\nReturns:\n- Returns `True` if `name1` matches the `name2` regex pattern; otherwise, it returns `False`.\n\nThis function relies on the `regex_match` function, which performs the actual matching operation. No constants are defined or used within this function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:regex_match\n\n- FUNCTION NAME: key_match5_func\n  - SIGNATURE: def key_match5_func(*args) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nkey_match5_func is a wrapper function that determines if one string (name1) matches a specified pattern (name2) according to a defined set of matching rules, which can include wildcard indicators. This function accepts two parameters:\n- name1 (str): The string to be matched against the pattern.\n- name2 (str): The pattern to match against, which may include a wildcard (*).\n\nThe function returns a boolean value: True if name1 matches the pattern defined by name2, or False otherwise. This function relies on the key_match5 function for the actual matching logic, which handles both exact matches and those that accommodate wildcards while ignoring query parameters in the input strings. No constants are directly used within this function, but it encapsulates the logic of key_match5, which is defined earlier in the code.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match5\n\n- FUNCTION NAME: key_match\n  - SIGNATURE: def key_match(key1, key2):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether `key1` matches the pattern of `key2`, which can be similar to a RESTful path where `key2` may contain a wildcard character '*'. \n\nParameters:\n- `key1` (str): The input string to be matched against the pattern defined by `key2`.\n- `key2` (str): The pattern string that may include a wildcard indicating variable path segments.\n\nReturns:\n- bool: True if `key1` matches the pattern defined by `key2`, otherwise False.\n\nThis function checks for the presence of the wildcard '*' in `key2`. If '*' is found, it compares the prefix of `key1` up to the position of '*' with the corresponding substring of `key2`. If no '*' is present, it simply checks for direct equality between `key1` and `key2`. This function interacts with the overall key matching logic used in similar functions defined throughout the code, which handle patterns in URLs and paths.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match_func\n\n- FUNCTION NAME: ip_match\n  - SIGNATURE: def ip_match(ip1, ip2):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the IP address `ip1` matches the pattern of IP address `ip2`, where `ip2` can represent either a singular IP address or a CIDR notation. The function converts `ip1` to an `ip_address` object and attempts to create an `ip_network` object from `ip2`. If `ip2` is valid and of CIDR format, it checks if `ip1` is within that network; otherwise, it checks for a direct equality between `ip1` and `ip2`.\n\nParameters:\n- ip1 (str): The IP address to check, expected in standard IP format (e.g., \"192.168.2.123\").\n- ip2 (str): The pattern to match against, either a specific IP address or a CIDR pattern (e.g., \"192.168.2.0/24\").\n\nReturns:\n- bool: True if `ip1` matches the pattern specified by `ip2`, else False.\n\nDependencies:\n- `ipaddress`: This module is utilized for creating IP address and network objects and is essential for conducting address comparisons.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:ip_match_func\n\n- FUNCTION NAME: key_get\n  - SIGNATURE: def key_get(key1, key2):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the portion of key1 that follows the matching segment defined by key2, which may contain a wildcard '*'. \n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which can contain a wildcard ('*') indicating that any segment can match in that position.\n\nReturns:\n- str: The substring of key1 that follows the matched portion, or an empty string if key1 does not match the pattern defined by key2.\n\nThe function relies on the position of the wildcard '*' in key2 to determine the matching criteria. If no wildcard is found, it returns an empty string. If a match is found, it checks if the initial segments of key1 and key2 are the same up until the wildcard and returns the unmatched part of key1 that comes after this match.\n\"\"\"\n```\n\n- FUNCTION NAME: time_match_func\n  - SIGNATURE: def time_match_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the current time falls within a specified time range. The function requires two arguments representing the start and end times in the format 'YYYY-MM-DD HH:MM:SS'. If either argument is the string \"_\", it is treated as an open boundary. Returns True if the current time is greater than the start time (if provided) and less than the end time (if provided); otherwise, returns False. Raises a RuntimeError if the number of arguments is not exactly two or if an invalid date format is encountered. The function uses the `datetime` module, specifically `datetime.now()` for fetching the current time and `datetime.strptime()` for parsing the provided time strings.\n\"\"\"\n```\n\n- FUNCTION NAME: regex_match\n  - SIGNATURE: def regex_match(key1, key2):\n  - DOCSTRING: \n```python\n\"\"\"\ndetermines whether `key1` matches the pattern of `key2` using regular expressions.\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The regular expression pattern that `key1` is tested against.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, otherwise False.\n\nThis function utilizes the `re` module for regular expression matching. It is used within various key matching functions, such as `key_match2`, `key_match3`, `key_match4`, and `key_match5`, to validate if a specific string structure adheres to defined patterns within those contexts.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:regex_match_func\n\n- FUNCTION NAME: key_match3_func\n  - SIGNATURE: def key_match3_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nkey_match3_func is a wrapper function for the key_match3 function, determining whether the first key (name1) matches the pattern of the second key (name2) using a RESTful path-like matching approach. \n\nParameters:\n- *args: A variable length argument list where:\n  - args[0] (str): The first key (name1) to be matched.\n  - args[1] (str): The second key (name2), which may contain special patterns such as \"*\".\n\nReturns:\n- bool: True if name1 matches the pattern specified by name2; otherwise, False.\n\nThis function relies on the key_match3 function, which uses patterns defined by the KEY_MATCH3_PATTERN constant (a regular expression) to perform the matching. If name2 contains variable segments defined by curly braces (e.g., \"{resource}\"), key_match3 will facilitate matching against these patterns.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match3\n\n- FUNCTION NAME: glob_match_func\n  - SIGNATURE: def glob_match_func(*args):\n  - DOCSTRING: \n```python\n\"\"\"\nWraps the `glob_match` function to determine if a given string matches a specified glob pattern.\n\nParameters:\n- *args: A variable number of arguments where:\n  - args[0] (str): The string to evaluate against the pattern.\n  - args[1] (str): The glob pattern to match the string against.\n\nReturns:\n- bool: True if the string matches the pattern, False otherwise.\n\nDependencies:\n- This function relies on the `glob_match` function for the actual matching logic. The `glob_match` function implements the matching rules for glob expressions, such as handling wildcards and character ranges.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:glob_match\n\n- FUNCTION NAME: repl\n  - SIGNATURE: def repl(matchobj):\n  - DOCSTRING: \n```python\n\"\"\"\nrepl(matchobj) processes a regex match object to extract a token from the matching string pattern.\n\nParameters:\n    matchobj (re.Match): A match object returned from a regular expression match, containing information about the matched string.\n\nReturns:\n    str: A string pattern \"([^/]+)\" that represents a capturing group matching one or more characters that are not a forward slash (\"/\"). This allows for dynamic matching of variable path segments in route patterns.\n\nSide Effects:\n    It appends the captured group (the first parenthesis in the regex) to the `tokens` list, which is defined outside this function and used to keep track of variables matched in the corresponding route pattern.\n\nDependencies:\n    The function relies on the `tokens` list being defined in the scope where this `repl` function is executed, which is essential for managing the matched variable tokens during regex replacement.\n\"\"\"\n```\n\n- FUNCTION NAME: key_match2\n  - SIGNATURE: def key_match2(key1, key2):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether `key1` matches the pattern of `key2`, which can contain wildcard characters (specifically '*'). It is useful for matching paths in a RESTful context. For example, \"/foo/bar\" will match the pattern \"/foo/*\", and \"/resource1\" will match \"/:resource\".\n\nParameters:\n- key1 (str): The string to be matched against the pattern.\n- key2 (str): The pattern string which may contain wildcards.\n\nReturns:\n- bool: True if `key1` matches the pattern specified by `key2`, False otherwise.\n\nDependencies:\n- Uses the `KEY_MATCH2_PATTERN` regular expression to replace segments in `key2` with a regex equivalent that captures variable path segments.\n- Utilizes the `regex_match` function to perform the final matching against the compiled regular expression pattern.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - casbin/util/builtin_operators.py:key_match2_func\n    - casbin/util/builtin_operators.py:regex_match\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/util/builtin_operators.py": "import ipaddress\nimport re\nfrom datetime import datetime\nKEY_MATCH2_PATTERN = re.compile('(.*?):[^\\\\/]+(.*?)')\nKEY_MATCH3_PATTERN = re.compile('(.*?){[^\\\\/]+?}(.*?)')\nKEY_MATCH4_PATTERN = re.compile('{([^/]+)}')\nKEY_MATCH5_PATTERN = re.compile('{[^/]+}')\n\ndef generate_g_function(rm):\n    \"\"\"the factory method of the g(_, _) function.\"\"\"\n\n    def f(*args):\n        name1 = args[0]\n        name2 = args[1]\n        if not rm:\n            return name1 == name2\n        elif 2 == len(args):\n            return rm.has_link(name1, name2)\n        else:\n            domain = str(args[2])\n            return rm.has_link(name1, name2, domain)\n    return f\n\ndef generate_conditional_g_function(crm):\n    \"\"\"the factory method of the g(_, _[, _]) function with conditions.\"\"\"\n\n    def conditional_g_function(*args):\n        name1, name2 = (args[0], args[1])\n        if crm is None:\n            has_link = name1 == name2\n        elif len(args) == 2:\n            has_link = crm.has_link(name1, name2)\n        else:\n            domain = str(args[2])\n            has_link = crm.has_link(name1, name2, domain)\n        return has_link\n    return conditional_g_function"
  }
}