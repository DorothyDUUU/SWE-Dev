{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_type_union",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_type_union.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion\n\n\nclass TestTypeLiteral:\n    def setup_method(self) -> None:\n        self.result = TypeUnion(name=\"Test\", children=(Type.str, Type.Any))\n\n    def test_init(self) -> None:\n        assert self.result.children == [Type.str, Type.Any]\n        assert hash(self.result)\n        assert self.result.name == \"Test\"\n        with pytest.raises(TypeAnnotationError):\n            TypeUnion([])\n        with pytest.raises(TypeAnnotationError):\n            TypeUnion([Type.str])\n\n    def test_get_sort_key(self) -> None:\n        assert self.result.get_sort_key() == \"Test\"\n\n    def test_render(self) -> None:\n        assert self.result.render() == \"Test\"\n\n    def test_get_import_records(self) -> None:\n        import_records = sorted(self.result.get_import_records())\n        assert len(import_records) == 1\n        assert import_records[0].render() == \"from .type_defs import Test\"\n\n    def test_get_definition_import_records(self) -> None:\n        import_records = sorted(self.result.get_definition_import_records())\n        assert len(import_records) == 2\n        assert import_records[0].render() == \"from typing import Any\"\n        assert import_records[1].render() == \"from typing import Union\"\n\n    def test_add_child(self) -> None:\n        clone = self.result.copy()\n        clone.add_child(Type.bool)\n        clone.add_child(Type.str)\n        assert set(clone.children) == {Type.str, Type.Any, Type.bool}\n\n    def test_is_type(self) -> None:\n        assert not self.result.is_dict()\n        assert not self.result.is_list()\n\n    def test_copy(self) -> None:\n        assert self.result.copy().children == self.result.children\n\n    def test_render_definition(self) -> None:\n        result = self.result.copy()\n        assert result.render_definition() == \"Test = Union[str, Any]\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/type_subscript.py": "\"\"\"\nWrapper for subscript type annotations, like `List[str]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\n\n\nclass TypeSubscript(TypeParent):\n    \"\"\"\n    Wrapper for subscript type annotations, like `List[str]`.\n\n    Arguments:\n        parent -- Parent type annotation.\n        children -- Children type annotations.\n        stringify -- Convert type annotation to string.\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: FakeAnnotation,\n        children: Iterable[FakeAnnotation] = (),\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        result = self.parent.render()\n        if self.children:\n            children = \", \".join([i.render() for i in self.children])\n            result = f\"{result}[{children}]\"\n\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        yield from self.parent.iterate_types()\n        for child in self.children:\n            yield from child.iterate_types()\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Add new child to Substcript.\n        \"\"\"\n        self.children.append(child)\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether subscript parent is Dict.\n        \"\"\"\n        return self.parent.is_dict()\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether subscript parent is List.\n        \"\"\"\n        return self.parent.is_list()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            parent=self.parent,\n            children=list(self.children),\n            stringify=self._stringify,\n        )\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        for child in self.children:\n            result.extend(child.get_local_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        yield from self.children\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        if child not in self.children:\n            raise TypeAnnotationError(f\"Child not found: {child}\")\n\n        index = self.children.index(child)\n        self.children[index] = new_child\n        return self\n\n    def iterate_children(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children.\n        \"\"\"\n        yield from self.children\n",
    "mypy_boto3_builder/type_annotations/type_union.py": "\"\"\"\nWrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeUnion(TypeSubscript, TypeDefSortable):\n    \"\"\"\n    Wrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n    \"\"\"\n\n    _MIN_CHILDREN: Final = 2\n\n    def __init__(\n        self,\n        children: Iterable[FakeAnnotation],\n        name: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.parent = Type.Union\n        self.children: list[FakeAnnotation] = list(children)\n        if len(self.children) < self._MIN_CHILDREN:\n            raise TypeAnnotationError(f\"Union must have at least {self._MIN_CHILDREN} children\")\n        self._stringify = stringify\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether Union usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render Union usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if not self.is_named():\n            return super().render()\n\n        result = self.name\n\n        if self._stringify:\n            result = f'\"{result}\"'\n\n        return result\n\n    def is_named(self) -> bool:\n        \"\"\"\n        Check if type annotation is a named type annotation.\n        \"\"\"\n        return bool(self.name)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            children=list(self.children),\n            name=self.name,\n            stringify=self._stringify,\n        )\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def get_children_literals(self, processed: Iterable[str] = ()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Union.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return self._get_import_records()\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        if self.is_named():\n            yield self\n            return\n\n        yield from super().iterate_types()\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return self.is_named()\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child for child in self.children if child.get_local_types()]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        if self.is_named():\n            return render_jinja2_template(Path(\"common/named_union.py.jinja2\"), {\"type_def\": self})\n\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/type_subscript.py": {
      "TypeSubscript.add_child": {
        "code": "    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"Add a new child type annotation to the TypeSubscript.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added. This should be an instance of the FakeAnnotation class, which represents type annotations that can be processed further by the class.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    The provided child is appended to the internal list of children annotations, allowing the TypeSubscript to manage multiple nested type annotations effectively.\n\nThis method interacts with the `children` attribute, which is a list of `FakeAnnotation` instances, and modifies it by appending the new child.\"\"\"\n        '\\n        Add new child to Substcript.\\n        '\n        self.children.append(child)",
        "docstring": "Add a new child type annotation to the TypeSubscript.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added. This should be an instance of the FakeAnnotation class, which represents type annotations that can be processed further by the class.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    The provided child is appended to the internal list of children annotations, allowing the TypeSubscript to manage multiple nested type annotations effectively.\n\nThis method interacts with the `children` attribute, which is a list of `FakeAnnotation` instances, and modifies it by appending the new child.",
        "signature": "def add_child(self, child: FakeAnnotation) -> None:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      },
      "TypeSubscript.is_dict": {
        "code": "    def is_dict(self) -> bool:\n        \"\"\"Check if the parent type annotation of the TypeSubscript instance is a dictionary.\n\nReturns:\n    bool: True if the parent type annotation represents a dictionary (Dict), otherwise False.\n\nThis method calls the `is_dict` method on the `parent` attribute, which is an instance of the `FakeAnnotation` class, indicating the type of container being wrapped by TypeSubscript. If the parent type is a dictionary (e.g., Dict[key_type, value_type]), the method returns True; otherwise, it returns False.\"\"\"\n        '\\n        Whether subscript parent is Dict.\\n        '\n        return self.parent.is_dict()",
        "docstring": "Check if the parent type annotation of the TypeSubscript instance is a dictionary.\n\nReturns:\n    bool: True if the parent type annotation represents a dictionary (Dict), otherwise False.\n\nThis method calls the `is_dict` method on the `parent` attribute, which is an instance of the `FakeAnnotation` class, indicating the type of container being wrapped by TypeSubscript. If the parent type is a dictionary (e.g., Dict[key_type, value_type]), the method returns True; otherwise, it returns False.",
        "signature": "def is_dict(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      },
      "TypeSubscript.is_list": {
        "code": "    def is_list(self) -> bool:\n        \"\"\"Determine if the parent type of the subscript is of type `List`.\n\nThis method checks the parent type annotation wrapped by the `TypeSubscript` instance to see if it indicates a list type. It internally calls the `is_list` method of the `parent`, which is expected to be an instance of `FakeAnnotation`, to perform this check.\n\nReturns:\n    bool: `True` if the parent type is a list, `False` otherwise.\n\nDependencies:\n    - `self.parent`: An instance of `FakeAnnotation` that represents the parent type annotation.\n    - `self.parent.is_list()`: Method that checks if the parent type annotation is of a list type.\"\"\"\n        '\\n        Whether subscript parent is List.\\n        '\n        return self.parent.is_list()",
        "docstring": "Determine if the parent type of the subscript is of type `List`.\n\nThis method checks the parent type annotation wrapped by the `TypeSubscript` instance to see if it indicates a list type. It internally calls the `is_list` method of the `parent`, which is expected to be an instance of `FakeAnnotation`, to perform this check.\n\nReturns:\n    bool: `True` if the parent type is a list, `False` otherwise.\n\nDependencies:\n    - `self.parent`: An instance of `FakeAnnotation` that represents the parent type annotation.\n    - `self.parent.is_list()`: Method that checks if the parent type annotation is of a list type.",
        "signature": "def is_list(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py": {
      "TypeUnion.__init__": {
        "code": "    def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:\n        \"\"\"Initializes a TypeUnion instance, which wraps a union type annotation composed of multiple children annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable of child type annotations that the union will contain. This should have at least \n  _MIN_CHILDREN number of elements to be valid.\n- name (str, optional): An optional name for the union type. Defaults to an empty string.\n- stringify (bool, optional): A boolean flag indicating whether to render the union type as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of children is less than _MIN_CHILDREN, indicating that a valid union type cannot be created.\n\nAttributes:\n- name (str): Stores the name of the union type.\n- parent (Type): Indicates that the parent type is a Union.\n- children (list[FakeAnnotation]): Holds the list of child annotations for the union.\n- _stringify (bool): Stores the flag determining whether to stringify the union type during rendering.\n\nConstants:\n- _MIN_CHILDREN (Final): Defines the minimum number of child annotations required to form a valid union. It is set to 2.\"\"\"\n        self.name = name\n        self.parent = Type.Union\n        self.children: list[FakeAnnotation] = list(children)\n        if len(self.children) < self._MIN_CHILDREN:\n            raise TypeAnnotationError(f'Union must have at least {self._MIN_CHILDREN} children')\n        self._stringify = stringify",
        "docstring": "Initializes a TypeUnion instance, which wraps a union type annotation composed of multiple children annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable of child type annotations that the union will contain. This should have at least \n  _MIN_CHILDREN number of elements to be valid.\n- name (str, optional): An optional name for the union type. Defaults to an empty string.\n- stringify (bool, optional): A boolean flag indicating whether to render the union type as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of children is less than _MIN_CHILDREN, indicating that a valid union type cannot be created.\n\nAttributes:\n- name (str): Stores the name of the union type.\n- parent (Type): Indicates that the parent type is a Union.\n- children (list[FakeAnnotation]): Holds the list of child annotations for the union.\n- _stringify (bool): Stores the flag determining whether to stringify the union type during rendering.\n\nConstants:\n- _MIN_CHILDREN (Final): Defines the minimum number of child annotations required to form a valid union. It is set to 2.",
        "signature": "def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render a type annotation to a valid Python code representation for local usage.\n\nThis method checks whether the Union type is named or not. If it is not named, it delegates the rendering to the superclass's render method. If the Union is named, it returns the name of the type, optionally enclosed in double quotes if the `_stringify` attribute is set to `True`. The `_stringify` attribute determines whether the name should be treated as a string, which can affect how it is displayed.\n\nReturns:\n    str: A string representation of the type annotation. If the type is named, it returns the name (optionally stringified); otherwise, it returns the rendered output from the superclass.\n\nDependencies:\n- Uses the `is_named()` method to check the type annotation's naming status.\n- Relies on `super().render()` for rendering if the type is not named.\n- The `_stringify` attribute is defined during initialization and may alter the output format.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if not self.is_named():\n            return super().render()\n        result = self.name\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result",
        "docstring": "Render a type annotation to a valid Python code representation for local usage.\n\nThis method checks whether the Union type is named or not. If it is not named, it delegates the rendering to the superclass's render method. If the Union is named, it returns the name of the type, optionally enclosed in double quotes if the `_stringify` attribute is set to `True`. The `_stringify` attribute determines whether the name should be treated as a string, which can affect how it is displayed.\n\nReturns:\n    str: A string representation of the type annotation. If the type is named, it returns the name (optionally stringified); otherwise, it returns the rendered output from the superclass.\n\nDependencies:\n- Uses the `is_named()` method to check the type annotation's naming status.\n- Relies on `super().render()` for rendering if the type is not named.\n- The `_stringify` attribute is defined during initialization and may alter the output format.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.get_definition_import_records": {
        "code": "    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get all required import records for using the Union type annotation.\n\nThis method aggregates import records needed for the Union type by first\ngathering records from its parent class and then collecting import records\nfrom each child type annotation within the Union. It returns a set of \nImportRecord objects that denote the required imports for proper usage.\n\nReturns:\n    set[ImportRecord]: A set of ImportRecord instances necessary for \n    utilizing the defined Union type correctly.\n\nDependencies:\n- Uses `self.parent.get_import_records()` to collect records from the parent class.\n- Iterates through `self.children` to obtain import records from each child type \n  annotation, ensuring all components of the Union are accounted for.\"\"\"\n        '\\n        Get import record required for using Union.\\n        '\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result",
        "docstring": "Get all required import records for using the Union type annotation.\n\nThis method aggregates import records needed for the Union type by first\ngathering records from its parent class and then collecting import records\nfrom each child type annotation within the Union. It returns a set of \nImportRecord objects that denote the required imports for proper usage.\n\nReturns:\n    set[ImportRecord]: A set of ImportRecord instances necessary for \n    utilizing the defined Union type correctly.\n\nDependencies:\n- Uses `self.parent.get_import_records()` to collect records from the parent class.\n- Iterates through `self.children` to obtain import records from each child type \n  annotation, ensuring all components of the Union are accounted for.",
        "signature": "def get_definition_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get all import records required for using the type annotation represented by this `TypeUnion`.\n\nThis method retrieves the necessary import records, which are important for properly annotating the type in code that utilizes this union. It primarily calls the `_get_import_records` method, which generates a set of `ImportRecord` instances relevant to the union's name and its children. This ensures that any types used in the union are properly imported.\n\nReturns:\n    A set of `ImportRecord` instances required for the type annotation.\n\nDependencies:\n    - `ImportRecord`: An object representing the import record for types.\n    - `InternalImportRecord`: A specific type of `ImportRecord` initialized with `ServiceModuleName.type_defs` and the name of the union, used in `_get_import_records`.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return self._get_import_records()",
        "docstring": "Get all import records required for using the type annotation represented by this `TypeUnion`.\n\nThis method retrieves the necessary import records, which are important for properly annotating the type in code that utilizes this union. It primarily calls the `_get_import_records` method, which generates a set of `ImportRecord` instances relevant to the union's name and its children. This ensures that any types used in the union are properly imported.\n\nReturns:\n    A set of `ImportRecord` instances required for the type annotation.\n\nDependencies:\n    - `ImportRecord`: An object representing the import record for types.\n    - `InternalImportRecord`: A specific type of `ImportRecord` initialized with `ServiceModuleName.type_defs` and the name of the union, used in `_get_import_records`.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.render_definition": {
        "code": "    def render_definition(self) -> str:\n        \"\"\"Render the type annotation definition for a Union type.\n\nThis method checks if the Union type is named using the `is_named()` method. If it is named, it renders the definition by using the `render_jinja2_template` function with a specified Jinja2 template located at \"common/named_union.py.jinja2\", passing the current instance as context. If the Union type is not named, it calls the `render()` method to obtain the string representation of the type annotation.\n\nReturns:\n    str: A string representation of the type annotation definition, either as a rendered template for named types or the result of the `render()` method for unnamed types.\n\nDependencies:\n- `render_jinja2_template`: A function from the `my_boto3_builder.utils.jinja2` module that processes the Jinja2 template.\n- `Path`: The `Path` class from the `pathlib` module is used to specify the template file location.\"\"\"\n        '\\n        Render type annotation definition.\\n        '\n        if self.is_named():\n            return render_jinja2_template(Path('common/named_union.py.jinja2'), {'type_def': self})\n        return self.render()",
        "docstring": "Render the type annotation definition for a Union type.\n\nThis method checks if the Union type is named using the `is_named()` method. If it is named, it renders the definition by using the `render_jinja2_template` function with a specified Jinja2 template located at \"common/named_union.py.jinja2\", passing the current instance as context. If the Union type is not named, it calls the `render()` method to obtain the string representation of the type annotation.\n\nReturns:\n    str: A string representation of the type annotation definition, either as a rendered template for named types or the result of the `render()` method for unnamed types.\n\nDependencies:\n- `render_jinja2_template`: A function from the `my_boto3_builder.utils.jinja2` module that processes the Jinja2 template.\n- `Path`: The `Path` class from the `pathlib` module is used to specify the template file location.",
        "signature": "def render_definition(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the FakeAnnotation instance, which is used to uniquely identify objects in hash-based collections like sets and dictionaries. This method relies on the `get_sort_key()` method to obtain a consistent string representation of the annotation, ensuring that two annotations deemed equal will have the same hash value. No parameters are required, and it returns an integer hash value based on that string. This interaction is crucial for maintaining integrity in data structures that depend on the uniqueness of instances of FakeAnnotation and its subclasses.\"\"\"\n        '\\n        Calculate hash value based on string render.\\n        '\n        return hash(self.get_sort_key())",
        "docstring": "Calculate the hash value for the FakeAnnotation instance, which is used to uniquely identify objects in hash-based collections like sets and dictionaries. This method relies on the `get_sort_key()` method to obtain a consistent string representation of the annotation, ensuring that two annotations deemed equal will have the same hash value. No parameters are required, and it returns an integer hash value based on that string. This interaction is crucial for maintaining integrity in data structures that depend on the uniqueness of instances of FakeAnnotation and its subclasses.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.get_sort_key": {
        "code": "    def get_sort_key(self) -> str:\n        \"\"\"Get a string representation of the annotation to be used as a sorting key.\n\nThis method converts the current instance of the `FakeAnnotation` class to a string using the `str()` function. The returned string is intended for use in comparing and sorting annotations based on their string representations, which are determined by the `__str__` method of the class.\n\nReturns:\n    str: The string representation of the annotation.\n\nThis method does not take any parameters and has no side effects. It relies on the `__str__` method, which should be implemented by subclasses to ensure a meaningful string representation of different annotation types.\"\"\"\n        '\\n        Get string to sort annotations.\\n        '\n        return str(self)",
        "docstring": "Get a string representation of the annotation to be used as a sorting key.\n\nThis method converts the current instance of the `FakeAnnotation` class to a string using the `str()` function. The returned string is intended for use in comparing and sorting annotations based on their string representations, which are determined by the `__str__` method of the class.\n\nReturns:\n    str: The string representation of the annotation.\n\nThis method does not take any parameters and has no side effects. It relies on the `__str__` method, which should be implemented by subclasses to ensure a meaningful string representation of different annotation types.",
        "signature": "def get_sort_key(self) -> str:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a copy of the type annotation wrapper instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to create a shallow copy of the current `FakeAnnotation` instance. It allows for duplication of type annotations without altering the original instance, maintaining the integrity of the type system that the class is designed to represent. \n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a copy of the type annotation wrapper instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to create a shallow copy of the current `FakeAnnotation` instance. It allows for duplication of type annotations without altering the original instance, maintaining the integrity of the type system that the class is designed to represent. \n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get rendered import statement based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a string that represents the import statement for a Python module, formatted according to the values of `source`, `name`, and `alias`. If `name` is present, it generates a \"from ... import ...\" statement; if only `alias` is present, it creates an \"import ... as ...\" statement; otherwise, it defaults to \"import ...\" with just the `source`.\n\nReturns:\n    str: The formatted import statement.\n\nDependencies:\n    - `self.source`: An instance of `ImportString`, which provides the source module or package for the import.\n    - `self.name`: The name of the item being imported, if any.\n    - `self.alias`: The local name that the imported item will be referenced as, if provided.\n\nThe method relies on `self.render_name()` to format the import name correctly, ensuring consistency with potential aliases.\"\"\"\n        '\\n        Get rendered string.\\n        '\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
        "docstring": "Get rendered import statement based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a string that represents the import statement for a Python module, formatted according to the values of `source`, `name`, and `alias`. If `name` is present, it generates a \"from ... import ...\" statement; if only `alias` is present, it creates an \"import ... as ...\" statement; otherwise, it defaults to \"import ...\" with just the `source`.\n\nReturns:\n    str: The formatted import statement.\n\nDependencies:\n    - `self.source`: An instance of `ImportString`, which provides the source module or package for the import.\n    - `self.name`: The name of the item being imported, if any.\n    - `self.alias`: The local name that the imported item will be referenced as, if provided.\n\nThe method relies on `self.render_name()` to format the import name correctly, ensuring consistency with potential aliases.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determine equality between two ImportRecord instances.\n\nArgs:\n    other (object): The object to compare against the current ImportRecord instance. It is expected to be another ImportRecord.\n\nReturns:\n    bool: True if the two ImportRecord instances render to the same import statement string; False otherwise.\n\nNotes:\n    This method relies on the `__str__` method to generate the string representation of the ImportRecord instances, ensuring that two records are considered equal if they produce identical import statements. If the `other` object is not an instance of ImportRecord, the method immediately returns False.\"\"\"\n        '\\n        Whether two import records produce the same render.\\n        '\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)",
        "docstring": "Determine equality between two ImportRecord instances.\n\nArgs:\n    other (object): The object to compare against the current ImportRecord instance. It is expected to be another ImportRecord.\n\nReturns:\n    bool: True if the two ImportRecord instances render to the same import statement string; False otherwise.\n\nNotes:\n    This method relies on the `__str__` method to generate the string representation of the ImportRecord instances, ensuring that two records are considered equal if they produce identical import statements. If the `other` object is not an instance of ImportRecord, the method immediately returns False.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__gt__": {
        "code": "    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"Compare two `ImportRecord` instances for sorting based on specific criteria.\n\nParameters:\n- `self`: The first `ImportRecord` instance being compared.\n- `other`: The second `ImportRecord` instance to compare against.\n\nReturns:\n- `bool`: Returns `True` if `self` is considered greater than `other` based on the following criteria:\n    1. If the minimum versions (`min_version`) of the two records differ, the record with the higher version is greater.\n    2. If one record has a fallback and the other does not, the one with a fallback is considered greater.\n    3. If the sources (`source`) of the two records differ, the one with the lexicographically greater source is considered greater.\n    4. If the names (`name`) of the records differ, the record with the lexicographically greater name is greater.\n\nThis method emulates logic used by `isort`, allowing for a consistent way to sort import records in Python code.\"\"\"\n        '\\n        Compare two import records for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name",
        "docstring": "Compare two `ImportRecord` instances for sorting based on specific criteria.\n\nParameters:\n- `self`: The first `ImportRecord` instance being compared.\n- `other`: The second `ImportRecord` instance to compare against.\n\nReturns:\n- `bool`: Returns `True` if `self` is considered greater than `other` based on the following criteria:\n    1. If the minimum versions (`min_version`) of the two records differ, the record with the higher version is greater.\n    2. If one record has a fallback and the other does not, the one with a fallback is considered greater.\n    3. If the sources (`source`) of the two records differ, the one with the lexicographically greater source is considered greater.\n    4. If the names (`name`) of the records differ, the record with the lexicographically greater name is greater.\n\nThis method emulates logic used by `isort`, allowing for a consistent way to sort import records in Python code.",
        "signature": "def __gt__(self: Self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the instance of the ExternalImport class. The hash is computed using a tuple containing the source module, import name, local alias, and a safety flag, which helps in identifying instances uniquely. This method is important for enabling instances to be used as keys in dictionaries or to be added to sets. It relies on the attributes `source`, `name`, `alias`, and `safe`, which capture the relevant import information for the external type annotations.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate a hash value for the instance of the ExternalImport class. The hash is computed using a tuple containing the source module, import name, local alias, and a safety flag, which helps in identifying instances uniquely. This method is important for enabling instances to be used as keys in dictionaries or to be added to sets. It relies on the attributes `source`, `name`, `alias`, and `safe`, which capture the relevant import information for the external type annotations.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render annotation usage as a valid Python statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render": {
      "mypy_boto3_builder/type_annotations/type_union.py": {
        "TypeUnion.is_named": {
          "code": "    def is_named(self) -> bool:\n        \"\"\"\n        Check if type annotation is a named type annotation.\n        \"\"\"\n        return bool(self.name)",
          "docstring": "Check if type annotation is a named type annotation.",
          "signature": "def is_named(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:get_import_records": {
      "mypy_boto3_builder/type_annotations/type_union.py": {
        "TypeUnion._get_import_records": {
          "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}",
          "docstring": "Get import record required for using type annotation.",
          "signature": "def _get_import_records(self) -> set[ImportRecord]:",
          "type": "Method",
          "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.render_name": {
          "code": "    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name",
          "docstring": "Get rendered import name.",
          "signature": "def render_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render as a part of a valid Python import statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:get_definition_import_records": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation.get_import_records": {
          "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
          "docstring": "Get all import records required for using type annotation.",
          "signature": "def get_import_records(self) -> set[ImportRecord]:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__eq__": {
          "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts",
          "docstring": "Whether import strings produce the same render.",
          "signature": "def __eq__(self, other: object) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render as a valid Python import statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
      "mypy_boto3_builder/type_annotations/type_union.py": {
        "TypeUnion.__copy__": {
          "code": "    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(children=list(self.children), name=self.name, stringify=self._stringify)",
          "docstring": "Create a copy of type annotation wrapper.",
          "signature": "def __copy__(self) -> Self:",
          "type": "Method",
          "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:is_dict": {
      "mypy_boto3_builder/type_annotations/type_annotation.py": {
        "TypeAnnotation.is_dict": {
          "code": "    def is_dict(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain Dict.\n        \"\"\"\n        return self._wrapped_type == \"Dict\"",
          "docstring": "Whether annotation is a plain Dict.",
          "signature": "def is_dict(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeAnnotation(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:is_list": {
      "mypy_boto3_builder/type_annotations/type_annotation.py": {
        "TypeAnnotation.is_list": {
          "code": "    def is_list(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain List.\n        \"\"\"\n        return self._wrapped_type == \"List\"",
          "docstring": "Whether annotation is a plain List.",
          "signature": "def is_list(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeAnnotation(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render_definition": {
      "mypy_boto3_builder/utils/jinja2.py": {
        "render_jinja2_template": {
          "code": "def render_jinja2_template(template_path: Path, context: Mapping[str, Any]) -> str:\n    \"\"\"\n    Render Jinja2 template to a string.\n\n    Arguments:\n        template_path -- Relative path to template in `TEMPLATES_PATH`\n        kwargs -- Render arguments\n\n    Returns:\n        A rendered template.\n    \"\"\"\n    template = JinjaManager.singleton().get_template(template_path)\n    return template.render(context)",
          "docstring": "Render Jinja2 template to a string.\n\nArguments:\n    template_path -- Relative path to template in `TEMPLATES_PATH`\n    kwargs -- Render arguments\n\nReturns:\n    A rendered template.",
          "signature": "def render_jinja2_template(template_path: Path, context: Mapping[str, Any]) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/type_annotations/type_union.py": {
        "TypeUnion.is_named": {
          "code": "    def is_named(self) -> bool:\n        \"\"\"\n        Check if type annotation is a named type annotation.\n        \"\"\"\n        return bool(self.name)",
          "docstring": "Check if type annotation is a named type annotation.",
          "signature": "def is_named(self) -> bool:",
          "type": "Method",
          "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
        }
      }
    }
  },
  "call_tree": {
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:setup_method": {
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_init": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render": {
              "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {}
            }
          }
        }
      },
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_get_sort_key": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render": {
            "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {}
          }
        }
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_render": {
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {}
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_get_import_records": {
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:get_import_records": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:_get_import_records": {
          "mypy_boto3_builder/import_helpers/internal_import_record.py:InternalImportRecord:__init__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_get_definition_import_records": {
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:get_definition_import_records": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
          "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:_get_import_records": {
            "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {},
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
            }
          },
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:_get_import_records": {
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
            }
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
                "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
              },
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
            }
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_add_child": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__copy__": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:add_child": {},
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      },
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
              "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
            }
          }
        }
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_is_type": {
      "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:is_dict": {
        "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:is_dict": {}
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:is_list": {
        "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:is_list": {}
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__copy__": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
        }
      }
    },
    "tests/type_annotations/test_type_union.py:TestTypeLiteral:test_render_definition": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__copy__": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render_definition": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {},
        "mypy_boto3_builder/utils/jinja2.py:render_jinja2_template": {
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:singleton": {
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:__init__": {}
          },
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:get_template": {},
          "mypy_boto3_builder/templates/common/named_union.py.jinja2:root": {
            "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
              "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
            },
            "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:iterate_children": {},
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
              "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
              },
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
            }
          }
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_type_union\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 import_helpers/\n    \u2502   \u2514\u2500\u2500 import_record.py\n    \u2502       \u251c\u2500\u2500 ImportRecord.__eq__\n    \u2502       \u251c\u2500\u2500 ImportRecord.__gt__\n    \u2502       \u2514\u2500\u2500 ImportRecord.render\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u2514\u2500\u2500 ExternalImport.__hash__\n        \u251c\u2500\u2500 fake_annotation.py\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__hash__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.copy\n        \u2502   \u2514\u2500\u2500 FakeAnnotation.get_sort_key\n        \u251c\u2500\u2500 type_subscript.py\n        \u2502   \u251c\u2500\u2500 TypeSubscript.add_child\n        \u2502   \u251c\u2500\u2500 TypeSubscript.is_dict\n        \u2502   \u2514\u2500\u2500 TypeSubscript.is_list\n        \u2514\u2500\u2500 type_union.py\n            \u251c\u2500\u2500 TypeUnion.__init__\n            \u251c\u2500\u2500 TypeUnion.get_definition_import_records\n            \u251c\u2500\u2500 TypeUnion.get_import_records\n            \u251c\u2500\u2500 TypeUnion.render\n            \u2514\u2500\u2500 TypeUnion.render_definition\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to facilitate the creation, validation, and management of type annotations, specifically for union types, in Python projects. It provides capabilities to define complex union types, render their string representations, manage their associated import statements, and validate their integrity according to predefined rules. By offering utilities for creating and manipulating type unions, the module streamlines type annotation workflow, ensuring consistent and reusable type definitions across codebases. This functionality addresses the challenges developers face when handling dynamically composed type definitions, improving maintainability and reducing error-prone manual type handling.\n\n## FILE 1: mypy_boto3_builder/type_annotations/type_subscript.py\n\n- CLASS METHOD: TypeSubscript.is_list\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def is_list(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the parent type of the subscript is of type `List`.\n\nThis method checks the parent type annotation wrapped by the `TypeSubscript` instance to see if it indicates a list type. It internally calls the `is_list` method of the `parent`, which is expected to be an instance of `FakeAnnotation`, to perform this check.\n\nReturns:\n    bool: `True` if the parent type is a list, `False` otherwise.\n\nDependencies:\n    - `self.parent`: An instance of `FakeAnnotation` that represents the parent type annotation.\n    - `self.parent.is_list()`: Method that checks if the parent type annotation is of a list type.\n\"\"\"\n```\n\n- CLASS METHOD: TypeSubscript.add_child\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def add_child(self, child: FakeAnnotation) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a new child type annotation to the TypeSubscript.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added. This should be an instance of the FakeAnnotation class, which represents type annotations that can be processed further by the class.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    The provided child is appended to the internal list of children annotations, allowing the TypeSubscript to manage multiple nested type annotations effectively.\n\nThis method interacts with the `children` attribute, which is a list of `FakeAnnotation` instances, and modifies it by appending the new child.\n\"\"\"\n```\n\n- CLASS METHOD: TypeSubscript.is_dict\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def is_dict(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the parent type annotation of the TypeSubscript instance is a dictionary.\n\nReturns:\n    bool: True if the parent type annotation represents a dictionary (Dict), otherwise False.\n\nThis method calls the `is_dict` method on the `parent` attribute, which is an instance of the `FakeAnnotation` class, indicating the type of container being wrapped by TypeSubscript. If the parent type is a dictionary (e.g., Dict[key_type, value_type]), the method returns True; otherwise, it returns False.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/type_union.py\n\n- CLASS METHOD: TypeUnion.get_definition_import_records\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def get_definition_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet all required import records for using the Union type annotation.\n\nThis method aggregates import records needed for the Union type by first\ngathering records from its parent class and then collecting import records\nfrom each child type annotation within the Union. It returns a set of \nImportRecord objects that denote the required imports for proper usage.\n\nReturns:\n    set[ImportRecord]: A set of ImportRecord instances necessary for \n    utilizing the defined Union type correctly.\n\nDependencies:\n- Uses `self.parent.get_import_records()` to collect records from the parent class.\n- Iterates through `self.children` to obtain import records from each child type \n  annotation, ensuring all components of the Union are accounted for.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.render_definition\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def render_definition(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation definition for a Union type.\n\nThis method checks if the Union type is named using the `is_named()` method. If it is named, it renders the definition by using the `render_jinja2_template` function with a specified Jinja2 template located at \"common/named_union.py.jinja2\", passing the current instance as context. If the Union type is not named, it calls the `render()` method to obtain the string representation of the type annotation.\n\nReturns:\n    str: A string representation of the type annotation definition, either as a rendered template for named types or the result of the `render()` method for unnamed types.\n\nDependencies:\n- `render_jinja2_template`: A function from the `my_boto3_builder.utils.jinja2` module that processes the Jinja2 template.\n- `Path`: The `Path` class from the `pathlib` module is used to specify the template file location.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.get_import_records\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet all import records required for using the type annotation represented by this `TypeUnion`.\n\nThis method retrieves the necessary import records, which are important for properly annotating the type in code that utilizes this union. It primarily calls the `_get_import_records` method, which generates a set of `ImportRecord` instances relevant to the union's name and its children. This ensures that any types used in the union are properly imported.\n\nReturns:\n    A set of `ImportRecord` instances required for the type annotation.\n\nDependencies:\n    - `ImportRecord`: An object representing the import record for types.\n    - `InternalImportRecord`: A specific type of `ImportRecord` initialized with `ServiceModuleName.type_defs` and the name of the union, used in `_get_import_records`.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.__init__\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a TypeUnion instance, which wraps a union type annotation composed of multiple children annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable of child type annotations that the union will contain. This should have at least \n  _MIN_CHILDREN number of elements to be valid.\n- name (str, optional): An optional name for the union type. Defaults to an empty string.\n- stringify (bool, optional): A boolean flag indicating whether to render the union type as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of children is less than _MIN_CHILDREN, indicating that a valid union type cannot be created.\n\nAttributes:\n- name (str): Stores the name of the union type.\n- parent (Type): Indicates that the parent type is a Union.\n- children (list[FakeAnnotation]): Holds the list of child annotations for the union.\n- _stringify (bool): Stores the flag determining whether to stringify the union type during rendering.\n\nConstants:\n- _MIN_CHILDREN (Final): Defines the minimum number of child annotations required to form a valid union. It is set to 2.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.render\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender a type annotation to a valid Python code representation for local usage.\n\nThis method checks whether the Union type is named or not. If it is not named, it delegates the rendering to the superclass's render method. If the Union is named, it returns the name of the type, optionally enclosed in double quotes if the `_stringify` attribute is set to `True`. The `_stringify` attribute determines whether the name should be treated as a string, which can affect how it is displayed.\n\nReturns:\n    str: A string representation of the type annotation. If the type is named, it returns the name (optionally stringified); otherwise, it returns the rendered output from the superclass.\n\nDependencies:\n- Uses the `is_named()` method to check the type annotation's naming status.\n- Relies on `super().render()` for rendering if the type is not named.\n- The `_stringify` attribute is defined during initialization and may alter the output format.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.__hash__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the FakeAnnotation instance, which is used to uniquely identify objects in hash-based collections like sets and dictionaries. This method relies on the `get_sort_key()` method to obtain a consistent string representation of the annotation, ensuring that two annotations deemed equal will have the same hash value. No parameters are required, and it returns an integer hash value based on that string. This interaction is crucial for maintaining integrity in data structures that depend on the uniqueness of instances of FakeAnnotation and its subclasses.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.get_sort_key\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_sort_key(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a string representation of the annotation to be used as a sorting key.\n\nThis method converts the current instance of the `FakeAnnotation` class to a string using the `str()` function. The returned string is intended for use in comparing and sorting annotations based on their string representations, which are determined by the `__str__` method of the class.\n\nReturns:\n    str: The string representation of the annotation.\n\nThis method does not take any parameters and has no side effects. It relies on the `__str__` method, which should be implemented by subclasses to ensure a meaningful string representation of different annotation types.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a copy of the type annotation wrapper instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to create a shallow copy of the current `FakeAnnotation` instance. It allows for duplication of type annotations without altering the original instance, maintaining the integrity of the type system that the class is designed to represent. \n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.__gt__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __gt__(self: Self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two `ImportRecord` instances for sorting based on specific criteria.\n\nParameters:\n- `self`: The first `ImportRecord` instance being compared.\n- `other`: The second `ImportRecord` instance to compare against.\n\nReturns:\n- `bool`: Returns `True` if `self` is considered greater than `other` based on the following criteria:\n    1. If the minimum versions (`min_version`) of the two records differ, the record with the higher version is greater.\n    2. If one record has a fallback and the other does not, the one with a fallback is considered greater.\n    3. If the sources (`source`) of the two records differ, the one with the lexicographically greater source is considered greater.\n    4. If the names (`name`) of the records differ, the record with the lexicographically greater name is greater.\n\nThis method emulates logic used by `isort`, allowing for a consistent way to sort import records in Python code.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.render\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet rendered import statement based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a string that represents the import statement for a Python module, formatted according to the values of `source`, `name`, and `alias`. If `name` is present, it generates a \"from ... import ...\" statement; if only `alias` is present, it creates an \"import ... as ...\" statement; otherwise, it defaults to \"import ...\" with just the `source`.\n\nReturns:\n    str: The formatted import statement.\n\nDependencies:\n    - `self.source`: An instance of `ImportString`, which provides the source module or package for the import.\n    - `self.name`: The name of the item being imported, if any.\n    - `self.alias`: The local name that the imported item will be referenced as, if provided.\n\nThe method relies on `self.render_name()` to format the import name correctly, ensuring consistency with potential aliases.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__eq__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine equality between two ImportRecord instances.\n\nArgs:\n    other (object): The object to compare against the current ImportRecord instance. It is expected to be another ImportRecord.\n\nReturns:\n    bool: True if the two ImportRecord instances render to the same import statement string; False otherwise.\n\nNotes:\n    This method relies on the `__str__` method to generate the string representation of the ImportRecord instances, ensuring that two records are considered equal if they produce identical import statements. If the `other` object is not an instance of ImportRecord, the method immediately returns False.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the instance of the ExternalImport class. The hash is computed using a tuple containing the source module, import name, local alias, and a safety flag, which helps in identifying instances uniquely. This method is important for enabling instances to be used as keys in dictionaries or to be added to sets. It relies on the attributes `source`, `name`, `alias`, and `safe`, which capture the relevant import information for the external type annotations.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/type_subscript.py": "\"\"\"\nWrapper for subscript type annotations, like `List[str]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\n\nclass TypeSubscript(TypeParent):\n    \"\"\"\n    Wrapper for subscript type annotations, like `List[str]`.\n\n    Arguments:\n        parent -- Parent type annotation.\n        children -- Children type annotations.\n        stringify -- Convert type annotation to string.\n    \"\"\"\n\n    def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        result = self.parent.render()\n        if self.children:\n            children = ', '.join([i.render() for i in self.children])\n            result = f'{result}[{children}]'\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        yield from self.parent.iterate_types()\n        for child in self.children:\n            yield from child.iterate_types()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(parent=self.parent, children=list(self.children), stringify=self._stringify)\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        for child in self.children:\n            result.extend(child.get_local_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        yield from self.children\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        if child not in self.children:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        index = self.children.index(child)\n        self.children[index] = new_child\n        return self\n\n    def iterate_children(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children.\n        \"\"\"\n        yield from self.children",
    "mypy_boto3_builder/type_annotations/type_union.py": "\"\"\"\nWrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeUnion(TypeSubscript, TypeDefSortable):\n    \"\"\"\n    Wrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n    \"\"\"\n    _MIN_CHILDREN: Final = 2\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether Union usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render Union usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def is_named(self) -> bool:\n        \"\"\"\n        Check if type annotation is a named type annotation.\n        \"\"\"\n        return bool(self.name)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(children=list(self.children), name=self.name, stringify=self._stringify)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        if self.is_named():\n            yield self\n            return\n        yield from super().iterate_types()\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return self.is_named()\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child for child in self.children if child.get_local_types()]",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe"
  }
}