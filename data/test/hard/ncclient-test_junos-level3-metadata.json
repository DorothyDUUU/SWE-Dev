{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_junos",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_junos.py",
  "test_code": "import unittest\nfrom ncclient.devices.junos import *\nimport ncclient.transport\ntry:\n    from unittest.mock import patch  # Python 3.4 and later\nexcept ImportError:\n    from mock import patch\nimport paramiko\nimport sys\n\nxml = '''<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n        <xsl:output method=\"xml\" indent=\"no\"/>\n\n        <xsl:template match=\"/|comment()|processing-instruction()\">\n            <xsl:copy>\n                <xsl:apply-templates/>\n            </xsl:copy>\n        </xsl:template>\n\n        <xsl:template match=\"*\">\n            <xsl:element name=\"{local-name()}\">\n                <xsl:apply-templates select=\"@*|node()\"/>\n            </xsl:element>\n        </xsl:template>\n\n        <xsl:template match=\"@*\">\n            <xsl:attribute name=\"{local-name()}\">\n                <xsl:value-of select=\".\"/>\n            </xsl:attribute>\n        </xsl:template>\n        </xsl:stylesheet>\n        '''\nxml2 = \"\"\"<rpc-reply xmlns:junos=\"http://xml.juniper.net/junos/12.1X46/junos\">\n<routing-engine>\n<name>reX</name>\n<commit-success/>\n<ok/>\n</rpc-reply>\"\"\"\n\nxml3 = \"\"\"<rpc-reply xmlns:junos=\"http://xml.juniper.net/junos/12.1X46/junos\">\n<routing-engine>\n<name>reX</name>\n<commit-success/>\n<routing-engine/>\n<ok/>\n</rpc-reply>\"\"\"\n\nxml4 = \"\"\"<rpc-reply>\n<operation>commit</operation>\n<name>reX</name>\n<commit-success/>\n<ok/>\n</rpc-reply>\n<rpc-error>\n<message>commit failure</message>\n</rpc-error>\n<hello>greeting!</hello>\"\"\"\n\n\nclass TestJunosDevice(unittest.TestCase):\n\n    def setUp(self):\n        self.obj = JunosDeviceHandler({'name': 'junos'})\n\n    @patch('paramiko.Channel.exec_command')\n    @patch('paramiko.Transport.__init__')\n    @patch('paramiko.Transport.open_channel')\n    def test_handle_connection_exceptions(\n            self, mock_open, mock_init, mock_channel):\n        session = ncclient.transport.SSHSession(self.obj)\n        session._channel_id = 100\n        mock_init.return_value = None\n        session._transport = paramiko.Transport()\n        channel = paramiko.Channel(100)\n        mock_open.return_value = channel\n        self.obj.handle_connection_exceptions(session)\n        self.assertEqual(channel._name, \"netconf-command-100\")\n        self.assertEqual(\n            mock_channel.call_args_list[0][0][0],\n            \"xml-mode netconf need-trailer\")\n\n    def test_additional_operations(self):\n        dict = {}\n        dict[\"rpc\"] = ExecuteRpc\n        dict[\"get_configuration\"] = GetConfiguration\n        dict[\"load_configuration\"] = LoadConfiguration\n        dict[\"compare_configuration\"] = CompareConfiguration\n        dict[\"command\"] = Command\n        dict[\"reboot\"] = Reboot\n        dict[\"halt\"] = Halt\n        dict[\"commit\"] = Commit\n        dict[\"rollback\"] = Rollback\n        self.assertEqual(dict, self.obj.add_additional_operations())\n\n    def test_transform_reply(self):\n        if sys.version >= '3':\n            reply = xml.encode('utf-8')\n        else:\n            reply = xml\n        self.assertEqual(self.obj.transform_reply(), reply)\n\n    def test_perform_quality_check(self):\n        self.assertFalse(self.obj.perform_qualify_check())\n\n    def test_handle_raw_dispatch(self):\n        self.assertFalse(self.obj.handle_raw_dispatch(xml))\n\n        expected = re.sub(r'<ok/>', '</routing-engine>\\n<ok/>', xml3)\n        self.assertEqual(expected, self.obj.handle_raw_dispatch(xml3))\n\n        expected = 'undefined: not an error message in the reply. Enable debug'\n        self.assertEqual(expected, str(self.obj.handle_raw_dispatch(xml4)))\n",
  "GT_file_code": {
    "ncclient/operations/rpc.py": "# Copyright 2009 Shikhar Bhushan\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import Event, Lock\nfrom uuid import uuid4\n\nfrom ncclient.xml_ import *\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport import SessionListener\nfrom ncclient.operations import util\nfrom ncclient.operations.errors import OperationError, TimeoutExpiredError, MissingCapabilityError\n\nimport logging\nlogger = logging.getLogger(\"ncclient.operations.rpc\")\n\n\nclass RPCError(OperationError):\n\n    \"Represents an `rpc-error`. It is a type of :exc:`OperationError` and can be raised as such.\"\n\n    tag_to_attr = {\n        qualify(\"error-type\"): \"_type\",\n        qualify(\"error-tag\"): \"_tag\",\n        qualify(\"error-app-tag\"): \"_app_tag\",\n        qualify(\"error-severity\"): \"_severity\",\n        qualify(\"error-info\"): \"_info\",\n        qualify(\"error-path\"): \"_path\",\n        qualify(\"error-message\"): \"_message\"\n    }\n\n    def __init__(self, raw, errs=None):\n        self._raw = raw\n        if errs is None:\n            # Single RPCError\n            self._errlist = None\n            for attr in six.itervalues(RPCError.tag_to_attr):\n                setattr(self, attr, None)\n            for subele in raw:\n                attr = RPCError.tag_to_attr.get(subele.tag, None)\n                if attr is not None:\n                    setattr(self, attr, subele.text if attr != \"_info\" else to_xml(subele) )\n            if self.message is not None:\n                OperationError.__init__(self, self.message)\n            else:\n                OperationError.__init__(self, self.to_dict())\n        else:\n            # Multiple errors returned. Errors is a list of RPCError objs\n            self._errlist = errs\n            errlist = []\n            for err in errs:\n                if err.severity:\n                    errsev = err.severity\n                else:\n                    errsev = 'undefined'\n                if err.message:\n                    errmsg = err.message\n                else:\n                    errmsg = 'not an error message in the reply. Enable debug'\n                errordict = {\"severity\": errsev, \"message\":errmsg}\n                errlist.append(errordict)\n            # We are interested in the severity and the message\n            self._severity = 'warning'\n            self._message = \"\\n\".join([\"%s: %s\" %(err['severity'].strip(), err['message'].strip()) for err in errlist])\n            self.errors = errs\n            has_error = filter(lambda higherr: higherr['severity'] == 'error', errlist)\n            if has_error:\n                self._severity = 'error'\n            OperationError.__init__(self, self.message)\n\n    def to_dict(self):\n        return dict([ (attr[1:], getattr(self, attr)) for attr in six.itervalues(RPCError.tag_to_attr) ])\n\n    @property\n    def xml(self):\n        \"The `rpc-error` element as returned in XML. \\\n        Multiple errors are returned as list of RPC errors\"\n        return self._raw\n\n    @property\n    def type(self):\n        \"The contents of the `error-type` element.\"\n        return self._type\n\n    @property\n    def tag(self):\n        \"The contents of the `error-tag` element.\"\n        return self._tag\n\n    @property\n    def app_tag(self):\n        \"The contents of the `error-app-tag` element.\"\n        return self._app_tag\n\n    @property\n    def severity(self):\n        \"The contents of the `error-severity` element.\"\n        return self._severity\n\n    @property\n    def path(self):\n        \"The contents of the `error-path` element if present or `None`.\"\n        return self._path\n\n    @property\n    def message(self):\n        \"The contents of the `error-message` element if present or `None`.\"\n        return self._message\n\n    @property\n    def info(self):\n        \"XML string or `None`; representing the `error-info` element.\"\n        return self._info\n\n    @property\n    def errlist(self):\n        \"List of errors if this represents multiple errors, otherwise None.\"\n        return self._errlist\n\n\nclass RPCReply(object):\n\n    \"\"\"Represents an *rpc-reply*. Only concerns itself with whether the operation was successful.\n\n    *raw*: the raw unparsed reply\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n\n    .. note::\n        If the reply has not yet been parsed there is an implicit, one-time parsing overhead to\n        accessing some of the attributes defined by this class.\n    \"\"\"\n\n    ERROR_CLS = RPCError\n    \"Subclasses can specify a different error class, but it should be a subclass of `RPCError`.\"\n\n    def __init__(self, raw, huge_tree=False, parsing_error_transform=None):\n        self._raw = raw\n        self._parsing_error_transform = parsing_error_transform\n        self._parsed = False\n        self._root = None\n        self._errors = []\n        self._huge_tree = huge_tree\n\n    def __repr__(self):\n        return self._raw\n\n    def parse(self):\n        \"Parses the *rpc-reply*.\"\n        if self._parsed: return\n        root = self._root = to_ele(self._raw, huge_tree=self._huge_tree) # The <rpc-reply> element\n        # Per RFC 4741 an <ok/> tag is sent when there are no errors or warnings\n        ok = root.find(qualify(\"ok\"))\n        if ok is None:\n            # Create RPCError objects from <rpc-error> elements\n            error = root.find('.//'+qualify('rpc-error'))\n            if error is not None:\n                for err in root.getiterator(error.tag):\n                    # Process a particular <rpc-error>\n                    self._errors.append(self.ERROR_CLS(err))\n        try:\n            self._parsing_hook(root)\n        except Exception as e:\n            if self._parsing_error_transform is None:\n                # re-raise as we have no workaround\n                exc_type, exc_value, exc_traceback = sys.exc_info()\n                six.reraise(exc_type, exc_value, exc_traceback)\n\n            # Apply device specific workaround and try again\n            self._parsing_error_transform(root)\n            self._parsing_hook(root)\n\n        self._parsed = True\n\n    def _parsing_hook(self, root):\n        \"No-op by default. Gets passed the *root* element for the reply.\"\n        pass\n\n    def set_parsing_error_transform(self, transform_function):\n        self._parsing_error_transform = transform_function\n\n    @property\n    def xml(self):\n        \"*rpc-reply* element as returned.\"\n        return self._raw\n\n    @property\n    def ok(self):\n        \"Boolean value indicating if there were no errors.\"\n        self.parse()\n        return not self.errors # empty list => false\n\n    @property\n    def error(self):\n        \"Returns the first :class:`RPCError` and `None` if there were no errors.\"\n        self.parse()\n        if self._errors:\n            return self._errors[0]\n        else:\n            return None\n\n    @property\n    def errors(self):\n        \"List of `RPCError` objects. Will be empty if there were no *rpc-error* elements in reply.\"\n        self.parse()\n        return self._errors\n\n\nclass RPCReplyListener(SessionListener): # internal use\n\n    creation_lock = Lock()\n\n    # one instance per session -- maybe there is a better way??\n    def __new__(cls, session, device_handler):\n        with RPCReplyListener.creation_lock:\n            instance = session.get_listener_instance(cls)\n            if instance is None:\n                instance = object.__new__(cls)\n                instance._lock = Lock()\n                instance._id2rpc = {}\n                instance._device_handler = device_handler\n                #instance._pipelined = session.can_pipeline\n                session.add_listener(instance)\n                instance.logger = SessionLoggerAdapter(logger,\n                                                       {'session': session})\n            return instance\n\n    def register(self, id, rpc):\n        with self._lock:\n            self._id2rpc[id] = rpc\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if self._device_handler.perform_qualify_check():\n            if tag != qualify(\"rpc-reply\"):\n                return\n        if \"message-id\" not in attrs:\n            # required attribute so raise OperationError\n            raise OperationError(\"Could not find 'message-id' attribute in <rpc-reply>\")\n        else:\n            id = attrs[\"message-id\"]  # get the msgid\n            with self._lock:\n                try:\n                    rpc = self._id2rpc[id]  # the corresponding rpc\n                    self.logger.debug(\"Delivering to %r\", rpc)\n                    rpc.deliver_reply(raw)\n                except KeyError:\n                    raise OperationError(\"Unknown 'message-id': %s\" % id)\n                # no catching other exceptions, fail loudly if must\n                else:\n                    # if no error delivering, can del the reference to the RPC\n                    del self._id2rpc[id]\n\n    def errback(self, err):\n        try:\n            for rpc in six.itervalues(self._id2rpc):\n                rpc.deliver_error(err)\n        finally:\n            self._id2rpc.clear()\n\n\nclass RaiseMode(object):\n    \"\"\"\n    Define how errors indicated by RPC should be handled.\n\n    Note that any error_filters defined in the device handler will still be\n    applied, even if ERRORS or ALL is defined: If the filter matches, an exception\n    will NOT be raised.\n\n    \"\"\"\n    NONE = 0\n    \"Don't attempt to raise any type of `rpc-error` as :exc:`RPCError`.\"\n\n    ERRORS = 1\n    \"Raise only when the `error-type` indicates it is an honest-to-god error.\"\n\n    ALL = 2\n    \"Don't look at the `error-type`, always raise.\"\n\n\nclass RPC(object):\n\n    \"\"\"Base class for all operations, directly corresponding to *rpc* requests. Handles making the request, and taking delivery of the reply.\"\"\"\n\n    DEPENDS = []\n    \"\"\"Subclasses can specify their dependencies on capabilities as a list of URI's or abbreviated names, e.g. ':writable-running'. These are verified at the time of instantiation. If the capability is not available, :exc:`MissingCapabilityError` is raised.\"\"\"\n\n    REPLY_CLS = RPCReply\n    \"By default :class:`RPCReply`. Subclasses can specify a :class:`RPCReply` subclass.\"\n\n\n    def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):\n        \"\"\"\n        *session* is the :class:`~ncclient.transport.Session` instance\n\n        *device_handler\" is the :class:`~ncclient.devices.*.*DeviceHandler` instance\n\n        *async* specifies whether the request is to be made asynchronously, see :attr:`is_async`\n\n        *timeout* is the timeout for a synchronous request, see :attr:`timeout`\n\n        *raise_mode* specifies the exception raising mode, see :attr:`raise_mode`\n\n        *huge_tree* parse xml with huge_tree support (e.g. for large text config retrieval), see :attr:`huge_tree`\n        \"\"\"\n        self._session = session\n        try:\n            for cap in self.DEPENDS:\n                self._assert(cap)\n        except AttributeError:\n            pass\n        self._async = async_mode\n        self._timeout = timeout\n        self._raise_mode = raise_mode\n        self._huge_tree = huge_tree\n        self._id = uuid4().urn # Keeps things simple instead of having a class attr with running ID that has to be locked\n        self._listener = RPCReplyListener(session, device_handler)\n        self._listener.register(self._id, self)\n        self._reply = None\n        self._error = None\n        self._event = Event()\n        self._device_handler = device_handler\n        self.logger = SessionLoggerAdapter(logger, {'session': session})\n\n\n    def _wrap(self, subele):\n        # internal use\n        ele = new_ele(\"rpc\", {\"message-id\": self._id},\n                      **self._device_handler.get_xml_extra_prefix_kwargs())\n        ele.append(subele)\n        return to_xml(ele)\n\n    def _request(self, op):\n        \"\"\"Implementations of :meth:`request` call this method to send the request and process the reply.\n\n        In synchronous mode, blocks until the reply is received and returns :class:`RPCReply`. Depending on the :attr:`raise_mode` a `rpc-error` element in the reply may lead to an :exc:`RPCError` exception.\n\n        In asynchronous mode, returns immediately, returning `self`. The :attr:`event` attribute will be set when the reply has been received (see :attr:`reply`) or an error occured (see :attr:`error`).\n\n        *op* is the operation to be requested as an :class:`~xml.etree.ElementTree.Element`\n        \"\"\"\n        self.logger.info('Requesting %r', self.__class__.__name__)\n        req = self._wrap(op)\n        self._session.send(req)\n        if self._async:\n            self.logger.debug('Async request, returning %r', self)\n            return self\n        else:\n            self.logger.debug('Sync request, will wait for timeout=%r', self._timeout)\n            self._event.wait(self._timeout)\n            if self._event.is_set():\n                if self._error:\n                    # Error that prevented reply delivery\n                    raise self._error\n                self._reply.parse()\n                if self._reply.error is not None and not self._device_handler.is_rpc_error_exempt(self._reply.error.message):\n                    # <rpc-error>'s [ RPCError ]\n\n                    if self._raise_mode == RaiseMode.ALL or (self._raise_mode == RaiseMode.ERRORS and self._reply.error.severity == \"error\"):\n                        errlist = []\n                        errors = self._reply.errors\n                        if len(errors) > 1:\n                            raise RPCError(to_ele(self._reply._raw), errs=errors)\n                        else:\n                            raise self._reply.error\n                if self._device_handler.transform_reply():\n                    return NCElement(self._reply, self._device_handler.transform_reply(), huge_tree=self._huge_tree)\n                else:\n                    return self._reply\n            else:\n                raise TimeoutExpiredError('ncclient timed out while waiting for an rpc reply.')\n\n    def request(self):\n        \"\"\"Subclasses must implement this method. Typically only the request needs to be built as an\n        :class:`~xml.etree.ElementTree.Element` and everything else can be handed off to\n        :meth:`_request`.\"\"\"\n        pass\n\n    def _assert(self, capability):\n        \"\"\"Subclasses can use this method to verify that a capability is available with the NETCONF\n        server, before making a request that requires it. A :exc:`MissingCapabilityError` will be\n        raised if the capability is not available.\"\"\"\n        if capability not in self._session.server_capabilities:\n            raise MissingCapabilityError('Server does not support [%s]' % capability)\n\n    def deliver_reply(self, raw):\n        # internal use\n        self._reply = self.REPLY_CLS(raw, huge_tree=self._huge_tree)\n\n        # Set the reply_parsing_error transform outside the constructor, to keep compatibility for\n        # third party reply classes outside of ncclient\n        self._reply.set_parsing_error_transform(\n            self._device_handler.reply_parsing_error_transform(self.REPLY_CLS)\n        )\n\n        self._event.set()\n\n    def deliver_error(self, err):\n        # internal use\n        self._error = err\n        self._event.set()\n\n    @property\n    def reply(self):\n        \":class:`RPCReply` element if reply has been received or `None`\"\n        return self._reply\n\n    @property\n    def error(self):\n        \"\"\":exc:`Exception` type if an error occured or `None`.\n\n        .. note::\n            This represents an error which prevented a reply from being received. An *rpc-error*\n            does not fall in that category -- see `RPCReply` for that.\n        \"\"\"\n        return self._error\n\n    @property\n    def id(self):\n        \"The *message-id* for this RPC.\"\n        return self._id\n\n    @property\n    def session(self):\n        \"The `~ncclient.transport.Session` object associated with this RPC.\"\n        return self._session\n\n    @property\n    def event(self):\n        \"\"\":class:`~threading.Event` that is set when reply has been received or when an error preventing\n        delivery of the reply occurs.\n        \"\"\"\n        return self._event\n\n    def __set_async(self, async_mode=True):\n        self._async = async_mode\n        if async_mode and not self._session.can_pipeline:\n            raise UserWarning('Asynchronous mode not supported for this device/session')\n\n    def __set_raise_mode(self, mode):\n        assert(mode in (RaiseMode.NONE, RaiseMode.ERRORS, RaiseMode.ALL))\n        self._raise_mode = mode\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n\n    raise_mode = property(fget=lambda self: self._raise_mode, fset=__set_raise_mode)\n    \"\"\"Depending on this exception raising mode, an `rpc-error` in the reply may be raised as an :exc:`RPCError` exception. Valid values are the constants defined in :class:`RaiseMode`. \"\"\"\n\n    is_async = property(fget=lambda self: self._async, fset=__set_async)\n    \"\"\"Specifies whether this RPC will be / was requested asynchronously. By default RPC's are synchronous.\"\"\"\n\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    \"\"\"Timeout in seconds for synchronous waiting defining how long the RPC request will block on a reply before raising :exc:`TimeoutExpiredError`.\n\n    Irrelevant for asynchronous usage.\n    \"\"\"\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x\n\nclass GenericRPC(RPC):\n    \"\"\"Generic rpc commands wrapper\"\"\"\n    REPLY_CLS = RPCReply\n    \"\"\"See :class:`RPCReply`.\"\"\"\n\n    def request(self, rpc_command, source=None, filter=None, config=None, target=None, format=None):\n        \"\"\"\n        *rpc_command* specifies rpc command to be dispatched either in plain text or in xml element format (depending on command)\n\n        *target* name of the configuration datastore being edited\n\n        *source* name of the configuration datastore being queried\n\n        *config* is the configuration, which must be rooted in the `config` element. It can be specified either as a string or an :class:`~xml.etree.ElementTree.Element`.\n\n        *filter* specifies the portion of the configuration to retrieve (by default entire configuration is retrieved)\n\n        :seealso: :ref:`filter_params`\n\n        Examples of usage::\n\n            m.rpc('rpc_command')\n\n        or dispatch element like ::\n\n            rpc_command = new_ele('get-xnm-information')\n            sub_ele(rpc_command, 'type').text = \"xml-schema\"\n            m.rpc(rpc_command)\n        \"\"\"\n\n        if etree.iselement(rpc_command):\n            node = rpc_command\n        else:\n            node = new_ele(rpc_command)\n        if target is not None:\n            node.append(util.datastore_or_url(\"target\", target, self._assert))\n        if source is not None:\n            node.append(util.datastore_or_url(\"source\", source, self._assert))\n        if filter is not None:\n            node.append(util.build_filter(filter))\n        if config is not None:\n            node.append(validated_element(config, (\"config\", qualify(\"config\"))))\n\n        return self._request(node)\n",
    "ncclient/xml_.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\n\n\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\n\n# In case issues come up with XML generation/parsing\n# make sure you have the ElementTree v1.2.7+ lib as\n# well as lxml v3.0+\n\nfrom ncclient import NCClientError\n\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\n\nclass XMLError(NCClientError):\n    pass\n\n### Namespace-related\n\n#: Base NETCONF namespace\nBASE_NS_1_0 = \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n#: YANG (RFC 6020/RFC 7950) namespace\nYANG_NS_1_0 = \"urn:ietf:params:xml:ns:yang:1\"\n#: NXOS_1_0\nNXOS_1_0 = \"http://www.cisco.com/nxos:1.0\"\n#: NXOS_IF\nNXOS_IF = \"http://www.cisco.com/nxos:1.0:if_manager\"\n#: Namespace for Tail-f core data model\nTAILF_AAA_1_1 = \"http://tail-f.com/ns/aaa/1.1\"\n#: Namespace for Tail-f execd data model\nTAILF_EXECD_1_1 = \"http://tail-f.com/ns/execd/1.1\"\n#: Namespace for Cisco data model\nCISCO_CPI_1_0 = \"http://www.cisco.com/cpi_10/schema\"\n#: Namespace for Flowmon data model\nFLOWMON_1_0 = \"http://www.liberouter.org/ns/netopeer/flowmon/1.0\"\n#: Namespace for Juniper 9.6R4. Tested with Junos 9.6R4+\nJUNIPER_1_1 = \"http://xml.juniper.net/xnm/1.1/xnm\"\n#: Namespace for Huawei data model\nHUAWEI_NS = \"http://www.huawei.com/netconf/vrp\"\n#: Namespace for Huawei private\nHW_PRIVATE_NS = \"http://www.huawei.com/netconf/capability/base/1.0\"\n#: Namespace for H3C data model\nH3C_DATA_1_0 = \"http://www.h3c.com/netconf/data:1.0\"\n#: Namespace for H3C config model\nH3C_CONFIG_1_0 = \"http://www.h3c.com/netconf/config:1.0\"\n#: Namespace for H3C action model\nH3C_ACTION_1_0 = \"http://www.h3c.com/netconf/action:1.0\"\n#: Namespace for netconf monitoring\nNETCONF_MONITORING_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\"\n#: Namespace for netconf notifications\nNETCONF_NOTIFICATION_NS = \"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n#: Namespace for netconf with-defaults (RFC 6243)\nNETCONF_WITH_DEFAULTS_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\"\n#: Namespace for Alcatel-Lucent SR OS Base r13 YANG models\nALU_CONFIG = \"urn:alcatel-lucent.com:sros:ns:yang:conf-r13\"\n#: Namespace for Nokia SR OS global operations\nSROS_GLOBAL_OPS_NS = \"urn:nokia.com:sros:ns:yang:sr:oper-global\"\n\n\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        # cElementTree uses ElementTree's _namespace_map, so that's ok\n        ElementTree._namespace_map[uri] = prefix\n\nfor (ns, pre) in six.iteritems({\n    BASE_NS_1_0: 'nc',\n    NETCONF_MONITORING_NS: 'ncm',\n    NXOS_1_0: 'nxos',\n    NXOS_IF: 'if',\n    TAILF_AAA_1_1: 'aaa',\n    TAILF_EXECD_1_1: 'execd',\n    CISCO_CPI_1_0: 'cpi',\n    FLOWMON_1_0: 'fm',\n    JUNIPER_1_1: 'junos',\n}):\n    register_namespace(pre, ns)\n\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else \"{%s}%s\" % (ns, tag)\n\"\"\"Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.\"\"\"\n\n\ndef to_xml(ele, encoding=\"UTF-8\", pretty_print=False):\n    \"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') \\\n            else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\n\ndef parse_root(raw):\n    \"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError(\"Element [%s] does not meet requirement\" % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)): req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError(\"Element [%s] does not have required attributes\" % ele.tag)\n    return ele\n\nXPATH_NAMESPACES = {\n    're':'http://exslt.org/regular-expressions'\n}\n\n\nclass NCElement(object):\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt=self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)),\n                                                                        parser=self.__parser))),\n                                       parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        # Comments don't have a namespace\n        if elem.tag is not etree.Comment:\n            # handle tag\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n\n            # handle attributes\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\n\n\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\n\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\n\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag,ns), attrs, **extra)\n\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\n\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)\n",
    "ncclient/transport/parser.py": "# Copyright 2018 Nitin Kumar\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport os\nimport sys\nimport re\n\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\n\nfrom xml.sax.handler import ContentHandler\n\nfrom ncclient.transport.errors import NetconfFramingError\nfrom ncclient.transport.session import NetconfBase\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.operations.errors import OperationError\nfrom ncclient.transport import SessionListener\n\nimport logging\nlogger = logging.getLogger(\"ncclient.transport.parser\")\n\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\n\n\nPORT_NETCONF_DEFAULT = 830\nPORT_SSH_DEFAULT = 22\n\nBUF_SIZE = 4096\n# v1.0: RFC 4742\nMSG_DELIM = \"]]>]]>\"\nMSG_DELIM_LEN = len(MSG_DELIM)\n# v1.1: RFC 6242\nEND_DELIM = '\\n##\\n'\n\nTICK = 0.1\n\n#\n# Define delimiters for chunks and messages for netconf 1.1 chunk enoding.\n# When matched:\n#\n# * result.group(0) will contain whole matched string\n# * result.group(1) will contain the digit string for a chunk\n# * result.group(2) will be defined if '##' found\n#\nRE_NC11_DELIM = re.compile(r'\\n(?:#([0-9]+)|(##))\\n')\n\nif sys.version < '3':\n    def textify(buf):\n        return buf\nelse:\n    def textify(buf):\n        return buf.decode('UTF-8')\n\n\nclass SAXParserHandler(SessionListener):\n\n    def __init__(self, session):\n        self._session = session\n\n    def callback(self, root, raw):\n        if type(self._session.parser) == DefaultXMLParser:\n            self._session.parser = self._session._device_handler.get_xml_parser(self._session)\n\n    def errback(self, _):\n        pass\n\n\nclass SAXFilterXMLNotFoundError(OperationError):\n    def __init__(self, rpc_listener):\n        self._listener = rpc_listener\n\n    def __str__(self):\n        return \"SAX filter input xml not provided for listener: %s\" % self._listener\n\n\nclass DefaultXMLParser(object):\n\n    def __init__(self, session):\n        \"\"\"\n        DOM Parser\n\n        :param session: ssh session object\n        \"\"\"\n        self._session = session\n        self._parsing_pos10 = 0\n        self.logger = SessionLoggerAdapter(logger, {'session': self._session})\n\n    def parse(self, data):\n        \"\"\"\n        parse incoming RPC response from networking device.\n\n        :param data: incoming RPC data from device\n        :return: None\n        \"\"\"\n        if data:\n            self._session._buffer.seek(0, os.SEEK_END)\n            self._session._buffer.write(data)\n            if self._session._base == NetconfBase.BASE_11:\n                self._parse11()\n            else:\n                self._parse10()\n\n    def _parse10(self):\n\n        \"\"\"Messages are delimited by MSG_DELIM. The buffer could have grown by\n        a maximum of BUF_SIZE bytes everytime this method is called. Retains\n        state across method calls and if a chunk has been read it will not be\n        considered again.\"\"\"\n\n        self.logger.debug(\"parsing netconf v1.0\")\n        buf = self._session._buffer\n        buf.seek(self._parsing_pos10)\n        if MSG_DELIM in buf.read().decode('UTF-8'):\n            buf.seek(0)\n            msg, _, remaining = buf.read().decode('UTF-8').partition(MSG_DELIM)\n            msg = msg.strip()\n            if sys.version < '3':\n                self._session._dispatch_message(msg.encode())\n            else:\n                self._session._dispatch_message(msg)\n            self._session._buffer = StringIO()\n            self._parsing_pos10 = 0\n            if len(remaining.strip()) > 0:\n                # There could be another entire message in the\n                # buffer, so we should try to parse again.\n                if type(self._session.parser) != DefaultXMLParser:\n                    self.logger.debug('send remaining data to SAX parser')\n                    self._session.parser.parse(remaining.encode())\n                else:\n                    self.logger.debug('Trying another round of parsing since there is still data')\n                    self._session._buffer.write(remaining.encode())\n                    self._parse10()\n        else:\n            # handle case that MSG_DELIM is split over two chunks\n            self._parsing_pos10 = buf.tell() - MSG_DELIM_LEN\n            if self._parsing_pos10 < 0:\n                self._parsing_pos10 = 0\n\n    def _parse11(self):\n\n        \"\"\"Messages are split into chunks. Chunks and messages are delimited\n        by the regex #RE_NC11_DELIM defined earlier in this file. Each\n        time we get called here either a chunk delimiter or an\n        end-of-message delimiter should be found iff there is enough\n        data. If there is not enough data, we will wait for more. If a\n        delimiter is found in the wrong place, a #NetconfFramingError\n        will be raised.\"\"\"\n\n        self.logger.debug(\"_parse11: starting\")\n\n        # suck in whole string that we have (this is what we will work on in\n        # this function) and initialize a couple of useful values\n        self._session._buffer.seek(0, os.SEEK_SET)\n        data = self._session._buffer.getvalue()\n        data_len = len(data)\n        start = 0\n        self.logger.debug('_parse11: working with buffer of %d bytes', data_len)\n        while True and start < data_len:\n            # match to see if we found at least some kind of delimiter\n            self.logger.debug('_parse11: matching from %d bytes from start of buffer', start)\n            re_result = RE_NC11_DELIM.match(data[start:].decode('utf-8', errors='ignore'))\n            if not re_result:\n\n                # not found any kind of delimiter just break; this should only\n                # ever happen if we just have the first few characters of a\n                # message such that we don't yet have a full delimiter\n                self.logger.debug('_parse11: no delimiter found, buffer=\"%s\"', data[start:].decode())\n                break\n\n            # save useful variables for reuse\n            re_start = re_result.start()\n            re_end = re_result.end()\n            self.logger.debug('_parse11: regular expression start=%d, end=%d', re_start, re_end)\n\n            # If the regex doesn't start at the beginning of the buffer,\n            # we're in trouble, so throw an error\n            if re_start != 0:\n                raise NetconfFramingError('_parse11: delimiter not at start of match buffer', data[start:])\n\n            if re_result.group(2):\n                # we've found the end of the message, need to form up\n                # whole message, save back remainder (if any) to buffer\n                # and dispatch the message\n                start += re_end\n                message = ''.join(self._session._message_list)\n                self._session._message_list = []\n                self.logger.debug('_parse11: found end of message delimiter')\n                self._session._dispatch_message(message)\n                break\n\n            elif re_result.group(1):\n                # we've found a chunk delimiter, and group(1) is the digit\n                # string that will tell us how many bytes past the end of\n                # where it was found that we need to have available to\n                # save the next chunk off\n                self.logger.debug('_parse11: found chunk delimiter')\n                digits = int(re_result.group(1))\n                self.logger.debug('_parse11: chunk size %d bytes', digits)\n                if (data_len-start) >= (re_end + digits):\n                    # we have enough data for the chunk\n                    fragment = textify(data[start+re_end:start+re_end+digits])\n                    self._session._message_list.append(fragment)\n                    start += re_end + digits\n                    self.logger.debug('_parse11: appending %d bytes', digits)\n                    self.logger.debug('_parse11: fragment = \"%s\"', fragment)\n                else:\n                    # we don't have enough bytes, just break out for now\n                    # after updating start pointer to start of new chunk\n                    start += re_start\n                    self.logger.debug('_parse11: not enough data for chunk yet')\n                    self.logger.debug('_parse11: setting start to %d', start)\n                    break\n\n        # Now out of the loop, need to see if we need to save back any content\n        if start > 0:\n            self.logger.debug(\n                '_parse11: saving back rest of message after %d bytes, original size %d',\n                start, data_len)\n            self._session._buffer = StringIO(data[start:])\n            if start < data_len:\n                self.logger.debug('_parse11: still have data, may have another full message!')\n                self._parse11()\n        self.logger.debug('_parse11: ending')\n",
    "ncclient/capabilities.py": "# Copyright 2009 Shikhar Bhushan\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\nimport six\n\n\nlogger = logging.getLogger(\"ncclient.capabilities\")\n\n\ndef _abbreviate(uri):\n    if uri.startswith(\"urn:ietf:params\") and \":netconf:\" in uri:\n        splitted = uri.split(\":\")\n        if \":capability:\" in uri:\n            if uri.startswith(\"urn:ietf:params:xml:ns:netconf\"):\n                name, version = splitted[7], splitted[8]\n            else:\n                name, version = splitted[5], splitted[6]\n            return [ \":\" + name, \":\" + name + \":\" + version ]\n        elif \":base:\" in uri:\n            if uri.startswith(\"urn:ietf:params:xml:ns:netconf\"):\n                return [ \":base\", \":base\" + \":\" + splitted[7] ]\n            else:\n                return [ \":base\", \":base\" + \":\" + splitted[5] ]\n    return []\n\ndef schemes(url_uri):\n    \"Given a URI that has a *scheme* query string (i.e. `:url` capability URI), will return a list of supported schemes.\"\n    return url_uri.partition(\"?scheme=\")[2].split(\",\")\n\nclass Capabilities(object):\n\n    \"Represents the set of capabilities available to a NETCONF client or server. It is initialized with a list of capability URI's.\"\n\n    def __init__(self, capabilities):\n        self._dict = {}\n        for uri in capabilities:\n            self.add(uri)\n\n    def __contains__(self, key):\n        try:\n            self.__getitem__(key)\n        except KeyError:\n            return False\n        else:\n            return True\n\n    def __getitem__(self, key):\n        try:\n            return self._dict[key]\n        except KeyError:\n            for capability in six.itervalues(self._dict):\n                if key in capability.get_abbreviations():\n                    return capability\n\n        raise KeyError(key)\n\n    def __len__(self):\n        return len(self._dict)\n\n    # python 2 and 3 compatible\n    def __iter__(self):\n        return six.iterkeys(self._dict)\n\n    def __repr__(self):\n        return repr(six.iterkeys(self._dict))\n\n    def add(self, uri):\n        \"Add a capability.\"\n        self._dict[uri] = Capability.from_uri(uri)\n\n    def remove(self, uri):\n        \"Remove a capability.\"\n        if uri in self._dict:\n            del self._dict[uri]\n\n\nclass Capability(object):\n\n    \"\"\"Represents a single capability\"\"\"\n\n    def __init__(self, namespace_uri, parameters=None):\n        self.namespace_uri = namespace_uri\n        self.parameters = parameters or {}\n\n    @classmethod\n    def from_uri(cls, uri):\n        split_uri = uri.split(\"?\")\n        namespace_uri = split_uri[0]\n        capability = cls(namespace_uri)\n\n        try:\n            param_string = split_uri[1]\n        except IndexError:\n            return capability\n\n        capability.parameters = {\n            param.key: param.value\n            for param in _parse_parameter_string(param_string, uri)\n        }\n\n        return capability\n\n    def __eq__(self, other):\n        return (\n            self.namespace_uri == other.namespace_uri and\n            self.parameters == other.parameters\n        )\n\n    def get_abbreviations(self):\n        return _abbreviate(self.namespace_uri)\n\n\ndef _parse_parameter_string(string, uri):\n    for param_string in string.split(\"&\"):\n        try:\n            yield _Parameter.from_string(param_string)\n        except _InvalidParameter:\n            logger.error(\n                \"Invalid parameter '{param}' in capability URI '{uri}'\".format(\n                    param=param_string,\n                    uri=uri,\n                )\n            )\n\n\nclass _Parameter(object):\n\n    \"\"\"Represents a parameter to a capability\"\"\"\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\n    @classmethod\n    def from_string(cls, string):\n        try:\n            key, value = string.split(\"=\")\n        except ValueError:\n            raise _InvalidParameter\n\n        return cls(key, value)\n\n\nclass _InvalidParameter(Exception):\n\n    pass\n",
    "ncclient/devices/junos.py": "\"\"\"\nHandler for Juniper device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Junos\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nimport logging\nimport re\n\nfrom lxml import etree\nfrom lxml.etree import QName\n\nfrom ncclient.operations.retrieve import GetSchemaReply\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.juniper.rpc import GetConfiguration, LoadConfiguration, CompareConfiguration\nfrom ncclient.operations.third_party.juniper.rpc import ExecuteRpc, Command, Reboot, Halt, Commit, Rollback\nfrom ncclient.operations.rpc import RPCError\nfrom ncclient.xml_ import to_ele, replace_namespace, BASE_NS_1_0, NETCONF_MONITORING_NS\nfrom ncclient.transport.third_party.junos.parser import JunosXMLParser\nfrom ncclient.transport.parser import DefaultXMLParser\nfrom ncclient.transport.parser import SAXParserHandler\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass JunosDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Juniper handler for device specific information.\n\n    \"\"\"\n\n    def __init__(self, device_params):\n        super(JunosDeviceHandler, self).__init__(device_params)\n        self.__reply_parsing_error_transform_by_cls = {\n            GetSchemaReply: fix_get_schema_reply\n        }\n\n    def add_additional_operations(self):\n        dict = {}\n        dict[\"rpc\"] = ExecuteRpc\n        dict[\"get_configuration\"] = GetConfiguration\n        dict[\"load_configuration\"] = LoadConfiguration\n        dict[\"compare_configuration\"] = CompareConfiguration\n        dict[\"command\"] = Command\n        dict[\"reboot\"] = Reboot\n        dict[\"halt\"] = Halt\n        dict[\"commit\"] = Commit\n        dict[\"rollback\"] = Rollback\n        return dict\n\n    def perform_qualify_check(self):\n        return False\n\n    def handle_raw_dispatch(self, raw):\n        if 'routing-engine' in raw:\n            raw = re.sub(r'<ok/>', '</routing-engine>\\n<ok/>', raw)\n            return raw\n        # check if error is during capabilities exchange itself\n        elif re.search(r'<rpc-reply>.*?</rpc-reply>.*</hello>?', raw, re.M | re.S):\n            errs = re.findall(\n                r'<rpc-error>.*?</rpc-error>', raw, re.M | re.S)\n            err_list = []\n            if errs:\n                add_ns = \"\"\"\n                        <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n                          <xsl:output indent=\"yes\"/>\n                            <xsl:template match=\"*\">\n                            <xsl:element name=\"{local-name()}\" namespace=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n                            <xsl:apply-templates select=\"@*|node()\"/>\n                            </xsl:element>\n                          </xsl:template>\n                        </xsl:stylesheet>\"\"\"\n                for err in errs:\n                    doc = etree.ElementTree(etree.XML(err))\n                    # Adding namespace using xslt\n                    xslt = etree.XSLT(etree.XML(add_ns))\n                    transformed_xml = etree.XML(etree.tostring(xslt(doc)))\n                    err_list.append(RPCError(transformed_xml))\n                return RPCError(to_ele(\"<rpc-reply>\"+''.join(errs)+\"</rpc-reply>\"), err_list)\n        else:\n            return False\n\n    def handle_connection_exceptions(self, sshsession):\n        c = sshsession._channel = sshsession._transport.open_channel(\n            kind=\"session\")\n        c.set_name(\"netconf-command-\" + str(sshsession._channel_id))\n        c.exec_command(\"xml-mode netconf need-trailer\")\n        return True\n\n    def reply_parsing_error_transform(self, reply_cls):\n        # return transform function if found, else None\n        return self.__reply_parsing_error_transform_by_cls.get(reply_cls)\n\n    def transform_reply(self):\n        reply = '''<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n        <xsl:output method=\"xml\" indent=\"no\"/>\n\n        <xsl:template match=\"/|comment()|processing-instruction()\">\n            <xsl:copy>\n                <xsl:apply-templates/>\n            </xsl:copy>\n        </xsl:template>\n\n        <xsl:template match=\"*\">\n            <xsl:element name=\"{local-name()}\">\n                <xsl:apply-templates select=\"@*|node()\"/>\n            </xsl:element>\n        </xsl:template>\n\n        <xsl:template match=\"@*\">\n            <xsl:attribute name=\"{local-name()}\">\n                <xsl:value-of select=\".\"/>\n            </xsl:attribute>\n        </xsl:template>\n        </xsl:stylesheet>\n        '''\n        import sys\n        if sys.version < '3':\n            return reply\n        else:\n            return reply.encode('UTF-8')\n\n    def get_xml_parser(self, session):\n        # use_filter in device_params can be used to enabled using SAX parsing\n        if self.device_params.get('use_filter', False):\n            l = session.get_listener_instance(SAXParserHandler)\n            if l:\n                session.remove_listener(l)\n                del l\n            session.add_listener(SAXParserHandler(session))\n            return JunosXMLParser(session)\n        else:\n            return DefaultXMLParser(session)\n\n\ndef fix_get_schema_reply(root):\n    # Workaround for wrong namespace of the data elem\n    # (issue with some Junos versions, might be corrected by Juniper at some point)\n\n    # get the data element, by local-name\n    data_elems = root.xpath('/nc:rpc-reply/*[local-name()=\"data\"]', namespaces={'nc': BASE_NS_1_0})\n\n    if len(data_elems) != 1:\n        return  # Will not alter unexpected content\n\n    data_el = data_elems[0]\n    namespace = QName(data_el).namespace\n\n    if namespace == BASE_NS_1_0:\n        # With the default netconf setting, we may get \"{BASE_NS_1_0}data\"; warn and fix it\n        logger.warning(\"The device seems to run non-rfc compliant netconf. You may want to \"\n                       \"configure: 'set system services netconf rfc-compliant'\")\n        replace_namespace(data_el, old_ns=BASE_NS_1_0, new_ns=NETCONF_MONITORING_NS)\n    elif namespace is None:\n        # With 'set system services netconf rfc-compliant' we may get \"data\" (no namespace); fix it\n        # There is no default xmlns and the data el is <data xmlns:ncm=\"NETCONF_MONITORING_NS\">\n        replace_namespace(data_el, old_ns=None, new_ns=NETCONF_MONITORING_NS)\n",
    "ncclient/transport/session.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport logging\nfrom threading import Thread, Lock, Event\ntry:\n    from Queue import Queue, Empty\nexcept ImportError:\n    from queue import Queue, Empty\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\n\nimport ncclient.transport\nfrom ncclient.xml_ import *\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TransportError, SessionError, SessionCloseError\nfrom ncclient.transport.notify import Notification\n\nlogger = logging.getLogger('ncclient.transport.session')\n\n# v1.0: RFC 4742\nMSG_DELIM = b\"]]>]]>\"\n# v1.1: RFC 6242\nEND_DELIM = b'\\n##\\n'\n\nTICK = 0.1\n\n\nclass NetconfBase(object):\n    '''Netconf Base protocol version'''\n    BASE_10 = 1\n    BASE_11 = 2\n\n\nclass Session(Thread):\n\n    \"Base class for use by transport protocol implementations.\"\n\n    def __init__(self, capabilities):\n        Thread.__init__(self, daemon=True, name='session')\n        self._listeners = set()\n        self._lock = Lock()\n        self._q = Queue()\n        self._notification_q = Queue()\n        self._client_capabilities = capabilities\n        self._server_capabilities = None # yet\n        self._base = NetconfBase.BASE_10\n        self._id = None # session-id\n        self._connected = False # to be set/cleared by subclass implementation\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n        self.logger.debug('%r created: client_capabilities=%r',\n                          self, self._client_capabilities)\n        self._device_handler = None # Should be set by child class\n\n    def _dispatch_message(self, raw):\n        try:\n            root = parse_root(raw)\n        except Exception as e:\n            device_handled_raw=self._device_handler.handle_raw_dispatch(raw)\n            if isinstance(device_handled_raw, str):\n                root = parse_root(device_handled_raw)\n            elif isinstance(device_handled_raw, Exception):\n                self._dispatch_error(device_handled_raw)\n                return\n            else:\n                self.logger.error('error parsing dispatch message: %s', e)\n                return\n        self.logger.debug('dispatching message to different listeners: %s',\n                          raw)\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching message to listener: %r', l)\n            l.callback(root, raw) # no try-except; fail loudly if you must!\n\n    def _dispatch_error(self, err):\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching error to %r', l)\n            try: # here we can be more considerate with catching exceptions\n                l.errback(err)\n            except Exception as e:\n                self.logger.warning('error dispatching to %r: %r', l, e)\n\n    def _post_connect(self, timeout=60):\n        \"Greeting stuff\"\n        init_event = Event()\n        error = [None] # so that err_cb can bind error[0]. just how it is.\n        # callbacks\n        def ok_cb(id, capabilities):\n            self._id = id\n            self._server_capabilities = capabilities\n            init_event.set()\n        def err_cb(err):\n            error[0] = err\n            init_event.set()\n        self.add_listener(NotificationHandler(self._notification_q))\n        listener = HelloHandler(ok_cb, err_cb)\n        self.add_listener(listener)\n        self.send(HelloHandler.build(self._client_capabilities, self._device_handler))\n        self.logger.debug('starting main loop')\n        self.start()\n        # we expect server's hello message, if server doesn't responds in 60 seconds raise exception\n        init_event.wait(timeout)\n        if not init_event.is_set():\n            raise SessionError(\"Capability exchange timed out\")\n        # received hello message or an error happened\n        self.remove_listener(listener)\n        if error[0]:\n            raise error[0]\n        #if ':base:1.0' not in self.server_capabilities:\n        #    raise MissingCapabilityError(':base:1.0')\n        if 'urn:ietf:params:netconf:base:1.1' in self._server_capabilities and 'urn:ietf:params:netconf:base:1.1' in self._client_capabilities:\n            self.logger.debug(\"After 'hello' message selecting netconf:base:1.1 for encoding\")\n            self._base = NetconfBase.BASE_11\n        self.logger.info('initialized: session-id=%s | server_capabilities=%s',\n                         self._id, self._server_capabilities)\n\n    def add_listener(self, listener):\n        \"\"\"Register a listener that will be notified of incoming messages and\n        errors.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('installing listener %r', listener)\n        if not isinstance(listener, SessionListener):\n            raise SessionError(\"Listener must be a SessionListener type\")\n        with self._lock:\n            self._listeners.add(listener)\n\n    def remove_listener(self, listener):\n        \"\"\"Unregister some listener; ignore if the listener was never\n        registered.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('discarding listener %r', listener)\n        with self._lock:\n            self._listeners.discard(listener)\n\n    def get_listener_instance(self, cls):\n        \"\"\"If a listener of the specified type is registered, returns the\n        instance.\n\n        :type cls: :class:`SessionListener`\n        \"\"\"\n        with self._lock:\n            for listener in self._listeners:\n                if isinstance(listener, cls):\n                    return listener\n\n    def connect(self, *args, **kwds): # subclass implements\n        raise NotImplementedError\n\n    def _transport_read(self):\n        \"\"\"\n        Read data from underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :return: Byte string read from Transport, or None if nothing was read.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_write(self, data):\n        \"\"\"\n        Write data into underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :param data: Byte string to write.\n        :return: Number of bytes sent, or 0 if the stream is closed.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_register(self, selector, event):\n        \"\"\"\n        Register the channel/socket of Transport layer for selection.\n        Implemented in a subclass.\n\n        :param selector: Selector to register with.\n        :param event: Type of event for selection.\n        \"\"\"\n        raise NotImplementedError\n\n    def _send_ready(self):\n        \"\"\"\n        Check if Transport layer is ready to send the data. Implemented\n        in a subclass.\n\n        :return: True if the layer is ready, False otherwise.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self):\n        q = self._q\n\n        def start_delim(data_len):\n            return b'\\n#%i\\n' % data_len\n\n        try:\n            s = selectors.DefaultSelector()\n            self._transport_register(s, selectors.EVENT_READ)\n            self.logger.debug('selector type = %s', s.__class__.__name__)\n            while True:\n                \n                if not q.empty() and self._send_ready():\n                    self.logger.debug(\"Sending message\")\n                    data = q.get().encode()\n                    if self._base == NetconfBase.BASE_11:\n                        data = b\"%s%s%s\" % (start_delim(len(data)), data, END_DELIM)\n                    else:\n                        data = b\"%s%s\" % (data, MSG_DELIM)\n                    self.logger.info(\"Sending:\\n%s\", data)\n                    while data:\n                        n = self._transport_write(data)\n                        if n <= 0:\n                            raise SessionCloseError(self._buffer.getvalue(), data)\n                        data = data[n:]\n                        \n                events = s.select(timeout=TICK)\n                if events:\n                    data = self._transport_read()\n                    if data:\n                        try:\n                            self.parser.parse(data)\n                        except ncclient.transport.parser.SAXFilterXMLNotFoundError:\n                            self.logger.debug('switching from sax to dom parsing')\n                            self.parser = ncclient.transport.parser.DefaultXMLParser(self)\n                            self.parser.parse(data)\n                    elif self._closing.is_set():\n                        # End of session, expected\n                        break\n                    else:\n                        # End of session, unexpected\n                        raise SessionCloseError(self._buffer.getvalue())\n        except Exception as e:\n            self.logger.debug(\"Broke out of main loop, error=%r\", e)\n            self._dispatch_error(e)\n            self.close()\n\n    def send(self, message):\n        \"\"\"Send the supplied *message* (xml string) to NETCONF server.\"\"\"\n        if not self.connected:\n            raise TransportError('Not connected to NETCONF server')\n        self.logger.debug('queueing %s', message)\n        self._q.put(message)\n\n    def scp(self):\n        raise NotImplementedError\n    ### Properties\n\n    def take_notification(self, block, timeout):\n        try:\n            return self._notification_q.get(block, timeout)\n        except Empty:\n            return None\n\n    @property\n    def connected(self):\n        \"Connection status of the session.\"\n        return self._connected\n\n    @property\n    def client_capabilities(self):\n        \"Client's :class:`Capabilities`\"\n        return self._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"Server's :class:`Capabilities`\"\n        return self._server_capabilities\n\n    @property\n    def id(self):\n        \"\"\"A string representing the `session-id`. If the session has not been initialized it will be `None`\"\"\"\n        return self._id\n\n\nclass SessionListener(object):\n\n    \"\"\"Base class for :class:`Session` listeners, which are notified when a new\n    NETCONF message is received or an error occurs.\n\n    .. note::\n        Avoid time-intensive tasks in a callback's context.\n    \"\"\"\n\n    def callback(self, root, raw):\n        \"\"\"Called when a new XML document is received. The *root* argument allows the callback to determine whether it wants to further process the document.\n\n        Here, *root* is a tuple of *(tag, attributes)* where *tag* is the qualified name of the root element and *attributes* is a dictionary of its attributes (also qualified names).\n\n        *raw* will contain the XML document as a string.\n        \"\"\"\n        raise NotImplementedError\n\n    def errback(self, ex):\n        \"\"\"Called when an error occurs.\n\n        :type ex: :exc:`Exception`\n        \"\"\"\n        raise NotImplementedError\n\n\nclass HelloHandler(SessionListener):\n\n    def __init__(self, init_cb, error_cb):\n        self._init_cb = init_cb\n        self._error_cb = error_cb\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if (tag == qualify(\"hello\")) or (tag == \"hello\"):\n            try:\n                id, capabilities = HelloHandler.parse(raw)\n            except Exception as e:\n                self._error_cb(e)\n            else:\n                self._init_cb(id, capabilities)\n\n    def errback(self, err):\n        self._error_cb(err)\n\n    @staticmethod\n    def build(capabilities, device_handler):\n        \"Given a list of capability URI's returns <hello> message XML string\"\n        if device_handler:\n            # This is used as kwargs dictionary for lxml's Element() function.\n            # Therefore the arg-name (\"nsmap\") is used as key here.\n            xml_namespace_kwargs = { \"nsmap\" : device_handler.get_xml_base_namespace_dict() }\n        else:\n            xml_namespace_kwargs = {}\n        hello = new_ele(\"hello\", **xml_namespace_kwargs)\n        caps = sub_ele(hello, \"capabilities\")\n        def fun(uri): sub_ele(caps, \"capability\").text = uri\n        #python3 changes\n        if sys.version < '3':\n            map(fun, capabilities)\n        else:\n            list(map(fun, capabilities))\n        return to_xml(hello)\n\n    @staticmethod\n    def parse(raw):\n        \"Returns tuple of (session-id (str), capabilities (Capabilities)\"\n        sid, capabilities = 0, []\n        root = to_ele(raw)\n        for child in root.getchildren():\n            if child.tag == qualify(\"session-id\") or child.tag == \"session-id\":\n                sid = child.text\n            elif child.tag == qualify(\"capabilities\") or child.tag == \"capabilities\" :\n                for cap in child.getchildren():\n                    if cap.tag == qualify(\"capability\") or cap.tag == \"capability\":\n                        capabilities.append(cap.text)\n        return sid, Capabilities(capabilities)\n\n\nclass NotificationHandler(SessionListener):\n    def __init__(self, notification_q):\n        self._notification_q = notification_q\n\n    def callback(self, root, raw):\n        tag, _ = root\n        if tag == qualify('notification', NETCONF_NOTIFICATION_NS):\n            self._notification_q.put(Notification(raw))\n\n    def errback(self, _):\n        pass\n",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/transport/ssh.py": "# Copyright 2012 Vaibhav Bajpai\n# Copyright 2009 Shikhar Bhushan\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport base64\nimport getpass\nimport os\nimport re\nimport six\nimport sys\nimport socket\nimport threading\nfrom binascii import hexlify\n\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\n\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\n\nimport paramiko\n\nfrom ncclient.transport.errors import AuthenticationError, SSHError, SSHUnknownHostError\nfrom ncclient.transport.session import Session\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport logging\nlogger = logging.getLogger(\"ncclient.transport.ssh\")\n\nPORT_NETCONF_DEFAULT = 830\n\nBUF_SIZE = 4096\n\n#\n# Define delimiters for chunks and messages for netconf 1.1 chunk enoding.\n# When matched:\n#\n# * result.group(0) will contain whole matched string\n# * result.group(1) will contain the digit string for a chunk\n# * result.group(2) will be defined if '##' found\n#\nRE_NC11_DELIM = re.compile(br'\\n(?:#([0-9]+)|(##))\\n')\n\n\ndef default_unknown_host_cb(host, fingerprint):\n    \"\"\"An unknown host callback returns `True` if it finds the key acceptable, and `False` if not.\n\n    This default callback always returns `False`, which would lead to :meth:`connect` raising a :exc:`SSHUnknownHost` exception.\n\n    Supply another valid callback if you need to verify the host key programmatically.\n\n    *host* is the hostname that needs to be verified\n\n    *fingerprint* is a hex string representing the host key fingerprint, colon-delimited e.g. `\"4b:69:6c:72:6f:79:20:77:61:73:20:68:65:72:65:21\"`\n    \"\"\"\n    return False\n\n\ndef _colonify(fp):\n    fp = fp.decode('UTF-8')\n    finga = fp[:2]\n    for idx in range(2, len(fp), 2):\n        finga += \":\" + fp[idx:idx+2]\n    return finga\n\n\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\n\n\nclass SSHSession(Session):\n\n    \"Implements a :rfc:`4742` NETCONF session over SSH.\"\n\n    def __init__(self, device_handler):\n        capabilities = Capabilities(device_handler.get_capabilities())\n        Session.__init__(self, capabilities)\n        self._host = None\n        self._host_keys = paramiko.HostKeys()\n        self._transport = None\n        self._connected = False\n        self._channel = None\n        self._channel_id = None\n        self._channel_name = None\n        self._buffer = StringIO()\n        self._device_handler = device_handler\n        self._message_list = []\n        self._closing = threading.Event()\n        self.parser = DefaultXMLParser(self)  # SAX or DOM parser\n\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n\n    def _dispatch_message(self, raw):\n        # Provide basic response message\n        self.logger.info(\"Received message from host\")\n        # Provide complete response from host at debug log level\n        self.logger.debug(\"Received:\\n%s\", raw)\n        return super(SSHSession, self)._dispatch_message(raw)\n\n    def _parse(self):\n        \"Messages ae delimited by MSG_DELIM. The buffer could have grown by a maximum of BUF_SIZE bytes everytime this method is called. Retains state across method calls and if a byte has been read it will not be considered again.\"\n        return self.parser._parse10()\n\n    def load_known_hosts(self, filename=None):\n\n        \"\"\"Load host keys from an openssh :file:`known_hosts`-style file. Can\n        be called multiple times.\n\n        If *filename* is not specified, looks in the default locations i.e. :file:`~/.ssh/known_hosts` and :file:`~/ssh/known_hosts` for Windows.\n        \"\"\"\n\n        if filename is None:\n            filename = os.path.expanduser('~/.ssh/known_hosts')\n            try:\n                self._host_keys.load(filename)\n            except IOError:\n                # for windows\n                filename = os.path.expanduser('~/ssh/known_hosts')\n                try:\n                    self._host_keys.load(filename)\n                except IOError:\n                    pass\n        else:\n            self._host_keys.load(filename)\n\n    def close(self):\n        self._closing.set()\n        if self._transport.is_active():\n            self._transport.close()\n\n        # Wait for the transport thread to close.\n        while self.is_alive() and (self is not threading.current_thread()):\n            self.join(10)\n\n        if self._channel:\n            self._channel.close()\n        self._channel = None\n        self._connected = False\n\n    # REMEMBER to update transport.rst if sig. changes, since it is hardcoded there\n    def connect(\n            self,\n            host,\n            port                = PORT_NETCONF_DEFAULT,\n            timeout             = None,\n            unknown_host_cb     = default_unknown_host_cb,\n            username            = None,\n            password            = None,\n            key_filename        = None,\n            allow_agent         = True,\n            hostkey_verify      = True,\n            hostkey_b64         = None,\n            look_for_keys       = True,\n            ssh_config          = None,\n            sock_fd             = None,\n            bind_addr           = None,\n            sock                = None,\n            keepalive           = None,\n            environment         = None):\n\n        \"\"\"Connect via SSH and initialize the NETCONF session. First attempts the publickey authentication method and then password authentication.\n\n        To disable attempting publickey authentication altogether, call with *allow_agent* and *look_for_keys* as `False`.\n\n        *host* is the hostname or IP address to connect to\n\n        *port* is by default 830 (PORT_NETCONF_DEFAULT), but some devices use the default SSH port of 22 so this may need to be specified\n\n        *timeout* is an optional timeout for socket connect\n\n        *unknown_host_cb* is called when the server host key is not recognized. It takes two arguments, the hostname and the fingerprint (see the signature of :func:`default_unknown_host_cb`)\n\n        *username* is the username to use for SSH authentication\n\n        *password* is the password used if using password authentication, or the passphrase to use for unlocking keys that require it\n\n        *key_filename* is a filename where a the private key to be used can be found\n\n        *allow_agent* enables querying SSH agent (if found) for keys\n\n        *hostkey_verify* enables hostkey verification from ~/.ssh/known_hosts\n\n        *hostkey_b64* only connect when server presents a public hostkey matching this (obtain from server /etc/ssh/ssh_host_*pub or ssh-keyscan)\n\n        *look_for_keys* enables looking in the usual locations for ssh keys (e.g. :file:`~/.ssh/id_*`)\n\n        *ssh_config* enables parsing of an OpenSSH configuration file, if set to its path, e.g. :file:`~/.ssh/config` or to True (in this case, use :file:`~/.ssh/config`).\n\n        *sock_fd* is an already open socket which shall be used for this connection. Useful for NETCONF outbound ssh. Use host=None together with a valid sock_fd number\n\n        *bind_addr* is a (local) source IP address to use, must be reachable from the remote device.\n        \n        *sock* is an already open Python socket to be used for this connection.\n\n        *keepalive* Turn on/off keepalive packets (default is off). If this is set, after interval seconds without sending any data over the connection, a \"keepalive\" packet will be sent (and ignored by the remote host). This can be useful to keep connections alive over a NAT.\n\n        *environment* a dictionary containing the name and respective values to set\n        \"\"\"\n        if not (host or sock_fd or sock):\n            raise SSHError(\"Missing host, socket or socket fd\")\n\n        self._host = host\n\n        # Optionally, parse .ssh/config\n        config = {}\n        if ssh_config is True:\n            ssh_config = \"~/.ssh/config\" if sys.platform != \"win32\" else \"~/ssh/config\"\n        if ssh_config is not None:\n            config = paramiko.SSHConfig()\n            with open(os.path.expanduser(ssh_config)) as ssh_config_file_obj:\n                config.parse(ssh_config_file_obj)\n\n            # Save default Paramiko SSH port so it can be reverted\n            paramiko_default_ssh_port = paramiko.config.SSH_PORT\n\n            # Change the default SSH port to the port specified by the user so expand_variables\n            # replaces %p with the passed in port rather than 22 (the defauld paramiko.config.SSH_PORT)\n\n            paramiko.config.SSH_PORT = port\n\n            config = config.lookup(host)\n\n            # paramiko.config.SSHconfig::expand_variables is called by lookup so we can set the SSH port\n            # back to the default\n            paramiko.config.SSH_PORT = paramiko_default_ssh_port\n\n            host = config.get(\"hostname\", host)\n            if username is None:\n                username = config.get(\"user\")\n            if key_filename is None:\n                key_filename = config.get(\"identityfile\")\n            if timeout is None:\n                timeout = config.get(\"connecttimeout\")\n                if timeout:\n                    timeout = int(timeout)\n\n        if hostkey_verify:\n            userknownhostsfile = config.get(\"userknownhostsfile\")\n            if userknownhostsfile:\n                self.load_known_hosts(os.path.expanduser(userknownhostsfile))\n            else:\n                self.load_known_hosts()\n\n        if username is None:\n            username = getpass.getuser()\n\n        if sock_fd is None and sock is None:\n            proxycommand = config.get(\"proxycommand\")\n            if proxycommand:\n                self.logger.debug(\"Configuring Proxy. %s\", proxycommand)\n                if not isinstance(proxycommand, six.string_types):\n                  proxycommand = [os.path.expanduser(elem) for elem in proxycommand]\n                else:\n                  proxycommand = os.path.expanduser(proxycommand)\n                sock = paramiko.proxy.ProxyCommand(proxycommand)\n            else:\n                for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM):\n                    af, socktype, proto, canonname, sa = res\n                    try:\n                        sock = socket.socket(af, socktype, proto)\n                        sock.settimeout(timeout)\n                    except socket.error:\n                        continue\n                    try:\n                        if bind_addr:\n                            sock.bind((bind_addr, 0))\n                        sock.connect(sa)\n                    except socket.error:\n                        sock.close()\n                        continue\n                    break\n                else:\n                    raise SSHError(\"Could not open socket to %s:%s\" % (host, port))\n        elif sock is None:\n            if sys.version_info[0] < 3:\n                s = socket.fromfd(int(sock_fd), socket.AF_INET, socket.SOCK_STREAM)\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, _sock=s)\n            else:\n                sock = socket.fromfd(int(sock_fd), socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n\n        self._transport = paramiko.Transport(sock)\n        self._transport.set_log_channel(logger.name)\n        if config.get(\"compression\") == 'yes':\n            self._transport.use_compression()\n\n        if hostkey_b64:\n            # If we need to connect with a specific hostkey, negotiate for only its type\n            hostkey_obj = None\n            for key_cls in [paramiko.DSSKey, paramiko.Ed25519Key, paramiko.RSAKey, paramiko.ECDSAKey]:\n                try:\n                    hostkey_obj = key_cls(data=base64.b64decode(hostkey_b64))\n                except paramiko.SSHException:\n                    # Not a key of this type - try the next\n                    pass\n            if not hostkey_obj:\n                # We've tried all known host key types and haven't found a suitable one to use - bail\n                raise SSHError(\"Couldn't find suitable paramiko key class for host key %s\" % hostkey_b64)\n            self._transport._preferred_keys = [hostkey_obj.get_name()]\n        elif self._host_keys:\n            # Else set preferred host keys to those we possess for the host\n            # (avoids situation where known_hosts contains a valid key for the host, but that key type is not selected during negotiation)\n            known_host_keys_for_this_host = self._host_keys.lookup(host) or {}\n            host_port = '[%s]:%s' % (host, port)\n            known_host_keys_for_this_host.update(self._host_keys.lookup(host_port) or {})\n            if known_host_keys_for_this_host:\n                self._transport._preferred_keys = list(known_host_keys_for_this_host)\n\n        # Connect\n        try:\n            self._transport.start_client()\n        except paramiko.SSHException as e:\n            raise SSHError('Negotiation failed: %s' % e)\n\n        if hostkey_verify:\n            server_key_obj = self._transport.get_remote_server_key()\n            fingerprint = _colonify(hexlify(server_key_obj.get_fingerprint()))\n\n            is_known_host = False\n\n            # For looking up entries for nonstandard (22) ssh ports in known_hosts\n            # we enclose host in brackets and append port number\n            known_hosts_lookups = [host, '[%s]:%s' % (host, port)]\n\n            if hostkey_b64:\n                # If hostkey specified, remote host /must/ use that hostkey\n                if(hostkey_obj.get_name() == server_key_obj.get_name() and hostkey_obj.asbytes() == server_key_obj.asbytes()):\n                    is_known_host = True\n            else:\n                # Check known_hosts\n                is_known_host = any(self._host_keys.check(lookup, server_key_obj) for lookup in known_hosts_lookups)\n\n            if not is_known_host and not unknown_host_cb(host, fingerprint):\n                raise SSHUnknownHostError(known_hosts_lookups[0], fingerprint)\n\n        # Authenticating with our private key/identity\n        if key_filename is None:\n            key_filenames = []\n        elif isinstance(key_filename, (str, bytes)):\n            key_filenames = [key_filename]\n        else:\n            key_filenames = key_filename\n\n        self._auth(username, password, key_filenames, allow_agent, look_for_keys)\n\n        self._connected = True      # there was no error authenticating\n        self._closing.clear()\n\n        if keepalive:\n            self._transport.set_keepalive(keepalive)\n\n        # TODO: leopoul: Review, test, and if needed rewrite this part\n        subsystem_names = self._device_handler.get_ssh_subsystem_names()\n        for subname in subsystem_names:\n            self._channel = self._transport.open_session()\n            self._channel_id = self._channel.get_id()\n            channel_name = \"%s-subsystem-%s\" % (subname, str(self._channel_id))\n            self._channel.set_name(channel_name)\n            if environment:\n                try:\n                    self._channel.update_environment(environment)\n                except paramiko.SSHException as e:\n                    self.logger.info(\"%s (environment update rejected)\", e)\n                    handle_exception = self._device_handler.handle_connection_exceptions(self)\n                    # Ignore the exception, since we continue to try the different\n                    # subsystem names until we find one that can connect.\n                    # have to handle exception for each vendor here\n                    if not handle_exception:\n                        continue\n            try:\n                self._channel.invoke_subsystem(subname)\n            except paramiko.SSHException as e:\n                self.logger.info(\"%s (subsystem request rejected)\", e)\n                handle_exception = self._device_handler.handle_connection_exceptions(self)\n                # Ignore the exception, since we continue to try the different\n                # subsystem names until we find one that can connect.\n                # have to handle exception for each vendor here\n                if not handle_exception:\n                    continue\n            self._channel_name = self._channel.get_name()\n            self._post_connect(timeout)\n            # for further upcoming RPC responses, vendor can chose their\n            # choice of parser. Say DOM or SAX\n            self.parser = self._device_handler.get_xml_parser(self)\n            return\n        raise SSHError(\"Could not open connection, possibly due to unacceptable\"\n                       \" SSH subsystem name.\")\n\n    def _auth(self, username, password, key_filenames, allow_agent,\n              look_for_keys):\n        saved_exception = None\n\n        for key_filename in key_filenames:\n            try:\n                key = paramiko.PKey.from_path(key_filename, password.encode(\"utf-8\"))\n                self.logger.debug(\"Trying key %s from %s\",\n                                  hexlify(key.get_fingerprint()),\n                                  key_filename)\n                self._transport.auth_publickey(username, key)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n\n        if allow_agent:\n            # resequence keys from agent using private key names\n            prepend_agent_keys=[]\n            append_agent_keys=list(paramiko.Agent().get_keys())\n\n            for key_filename in key_filenames:\n                pubkey_filename=key_filename.strip(\".pub\")+\".pub\"\n                try:\n                    file_key=paramiko.PublicBlob.from_file(pubkey_filename).key_blob\n                except (FileNotFoundError, ValueError):\n                    continue\n\n                for idx, agent_key in enumerate(append_agent_keys):\n                    if agent_key.asbytes() == file_key:\n                        self.logger.debug(\"Prioritising SSH agent key found in %s\",key_filename )\n                        prepend_agent_keys.append(append_agent_keys.pop(idx))\n                        break\n\n            agent_keys=tuple(prepend_agent_keys+append_agent_keys)\n\n            for key in agent_keys:\n                try:\n                    self.logger.debug(\"Trying SSH agent key %s\",\n                                      hexlify(key.get_fingerprint()))\n                    self._transport.auth_publickey(username, key)\n                    return\n                except Exception as e:\n                    saved_exception = e\n                    self.logger.debug(e)\n\n        keyfiles = []\n        if look_for_keys:\n            rsa_key = os.path.expanduser(\"~/.ssh/id_rsa\")\n            dsa_key = os.path.expanduser(\"~/.ssh/id_dsa\")\n            ecdsa_key = os.path.expanduser(\"~/.ssh/id_ecdsa\")\n            ed25519_key = os.path.expanduser(\"~/.ssh/id_ed25519\")\n            if os.path.isfile(rsa_key):\n                keyfiles.append(rsa_key)\n            if os.path.isfile(dsa_key):\n                keyfiles.append(dsa_key)\n            if os.path.isfile(ecdsa_key):\n                keyfiles.append(ecdsa_key)\n            if os.path.isfile(ed25519_key):\n                keyfiles.append(ed25519_key)\n            # look in ~/ssh/ for windows users:\n            rsa_key = os.path.expanduser(\"~/ssh/id_rsa\")\n            dsa_key = os.path.expanduser(\"~/ssh/id_dsa\")\n            ecdsa_key = os.path.expanduser(\"~/ssh/id_ecdsa\")\n            ed25519_key = os.path.expanduser(\"~/ssh/id_ed25519\")\n            if os.path.isfile(rsa_key):\n                keyfiles.append(rsa_key)\n            if os.path.isfile(dsa_key):\n                keyfiles.append(dsa_key)\n            if os.path.isfile(ecdsa_key):\n                keyfiles.append(ecdsa_key)\n            if os.path.isfile(ed25519_key):\n                keyfiles.append(ed25519_key)\n\n        for filename in keyfiles:\n            try:\n                key = paramiko.PKey.from_path(filename, password.encode(\"utf-8\"))\n                self.logger.debug(\"Trying discovered key %s in %s\",\n                                  hexlify(key.get_fingerprint()), filename)\n                self._transport.auth_publickey(username, key)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n\n        if password is not None:\n            try:\n                self._transport.auth_password(username, password)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n\n        if saved_exception is not None:\n            # need pep-3134 to do this right\n            raise AuthenticationError(repr(saved_exception))\n\n        raise AuthenticationError(\"No authentication methods available\")\n\n    def _transport_read(self):\n        return self._channel.recv(BUF_SIZE)\n\n    def _transport_write(self, data):\n        return self._channel.send(data)\n\n    def _transport_register(self, selector, event):\n        selector.register(self._channel, event)\n\n    def _send_ready(self):\n        return self._channel.send_ready()\n\n    @property\n    def host(self):\n        \"\"\"Host this session is connected to, or None if not connected.\"\"\"\n        if hasattr(self, '_host'):\n            return self._host\n        return None\n\n    @property\n    def transport(self):\n        \"Underlying `paramiko.Transport <http://www.lag.net/paramiko/docs/paramiko.Transport-class.html>`_ object. This makes it possible to call methods like :meth:`~paramiko.Transport.set_keepalive` on it.\"\n        return self._transport\n"
  },
  "GT_src_dict": {
    "ncclient/operations/rpc.py": {
      "RPCError.__init__": {
        "code": "    def __init__(self, raw, errs=None):\n        \"\"\"Initialize an instance of the `RPCError` class, which represents an error response from an RPC operation.\n\nParameters:\n- raw: The raw XML element containing the error information. This is of the XML type and is typically obtained from the response of a remote procedure call.\n- errs: An optional list of `RPCError` objects, used when multiple errors are returned.\n\nThis constructor extracts relevant error attributes (`error-type`, `error-tag`, `error-app-tag`, `error-severity`, `error-info`, `error-path`, and `error-message`) from the raw XML data. It populates attributes corresponding to these error types using the provided `tag_to_attr` mapping. If a list of errors is provided, it aggregates their details to generate a cumulative error message and defines the overall severity of the reported errors.\n\nThis method directly interacts with the `OperationError` class from the `ncclient.operations.errors` module, raising it when necessary based on the presence and severity of the errors encountered.\n\nAttributes:\n- _raw: Stores the raw XML error response.\n- _errlist: Keeps track of multiple error instances, if applicable.\n- severity: A string representing the highest level of severity encountered in the errors.\n- message: The aggregated message describing the errors.\n\nThis constructor utilizes the `six` module for compatibility with Python 2 and 3.\"\"\"\n        self._raw = raw\n        if errs is None:\n            self._errlist = None\n            for attr in six.itervalues(RPCError.tag_to_attr):\n                setattr(self, attr, None)\n            for subele in raw:\n                attr = RPCError.tag_to_attr.get(subele.tag, None)\n                if attr is not None:\n                    setattr(self, attr, subele.text if attr != '_info' else to_xml(subele))\n            if self.message is not None:\n                OperationError.__init__(self, self.message)\n            else:\n                OperationError.__init__(self, self.to_dict())\n        else:\n            self._errlist = errs\n            errlist = []\n            for err in errs:\n                if err.severity:\n                    errsev = err.severity\n                else:\n                    errsev = 'undefined'\n                if err.message:\n                    errmsg = err.message\n                else:\n                    errmsg = 'not an error message in the reply. Enable debug'\n                errordict = {'severity': errsev, 'message': errmsg}\n                errlist.append(errordict)\n            self._severity = 'warning'\n            self._message = '\\n'.join(['%s: %s' % (err['severity'].strip(), err['message'].strip()) for err in errlist])\n            self.errors = errs\n            has_error = filter(lambda higherr: higherr['severity'] == 'error', errlist)\n            if has_error:\n                self._severity = 'error'\n            OperationError.__init__(self, self.message)",
        "docstring": "Initialize an instance of the `RPCError` class, which represents an error response from an RPC operation.\n\nParameters:\n- raw: The raw XML element containing the error information. This is of the XML type and is typically obtained from the response of a remote procedure call.\n- errs: An optional list of `RPCError` objects, used when multiple errors are returned.\n\nThis constructor extracts relevant error attributes (`error-type`, `error-tag`, `error-app-tag`, `error-severity`, `error-info`, `error-path`, and `error-message`) from the raw XML data. It populates attributes corresponding to these error types using the provided `tag_to_attr` mapping. If a list of errors is provided, it aggregates their details to generate a cumulative error message and defines the overall severity of the reported errors.\n\nThis method directly interacts with the `OperationError` class from the `ncclient.operations.errors` module, raising it when necessary based on the presence and severity of the errors encountered.\n\nAttributes:\n- _raw: Stores the raw XML error response.\n- _errlist: Keeps track of multiple error instances, if applicable.\n- severity: A string representing the highest level of severity encountered in the errors.\n- message: The aggregated message describing the errors.\n\nThis constructor utilizes the `six` module for compatibility with Python 2 and 3.",
        "signature": "def __init__(self, raw, errs=None):",
        "type": "Method",
        "class_signature": "class RPCError(OperationError):"
      },
      "RPCError.to_dict": {
        "code": "    def to_dict(self):\n        \"\"\"Converts the attributes of the `RPCError` instance into a dictionary format.\n\nThis method collects the relevant error information (such as error type, tag, application tag, severity, path, message, and info) and organizes it into a dictionary. It utilizes the `tag_to_attr` mapping defined in the `RPCError` class to correlate XML tags with instance attributes.\n\nReturns:\n    dict: A dictionary representation of the `RPCError` instance, where keys are attribute names (excluding the leading underscore) and values are the corresponding attribute values.\n\nDependencies:\n- `RPCError.tag_to_attr`: A constant dictionary that maps XML error tags to the respective attributes of the `RPCError` class.\n- `six.itervalues`: Used to iterate over the values of the `tag_to_attr` dictionary for retrieving attribute names dynamically.\"\"\"\n        return dict([(attr[1:], getattr(self, attr)) for attr in six.itervalues(RPCError.tag_to_attr)])",
        "docstring": "Converts the attributes of the `RPCError` instance into a dictionary format.\n\nThis method collects the relevant error information (such as error type, tag, application tag, severity, path, message, and info) and organizes it into a dictionary. It utilizes the `tag_to_attr` mapping defined in the `RPCError` class to correlate XML tags with instance attributes.\n\nReturns:\n    dict: A dictionary representation of the `RPCError` instance, where keys are attribute names (excluding the leading underscore) and values are the corresponding attribute values.\n\nDependencies:\n- `RPCError.tag_to_attr`: A constant dictionary that maps XML error tags to the respective attributes of the `RPCError` class.\n- `six.itervalues`: Used to iterate over the values of the `tag_to_attr` dictionary for retrieving attribute names dynamically.",
        "signature": "def to_dict(self):",
        "type": "Method",
        "class_signature": "class RPCError(OperationError):"
      },
      "RPCError.severity": {
        "code": "    def severity(self):\n        \"\"\"@property\ndef severity(self):\"\"\"\n        'The contents of the `error-severity` element.'\n        return self._severity",
        "docstring": "@property\ndef severity(self):",
        "signature": "def severity(self):",
        "type": "Method",
        "class_signature": "class RPCError(OperationError):"
      },
      "RPCError.message": {
        "code": "    def message(self):\n        \"\"\"@property\ndef message(self):\"\"\"\n        'The contents of the `error-message` element if present or `None`.'\n        return self._message",
        "docstring": "@property\ndef message(self):",
        "signature": "def message(self):",
        "type": "Method",
        "class_signature": "class RPCError(OperationError):"
      }
    },
    "ncclient/xml_.py": {
      "_get_parser": {
        "code": "def _get_parser(huge_tree=False):\n    \"\"\"Returns an XML parser based on the specified options for handling large XML documents.\n\nParameters:\n- huge_tree (bool): If set to True, the function returns a parser configured for handling very deep trees and long text content using the `huge_parser`. If False, it returns the standard `parser`.\n\nReturns:\n- etree.XMLParser: An instance of `lxml.etree.XMLParser`, either the `huge_parser` or the standard `parser`, as defined at the module level.\n\nDependencies:\n- `parser` and `huge_parser` are defined globally in the module and provide different configurations for XML parsing depending on the size of the XML document.\"\"\"\n    return huge_parser if huge_tree else parser",
        "docstring": "Returns an XML parser based on the specified options for handling large XML documents.\n\nParameters:\n- huge_tree (bool): If set to True, the function returns a parser configured for handling very deep trees and long text content using the `huge_parser`. If False, it returns the standard `parser`.\n\nReturns:\n- etree.XMLParser: An instance of `lxml.etree.XMLParser`, either the `huge_parser` or the standard `parser`, as defined at the module level.\n\nDependencies:\n- `parser` and `huge_parser` are defined globally in the module and provide different configurations for XML parsing depending on the size of the XML document.",
        "signature": "def _get_parser(huge_tree=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_ele": {
        "code": "def to_ele(x, huge_tree=False):\n    \"\"\"Convert and return an `ElementTree.Element` for the provided XML document *x*. If *x* is already an `Element`, it is returned directly. If *huge_tree* is set to True, the XML is parsed to accommodate very deep trees or lengthy text content. The function utilizes the `etree.fromstring` method from the `lxml` library, and the parser used is determined by the `_get_parser()` function, which returns either the standard or a huge tree parser. This function requires Python's sys module to determine the Python version for compatibility.\"\"\"\n    'Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\\n\\n    *huge_tree*: parse XML with very deep trees and very long text content\\n    '\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))",
        "docstring": "Convert and return an `ElementTree.Element` for the provided XML document *x*. If *x* is already an `Element`, it is returned directly. If *huge_tree* is set to True, the XML is parsed to accommodate very deep trees or lengthy text content. The function utilizes the `etree.fromstring` method from the `lxml` library, and the parser used is determined by the `_get_parser()` function, which returns either the standard or a huge tree parser. This function requires Python's sys module to determine the Python version for compatibility.",
        "signature": "def to_ele(x, huge_tree=False):",
        "type": "Function",
        "class_signature": null
      }
    },
    "ncclient/transport/parser.py": {
      "DefaultXMLParser.__init__": {
        "code": "    def __init__(self, session):\n        \"\"\"Initializes a DefaultXMLParser instance for parsing XML data from a networking device over a session.\n\n    :param session: An SSH session object that manages the connection to the networking device.\n                    This session interacts with various components of the netconf transport layer,\n                    allowing the parser to process incoming RPC responses effectively.\n\n    Attributes:\n        _session (Session): Stores the provided session object for future parsing operations and message handling.\n        _parsing_pos10 (int): Keeps track of the current position in the buffer during parsing of messages\n                               adhering to Netconf v1.0, initialized to 0.\n        logger (SessionLoggerAdapter): A logging adapter that enhances logging capabilities for session-specific events.\n\n    The constructor does not return a value but sets up the necessary attributes for the parser to function correctly.\"\"\"\n        '\\n        DOM Parser\\n\\n        :param session: ssh session object\\n        '\n        self._session = session\n        self._parsing_pos10 = 0\n        self.logger = SessionLoggerAdapter(logger, {'session': self._session})",
        "docstring": "Initializes a DefaultXMLParser instance for parsing XML data from a networking device over a session.\n\n:param session: An SSH session object that manages the connection to the networking device.\n                This session interacts with various components of the netconf transport layer,\n                allowing the parser to process incoming RPC responses effectively.\n\nAttributes:\n    _session (Session): Stores the provided session object for future parsing operations and message handling.\n    _parsing_pos10 (int): Keeps track of the current position in the buffer during parsing of messages\n                           adhering to Netconf v1.0, initialized to 0.\n    logger (SessionLoggerAdapter): A logging adapter that enhances logging capabilities for session-specific events.\n\nThe constructor does not return a value but sets up the necessary attributes for the parser to function correctly.",
        "signature": "def __init__(self, session):",
        "type": "Method",
        "class_signature": "class DefaultXMLParser(object):"
      }
    },
    "ncclient/capabilities.py": {
      "Capabilities.__init__": {
        "code": "    def __init__(self, capabilities):\n        \"\"\"Initializes a Capabilities object with a set of capability URIs.\n\nParameters:\ncapabilities (list of str): A list of capability URIs that the NETCONF client or server supports. Each URI is expected to be in a specific format that can be parsed to represent a capability.\n\nThis method creates an empty dictionary `self._dict` to hold capabilities and then populates it by adding each URI provided in the capabilities list. The `add` method is invoked for each URI, which processes the URI to create a corresponding Capability object. It is important to ensure that valid URIs are passed, as invalid ones may raise errors during parsing.\n\nSide Effects:\nModifies the internal state of the Capabilities instance by populating `self._dict` with Capability objects derived from the provided URIs.\"\"\"\n        self._dict = {}\n        for uri in capabilities:\n            self.add(uri)",
        "docstring": "Initializes a Capabilities object with a set of capability URIs.\n\nParameters:\ncapabilities (list of str): A list of capability URIs that the NETCONF client or server supports. Each URI is expected to be in a specific format that can be parsed to represent a capability.\n\nThis method creates an empty dictionary `self._dict` to hold capabilities and then populates it by adding each URI provided in the capabilities list. The `add` method is invoked for each URI, which processes the URI to create a corresponding Capability object. It is important to ensure that valid URIs are passed, as invalid ones may raise errors during parsing.\n\nSide Effects:\nModifies the internal state of the Capabilities instance by populating `self._dict` with Capability objects derived from the provided URIs.",
        "signature": "def __init__(self, capabilities):",
        "type": "Method",
        "class_signature": "class Capabilities(object):"
      },
      "Capabilities.add": {
        "code": "    def add(self, uri):\n        \"\"\"Adds a capability represented by a URI to the internal dictionary of capabilities.\n\nParameters:\n- uri (str): The capability URI to be added. This URI will be processed to create a `Capability` object, which includes a namespace and any associated parameters.\n\nReturns:\n- None\n\nSide Effects:\n- Modifies the internal dictionary `_dict` that stores capabilities, associating the provided URI with a `Capability` instance created using the `Capability.from_uri()` class method.\n\nDependencies:\n- Interacts with the `Capability` class, specifically its `from_uri` method which is used to parse the URI and generate the corresponding capability object.\"\"\"\n        'Add a capability.'\n        self._dict[uri] = Capability.from_uri(uri)",
        "docstring": "Adds a capability represented by a URI to the internal dictionary of capabilities.\n\nParameters:\n- uri (str): The capability URI to be added. This URI will be processed to create a `Capability` object, which includes a namespace and any associated parameters.\n\nReturns:\n- None\n\nSide Effects:\n- Modifies the internal dictionary `_dict` that stores capabilities, associating the provided URI with a `Capability` instance created using the `Capability.from_uri()` class method.\n\nDependencies:\n- Interacts with the `Capability` class, specifically its `from_uri` method which is used to parse the URI and generate the corresponding capability object.",
        "signature": "def add(self, uri):",
        "type": "Method",
        "class_signature": "class Capabilities(object):"
      },
      "Capability.__init__": {
        "code": "    def __init__(self, namespace_uri, parameters=None):\n        \"\"\"Initializes a Capability instance with a specified namespace URI and optional parameters.\n\n    Parameters:\n    - namespace_uri (str): The namespace URI representing the capability.\n    - parameters (dict, optional): A dictionary of parameters associated with the capability. Defaults to an empty dictionary if not provided.\n\n    Attributes:\n    - namespace_uri (str): Stores the provided namespace URI.\n    - parameters (dict): Stores the provided parameters or an empty dictionary.\n\n    This constructor facilitates the creation of Capability objects that represent individual capabilities in NETCONF communication, allowing for the encapsulation of both the capability's namespace and any associated parameters.\"\"\"\n        self.namespace_uri = namespace_uri\n        self.parameters = parameters or {}",
        "docstring": "Initializes a Capability instance with a specified namespace URI and optional parameters.\n\nParameters:\n- namespace_uri (str): The namespace URI representing the capability.\n- parameters (dict, optional): A dictionary of parameters associated with the capability. Defaults to an empty dictionary if not provided.\n\nAttributes:\n- namespace_uri (str): Stores the provided namespace URI.\n- parameters (dict): Stores the provided parameters or an empty dictionary.\n\nThis constructor facilitates the creation of Capability objects that represent individual capabilities in NETCONF communication, allowing for the encapsulation of both the capability's namespace and any associated parameters.",
        "signature": "def __init__(self, namespace_uri, parameters=None):",
        "type": "Method",
        "class_signature": "class Capability(object):"
      },
      "Capability.from_uri": {
        "code": "    def from_uri(cls, uri):\n        \"\"\"Class method that creates a Capability instance from a given URI. The URI can optionally include a query string for parameters, which are parsed and stored in the instance. The method splits the URI into the namespace and parameter string, then utilizes the _parse_parameter_string helper to generate the parameters while handling any parsing errors. If no parameters are present, only the namespace is set. Returns a Capability object initialized with the namespace URI and parameters.\n\nParameters:\n- uri (str): The URI representing the capability, which may include a query string with parameters.\n\nReturns:\n- Capability: An instance of the Capability class populated with the namespace URI and any parsed parameters.\n\nDependencies:\n- _parse_parameter_string: A helper function that parses the parameter string and yields Parameter objects, logging errors for invalid parameters.\"\"\"\n        split_uri = uri.split('?')\n        namespace_uri = split_uri[0]\n        capability = cls(namespace_uri)\n        try:\n            param_string = split_uri[1]\n        except IndexError:\n            return capability\n        capability.parameters = {param.key: param.value for param in _parse_parameter_string(param_string, uri)}\n        return capability",
        "docstring": "Class method that creates a Capability instance from a given URI. The URI can optionally include a query string for parameters, which are parsed and stored in the instance. The method splits the URI into the namespace and parameter string, then utilizes the _parse_parameter_string helper to generate the parameters while handling any parsing errors. If no parameters are present, only the namespace is set. Returns a Capability object initialized with the namespace URI and parameters.\n\nParameters:\n- uri (str): The URI representing the capability, which may include a query string with parameters.\n\nReturns:\n- Capability: An instance of the Capability class populated with the namespace URI and any parsed parameters.\n\nDependencies:\n- _parse_parameter_string: A helper function that parses the parameter string and yields Parameter objects, logging errors for invalid parameters.",
        "signature": "def from_uri(cls, uri):",
        "type": "Method",
        "class_signature": "class Capability(object):"
      },
      "_parse_parameter_string": {
        "code": "def _parse_parameter_string(string, uri):\n    \"\"\"Parse a parameter string from a capability URI and yield individual parameters as _Parameter instances.\n\nArgs:\n    string (str): The parameter string containing key-value pairs separated by '&'.\n    uri (str): The original capability URI for logging purposes, in case of invalid parameters.\n\nYields:\n    _Parameter: Instances of _Parameter for each valid key-value pair parsed from the string.\n\nSide Effects:\n    Logs an error message using the logger if any parameter is invalid. The logger is configured at the start of the code with the name \"ncclient.capabilities\".\"\"\"\n    for param_string in string.split('&'):\n        try:\n            yield _Parameter.from_string(param_string)\n        except _InvalidParameter:\n            logger.error(\"Invalid parameter '{param}' in capability URI '{uri}'\".format(param=param_string, uri=uri))",
        "docstring": "Parse a parameter string from a capability URI and yield individual parameters as _Parameter instances.\n\nArgs:\n    string (str): The parameter string containing key-value pairs separated by '&'.\n    uri (str): The original capability URI for logging purposes, in case of invalid parameters.\n\nYields:\n    _Parameter: Instances of _Parameter for each valid key-value pair parsed from the string.\n\nSide Effects:\n    Logs an error message using the logger if any parameter is invalid. The logger is configured at the start of the code with the name \"ncclient.capabilities\".",
        "signature": "def _parse_parameter_string(string, uri):",
        "type": "Function",
        "class_signature": null
      },
      "_Parameter.__init__": {
        "code": "    def __init__(self, key, value):\n        \"\"\"Initializes a _Parameter instance representing a specific key-value pair for capability parameters.\n\nParameters:\n- key (str): The parameter key, extracted from the capability URI.\n- value (str): The parameter value, also derived from the capability URI.\n\nThis constructor sets the `key` and `value` attributes for the _Parameter instance, which are used in the capability representation within the Capability class. The _Parameter class is intended for managing parameters in capability URIs, and instances of _Parameter are created when parsing parameters from a URI string in the _parse_parameter_string function. No constants are used directly within this method.\"\"\"\n        self.key = key\n        self.value = value",
        "docstring": "Initializes a _Parameter instance representing a specific key-value pair for capability parameters.\n\nParameters:\n- key (str): The parameter key, extracted from the capability URI.\n- value (str): The parameter value, also derived from the capability URI.\n\nThis constructor sets the `key` and `value` attributes for the _Parameter instance, which are used in the capability representation within the Capability class. The _Parameter class is intended for managing parameters in capability URIs, and instances of _Parameter are created when parsing parameters from a URI string in the _parse_parameter_string function. No constants are used directly within this method.",
        "signature": "def __init__(self, key, value):",
        "type": "Method",
        "class_signature": "class _Parameter(object):"
      },
      "_Parameter.from_string": {
        "code": "    def from_string(cls, string):\n        \"\"\"Transforms a query parameter string into a _Parameter instance. \n\nThis class method takes a string formatted as \"key=value\" and splits it into a key and a value. If the string cannot be split correctly due to the absence of an equal sign, it raises an _InvalidParameter exception.\n\nParameters:\n- string (str): The input string representing the parameter in the format \"key=value\".\n\nReturns:\n- _Parameter: An instance of the _Parameter class initialized with the extracted key and value.\n\nRaises:\n- _InvalidParameter: If the input string does not contain exactly one equal sign for splitting.\"\"\"\n        try:\n            key, value = string.split('=')\n        except ValueError:\n            raise _InvalidParameter\n        return cls(key, value)",
        "docstring": "Transforms a query parameter string into a _Parameter instance. \n\nThis class method takes a string formatted as \"key=value\" and splits it into a key and a value. If the string cannot be split correctly due to the absence of an equal sign, it raises an _InvalidParameter exception.\n\nParameters:\n- string (str): The input string representing the parameter in the format \"key=value\".\n\nReturns:\n- _Parameter: An instance of the _Parameter class initialized with the extracted key and value.\n\nRaises:\n- _InvalidParameter: If the input string does not contain exactly one equal sign for splitting.",
        "signature": "def from_string(cls, string):",
        "type": "Method",
        "class_signature": "class _Parameter(object):"
      }
    },
    "ncclient/devices/junos.py": {
      "JunosDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initialize the JunosDeviceHandler with specified device parameters.\n\nThis constructor method sets up the JunosDeviceHandler instance by calling the superclass \n(DefaultDeviceHandler) constructor and initializing a dictionary for error transformation \nrelated to reply parsing. Specifically, it associates the `GetSchemaReply` class with a \nfixing function `fix_get_schema_reply`, which addresses namespace issues that may arise \nwith certain Junos versions.\n\nParameters:\n    device_params (dict): A dictionary containing device configuration parameters required \n    for establishing a NETCONF connection and defining specific device behavior.\n\nAttributes:\n    __reply_parsing_error_transform_by_cls (dict): A mapping of reply classes to functions \n    that can transform the replies to accommodate for known issues or non-compliance with \n    RFCs.\n\nDependencies:\n    This class relies on the `DefaultDeviceHandler` class for general functionality and \n    interaction with the NETCONF protocol. The specific reply handling is executed in \n    conjunction with the `fix_get_schema_reply` function which is defined in the \n    same module.\"\"\"\n        super(JunosDeviceHandler, self).__init__(device_params)\n        self.__reply_parsing_error_transform_by_cls = {GetSchemaReply: fix_get_schema_reply}",
        "docstring": "Initialize the JunosDeviceHandler with specified device parameters.\n\nThis constructor method sets up the JunosDeviceHandler instance by calling the superclass \n(DefaultDeviceHandler) constructor and initializing a dictionary for error transformation \nrelated to reply parsing. Specifically, it associates the `GetSchemaReply` class with a \nfixing function `fix_get_schema_reply`, which addresses namespace issues that may arise \nwith certain Junos versions.\n\nParameters:\n    device_params (dict): A dictionary containing device configuration parameters required \n    for establishing a NETCONF connection and defining specific device behavior.\n\nAttributes:\n    __reply_parsing_error_transform_by_cls (dict): A mapping of reply classes to functions \n    that can transform the replies to accommodate for known issues or non-compliance with \n    RFCs.\n\nDependencies:\n    This class relies on the `DefaultDeviceHandler` class for general functionality and \n    interaction with the NETCONF protocol. The specific reply handling is executed in \n    conjunction with the `fix_get_schema_reply` function which is defined in the \n    same module.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      },
      "JunosDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Provides additional NETCONF operations specific to Juniper devices.\n\nThis method constructs and returns a dictionary mapping operation names to their corresponding \nclasses, which handle various NETCONF operations such as executing RPC commands, managing \nconfigurations, and controlling device states.\n\nReturns:\n    dict: A dictionary with operation names as keys and associated operation classes as values.\n           The key-value pairs include:\n           - \"rpc\": ExecuteRpc\n           - \"get_configuration\": GetConfiguration\n           - \"load_configuration\": LoadConfiguration\n           - \"compare_configuration\": CompareConfiguration\n           - \"command\": Command\n           - \"reboot\": Reboot\n           - \"halt\": Halt\n           - \"commit\": Commit\n           - \"rollback\": Rollback\n\nDependencies:\n    The operation classes (ExecuteRpc, GetConfiguration, LoadConfiguration, \n    CompareConfiguration, Command, Reboot, Halt, Commit, and Rollback) are imported \n    from the `ncclient.operations.third_party.juniper.rpc` module.\"\"\"\n        dict = {}\n        dict['rpc'] = ExecuteRpc\n        dict['get_configuration'] = GetConfiguration\n        dict['load_configuration'] = LoadConfiguration\n        dict['compare_configuration'] = CompareConfiguration\n        dict['command'] = Command\n        dict['reboot'] = Reboot\n        dict['halt'] = Halt\n        dict['commit'] = Commit\n        dict['rollback'] = Rollback\n        return dict",
        "docstring": "Provides additional NETCONF operations specific to Juniper devices.\n\nThis method constructs and returns a dictionary mapping operation names to their corresponding \nclasses, which handle various NETCONF operations such as executing RPC commands, managing \nconfigurations, and controlling device states.\n\nReturns:\n    dict: A dictionary with operation names as keys and associated operation classes as values.\n           The key-value pairs include:\n           - \"rpc\": ExecuteRpc\n           - \"get_configuration\": GetConfiguration\n           - \"load_configuration\": LoadConfiguration\n           - \"compare_configuration\": CompareConfiguration\n           - \"command\": Command\n           - \"reboot\": Reboot\n           - \"halt\": Halt\n           - \"commit\": Commit\n           - \"rollback\": Rollback\n\nDependencies:\n    The operation classes (ExecuteRpc, GetConfiguration, LoadConfiguration, \n    CompareConfiguration, Command, Reboot, Halt, Commit, and Rollback) are imported \n    from the `ncclient.operations.third_party.juniper.rpc` module.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      },
      "JunosDeviceHandler.perform_qualify_check": {
        "code": "    def perform_qualify_check(self):\n        \"\"\"Checks whether the current device meets any qualification requirements for operations.\n\nThis method is intended to provide a mechanism for determining the qualification of a device\nfor performing certain operations. In this implementation, it always returns False, indicating\nthat no specific qualifications are enforced or required at this level of the Junos device handler.\n\nReturns:\n    bool: Always returns False, indicating that qualification checks are not implemented.\"\"\"\n        return False",
        "docstring": "Checks whether the current device meets any qualification requirements for operations.\n\nThis method is intended to provide a mechanism for determining the qualification of a device\nfor performing certain operations. In this implementation, it always returns False, indicating\nthat no specific qualifications are enforced or required at this level of the Junos device handler.\n\nReturns:\n    bool: Always returns False, indicating that qualification checks are not implemented.",
        "signature": "def perform_qualify_check(self):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      },
      "JunosDeviceHandler.handle_raw_dispatch": {
        "code": "    def handle_raw_dispatch(self, raw):\n        \"\"\"Handles the dispatch of raw XML responses from the Juniper device. The method checks for specific elements in the raw response to either modify the response format if it contains 'routing-engine' or to extract and transform any RPC errors present during capabilities exchange. \n\nParameters:\n- raw (str): The raw XML response string from the Juniper device.\n\nReturns:\n- str or RPCError: Returns a modified raw XML string if 'routing-engine' is found, or an RPCError object containing detailed error information if RPC errors are identified. If neither condition is met, returns False.\n\nThe method relies on regular expressions from the `re` module for string pattern matching and uses the `lxml.etree` module to parse and transform XML data. The `RPCError` class is imported from `ncclient.operations.rpc` and is used to encapsulate errors found in the input XML. The constant `'<ok/>'` is utilized as a marker in the response and is replaced to maintain proper XML structure.\"\"\"\n        if 'routing-engine' in raw:\n            raw = re.sub('<ok/>', '</routing-engine>\\n<ok/>', raw)\n            return raw\n        elif re.search('<rpc-reply>.*?</rpc-reply>.*</hello>?', raw, re.M | re.S):\n            errs = re.findall('<rpc-error>.*?</rpc-error>', raw, re.M | re.S)\n            err_list = []\n            if errs:\n                add_ns = '\\n                        <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n                          <xsl:output indent=\"yes\"/>\\n                            <xsl:template match=\"*\">\\n                            <xsl:element name=\"{local-name()}\" namespace=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\\n                            <xsl:apply-templates select=\"@*|node()\"/>\\n                            </xsl:element>\\n                          </xsl:template>\\n                        </xsl:stylesheet>'\n                for err in errs:\n                    doc = etree.ElementTree(etree.XML(err))\n                    xslt = etree.XSLT(etree.XML(add_ns))\n                    transformed_xml = etree.XML(etree.tostring(xslt(doc)))\n                    err_list.append(RPCError(transformed_xml))\n                return RPCError(to_ele('<rpc-reply>' + ''.join(errs) + '</rpc-reply>'), err_list)\n        else:\n            return False",
        "docstring": "Handles the dispatch of raw XML responses from the Juniper device. The method checks for specific elements in the raw response to either modify the response format if it contains 'routing-engine' or to extract and transform any RPC errors present during capabilities exchange. \n\nParameters:\n- raw (str): The raw XML response string from the Juniper device.\n\nReturns:\n- str or RPCError: Returns a modified raw XML string if 'routing-engine' is found, or an RPCError object containing detailed error information if RPC errors are identified. If neither condition is met, returns False.\n\nThe method relies on regular expressions from the `re` module for string pattern matching and uses the `lxml.etree` module to parse and transform XML data. The `RPCError` class is imported from `ncclient.operations.rpc` and is used to encapsulate errors found in the input XML. The constant `'<ok/>'` is utilized as a marker in the response and is replaced to maintain proper XML structure.",
        "signature": "def handle_raw_dispatch(self, raw):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      },
      "JunosDeviceHandler.handle_connection_exceptions": {
        "code": "    def handle_connection_exceptions(self, sshsession):\n        \"\"\"Handle connection exceptions for the NETCONF session with a Juniper device.\n\nThis method opens a new SSH channel for the session and sets its name using \nthe channel ID. It then executes a command to set the session to xml-mode \nfor NETCONF operations, specifically specifying the need for a trailer in the \nXML response.\n\nParameters:\n    sshsession: An active SSH session instance that manages the connection \n                to the Juniper device. It is expected to have a transport \n                layer that supports opening channels.\n\nReturns:\n    bool: Always returns True to indicate that the connection handling \n          was initiated.\n\nThis method interacts with the underlying transport mechanism of the \nNETCONF client, particularly using the `sshsession._transport` and \n`sshsession._channel` attributes. The `sshsession._channel_id` is used \nto uniquely identify the channel during interactions with the device.\"\"\"\n        c = sshsession._channel = sshsession._transport.open_channel(kind='session')\n        c.set_name('netconf-command-' + str(sshsession._channel_id))\n        c.exec_command('xml-mode netconf need-trailer')\n        return True",
        "docstring": "Handle connection exceptions for the NETCONF session with a Juniper device.\n\nThis method opens a new SSH channel for the session and sets its name using \nthe channel ID. It then executes a command to set the session to xml-mode \nfor NETCONF operations, specifically specifying the need for a trailer in the \nXML response.\n\nParameters:\n    sshsession: An active SSH session instance that manages the connection \n                to the Juniper device. It is expected to have a transport \n                layer that supports opening channels.\n\nReturns:\n    bool: Always returns True to indicate that the connection handling \n          was initiated.\n\nThis method interacts with the underlying transport mechanism of the \nNETCONF client, particularly using the `sshsession._transport` and \n`sshsession._channel` attributes. The `sshsession._channel_id` is used \nto uniquely identify the channel during interactions with the device.",
        "signature": "def handle_connection_exceptions(self, sshsession):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      },
      "JunosDeviceHandler.transform_reply": {
        "code": "    def transform_reply(self):\n        \"\"\"Generates an XSLT stylesheet for transforming XML replies from the Juniper device.\n\nThis method returns an XSLT stylesheet that defines how to transform XML nodes \nby copying elements and their attributes while maintaining their names. It \nensures compliant XML by removing unnecessary whitespace and formatting during \nthe transformation process.\n\nReturns:\n    str or bytes: An XSLT stylesheet string encoded in UTF-8 for Python 3 \n    environments, or a plain string for Python 2. \n\nDependencies:\n    - The method imports the sys module to check the Python version and \n      adjust the return type accordingly.\"\"\"\n        reply = '<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\\n        <xsl:output method=\"xml\" indent=\"no\"/>\\n\\n        <xsl:template match=\"/|comment()|processing-instruction()\">\\n            <xsl:copy>\\n                <xsl:apply-templates/>\\n            </xsl:copy>\\n        </xsl:template>\\n\\n        <xsl:template match=\"*\">\\n            <xsl:element name=\"{local-name()}\">\\n                <xsl:apply-templates select=\"@*|node()\"/>\\n            </xsl:element>\\n        </xsl:template>\\n\\n        <xsl:template match=\"@*\">\\n            <xsl:attribute name=\"{local-name()}\">\\n                <xsl:value-of select=\".\"/>\\n            </xsl:attribute>\\n        </xsl:template>\\n        </xsl:stylesheet>\\n        '\n        import sys\n        if sys.version < '3':\n            return reply\n        else:\n            return reply.encode('UTF-8')",
        "docstring": "Generates an XSLT stylesheet for transforming XML replies from the Juniper device.\n\nThis method returns an XSLT stylesheet that defines how to transform XML nodes \nby copying elements and their attributes while maintaining their names. It \nensures compliant XML by removing unnecessary whitespace and formatting during \nthe transformation process.\n\nReturns:\n    str or bytes: An XSLT stylesheet string encoded in UTF-8 for Python 3 \n    environments, or a plain string for Python 2. \n\nDependencies:\n    - The method imports the sys module to check the Python version and \n      adjust the return type accordingly.",
        "signature": "def transform_reply(self):",
        "type": "Method",
        "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
      }
    },
    "ncclient/transport/session.py": {
      "Session.__init__": {
        "code": "    def __init__(self, capabilities):\n        \"\"\"Initialize a new Session instance for managing a NETCONF session.\n\n    This constructor sets up the session's necessary infrastructure, including:\n    - Initializing the thread as a daemon, allowing it to run in the background.\n    - Setting up a listener set to handle incoming messages and errors.\n    - Creating thread locks and queues for message handling.\n    - Storing client capabilities provided during initialization.\n    - Initializing server capabilities, session-id, and connection status.\n    - Logging session creation with client capabilities.\n\n    Parameters:\n    capabilities (list): A list of capabilities supported by the client, which will be \n                         communicated during the NETCONF session establishment.\n\n    Attributes:\n    - self._listeners: A set to hold listeners for incoming messages and errors.\n    - self._lock: A threading Lock to manage concurrent access to shared resources.\n    - self._q: A Queue for queuing messages to be sent to the NETCONF server.\n    - self._notification_q: A Queue for handling notifications received from the server.\n    - self._client_capabilities: Stores the capabilities passed as a parameter.\n    - self._server_capabilities: Initialized as None, to be set during capability exchange.\n    - self._base: Initialized to NetconfBase.BASE_10, indicating the default protocol version.\n    - self._id: Represents the session ID, initially set as None.\n    - self._connected: A boolean flag indicating the connection status, initially False.\n    - self.logger: A logger instance for session logging, configured with the session's context.\n    - self._device_handler: Initially set to None, expected to be defined by a subclass.\n\n    Constants used:\n    - `NetconfBase.BASE_10`: Indicates the default NETCONF protocol version (1.0).\"\"\"\n        Thread.__init__(self, daemon=True, name='session')\n        self._listeners = set()\n        self._lock = Lock()\n        self._q = Queue()\n        self._notification_q = Queue()\n        self._client_capabilities = capabilities\n        self._server_capabilities = None\n        self._base = NetconfBase.BASE_10\n        self._id = None\n        self._connected = False\n        self.logger = SessionLoggerAdapter(logger, {'session': self})\n        self.logger.debug('%r created: client_capabilities=%r', self, self._client_capabilities)\n        self._device_handler = None",
        "docstring": "Initialize a new Session instance for managing a NETCONF session.\n\nThis constructor sets up the session's necessary infrastructure, including:\n- Initializing the thread as a daemon, allowing it to run in the background.\n- Setting up a listener set to handle incoming messages and errors.\n- Creating thread locks and queues for message handling.\n- Storing client capabilities provided during initialization.\n- Initializing server capabilities, session-id, and connection status.\n- Logging session creation with client capabilities.\n\nParameters:\ncapabilities (list): A list of capabilities supported by the client, which will be \n                     communicated during the NETCONF session establishment.\n\nAttributes:\n- self._listeners: A set to hold listeners for incoming messages and errors.\n- self._lock: A threading Lock to manage concurrent access to shared resources.\n- self._q: A Queue for queuing messages to be sent to the NETCONF server.\n- self._notification_q: A Queue for handling notifications received from the server.\n- self._client_capabilities: Stores the capabilities passed as a parameter.\n- self._server_capabilities: Initialized as None, to be set during capability exchange.\n- self._base: Initialized to NetconfBase.BASE_10, indicating the default protocol version.\n- self._id: Represents the session ID, initially set as None.\n- self._connected: A boolean flag indicating the connection status, initially False.\n- self.logger: A logger instance for session logging, configured with the session's context.\n- self._device_handler: Initially set to None, expected to be defined by a subclass.\n\nConstants used:\n- `NetconfBase.BASE_10`: Indicates the default NETCONF protocol version (1.0).",
        "signature": "def __init__(self, capabilities):",
        "type": "Method",
        "class_signature": "class Session(Thread):"
      }
    },
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initialize a DefaultDeviceHandler instance.\n\nThis constructor method sets up the device handler for Netconf interactions. It accepts optional device-specific parameters and initializes necessary attributes for managing exempt error messages. The exempt error messages are handled in various categories (exact match, wildcard start, wildcard end, and full wildcard) to facilitate case-insensitive comparisons when evaluating RPC error messages.\n\nParameters:\n    device_params (dict or None): Optional dictionary holding device-specific parameters which may influence the handler's behavior. Defaults to None.\n\nAttributes:\n    device_params (dict or None): Stores the provided device parameters.\n    capabilities (list): Initializes an empty list to hold Netconf capabilities.\n    _exempt_errors_exact_match (list): Holds exact match exempt error messages.\n    _exempt_errors_startwith_wildcard_match (list): Holds exempt error messages that start with a wildcard.\n    _exempt_errors_endwith_wildcard_match (list): Holds exempt error messages that end with a wildcard.\n    _exempt_errors_full_wildcard_match (list): Holds exempt error messages that match with wildcards at both ends.\n\nConstants:\n    _EXEMPT_ERRORS (list): A class-level list (initially empty) that can be defined in subclasses to specify exempt error messages. This is utilized during error handling to determine if certain error messages should be ignored.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initialize a DefaultDeviceHandler instance.\n\nThis constructor method sets up the device handler for Netconf interactions. It accepts optional device-specific parameters and initializes necessary attributes for managing exempt error messages. The exempt error messages are handled in various categories (exact match, wildcard start, wildcard end, and full wildcard) to facilitate case-insensitive comparisons when evaluating RPC error messages.\n\nParameters:\n    device_params (dict or None): Optional dictionary holding device-specific parameters which may influence the handler's behavior. Defaults to None.\n\nAttributes:\n    device_params (dict or None): Stores the provided device parameters.\n    capabilities (list): Initializes an empty list to hold Netconf capabilities.\n    _exempt_errors_exact_match (list): Holds exact match exempt error messages.\n    _exempt_errors_startwith_wildcard_match (list): Holds exempt error messages that start with a wildcard.\n    _exempt_errors_endwith_wildcard_match (list): Holds exempt error messages that end with a wildcard.\n    _exempt_errors_full_wildcard_match (list): Holds exempt error messages that match with wildcards at both ends.\n\nConstants:\n    _EXEMPT_ERRORS (list): A class-level list (initially empty) that can be defined in subclasses to specify exempt error messages. This is utilized during error handling to determine if certain error messages should be ignored.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      },
      "DefaultDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Return the list of capabilities for the device.\n\nThis method combines the base capabilities defined in the class constant `_BASE_CAPABILITIES` with any additional capabilities stored in the instance variable `self.capabilities`. The returned list is utilized during the initial NETCONF capability exchange between the client and the device.\n\nReturns:\n    list: A list of URIs representing the client's capabilities used to negotiate supported features with the NETCONF server.\n\nDependencies:\n    - `_BASE_CAPABILITIES`: A class constant that holds a predefined list of URIs representing standard NETCONF capabilities.\n    - `self.capabilities`: An instance variable that can be modified by external calls to include additional device-specific capabilities.\"\"\"\n        \"\\n        Return the capability list.\\n\\n        A list of URI's representing the client's capabilities. This is used during\\n        the initial capability exchange. Modify (in a new device-handler subclass)\\n        as needed.\\n\\n        \"\n        return self._BASE_CAPABILITIES + self.capabilities",
        "docstring": "Return the list of capabilities for the device.\n\nThis method combines the base capabilities defined in the class constant `_BASE_CAPABILITIES` with any additional capabilities stored in the instance variable `self.capabilities`. The returned list is utilized during the initial NETCONF capability exchange between the client and the device.\n\nReturns:\n    list: A list of URIs representing the client's capabilities used to negotiate supported features with the NETCONF server.\n\nDependencies:\n    - `_BASE_CAPABILITIES`: A class constant that holds a predefined list of URIs representing standard NETCONF capabilities.\n    - `self.capabilities`: An instance variable that can be modified by external calls to include additional device-specific capabilities.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/transport/ssh.py": {
      "SSHSession.__init__": {
        "code": "    def __init__(self, device_handler):\n        \"\"\"Initializes an instance of the `SSHSession` class, which implements a NETCONF session over SSH.\n\nParameters:\n- device_handler: An object that provides capabilities and device-specific handling for establishing a connection. It must implement the `get_capabilities` method.\n\nAttributes initialized:\n- `_host`: Stores the hostname associated with the session, initially set to None.\n- `_host_keys`: Holds the known host keys using `paramiko.HostKeys()`.\n- `_transport`: Placeholder for the transport layer, initially set to None.\n- `_connected`: A boolean flag indicating connection status, initialized to False.\n- `_channel`: Represents the SSH channel for the session, initially None.\n- `_channel_id`: Identifier for the SSH channel, initially None.\n- `_channel_name`: Name assigned to the SSH channel, initially None.\n- `_buffer`: A buffer for incoming data, implemented using `StringIO()`.\n- `_device_handler`: Reference to the provided device handler.\n- `_message_list`: A list to store incoming messages.\n- `_closing`: An event that indicates if the session is in the process of closing, initialized as a threading event.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML in the session.\n\nDependencies:\n- The class relies on the `Capabilities` from `ncclient.capabilities` for device capabilities and `paramiko` for SSH transport functionality.\n- Logging is configured through `SessionLoggerAdapter` to track session events.\"\"\"\n        capabilities = Capabilities(device_handler.get_capabilities())\n        Session.__init__(self, capabilities)\n        self._host = None\n        self._host_keys = paramiko.HostKeys()\n        self._transport = None\n        self._connected = False\n        self._channel = None\n        self._channel_id = None\n        self._channel_name = None\n        self._buffer = StringIO()\n        self._device_handler = device_handler\n        self._message_list = []\n        self._closing = threading.Event()\n        self.parser = DefaultXMLParser(self)\n        self.logger = SessionLoggerAdapter(logger, {'session': self})",
        "docstring": "Initializes an instance of the `SSHSession` class, which implements a NETCONF session over SSH.\n\nParameters:\n- device_handler: An object that provides capabilities and device-specific handling for establishing a connection. It must implement the `get_capabilities` method.\n\nAttributes initialized:\n- `_host`: Stores the hostname associated with the session, initially set to None.\n- `_host_keys`: Holds the known host keys using `paramiko.HostKeys()`.\n- `_transport`: Placeholder for the transport layer, initially set to None.\n- `_connected`: A boolean flag indicating connection status, initialized to False.\n- `_channel`: Represents the SSH channel for the session, initially None.\n- `_channel_id`: Identifier for the SSH channel, initially None.\n- `_channel_name`: Name assigned to the SSH channel, initially None.\n- `_buffer`: A buffer for incoming data, implemented using `StringIO()`.\n- `_device_handler`: Reference to the provided device handler.\n- `_message_list`: A list to store incoming messages.\n- `_closing`: An event that indicates if the session is in the process of closing, initialized as a threading event.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML in the session.\n\nDependencies:\n- The class relies on the `Capabilities` from `ncclient.capabilities` for device capabilities and `paramiko` for SSH transport functionality.\n- Logging is configured through `SessionLoggerAdapter` to track session events.",
        "signature": "def __init__(self, device_handler):",
        "type": "Method",
        "class_signature": "class SSHSession(Session):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/junos.py:JunosDeviceHandler:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {},
    "ncclient/transport/ssh.py:SSHSession:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {},
    "ncclient/capabilities.py:Capabilities:__init__": {},
    "ncclient/capabilities.py:Capabilities:add": {},
    "ncclient/capabilities.py:Capability:from_uri": {},
    "ncclient/capabilities.py:_parse_parameter_string": {},
    "ncclient/capabilities.py:_Parameter:from_string": {},
    "ncclient/transport/session.py:Session:__init__": {},
    "ncclient/transport/parser.py:DefaultXMLParser:__init__": {},
    "ncclient/devices/junos.py:JunosDeviceHandler:handle_raw_dispatch": {},
    "ncclient/operations/rpc.py:RPCError:__init__": {},
    "ncclient/xml_.py:to_ele": {}
  },
  "PRD": "# PROJECT NAME: ncclient-test_junos\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 capabilities.py\n    \u2502   \u251c\u2500\u2500 Capabilities.__init__\n    \u2502   \u251c\u2500\u2500 Capabilities.add\n    \u2502   \u251c\u2500\u2500 Capability.__init__\n    \u2502   \u251c\u2500\u2500 Capability.from_uri\n    \u2502   \u251c\u2500\u2500 _Parameter.__init__\n    \u2502   \u251c\u2500\u2500 _Parameter.from_string\n    \u2502   \u2514\u2500\u2500 _parse_parameter_string\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 default.py\n    \u2502   \u2502   \u251c\u2500\u2500 DefaultDeviceHandler.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultDeviceHandler.get_capabilities\n    \u2502   \u2514\u2500\u2500 junos.py\n    \u2502       \u251c\u2500\u2500 JunosDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 JunosDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 JunosDeviceHandler.handle_connection_exceptions\n    \u2502       \u251c\u2500\u2500 JunosDeviceHandler.handle_raw_dispatch\n    \u2502       \u251c\u2500\u2500 JunosDeviceHandler.perform_qualify_check\n    \u2502       \u2514\u2500\u2500 JunosDeviceHandler.transform_reply\n    \u251c\u2500\u2500 operations/\n    \u2502   \u2514\u2500\u2500 rpc.py\n    \u2502       \u251c\u2500\u2500 RPCError.__init__\n    \u2502       \u251c\u2500\u2500 RPCError.message\n    \u2502       \u251c\u2500\u2500 RPCError.severity\n    \u2502       \u2514\u2500\u2500 RPCError.to_dict\n    \u251c\u2500\u2500 transport/\n    \u2502   \u251c\u2500\u2500 errors.py\n    \u2502   \u2502   \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n    \u2502   \u251c\u2500\u2500 parser.py\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultXMLParser.__init__\n    \u2502   \u251c\u2500\u2500 session.py\n    \u2502   \u2502   \u2514\u2500\u2500 Session.__init__\n    \u2502   \u2514\u2500\u2500 ssh.py\n    \u2502       \u2514\u2500\u2500 SSHSession.__init__\n    \u2514\u2500\u2500 xml_.py\n        \u251c\u2500\u2500 _get_parser\n        \u2514\u2500\u2500 to_ele\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates automated testing and validation of operations for Junos devices, leveraging network communication capabilities via the `ncclient` library. It provides features to handle device-specific connection exceptions, perform network configuration tasks such as executing RPC calls, managing configurations, and orchestrating operational commands like commit, rollback, reboot, and halt, while also transforming and validating XML-based responses. By abstracting complex device communication processes and standardizing the response handling, the module simplifies device interaction for developers, ensuring robust and error-resilient integration with Junos-based network infrastructure.\n\n## FILE 1: ncclient/operations/rpc.py\n\n- CLASS METHOD: RPCError.severity\n  - CLASS SIGNATURE: class RPCError(OperationError):\n  - SIGNATURE: def severity(self):\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef severity(self):\n\"\"\"\n```\n\n- CLASS METHOD: RPCError.message\n  - CLASS SIGNATURE: class RPCError(OperationError):\n  - SIGNATURE: def message(self):\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef message(self):\n\"\"\"\n```\n\n- CLASS METHOD: RPCError.__init__\n  - CLASS SIGNATURE: class RPCError(OperationError):\n  - SIGNATURE: def __init__(self, raw, errs=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the `RPCError` class, which represents an error response from an RPC operation.\n\nParameters:\n- raw: The raw XML element containing the error information. This is of the XML type and is typically obtained from the response of a remote procedure call.\n- errs: An optional list of `RPCError` objects, used when multiple errors are returned.\n\nThis constructor extracts relevant error attributes (`error-type`, `error-tag`, `error-app-tag`, `error-severity`, `error-info`, `error-path`, and `error-message`) from the raw XML data. It populates attributes corresponding to these error types using the provided `tag_to_attr` mapping. If a list of errors is provided, it aggregates their details to generate a cumulative error message and defines the overall severity of the reported errors.\n\nThis method directly interacts with the `OperationError` class from the `ncclient.operations.errors` module, raising it when necessary based on the presence and severity of the errors encountered.\n\nAttributes:\n- _raw: Stores the raw XML error response.\n- _errlist: Keeps track of multiple error instances, if applicable.\n- severity: A string representing the highest level of severity encountered in the errors.\n- message: The aggregated message describing the errors.\n\nThis constructor utilizes the `six` module for compatibility with Python 2 and 3.\n\"\"\"\n```\n\n- CLASS METHOD: RPCError.to_dict\n  - CLASS SIGNATURE: class RPCError(OperationError):\n  - SIGNATURE: def to_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts the attributes of the `RPCError` instance into a dictionary format.\n\nThis method collects the relevant error information (such as error type, tag, application tag, severity, path, message, and info) and organizes it into a dictionary. It utilizes the `tag_to_attr` mapping defined in the `RPCError` class to correlate XML tags with instance attributes.\n\nReturns:\n    dict: A dictionary representation of the `RPCError` instance, where keys are attribute names (excluding the leading underscore) and values are the corresponding attribute values.\n\nDependencies:\n- `RPCError.tag_to_attr`: A constant dictionary that maps XML error tags to the respective attributes of the `RPCError` class.\n- `six.itervalues`: Used to iterate over the values of the `tag_to_attr` dictionary for retrieving attribute names dynamically.\n\"\"\"\n```\n\n## FILE 2: ncclient/xml_.py\n\n- FUNCTION NAME: to_ele\n  - SIGNATURE: def to_ele(x, huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert and return an `ElementTree.Element` for the provided XML document *x*. If *x* is already an `Element`, it is returned directly. If *huge_tree* is set to True, the XML is parsed to accommodate very deep trees or lengthy text content. The function utilizes the `etree.fromstring` method from the `lxml` library, and the parser used is determined by the `_get_parser()` function, which returns either the standard or a huge tree parser. This function requires Python's sys module to determine the Python version for compatibility.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:_get_parser\n    - ncclient/devices/junos.py:JunosDeviceHandler:handle_raw_dispatch\n\n- FUNCTION NAME: _get_parser\n  - SIGNATURE: def _get_parser(huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns an XML parser based on the specified options for handling large XML documents.\n\nParameters:\n- huge_tree (bool): If set to True, the function returns a parser configured for handling very deep trees and long text content using the `huge_parser`. If False, it returns the standard `parser`.\n\nReturns:\n- etree.XMLParser: An instance of `lxml.etree.XMLParser`, either the `huge_parser` or the standard `parser`, as defined at the module level.\n\nDependencies:\n- `parser` and `huge_parser` are defined globally in the module and provide different configurations for XML parsing depending on the size of the XML document.\n\"\"\"\n```\n\n## FILE 3: ncclient/transport/parser.py\n\n- CLASS METHOD: DefaultXMLParser.__init__\n  - CLASS SIGNATURE: class DefaultXMLParser(object):\n  - SIGNATURE: def __init__(self, session):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DefaultXMLParser instance for parsing XML data from a networking device over a session.\n\n:param session: An SSH session object that manages the connection to the networking device.\n                This session interacts with various components of the netconf transport layer,\n                allowing the parser to process incoming RPC responses effectively.\n\nAttributes:\n    _session (Session): Stores the provided session object for future parsing operations and message handling.\n    _parsing_pos10 (int): Keeps track of the current position in the buffer during parsing of messages\n                           adhering to Netconf v1.0, initialized to 0.\n    logger (SessionLoggerAdapter): A logging adapter that enhances logging capabilities for session-specific events.\n\nThe constructor does not return a value but sets up the necessary attributes for the parser to function correctly.\n\"\"\"\n```\n\n## FILE 4: ncclient/capabilities.py\n\n- CLASS METHOD: Capabilities.__init__\n  - CLASS SIGNATURE: class Capabilities(object):\n  - SIGNATURE: def __init__(self, capabilities):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Capabilities object with a set of capability URIs.\n\nParameters:\ncapabilities (list of str): A list of capability URIs that the NETCONF client or server supports. Each URI is expected to be in a specific format that can be parsed to represent a capability.\n\nThis method creates an empty dictionary `self._dict` to hold capabilities and then populates it by adding each URI provided in the capabilities list. The `add` method is invoked for each URI, which processes the URI to create a corresponding Capability object. It is important to ensure that valid URIs are passed, as invalid ones may raise errors during parsing.\n\nSide Effects:\nModifies the internal state of the Capabilities instance by populating `self._dict` with Capability objects derived from the provided URIs.\n\"\"\"\n```\n\n- CLASS METHOD: _Parameter.__init__\n  - CLASS SIGNATURE: class _Parameter(object):\n  - SIGNATURE: def __init__(self, key, value):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a _Parameter instance representing a specific key-value pair for capability parameters.\n\nParameters:\n- key (str): The parameter key, extracted from the capability URI.\n- value (str): The parameter value, also derived from the capability URI.\n\nThis constructor sets the `key` and `value` attributes for the _Parameter instance, which are used in the capability representation within the Capability class. The _Parameter class is intended for managing parameters in capability URIs, and instances of _Parameter are created when parsing parameters from a URI string in the _parse_parameter_string function. No constants are used directly within this method.\n\"\"\"\n```\n\n- FUNCTION NAME: _parse_parameter_string\n  - SIGNATURE: def _parse_parameter_string(string, uri):\n  - DOCSTRING: \n```python\n\"\"\"\nParse a parameter string from a capability URI and yield individual parameters as _Parameter instances.\n\nArgs:\n    string (str): The parameter string containing key-value pairs separated by '&'.\n    uri (str): The original capability URI for logging purposes, in case of invalid parameters.\n\nYields:\n    _Parameter: Instances of _Parameter for each valid key-value pair parsed from the string.\n\nSide Effects:\n    Logs an error message using the logger if any parameter is invalid. The logger is configured at the start of the code with the name \"ncclient.capabilities\".\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/capabilities.py:_Parameter:from_string\n\n- CLASS METHOD: Capability.__init__\n  - CLASS SIGNATURE: class Capability(object):\n  - SIGNATURE: def __init__(self, namespace_uri, parameters=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Capability instance with a specified namespace URI and optional parameters.\n\nParameters:\n- namespace_uri (str): The namespace URI representing the capability.\n- parameters (dict, optional): A dictionary of parameters associated with the capability. Defaults to an empty dictionary if not provided.\n\nAttributes:\n- namespace_uri (str): Stores the provided namespace URI.\n- parameters (dict): Stores the provided parameters or an empty dictionary.\n\nThis constructor facilitates the creation of Capability objects that represent individual capabilities in NETCONF communication, allowing for the encapsulation of both the capability's namespace and any associated parameters.\n\"\"\"\n```\n\n- CLASS METHOD: _Parameter.from_string\n  - CLASS SIGNATURE: class _Parameter(object):\n  - SIGNATURE: def from_string(cls, string):\n  - DOCSTRING: \n```python\n\"\"\"\nTransforms a query parameter string into a _Parameter instance. \n\nThis class method takes a string formatted as \"key=value\" and splits it into a key and a value. If the string cannot be split correctly due to the absence of an equal sign, it raises an _InvalidParameter exception.\n\nParameters:\n- string (str): The input string representing the parameter in the format \"key=value\".\n\nReturns:\n- _Parameter: An instance of the _Parameter class initialized with the extracted key and value.\n\nRaises:\n- _InvalidParameter: If the input string does not contain exactly one equal sign for splitting.\n\"\"\"\n```\n\n- CLASS METHOD: Capabilities.add\n  - CLASS SIGNATURE: class Capabilities(object):\n  - SIGNATURE: def add(self, uri):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds a capability represented by a URI to the internal dictionary of capabilities.\n\nParameters:\n- uri (str): The capability URI to be added. This URI will be processed to create a `Capability` object, which includes a namespace and any associated parameters.\n\nReturns:\n- None\n\nSide Effects:\n- Modifies the internal dictionary `_dict` that stores capabilities, associating the provided URI with a `Capability` instance created using the `Capability.from_uri()` class method.\n\nDependencies:\n- Interacts with the `Capability` class, specifically its `from_uri` method which is used to parse the URI and generate the corresponding capability object.\n\"\"\"\n```\n\n- CLASS METHOD: Capability.from_uri\n  - CLASS SIGNATURE: class Capability(object):\n  - SIGNATURE: def from_uri(cls, uri):\n  - DOCSTRING: \n```python\n\"\"\"\nClass method that creates a Capability instance from a given URI. The URI can optionally include a query string for parameters, which are parsed and stored in the instance. The method splits the URI into the namespace and parameter string, then utilizes the _parse_parameter_string helper to generate the parameters while handling any parsing errors. If no parameters are present, only the namespace is set. Returns a Capability object initialized with the namespace URI and parameters.\n\nParameters:\n- uri (str): The URI representing the capability, which may include a query string with parameters.\n\nReturns:\n- Capability: An instance of the Capability class populated with the namespace URI and any parsed parameters.\n\nDependencies:\n- _parse_parameter_string: A helper function that parses the parameter string and yields Parameter objects, logging errors for invalid parameters.\n\"\"\"\n```\n\n## FILE 5: ncclient/devices/junos.py\n\n- CLASS METHOD: JunosDeviceHandler.perform_qualify_check\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def perform_qualify_check(self):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks whether the current device meets any qualification requirements for operations.\n\nThis method is intended to provide a mechanism for determining the qualification of a device\nfor performing certain operations. In this implementation, it always returns False, indicating\nthat no specific qualifications are enforced or required at this level of the Junos device handler.\n\nReturns:\n    bool: Always returns False, indicating that qualification checks are not implemented.\n\"\"\"\n```\n\n- CLASS METHOD: JunosDeviceHandler.transform_reply\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def transform_reply(self):\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates an XSLT stylesheet for transforming XML replies from the Juniper device.\n\nThis method returns an XSLT stylesheet that defines how to transform XML nodes \nby copying elements and their attributes while maintaining their names. It \nensures compliant XML by removing unnecessary whitespace and formatting during \nthe transformation process.\n\nReturns:\n    str or bytes: An XSLT stylesheet string encoded in UTF-8 for Python 3 \n    environments, or a plain string for Python 2. \n\nDependencies:\n    - The method imports the sys module to check the Python version and \n      adjust the return type accordingly.\n\"\"\"\n```\n\n- CLASS METHOD: JunosDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nProvides additional NETCONF operations specific to Juniper devices.\n\nThis method constructs and returns a dictionary mapping operation names to their corresponding \nclasses, which handle various NETCONF operations such as executing RPC commands, managing \nconfigurations, and controlling device states.\n\nReturns:\n    dict: A dictionary with operation names as keys and associated operation classes as values.\n           The key-value pairs include:\n           - \"rpc\": ExecuteRpc\n           - \"get_configuration\": GetConfiguration\n           - \"load_configuration\": LoadConfiguration\n           - \"compare_configuration\": CompareConfiguration\n           - \"command\": Command\n           - \"reboot\": Reboot\n           - \"halt\": Halt\n           - \"commit\": Commit\n           - \"rollback\": Rollback\n\nDependencies:\n    The operation classes (ExecuteRpc, GetConfiguration, LoadConfiguration, \n    CompareConfiguration, Command, Reboot, Halt, Commit, and Rollback) are imported \n    from the `ncclient.operations.third_party.juniper.rpc` module.\n\"\"\"\n```\n\n- CLASS METHOD: JunosDeviceHandler.handle_connection_exceptions\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def handle_connection_exceptions(self, sshsession):\n  - DOCSTRING: \n```python\n\"\"\"\nHandle connection exceptions for the NETCONF session with a Juniper device.\n\nThis method opens a new SSH channel for the session and sets its name using \nthe channel ID. It then executes a command to set the session to xml-mode \nfor NETCONF operations, specifically specifying the need for a trailer in the \nXML response.\n\nParameters:\n    sshsession: An active SSH session instance that manages the connection \n                to the Juniper device. It is expected to have a transport \n                layer that supports opening channels.\n\nReturns:\n    bool: Always returns True to indicate that the connection handling \n          was initiated.\n\nThis method interacts with the underlying transport mechanism of the \nNETCONF client, particularly using the `sshsession._transport` and \n`sshsession._channel` attributes. The `sshsession._channel_id` is used \nto uniquely identify the channel during interactions with the device.\n\"\"\"\n```\n\n- CLASS METHOD: JunosDeviceHandler.handle_raw_dispatch\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def handle_raw_dispatch(self, raw):\n  - DOCSTRING: \n```python\n\"\"\"\nHandles the dispatch of raw XML responses from the Juniper device. The method checks for specific elements in the raw response to either modify the response format if it contains 'routing-engine' or to extract and transform any RPC errors present during capabilities exchange. \n\nParameters:\n- raw (str): The raw XML response string from the Juniper device.\n\nReturns:\n- str or RPCError: Returns a modified raw XML string if 'routing-engine' is found, or an RPCError object containing detailed error information if RPC errors are identified. If neither condition is met, returns False.\n\nThe method relies on regular expressions from the `re` module for string pattern matching and uses the `lxml.etree` module to parse and transform XML data. The `RPCError` class is imported from `ncclient.operations.rpc` and is used to encapsulate errors found in the input XML. The constant `'<ok/>'` is utilized as a marker in the response and is replaced to maintain proper XML structure.\n\"\"\"\n```\n\n- CLASS METHOD: JunosDeviceHandler.__init__\n  - CLASS SIGNATURE: class JunosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the JunosDeviceHandler with specified device parameters.\n\nThis constructor method sets up the JunosDeviceHandler instance by calling the superclass \n(DefaultDeviceHandler) constructor and initializing a dictionary for error transformation \nrelated to reply parsing. Specifically, it associates the `GetSchemaReply` class with a \nfixing function `fix_get_schema_reply`, which addresses namespace issues that may arise \nwith certain Junos versions.\n\nParameters:\n    device_params (dict): A dictionary containing device configuration parameters required \n    for establishing a NETCONF connection and defining specific device behavior.\n\nAttributes:\n    __reply_parsing_error_transform_by_cls (dict): A mapping of reply classes to functions \n    that can transform the replies to accommodate for known issues or non-compliance with \n    RFCs.\n\nDependencies:\n    This class relies on the `DefaultDeviceHandler` class for general functionality and \n    interaction with the NETCONF protocol. The specific reply handling is executed in \n    conjunction with the `fix_get_schema_reply` function which is defined in the \n    same module.\n\"\"\"\n```\n\n## FILE 6: ncclient/transport/session.py\n\n- CLASS METHOD: Session.__init__\n  - CLASS SIGNATURE: class Session(Thread):\n  - SIGNATURE: def __init__(self, capabilities):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new Session instance for managing a NETCONF session.\n\nThis constructor sets up the session's necessary infrastructure, including:\n- Initializing the thread as a daemon, allowing it to run in the background.\n- Setting up a listener set to handle incoming messages and errors.\n- Creating thread locks and queues for message handling.\n- Storing client capabilities provided during initialization.\n- Initializing server capabilities, session-id, and connection status.\n- Logging session creation with client capabilities.\n\nParameters:\ncapabilities (list): A list of capabilities supported by the client, which will be \n                     communicated during the NETCONF session establishment.\n\nAttributes:\n- self._listeners: A set to hold listeners for incoming messages and errors.\n- self._lock: A threading Lock to manage concurrent access to shared resources.\n- self._q: A Queue for queuing messages to be sent to the NETCONF server.\n- self._notification_q: A Queue for handling notifications received from the server.\n- self._client_capabilities: Stores the capabilities passed as a parameter.\n- self._server_capabilities: Initialized as None, to be set during capability exchange.\n- self._base: Initialized to NetconfBase.BASE_10, indicating the default protocol version.\n- self._id: Represents the session ID, initially set as None.\n- self._connected: A boolean flag indicating the connection status, initially False.\n- self.logger: A logger instance for session logging, configured with the session's context.\n- self._device_handler: Initially set to None, expected to be defined by a subclass.\n\nConstants used:\n- `NetconfBase.BASE_10`: Indicates the default NETCONF protocol version (1.0).\n\"\"\"\n```\n\n## FILE 7: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a DefaultDeviceHandler instance.\n\nThis constructor method sets up the device handler for Netconf interactions. It accepts optional device-specific parameters and initializes necessary attributes for managing exempt error messages. The exempt error messages are handled in various categories (exact match, wildcard start, wildcard end, and full wildcard) to facilitate case-insensitive comparisons when evaluating RPC error messages.\n\nParameters:\n    device_params (dict or None): Optional dictionary holding device-specific parameters which may influence the handler's behavior. Defaults to None.\n\nAttributes:\n    device_params (dict or None): Stores the provided device parameters.\n    capabilities (list): Initializes an empty list to hold Netconf capabilities.\n    _exempt_errors_exact_match (list): Holds exact match exempt error messages.\n    _exempt_errors_startwith_wildcard_match (list): Holds exempt error messages that start with a wildcard.\n    _exempt_errors_endwith_wildcard_match (list): Holds exempt error messages that end with a wildcard.\n    _exempt_errors_full_wildcard_match (list): Holds exempt error messages that match with wildcards at both ends.\n\nConstants:\n    _EXEMPT_ERRORS (list): A class-level list (initially empty) that can be defined in subclasses to specify exempt error messages. This is utilized during error handling to determine if certain error messages should be ignored.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the list of capabilities for the device.\n\nThis method combines the base capabilities defined in the class constant `_BASE_CAPABILITIES` with any additional capabilities stored in the instance variable `self.capabilities`. The returned list is utilized during the initial NETCONF capability exchange between the client and the device.\n\nReturns:\n    list: A list of URIs representing the client's capabilities used to negotiate supported features with the NETCONF server.\n\nDependencies:\n    - `_BASE_CAPABILITIES`: A class constant that holds a predefined list of URIs representing standard NETCONF capabilities.\n    - `self.capabilities`: An instance variable that can be modified by external calls to include additional device-specific capabilities.\n\"\"\"\n```\n\n## FILE 8: ncclient/transport/errors.py\n\n## FILE 9: ncclient/transport/ssh.py\n\n- CLASS METHOD: SSHSession.__init__\n  - CLASS SIGNATURE: class SSHSession(Session):\n  - SIGNATURE: def __init__(self, device_handler):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the `SSHSession` class, which implements a NETCONF session over SSH.\n\nParameters:\n- device_handler: An object that provides capabilities and device-specific handling for establishing a connection. It must implement the `get_capabilities` method.\n\nAttributes initialized:\n- `_host`: Stores the hostname associated with the session, initially set to None.\n- `_host_keys`: Holds the known host keys using `paramiko.HostKeys()`.\n- `_transport`: Placeholder for the transport layer, initially set to None.\n- `_connected`: A boolean flag indicating connection status, initialized to False.\n- `_channel`: Represents the SSH channel for the session, initially None.\n- `_channel_id`: Identifier for the SSH channel, initially None.\n- `_channel_name`: Name assigned to the SSH channel, initially None.\n- `_buffer`: A buffer for incoming data, implemented using `StringIO()`.\n- `_device_handler`: Reference to the provided device handler.\n- `_message_list`: A list to store incoming messages.\n- `_closing`: An event that indicates if the session is in the process of closing, initialized as a threading event.\n- `parser`: An instance of `DefaultXMLParser` for parsing XML in the session.\n\nDependencies:\n- The class relies on the `Capabilities` from `ncclient.capabilities` for device capabilities and `paramiko` for SSH transport functionality.\n- Logging is configured through `SessionLoggerAdapter` to track session events.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/operations/rpc.py": "from threading import Event, Lock\nfrom uuid import uuid4\nfrom ncclient.xml_ import *\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport import SessionListener\nfrom ncclient.operations import util\nfrom ncclient.operations.errors import OperationError, TimeoutExpiredError, MissingCapabilityError\nimport logging\nlogger = logging.getLogger('ncclient.operations.rpc')\n\nclass RPCError(OperationError):\n    \"\"\"Represents an `rpc-error`. It is a type of :exc:`OperationError` and can be raised as such.\"\"\"\n    tag_to_attr = {qualify('error-type'): '_type', qualify('error-tag'): '_tag', qualify('error-app-tag'): '_app_tag', qualify('error-severity'): '_severity', qualify('error-info'): '_info', qualify('error-path'): '_path', qualify('error-message'): '_message'}\n\n    @property\n    def xml(self):\n        \"\"\"The `rpc-error` element as returned in XML.         Multiple errors are returned as list of RPC errors\"\"\"\n        return self._raw\n\n    @property\n    def type(self):\n        \"\"\"The contents of the `error-type` element.\"\"\"\n        return self._type\n\n    @property\n    def tag(self):\n        \"\"\"The contents of the `error-tag` element.\"\"\"\n        return self._tag\n\n    @property\n    def app_tag(self):\n        \"\"\"The contents of the `error-app-tag` element.\"\"\"\n        return self._app_tag\n\n    @property\n    def path(self):\n        \"\"\"The contents of the `error-path` element if present or `None`.\"\"\"\n        return self._path\n\n    @property\n    def info(self):\n        \"\"\"XML string or `None`; representing the `error-info` element.\"\"\"\n        return self._info\n\n    @property\n    def errlist(self):\n        \"\"\"List of errors if this represents multiple errors, otherwise None.\"\"\"\n        return self._errlist\n\nclass RPCReply(object):\n    \"\"\"Represents an *rpc-reply*. Only concerns itself with whether the operation was successful.\n\n    *raw*: the raw unparsed reply\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n\n    .. note::\n        If the reply has not yet been parsed there is an implicit, one-time parsing overhead to\n        accessing some of the attributes defined by this class.\n    \"\"\"\n    ERROR_CLS = RPCError\n    'Subclasses can specify a different error class, but it should be a subclass of `RPCError`.'\n\n    def __init__(self, raw, huge_tree=False, parsing_error_transform=None):\n        self._raw = raw\n        self._parsing_error_transform = parsing_error_transform\n        self._parsed = False\n        self._root = None\n        self._errors = []\n        self._huge_tree = huge_tree\n\n    def __repr__(self):\n        return self._raw\n\n    def parse(self):\n        \"\"\"Parses the *rpc-reply*.\"\"\"\n        if self._parsed:\n            return\n        root = self._root = to_ele(self._raw, huge_tree=self._huge_tree)\n        ok = root.find(qualify('ok'))\n        if ok is None:\n            error = root.find('.//' + qualify('rpc-error'))\n            if error is not None:\n                for err in root.getiterator(error.tag):\n                    self._errors.append(self.ERROR_CLS(err))\n        try:\n            self._parsing_hook(root)\n        except Exception as e:\n            if self._parsing_error_transform is None:\n                exc_type, exc_value, exc_traceback = sys.exc_info()\n                six.reraise(exc_type, exc_value, exc_traceback)\n            self._parsing_error_transform(root)\n            self._parsing_hook(root)\n        self._parsed = True\n\n    def _parsing_hook(self, root):\n        \"\"\"No-op by default. Gets passed the *root* element for the reply.\"\"\"\n        pass\n\n    def set_parsing_error_transform(self, transform_function):\n        self._parsing_error_transform = transform_function\n\n    @property\n    def xml(self):\n        \"\"\"*rpc-reply* element as returned.\"\"\"\n        return self._raw\n\n    @property\n    def ok(self):\n        \"\"\"Boolean value indicating if there were no errors.\"\"\"\n        self.parse()\n        return not self.errors\n\n    @property\n    def error(self):\n        \"\"\"Returns the first :class:`RPCError` and `None` if there were no errors.\"\"\"\n        self.parse()\n        if self._errors:\n            return self._errors[0]\n        else:\n            return None\n\n    @property\n    def errors(self):\n        \"\"\"List of `RPCError` objects. Will be empty if there were no *rpc-error* elements in reply.\"\"\"\n        self.parse()\n        return self._errors\n\nclass RPCReplyListener(SessionListener):\n    creation_lock = Lock()\n\n    def __new__(cls, session, device_handler):\n        with RPCReplyListener.creation_lock:\n            instance = session.get_listener_instance(cls)\n            if instance is None:\n                instance = object.__new__(cls)\n                instance._lock = Lock()\n                instance._id2rpc = {}\n                instance._device_handler = device_handler\n                session.add_listener(instance)\n                instance.logger = SessionLoggerAdapter(logger, {'session': session})\n            return instance\n\n    def register(self, id, rpc):\n        with self._lock:\n            self._id2rpc[id] = rpc\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if self._device_handler.perform_qualify_check():\n            if tag != qualify('rpc-reply'):\n                return\n        if 'message-id' not in attrs:\n            raise OperationError(\"Could not find 'message-id' attribute in <rpc-reply>\")\n        else:\n            id = attrs['message-id']\n            with self._lock:\n                try:\n                    rpc = self._id2rpc[id]\n                    self.logger.debug('Delivering to %r', rpc)\n                    rpc.deliver_reply(raw)\n                except KeyError:\n                    raise OperationError(\"Unknown 'message-id': %s\" % id)\n                else:\n                    del self._id2rpc[id]\n\n    def errback(self, err):\n        try:\n            for rpc in six.itervalues(self._id2rpc):\n                rpc.deliver_error(err)\n        finally:\n            self._id2rpc.clear()\n\nclass RaiseMode(object):\n    \"\"\"\n    Define how errors indicated by RPC should be handled.\n\n    Note that any error_filters defined in the device handler will still be\n    applied, even if ERRORS or ALL is defined: If the filter matches, an exception\n    will NOT be raised.\n\n    \"\"\"\n    NONE = 0\n    \"Don't attempt to raise any type of `rpc-error` as :exc:`RPCError`.\"\n    ERRORS = 1\n    'Raise only when the `error-type` indicates it is an honest-to-god error.'\n    ALL = 2\n    \"Don't look at the `error-type`, always raise.\"\n\nclass RPC(object):\n    \"\"\"Base class for all operations, directly corresponding to *rpc* requests. Handles making the request, and taking delivery of the reply.\"\"\"\n    DEPENDS = []\n    \"Subclasses can specify their dependencies on capabilities as a list of URI's or abbreviated names, e.g. ':writable-running'. These are verified at the time of instantiation. If the capability is not available, :exc:`MissingCapabilityError` is raised.\"\n    REPLY_CLS = RPCReply\n    'By default :class:`RPCReply`. Subclasses can specify a :class:`RPCReply` subclass.'\n\n    def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):\n        \"\"\"\n        *session* is the :class:`~ncclient.transport.Session` instance\n\n        *device_handler\" is the :class:`~ncclient.devices.*.*DeviceHandler` instance\n\n        *async* specifies whether the request is to be made asynchronously, see :attr:`is_async`\n\n        *timeout* is the timeout for a synchronous request, see :attr:`timeout`\n\n        *raise_mode* specifies the exception raising mode, see :attr:`raise_mode`\n\n        *huge_tree* parse xml with huge_tree support (e.g. for large text config retrieval), see :attr:`huge_tree`\n        \"\"\"\n        self._session = session\n        try:\n            for cap in self.DEPENDS:\n                self._assert(cap)\n        except AttributeError:\n            pass\n        self._async = async_mode\n        self._timeout = timeout\n        self._raise_mode = raise_mode\n        self._huge_tree = huge_tree\n        self._id = uuid4().urn\n        self._listener = RPCReplyListener(session, device_handler)\n        self._listener.register(self._id, self)\n        self._reply = None\n        self._error = None\n        self._event = Event()\n        self._device_handler = device_handler\n        self.logger = SessionLoggerAdapter(logger, {'session': session})\n\n    def _wrap(self, subele):\n        ele = new_ele('rpc', {'message-id': self._id}, **self._device_handler.get_xml_extra_prefix_kwargs())\n        ele.append(subele)\n        return to_xml(ele)\n\n    def _request(self, op):\n        \"\"\"Implementations of :meth:`request` call this method to send the request and process the reply.\n\n        In synchronous mode, blocks until the reply is received and returns :class:`RPCReply`. Depending on the :attr:`raise_mode` a `rpc-error` element in the reply may lead to an :exc:`RPCError` exception.\n\n        In asynchronous mode, returns immediately, returning `self`. The :attr:`event` attribute will be set when the reply has been received (see :attr:`reply`) or an error occured (see :attr:`error`).\n\n        *op* is the operation to be requested as an :class:`~xml.etree.ElementTree.Element`\n        \"\"\"\n        self.logger.info('Requesting %r', self.__class__.__name__)\n        req = self._wrap(op)\n        self._session.send(req)\n        if self._async:\n            self.logger.debug('Async request, returning %r', self)\n            return self\n        else:\n            self.logger.debug('Sync request, will wait for timeout=%r', self._timeout)\n            self._event.wait(self._timeout)\n            if self._event.is_set():\n                if self._error:\n                    raise self._error\n                self._reply.parse()\n                if self._reply.error is not None and (not self._device_handler.is_rpc_error_exempt(self._reply.error.message)):\n                    if self._raise_mode == RaiseMode.ALL or (self._raise_mode == RaiseMode.ERRORS and self._reply.error.severity == 'error'):\n                        errlist = []\n                        errors = self._reply.errors\n                        if len(errors) > 1:\n                            raise RPCError(to_ele(self._reply._raw), errs=errors)\n                        else:\n                            raise self._reply.error\n                if self._device_handler.transform_reply():\n                    return NCElement(self._reply, self._device_handler.transform_reply(), huge_tree=self._huge_tree)\n                else:\n                    return self._reply\n            else:\n                raise TimeoutExpiredError('ncclient timed out while waiting for an rpc reply.')\n\n    def request(self):\n        \"\"\"Subclasses must implement this method. Typically only the request needs to be built as an\n        :class:`~xml.etree.ElementTree.Element` and everything else can be handed off to\n        :meth:`_request`.\"\"\"\n        pass\n\n    def _assert(self, capability):\n        \"\"\"Subclasses can use this method to verify that a capability is available with the NETCONF\n        server, before making a request that requires it. A :exc:`MissingCapabilityError` will be\n        raised if the capability is not available.\"\"\"\n        if capability not in self._session.server_capabilities:\n            raise MissingCapabilityError('Server does not support [%s]' % capability)\n\n    def deliver_reply(self, raw):\n        self._reply = self.REPLY_CLS(raw, huge_tree=self._huge_tree)\n        self._reply.set_parsing_error_transform(self._device_handler.reply_parsing_error_transform(self.REPLY_CLS))\n        self._event.set()\n\n    def deliver_error(self, err):\n        self._error = err\n        self._event.set()\n\n    @property\n    def reply(self):\n        \"\"\":class:`RPCReply` element if reply has been received or `None`\"\"\"\n        return self._reply\n\n    @property\n    def error(self):\n        \"\"\":exc:`Exception` type if an error occured or `None`.\n\n        .. note::\n            This represents an error which prevented a reply from being received. An *rpc-error*\n            does not fall in that category -- see `RPCReply` for that.\n        \"\"\"\n        return self._error\n\n    @property\n    def id(self):\n        \"\"\"The *message-id* for this RPC.\"\"\"\n        return self._id\n\n    @property\n    def session(self):\n        \"\"\"The `~ncclient.transport.Session` object associated with this RPC.\"\"\"\n        return self._session\n\n    @property\n    def event(self):\n        \"\"\":class:`~threading.Event` that is set when reply has been received or when an error preventing\n        delivery of the reply occurs.\n        \"\"\"\n        return self._event\n\n    def __set_async(self, async_mode=True):\n        self._async = async_mode\n        if async_mode and (not self._session.can_pipeline):\n            raise UserWarning('Asynchronous mode not supported for this device/session')\n\n    def __set_raise_mode(self, mode):\n        assert mode in (RaiseMode.NONE, RaiseMode.ERRORS, RaiseMode.ALL)\n        self._raise_mode = mode\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n    raise_mode = property(fget=lambda self: self._raise_mode, fset=__set_raise_mode)\n    'Depending on this exception raising mode, an `rpc-error` in the reply may be raised as an :exc:`RPCError` exception. Valid values are the constants defined in :class:`RaiseMode`. '\n    is_async = property(fget=lambda self: self._async, fset=__set_async)\n    \"Specifies whether this RPC will be / was requested asynchronously. By default RPC's are synchronous.\"\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    'Timeout in seconds for synchronous waiting defining how long the RPC request will block on a reply before raising :exc:`TimeoutExpiredError`.\\n\\n    Irrelevant for asynchronous usage.\\n    '\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x\n\nclass GenericRPC(RPC):\n    \"\"\"Generic rpc commands wrapper\"\"\"\n    REPLY_CLS = RPCReply\n    'See :class:`RPCReply`.'\n\n    def request(self, rpc_command, source=None, filter=None, config=None, target=None, format=None):\n        \"\"\"\n        *rpc_command* specifies rpc command to be dispatched either in plain text or in xml element format (depending on command)\n\n        *target* name of the configuration datastore being edited\n\n        *source* name of the configuration datastore being queried\n\n        *config* is the configuration, which must be rooted in the `config` element. It can be specified either as a string or an :class:`~xml.etree.ElementTree.Element`.\n\n        *filter* specifies the portion of the configuration to retrieve (by default entire configuration is retrieved)\n\n        :seealso: :ref:`filter_params`\n\n        Examples of usage::\n\n            m.rpc('rpc_command')\n\n        or dispatch element like ::\n\n            rpc_command = new_ele('get-xnm-information')\n            sub_ele(rpc_command, 'type').text = \"xml-schema\"\n            m.rpc(rpc_command)\n        \"\"\"\n        if etree.iselement(rpc_command):\n            node = rpc_command\n        else:\n            node = new_ele(rpc_command)\n        if target is not None:\n            node.append(util.datastore_or_url('target', target, self._assert))\n        if source is not None:\n            node.append(util.datastore_or_url('source', source, self._assert))\n        if filter is not None:\n            node.append(util.build_filter(filter))\n        if config is not None:\n            node.append(validated_element(config, ('config', qualify('config'))))\n        return self._request(node)",
    "ncclient/xml_.py": "\"\"\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\"\"\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\nfrom ncclient import NCClientError\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\nclass XMLError(NCClientError):\n    pass\nBASE_NS_1_0 = 'urn:ietf:params:xml:ns:netconf:base:1.0'\nYANG_NS_1_0 = 'urn:ietf:params:xml:ns:yang:1'\nNXOS_1_0 = 'http://www.cisco.com/nxos:1.0'\nNXOS_IF = 'http://www.cisco.com/nxos:1.0:if_manager'\nTAILF_AAA_1_1 = 'http://tail-f.com/ns/aaa/1.1'\nTAILF_EXECD_1_1 = 'http://tail-f.com/ns/execd/1.1'\nCISCO_CPI_1_0 = 'http://www.cisco.com/cpi_10/schema'\nFLOWMON_1_0 = 'http://www.liberouter.org/ns/netopeer/flowmon/1.0'\nJUNIPER_1_1 = 'http://xml.juniper.net/xnm/1.1/xnm'\nHUAWEI_NS = 'http://www.huawei.com/netconf/vrp'\nHW_PRIVATE_NS = 'http://www.huawei.com/netconf/capability/base/1.0'\nH3C_DATA_1_0 = 'http://www.h3c.com/netconf/data:1.0'\nH3C_CONFIG_1_0 = 'http://www.h3c.com/netconf/config:1.0'\nH3C_ACTION_1_0 = 'http://www.h3c.com/netconf/action:1.0'\nNETCONF_MONITORING_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring'\nNETCONF_NOTIFICATION_NS = 'urn:ietf:params:xml:ns:netconf:notification:1.0'\nNETCONF_WITH_DEFAULTS_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults'\nALU_CONFIG = 'urn:alcatel-lucent.com:sros:ns:yang:conf-r13'\nSROS_GLOBAL_OPS_NS = 'urn:nokia.com:sros:ns:yang:sr:oper-global'\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        ElementTree._namespace_map[uri] = prefix\nfor ns, pre in six.iteritems({BASE_NS_1_0: 'nc', NETCONF_MONITORING_NS: 'ncm', NXOS_1_0: 'nxos', NXOS_IF: 'if', TAILF_AAA_1_1: 'aaa', TAILF_EXECD_1_1: 'execd', CISCO_CPI_1_0: 'cpi', FLOWMON_1_0: 'fm', JUNIPER_1_1: 'junos'}):\n    register_namespace(pre, ns)\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else '{%s}%s' % (ns, tag)\n'Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.'\n\ndef to_xml(ele, encoding='UTF-8', pretty_print=False):\n    \"\"\"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\"\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\ndef parse_root(raw):\n    \"\"\"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\"\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError('Element [%s] does not meet requirement' % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)):\n                req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError('Element [%s] does not have required attributes' % ele.tag)\n    return ele\nXPATH_NAMESPACES = {'re': 'http://exslt.org/regular-expressions'}\n\nclass NCElement(object):\n\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt = self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)), parser=self.__parser))), parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        if elem.tag is not etree.Comment:\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag, ns), attrs, **extra)\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)",
    "ncclient/transport/parser.py": "import os\nimport sys\nimport re\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\nfrom xml.sax.handler import ContentHandler\nfrom ncclient.transport.errors import NetconfFramingError\nfrom ncclient.transport.session import NetconfBase\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.operations.errors import OperationError\nfrom ncclient.transport import SessionListener\nimport logging\nlogger = logging.getLogger('ncclient.transport.parser')\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\nPORT_NETCONF_DEFAULT = 830\nPORT_SSH_DEFAULT = 22\nBUF_SIZE = 4096\nMSG_DELIM = ']]>]]>'\nMSG_DELIM_LEN = len(MSG_DELIM)\nEND_DELIM = '\\n##\\n'\nTICK = 0.1\nRE_NC11_DELIM = re.compile('\\\\n(?:#([0-9]+)|(##))\\\\n')\nif sys.version < '3':\n\n    def textify(buf):\n        return buf\nelse:\n\n    def textify(buf):\n        return buf.decode('UTF-8')\n\nclass SAXParserHandler(SessionListener):\n\n    def __init__(self, session):\n        self._session = session\n\n    def callback(self, root, raw):\n        if type(self._session.parser) == DefaultXMLParser:\n            self._session.parser = self._session._device_handler.get_xml_parser(self._session)\n\n    def errback(self, _):\n        pass\n\nclass SAXFilterXMLNotFoundError(OperationError):\n\n    def __init__(self, rpc_listener):\n        self._listener = rpc_listener\n\n    def __str__(self):\n        return 'SAX filter input xml not provided for listener: %s' % self._listener\n\nclass DefaultXMLParser(object):\n\n    def parse(self, data):\n        \"\"\"\n        parse incoming RPC response from networking device.\n\n        :param data: incoming RPC data from device\n        :return: None\n        \"\"\"\n        if data:\n            self._session._buffer.seek(0, os.SEEK_END)\n            self._session._buffer.write(data)\n            if self._session._base == NetconfBase.BASE_11:\n                self._parse11()\n            else:\n                self._parse10()\n\n    def _parse10(self):\n        \"\"\"Messages are delimited by MSG_DELIM. The buffer could have grown by\n        a maximum of BUF_SIZE bytes everytime this method is called. Retains\n        state across method calls and if a chunk has been read it will not be\n        considered again.\"\"\"\n        self.logger.debug('parsing netconf v1.0')\n        buf = self._session._buffer\n        buf.seek(self._parsing_pos10)\n        if MSG_DELIM in buf.read().decode('UTF-8'):\n            buf.seek(0)\n            msg, _, remaining = buf.read().decode('UTF-8').partition(MSG_DELIM)\n            msg = msg.strip()\n            if sys.version < '3':\n                self._session._dispatch_message(msg.encode())\n            else:\n                self._session._dispatch_message(msg)\n            self._session._buffer = StringIO()\n            self._parsing_pos10 = 0\n            if len(remaining.strip()) > 0:\n                if type(self._session.parser) != DefaultXMLParser:\n                    self.logger.debug('send remaining data to SAX parser')\n                    self._session.parser.parse(remaining.encode())\n                else:\n                    self.logger.debug('Trying another round of parsing since there is still data')\n                    self._session._buffer.write(remaining.encode())\n                    self._parse10()\n        else:\n            self._parsing_pos10 = buf.tell() - MSG_DELIM_LEN\n            if self._parsing_pos10 < 0:\n                self._parsing_pos10 = 0\n\n    def _parse11(self):\n        \"\"\"Messages are split into chunks. Chunks and messages are delimited\n        by the regex #RE_NC11_DELIM defined earlier in this file. Each\n        time we get called here either a chunk delimiter or an\n        end-of-message delimiter should be found iff there is enough\n        data. If there is not enough data, we will wait for more. If a\n        delimiter is found in the wrong place, a #NetconfFramingError\n        will be raised.\"\"\"\n        self.logger.debug('_parse11: starting')\n        self._session._buffer.seek(0, os.SEEK_SET)\n        data = self._session._buffer.getvalue()\n        data_len = len(data)\n        start = 0\n        self.logger.debug('_parse11: working with buffer of %d bytes', data_len)\n        while True and start < data_len:\n            self.logger.debug('_parse11: matching from %d bytes from start of buffer', start)\n            re_result = RE_NC11_DELIM.match(data[start:].decode('utf-8', errors='ignore'))\n            if not re_result:\n                self.logger.debug('_parse11: no delimiter found, buffer=\"%s\"', data[start:].decode())\n                break\n            re_start = re_result.start()\n            re_end = re_result.end()\n            self.logger.debug('_parse11: regular expression start=%d, end=%d', re_start, re_end)\n            if re_start != 0:\n                raise NetconfFramingError('_parse11: delimiter not at start of match buffer', data[start:])\n            if re_result.group(2):\n                start += re_end\n                message = ''.join(self._session._message_list)\n                self._session._message_list = []\n                self.logger.debug('_parse11: found end of message delimiter')\n                self._session._dispatch_message(message)\n                break\n            elif re_result.group(1):\n                self.logger.debug('_parse11: found chunk delimiter')\n                digits = int(re_result.group(1))\n                self.logger.debug('_parse11: chunk size %d bytes', digits)\n                if data_len - start >= re_end + digits:\n                    fragment = textify(data[start + re_end:start + re_end + digits])\n                    self._session._message_list.append(fragment)\n                    start += re_end + digits\n                    self.logger.debug('_parse11: appending %d bytes', digits)\n                    self.logger.debug('_parse11: fragment = \"%s\"', fragment)\n                else:\n                    start += re_start\n                    self.logger.debug('_parse11: not enough data for chunk yet')\n                    self.logger.debug('_parse11: setting start to %d', start)\n                    break\n        if start > 0:\n            self.logger.debug('_parse11: saving back rest of message after %d bytes, original size %d', start, data_len)\n            self._session._buffer = StringIO(data[start:])\n            if start < data_len:\n                self.logger.debug('_parse11: still have data, may have another full message!')\n                self._parse11()\n        self.logger.debug('_parse11: ending')",
    "ncclient/capabilities.py": "import logging\nimport six\nlogger = logging.getLogger('ncclient.capabilities')\n\ndef _abbreviate(uri):\n    if uri.startswith('urn:ietf:params') and ':netconf:' in uri:\n        splitted = uri.split(':')\n        if ':capability:' in uri:\n            if uri.startswith('urn:ietf:params:xml:ns:netconf'):\n                name, version = (splitted[7], splitted[8])\n            else:\n                name, version = (splitted[5], splitted[6])\n            return [':' + name, ':' + name + ':' + version]\n        elif ':base:' in uri:\n            if uri.startswith('urn:ietf:params:xml:ns:netconf'):\n                return [':base', ':base' + ':' + splitted[7]]\n            else:\n                return [':base', ':base' + ':' + splitted[5]]\n    return []\n\ndef schemes(url_uri):\n    \"\"\"Given a URI that has a *scheme* query string (i.e. `:url` capability URI), will return a list of supported schemes.\"\"\"\n    return url_uri.partition('?scheme=')[2].split(',')\n\nclass Capabilities(object):\n    \"\"\"Represents the set of capabilities available to a NETCONF client or server. It is initialized with a list of capability URI's.\"\"\"\n\n    def __contains__(self, key):\n        try:\n            self.__getitem__(key)\n        except KeyError:\n            return False\n        else:\n            return True\n\n    def __getitem__(self, key):\n        try:\n            return self._dict[key]\n        except KeyError:\n            for capability in six.itervalues(self._dict):\n                if key in capability.get_abbreviations():\n                    return capability\n        raise KeyError(key)\n\n    def __len__(self):\n        return len(self._dict)\n\n    def __iter__(self):\n        return six.iterkeys(self._dict)\n\n    def __repr__(self):\n        return repr(six.iterkeys(self._dict))\n\n    def remove(self, uri):\n        \"\"\"Remove a capability.\"\"\"\n        if uri in self._dict:\n            del self._dict[uri]\n\nclass Capability(object):\n    \"\"\"Represents a single capability\"\"\"\n\n    def __eq__(self, other):\n        return self.namespace_uri == other.namespace_uri and self.parameters == other.parameters\n\n    def get_abbreviations(self):\n        return _abbreviate(self.namespace_uri)\n\nclass _Parameter(object):\n    \"\"\"Represents a parameter to a capability\"\"\"\n\nclass _InvalidParameter(Exception):\n    pass",
    "ncclient/devices/junos.py": "\"\"\"\nHandler for Juniper device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Junos\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nimport logging\nimport re\nfrom lxml import etree\nfrom lxml.etree import QName\nfrom ncclient.operations.retrieve import GetSchemaReply\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.juniper.rpc import GetConfiguration, LoadConfiguration, CompareConfiguration\nfrom ncclient.operations.third_party.juniper.rpc import ExecuteRpc, Command, Reboot, Halt, Commit, Rollback\nfrom ncclient.operations.rpc import RPCError\nfrom ncclient.xml_ import to_ele, replace_namespace, BASE_NS_1_0, NETCONF_MONITORING_NS\nfrom ncclient.transport.third_party.junos.parser import JunosXMLParser\nfrom ncclient.transport.parser import DefaultXMLParser\nfrom ncclient.transport.parser import SAXParserHandler\nlogger = logging.getLogger(__name__)\n\nclass JunosDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Juniper handler for device specific information.\n\n    \"\"\"\n\n    def reply_parsing_error_transform(self, reply_cls):\n        return self.__reply_parsing_error_transform_by_cls.get(reply_cls)\n\n    def get_xml_parser(self, session):\n        if self.device_params.get('use_filter', False):\n            l = session.get_listener_instance(SAXParserHandler)\n            if l:\n                session.remove_listener(l)\n                del l\n            session.add_listener(SAXParserHandler(session))\n            return JunosXMLParser(session)\n        else:\n            return DefaultXMLParser(session)\n\ndef fix_get_schema_reply(root):\n    data_elems = root.xpath('/nc:rpc-reply/*[local-name()=\"data\"]', namespaces={'nc': BASE_NS_1_0})\n    if len(data_elems) != 1:\n        return\n    data_el = data_elems[0]\n    namespace = QName(data_el).namespace\n    if namespace == BASE_NS_1_0:\n        logger.warning(\"The device seems to run non-rfc compliant netconf. You may want to configure: 'set system services netconf rfc-compliant'\")\n        replace_namespace(data_el, old_ns=BASE_NS_1_0, new_ns=NETCONF_MONITORING_NS)\n    elif namespace is None:\n        replace_namespace(data_el, old_ns=None, new_ns=NETCONF_MONITORING_NS)",
    "ncclient/transport/session.py": "import logging\nfrom threading import Thread, Lock, Event\ntry:\n    from Queue import Queue, Empty\nexcept ImportError:\n    from queue import Queue, Empty\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\nimport ncclient.transport\nfrom ncclient.xml_ import *\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport.errors import TransportError, SessionError, SessionCloseError\nfrom ncclient.transport.notify import Notification\nlogger = logging.getLogger('ncclient.transport.session')\nMSG_DELIM = b']]>]]>'\nEND_DELIM = b'\\n##\\n'\nTICK = 0.1\n\nclass NetconfBase(object):\n    \"\"\"Netconf Base protocol version\"\"\"\n    BASE_10 = 1\n    BASE_11 = 2\n\nclass Session(Thread):\n    \"\"\"Base class for use by transport protocol implementations.\"\"\"\n\n    def _dispatch_message(self, raw):\n        try:\n            root = parse_root(raw)\n        except Exception as e:\n            device_handled_raw = self._device_handler.handle_raw_dispatch(raw)\n            if isinstance(device_handled_raw, str):\n                root = parse_root(device_handled_raw)\n            elif isinstance(device_handled_raw, Exception):\n                self._dispatch_error(device_handled_raw)\n                return\n            else:\n                self.logger.error('error parsing dispatch message: %s', e)\n                return\n        self.logger.debug('dispatching message to different listeners: %s', raw)\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching message to listener: %r', l)\n            l.callback(root, raw)\n\n    def _dispatch_error(self, err):\n        with self._lock:\n            listeners = list(self._listeners)\n        for l in listeners:\n            self.logger.debug('dispatching error to %r', l)\n            try:\n                l.errback(err)\n            except Exception as e:\n                self.logger.warning('error dispatching to %r: %r', l, e)\n\n    def _post_connect(self, timeout=60):\n        \"\"\"Greeting stuff\"\"\"\n        init_event = Event()\n        error = [None]\n\n        def ok_cb(id, capabilities):\n            self._id = id\n            self._server_capabilities = capabilities\n            init_event.set()\n\n        def err_cb(err):\n            error[0] = err\n            init_event.set()\n        self.add_listener(NotificationHandler(self._notification_q))\n        listener = HelloHandler(ok_cb, err_cb)\n        self.add_listener(listener)\n        self.send(HelloHandler.build(self._client_capabilities, self._device_handler))\n        self.logger.debug('starting main loop')\n        self.start()\n        init_event.wait(timeout)\n        if not init_event.is_set():\n            raise SessionError('Capability exchange timed out')\n        self.remove_listener(listener)\n        if error[0]:\n            raise error[0]\n        if 'urn:ietf:params:netconf:base:1.1' in self._server_capabilities and 'urn:ietf:params:netconf:base:1.1' in self._client_capabilities:\n            self.logger.debug(\"After 'hello' message selecting netconf:base:1.1 for encoding\")\n            self._base = NetconfBase.BASE_11\n        self.logger.info('initialized: session-id=%s | server_capabilities=%s', self._id, self._server_capabilities)\n\n    def add_listener(self, listener):\n        \"\"\"Register a listener that will be notified of incoming messages and\n        errors.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('installing listener %r', listener)\n        if not isinstance(listener, SessionListener):\n            raise SessionError('Listener must be a SessionListener type')\n        with self._lock:\n            self._listeners.add(listener)\n\n    def remove_listener(self, listener):\n        \"\"\"Unregister some listener; ignore if the listener was never\n        registered.\n\n        :type listener: :class:`SessionListener`\n        \"\"\"\n        self.logger.debug('discarding listener %r', listener)\n        with self._lock:\n            self._listeners.discard(listener)\n\n    def get_listener_instance(self, cls):\n        \"\"\"If a listener of the specified type is registered, returns the\n        instance.\n\n        :type cls: :class:`SessionListener`\n        \"\"\"\n        with self._lock:\n            for listener in self._listeners:\n                if isinstance(listener, cls):\n                    return listener\n\n    def connect(self, *args, **kwds):\n        raise NotImplementedError\n\n    def _transport_read(self):\n        \"\"\"\n        Read data from underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :return: Byte string read from Transport, or None if nothing was read.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_write(self, data):\n        \"\"\"\n        Write data into underlying Transport layer, either SSH or TLS, as\n        implemented in subclass.\n\n        :param data: Byte string to write.\n        :return: Number of bytes sent, or 0 if the stream is closed.\n        \"\"\"\n        raise NotImplementedError\n\n    def _transport_register(self, selector, event):\n        \"\"\"\n        Register the channel/socket of Transport layer for selection.\n        Implemented in a subclass.\n\n        :param selector: Selector to register with.\n        :param event: Type of event for selection.\n        \"\"\"\n        raise NotImplementedError\n\n    def _send_ready(self):\n        \"\"\"\n        Check if Transport layer is ready to send the data. Implemented\n        in a subclass.\n\n        :return: True if the layer is ready, False otherwise.\n        \"\"\"\n        raise NotImplementedError\n\n    def run(self):\n        q = self._q\n\n        def start_delim(data_len):\n            return b'\\n#%i\\n' % data_len\n        try:\n            s = selectors.DefaultSelector()\n            self._transport_register(s, selectors.EVENT_READ)\n            self.logger.debug('selector type = %s', s.__class__.__name__)\n            while True:\n                if not q.empty() and self._send_ready():\n                    self.logger.debug('Sending message')\n                    data = q.get().encode()\n                    if self._base == NetconfBase.BASE_11:\n                        data = b'%s%s%s' % (start_delim(len(data)), data, END_DELIM)\n                    else:\n                        data = b'%s%s' % (data, MSG_DELIM)\n                    self.logger.info('Sending:\\n%s', data)\n                    while data:\n                        n = self._transport_write(data)\n                        if n <= 0:\n                            raise SessionCloseError(self._buffer.getvalue(), data)\n                        data = data[n:]\n                events = s.select(timeout=TICK)\n                if events:\n                    data = self._transport_read()\n                    if data:\n                        try:\n                            self.parser.parse(data)\n                        except ncclient.transport.parser.SAXFilterXMLNotFoundError:\n                            self.logger.debug('switching from sax to dom parsing')\n                            self.parser = ncclient.transport.parser.DefaultXMLParser(self)\n                            self.parser.parse(data)\n                    elif self._closing.is_set():\n                        break\n                    else:\n                        raise SessionCloseError(self._buffer.getvalue())\n        except Exception as e:\n            self.logger.debug('Broke out of main loop, error=%r', e)\n            self._dispatch_error(e)\n            self.close()\n\n    def send(self, message):\n        \"\"\"Send the supplied *message* (xml string) to NETCONF server.\"\"\"\n        if not self.connected:\n            raise TransportError('Not connected to NETCONF server')\n        self.logger.debug('queueing %s', message)\n        self._q.put(message)\n\n    def scp(self):\n        raise NotImplementedError\n\n    def take_notification(self, block, timeout):\n        try:\n            return self._notification_q.get(block, timeout)\n        except Empty:\n            return None\n\n    @property\n    def connected(self):\n        \"\"\"Connection status of the session.\"\"\"\n        return self._connected\n\n    @property\n    def client_capabilities(self):\n        \"\"\"Client's :class:`Capabilities`\"\"\"\n        return self._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"\"\"Server's :class:`Capabilities`\"\"\"\n        return self._server_capabilities\n\n    @property\n    def id(self):\n        \"\"\"A string representing the `session-id`. If the session has not been initialized it will be `None`\"\"\"\n        return self._id\n\nclass SessionListener(object):\n    \"\"\"Base class for :class:`Session` listeners, which are notified when a new\n    NETCONF message is received or an error occurs.\n\n    .. note::\n        Avoid time-intensive tasks in a callback's context.\n    \"\"\"\n\n    def callback(self, root, raw):\n        \"\"\"Called when a new XML document is received. The *root* argument allows the callback to determine whether it wants to further process the document.\n\n        Here, *root* is a tuple of *(tag, attributes)* where *tag* is the qualified name of the root element and *attributes* is a dictionary of its attributes (also qualified names).\n\n        *raw* will contain the XML document as a string.\n        \"\"\"\n        raise NotImplementedError\n\n    def errback(self, ex):\n        \"\"\"Called when an error occurs.\n\n        :type ex: :exc:`Exception`\n        \"\"\"\n        raise NotImplementedError\n\nclass HelloHandler(SessionListener):\n\n    def __init__(self, init_cb, error_cb):\n        self._init_cb = init_cb\n        self._error_cb = error_cb\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if tag == qualify('hello') or tag == 'hello':\n            try:\n                id, capabilities = HelloHandler.parse(raw)\n            except Exception as e:\n                self._error_cb(e)\n            else:\n                self._init_cb(id, capabilities)\n\n    def errback(self, err):\n        self._error_cb(err)\n\n    @staticmethod\n    def build(capabilities, device_handler):\n        \"\"\"Given a list of capability URI's returns <hello> message XML string\"\"\"\n        if device_handler:\n            xml_namespace_kwargs = {'nsmap': device_handler.get_xml_base_namespace_dict()}\n        else:\n            xml_namespace_kwargs = {}\n        hello = new_ele('hello', **xml_namespace_kwargs)\n        caps = sub_ele(hello, 'capabilities')\n\n        def fun(uri):\n            sub_ele(caps, 'capability').text = uri\n        if sys.version < '3':\n            map(fun, capabilities)\n        else:\n            list(map(fun, capabilities))\n        return to_xml(hello)\n\n    @staticmethod\n    def parse(raw):\n        \"\"\"Returns tuple of (session-id (str), capabilities (Capabilities)\"\"\"\n        sid, capabilities = (0, [])\n        root = to_ele(raw)\n        for child in root.getchildren():\n            if child.tag == qualify('session-id') or child.tag == 'session-id':\n                sid = child.text\n            elif child.tag == qualify('capabilities') or child.tag == 'capabilities':\n                for cap in child.getchildren():\n                    if cap.tag == qualify('capability') or cap.tag == 'capability':\n                        capabilities.append(cap.text)\n        return (sid, Capabilities(capabilities))\n\nclass NotificationHandler(SessionListener):\n\n    def __init__(self, notification_q):\n        self._notification_q = notification_q\n\n    def callback(self, root, raw):\n        tag, _ = root\n        if tag == qualify('notification', NETCONF_NOTIFICATION_NS):\n            self._notification_q.put(Notification(raw))\n\n    def errback(self, _):\n        pass",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/transport/ssh.py": "import base64\nimport getpass\nimport os\nimport re\nimport six\nimport sys\nimport socket\nimport threading\nfrom binascii import hexlify\ntry:\n    import selectors\nexcept ImportError:\n    import selectors2 as selectors\nfrom ncclient.capabilities import Capabilities\nfrom ncclient.logging_ import SessionLoggerAdapter\nimport paramiko\nfrom ncclient.transport.errors import AuthenticationError, SSHError, SSHUnknownHostError\nfrom ncclient.transport.session import Session\nfrom ncclient.transport.parser import DefaultXMLParser\nimport logging\nlogger = logging.getLogger('ncclient.transport.ssh')\nPORT_NETCONF_DEFAULT = 830\nBUF_SIZE = 4096\nRE_NC11_DELIM = re.compile(b'\\\\n(?:#([0-9]+)|(##))\\\\n')\n\ndef default_unknown_host_cb(host, fingerprint):\n    \"\"\"An unknown host callback returns `True` if it finds the key acceptable, and `False` if not.\n\n    This default callback always returns `False`, which would lead to :meth:`connect` raising a :exc:`SSHUnknownHost` exception.\n\n    Supply another valid callback if you need to verify the host key programmatically.\n\n    *host* is the hostname that needs to be verified\n\n    *fingerprint* is a hex string representing the host key fingerprint, colon-delimited e.g. `\"4b:69:6c:72:6f:79:20:77:61:73:20:68:65:72:65:21\"`\n    \"\"\"\n    return False\n\ndef _colonify(fp):\n    fp = fp.decode('UTF-8')\n    finga = fp[:2]\n    for idx in range(2, len(fp), 2):\n        finga += ':' + fp[idx:idx + 2]\n    return finga\nif sys.version < '3':\n    from six import StringIO\nelse:\n    from io import BytesIO as StringIO\n\nclass SSHSession(Session):\n    \"\"\"Implements a :rfc:`4742` NETCONF session over SSH.\"\"\"\n\n    def _dispatch_message(self, raw):\n        self.logger.info('Received message from host')\n        self.logger.debug('Received:\\n%s', raw)\n        return super(SSHSession, self)._dispatch_message(raw)\n\n    def _parse(self):\n        \"\"\"Messages ae delimited by MSG_DELIM. The buffer could have grown by a maximum of BUF_SIZE bytes everytime this method is called. Retains state across method calls and if a byte has been read it will not be considered again.\"\"\"\n        return self.parser._parse10()\n\n    def load_known_hosts(self, filename=None):\n        \"\"\"Load host keys from an openssh :file:`known_hosts`-style file. Can\n        be called multiple times.\n\n        If *filename* is not specified, looks in the default locations i.e. :file:`~/.ssh/known_hosts` and :file:`~/ssh/known_hosts` for Windows.\n        \"\"\"\n        if filename is None:\n            filename = os.path.expanduser('~/.ssh/known_hosts')\n            try:\n                self._host_keys.load(filename)\n            except IOError:\n                filename = os.path.expanduser('~/ssh/known_hosts')\n                try:\n                    self._host_keys.load(filename)\n                except IOError:\n                    pass\n        else:\n            self._host_keys.load(filename)\n\n    def close(self):\n        self._closing.set()\n        if self._transport.is_active():\n            self._transport.close()\n        while self.is_alive() and self is not threading.current_thread():\n            self.join(10)\n        if self._channel:\n            self._channel.close()\n        self._channel = None\n        self._connected = False\n\n    def connect(self, host, port=PORT_NETCONF_DEFAULT, timeout=None, unknown_host_cb=default_unknown_host_cb, username=None, password=None, key_filename=None, allow_agent=True, hostkey_verify=True, hostkey_b64=None, look_for_keys=True, ssh_config=None, sock_fd=None, bind_addr=None, sock=None, keepalive=None, environment=None):\n        \"\"\"Connect via SSH and initialize the NETCONF session. First attempts the publickey authentication method and then password authentication.\n\n        To disable attempting publickey authentication altogether, call with *allow_agent* and *look_for_keys* as `False`.\n\n        *host* is the hostname or IP address to connect to\n\n        *port* is by default 830 (PORT_NETCONF_DEFAULT), but some devices use the default SSH port of 22 so this may need to be specified\n\n        *timeout* is an optional timeout for socket connect\n\n        *unknown_host_cb* is called when the server host key is not recognized. It takes two arguments, the hostname and the fingerprint (see the signature of :func:`default_unknown_host_cb`)\n\n        *username* is the username to use for SSH authentication\n\n        *password* is the password used if using password authentication, or the passphrase to use for unlocking keys that require it\n\n        *key_filename* is a filename where a the private key to be used can be found\n\n        *allow_agent* enables querying SSH agent (if found) for keys\n\n        *hostkey_verify* enables hostkey verification from ~/.ssh/known_hosts\n\n        *hostkey_b64* only connect when server presents a public hostkey matching this (obtain from server /etc/ssh/ssh_host_*pub or ssh-keyscan)\n\n        *look_for_keys* enables looking in the usual locations for ssh keys (e.g. :file:`~/.ssh/id_*`)\n\n        *ssh_config* enables parsing of an OpenSSH configuration file, if set to its path, e.g. :file:`~/.ssh/config` or to True (in this case, use :file:`~/.ssh/config`).\n\n        *sock_fd* is an already open socket which shall be used for this connection. Useful for NETCONF outbound ssh. Use host=None together with a valid sock_fd number\n\n        *bind_addr* is a (local) source IP address to use, must be reachable from the remote device.\n        \n        *sock* is an already open Python socket to be used for this connection.\n\n        *keepalive* Turn on/off keepalive packets (default is off). If this is set, after interval seconds without sending any data over the connection, a \"keepalive\" packet will be sent (and ignored by the remote host). This can be useful to keep connections alive over a NAT.\n\n        *environment* a dictionary containing the name and respective values to set\n        \"\"\"\n        if not (host or sock_fd or sock):\n            raise SSHError('Missing host, socket or socket fd')\n        self._host = host\n        config = {}\n        if ssh_config is True:\n            ssh_config = '~/.ssh/config' if sys.platform != 'win32' else '~/ssh/config'\n        if ssh_config is not None:\n            config = paramiko.SSHConfig()\n            with open(os.path.expanduser(ssh_config)) as ssh_config_file_obj:\n                config.parse(ssh_config_file_obj)\n            paramiko_default_ssh_port = paramiko.config.SSH_PORT\n            paramiko.config.SSH_PORT = port\n            config = config.lookup(host)\n            paramiko.config.SSH_PORT = paramiko_default_ssh_port\n            host = config.get('hostname', host)\n            if username is None:\n                username = config.get('user')\n            if key_filename is None:\n                key_filename = config.get('identityfile')\n            if timeout is None:\n                timeout = config.get('connecttimeout')\n                if timeout:\n                    timeout = int(timeout)\n        if hostkey_verify:\n            userknownhostsfile = config.get('userknownhostsfile')\n            if userknownhostsfile:\n                self.load_known_hosts(os.path.expanduser(userknownhostsfile))\n            else:\n                self.load_known_hosts()\n        if username is None:\n            username = getpass.getuser()\n        if sock_fd is None and sock is None:\n            proxycommand = config.get('proxycommand')\n            if proxycommand:\n                self.logger.debug('Configuring Proxy. %s', proxycommand)\n                if not isinstance(proxycommand, six.string_types):\n                    proxycommand = [os.path.expanduser(elem) for elem in proxycommand]\n                else:\n                    proxycommand = os.path.expanduser(proxycommand)\n                sock = paramiko.proxy.ProxyCommand(proxycommand)\n            else:\n                for res in socket.getaddrinfo(host, port, socket.AF_UNSPEC, socket.SOCK_STREAM):\n                    af, socktype, proto, canonname, sa = res\n                    try:\n                        sock = socket.socket(af, socktype, proto)\n                        sock.settimeout(timeout)\n                    except socket.error:\n                        continue\n                    try:\n                        if bind_addr:\n                            sock.bind((bind_addr, 0))\n                        sock.connect(sa)\n                    except socket.error:\n                        sock.close()\n                        continue\n                    break\n                else:\n                    raise SSHError('Could not open socket to %s:%s' % (host, port))\n        elif sock is None:\n            if sys.version_info[0] < 3:\n                s = socket.fromfd(int(sock_fd), socket.AF_INET, socket.SOCK_STREAM)\n                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, _sock=s)\n            else:\n                sock = socket.fromfd(int(sock_fd), socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n        self._transport = paramiko.Transport(sock)\n        self._transport.set_log_channel(logger.name)\n        if config.get('compression') == 'yes':\n            self._transport.use_compression()\n        if hostkey_b64:\n            hostkey_obj = None\n            for key_cls in [paramiko.DSSKey, paramiko.Ed25519Key, paramiko.RSAKey, paramiko.ECDSAKey]:\n                try:\n                    hostkey_obj = key_cls(data=base64.b64decode(hostkey_b64))\n                except paramiko.SSHException:\n                    pass\n            if not hostkey_obj:\n                raise SSHError(\"Couldn't find suitable paramiko key class for host key %s\" % hostkey_b64)\n            self._transport._preferred_keys = [hostkey_obj.get_name()]\n        elif self._host_keys:\n            known_host_keys_for_this_host = self._host_keys.lookup(host) or {}\n            host_port = '[%s]:%s' % (host, port)\n            known_host_keys_for_this_host.update(self._host_keys.lookup(host_port) or {})\n            if known_host_keys_for_this_host:\n                self._transport._preferred_keys = list(known_host_keys_for_this_host)\n        try:\n            self._transport.start_client()\n        except paramiko.SSHException as e:\n            raise SSHError('Negotiation failed: %s' % e)\n        if hostkey_verify:\n            server_key_obj = self._transport.get_remote_server_key()\n            fingerprint = _colonify(hexlify(server_key_obj.get_fingerprint()))\n            is_known_host = False\n            known_hosts_lookups = [host, '[%s]:%s' % (host, port)]\n            if hostkey_b64:\n                if hostkey_obj.get_name() == server_key_obj.get_name() and hostkey_obj.asbytes() == server_key_obj.asbytes():\n                    is_known_host = True\n            else:\n                is_known_host = any((self._host_keys.check(lookup, server_key_obj) for lookup in known_hosts_lookups))\n            if not is_known_host and (not unknown_host_cb(host, fingerprint)):\n                raise SSHUnknownHostError(known_hosts_lookups[0], fingerprint)\n        if key_filename is None:\n            key_filenames = []\n        elif isinstance(key_filename, (str, bytes)):\n            key_filenames = [key_filename]\n        else:\n            key_filenames = key_filename\n        self._auth(username, password, key_filenames, allow_agent, look_for_keys)\n        self._connected = True\n        self._closing.clear()\n        if keepalive:\n            self._transport.set_keepalive(keepalive)\n        subsystem_names = self._device_handler.get_ssh_subsystem_names()\n        for subname in subsystem_names:\n            self._channel = self._transport.open_session()\n            self._channel_id = self._channel.get_id()\n            channel_name = '%s-subsystem-%s' % (subname, str(self._channel_id))\n            self._channel.set_name(channel_name)\n            if environment:\n                try:\n                    self._channel.update_environment(environment)\n                except paramiko.SSHException as e:\n                    self.logger.info('%s (environment update rejected)', e)\n                    handle_exception = self._device_handler.handle_connection_exceptions(self)\n                    if not handle_exception:\n                        continue\n            try:\n                self._channel.invoke_subsystem(subname)\n            except paramiko.SSHException as e:\n                self.logger.info('%s (subsystem request rejected)', e)\n                handle_exception = self._device_handler.handle_connection_exceptions(self)\n                if not handle_exception:\n                    continue\n            self._channel_name = self._channel.get_name()\n            self._post_connect(timeout)\n            self.parser = self._device_handler.get_xml_parser(self)\n            return\n        raise SSHError('Could not open connection, possibly due to unacceptable SSH subsystem name.')\n\n    def _auth(self, username, password, key_filenames, allow_agent, look_for_keys):\n        saved_exception = None\n        for key_filename in key_filenames:\n            try:\n                key = paramiko.PKey.from_path(key_filename, password.encode('utf-8'))\n                self.logger.debug('Trying key %s from %s', hexlify(key.get_fingerprint()), key_filename)\n                self._transport.auth_publickey(username, key)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n        if allow_agent:\n            prepend_agent_keys = []\n            append_agent_keys = list(paramiko.Agent().get_keys())\n            for key_filename in key_filenames:\n                pubkey_filename = key_filename.strip('.pub') + '.pub'\n                try:\n                    file_key = paramiko.PublicBlob.from_file(pubkey_filename).key_blob\n                except (FileNotFoundError, ValueError):\n                    continue\n                for idx, agent_key in enumerate(append_agent_keys):\n                    if agent_key.asbytes() == file_key:\n                        self.logger.debug('Prioritising SSH agent key found in %s', key_filename)\n                        prepend_agent_keys.append(append_agent_keys.pop(idx))\n                        break\n            agent_keys = tuple(prepend_agent_keys + append_agent_keys)\n            for key in agent_keys:\n                try:\n                    self.logger.debug('Trying SSH agent key %s', hexlify(key.get_fingerprint()))\n                    self._transport.auth_publickey(username, key)\n                    return\n                except Exception as e:\n                    saved_exception = e\n                    self.logger.debug(e)\n        keyfiles = []\n        if look_for_keys:\n            rsa_key = os.path.expanduser('~/.ssh/id_rsa')\n            dsa_key = os.path.expanduser('~/.ssh/id_dsa')\n            ecdsa_key = os.path.expanduser('~/.ssh/id_ecdsa')\n            ed25519_key = os.path.expanduser('~/.ssh/id_ed25519')\n            if os.path.isfile(rsa_key):\n                keyfiles.append(rsa_key)\n            if os.path.isfile(dsa_key):\n                keyfiles.append(dsa_key)\n            if os.path.isfile(ecdsa_key):\n                keyfiles.append(ecdsa_key)\n            if os.path.isfile(ed25519_key):\n                keyfiles.append(ed25519_key)\n            rsa_key = os.path.expanduser('~/ssh/id_rsa')\n            dsa_key = os.path.expanduser('~/ssh/id_dsa')\n            ecdsa_key = os.path.expanduser('~/ssh/id_ecdsa')\n            ed25519_key = os.path.expanduser('~/ssh/id_ed25519')\n            if os.path.isfile(rsa_key):\n                keyfiles.append(rsa_key)\n            if os.path.isfile(dsa_key):\n                keyfiles.append(dsa_key)\n            if os.path.isfile(ecdsa_key):\n                keyfiles.append(ecdsa_key)\n            if os.path.isfile(ed25519_key):\n                keyfiles.append(ed25519_key)\n        for filename in keyfiles:\n            try:\n                key = paramiko.PKey.from_path(filename, password.encode('utf-8'))\n                self.logger.debug('Trying discovered key %s in %s', hexlify(key.get_fingerprint()), filename)\n                self._transport.auth_publickey(username, key)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n        if password is not None:\n            try:\n                self._transport.auth_password(username, password)\n                return\n            except Exception as e:\n                saved_exception = e\n                self.logger.debug(e)\n        if saved_exception is not None:\n            raise AuthenticationError(repr(saved_exception))\n        raise AuthenticationError('No authentication methods available')\n\n    def _transport_read(self):\n        return self._channel.recv(BUF_SIZE)\n\n    def _transport_write(self, data):\n        return self._channel.send(data)\n\n    def _transport_register(self, selector, event):\n        selector.register(self._channel, event)\n\n    def _send_ready(self):\n        return self._channel.send_ready()\n\n    @property\n    def host(self):\n        \"\"\"Host this session is connected to, or None if not connected.\"\"\"\n        if hasattr(self, '_host'):\n            return self._host\n        return None\n\n    @property\n    def transport(self):\n        \"\"\"Underlying `paramiko.Transport <http://www.lag.net/paramiko/docs/paramiko.Transport-class.html>`_ object. This makes it possible to call methods like :meth:`~paramiko.Transport.set_keepalive` on it.\"\"\"\n        return self._transport"
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:setUp": {
      "ncclient/devices/junos.py:JunosDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:test_additional_operations": {
      "ncclient/devices/junos.py:JunosDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:test_handle_connection_exceptions": {
      "ncclient/transport/ssh.py:SSHSession:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {},
        "ncclient/capabilities.py:Capabilities:__init__": {
          "ncclient/capabilities.py:Capabilities:add": {
            "ncclient/capabilities.py:Capability:from_uri": {
              "ncclient/capabilities.py:Capability:__init__": {},
              "ncclient/capabilities.py:_parse_parameter_string": {
                "ncclient/capabilities.py:_Parameter:from_string": {
                  "ncclient/capabilities.py:_Parameter:__init__": {}
                }
              }
            }
          }
        },
        "ncclient/transport/session.py:Session:__init__": {},
        "ncclient/transport/parser.py:DefaultXMLParser:__init__": {}
      },
      "ncclient/devices/junos.py:JunosDeviceHandler:handle_connection_exceptions": {}
    },
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:test_handle_raw_dispatch": {
      "ncclient/devices/junos.py:JunosDeviceHandler:handle_raw_dispatch": {
        "ncclient/operations/rpc.py:RPCError:__init__": {
          "ncclient/operations/rpc.py:RPCError:message": {},
          "ncclient/operations/rpc.py:RPCError:to_dict": {},
          "ncclient/operations/rpc.py:RPCError:severity": {}
        },
        "ncclient/xml_.py:to_ele": {
          "ncclient/xml_.py:_get_parser": {}
        }
      }
    },
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:test_perform_quality_check": {
      "ncclient/devices/junos.py:JunosDeviceHandler:perform_qualify_check": {}
    },
    "modified_testcases/unit/devices/test_junos.py:TestJunosDevice:test_transform_reply": {
      "ncclient/devices/junos.py:JunosDeviceHandler:transform_reply": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}