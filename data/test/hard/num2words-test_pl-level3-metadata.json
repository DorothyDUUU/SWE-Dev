{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_pl",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_pl.py",
  "test_code": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom unittest import TestCase\n\nfrom num2words import num2words\n\n\nclass Num2WordsPLTest(TestCase):\n    def test_cardinal(self):\n        self.assertEqual(num2words(90, lang='pl'), \"dziewi\u0119\u0107dziesi\u0105t\")\n        self.assertEqual(num2words(100, lang='pl'), \"sto\")\n        self.assertEqual(num2words(101, lang='pl'), \"sto jeden\")\n        self.assertEqual(num2words(110, lang='pl'), \"sto dziesi\u0119\u0107\")\n        self.assertEqual(num2words(115, lang='pl'), \"sto pi\u0119tna\u015bcie\")\n        self.assertEqual(num2words(123, lang='pl'), \"sto dwadzie\u015bcia trzy\")\n        self.assertEqual(num2words(400, lang='pl'), \"czterysta\")\n        self.assertEqual(num2words(1000, lang='pl'), \"tysi\u0105c\")\n        self.assertEqual(num2words(1001, lang='pl'), \"tysi\u0105c jeden\")\n        self.assertEqual(num2words(2012, lang='pl'), \"dwa tysi\u0105ce dwana\u015bcie\")\n        self.assertEqual(\n            num2words(10.02, lang='pl'),\n            \"dziesi\u0119\u0107 przecinek zero dwa\"\n        )\n        self.assertEqual(\n            num2words(15.007, lang='pl'),\n            \"pi\u0119tna\u015bcie przecinek zero zero siedem\"\n        )\n        self.assertEqual(\n            num2words(12519.85, lang='pl'),\n            \"dwana\u015bcie tysi\u0119cy pi\u0119\u0107set dziewi\u0119tna\u015bcie przecinek \"\n            \"osiemdziesi\u0105t pi\u0119\u0107\"\n        )\n        self.assertEqual(\n            num2words(123.50, lang='pl'),\n            \"sto dwadzie\u015bcia trzy przecinek pi\u0119\u0107\"\n        )\n        self.assertEqual(\n            num2words(1234567890, lang='pl'),\n            \"miliard dwie\u015bcie trzydzie\u015bci cztery miliony pi\u0119\u0107set \"\n            \"sze\u015b\u0107dziesi\u0105t siedem tysi\u0119cy osiemset dziewi\u0119\u0107dziesi\u0105t\"\n        )\n        self.assertEqual(\n            num2words(10000000001000000100000, lang='pl'),\n            \"dziesi\u0119\u0107 tryliard\u00f3w bilion sto tysi\u0119cy\"\n        )\n        self.assertEqual(\n            num2words(215461407892039002157189883901676, lang='pl'),\n            \"dwie\u015bcie pi\u0119tna\u015bcie kwintylion\u00f3w czterysta sze\u015b\u0107dziesi\u0105t jeden \"\n            \"kwadryliard\u00f3w czterysta siedem kwadrylion\u00f3w osiemset \"\n            \"dziewi\u0119\u0107dziesi\u0105t dwa tryliardy trzydzie\u015bci dziewi\u0119\u0107 trylion\u00f3w \"\n            \"dwa biliardy sto pi\u0119\u0107dziesi\u0105t siedem bilion\u00f3w sto osiemdziesi\u0105t \"\n            \"dziewi\u0119\u0107 miliard\u00f3w osiemset osiemdziesi\u0105t trzy miliony \"\n            \"dziewi\u0119\u0107set jeden tysi\u0119cy sze\u015b\u0107set siedemdziesi\u0105t sze\u015b\u0107\"\n        )\n        self.assertEqual(\n            num2words(719094234693663034822824384220291, lang='pl'),\n            \"siedemset dziewi\u0119tna\u015bcie kwintylion\u00f3w dziewi\u0119\u0107dziesi\u0105t cztery \"\n            \"kwadryliardy dwie\u015bcie trzydzie\u015bci cztery kwadryliony sze\u015b\u0107set \"\n            \"dziewi\u0119\u0107dziesi\u0105t trzy tryliardy sze\u015b\u0107set sze\u015b\u0107dziesi\u0105t trzy \"\n            \"tryliony trzydzie\u015bci cztery biliardy osiemset dwadzie\u015bcia dwa \"\n            \"biliony osiemset dwadzie\u015bcia cztery miliardy trzysta \"\n            \"osiemdziesi\u0105t cztery miliony dwie\u015bcie dwadzie\u015bcia \"\n            \"tysi\u0119cy dwie\u015bcie dziewi\u0119\u0107dziesi\u0105t jeden\"\n        )\n        self.assertEqual(\n            num2words(\n                963301000001918264129471001047146102 * 10**30 + 1007,\n                lang='pl'\n            ),\n            \"dziewi\u0119\u0107set sze\u015b\u0107dziesi\u0105t trzy decyliardy trzysta jeden \"\n            \"decylion\u00f3w nonylion dziewi\u0119\u0107set osiemna\u015bcie oktyliard\u00f3w dwie\u015bcie \"\n            \"sze\u015b\u0107dziesi\u0105t cztery oktyliony sto dwadzie\u015bcia dziewi\u0119\u0107 \"\n            \"septyliard\u00f3w czterysta siedemdziesi\u0105t jeden septylion\u00f3w \"\n            \"sekstyliard czterdzie\u015bci siedem sekstylion\u00f3w sto czterdzie\u015bci \"\n            \"sze\u015b\u0107 kwintyliard\u00f3w sto dwa kwintyliony tysi\u0105c siedem\"\n        )\n\n    def test_to_ordinal(self):\n        self.assertEqual(num2words(100, lang='pl', to='ordinal'), \"setny\")\n        self.assertEqual(\n            num2words(101, lang='pl', to='ordinal'), \"sto pierwszy\")\n        self.assertEqual(num2words(120, lang='pl', to='ordinal'),\n                         \"sto dwudziesty\")\n        self.assertEqual(num2words(20, lang='pl', to='ordinal'), \"dwudziesty\")\n        self.assertEqual(num2words(121, lang='pl', to='ordinal'),\n                         \"sto dwudziesty pierwszy\")\n        self.assertEqual(\n            num2words(115, lang='pl', to='ordinal'), \"sto pi\u0119tnasty\")\n        self.assertEqual(\n            num2words(25, lang='pl', to='ordinal'), \"dwudziesty pi\u0105ty\")\n        self.assertEqual(num2words(1021, lang='pl', to='ordinal'),\n                         \"tysi\u0105c dwudziesty pierwszy\")\n        self.assertEqual(\n            num2words(120, lang='pl', to='ordinal'), \"sto dwudziesty\")\n        self.assertEqual(num2words(1000021, lang='pl',\n                                   to='ordinal'), \"milion dwudziesty pierwszy\")\n        self.assertEqual(num2words(1000, lang='pl', to='ordinal'), \"tysi\u0119czny\")\n        self.assertEqual(num2words(10000, lang='pl',\n                                   to='ordinal'), \"dziesi\u0119ciotysi\u0119czny\")\n        self.assertEqual(num2words(100000000, lang='pl',\n                                   to='ordinal'), \"stumilionowy\")\n        self.assertEqual(num2words(1002000, lang='pl',\n                                   to='ordinal'), \"milion dwutysi\u0119czny\")\n        self.assertEqual(num2words(1001000, lang='pl',\n                                   to='ordinal'), \"milion tysi\u0119czny\")\n        self.assertEqual(num2words(1000000, lang='pl',\n                                   to='ordinal'), \"milionowy\")\n\n    def test_to_ordinal_error(self):\n        with self.assertRaises(NotImplementedError):\n            num2words(1.5, lang='pl', to='ordinal')\n\n    def test_currency(self):\n        self.assertEqual(\n            num2words(1.0, lang='pl', to='currency', currency='EUR'),\n            \"jeden euro, zero cent\u00f3w\")\n        self.assertEqual(\n            num2words(1.0, lang='pl', to='currency', currency='PLN'),\n            \"jeden z\u0142oty, zero groszy\")\n        self.assertEqual(\n            num2words(1234.56, lang='pl', to='currency', currency='EUR'),\n            \"tysi\u0105c dwie\u015bcie trzydzie\u015bci cztery euro, pi\u0119\u0107dziesi\u0105t sze\u015b\u0107 \"\n            \"cent\u00f3w\"\n        )\n        self.assertEqual(\n            num2words(1234.56, lang='pl', to='currency', currency='PLN'),\n            \"tysi\u0105c dwie\u015bcie trzydzie\u015bci cztery z\u0142ote, pi\u0119\u0107dziesi\u0105t sze\u015b\u0107 \"\n            \"groszy\"\n        )\n        self.assertEqual(\n            num2words(10111, lang='pl', to='currency', currency='EUR',\n                      separator=' i'),\n            \"sto jeden euro i jedena\u015bcie cent\u00f3w\"\n        )\n        self.assertEqual(\n            num2words(10121, lang='pl', to='currency', currency='PLN',\n                      separator=' i'),\n            \"sto jeden z\u0142otych i dwadzie\u015bcia jeden groszy\"\n        )\n        self.assertEqual(\n            num2words(-1251985, lang='pl', to='currency', cents=False),\n            \"minus dwana\u015bcie tysi\u0119cy pi\u0119\u0107set dziewi\u0119tna\u015bcie euro, 85 cent\u00f3w\"\n        )\n        self.assertEqual(\n            num2words(123.50, lang='pl', to='currency', currency='PLN',\n                      separator=' i'),\n            \"sto dwadzie\u015bcia trzy z\u0142ote i pi\u0119\u0107dziesi\u0105t groszy\"\n        )\n        self.assertEqual(\n            num2words(1950, lang='pl', to='currency', cents=False),\n            \"dziewi\u0119tna\u015bcie euro, 50 cent\u00f3w\"\n        )\n",
  "GT_file_code": {
    "num2words/lang_PL.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nimport itertools\n\nfrom .base import Num2Word_Base\nfrom .utils import get_digits, splitbyx\n\nZERO = ('zero',)\n\nONES = {\n    1: ('jeden',),\n    2: ('dwa',),\n    3: ('trzy',),\n    4: ('cztery',),\n    5: ('pi\u0119\u0107',),\n    6: ('sze\u015b\u0107',),\n    7: ('siedem',),\n    8: ('osiem',),\n    9: ('dziewi\u0119\u0107',),\n}\n\nONES_ORDINALS = {\n    1: ('pierwszy', \"pierwszo\"),\n    2: ('drugi', \"dwu\"),\n    3: ('trzeci', \"trzy\"),\n    4: ('czwarty', \"cztero\"),\n    5: ('pi\u0105ty', \"pi\u0119cio\"),\n    6: ('sz\u00f3sty', \"sze\u015bcio\"),\n    7: ('si\u00f3dmy', \"siedmio\"),\n    8: ('\u00f3smy', \"o\u015bmio\"),\n    9: ('dziewi\u0105ty', \"dziewi\u0119cio\"),\n    10: ('dziesi\u0105ty', \"dziesi\u0119cio\"),\n    11: ('jedenasty', \"jedenasto\"),\n    12: ('dwunasty', \"dwunasto\"),\n    13: ('trzynasty', \"trzynasto\"),\n    14: ('czternasty', \"czternasto\"),\n    15: ('pi\u0119tnasty', \"pi\u0119tnasto\"),\n    16: ('szesnasty', \"szesnasto\"),\n    17: ('siedemnasty', \"siedemnasto\"),\n    18: ('osiemnasty', \"osiemnasto\"),\n    19: ('dziewi\u0119tnasty', \"dziewi\u0119tnasto\"),\n}\n\nTENS = {\n    0: ('dziesi\u0119\u0107',),\n    1: ('jedena\u015bcie',),\n    2: ('dwana\u015bcie',),\n    3: ('trzyna\u015bcie',),\n    4: ('czterna\u015bcie',),\n    5: ('pi\u0119tna\u015bcie',),\n    6: ('szesna\u015bcie',),\n    7: ('siedemna\u015bcie',),\n    8: ('osiemna\u015bcie',),\n    9: ('dziewi\u0119tna\u015bcie',),\n}\n\n\nTWENTIES = {\n    2: ('dwadzie\u015bcia',),\n    3: ('trzydzie\u015bci',),\n    4: ('czterdzie\u015bci',),\n    5: ('pi\u0119\u0107dziesi\u0105t',),\n    6: ('sze\u015b\u0107dziesi\u0105t',),\n    7: ('siedemdziesi\u0105t',),\n    8: ('osiemdziesi\u0105t',),\n    9: ('dziewi\u0119\u0107dziesi\u0105t',),\n}\n\nTWENTIES_ORDINALS = {\n    2: ('dwudziesty', \"dwudziesto\"),\n    3: ('trzydziesty', \"trzydiesto\"),\n    4: ('czterdziesty', \"czterdziesto\"),\n    5: ('pi\u0119\u0107dziesi\u0105ty', \"pi\u0119\u0107dziesi\u0119cio\"),\n    6: ('sze\u015b\u0107dziesi\u0105ty', \"sze\u015b\u0107dziesi\u0119cio\"),\n    7: ('siedemdziesi\u0105ty', \"siedemdziesi\u0119cio\"),\n    8: ('osiemdziesi\u0105ty', \"osiemdziesi\u0119cio\"),\n    9: ('dziewi\u0119\u0107dziesi\u0105ty', \"dziewi\u0119\u0107dziesi\u0119cio\"),\n}\n\nHUNDREDS = {\n    1: ('sto',),\n    2: ('dwie\u015bcie',),\n    3: ('trzysta',),\n    4: ('czterysta',),\n    5: ('pi\u0119\u0107set',),\n    6: ('sze\u015b\u0107set',),\n    7: ('siedemset',),\n    8: ('osiemset',),\n    9: ('dziewi\u0119\u0107set',),\n}\n\nHUNDREDS_ORDINALS = {\n    1: ('setny', \"stu\"),\n    2: ('dwusetny', \"dwustu\"),\n    3: ('trzysetny', \"trzystu\"),\n    4: ('czterysetny', \"czterystu\"),\n    5: ('pi\u0119\u0107setny', \"pi\u0119cset\"),\n    6: ('sze\u015b\u0107setny', \"sze\u015b\u0107set\"),\n    7: ('siedemsetny', \"siedemset\"),\n    8: ('osiemsetny', \"o\u015biemset\"),\n    9: ('dziewi\u0119\u0107setny', \"dziewi\u0119\u0107set\"),\n}\n\nTHOUSANDS = {\n    1: ('tysi\u0105c', 'tysi\u0105ce', 'tysi\u0119cy'),  # 10^3\n}\n\nprefixes_ordinal = {\n    1: \"tysi\u0119czny\",\n    2: \"milionowy\",\n    3: \"milairdowy\"\n}\n\nprefixes = (   # 10^(6*x)\n    \"mi\",      # 10^6\n    \"bi\",      # 10^12\n    \"try\",     # 10^18\n    \"kwadry\",  # 10^24\n    \"kwinty\",  # 10^30\n    \"seksty\",  # 10^36\n    \"septy\",   # 10^42\n    \"okty\",    # 10^48\n    \"nony\",    # 10^54\n    \"decy\"     # 10^60\n)\nsuffixes = (\"lion\", \"liard\")  # 10^x or 10^(x+3)\n\nfor idx, (p, s) in enumerate(itertools.product(prefixes, suffixes)):\n    name = p + s\n    THOUSANDS[idx+2] = (name, name + 'y', name + '\u00f3w')\n\n\nclass Num2Word_PL(Num2Word_Base):\n    CURRENCY_FORMS = {\n        'PLN': (\n            ('z\u0142oty', 'z\u0142ote', 'z\u0142otych'), ('grosz', 'grosze', 'groszy')\n        ),\n        'EUR': (\n            ('euro', 'euro', 'euro'), ('cent', 'centy', 'cent\u00f3w')\n        ),\n        'USD': (\n            (\n                'dolar ameryka\u0144ski',\n                'dolary ameryka\u0144skie',\n                'dolar\u00f3w ameryka\u0144skich'\n            ),\n            (\n                'cent',\n                'centy',\n                'cent\u00f3w'\n            )\n        ),\n    }\n\n    def setup(self):\n        self.negword = \"minus\"\n        self.pointword = \"przecinek\"\n\n    def to_cardinal(self, number):\n        n = str(number).replace(',', '.')\n        if '.' in n:\n            left, right = n.split('.')\n            leading_zero_count = len(right) - len(right.lstrip('0'))\n            decimal_part = ((ZERO[0] + ' ') * leading_zero_count +\n                            self._int2word(int(right)))\n            return u'%s %s %s' % (\n                self._int2word(int(left)),\n                self.pointword,\n                decimal_part\n            )\n        else:\n            return self._int2word(int(n))\n\n    def pluralize(self, n, forms):\n        if n == 1:\n            form = 0\n        elif 5 > n % 10 > 1 and (n % 100 < 10 or n % 100 > 20):\n            form = 1\n        else:\n            form = 2\n        return forms[form]\n\n    def last_fragment_to_ordinal(self, last, words, level):\n        n1, n2, n3 = get_digits(last)\n        last_two = n2*10+n1\n        if last_two == 0:\n            words.append(HUNDREDS_ORDINALS[n3][level])\n        elif level == 1 and last == 1:\n            return\n        elif last_two < 20:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][level])\n            words.append(ONES_ORDINALS[last_two][level])\n        elif last_two % 10 == 0:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][level])\n            words.append(TWENTIES_ORDINALS[n2][level])\n        else:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][0])\n            words.append(TWENTIES_ORDINALS[n2][0])\n            words.append(ONES_ORDINALS[n1][0])\n\n    def to_ordinal(self, number):\n        if number % 1 != 0:\n            raise NotImplementedError()\n        words = []\n        fragments = list(splitbyx(str(number), 3))\n        level = 0\n        last = fragments[-1]\n        while last == 0:\n            level = level+1\n            fragments.pop()\n            last = fragments[-1]\n        if len(fragments) > 1:\n            pre_part = self._int2word(number-(last*1000**level))\n            words.append(pre_part)\n        self.last_fragment_to_ordinal(last, words, 0 if level == 0 else 1)\n        output = \" \".join(words)\n        if last == 1 and level > 0 and output != \"\":\n            output = output + \" \"\n        if level > 0:\n            output = output + prefixes_ordinal[level]\n        return output\n\n    def _int2word(self, n):\n        if n == 0:\n            return ZERO[0]\n\n        words = []\n        chunks = list(splitbyx(str(n), 3))\n        i = len(chunks)\n        for x in chunks:\n            i -= 1\n\n            if x == 0:\n                continue\n\n            n1, n2, n3 = get_digits(x)\n\n            if n3 > 0:\n                words.append(HUNDREDS[n3][0])\n\n            if n2 > 1:\n                words.append(TWENTIES[n2][0])\n\n            if n2 == 1:\n                words.append(TENS[n1][0])\n            elif n1 > 0 and not (i > 0 and x == 1):\n                words.append(ONES[n1][0])\n\n            if i > 0:\n                words.append(self.pluralize(x, THOUSANDS[i]))\n\n        return ' '.join(words)\n",
    "num2words/base.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\n\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def __init__(self):\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = \"(-) \"\n        self.pointword = \"(.)\"\n        self.errmsg_nonnum = \"type(%s) not in [long, int, float]\"\n        self.errmsg_floatord = \"Cannot treat float %s as ordinal.\"\n        self.errmsg_negord = \"Cannot treat negative num %s as ordinal.\"\n        self.errmsg_toobig = \"abs(%s) must be less than %s.\"\n\n        self.setup()\n\n        # uses cards\n        if any(hasattr(self, field) for field in\n               ['high_numwords', 'mid_numwords', 'low_numwords']):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_high_numwords(self, *args):\n        raise NotImplementedError\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n\n            out = []\n            if value == 0:\n                div, mod = 1, 0\n            else:\n                div, mod = divmod(value, elem)\n\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:  # The system tallies, eg Roman Numerals\n                    return [(div * self.cards[elem], div*elem)]\n                out.append(self.splitnum(div))\n\n            out.append((self.cards[elem], elem))\n\n            if mod:\n                out.append(self.splitnum(mod))\n\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            # Extra spacing to compensate if there is no minus.\n            return '%s ' % self.negword.strip(), num_str[1:]\n        return '', num_str\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n\n        out = \"\"\n        if value < 0:\n            value = abs(value)\n            out = \"%s \" % self.negword.strip()\n\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n\n        # Simple way of finding decimal places to update the precision\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n\n        post = abs(value - pre) * 10**self.precision\n        if abs(round(post) - post) < 0.01:\n            # We generally floor all values beyond our precision (rather than\n            # rounding), but in cases where we have something like 1.239999999,\n            # which is probably due to python's handling of floats, we actually\n            # want to consider it as 1.24 instead of 1.23\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n\n        return pre, post\n\n    def to_cardinal_float(self, value):\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n\n        pre, post = self.float2tuple(float(value))\n\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n\n        return \" \".join(out)\n\n    def merge(self, curr, next):\n        raise NotImplementedError\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def title(self, value):\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = \" \".join(out)\n        return value\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def to_ordinal_num(self, value):\n        return value\n\n    # Trivial version\n    def inflect(self, value, text):\n        text = text.split(\"/\")\n        if value == 1:\n            return text[0]\n        return \"\".join(text)\n\n    # //CHECK: generalise? Any others like pounds/shillings/pence?\n    def to_splitnum(self, val, hightxt=\"\", lowtxt=\"\", jointxt=\"\",\n                    divisor=100, longval=True, cents=True):\n        out = []\n\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append(\"%02d\" % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n\n        return \" \".join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def pluralize(self, n, forms):\n        \"\"\"\n        Should resolve gettext form:\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n        \"\"\"\n        raise NotImplementedError\n\n    def _money_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_terse(self, number, currency):\n        return \"%02d\" % number\n\n    def to_currency(self, val, currency='EUR', cents=True, separator=',',\n                    adjective=False):\n        \"\"\"\n        Args:\n            val: Numeric value\n            currency (str): Currency code\n            cents (bool): Verbose cents\n            separator (str): Cent separator\n            adjective (bool): Prefix currency name with adjective\n        Returns:\n            str: Formatted string\n\n        \"\"\"\n        left, right, is_negative = parse_currency_parts(val)\n\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n\n        except KeyError:\n            raise NotImplementedError(\n                'Currency code \"%s\" not implemented for \"%s\"' %\n                (currency, self.__class__.__name__))\n\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n\n        minus_str = \"%s \" % self.negword.strip() if is_negative else \"\"\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) \\\n            if cents else self._cents_terse(right, currency)\n\n        return u'%s%s %s%s %s %s' % (\n            minus_str,\n            money_str,\n            self.pluralize(left, cr1),\n            separator,\n            cents_str,\n            self.pluralize(right, cr2)\n        )\n\n    def setup(self):\n        pass\n",
    "num2words/currency.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import division\n\nfrom decimal import ROUND_HALF_UP, Decimal\n\n\ndef parse_currency_parts(value, is_int_with_cents=True):\n    if isinstance(value, int):\n        if is_int_with_cents:\n            # assume cents if value is integer\n            negative = value < 0\n            value = abs(value)\n            integer, cents = divmod(value, 100)\n        else:\n            negative = value < 0\n            integer, cents = abs(value), 0\n\n    else:\n        value = Decimal(value)\n        value = value.quantize(\n            Decimal('.01'),\n            rounding=ROUND_HALF_UP\n        )\n        negative = value < 0\n        value = abs(value)\n        integer, fraction = divmod(value, 1)\n        integer = int(integer)\n        cents = int(fraction * 100)\n\n    return integer, cents, negative\n\n\ndef prefix_currency(prefix, base):\n    return tuple(\"%s %s\" % (prefix, i) for i in base)\n",
    "num2words/utils.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\n\ndef splitbyx(n, x, format_int=True):\n    length = len(n)\n    if length > x:\n        start = length % x\n        if start > 0:\n            result = n[:start]\n            yield int(result) if format_int else result\n        for i in range(start, length, x):\n            result = n[i:i+x]\n            yield int(result) if format_int else result\n    else:\n        yield int(n) if format_int else n\n\n\ndef get_digits(n):\n    a = [int(x) for x in reversed(list(('%03d' % n)[-3:]))]\n    return a\n",
    "num2words/__init__.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom . import (lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE,\n               lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN,\n               lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR,\n               lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR,\n               lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID,\n               lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT,\n               lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR,\n               lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE,\n               lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI)\n\nCONVERTER_CLASSES = {\n    'am': lang_AM.Num2Word_AM(),\n    'ar': lang_AR.Num2Word_AR(),\n    'az': lang_AZ.Num2Word_AZ(),\n    'be': lang_BE.Num2Word_BE(),\n    'bn': lang_BN.Num2Word_BN(),\n    'ca': lang_CA.Num2Word_CA(),\n    'ce': lang_CE.Num2Word_CE(),\n    'cy': lang_CY.Num2Word_CY(),\n    'cz': lang_CZ.Num2Word_CZ(),\n    'en': lang_EN.Num2Word_EN(),\n    'en_IN': lang_EN_IN.Num2Word_EN_IN(),\n    'en_NG': lang_EN_NG.Num2Word_EN_NG(),\n    'fa': lang_FA.Num2Word_FA(),\n    'fr': lang_FR.Num2Word_FR(),\n    'fr_CH': lang_FR_CH.Num2Word_FR_CH(),\n    'fr_BE': lang_FR_BE.Num2Word_FR_BE(),\n    'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(),\n    'de': lang_DE.Num2Word_DE(),\n    'fi': lang_FI.Num2Word_FI(),\n    'eo': lang_EO.Num2Word_EO(),\n    'es': lang_ES.Num2Word_ES(),\n    'es_CO': lang_ES_CO.Num2Word_ES_CO(),\n    'es_CR': lang_ES_CR.Num2Word_ES_CR(),\n    'es_GT': lang_ES_GT.Num2Word_ES_GT(),\n    'es_NI': lang_ES_NI.Num2Word_ES_NI(),\n    'es_VE': lang_ES_VE.Num2Word_ES_VE(),\n    'id': lang_ID.Num2Word_ID(),\n    'ja': lang_JA.Num2Word_JA(),\n    'kn': lang_KN.Num2Word_KN(),\n    'ko': lang_KO.Num2Word_KO(),\n    'kz': lang_KZ.Num2Word_KZ(),\n    'lt': lang_LT.Num2Word_LT(),\n    'lv': lang_LV.Num2Word_LV(),\n    'pl': lang_PL.Num2Word_PL(),\n    'ro': lang_RO.Num2Word_RO(),\n    'ru': lang_RU.Num2Word_RU(),\n    'sk': lang_SK.Num2Word_SK(),\n    'sl': lang_SL.Num2Word_SL(),\n    'sr': lang_SR.Num2Word_SR(),\n    'sv': lang_SV.Num2Word_SV(),\n    'no': lang_NO.Num2Word_NO(),\n    'dk': lang_DK.Num2Word_DK(),\n    'pt': lang_PT.Num2Word_PT(),\n    'pt_BR': lang_PT_BR.Num2Word_PT_BR(),\n    'he': lang_HE.Num2Word_HE(),\n    'it': lang_IT.Num2Word_IT(),\n    'vi': lang_VI.Num2Word_VI(),\n    'tg': lang_TG.Num2Word_TG(),\n    'th': lang_TH.Num2Word_TH(),\n    'tr': lang_TR.Num2Word_TR(),\n    'nl': lang_NL.Num2Word_NL(),\n    'uk': lang_UK.Num2Word_UK(),\n    'te': lang_TE.Num2Word_TE(),\n    'tet': lang_TET.Num2Word_TET(),\n    'hu': lang_HU.Num2Word_HU(),\n    'is': lang_IS.Num2Word_IS(),\n}\n\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']\n\n\ndef num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    # We try the full language first\n    if lang not in CONVERTER_CLASSES:\n        # ... and then try only the first 2 letters\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n\n    # backwards compatible\n    if ordinal:\n        to = 'ordinal'\n\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)\n"
  },
  "GT_src_dict": {
    "num2words/lang_PL.py": {
      "Num2Word_PL.to_cardinal": {
        "code": "    def to_cardinal(self, number):\n        \"\"\"Converts a numerical value to its cardinal word representation in Polish.\n\nParameters:\n    number (int, float, str): A number that will be converted to its word form. \n    If the number contains a decimal point, the decimal portion will be handled as a fraction of a whole.\n\nReturns:\n    str: The cardinal word representation of the number, including the word for the decimal point, if applicable. \n    For decimal numbers, it will return the whole number portion and the fractional part separated by the defined decimal word.\n\nDependencies:\n    Utilizes the constant ZERO which is defined outside the function as a tuple containing the Polish word for zero. \n    It also calls the private method _int2word to handle the conversion of integer parts into words.\n\nSide Effects:\n    If the number is a decimal, the function also counts leading zeros in the decimal fraction and converts it to words accordingly.\"\"\"\n        n = str(number).replace(',', '.')\n        if '.' in n:\n            left, right = n.split('.')\n            leading_zero_count = len(right) - len(right.lstrip('0'))\n            decimal_part = (ZERO[0] + ' ') * leading_zero_count + self._int2word(int(right))\n            return u'%s %s %s' % (self._int2word(int(left)), self.pointword, decimal_part)\n        else:\n            return self._int2word(int(n))",
        "docstring": "Converts a numerical value to its cardinal word representation in Polish.\n\nParameters:\n    number (int, float, str): A number that will be converted to its word form. \n    If the number contains a decimal point, the decimal portion will be handled as a fraction of a whole.\n\nReturns:\n    str: The cardinal word representation of the number, including the word for the decimal point, if applicable. \n    For decimal numbers, it will return the whole number portion and the fractional part separated by the defined decimal word.\n\nDependencies:\n    Utilizes the constant ZERO which is defined outside the function as a tuple containing the Polish word for zero. \n    It also calls the private method _int2word to handle the conversion of integer parts into words.\n\nSide Effects:\n    If the number is a decimal, the function also counts leading zeros in the decimal fraction and converts it to words accordingly.",
        "signature": "def to_cardinal(self, number):",
        "type": "Method",
        "class_signature": "class Num2Word_PL(Num2Word_Base):"
      },
      "Num2Word_PL.pluralize": {
        "code": "    def pluralize(self, n, forms):\n        \"\"\"Defines the pluralization logic for Polish number words in the Num2Word_PL class. \n\nParameters:\n- n (int): The number to pluralize, affecting the choice of word form.\n- forms (tuple): A tuple containing three forms of a noun in Polish for singular or plural usage (e.g., ('z\u0142oty', 'z\u0142ote', 'z\u0142otych') for currency).\n\nReturns:\n- str: The appropriate word form based on the value of n. If n is 1, the singular form is returned. For numbers between 2 and 4 (inclusive) that are not in the range of 12 to 14, the second form is used; otherwise, the plural form is returned.\n\nThis method relies on the Polish grammatical rules for numeral agreements, which are influenced by constants and dictionary entries defined in the class, such as CURRENCY_FORMS.\"\"\"\n        if n == 1:\n            form = 0\n        elif 5 > n % 10 > 1 and (n % 100 < 10 or n % 100 > 20):\n            form = 1\n        else:\n            form = 2\n        return forms[form]",
        "docstring": "Defines the pluralization logic for Polish number words in the Num2Word_PL class. \n\nParameters:\n- n (int): The number to pluralize, affecting the choice of word form.\n- forms (tuple): A tuple containing three forms of a noun in Polish for singular or plural usage (e.g., ('z\u0142oty', 'z\u0142ote', 'z\u0142otych') for currency).\n\nReturns:\n- str: The appropriate word form based on the value of n. If n is 1, the singular form is returned. For numbers between 2 and 4 (inclusive) that are not in the range of 12 to 14, the second form is used; otherwise, the plural form is returned.\n\nThis method relies on the Polish grammatical rules for numeral agreements, which are influenced by constants and dictionary entries defined in the class, such as CURRENCY_FORMS.",
        "signature": "def pluralize(self, n, forms):",
        "type": "Method",
        "class_signature": "class Num2Word_PL(Num2Word_Base):"
      },
      "Num2Word_PL.last_fragment_to_ordinal": {
        "code": "    def last_fragment_to_ordinal(self, last, words, level):\n        \"\"\"Handles the conversion of the last three digits of a number into its corresponding ordinal representation in Polish. It updates the provided list `words` with the appropriate ordinal words based on the input `last` value and the `level` of magnitude, which corresponds to thousands or more.\n\nParameters:\n- last (int): The last three digits of the number to be converted.\n- words (list): A list where the resulting ordinal words are appended.\n- level (int): The magnitude level of the number (0 for zero to hundreds, 1 for thousands).\n\nThe function utilizes several constants from the module:\n- `HUNDREDS_ORDINALS`: A dictionary for mapping hundreds (1-9) to their ordinal forms in Polish.\n- `ONES_ORDINALS`: A dictionary for mapping the last two digits (1-19) to their ordinal forms in Polish.\n- `TENS`: A dictionary for mapping ten's place values (10-19) for special ordinal cases.\n- `TWENTIES_ORDINALS`: A dictionary used for converting the twenties (20-90) to their ordinal forms.\n\nThis method is designed to facilitate the ordinal number conversion process within the overall number-to-word translation functionality of the `Num2Word_PL` class.\"\"\"\n        n1, n2, n3 = get_digits(last)\n        last_two = n2 * 10 + n1\n        if last_two == 0:\n            words.append(HUNDREDS_ORDINALS[n3][level])\n        elif level == 1 and last == 1:\n            return\n        elif last_two < 20:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][level])\n            words.append(ONES_ORDINALS[last_two][level])\n        elif last_two % 10 == 0:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][level])\n            words.append(TWENTIES_ORDINALS[n2][level])\n        else:\n            if n3 > 0:\n                words.append(HUNDREDS[n3][0])\n            words.append(TWENTIES_ORDINALS[n2][0])\n            words.append(ONES_ORDINALS[n1][0])",
        "docstring": "Handles the conversion of the last three digits of a number into its corresponding ordinal representation in Polish. It updates the provided list `words` with the appropriate ordinal words based on the input `last` value and the `level` of magnitude, which corresponds to thousands or more.\n\nParameters:\n- last (int): The last three digits of the number to be converted.\n- words (list): A list where the resulting ordinal words are appended.\n- level (int): The magnitude level of the number (0 for zero to hundreds, 1 for thousands).\n\nThe function utilizes several constants from the module:\n- `HUNDREDS_ORDINALS`: A dictionary for mapping hundreds (1-9) to their ordinal forms in Polish.\n- `ONES_ORDINALS`: A dictionary for mapping the last two digits (1-19) to their ordinal forms in Polish.\n- `TENS`: A dictionary for mapping ten's place values (10-19) for special ordinal cases.\n- `TWENTIES_ORDINALS`: A dictionary used for converting the twenties (20-90) to their ordinal forms.\n\nThis method is designed to facilitate the ordinal number conversion process within the overall number-to-word translation functionality of the `Num2Word_PL` class.",
        "signature": "def last_fragment_to_ordinal(self, last, words, level):",
        "type": "Method",
        "class_signature": "class Num2Word_PL(Num2Word_Base):"
      },
      "Num2Word_PL.to_ordinal": {
        "code": "    def to_ordinal(self, number):\n        \"\"\"Converts a given integer number to its ordinal representation in Polish language.\n\nParameters:\n- number (int): An integer value representing the number to convert to ordinal form. The number must be a whole number (no decimals); otherwise, a NotImplementedError is raised.\n\nReturns:\n- str: The ordinal form of the given number as a string. The output includes numbers expressed in Polish, considering grammar rules for different number ranges and appropriate suffixes.\n\nDependencies:\n- Utilizes the `get_digits` function to extract hundreds, tens, and units from the number.\n- Relies on constants such as `HUNDREDS_ORDINALS` and `prefixes_ordinal` to map numeric values to their corresponding ordinal forms and appropriate prefixes for larger scales (thousands, millions, etc.).\n- Uses the `_int2word` method to convert the number parts before appending the ordinal suffix.\n\nThe method handles values by breaking down the number into chunks of three digits and applying specific rules based on Polish grammar for ordinal numbers, managing cases for larger numbers and ensuring correct formatting.\"\"\"\n        if number % 1 != 0:\n            raise NotImplementedError()\n        words = []\n        fragments = list(splitbyx(str(number), 3))\n        level = 0\n        last = fragments[-1]\n        while last == 0:\n            level = level + 1\n            fragments.pop()\n            last = fragments[-1]\n        if len(fragments) > 1:\n            pre_part = self._int2word(number - last * 1000 ** level)\n            words.append(pre_part)\n        self.last_fragment_to_ordinal(last, words, 0 if level == 0 else 1)\n        output = ' '.join(words)\n        if last == 1 and level > 0 and (output != ''):\n            output = output + ' '\n        if level > 0:\n            output = output + prefixes_ordinal[level]\n        return output",
        "docstring": "Converts a given integer number to its ordinal representation in Polish language.\n\nParameters:\n- number (int): An integer value representing the number to convert to ordinal form. The number must be a whole number (no decimals); otherwise, a NotImplementedError is raised.\n\nReturns:\n- str: The ordinal form of the given number as a string. The output includes numbers expressed in Polish, considering grammar rules for different number ranges and appropriate suffixes.\n\nDependencies:\n- Utilizes the `get_digits` function to extract hundreds, tens, and units from the number.\n- Relies on constants such as `HUNDREDS_ORDINALS` and `prefixes_ordinal` to map numeric values to their corresponding ordinal forms and appropriate prefixes for larger scales (thousands, millions, etc.).\n- Uses the `_int2word` method to convert the number parts before appending the ordinal suffix.\n\nThe method handles values by breaking down the number into chunks of three digits and applying specific rules based on Polish grammar for ordinal numbers, managing cases for larger numbers and ensuring correct formatting.",
        "signature": "def to_ordinal(self, number):",
        "type": "Method",
        "class_signature": "class Num2Word_PL(Num2Word_Base):"
      },
      "Num2Word_PL._int2word": {
        "code": "    def _int2word(self, n):\n        \"\"\"Converts an integer into its Polish words representation.\n\nParameters:\n    n (int): The integer to be converted. It must be a non-negative integer.\n\nReturns:\n    str: The Polish words representation of the integer.\n\nDependencies:\n    - Utilizes constants defined at the module level, such as:\n        - `ZERO`: Represents the word for zero in Polish.\n        - `HUNDREDS`, `TWENTIES`, `TENS`, and `ONES`: Dictionaries that map digit values to their corresponding Polish word representations.\n    - Relies on the `get_digits` function to extract individual digits from the number and the `splitbyx` function to separate the number into chunks of three digits for processing.\n    - Implements the `pluralize` method to handle the appropriate plural form for thousands.\n\nThe method constructs the number's word representation by evaluating each chunk of digits from the least significant to the most significant, while applying the appropriate units (hundreds, tens, ones) and handling pluralization for the thousands as necessary.\"\"\"\n        if n == 0:\n            return ZERO[0]\n        words = []\n        chunks = list(splitbyx(str(n), 3))\n        i = len(chunks)\n        for x in chunks:\n            i -= 1\n            if x == 0:\n                continue\n            n1, n2, n3 = get_digits(x)\n            if n3 > 0:\n                words.append(HUNDREDS[n3][0])\n            if n2 > 1:\n                words.append(TWENTIES[n2][0])\n            if n2 == 1:\n                words.append(TENS[n1][0])\n            elif n1 > 0 and (not (i > 0 and x == 1)):\n                words.append(ONES[n1][0])\n            if i > 0:\n                words.append(self.pluralize(x, THOUSANDS[i]))\n        return ' '.join(words)",
        "docstring": "Converts an integer into its Polish words representation.\n\nParameters:\n    n (int): The integer to be converted. It must be a non-negative integer.\n\nReturns:\n    str: The Polish words representation of the integer.\n\nDependencies:\n    - Utilizes constants defined at the module level, such as:\n        - `ZERO`: Represents the word for zero in Polish.\n        - `HUNDREDS`, `TWENTIES`, `TENS`, and `ONES`: Dictionaries that map digit values to their corresponding Polish word representations.\n    - Relies on the `get_digits` function to extract individual digits from the number and the `splitbyx` function to separate the number into chunks of three digits for processing.\n    - Implements the `pluralize` method to handle the appropriate plural form for thousands.\n\nThe method constructs the number's word representation by evaluating each chunk of digits from the least significant to the most significant, while applying the appropriate units (hundreds, tens, ones) and handling pluralization for the thousands as necessary.",
        "signature": "def _int2word(self, n):",
        "type": "Method",
        "class_signature": "class Num2Word_PL(Num2Word_Base):"
      }
    },
    "num2words/base.py": {
      "Num2Word_Base._money_verbose": {
        "code": "    def _money_verbose(self, number, currency):\n        \"\"\"Convert a numeric value representing money to its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of money to be converted to words.\n    currency (str): The currency code (e.g., 'EUR') which is not used in this method directly.\n\nReturns:\n    str: The money amount in cardinal words as a string.\n\nThis method relies on the `to_cardinal()` method for converting the numeric value to its corresponding word form. It does not implement any specific currency formatting and treats the input value as an absolute number.\"\"\"\n        return self.to_cardinal(number)",
        "docstring": "Convert a numeric value representing money to its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of money to be converted to words.\n    currency (str): The currency code (e.g., 'EUR') which is not used in this method directly.\n\nReturns:\n    str: The money amount in cardinal words as a string.\n\nThis method relies on the `to_cardinal()` method for converting the numeric value to its corresponding word form. It does not implement any specific currency formatting and treats the input value as an absolute number.",
        "signature": "def _money_verbose(self, number, currency):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base._cents_verbose": {
        "code": "    def _cents_verbose(self, number, currency):\n        \"\"\"Converts a numeric value representing cents into its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of cents to be converted to words.\n    currency (str): The currency code, though it is not utilized in this method.\n\nReturns:\n    str: A string representing the value of cents in words.\n\nThis method relies on the `to_cardinal` method to perform the conversion. It is part of the `Num2Word_Base` class, which provides a base for converting numbers to their word forms, including support for different numeric formats and currencies.\"\"\"\n        return self.to_cardinal(number)",
        "docstring": "Converts a numeric value representing cents into its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of cents to be converted to words.\n    currency (str): The currency code, though it is not utilized in this method.\n\nReturns:\n    str: A string representing the value of cents in words.\n\nThis method relies on the `to_cardinal` method to perform the conversion. It is part of the `Num2Word_Base` class, which provides a base for converting numbers to their word forms, including support for different numeric formats and currencies.",
        "signature": "def _cents_verbose(self, number, currency):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base._cents_terse": {
        "code": "    def _cents_terse(self, number, currency):\n        \"\"\"Returns a formatted string representing the number of cents as a two-digit decimal string, suitable for currency representation.\n\nParameters:\n    number (int): The number of cents to format.\n    currency (str): The currency code (not used in this method, but present for consistency with the class interface).\n\nReturns:\n    str: A two-character string formatted as a decimal, padded with zeros if necessary (e.g., '05' for 5 cents).\n\nThis method is part of the Num2Word_Base class, which provides functionalities for converting numbers to words, including handling currency. The `currency` parameter is maintained for method signature consistency with other currency-related methods in the class.\"\"\"\n        return '%02d' % number",
        "docstring": "Returns a formatted string representing the number of cents as a two-digit decimal string, suitable for currency representation.\n\nParameters:\n    number (int): The number of cents to format.\n    currency (str): The currency code (not used in this method, but present for consistency with the class interface).\n\nReturns:\n    str: A two-character string formatted as a decimal, padded with zeros if necessary (e.g., '05' for 5 cents).\n\nThis method is part of the Num2Word_Base class, which provides functionalities for converting numbers to words, including handling currency. The `currency` parameter is maintained for method signature consistency with other currency-related methods in the class.",
        "signature": "def _cents_terse(self, number, currency):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.to_currency": {
        "code": "    def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n        \"\"\"Converts a numeric value to a formatted currency string in words. \n\nArgs:\n    val (numeric): The numeric value to be converted to currency format.\n    currency (str, optional): The currency code (default is 'EUR'). Determines the currency format to use.\n    cents (bool, optional): If True, includes verbose representation of the cents (default is True).\n    separator (str, optional): The separator used between the whole number and cents (default is ',').\n    adjective (bool, optional): If True, prefixes the currency name with an adjective (default is False).\n\nReturns:\n    str: A formatted currency string combining the numeric value in words, its currency name and cents.\n\nThis method utilizes the `CURRENCY_FORMS` and `CURRENCY_ADJECTIVES` dictionaries defined in the class to map currency codes to their respective formatted forms and optional adjectives. It calls `parse_currency_parts` to separate the value into its integer and fractional parts, which it uses to create the final output string, integrating elements like the negative sign, monetary values, and their plural forms through `pluralize`. It raises a NotImplementedError if the provided currency code is not found in `CURRENCY_FORMS`.\"\"\"\n        '\\n        Args:\\n            val: Numeric value\\n            currency (str): Currency code\\n            cents (bool): Verbose cents\\n            separator (str): Cent separator\\n            adjective (bool): Prefix currency name with adjective\\n        Returns:\\n            str: Formatted string\\n\\n        '\n        left, right, is_negative = parse_currency_parts(val)\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n        except KeyError:\n            raise NotImplementedError('Currency code \"%s\" not implemented for \"%s\"' % (currency, self.__class__.__name__))\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n        minus_str = '%s ' % self.negword.strip() if is_negative else ''\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) if cents else self._cents_terse(right, currency)\n        return u'%s%s %s%s %s %s' % (minus_str, money_str, self.pluralize(left, cr1), separator, cents_str, self.pluralize(right, cr2))",
        "docstring": "Converts a numeric value to a formatted currency string in words. \n\nArgs:\n    val (numeric): The numeric value to be converted to currency format.\n    currency (str, optional): The currency code (default is 'EUR'). Determines the currency format to use.\n    cents (bool, optional): If True, includes verbose representation of the cents (default is True).\n    separator (str, optional): The separator used between the whole number and cents (default is ',').\n    adjective (bool, optional): If True, prefixes the currency name with an adjective (default is False).\n\nReturns:\n    str: A formatted currency string combining the numeric value in words, its currency name and cents.\n\nThis method utilizes the `CURRENCY_FORMS` and `CURRENCY_ADJECTIVES` dictionaries defined in the class to map currency codes to their respective formatted forms and optional adjectives. It calls `parse_currency_parts` to separate the value into its integer and fractional parts, which it uses to create the final output string, integrating elements like the negative sign, monetary values, and their plural forms through `pluralize`. It raises a NotImplementedError if the provided currency code is not found in `CURRENCY_FORMS`.",
        "signature": "def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      }
    },
    "num2words/currency.py": {
      "parse_currency_parts": {
        "code": "def parse_currency_parts(value, is_int_with_cents=True):\n    \"\"\"Parse a currency value into its integer and cents components.\n\nParameters:\n- value (int or str/Decimal): The currency value to be parsed. This can be an integer representing the total in cents or a string/Decimal value for currency representation.\n- is_int_with_cents (bool): Indicates whether the integer value represents cents (True) or not (False). Default is True.\n\nReturns:\n- tuple: A tuple containing three elements:\n    - integer (int): The integer part of the currency value.\n    - cents (int): The cents part of the currency value (0 if the input is an integer without cents).\n    - negative (bool): A flag indicating if the value is negative.\n\nDependencies:\n- The function utilizes the Decimal class from the decimal module for precise decimal arithmetic, specifically using the method `quantize` for rounding to two decimal places with the `ROUND_HALF_UP` rounding mode. This ensures that any fractional part is handled accurately.\"\"\"\n    if isinstance(value, int):\n        if is_int_with_cents:\n            negative = value < 0\n            value = abs(value)\n            integer, cents = divmod(value, 100)\n        else:\n            negative = value < 0\n            integer, cents = (abs(value), 0)\n    else:\n        value = Decimal(value)\n        value = value.quantize(Decimal('.01'), rounding=ROUND_HALF_UP)\n        negative = value < 0\n        value = abs(value)\n        integer, fraction = divmod(value, 1)\n        integer = int(integer)\n        cents = int(fraction * 100)\n    return (integer, cents, negative)",
        "docstring": "Parse a currency value into its integer and cents components.\n\nParameters:\n- value (int or str/Decimal): The currency value to be parsed. This can be an integer representing the total in cents or a string/Decimal value for currency representation.\n- is_int_with_cents (bool): Indicates whether the integer value represents cents (True) or not (False). Default is True.\n\nReturns:\n- tuple: A tuple containing three elements:\n    - integer (int): The integer part of the currency value.\n    - cents (int): The cents part of the currency value (0 if the input is an integer without cents).\n    - negative (bool): A flag indicating if the value is negative.\n\nDependencies:\n- The function utilizes the Decimal class from the decimal module for precise decimal arithmetic, specifically using the method `quantize` for rounding to two decimal places with the `ROUND_HALF_UP` rounding mode. This ensures that any fractional part is handled accurately.",
        "signature": "def parse_currency_parts(value, is_int_with_cents=True):",
        "type": "Function",
        "class_signature": null
      }
    },
    "num2words/utils.py": {
      "splitbyx": {
        "code": "def splitbyx(n, x, format_int=True):\n    \"\"\"Splits a numeric string into segments of specified length and yields the segments.\n\nParameters:\n- n (str): The numeric string to be split.\n- x (int): The length of each segment.\n- format_int (bool, optional): If True, yields integers; if False, yields strings. Default is True.\n\nYields:\n- str or int: Segmented parts of the numeric string.\n\nIf the length of the string is greater than x, the function handles the potential remainder at the start separately, yielding that first segment before processing the rest in chunks of size x. If the length is less than or equal to x, the entire input is yielded as either an int or str based on format_int.\"\"\"\n    length = len(n)\n    if length > x:\n        start = length % x\n        if start > 0:\n            result = n[:start]\n            yield (int(result) if format_int else result)\n        for i in range(start, length, x):\n            result = n[i:i + x]\n            yield (int(result) if format_int else result)\n    else:\n        yield (int(n) if format_int else n)",
        "docstring": "Splits a numeric string into segments of specified length and yields the segments.\n\nParameters:\n- n (str): The numeric string to be split.\n- x (int): The length of each segment.\n- format_int (bool, optional): If True, yields integers; if False, yields strings. Default is True.\n\nYields:\n- str or int: Segmented parts of the numeric string.\n\nIf the length of the string is greater than x, the function handles the potential remainder at the start separately, yielding that first segment before processing the rest in chunks of size x. If the length is less than or equal to x, the entire input is yielded as either an int or str based on format_int.",
        "signature": "def splitbyx(n, x, format_int=True):",
        "type": "Function",
        "class_signature": null
      },
      "get_digits": {
        "code": "def get_digits(n):\n    \"\"\"Extracts the last three digits of a given integer, returning them in a reversed list format.\n\nParameters:\nn (int): The input integer from which the last three digits are extracted.\n\nReturns:\nlist: A list of integers representing the last three digits of the input integer 'n' in reverse order.\n\nThe function formats 'n' as a zero-padded three-digit string, ensuring that numbers less than 100 are represented with leading zeros. It utilizes Python's string formatting and list comprehensions to generate the output.\"\"\"\n    a = [int(x) for x in reversed(list(('%03d' % n)[-3:]))]\n    return a",
        "docstring": "Extracts the last three digits of a given integer, returning them in a reversed list format.\n\nParameters:\nn (int): The input integer from which the last three digits are extracted.\n\nReturns:\nlist: A list of integers representing the last three digits of the input integer 'n' in reverse order.\n\nThe function formats 'n' as a zero-padded three-digit string, ensuring that numbers less than 100 are represented with leading zeros. It utilizes Python's string formatting and list comprehensions to generate the output.",
        "signature": "def get_digits(n):",
        "type": "Function",
        "class_signature": null
      }
    },
    "num2words/__init__.py": {
      "num2words": {
        "code": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    \"\"\"Converts a given number into its word representation in multiple languages.\n\nParameters:\n- number (int, float, str): The number to convert to words. If a string is provided, it will be converted to a number using the language-specific converter.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., 1 becomes \"first\"). Defaults to False.\n- lang (str): The language code (e.g., 'en' for English, 'fr' for French). Can also be a shortened two-letter version. Defaults to 'en'.\n- to (str): The type of conversion to perform, which must be one of the types listed in CONVERTES_TYPES (e.g., 'cardinal', 'ordinal'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the specified language is not supported or if the requested conversion type is not recognized.\n\nInteractions:\nRelies on the CONVERTER_CLASSES dictionary, which maps language codes to their corresponding Num2Word converter instances. Also uses the CONVERTES_TYPES list to validate the conversion type.\"\"\"\n    if lang not in CONVERTER_CLASSES:\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n    if ordinal:\n        to = 'ordinal'\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)",
        "docstring": "Converts a given number into its word representation in multiple languages.\n\nParameters:\n- number (int, float, str): The number to convert to words. If a string is provided, it will be converted to a number using the language-specific converter.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., 1 becomes \"first\"). Defaults to False.\n- lang (str): The language code (e.g., 'en' for English, 'fr' for French). Can also be a shortened two-letter version. Defaults to 'en'.\n- to (str): The type of conversion to perform, which must be one of the types listed in CONVERTES_TYPES (e.g., 'cardinal', 'ordinal'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the specified language is not supported or if the requested conversion type is not recognized.\n\nInteractions:\nRelies on the CONVERTER_CLASSES dictionary, which maps language codes to their corresponding Num2Word converter instances. Also uses the CONVERTES_TYPES list to validate the conversion type.",
        "signature": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: num2words-test_pl\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 num2words\n    \u251c\u2500\u2500 base.py\n    \u2502   \u251c\u2500\u2500 Num2Word_Base._cents_terse\n    \u2502   \u251c\u2500\u2500 Num2Word_Base._cents_verbose\n    \u2502   \u251c\u2500\u2500 Num2Word_Base._money_verbose\n    \u2502   \u2514\u2500\u2500 Num2Word_Base.to_currency\n    \u251c\u2500\u2500 currency.py\n    \u2502   \u2514\u2500\u2500 parse_currency_parts\n    \u251c\u2500\u2500 lang_PL.py\n    \u2502   \u251c\u2500\u2500 Num2Word_PL._int2word\n    \u2502   \u251c\u2500\u2500 Num2Word_PL.last_fragment_to_ordinal\n    \u2502   \u251c\u2500\u2500 Num2Word_PL.pluralize\n    \u2502   \u251c\u2500\u2500 Num2Word_PL.to_cardinal\n    \u2502   \u2514\u2500\u2500 Num2Word_PL.to_ordinal\n    \u2514\u2500\u2500 utils.py\n        \u251c\u2500\u2500 get_digits\n        \u2514\u2500\u2500 splitbyx\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to convert numerical values into their Polish language word equivalents, offering functionality for cardinal, ordinal, and currency representations. It supports a wide range of numerical inputs, including integers, floating-point numbers, and extremely large values, providing accurate and grammatically correct Polish outputs. Additionally, the module includes features to handle specific linguistic contexts, such as expressing decimal places, ordinals, and monetary amounts with appropriate currency formats (e.g., euros and z\u0142oty). This functionality streamlines the process of integrating Polish numerical text conversion into applications, reducing development complexity and ensuring consistency in language output for tasks such as report generation, localization, and financial communication.\n\n## FILE 1: num2words/lang_PL.py\n\n- CLASS METHOD: Num2Word_PL._int2word\n  - CLASS SIGNATURE: class Num2Word_PL(Num2Word_Base):\n  - SIGNATURE: def _int2word(self, n):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts an integer into its Polish words representation.\n\nParameters:\n    n (int): The integer to be converted. It must be a non-negative integer.\n\nReturns:\n    str: The Polish words representation of the integer.\n\nDependencies:\n    - Utilizes constants defined at the module level, such as:\n        - `ZERO`: Represents the word for zero in Polish.\n        - `HUNDREDS`, `TWENTIES`, `TENS`, and `ONES`: Dictionaries that map digit values to their corresponding Polish word representations.\n    - Relies on the `get_digits` function to extract individual digits from the number and the `splitbyx` function to separate the number into chunks of three digits for processing.\n    - Implements the `pluralize` method to handle the appropriate plural form for thousands.\n\nThe method constructs the number's word representation by evaluating each chunk of digits from the least significant to the most significant, while applying the appropriate units (hundreds, tens, ones) and handling pluralization for the thousands as necessary.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_PL.to_ordinal\n  - CLASS SIGNATURE: class Num2Word_PL(Num2Word_Base):\n  - SIGNATURE: def to_ordinal(self, number):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given integer number to its ordinal representation in Polish language.\n\nParameters:\n- number (int): An integer value representing the number to convert to ordinal form. The number must be a whole number (no decimals); otherwise, a NotImplementedError is raised.\n\nReturns:\n- str: The ordinal form of the given number as a string. The output includes numbers expressed in Polish, considering grammar rules for different number ranges and appropriate suffixes.\n\nDependencies:\n- Utilizes the `get_digits` function to extract hundreds, tens, and units from the number.\n- Relies on constants such as `HUNDREDS_ORDINALS` and `prefixes_ordinal` to map numeric values to their corresponding ordinal forms and appropriate prefixes for larger scales (thousands, millions, etc.).\n- Uses the `_int2word` method to convert the number parts before appending the ordinal suffix.\n\nThe method handles values by breaking down the number into chunks of three digits and applying specific rules based on Polish grammar for ordinal numbers, managing cases for larger numbers and ensuring correct formatting.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_PL.last_fragment_to_ordinal\n  - CLASS SIGNATURE: class Num2Word_PL(Num2Word_Base):\n  - SIGNATURE: def last_fragment_to_ordinal(self, last, words, level):\n  - DOCSTRING: \n```python\n\"\"\"\nHandles the conversion of the last three digits of a number into its corresponding ordinal representation in Polish. It updates the provided list `words` with the appropriate ordinal words based on the input `last` value and the `level` of magnitude, which corresponds to thousands or more.\n\nParameters:\n- last (int): The last three digits of the number to be converted.\n- words (list): A list where the resulting ordinal words are appended.\n- level (int): The magnitude level of the number (0 for zero to hundreds, 1 for thousands).\n\nThe function utilizes several constants from the module:\n- `HUNDREDS_ORDINALS`: A dictionary for mapping hundreds (1-9) to their ordinal forms in Polish.\n- `ONES_ORDINALS`: A dictionary for mapping the last two digits (1-19) to their ordinal forms in Polish.\n- `TENS`: A dictionary for mapping ten's place values (10-19) for special ordinal cases.\n- `TWENTIES_ORDINALS`: A dictionary used for converting the twenties (20-90) to their ordinal forms.\n\nThis method is designed to facilitate the ordinal number conversion process within the overall number-to-word translation functionality of the `Num2Word_PL` class.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_PL.pluralize\n  - CLASS SIGNATURE: class Num2Word_PL(Num2Word_Base):\n  - SIGNATURE: def pluralize(self, n, forms):\n  - DOCSTRING: \n```python\n\"\"\"\nDefines the pluralization logic for Polish number words in the Num2Word_PL class. \n\nParameters:\n- n (int): The number to pluralize, affecting the choice of word form.\n- forms (tuple): A tuple containing three forms of a noun in Polish for singular or plural usage (e.g., ('z\u0142oty', 'z\u0142ote', 'z\u0142otych') for currency).\n\nReturns:\n- str: The appropriate word form based on the value of n. If n is 1, the singular form is returned. For numbers between 2 and 4 (inclusive) that are not in the range of 12 to 14, the second form is used; otherwise, the plural form is returned.\n\nThis method relies on the Polish grammatical rules for numeral agreements, which are influenced by constants and dictionary entries defined in the class, such as CURRENCY_FORMS.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_PL.to_cardinal\n  - CLASS SIGNATURE: class Num2Word_PL(Num2Word_Base):\n  - SIGNATURE: def to_cardinal(self, number):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numerical value to its cardinal word representation in Polish.\n\nParameters:\n    number (int, float, str): A number that will be converted to its word form. \n    If the number contains a decimal point, the decimal portion will be handled as a fraction of a whole.\n\nReturns:\n    str: The cardinal word representation of the number, including the word for the decimal point, if applicable. \n    For decimal numbers, it will return the whole number portion and the fractional part separated by the defined decimal word.\n\nDependencies:\n    Utilizes the constant ZERO which is defined outside the function as a tuple containing the Polish word for zero. \n    It also calls the private method _int2word to handle the conversion of integer parts into words.\n\nSide Effects:\n    If the number is a decimal, the function also counts leading zeros in the decimal fraction and converts it to words accordingly.\n\"\"\"\n```\n\n## FILE 2: num2words/base.py\n\n- CLASS METHOD: Num2Word_Base._cents_verbose\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def _cents_verbose(self, number, currency):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numeric value representing cents into its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of cents to be converted to words.\n    currency (str): The currency code, though it is not utilized in this method.\n\nReturns:\n    str: A string representing the value of cents in words.\n\nThis method relies on the `to_cardinal` method to perform the conversion. It is part of the `Num2Word_Base` class, which provides a base for converting numbers to their word forms, including support for different numeric formats and currencies.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base._cents_terse\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def _cents_terse(self, number, currency):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a formatted string representing the number of cents as a two-digit decimal string, suitable for currency representation.\n\nParameters:\n    number (int): The number of cents to format.\n    currency (str): The currency code (not used in this method, but present for consistency with the class interface).\n\nReturns:\n    str: A two-character string formatted as a decimal, padded with zeros if necessary (e.g., '05' for 5 cents).\n\nThis method is part of the Num2Word_Base class, which provides functionalities for converting numbers to words, including handling currency. The `currency` parameter is maintained for method signature consistency with other currency-related methods in the class.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.to_currency\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numeric value to a formatted currency string in words. \n\nArgs:\n    val (numeric): The numeric value to be converted to currency format.\n    currency (str, optional): The currency code (default is 'EUR'). Determines the currency format to use.\n    cents (bool, optional): If True, includes verbose representation of the cents (default is True).\n    separator (str, optional): The separator used between the whole number and cents (default is ',').\n    adjective (bool, optional): If True, prefixes the currency name with an adjective (default is False).\n\nReturns:\n    str: A formatted currency string combining the numeric value in words, its currency name and cents.\n\nThis method utilizes the `CURRENCY_FORMS` and `CURRENCY_ADJECTIVES` dictionaries defined in the class to map currency codes to their respective formatted forms and optional adjectives. It calls `parse_currency_parts` to separate the value into its integer and fractional parts, which it uses to create the final output string, integrating elements like the negative sign, monetary values, and their plural forms through `pluralize`. It raises a NotImplementedError if the provided currency code is not found in `CURRENCY_FORMS`.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base._money_verbose\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def _money_verbose(self, number, currency):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a numeric value representing money to its cardinal word representation.\n\nParameters:\n    number (int or Decimal): The numeric value of money to be converted to words.\n    currency (str): The currency code (e.g., 'EUR') which is not used in this method directly.\n\nReturns:\n    str: The money amount in cardinal words as a string.\n\nThis method relies on the `to_cardinal()` method for converting the numeric value to its corresponding word form. It does not implement any specific currency formatting and treats the input value as an absolute number.\n\"\"\"\n```\n\n## FILE 3: num2words/currency.py\n\n- FUNCTION NAME: parse_currency_parts\n  - SIGNATURE: def parse_currency_parts(value, is_int_with_cents=True):\n  - DOCSTRING: \n```python\n\"\"\"\nParse a currency value into its integer and cents components.\n\nParameters:\n- value (int or str/Decimal): The currency value to be parsed. This can be an integer representing the total in cents or a string/Decimal value for currency representation.\n- is_int_with_cents (bool): Indicates whether the integer value represents cents (True) or not (False). Default is True.\n\nReturns:\n- tuple: A tuple containing three elements:\n    - integer (int): The integer part of the currency value.\n    - cents (int): The cents part of the currency value (0 if the input is an integer without cents).\n    - negative (bool): A flag indicating if the value is negative.\n\nDependencies:\n- The function utilizes the Decimal class from the decimal module for precise decimal arithmetic, specifically using the method `quantize` for rounding to two decimal places with the `ROUND_HALF_UP` rounding mode. This ensures that any fractional part is handled accurately.\n\"\"\"\n```\n\n## FILE 4: num2words/utils.py\n\n- FUNCTION NAME: get_digits\n  - SIGNATURE: def get_digits(n):\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the last three digits of a given integer, returning them in a reversed list format.\n\nParameters:\nn (int): The input integer from which the last three digits are extracted.\n\nReturns:\nlist: A list of integers representing the last three digits of the input integer 'n' in reverse order.\n\nThe function formats 'n' as a zero-padded three-digit string, ensuring that numbers less than 100 are represented with leading zeros. It utilizes Python's string formatting and list comprehensions to generate the output.\n\"\"\"\n```\n\n- FUNCTION NAME: splitbyx\n  - SIGNATURE: def splitbyx(n, x, format_int=True):\n  - DOCSTRING: \n```python\n\"\"\"\nSplits a numeric string into segments of specified length and yields the segments.\n\nParameters:\n- n (str): The numeric string to be split.\n- x (int): The length of each segment.\n- format_int (bool, optional): If True, yields integers; if False, yields strings. Default is True.\n\nYields:\n- str or int: Segmented parts of the numeric string.\n\nIf the length of the string is greater than x, the function handles the potential remainder at the start separately, yielding that first segment before processing the rest in chunks of size x. If the length is less than or equal to x, the entire input is yielded as either an int or str based on format_int.\n\"\"\"\n```\n\n## FILE 5: num2words/__init__.py\n\n- FUNCTION NAME: num2words\n  - SIGNATURE: def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given number into its word representation in multiple languages.\n\nParameters:\n- number (int, float, str): The number to convert to words. If a string is provided, it will be converted to a number using the language-specific converter.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., 1 becomes \"first\"). Defaults to False.\n- lang (str): The language code (e.g., 'en' for English, 'fr' for French). Can also be a shortened two-letter version. Defaults to 'en'.\n- to (str): The type of conversion to perform, which must be one of the types listed in CONVERTES_TYPES (e.g., 'cardinal', 'ordinal'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the specified language is not supported or if the requested conversion type is not recognized.\n\nInteractions:\nRelies on the CONVERTER_CLASSES dictionary, which maps language codes to their corresponding Num2Word converter instances. Also uses the CONVERTES_TYPES list to validate the conversion type.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - num2words/lang_PL.py:Num2Word_PL:to_ordinal\n    - num2words/base.py:Num2Word_Base:to_currency\n    - num2words/lang_PL.py:Num2Word_PL:to_cardinal\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/lang_PL.py": "from __future__ import unicode_literals\nimport itertools\nfrom .base import Num2Word_Base\nfrom .utils import get_digits, splitbyx\nZERO = ('zero',)\nONES = {1: ('jeden',), 2: ('dwa',), 3: ('trzy',), 4: ('cztery',), 5: ('pi\u0119\u0107',), 6: ('sze\u015b\u0107',), 7: ('siedem',), 8: ('osiem',), 9: ('dziewi\u0119\u0107',)}\nONES_ORDINALS = {1: ('pierwszy', 'pierwszo'), 2: ('drugi', 'dwu'), 3: ('trzeci', 'trzy'), 4: ('czwarty', 'cztero'), 5: ('pi\u0105ty', 'pi\u0119cio'), 6: ('sz\u00f3sty', 'sze\u015bcio'), 7: ('si\u00f3dmy', 'siedmio'), 8: ('\u00f3smy', 'o\u015bmio'), 9: ('dziewi\u0105ty', 'dziewi\u0119cio'), 10: ('dziesi\u0105ty', 'dziesi\u0119cio'), 11: ('jedenasty', 'jedenasto'), 12: ('dwunasty', 'dwunasto'), 13: ('trzynasty', 'trzynasto'), 14: ('czternasty', 'czternasto'), 15: ('pi\u0119tnasty', 'pi\u0119tnasto'), 16: ('szesnasty', 'szesnasto'), 17: ('siedemnasty', 'siedemnasto'), 18: ('osiemnasty', 'osiemnasto'), 19: ('dziewi\u0119tnasty', 'dziewi\u0119tnasto')}\nTENS = {0: ('dziesi\u0119\u0107',), 1: ('jedena\u015bcie',), 2: ('dwana\u015bcie',), 3: ('trzyna\u015bcie',), 4: ('czterna\u015bcie',), 5: ('pi\u0119tna\u015bcie',), 6: ('szesna\u015bcie',), 7: ('siedemna\u015bcie',), 8: ('osiemna\u015bcie',), 9: ('dziewi\u0119tna\u015bcie',)}\nTWENTIES = {2: ('dwadzie\u015bcia',), 3: ('trzydzie\u015bci',), 4: ('czterdzie\u015bci',), 5: ('pi\u0119\u0107dziesi\u0105t',), 6: ('sze\u015b\u0107dziesi\u0105t',), 7: ('siedemdziesi\u0105t',), 8: ('osiemdziesi\u0105t',), 9: ('dziewi\u0119\u0107dziesi\u0105t',)}\nTWENTIES_ORDINALS = {2: ('dwudziesty', 'dwudziesto'), 3: ('trzydziesty', 'trzydiesto'), 4: ('czterdziesty', 'czterdziesto'), 5: ('pi\u0119\u0107dziesi\u0105ty', 'pi\u0119\u0107dziesi\u0119cio'), 6: ('sze\u015b\u0107dziesi\u0105ty', 'sze\u015b\u0107dziesi\u0119cio'), 7: ('siedemdziesi\u0105ty', 'siedemdziesi\u0119cio'), 8: ('osiemdziesi\u0105ty', 'osiemdziesi\u0119cio'), 9: ('dziewi\u0119\u0107dziesi\u0105ty', 'dziewi\u0119\u0107dziesi\u0119cio')}\nHUNDREDS = {1: ('sto',), 2: ('dwie\u015bcie',), 3: ('trzysta',), 4: ('czterysta',), 5: ('pi\u0119\u0107set',), 6: ('sze\u015b\u0107set',), 7: ('siedemset',), 8: ('osiemset',), 9: ('dziewi\u0119\u0107set',)}\nHUNDREDS_ORDINALS = {1: ('setny', 'stu'), 2: ('dwusetny', 'dwustu'), 3: ('trzysetny', 'trzystu'), 4: ('czterysetny', 'czterystu'), 5: ('pi\u0119\u0107setny', 'pi\u0119cset'), 6: ('sze\u015b\u0107setny', 'sze\u015b\u0107set'), 7: ('siedemsetny', 'siedemset'), 8: ('osiemsetny', 'o\u015biemset'), 9: ('dziewi\u0119\u0107setny', 'dziewi\u0119\u0107set')}\nTHOUSANDS = {1: ('tysi\u0105c', 'tysi\u0105ce', 'tysi\u0119cy')}\nprefixes_ordinal = {1: 'tysi\u0119czny', 2: 'milionowy', 3: 'milairdowy'}\nprefixes = ('mi', 'bi', 'try', 'kwadry', 'kwinty', 'seksty', 'septy', 'okty', 'nony', 'decy')\nsuffixes = ('lion', 'liard')\nfor idx, (p, s) in enumerate(itertools.product(prefixes, suffixes)):\n    name = p + s\n    THOUSANDS[idx + 2] = (name, name + 'y', name + '\u00f3w')\n\nclass Num2Word_PL(Num2Word_Base):\n    CURRENCY_FORMS = {'PLN': (('z\u0142oty', 'z\u0142ote', 'z\u0142otych'), ('grosz', 'grosze', 'groszy')), 'EUR': (('euro', 'euro', 'euro'), ('cent', 'centy', 'cent\u00f3w')), 'USD': (('dolar ameryka\u0144ski', 'dolary ameryka\u0144skie', 'dolar\u00f3w ameryka\u0144skich'), ('cent', 'centy', 'cent\u00f3w'))}\n\n    def setup(self):\n        self.negword = 'minus'\n        self.pointword = 'przecinek'",
    "num2words/base.py": "from __future__ import unicode_literals\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def __init__(self):\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = '(-) '\n        self.pointword = '(.)'\n        self.errmsg_nonnum = 'type(%s) not in [long, int, float]'\n        self.errmsg_floatord = 'Cannot treat float %s as ordinal.'\n        self.errmsg_negord = 'Cannot treat negative num %s as ordinal.'\n        self.errmsg_toobig = 'abs(%s) must be less than %s.'\n        self.setup()\n        if any((hasattr(self, field) for field in ['high_numwords', 'mid_numwords', 'low_numwords'])):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_high_numwords(self, *args):\n        raise NotImplementedError\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n            out = []\n            if value == 0:\n                div, mod = (1, 0)\n            else:\n                div, mod = divmod(value, elem)\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:\n                    return [(div * self.cards[elem], div * elem)]\n                out.append(self.splitnum(div))\n            out.append((self.cards[elem], elem))\n            if mod:\n                out.append(self.splitnum(mod))\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            return ('%s ' % self.negword.strip(), num_str[1:])\n        return ('', num_str)\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n        out = ''\n        if value < 0:\n            value = abs(value)\n            out = '%s ' % self.negword.strip()\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n        post = abs(value - pre) * 10 ** self.precision\n        if abs(round(post) - post) < 0.01:\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n        return (pre, post)\n\n    def to_cardinal_float(self, value):\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n        pre, post = self.float2tuple(float(value))\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n        return ' '.join(out)\n\n    def merge(self, curr, next):\n        raise NotImplementedError\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def title(self, value):\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = ' '.join(out)\n        return value\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def to_ordinal_num(self, value):\n        return value\n\n    def inflect(self, value, text):\n        text = text.split('/')\n        if value == 1:\n            return text[0]\n        return ''.join(text)\n\n    def to_splitnum(self, val, hightxt='', lowtxt='', jointxt='', divisor=100, longval=True, cents=True):\n        out = []\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append('%02d' % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n        return ' '.join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def pluralize(self, n, forms):\n        \"\"\"\n        Should resolve gettext form:\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n        \"\"\"\n        raise NotImplementedError\n\n    def setup(self):\n        pass",
    "num2words/currency.py": "from __future__ import division\nfrom decimal import ROUND_HALF_UP, Decimal\n\ndef prefix_currency(prefix, base):\n    return tuple(('%s %s' % (prefix, i) for i in base))",
    "num2words/utils.py": "",
    "num2words/__init__.py": "from __future__ import unicode_literals\nfrom . import lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE, lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN, lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR, lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR, lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID, lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT, lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR, lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE, lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI\nCONVERTER_CLASSES = {'am': lang_AM.Num2Word_AM(), 'ar': lang_AR.Num2Word_AR(), 'az': lang_AZ.Num2Word_AZ(), 'be': lang_BE.Num2Word_BE(), 'bn': lang_BN.Num2Word_BN(), 'ca': lang_CA.Num2Word_CA(), 'ce': lang_CE.Num2Word_CE(), 'cy': lang_CY.Num2Word_CY(), 'cz': lang_CZ.Num2Word_CZ(), 'en': lang_EN.Num2Word_EN(), 'en_IN': lang_EN_IN.Num2Word_EN_IN(), 'en_NG': lang_EN_NG.Num2Word_EN_NG(), 'fa': lang_FA.Num2Word_FA(), 'fr': lang_FR.Num2Word_FR(), 'fr_CH': lang_FR_CH.Num2Word_FR_CH(), 'fr_BE': lang_FR_BE.Num2Word_FR_BE(), 'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(), 'de': lang_DE.Num2Word_DE(), 'fi': lang_FI.Num2Word_FI(), 'eo': lang_EO.Num2Word_EO(), 'es': lang_ES.Num2Word_ES(), 'es_CO': lang_ES_CO.Num2Word_ES_CO(), 'es_CR': lang_ES_CR.Num2Word_ES_CR(), 'es_GT': lang_ES_GT.Num2Word_ES_GT(), 'es_NI': lang_ES_NI.Num2Word_ES_NI(), 'es_VE': lang_ES_VE.Num2Word_ES_VE(), 'id': lang_ID.Num2Word_ID(), 'ja': lang_JA.Num2Word_JA(), 'kn': lang_KN.Num2Word_KN(), 'ko': lang_KO.Num2Word_KO(), 'kz': lang_KZ.Num2Word_KZ(), 'lt': lang_LT.Num2Word_LT(), 'lv': lang_LV.Num2Word_LV(), 'pl': lang_PL.Num2Word_PL(), 'ro': lang_RO.Num2Word_RO(), 'ru': lang_RU.Num2Word_RU(), 'sk': lang_SK.Num2Word_SK(), 'sl': lang_SL.Num2Word_SL(), 'sr': lang_SR.Num2Word_SR(), 'sv': lang_SV.Num2Word_SV(), 'no': lang_NO.Num2Word_NO(), 'dk': lang_DK.Num2Word_DK(), 'pt': lang_PT.Num2Word_PT(), 'pt_BR': lang_PT_BR.Num2Word_PT_BR(), 'he': lang_HE.Num2Word_HE(), 'it': lang_IT.Num2Word_IT(), 'vi': lang_VI.Num2Word_VI(), 'tg': lang_TG.Num2Word_TG(), 'th': lang_TH.Num2Word_TH(), 'tr': lang_TR.Num2Word_TR(), 'nl': lang_NL.Num2Word_NL(), 'uk': lang_UK.Num2Word_UK(), 'te': lang_TE.Num2Word_TE(), 'tet': lang_TET.Num2Word_TET(), 'hu': lang_HU.Num2Word_HU(), 'is': lang_IS.Num2Word_IS()}\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']"
  },
  "call_tree": {
    "modified_testcases/test_pl.py:Num2WordsPLTest:test_cardinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_PL.py:Num2Word_PL:to_cardinal": {
          "num2words/lang_PL.py:Num2Word_PL:_int2word": {
            "num2words/utils.py:splitbyx": {},
            "num2words/utils.py:get_digits": {},
            "num2words/lang_PL.py:Num2Word_PL:pluralize": {}
          }
        }
      }
    },
    "modified_testcases/test_pl.py:Num2WordsPLTest:test_currency": {
      "num2words/__init__.py:num2words": {
        "num2words/base.py:Num2Word_Base:to_currency": {
          "num2words/currency.py:parse_currency_parts": {},
          "num2words/base.py:Num2Word_Base:_money_verbose": {
            "num2words/lang_PL.py:Num2Word_PL:to_cardinal": {
              "num2words/lang_PL.py:Num2Word_PL:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {},
                "num2words/lang_PL.py:Num2Word_PL:pluralize": {}
              }
            }
          },
          "num2words/base.py:Num2Word_Base:_cents_verbose": {
            "num2words/lang_PL.py:Num2Word_PL:to_cardinal": {
              "num2words/lang_PL.py:Num2Word_PL:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {}
              }
            }
          },
          "num2words/lang_PL.py:Num2Word_PL:pluralize": {},
          "num2words/base.py:Num2Word_Base:_cents_terse": {}
        }
      }
    },
    "modified_testcases/test_pl.py:Num2WordsPLTest:test_to_ordinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_PL.py:Num2Word_PL:to_ordinal": {
          "num2words/utils.py:splitbyx": {},
          "num2words/lang_PL.py:Num2Word_PL:last_fragment_to_ordinal": {
            "num2words/utils.py:get_digits": {}
          },
          "num2words/lang_PL.py:Num2Word_PL:_int2word": {
            "num2words/utils.py:splitbyx": {},
            "num2words/utils.py:get_digits": {},
            "num2words/lang_PL.py:Num2Word_PL:pluralize": {}
          }
        }
      }
    },
    "modified_testcases/test_pl.py:Num2WordsPLTest:test_to_ordinal_error": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_PL.py:Num2Word_PL:to_ordinal": {}
      }
    }
  }
}