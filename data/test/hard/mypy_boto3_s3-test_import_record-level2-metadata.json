{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_record",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_record.py",
  "test_code": "from mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportRecord:\n    def test_str(self) -> None:\n        source = ImportString(\"source\")\n        assert str(ImportRecord(source, \"name\", \"alias\")) == \"from source import name as alias\"\n        assert str(ImportRecord(source, alias=\"alias\")) == \"import source as alias\"\n        assert str(ImportRecord(source, \"name\")) == \"from source import name\"\n        assert str(ImportRecord(source)) == \"import source\"\n\n    def test_operations(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source, \"name\", \"alias\")\n        assert hash(ImportRecord(source, \"name\")) == hash(ImportRecord(source, \"name\"))\n        assert hash(ImportRecord(source, \"name\")) != hash(ImportRecord(source, \"name2\"))\n        assert ImportRecord(source, \"name\") == ImportRecord(source, \"name\")\n        assert ImportRecord(source, \"name\") != ImportRecord(source, \"name2\")\n        assert ImportRecord(source, \"name\") != \"test\"\n\n    def test_comparison(self) -> None:\n        local_source = ImportString(\"mypy_boto3_s3\")\n        third_party_source = ImportString(\"boto3\")\n        other_source = ImportString(\"other\")\n        assert ImportRecord(local_source, \"test\") > ImportRecord(local_source, \"name\")\n        assert ImportRecord(third_party_source, \"test\") < ImportRecord(local_source, \"name\")\n        assert ImportRecord(other_source, \"test\") < ImportRecord(third_party_source, \"name\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(third_party_source, \"test\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(third_party_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(ImportString(\"zzz\")) > ImportRecord(ImportString(\"aaa\"))\n        assert ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n        ) > ImportRecord(local_source, \"name\")\n        assert not (\n            ImportRecord(local_source, \"name\")\n            > ImportRecord(local_source, \"test\", fallback=ImportRecord(local_source, \"test2\"))\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            third_party_source,\n            \"test\",\n            fallback=ImportRecord(third_party_source, \"test2\"),\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n            min_version=(2, 11),\n        )\n\n    def test_get_local_name(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source).get_local_name() == \"source\"\n        assert ImportRecord(source, \"name\").get_local_name() == \"name\"\n        assert ImportRecord(source, \"name\", \"alias\").get_local_name() == \"alias\"\n        assert ImportRecord(source, alias=\"alias\").get_local_name() == \"alias\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initialize an ImportString instance.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts that will be appended to the parent to form the complete import string.\n\nRaises:\n    StructureError: If the parent and parts are both empty, if any part contains a dot (indicating an incorrect split), or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the parent and all additional parts, ensuring each part adheres to the import string formatting rules.\n\nConstants Used:\n    - StructureError: Exception raised for incorrect import string structures, defined in the mypy_boto3_builder.exceptions module. This error is raised to enforce constraints on the input values during initialization.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initialize an ImportString instance.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts that will be appended to the parent to form the complete import string.\n\nRaises:\n    StructureError: If the parent and parts are both empty, if any part contains a dot (indicating an incorrect split), or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the parent and all additional parts, ensuring each part adheres to the import string formatting rules.\n\nConstants Used:\n    - StructureError: Exception raised for incorrect import string structures, defined in the mypy_boto3_builder.exceptions module. This error is raised to enforce constraints on the input values during initialization.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ImportString instance based on its parts.\n\nThis method computes the hash by using the built-in `hash()` function on the tuple of import string parts stored in the `self.parts` attribute. This allows instances of ImportString to be used as keys in dictionaries and stored in sets, ensuring that two ImportString instances are considered the same if they have the same import parts.\n\nReturns:\n    int: The hash value of the ImportString instance.\n\nAttributes:\n    self.parts: A tuple that consists of the parent module name and any additional parts, ensuring that hash calculation reflects the complete import structure.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate a hash value for the ImportString instance based on its parts.\n\nThis method computes the hash by using the built-in `hash()` function on the tuple of import string parts stored in the `self.parts` attribute. This allows instances of ImportString to be used as keys in dictionaries and stored in sets, ensuring that two ImportString instances are considered the same if they have the same import parts.\n\nReturns:\n    int: The hash value of the ImportString instance.\n\nAttributes:\n    self.parts: A tuple that consists of the parent module name and any additional parts, ensuring that hash calculation reflects the complete import structure.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether two `ImportString` instances represent the same import by comparing their parts. \n\nParameters:\n    other (object): The object to compare against. It should be an instance of `ImportString`.\n\nReturns:\n    bool: True if the parts of both instances are equal, otherwise False.\n\nRaises:\n    BuildInternalError: If `other` is not an instance of `ImportString`, indicating type safety for equality checks.\n\nThis method relies on the `parts` attribute, which is a tuple of strings representing the components of the import. It is defined in the `__init__` method and plays a crucial role in determining equality by directly comparing these parts.\"\"\"\n        '\\n        Whether import strings produce the same render.\\n        '\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
        "docstring": "Whether two `ImportString` instances represent the same import by comparing their parts. \n\nParameters:\n    other (object): The object to compare against. It should be an instance of `ImportString`.\n\nReturns:\n    bool: True if the parts of both instances are equal, otherwise False.\n\nRaises:\n    BuildInternalError: If `other` is not an instance of `ImportString`, indicating type safety for equality checks.\n\nThis method relies on the `parts` attribute, which is a tuple of strings representing the components of the import. It is defined in the `__init__` method and plays a crucial role in determining equality by directly comparing these parts.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__gt__": {
        "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"Compare two ImportString instances for sorting purposes. This method emulates the logic used in `isort` to determine the order of import strings.\n\nParameters:\n- other (Self): Another instance of ImportString to compare against.\n\nReturns:\n- bool: True if the instance is greater than the other instance based on sorting criteria, otherwise False.\n\nSorting criteria are as follows:\n1. If the two import strings are equal, return False.\n2. Prioritize local imports over third-party imports, which are identified by checking the parent module name against the set of third-party modules defined in _THIRD_PARTY.\n3. If both are of the same type (local or third-party), compare their parts lexicographically.\"\"\"\n        '\\n        Compare import strings for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
        "docstring": "Compare two ImportString instances for sorting purposes. This method emulates the logic used in `isort` to determine the order of import strings.\n\nParameters:\n- other (Self): Another instance of ImportString to compare against.\n\nReturns:\n- bool: True if the instance is greater than the other instance based on sorting criteria, otherwise False.\n\nSorting criteria are as follows:\n1. If the two import strings are equal, return False.\n2. Prioritize local imports over third-party imports, which are identified by checking the parent module name against the set of third-party modules defined in _THIRD_PARTY.\n3. If both are of the same type (local or third-party), compare their parts lexicographically.",
        "signature": "def __gt__(self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the ImportString object to a valid Python import string.\n\nThis method concatenates all parts of the import string, separated by dots, to form a fully qualified import statement. It does not take any parameters and returns a string representation of the import path. The output is ready to be used directly in an import statement in Python code.\n\nReturns:\n    str: A string representing the complete import path formed by joining the parts of the ImportString instance.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the ImportString object to a valid Python import string.\n\nThis method concatenates all parts of the import string, separated by dots, to form a fully qualified import statement. It does not take any parameters and returns a string representation of the import path. The output is ready to be used directly in an import statement in Python code.\n\nReturns:\n    str: A string representing the complete import path formed by joining the parts of the ImportString instance.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        \"\"\"Initialize an ImportRecord instance that represents a Python import string.\n\nParameters:\n- source (ImportString): The source from which the import is made, represented as an ImportString object.\n- name (str, optional): The name of the import. Defaults to an empty string.\n- alias (str, optional): An optional local alias for the import. Defaults to an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for this import, used for version checks. Defaults to None.\n- fallback (Self | None, optional): An optional fallback ImportRecord to be used if the import fails under certain conditions. Allows for chaining of import attempts. Defaults to None.\n\nThis constructor sets the provided parameters as attributes of the instance for later retrieval in other methods, such as rendering the import statement or comparing instances.\"\"\"\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback",
        "docstring": "Initialize an ImportRecord instance that represents a Python import string.\n\nParameters:\n- source (ImportString): The source from which the import is made, represented as an ImportString object.\n- name (str, optional): The name of the import. Defaults to an empty string.\n- alias (str, optional): An optional local alias for the import. Defaults to an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for this import, used for version checks. Defaults to None.\n- fallback (Self | None, optional): An optional fallback ImportRecord to be used if the import fails under certain conditions. Allows for chaining of import attempts. Defaults to None.\n\nThis constructor sets the provided parameters as attributes of the instance for later retrieval in other methods, such as rendering the import statement or comparing instances.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get rendered import statement as a string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a valid Python import statement in string format. It utilizes the `source`, `name`, and `alias` attributes to determine the appropriate rendering:\n\n- If `name` is provided, it returns a format of \"from {source} import {name}\".\n- If `name` is not provided but `alias` is set, it returns \"import {source} as {alias}\".\n- If neither `name` nor `alias` are provided, it simply returns \"import {source}\".\n\nNo parameters are required for this method, and it does not have side effects. The attributes `source`, `name`, and `alias` are defined in the `__init__` method. The method assumes `source` is an instance of `ImportString`. If `name` is missing when required, it raises a `StructureError`.\"\"\"\n        '\\n        Get rendered string.\\n        '\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
        "docstring": "Get rendered import statement as a string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a valid Python import statement in string format. It utilizes the `source`, `name`, and `alias` attributes to determine the appropriate rendering:\n\n- If `name` is provided, it returns a format of \"from {source} import {name}\".\n- If `name` is not provided but `alias` is set, it returns \"import {source} as {alias}\".\n- If neither `name` nor `alias` are provided, it simply returns \"import {source}\".\n\nNo parameters are required for this method, and it does not have side effects. The attributes `source`, `name`, and `alias` are defined in the `__init__` method. The method assumes `source` is an instance of `ImportString`. If `name` is missing when required, it raises a `StructureError`.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Render the ImportRecord as a valid Python import statement.\n\nThis method formats the ImportRecord instance into a string that represents\na Python import statement. It delegates the rendering to the `render` method,\nwhich constructs the appropriate import syntax based on the attributes: \n`source`, `name`, and `alias`. The output varies depending on whether \nthe ImportRecord has a name, an alias, or none, ensuring valid syntax for \nimporting modules in Python.\n\nReturns:\n    str: A string representing the Python import statement.\n\nDependencies:\n    This method relies on the `render` method of the ImportRecord class\n    to generate the import statement based on the specified attributes.\"\"\"\n        '\\n        Render as a valid Python import statement.\\n        '\n        return self.render()",
        "docstring": "Render the ImportRecord as a valid Python import statement.\n\nThis method formats the ImportRecord instance into a string that represents\na Python import statement. It delegates the rendering to the `render` method,\nwhich constructs the appropriate import syntax based on the attributes: \n`source`, `name`, and `alias`. The output varies depending on whether \nthe ImportRecord has a name, an alias, or none, ensuring valid syntax for \nimporting modules in Python.\n\nReturns:\n    str: A string representing the Python import statement.\n\nDependencies:\n    This method relies on the `render` method of the ImportRecord class\n    to generate the import statement based on the specified attributes.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the ImportRecord instance.\n\nThis method is used to generate a unique hash based on the attributes of the ImportRecord, specifically the `source` (an instance of ImportString), `name`, `alias`, `min_version`, and `fallback`. The resulting hash value is essential for using ImportRecord instances in hashed collections such as sets or as keys in dictionaries. The method relies on the built-in `hash()` function to obtain a hash value from a tuple containing the key attributes.\"\"\"\n        '\\n        Calculate hash value based on source, name and alias.\\n        '\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))",
        "docstring": "Calculate the hash value for the ImportRecord instance.\n\nThis method is used to generate a unique hash based on the attributes of the ImportRecord, specifically the `source` (an instance of ImportString), `name`, `alias`, `min_version`, and `fallback`. The resulting hash value is essential for using ImportRecord instances in hashed collections such as sets or as keys in dictionaries. The method relies on the built-in `hash()` function to obtain a hash value from a tuple containing the key attributes.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Check equality between two ImportRecord instances.\n\nParameters:\n- other (object): The object to compare against the current instance.\n\nReturns:\n- bool: True if both instances produce the same rendered import statement; otherwise, False. \n\nThis method relies on the __str__ method to produce the rendered import statement, ensuring that two ImportRecord instances are considered equal if their string representations are identical. It is important for correct behavior in sets and dictionaries where ImportRecord instances are used as keys or elements.\"\"\"\n        '\\n        Whether two import records produce the same render.\\n        '\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)",
        "docstring": "Check equality between two ImportRecord instances.\n\nParameters:\n- other (object): The object to compare against the current instance.\n\nReturns:\n- bool: True if both instances produce the same rendered import statement; otherwise, False. \n\nThis method relies on the __str__ method to produce the rendered import statement, ensuring that two ImportRecord instances are considered equal if their string representations are identical. It is important for correct behavior in sets and dictionaries where ImportRecord instances are used as keys or elements.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__gt__": {
        "code": "    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"Compare two ImportRecord instances to determine their ordering based on specific criteria, emulating `isort` logic.\n\nParameters:\n- self (ImportRecord): The first import record being compared.\n- other (ImportRecord): The second import record to compare against.\n\nReturns:\n- bool: True if `self` is greater than `other`, otherwise False.\n\nThe comparison is done based on the following attributes in order: \n1. `min_version`: If the minimum versions differ, the record with the higher version is greater.\n2. `fallback`: If one record has a fallback and the other does not, the one with a fallback is considered greater.\n3. `source`: If both records have the same min version and fallback status, they are compared by `source`.\n4. `name`: If all prior comparisons are equal, the names are compared.\n\nRelevant dependencies include the `min_version` attribute representing the minimum Python version required for the import, and `fallback`, an optional ImportRecord that provides an alternative import if necessary. These attributes are integral to establishing the order amongst import records within the broader logic of Python imports.\"\"\"\n        '\\n        Compare two import records for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name",
        "docstring": "Compare two ImportRecord instances to determine their ordering based on specific criteria, emulating `isort` logic.\n\nParameters:\n- self (ImportRecord): The first import record being compared.\n- other (ImportRecord): The second import record to compare against.\n\nReturns:\n- bool: True if `self` is greater than `other`, otherwise False.\n\nThe comparison is done based on the following attributes in order: \n1. `min_version`: If the minimum versions differ, the record with the higher version is greater.\n2. `fallback`: If one record has a fallback and the other does not, the one with a fallback is considered greater.\n3. `source`: If both records have the same min version and fallback status, they are compared by `source`.\n4. `name`: If all prior comparisons are equal, the names are compared.\n\nRelevant dependencies include the `min_version` attribute representing the minimum Python version required for the import, and `fallback`, an optional ImportRecord that provides an alternative import if necessary. These attributes are integral to establishing the order amongst import records within the broader logic of Python imports.",
        "signature": "def __gt__(self: Self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.get_local_name": {
        "code": "    def get_local_name(self) -> str:\n        \"\"\"Get the local import name for this import record.\n\nThis method returns the local name used when importing a module or a symbol. It prioritizes the `alias` if it is defined, then it falls back to the `name`. If neither is present, it uses the rendered representation of the `source`, which is an instance of `ImportString`. The `source` is crucial as it provides the original import string when no alias or name is specified.\n\nReturns:\n    str: The local import name, which may be the alias, the name, or the rendered string of the source.\"\"\"\n        '\\n        Get local import name.\\n        '\n        return self.alias or self.name or self.source.render()",
        "docstring": "Get the local import name for this import record.\n\nThis method returns the local name used when importing a module or a symbol. It prioritizes the `alias` if it is defined, then it falls back to the `name`. If neither is present, it uses the rendered representation of the `source`, which is an instance of `ImportString`. The `source` is crucial as it provides the original import string when no alias or name is specified.\n\nReturns:\n    str: The local import name, which may be the alias, the name, or the rendered string of the source.",
        "signature": "def get_local_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.render_name": {
          "code": "    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name",
          "docstring": "Get rendered import name.",
          "signature": "def render_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render as a part of a valid Python import statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.is_local": {
          "code": "    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()",
          "docstring": "Whether import is from local module.",
          "signature": "def is_local(self) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        },
        "ImportString.is_third_party": {
          "code": "    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
          "docstring": "Whether import is from 3rd party module.",
          "signature": "def is_third_party(self) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
  },
  "call_tree": {
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
                "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
              },
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
            }
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
          },
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_get_local_name": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_record\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u251c\u2500\u2500 import_record.py\n        \u2502   \u251c\u2500\u2500 ImportRecord\n        \u2502   \u251c\u2500\u2500 ImportRecord.__eq__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__gt__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__hash__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__init__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__str__\n        \u2502   \u251c\u2500\u2500 ImportRecord.get_local_name\n        \u2502   \u2514\u2500\u2500 ImportRecord.render\n        \u2514\u2500\u2500 import_string.py\n            \u251c\u2500\u2500 ImportString.__eq__\n            \u251c\u2500\u2500 ImportString.__gt__\n            \u251c\u2500\u2500 ImportString.__hash__\n            \u251c\u2500\u2500 ImportString.__init__\n            \u2514\u2500\u2500 ImportString.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for managing and representing Python import statements, enabling developers to construct, compare, and manipulate imports programmatically. It offers capabilities to generate import strings, handle aliasing, support fallback imports, and enforce version constraints, ensuring comprehensive control over import requirements in dynamic or static code generation scenarios. By facilitating the structured management of imports, the module resolves challenges related to import conflicts, readability, and maintainability, streamlining the development of tools or applications that interact with Python import mechanics. This is particularly beneficial in cases requiring programmatically generated or complex import structures, such as dynamic SDKs or automated code generation workflows.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportString instance.\n\nParameters:\n    parent (str): The master module name that serves as the base for the import string.\n    *parts (str): Additional parts that will be appended to the parent to form the complete import string.\n\nRaises:\n    StructureError: If the parent and parts are both empty, if any part contains a dot (indicating an incorrect split), or if there are empty parts following non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the parent and all additional parts, ensuring each part adheres to the import string formatting rules.\n\nConstants Used:\n    - StructureError: Exception raised for incorrect import string structures, defined in the mypy_boto3_builder.exceptions module. This error is raised to enforce constraints on the input values during initialization.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__gt__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __gt__(self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two ImportString instances for sorting purposes. This method emulates the logic used in `isort` to determine the order of import strings.\n\nParameters:\n- other (Self): Another instance of ImportString to compare against.\n\nReturns:\n- bool: True if the instance is greater than the other instance based on sorting criteria, otherwise False.\n\nSorting criteria are as follows:\n1. If the two import strings are equal, return False.\n2. Prioritize local imports over third-party imports, which are identified by checking the parent module name against the set of third-party modules defined in _THIRD_PARTY.\n3. If both are of the same type (local or third-party), compare their parts lexicographically.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ImportString instance based on its parts.\n\nThis method computes the hash by using the built-in `hash()` function on the tuple of import string parts stored in the `self.parts` attribute. This allows instances of ImportString to be used as keys in dictionaries and stored in sets, ensuring that two ImportString instances are considered the same if they have the same import parts.\n\nReturns:\n    int: The hash value of the ImportString instance.\n\nAttributes:\n    self.parts: A tuple that consists of the parent module name and any additional parts, ensuring that hash calculation reflects the complete import structure.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the ImportString object to a valid Python import string.\n\nThis method concatenates all parts of the import string, separated by dots, to form a fully qualified import statement. It does not take any parameters and returns a string representation of the import path. The output is ready to be used directly in an import statement in Python code.\n\nReturns:\n    str: A string representing the complete import path formed by joining the parts of the ImportString instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__eq__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nWhether two `ImportString` instances represent the same import by comparing their parts. \n\nParameters:\n    other (object): The object to compare against. It should be an instance of `ImportString`.\n\nReturns:\n    bool: True if the parts of both instances are equal, otherwise False.\n\nRaises:\n    BuildInternalError: If `other` is not an instance of `ImportString`, indicating type safety for equality checks.\n\nThis method relies on the `parts` attribute, which is a tuple of strings representing the components of the import. It is defined in the `__init__` method and plays a crucial role in determining equality by directly comparing these parts.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.__hash__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the ImportRecord instance.\n\nThis method is used to generate a unique hash based on the attributes of the ImportRecord, specifically the `source` (an instance of ImportString), `name`, `alias`, `min_version`, and `fallback`. The resulting hash value is essential for using ImportRecord instances in hashed collections such as sets or as keys in dictionaries. The method relies on the built-in `hash()` function to obtain a hash value from a tuple containing the key attributes.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.get_local_name\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def get_local_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local import name for this import record.\n\nThis method returns the local name used when importing a module or a symbol. It prioritizes the `alias` if it is defined, then it falls back to the `name`. If neither is present, it uses the rendered representation of the `source`, which is an instance of `ImportString`. The `source` is crucial as it provides the original import string when no alias or name is specified.\n\nReturns:\n    str: The local import name, which may be the alias, the name, or the rendered string of the source.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__init__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportRecord instance that represents a Python import string.\n\nParameters:\n- source (ImportString): The source from which the import is made, represented as an ImportString object.\n- name (str, optional): The name of the import. Defaults to an empty string.\n- alias (str, optional): An optional local alias for the import. Defaults to an empty string.\n- min_version (tuple[int, ...] | None, optional): The minimum Python version required for this import, used for version checks. Defaults to None.\n- fallback (Self | None, optional): An optional fallback ImportRecord to be used if the import fails under certain conditions. Allows for chaining of import attempts. Defaults to None.\n\nThis constructor sets the provided parameters as attributes of the instance for later retrieval in other methods, such as rendering the import statement or comparing instances.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__gt__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __gt__(self: Self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two ImportRecord instances to determine their ordering based on specific criteria, emulating `isort` logic.\n\nParameters:\n- self (ImportRecord): The first import record being compared.\n- other (ImportRecord): The second import record to compare against.\n\nReturns:\n- bool: True if `self` is greater than `other`, otherwise False.\n\nThe comparison is done based on the following attributes in order: \n1. `min_version`: If the minimum versions differ, the record with the higher version is greater.\n2. `fallback`: If one record has a fallback and the other does not, the one with a fallback is considered greater.\n3. `source`: If both records have the same min version and fallback status, they are compared by `source`.\n4. `name`: If all prior comparisons are equal, the names are compared.\n\nRelevant dependencies include the `min_version` attribute representing the minimum Python version required for the import, and `fallback`, an optional ImportRecord that provides an alternative import if necessary. These attributes are integral to establishing the order amongst import records within the broader logic of Python imports.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.render\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet rendered import statement as a string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns a valid Python import statement in string format. It utilizes the `source`, `name`, and `alias` attributes to determine the appropriate rendering:\n\n- If `name` is provided, it returns a format of \"from {source} import {name}\".\n- If `name` is not provided but `alias` is set, it returns \"import {source} as {alias}\".\n- If neither `name` nor `alias` are provided, it simply returns \"import {source}\".\n\nNo parameters are required for this method, and it does not have side effects. The attributes `source`, `name`, and `alias` are defined in the `__init__` method. The method assumes `source` is an instance of `ImportString`. If `name` is missing when required, it raises a `StructureError`.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__str__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the ImportRecord as a valid Python import statement.\n\nThis method formats the ImportRecord instance into a string that represents\na Python import statement. It delegates the rendering to the `render` method,\nwhich constructs the appropriate import syntax based on the attributes: \n`source`, `name`, and `alias`. The output varies depending on whether \nthe ImportRecord has a name, an alias, or none, ensuring valid syntax for \nimporting modules in Python.\n\nReturns:\n    str: A string representing the Python import statement.\n\nDependencies:\n    This method relies on the `render` method of the ImportRecord class\n    to generate the import statement based on the specified attributes.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__eq__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck equality between two ImportRecord instances.\n\nParameters:\n- other (object): The object to compare against the current instance.\n\nReturns:\n- bool: True if both instances produce the same rendered import statement; otherwise, False. \n\nThis method relies on the __str__ method to produce the rendered import statement, ensuring that two ImportRecord instances are considered equal if their string representations are identical. It is important for correct behavior in sets and dictionaries where ImportRecord instances are used as keys or elements.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)"
  }
}