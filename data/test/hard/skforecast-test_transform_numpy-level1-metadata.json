{
  "dir_path": "/app/skforecast",
  "package_name": "skforecast",
  "sample_name": "skforecast-test_transform_numpy",
  "src_dir": "skforecast/",
  "test_dir": "tests/",
  "test_file": "skforecast/utils/tests/tests_utils/test_transform_numpy.py",
  "test_code": "# Unit test transform_numpy\n# ==============================================================================\nimport re\nimport pytest\nimport numpy as np\nimport pandas as pd\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.preprocessing import OneHotEncoder\nfrom skforecast.utils import transform_numpy\n\n\ndef test_transform_numpy_TypeError_when_array_is_not_numpy_ndarray():\n    \"\"\"\n    Test TypeError is raised when `array` is not a numpy ndarray.\n    \"\"\"\n    array = pd.Series(np.arange(10))\n\n    err_msg = re.escape(f\"`array` argument must be a numpy ndarray. Got {type(array)}\")\n    with pytest.raises(TypeError, match = err_msg):\n        transform_numpy(\n            array             = array,\n            transformer       = None,\n            fit               = True,\n            inverse_transform = False\n        )\n\n\ndef test_transform_numpy_when_transformer_is_None():\n    \"\"\"\n    Test the output of transform_numpy when transformer is None.\n    \"\"\"\n    input_array = np.array([1.16, -0.28, 0.07, 2.4, 0.25, -0.56, -1.42, 1.26, 1.78, -1.49])\n    transformer = None\n    results = transform_numpy(\n                  array             = input_array,\n                  transformer       = transformer,\n                  fit               = True,\n                  inverse_transform = False\n              )\n    \n    expected = input_array\n    \n    np.testing.assert_array_almost_equal(results, expected)\n\n\ndef test_transform_numpy_ValueError_when_transformer_is_ColumnTransformer_and_inverse_transform_is_true():\n    \"\"\"\n    Test that transform_numpy raise ValueError when transformer is ColumnTransformer\n    and argument inverse_transform is True.\n    \"\"\"\n    array = np.array([\n                [7.5, 'a'],\n                [24.4, 'a'],\n                [60.3, 'a'],\n                [57.3, 'a'],\n                [50.7, 'b'],\n                [41.4, 'b'],\n                [87.2, 'b'],\n                [47.4, 'b']\n            ], dtype=object)\n    \n    transformer = ColumnTransformer(\n                      [('scale', StandardScaler(), 0),\n                       ('onehot', OneHotEncoder(sparse_output=False), 1)],\n                      remainder = 'passthrough',\n                      verbose_feature_names_out = False\n                  )\n\n    err_msg = re.escape(\"`inverse_transform` is not available when using ColumnTransformers.\")\n    with pytest.raises(ValueError, match = err_msg):\n        transform_numpy(\n            array             = array,\n            transformer       = transformer,\n            fit               = True,\n            inverse_transform = True\n        )\n\n\ndef test_transform_numpy_when_transformer_is_StandardScaler():\n    \"\"\"\n    Test the output of transform_numpy when transformer is StandardScaler.\n    \"\"\"\n    input_array = np.array([1.16, -0.28, 0.07, 2.4, 0.25, -0.56, -1.42, 1.26, 1.78, -1.49])\n    transformer = StandardScaler()\n    results = transform_numpy(\n                  array             = input_array,\n                  transformer       = transformer,\n                  fit               = True,\n                  inverse_transform = False\n              )\n    \n    expected = np.array([\n        0.67596768, -0.47871021, -0.19805933,  1.67027365, -0.0537246,\n        -0.70323091, -1.39283021,  0.75615365,  1.17312067, -1.44896038]\n    )\n    \n    np.testing.assert_array_almost_equal(results, expected)\n\n\ndef test_transform_numpy_when_transformer_is_StandardScaler_and_inverse_transform_is_True():\n    \"\"\"\n    Test the output of transform_numpy when transformer is StandardScaler and\n    inverse_transform is True.\n    \"\"\"\n    input_1 = np.array([1.16, -0.28, 0.07, 2.4, 0.25, -0.56, -1.42, 1.26, 1.78, -1.49])\n    transformer = StandardScaler()\n    transformer.fit(input_1.reshape(-1, 1))\n\n    input_2 = transformer.transform(input_1.reshape(-1, 1)).ravel()\n    results = transform_numpy(\n                  array             = input_2,\n                  transformer       = transformer,\n                  fit               = False,\n                  inverse_transform = True\n              )\n    \n    expected = input_1\n    \n    np.testing.assert_array_almost_equal(results, expected)\n\n\ndef test_transform_numpy_when_transformer_is_OneHotEncoder():\n    \"\"\"\n    Test the output of transform_numpy when transformer is OneHotEncoder.\n    \"\"\"\n    input_array = np.array(['A'] * 5 + ['B'] * 5).reshape(-1, 1)\n    transformer = OneHotEncoder(sparse_output=False)\n    transformer.fit(input_array)\n\n    results = transform_numpy(\n                  array             = input_array,\n                  transformer       = transformer,\n                  fit               = False,\n                  inverse_transform = False\n              )\n\n    expected = np.array(\n                   [[1., 0.],\n                    [1., 0.],\n                    [1., 0.],\n                    [1., 0.],\n                    [1., 0.],\n                    [0., 1.],\n                    [0., 1.],\n                    [0., 1.],\n                    [0., 1.],\n                    [0., 1.]]\n               )\n    \n    np.testing.assert_array_almost_equal(results, expected)\n\n\ndef test_transform_numpy_when_transformer_is_ColumnTransformer():\n    \"\"\"\n    Test the output of transform_numpy when transformer is ColumnTransformer.\n    \"\"\"\n    array = np.array([\n                [7.5, 'a'],\n                [24.4, 'a'],\n                [60.3, 'a'],\n                [57.3, 'a'],\n                [50.7, 'b'],\n                [41.4, 'b'],\n                [87.2, 'b'],\n                [47.4, 'b']\n            ], dtype=object)\n    transformer = ColumnTransformer(\n                      [('scale', StandardScaler(), [0]),\n                       ('onehot', OneHotEncoder(), [1])],\n                      remainder = 'passthrough',\n                      verbose_feature_names_out = False\n                  )\n    results = transform_numpy(\n                  array             = array,\n                  transformer       = transformer,\n                  fit               = True,\n                  inverse_transform = False\n              )\n    \n    expected = np.array([\n        [-1.76425513, 1., 0.],\n        [-1.00989936, 1., 0.],\n        [ 0.59254869, 1., 0.],\n        [ 0.45863938, 1., 0.],\n        [ 0.1640389 , 0., 1.],\n        [-0.25107995, 0., 1.],\n        [ 1.79326881, 0., 1.],\n        [ 0.01673866, 0., 1.]\n    ])\n    \n    np.testing.assert_array_almost_equal(results, expected)\n",
  "GT_file_code": {
    "skforecast/utils/utils.py": "################################################################################\n#                               skforecast.utils                               #\n#                                                                              #\n# This work by skforecast team is licensed under the BSD 3-Clause License.     #\n################################################################################\n# coding=utf-8\n\nimport importlib\nimport inspect\nimport warnings\nfrom copy import deepcopy\nfrom typing import Any, Callable, Optional, Tuple, Union\nfrom pathlib import Path\nimport joblib\nimport numpy as np\nimport pandas as pd\nimport sklearn.linear_model\nfrom sklearn.base import clone\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.exceptions import NotFittedError\nimport skforecast\nfrom ..exceptions import warn_skforecast_categories\nfrom ..exceptions import (\n    MissingValuesWarning,\n    MissingExogWarning,\n    DataTypeWarning,\n    UnknownLevelWarning,\n    IgnoredArgumentWarning,\n    SaveLoadSkforecastWarning,\n    SkforecastVersionWarning\n)\n\noptional_dependencies = {\n    'sarimax': [\n        'statsmodels>=0.12, <0.15'\n    ],\n    'deeplearning': [\n        'matplotlib>=3.3, <3.10',\n        'keras>=2.6, <4.0',\n    ],\n    'plotting': [\n        'matplotlib>=3.3, <3.10', \n        'seaborn>=0.11, <0.14', \n        'statsmodels>=0.12, <0.15'\n    ]\n}\n\n\ndef initialize_lags(\n    forecaster_name: str,\n    lags: Any\n) -> Union[Optional[np.ndarray], Optional[list], Optional[int]]:\n    \"\"\"\n    Check lags argument input and generate the corresponding numpy ndarray.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    lags : Any\n        Lags used as predictors.\n\n    Returns\n    -------\n    lags : numpy ndarray, None\n        Lags used as predictors.\n    lags_names : list, None\n        Names of the lags used as predictors.\n    max_lag : int, None\n        Maximum value of the lags.\n    \n    \"\"\"\n\n    lags_names = None\n    max_lag = None\n    if lags is not None:\n        if isinstance(lags, int):\n            if lags < 1:\n                raise ValueError(\"Minimum value of lags allowed is 1.\")\n            lags = np.arange(1, lags + 1)\n\n        if isinstance(lags, (list, tuple, range)):\n            lags = np.array(lags)\n        \n        if isinstance(lags, np.ndarray):\n            if lags.size == 0:\n                return None, None, None\n            if lags.ndim != 1:\n                raise ValueError(\"`lags` must be a 1-dimensional array.\")\n            if not np.issubdtype(lags.dtype, np.integer):\n                raise TypeError(\"All values in `lags` must be integers.\")\n            if np.any(lags < 1):\n                raise ValueError(\"Minimum value of lags allowed is 1.\")\n        else:\n            if forecaster_name != 'ForecasterDirectMultiVariate':\n                raise TypeError(\n                    (f\"`lags` argument must be an int, 1d numpy ndarray, range, \"\n                     f\"tuple or list. Got {type(lags)}.\")\n                )\n            else:\n                raise TypeError(\n                    (f\"`lags` argument must be a dict, int, 1d numpy ndarray, range, \"\n                     f\"tuple or list. Got {type(lags)}.\")\n                )\n        \n        lags_names = [f'lag_{i}' for i in lags]\n        max_lag = max(lags)\n\n    return lags, lags_names, max_lag\n\n\ndef initialize_window_features(\n    window_features: Any\n) -> Union[Optional[list], Optional[list], Optional[int]]:\n    \"\"\"\n    Check window_features argument input and generate the corresponding list.\n\n    Parameters\n    ----------\n    window_features : Any\n        Classes used to create window features.\n\n    Returns\n    -------\n    window_features : list, None\n        List of classes used to create window features.\n    window_features_names : list, None\n        List with all the features names of the window features.\n    max_size_window_features : int, None\n        Maximum value of the `window_sizes` attribute of all classes.\n    \n    \"\"\"\n\n    needed_atts = ['window_sizes', 'features_names']\n    needed_methods = ['transform_batch', 'transform']\n\n    max_window_sizes = None\n    window_features_names = None\n    max_size_window_features = None\n    if window_features is not None:\n        if isinstance(window_features, list) and len(window_features) < 1:\n            raise ValueError(\n                \"Argument `window_features` must contain at least one element.\"\n            )\n        if not isinstance(window_features, list):\n            window_features = [window_features]\n\n        link_to_docs = (\n            \"\\nVisit the documentation for more information about how to create \"\n            \"custom window features:\\n\"\n            \"https://skforecast.org/latest/user_guides/window-features-and-custom-features.html#create-your-custom-window-features\"\n        )\n        \n        max_window_sizes = []\n        window_features_names = []\n        for wf in window_features:\n            wf_name = type(wf).__name__\n            atts_methods = set([a for a in dir(wf)])\n            if not set(needed_atts).issubset(atts_methods):\n                raise ValueError(\n                    f\"{wf_name} must have the attributes: {needed_atts}.\" + link_to_docs\n                )\n            if not set(needed_methods).issubset(atts_methods):\n                raise ValueError(\n                    f\"{wf_name} must have the methods: {needed_methods}.\" + link_to_docs\n                )\n            \n            window_sizes = wf.window_sizes\n            if not isinstance(window_sizes, (int, list)):\n                raise TypeError(\n                    f\"Attribute `window_sizes` of {wf_name} must be an int or a list \"\n                    f\"of ints. Got {type(window_sizes)}.\" + link_to_docs\n                )\n            \n            if isinstance(window_sizes, int):\n                if window_sizes < 1:\n                    raise ValueError(\n                        f\"If argument `window_sizes` is an integer, it must be equal to or \"\n                        f\"greater than 1. Got {window_sizes} from {wf_name}.\" + link_to_docs\n                    )\n                max_window_sizes.append(window_sizes)\n            else:\n                if not all(isinstance(ws, int) for ws in window_sizes) or not all(\n                    ws >= 1 for ws in window_sizes\n                ):                    \n                    raise ValueError(\n                        f\"If argument `window_sizes` is a list, all elements must be integers \"\n                        f\"equal to or greater than 1. Got {window_sizes} from {wf_name}.\" + link_to_docs\n                    )\n                max_window_sizes.append(max(window_sizes))\n\n            features_names = wf.features_names\n            if not isinstance(features_names, (str, list)):\n                raise TypeError(\n                    f\"Attribute `features_names` of {wf_name} must be a str or \"\n                    f\"a list of strings. Got {type(features_names)}.\" + link_to_docs\n                )\n            if isinstance(features_names, str):\n                window_features_names.append(features_names)\n            else:\n                if not all(isinstance(fn, str) for fn in features_names):\n                    raise TypeError(\n                        f\"If argument `features_names` is a list, all elements \"\n                        f\"must be strings. Got {features_names} from {wf_name}.\" + link_to_docs\n                    )\n                window_features_names.extend(features_names)\n\n        max_size_window_features = max(max_window_sizes)\n        if len(set(window_features_names)) != len(window_features_names):\n            raise ValueError(\n                f\"All window features names must be unique. Got {window_features_names}.\"\n            )\n\n    return window_features, window_features_names, max_size_window_features\n\n\ndef initialize_weights(\n    forecaster_name: str,\n    regressor: object,\n    weight_func: Union[Callable, dict],\n    series_weights: dict\n) -> Tuple[Union[Callable, dict], Union[str, dict], dict]:\n    \"\"\"\n    Check weights arguments, `weight_func` and `series_weights` for the different \n    forecasters. Create `source_code_weight_func`, source code of the custom \n    function(s) used to create weights.\n    \n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    regressor : regressor or pipeline compatible with the scikit-learn API\n        Regressor of the forecaster.\n    weight_func : Callable, dict\n        Argument `weight_func` of the forecaster.\n    series_weights : dict\n        Argument `series_weights` of the forecaster.\n\n    Returns\n    -------\n    weight_func : Callable, dict\n        Argument `weight_func` of the forecaster.\n    source_code_weight_func : str, dict\n        Argument `source_code_weight_func` of the forecaster.\n    series_weights : dict\n        Argument `series_weights` of the forecaster.\n    \n    \"\"\"\n\n    source_code_weight_func = None\n\n    if weight_func is not None:\n\n        if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n            if not isinstance(weight_func, (Callable, dict)):\n                raise TypeError(\n                    (f\"Argument `weight_func` must be a Callable or a dict of \"\n                     f\"Callables. Got {type(weight_func)}.\")\n                )\n        elif not isinstance(weight_func, Callable):\n            raise TypeError(\n                f\"Argument `weight_func` must be a Callable. Got {type(weight_func)}.\"\n            )\n        \n        if isinstance(weight_func, dict):\n            source_code_weight_func = {}\n            for key in weight_func:\n                source_code_weight_func[key] = inspect.getsource(weight_func[key])\n        else:\n            source_code_weight_func = inspect.getsource(weight_func)\n\n        if 'sample_weight' not in inspect.signature(regressor.fit).parameters:\n            warnings.warn(\n                (f\"Argument `weight_func` is ignored since regressor {regressor} \"\n                 f\"does not accept `sample_weight` in its `fit` method.\"),\n                 IgnoredArgumentWarning\n            )\n            weight_func = None\n            source_code_weight_func = None\n\n    if series_weights is not None:\n        if not isinstance(series_weights, dict):\n            raise TypeError(\n                (f\"Argument `series_weights` must be a dict of floats or ints.\"\n                 f\"Got {type(series_weights)}.\")\n            )\n        if 'sample_weight' not in inspect.signature(regressor.fit).parameters:\n            warnings.warn(\n                (f\"Argument `series_weights` is ignored since regressor {regressor} \"\n                 f\"does not accept `sample_weight` in its `fit` method.\"),\n                 IgnoredArgumentWarning\n            )\n            series_weights = None\n\n    return weight_func, source_code_weight_func, series_weights\n\n\ndef initialize_transformer_series(\n    forecaster_name: str,\n    series_names_in_: list,\n    encoding: Optional[str] = None,\n    transformer_series: Optional[Union[object, dict]] = None\n) -> dict:\n    \"\"\"\n    Initialize `transformer_series_` attribute for the Forecasters Multiseries.\n\n    - If `transformer_series` is `None`, no transformation is applied.\n    - If `transformer_series` is a scikit-learn transformer (object), the same \n    transformer is applied to all series (`series_names_in_`).\n    - If `transformer_series` is a `dict`, a different transformer can be\n    applied to each series. The keys of the dictionary must be the same as the\n    names of the series in `series_names_in_`.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    series_names_in_ : list\n        Names of the series (levels) used during training.\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n    transformer_series : object, dict, default `None`\n        An instance of a transformer (preprocessor) compatible with the scikit-learn\n        preprocessing API with methods: fit, transform, fit_transform and \n        inverse_transform. \n\n    Returns\n    -------\n    transformer_series_ : dict\n        Dictionary with the transformer for each series. It is created cloning the \n        objects in `transformer_series` and is used internally to avoid overwriting.\n    \n    \"\"\"\n\n    multiseries_forecasters = [\n        'ForecasterRecursiveMultiSeries'\n    ]\n\n    if forecaster_name in multiseries_forecasters:\n        if encoding is None:\n            series_names_in_ = ['_unknown_level']\n        else:\n            series_names_in_ = series_names_in_ + ['_unknown_level']\n\n    if transformer_series is None:\n        transformer_series_ = {serie: None for serie in series_names_in_}\n    elif not isinstance(transformer_series, dict):\n        transformer_series_ = {serie: clone(transformer_series) \n                               for serie in series_names_in_}\n    else:\n        transformer_series_ = {serie: None for serie in series_names_in_}\n        # Only elements already present in transformer_series_ are updated\n        transformer_series_.update(\n            (k, v) for k, v in deepcopy(transformer_series).items() \n            if k in transformer_series_\n        )\n\n        series_not_in_transformer_series = (\n            set(series_names_in_) - set(transformer_series.keys())\n        ) - {'_unknown_level'}\n        if series_not_in_transformer_series:\n            warnings.warn(\n                (f\"{series_not_in_transformer_series} not present in `transformer_series`.\"\n                f\" No transformation is applied to these series.\"),\n                IgnoredArgumentWarning\n            )\n\n    return transformer_series_\n\n\ndef check_select_fit_kwargs(\n    regressor: object,\n    fit_kwargs: Optional[dict] = None\n) -> dict:\n    \"\"\"\n    Check if `fit_kwargs` is a dict and select only the keys that are used by\n    the `fit` method of the regressor.\n\n    Parameters\n    ----------\n    regressor : object\n        Regressor object.\n    fit_kwargs : dict, default `None`\n        Dictionary with the arguments to pass to the `fit' method of the forecaster.\n\n    Returns\n    -------\n    fit_kwargs : dict\n        Dictionary with the arguments to be passed to the `fit` method of the \n        regressor after removing the unused keys.\n    \n    \"\"\"\n\n    if fit_kwargs is None:\n        fit_kwargs = {}\n    else:\n        if not isinstance(fit_kwargs, dict):\n            raise TypeError(\n                f\"Argument `fit_kwargs` must be a dict. Got {type(fit_kwargs)}.\"\n            )\n\n        # Non used keys\n        non_used_keys = [k for k in fit_kwargs.keys()\n                         if k not in inspect.signature(regressor.fit).parameters]\n        if non_used_keys:\n            warnings.warn(\n                (f\"Argument/s {non_used_keys} ignored since they are not used by the \"\n                 f\"regressor's `fit` method.\"),\n                 IgnoredArgumentWarning\n            )\n\n        if 'sample_weight' in fit_kwargs.keys():\n            warnings.warn(\n                (\"The `sample_weight` argument is ignored. Use `weight_func` to pass \"\n                 \"a function that defines the individual weights for each sample \"\n                 \"based on its index.\"),\n                 IgnoredArgumentWarning\n            )\n            del fit_kwargs['sample_weight']\n\n        # Select only the keyword arguments allowed by the regressor's `fit` method.\n        fit_kwargs = {k: v for k, v in fit_kwargs.items()\n                      if k in inspect.signature(regressor.fit).parameters}\n\n    return fit_kwargs\n\n\ndef check_y(\n    y: Any,\n    series_id: str = \"`y`\"\n) -> None:\n    \"\"\"\n    Raise Exception if `y` is not pandas Series or if it has missing values.\n    \n    Parameters\n    ----------\n    y : Any\n        Time series values.\n    series_id : str, default '`y`'\n        Identifier of the series used in the warning message.\n    \n    Returns\n    -------\n    None\n    \n    \"\"\"\n    \n    if not isinstance(y, pd.Series):\n        raise TypeError(f\"{series_id} must be a pandas Series.\")\n        \n    if y.isnull().any():\n        raise ValueError(f\"{series_id} has missing values.\")\n    \n    return\n\n\ndef check_exog(\n    exog: Union[pd.Series, pd.DataFrame],\n    allow_nan: bool = True,\n    series_id: str = \"`exog`\"\n) -> None:\n    \"\"\"\n    Raise Exception if `exog` is not pandas Series or pandas DataFrame.\n    If `allow_nan = True`, issue a warning if `exog` contains NaN values.\n    \n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n    allow_nan : bool, default `True`\n        If True, allows the presence of NaN values in `exog`. If False (default),\n        issue a warning if `exog` contains NaN values.\n    series_id : str, default '`exog`'\n        Identifier of the series for which the exogenous variable/s are used\n        in the warning message.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    \n    if not isinstance(exog, (pd.Series, pd.DataFrame)):\n        raise TypeError(\n            f\"{series_id} must be a pandas Series or DataFrame. Got {type(exog)}.\"\n        )\n    \n    if isinstance(exog, pd.Series) and exog.name is None:\n        raise ValueError(f\"When {series_id} is a pandas Series, it must have a name.\")\n\n    if not allow_nan:\n        if exog.isnull().any().any():\n            warnings.warn(\n                (f\"{series_id} has missing values. Most machine learning models \"\n                 f\"do not allow missing values. Fitting the forecaster may fail.\"), \n                 MissingValuesWarning\n            )\n    \n    return\n\n\ndef get_exog_dtypes(\n    exog: Union[pd.DataFrame, pd.Series]\n) -> dict:\n    \"\"\"\n    Store dtypes of `exog`.\n\n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n\n    Returns\n    -------\n    exog_dtypes : dict\n        Dictionary with the dtypes in `exog`.\n    \n    \"\"\"\n\n    if isinstance(exog, pd.Series):\n        exog_dtypes = {exog.name: exog.dtypes}\n    else:\n        exog_dtypes = exog.dtypes.to_dict()\n    \n    return exog_dtypes\n\n\ndef check_exog_dtypes(\n    exog: Union[pd.DataFrame, pd.Series],\n    call_check_exog: bool = True,\n    series_id: str = \"`exog`\"\n) -> None:\n    \"\"\"\n    Raise Exception if `exog` has categorical columns with non integer values.\n    This is needed when using machine learning regressors that allow categorical\n    features.\n    Issue a Warning if `exog` has columns that are not `init`, `float`, or `category`.\n    \n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n    call_check_exog : bool, default `True`\n        If `True`, call `check_exog` function.\n    series_id : str, default '`exog`'\n        Identifier of the series for which the exogenous variable/s are used\n        in the warning message.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    if call_check_exog:\n        check_exog(exog=exog, allow_nan=False, series_id=series_id)\n\n    if isinstance(exog, pd.DataFrame):\n        if not exog.select_dtypes(exclude=[np.number, 'category']).columns.empty:\n            warnings.warn(\n                (f\"{series_id} may contain only `int`, `float` or `category` dtypes. \"\n                 f\"Most machine learning models do not allow other types of values. \"\n                 f\"Fitting the forecaster may fail.\"), \n                 DataTypeWarning\n            )\n        for col in exog.select_dtypes(include='category'):\n            if exog[col].cat.categories.dtype not in [int, np.int32, np.int64]:\n                raise TypeError(\n                    (\"Categorical dtypes in exog must contain only integer values. \"\n                     \"See skforecast docs for more info about how to include \"\n                     \"categorical features https://skforecast.org/\"\n                     \"latest/user_guides/categorical-features.html\")\n                )\n    else:\n        if exog.dtype.name not in ['int', 'int8', 'int16', 'int32', 'int64', 'float', \n        'float16', 'float32', 'float64', 'uint8', 'uint16', 'uint32', 'uint64', 'category']:\n            warnings.warn(\n                (f\"{series_id} may contain only `int`, `float` or `category` dtypes. Most \"\n                 f\"machine learning models do not allow other types of values. \"\n                 f\"Fitting the forecaster may fail.\"), \n                 DataTypeWarning\n            )\n        if exog.dtype.name == 'category' and exog.cat.categories.dtype not in [int,\n        np.int32, np.int64]:\n            raise TypeError(\n                (\"Categorical dtypes in exog must contain only integer values. \"\n                 \"See skforecast docs for more info about how to include \"\n                 \"categorical features https://skforecast.org/\"\n                 \"latest/user_guides/categorical-features.html\")\n            )\n         \n    return\n\n\ndef check_interval(\n    interval: list = None,\n    quantiles: float = None,\n    alpha: float = None\n) -> None:\n    \"\"\"\n    Check provided confidence interval sequence is valid.\n\n    Parameters\n    ----------\n    interval : list, default `None`\n        Confidence of the prediction interval estimated. Sequence of percentiles\n        to compute, which must be between 0 and 100 inclusive. For example, \n        interval of 95% should be as `interval = [2.5, 97.5]`.\n    quantiles : list, default `None`\n        Sequence of quantiles to compute, which must be between 0 and 1 \n        inclusive. For example, quantiles of 0.05, 0.5 and 0.95 should be as \n        `quantiles = [0.05, 0.5, 0.95]`.\n    alpha : float, default `None`\n        The confidence intervals used in ForecasterSarimax are (1 - alpha) %.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n\n    if interval is not None:\n        if not isinstance(interval, list):\n            raise TypeError(\n                (\"`interval` must be a `list`. For example, interval of 95% \"\n                 \"should be as `interval = [2.5, 97.5]`.\")\n            )\n\n        if len(interval) != 2:\n            raise ValueError(\n                (\"`interval` must contain exactly 2 values, respectively the \"\n                 \"lower and upper interval bounds. For example, interval of 95% \"\n                 \"should be as `interval = [2.5, 97.5]`.\")\n            )\n\n        if (interval[0] < 0.) or (interval[0] >= 100.):\n            raise ValueError(\n                f\"Lower interval bound ({interval[0]}) must be >= 0 and < 100.\"\n            )\n\n        if (interval[1] <= 0.) or (interval[1] > 100.):\n            raise ValueError(\n                f\"Upper interval bound ({interval[1]}) must be > 0 and <= 100.\"\n            )\n\n        if interval[0] >= interval[1]:\n            raise ValueError(\n                (f\"Lower interval bound ({interval[0]}) must be less than the \"\n                 f\"upper interval bound ({interval[1]}).\")\n            )\n        \n    if quantiles is not None:\n        if not isinstance(quantiles, list):\n            raise TypeError(\n                (\"`quantiles` must be a `list`. For example, quantiles 0.05, \"\n                 \"0.5, and 0.95 should be as `quantiles = [0.05, 0.5, 0.95]`.\")\n            )\n        \n        for q in quantiles:\n            if (q < 0.) or (q > 1.):\n                raise ValueError(\n                    (\"All elements in `quantiles` must be >= 0 and <= 1.\")\n                )\n    \n    if alpha is not None:\n        if not isinstance(alpha, float):\n            raise TypeError(\n                (\"`alpha` must be a `float`. For example, interval of 95% \"\n                 \"should be as `alpha = 0.05`.\")\n            )\n\n        if (alpha <= 0.) or (alpha >= 1):\n            raise ValueError(\n                f\"`alpha` must have a value between 0 and 1. Got {alpha}.\"\n            )\n\n    return\n\n\ndef check_predict_input(\n    forecaster_name: str,\n    steps: Union[int, list],\n    is_fitted: bool,\n    exog_in_: bool,\n    index_type_: type,\n    index_freq_: str,\n    window_size: int,\n    last_window: Union[pd.Series, pd.DataFrame, None],\n    last_window_exog: Optional[Union[pd.Series, pd.DataFrame]] = None,\n    exog: Optional[Union[pd.Series, pd.DataFrame]] = None,\n    exog_type_in_: Optional[type] = None,\n    exog_names_in_: Optional[list] = None,\n    interval: Optional[list] = None,\n    alpha: Optional[float] = None,\n    max_steps: Optional[int] = None,\n    levels: Optional[Union[str, list]] = None,\n    levels_forecaster: Optional[Union[str, list]] = None,\n    series_names_in_: Optional[list] = None,\n    encoding: Optional[str] = None\n) -> None:\n    \"\"\"\n    Check all inputs of predict method. This is a helper function to validate\n    that inputs used in predict method match attributes of a forecaster already\n    trained.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    steps : int, list\n        Number of future steps predicted.\n    is_fitted: bool\n        Tag to identify if the regressor has been fitted (trained).\n    exog_in_ : bool\n        If the forecaster has been trained using exogenous variable/s.\n    index_type_ : type\n        Type of index of the input used in training.\n    index_freq_ : str\n        Frequency of Index of the input used in training.\n    window_size: int\n        Size of the window needed to create the predictors. It is equal to \n        `max_lag`.\n    last_window : pandas Series, pandas DataFrame, None\n        Values of the series used to create the predictors (lags) need in the \n        first iteration of prediction (t + 1).\n    last_window_exog : pandas Series, pandas DataFrame, default `None`\n        Values of the exogenous variables aligned with `last_window` in \n        ForecasterSarimax predictions.\n    exog : pandas Series, pandas DataFrame, default `None`\n        Exogenous variable/s included as predictor/s.\n    exog_type_in_ : type, default `None`\n        Type of exogenous variable/s used in training.\n    exog_names_in_ : list, default `None`\n        Names of the exogenous variables used during training.\n    interval : list, default `None`\n        Confidence of the prediction interval estimated. Sequence of percentiles\n        to compute, which must be between 0 and 100 inclusive. For example, \n        interval of 95% should be as `interval = [2.5, 97.5]`.\n    alpha : float, default `None`\n        The confidence intervals used in ForecasterSarimax are (1 - alpha) %.\n    max_steps: int, default `None`\n        Maximum number of steps allowed (`ForecasterDirect` and \n        `ForecasterDirectMultiVariate`).\n    levels : str, list, default `None`\n        Time series to be predicted (`ForecasterRecursiveMultiSeries`\n        and `ForecasterRnn).\n    levels_forecaster : str, list, default `None`\n        Time series used as output data of a multiseries problem in a RNN problem\n        (`ForecasterRnn`).\n    series_names_in_ : list, default `None`\n        Names of the columns used during fit (`ForecasterRecursiveMultiSeries`, \n        `ForecasterDirectMultiVariate` and `ForecasterRnn`).\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    if not is_fitted:\n        raise NotFittedError(\n            (\"This Forecaster instance is not fitted yet. Call `fit` with \"\n             \"appropriate arguments before using predict.\")\n        )\n\n    if isinstance(steps, (int, np.integer)) and steps < 1:\n        raise ValueError(\n            f\"`steps` must be an integer greater than or equal to 1. Got {steps}.\"\n        )\n\n    if isinstance(steps, list) and min(steps) < 1:\n        raise ValueError(\n           (f\"The minimum value of `steps` must be equal to or greater than 1. \"\n            f\"Got {min(steps)}.\")\n        )\n\n    if max_steps is not None:\n        if max(steps) > max_steps:\n            raise ValueError(\n                (f\"The maximum value of `steps` must be less than or equal to \"\n                 f\"the value of steps defined when initializing the forecaster. \"\n                 f\"Got {max(steps)}, but the maximum is {max_steps}.\")\n            )\n\n    if interval is not None or alpha is not None:\n        check_interval(interval=interval, alpha=alpha)\n\n    if forecaster_name in ['ForecasterRecursiveMultiSeries', \n                           'ForecasterRnn']:\n        if not isinstance(levels, (type(None), str, list)):\n            raise TypeError(\n                (\"`levels` must be a `list` of column names, a `str` of a \"\n                 \"column name or `None`.\")\n            )\n\n        levels_to_check = (\n            levels_forecaster if forecaster_name == 'ForecasterRnn'\n            else series_names_in_\n        )\n        unknown_levels = set(levels) - set(levels_to_check)\n        if forecaster_name == 'ForecasterRnn':\n            if len(unknown_levels) != 0:\n                raise ValueError(\n                    (f\"`levels` names must be included in the series used during fit \"\n                     f\"({levels_to_check}). Got {levels}.\")\n                )\n        else:\n            if len(unknown_levels) != 0 and last_window is not None and encoding is not None:\n                if encoding == 'onehot':\n                    warnings.warn(\n                        (f\"`levels` {unknown_levels} were not included in training. The resulting \"\n                         f\"one-hot encoded columns for this feature will be all zeros.\"),\n                         UnknownLevelWarning\n                    )\n                else:\n                    warnings.warn(\n                        (f\"`levels` {unknown_levels} were not included in training. \"\n                         f\"Unknown levels are encoded as NaN, which may cause the \"\n                         f\"prediction to fail if the regressor does not accept NaN values.\"),\n                         UnknownLevelWarning\n                    )\n\n    if exog is None and exog_in_:\n        raise ValueError(\n            (\"Forecaster trained with exogenous variable/s. \"\n             \"Same variable/s must be provided when predicting.\")\n        )\n\n    if exog is not None and not exog_in_:\n        raise ValueError(\n            (\"Forecaster trained without exogenous variable/s. \"\n             \"`exog` must be `None` when predicting.\")\n        )\n\n    # Checks last_window\n    # Check last_window type (pd.Series or pd.DataFrame according to forecaster)\n    if isinstance(last_window, type(None)) and forecaster_name not in [\n        'ForecasterRecursiveMultiSeries', \n        'ForecasterRnn'\n    ]:\n        raise ValueError(\n            (\"`last_window` was not stored during training. If you don't want \"\n             \"to retrain the Forecaster, provide `last_window` as argument.\")\n        )\n\n    if forecaster_name in ['ForecasterRecursiveMultiSeries', \n                           'ForecasterDirectMultiVariate',\n                           'ForecasterRnn']:\n        if not isinstance(last_window, pd.DataFrame):\n            raise TypeError(\n                f\"`last_window` must be a pandas DataFrame. Got {type(last_window)}.\"\n            )\n\n        last_window_cols = last_window.columns.to_list()\n\n        if forecaster_name in ['ForecasterRecursiveMultiSeries', \n                               'ForecasterRnn'] and \\\n            len(set(levels) - set(last_window_cols)) != 0:\n            raise ValueError(\n                (f\"`last_window` must contain a column(s) named as the level(s) \"\n                 f\"to be predicted.\\n\"\n                 f\"    `levels` : {levels}\\n\"\n                 f\"    `last_window` columns : {last_window_cols}\")\n            )\n\n        if forecaster_name == 'ForecasterDirectMultiVariate':\n            if len(set(series_names_in_) - set(last_window_cols)) > 0:\n                raise ValueError(\n                    (f\"`last_window` columns must be the same as the `series` \"\n                     f\"column names used to create the X_train matrix.\\n\"\n                     f\"    `last_window` columns    : {last_window_cols}\\n\"\n                     f\"    `series` columns X train : {series_names_in_}\")\n                )\n    else:\n        if not isinstance(last_window, (pd.Series, pd.DataFrame)):\n            raise TypeError(\n                f\"`last_window` must be a pandas Series or DataFrame. \"\n                f\"Got {type(last_window)}.\"\n            )\n\n    # Check last_window len, nulls and index (type and freq)\n    if len(last_window) < window_size:\n        raise ValueError(\n            (f\"`last_window` must have as many values as needed to \"\n             f\"generate the predictors. For this forecaster it is {window_size}.\")\n        )\n    if last_window.isnull().any().all():\n        warnings.warn(\n            (\"`last_window` has missing values. Most of machine learning models do \"\n             \"not allow missing values. Prediction method may fail.\"), \n             MissingValuesWarning\n        )\n    _, last_window_index = preprocess_last_window(\n                               last_window   = last_window.iloc[:0],\n                               return_values = False\n                           ) \n    if not isinstance(last_window_index, index_type_):\n        raise TypeError(\n            (f\"Expected index of type {index_type_} for `last_window`. \"\n             f\"Got {type(last_window_index)}.\")\n        )\n    if isinstance(last_window_index, pd.DatetimeIndex):\n        if not last_window_index.freqstr == index_freq_:\n            raise TypeError(\n                (f\"Expected frequency of type {index_freq_} for `last_window`. \"\n                 f\"Got {last_window_index.freqstr}.\")\n            )\n\n    # Checks exog\n    if exog is not None:\n\n        # Check type, nulls and expected type\n        if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n            if not isinstance(exog, (pd.Series, pd.DataFrame, dict)):\n                raise TypeError(\n                    f\"`exog` must be a pandas Series, DataFrame or dict. Got {type(exog)}.\"\n                )\n            if exog_type_in_ == dict and not isinstance(exog, dict):\n                raise TypeError(\n                    f\"Expected type for `exog`: {exog_type_in_}. Got {type(exog)}.\"\n                )\n        else:\n            if not isinstance(exog, (pd.Series, pd.DataFrame)):\n                raise TypeError(\n                    f\"`exog` must be a pandas Series or DataFrame. Got {type(exog)}.\"\n                )\n\n        if isinstance(exog, dict):\n            no_exog_levels = set(levels) - set(exog.keys())\n            if no_exog_levels:\n                warnings.warn(\n                    (f\"`exog` does not contain keys for levels {no_exog_levels}. \"\n                     f\"Missing levels are filled with NaN. Most of machine learning \"\n                     f\"models do not allow missing values. Prediction method may fail.\"),\n                     MissingExogWarning\n                )\n            exogs_to_check = [\n                (f\"`exog` for series '{k}'\", v) \n                for k, v in exog.items() \n                if v is not None and k in levels\n            ]\n        else:\n            exogs_to_check = [('`exog`', exog)]\n\n        for exog_name, exog_to_check in exogs_to_check:\n\n            if not isinstance(exog_to_check, (pd.Series, pd.DataFrame)):\n                raise TypeError(\n                    f\"{exog_name} must be a pandas Series or DataFrame. Got {type(exog_to_check)}\"\n                )\n\n            if exog_to_check.isnull().any().any():\n                warnings.warn(\n                    (f\"{exog_name} has missing values. Most of machine learning models \"\n                     f\"do not allow missing values. Prediction method may fail.\"), \n                     MissingValuesWarning\n                )\n\n            # Check exog has many values as distance to max step predicted\n            last_step = max(steps) if isinstance(steps, list) else steps\n            if len(exog_to_check) < last_step:\n                if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                    warnings.warn(\n                        (f\"{exog_name} doesn't have as many values as steps \"\n                         f\"predicted, {last_step}. Missing values are filled \"\n                         f\"with NaN. Most of machine learning models do not \"\n                         f\"allow missing values. Prediction method may fail.\"),\n                         MissingValuesWarning\n                    )\n                else: \n                    raise ValueError(\n                        (f\"{exog_name} must have at least as many values as \"\n                         f\"steps predicted, {last_step}.\")\n                    )\n\n            # Check name/columns are in exog_names_in_\n            if isinstance(exog_to_check, pd.DataFrame):\n                col_missing = set(exog_names_in_).difference(set(exog_to_check.columns))\n                if col_missing:\n                    if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                        warnings.warn(\n                            (f\"{col_missing} not present in {exog_name}. All \"\n                             f\"values will be NaN.\"),\n                             MissingExogWarning\n                        ) \n                    else:\n                        raise ValueError(\n                            (f\"Missing columns in {exog_name}. Expected {exog_names_in_}. \"\n                             f\"Got {exog_to_check.columns.to_list()}.\")\n                        )\n            else:\n                if exog_to_check.name is None:\n                    raise ValueError(\n                        (f\"When {exog_name} is a pandas Series, it must have a name. Got None.\")\n                    )\n\n                if exog_to_check.name not in exog_names_in_:\n                    if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                        warnings.warn(\n                            (f\"'{exog_to_check.name}' was not observed during training. \"\n                             f\"{exog_name} is ignored. Exogenous variables must be one \"\n                             f\"of: {exog_names_in_}.\"),\n                             IgnoredArgumentWarning\n                        )\n                    else:\n                        raise ValueError(\n                            (f\"'{exog_to_check.name}' was not observed during training. \"\n                             f\"Exogenous variables must be: {exog_names_in_}.\")\n                        )\n\n            # Check index dtype and freq\n            _, exog_index = preprocess_exog(\n                                exog          = exog_to_check.iloc[:0, ],\n                                return_values = False\n                            )\n            if not isinstance(exog_index, index_type_):\n                raise TypeError(\n                    (f\"Expected index of type {index_type_} for {exog_name}. \"\n                     f\"Got {type(exog_index)}.\")\n                )\n            if forecaster_name not in ['ForecasterRecursiveMultiSeries']:\n                if isinstance(exog_index, pd.DatetimeIndex):\n                    if not exog_index.freqstr == index_freq_:\n                        raise TypeError(\n                            (f\"Expected frequency of type {index_freq_} for {exog_name}. \"\n                             f\"Got {exog_index.freqstr}.\")\n                        )\n\n            # Check exog starts one step ahead of last_window end.\n            expected_index = expand_index(last_window.index, 1)[0]\n            if expected_index != exog_to_check.index[0]:\n                if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                    warnings.warn(\n                        (f\"To make predictions {exog_name} must start one step \"\n                         f\"ahead of `last_window`. Missing values are filled \"\n                         f\"with NaN.\\n\"\n                         f\"    `last_window` ends at : {last_window.index[-1]}.\\n\"\n                         f\"    {exog_name} starts at : {exog_to_check.index[0]}.\\n\"\n                         f\"     Expected index       : {expected_index}.\"),\n                         MissingValuesWarning\n                    )  \n                else:\n                    raise ValueError(\n                        (f\"To make predictions {exog_name} must start one step \"\n                         f\"ahead of `last_window`.\\n\"\n                         f\"    `last_window` ends at : {last_window.index[-1]}.\\n\"\n                         f\"    {exog_name} starts at : {exog_to_check.index[0]}.\\n\"\n                         f\"     Expected index : {expected_index}.\")\n                    )\n\n    # Checks ForecasterSarimax\n    if forecaster_name == 'ForecasterSarimax':\n        # Check last_window_exog type, len, nulls and index (type and freq)\n        if last_window_exog is not None:\n            if not exog_in_:\n                raise ValueError(\n                    (\"Forecaster trained without exogenous variable/s. \"\n                     \"`last_window_exog` must be `None` when predicting.\")\n                )\n\n            if not isinstance(last_window_exog, (pd.Series, pd.DataFrame)):\n                raise TypeError(\n                    (f\"`last_window_exog` must be a pandas Series or a \"\n                     f\"pandas DataFrame. Got {type(last_window_exog)}.\")\n                )\n            if len(last_window_exog) < window_size:\n                raise ValueError(\n                    (f\"`last_window_exog` must have as many values as needed to \"\n                     f\"generate the predictors. For this forecaster it is {window_size}.\")\n                )\n            if last_window_exog.isnull().any().all():\n                warnings.warn(\n                    (\"`last_window_exog` has missing values. Most of machine learning \"\n                     \"models do not allow missing values. Prediction method may fail.\"),\n                     MissingValuesWarning\n            )\n            _, last_window_exog_index = preprocess_last_window(\n                                            last_window   = last_window_exog.iloc[:0],\n                                            return_values = False\n                                        ) \n            if not isinstance(last_window_exog_index, index_type_):\n                raise TypeError(\n                    (f\"Expected index of type {index_type_} for `last_window_exog`. \"\n                     f\"Got {type(last_window_exog_index)}.\")\n                )\n            if isinstance(last_window_exog_index, pd.DatetimeIndex):\n                if not last_window_exog_index.freqstr == index_freq_:\n                    raise TypeError(\n                        (f\"Expected frequency of type {index_freq_} for \"\n                         f\"`last_window_exog`. Got {last_window_exog_index.freqstr}.\")\n                    )\n\n            # Check all columns are in the pd.DataFrame, last_window_exog\n            if isinstance(last_window_exog, pd.DataFrame):\n                col_missing = set(exog_names_in_).difference(set(last_window_exog.columns))\n                if col_missing:\n                    raise ValueError(\n                        (f\"Missing columns in `last_window_exog`. Expected {exog_names_in_}. \"\n                         f\"Got {last_window_exog.columns.to_list()}.\") \n                    )\n            else:\n                if last_window_exog.name is None:\n                    raise ValueError(\n                        (\"When `last_window_exog` is a pandas Series, it must have a \"\n                         \"name. Got None.\")\n                    )\n\n                if last_window_exog.name not in exog_names_in_:\n                    raise ValueError(\n                        (f\"'{last_window_exog.name}' was not observed during training. \"\n                         f\"Exogenous variables must be: {exog_names_in_}.\")\n                    )\n\n    return\n\n\ndef preprocess_y(\n    y: Union[pd.Series, pd.DataFrame],\n    return_values: bool = True\n) -> Tuple[Union[None, np.ndarray], pd.Index]:\n    \"\"\"\n    Return values and index of series separately. Index is overwritten \n    according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n    \n    Parameters\n    ----------\n    y : pandas Series, pandas DataFrame\n        Time series.\n    return_values : bool, default `True`\n        If `True` return the values of `y` as numpy ndarray. This option is \n        intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    y_values : None, numpy ndarray\n        Numpy array with values of `y`.\n    y_index : pandas Index\n        Index of `y` modified according to the rules.\n    \n    \"\"\"\n    \n    if isinstance(y.index, pd.DatetimeIndex) and y.index.freq is not None:\n        y_index = y.index\n    elif isinstance(y.index, pd.RangeIndex):\n        y_index = y.index\n    elif isinstance(y.index, pd.DatetimeIndex) and y.index.freq is None:\n        warnings.warn(\n            (\"Series has DatetimeIndex index but no frequency. \"\n             \"Index is overwritten with a RangeIndex of step 1.\")\n        )\n        y_index = pd.RangeIndex(\n                      start = 0,\n                      stop  = len(y),\n                      step  = 1\n                  )\n    else:\n        warnings.warn(\n            (\"Series has no DatetimeIndex nor RangeIndex index. \"\n             \"Index is overwritten with a RangeIndex.\")\n        )\n        y_index = pd.RangeIndex(\n                      start = 0,\n                      stop  = len(y),\n                      step  = 1\n                  )\n\n    y_values = y.to_numpy(copy=True).ravel() if return_values else None\n\n    return y_values, y_index\n\n\ndef preprocess_last_window(\n    last_window: Union[pd.Series, pd.DataFrame],\n    return_values: bool = True\n ) -> Tuple[np.ndarray, pd.Index]:\n    \"\"\"\n    Return values and index of series separately. Index is overwritten \n    according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n    \n    Parameters\n    ----------\n    last_window : pandas Series, pandas DataFrame\n        Time series values.\n    return_values : bool, default `True`\n        If `True` return the values of `last_window` as numpy ndarray. This option \n        is intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    last_window_values : numpy ndarray\n        Numpy array with values of `last_window`.\n    last_window_index : pandas Index\n        Index of `last_window` modified according to the rules.\n    \n    \"\"\"\n    \n    if isinstance(last_window.index, pd.DatetimeIndex) and last_window.index.freq is not None:\n        last_window_index = last_window.index\n    elif isinstance(last_window.index, pd.RangeIndex):\n        last_window_index = last_window.index\n    elif isinstance(last_window.index, pd.DatetimeIndex) and last_window.index.freq is None:\n        warnings.warn(\n            (\"`last_window` has DatetimeIndex index but no frequency. \"\n             \"Index is overwritten with a RangeIndex of step 1.\")\n        )\n        last_window_index = pd.RangeIndex(\n                                start = 0,\n                                stop  = len(last_window),\n                                step  = 1\n                            )\n    else:\n        warnings.warn(\n            (\"`last_window` has no DatetimeIndex nor RangeIndex index. \"\n             \"Index is overwritten with a RangeIndex.\")\n        )\n        last_window_index = pd.RangeIndex(\n                                start = 0,\n                                stop  = len(last_window),\n                                step  = 1\n                            )\n\n    last_window_values = last_window.to_numpy(copy=True).ravel() if return_values else None\n\n    return last_window_values, last_window_index\n\n\ndef preprocess_exog(\n    exog: Union[pd.Series, pd.DataFrame],\n    return_values: bool = True\n) -> Tuple[Union[None, np.ndarray], pd.Index]:\n    \"\"\"\n    Return values and index of series or data frame separately. Index is\n    overwritten  according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n\n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    return_values : bool, default `True`\n        If `True` return the values of `exog` as numpy ndarray. This option is \n        intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    exog_values : None, numpy ndarray\n        Numpy array with values of `exog`.\n    exog_index : pandas Index\n        Index of `exog` modified according to the rules.\n    \n    \"\"\"\n    \n    if isinstance(exog.index, pd.DatetimeIndex) and exog.index.freq is not None:\n        exog_index = exog.index\n    elif isinstance(exog.index, pd.RangeIndex):\n        exog_index = exog.index\n    elif isinstance(exog.index, pd.DatetimeIndex) and exog.index.freq is None:\n        warnings.warn(\n            (\"`exog` has DatetimeIndex index but no frequency. \"\n             \"Index is overwritten with a RangeIndex of step 1.\")\n        )\n        exog_index = pd.RangeIndex(\n                         start = 0,\n                         stop  = len(exog),\n                         step  = 1\n                     )\n\n    else:\n        warnings.warn(\n            (\"`exog` has no DatetimeIndex nor RangeIndex index. \"\n             \"Index is overwritten with a RangeIndex.\")\n        )\n        exog_index = pd.RangeIndex(\n                         start = 0,\n                         stop  = len(exog),\n                         step  = 1\n                     )\n\n    exog_values = exog.to_numpy(copy=True) if return_values else None\n\n    return exog_values, exog_index\n\n\ndef input_to_frame(\n    data: Union[pd.Series, pd.DataFrame],\n    input_name: str\n) -> pd.DataFrame:\n    \"\"\"\n    Convert data to a pandas DataFrame. If data is a pandas Series, it is \n    converted to a DataFrame with a single column. If data is a DataFrame, \n    it is returned as is.\n\n    Parameters\n    ----------\n    data : pandas Series, pandas DataFrame\n        Input data.\n    input_name : str\n        Name of the input data. Accepted values are 'y', 'last_window' and 'exog'.\n\n    Returns\n    -------\n    data : pandas DataFrame\n        Input data as a DataFrame.\n\n    \"\"\"\n\n    output_col_name = {\n        'y': 'y',\n        'last_window': 'y',\n        'exog': 'exog'\n    }\n\n    if isinstance(data, pd.Series):\n        data = data.to_frame(\n            name=data.name if data.name is not None else output_col_name[input_name]\n        )\n\n    return data\n\n\ndef cast_exog_dtypes(\n    exog: Union[pd.Series, pd.DataFrame],\n    exog_dtypes: dict,\n) -> Union[pd.Series, pd.DataFrame]:  # pragma: no cover\n    \"\"\"\n    Cast `exog` to a specified types. This is done because, for a forecaster to \n    accept a categorical exog, it must contain only integer values. Due to the \n    internal modifications of numpy, the values may be casted to `float`, so \n    they have to be re-converted to `int`.\n\n    - If `exog` is a pandas Series, `exog_dtypes` must be a dict with a \n    single value.\n    - If `exog_dtypes` is `category` but the current type of `exog` is `float`, \n    then the type is cast to `int` and then to `category`. \n\n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    exog_dtypes: dict\n        Dictionary with name and type of the series or data frame columns.\n\n    Returns\n    -------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables casted to the indicated dtypes.\n\n    \"\"\"\n\n    # Remove keys from exog_dtypes not in exog.columns\n    exog_dtypes = {k: v for k, v in exog_dtypes.items() if k in exog.columns}\n    \n    if isinstance(exog, pd.Series) and exog.dtypes != list(exog_dtypes.values())[0]:\n        exog = exog.astype(list(exog_dtypes.values())[0])\n    elif isinstance(exog, pd.DataFrame):\n        for col, initial_dtype in exog_dtypes.items():\n            if exog[col].dtypes != initial_dtype:\n                if initial_dtype == \"category\" and exog[col].dtypes == float:\n                    exog[col] = exog[col].astype(int).astype(\"category\")\n                else:\n                    exog[col] = exog[col].astype(initial_dtype)\n\n    return exog\n\n\ndef exog_to_direct(\n    exog: Union[pd.Series, pd.DataFrame],\n    steps: int\n) -> Union[pd.DataFrame, list]:\n    \"\"\"\n    Transforms `exog` to a pandas DataFrame with the shape needed for Direct\n    forecasting.\n    \n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    steps : int\n        Number of steps that will be predicted using exog.\n\n    Returns\n    -------\n    exog_direct : pandas DataFrame\n        Exogenous variables transformed.\n    exog_direct_names : list\n        Names of the columns of the exogenous variables transformed. Only \n        created if `exog` is a pandas Series or DataFrame.\n    \n    \"\"\"\n\n    if not isinstance(exog, (pd.Series, pd.DataFrame)):\n        raise TypeError(f\"`exog` must be a pandas Series or DataFrame. Got {type(exog)}.\")\n\n    if isinstance(exog, pd.Series):\n        exog = exog.to_frame()\n\n    n_rows = len(exog)\n    exog_idx = exog.index\n    exog_cols = exog.columns\n    exog_direct = []\n    for i in range(steps):\n        exog_step = exog.iloc[i : n_rows - (steps - 1 - i), ]\n        exog_step.index = pd.RangeIndex(len(exog_step))\n        exog_step.columns = [f\"{col}_step_{i + 1}\" for col in exog_cols]\n        exog_direct.append(exog_step)\n\n    if len(exog_direct) > 1:\n        exog_direct = pd.concat(exog_direct, axis=1, copy=False)\n    else:\n        exog_direct = exog_direct[0]\n\n    exog_direct_names = exog_direct.columns.to_list()\n    exog_direct.index = exog_idx[-len(exog_direct):]\n    \n    return exog_direct, exog_direct_names\n\n\ndef exog_to_direct_numpy(\n    exog: Union[np.ndarray, pd.Series, pd.DataFrame],\n    steps: int\n) -> Tuple[np.ndarray, Optional[list]]:\n    \"\"\"\n    Transforms `exog` to numpy ndarray with the shape needed for Direct\n    forecasting.\n    \n    Parameters\n    ----------\n    exog : numpy ndarray, pandas Series, pandas DataFrame\n        Exogenous variables, shape(samples,). If exog is a pandas format, the \n        direct exog names are created.\n    steps : int\n        Number of steps that will be predicted using exog.\n\n    Returns\n    -------\n    exog_direct : numpy ndarray\n        Exogenous variables transformed.\n    exog_direct_names : list, None\n        Names of the columns of the exogenous variables transformed. Only \n        created if `exog` is a pandas Series or DataFrame.\n\n    \"\"\"\n\n    if isinstance(exog, (pd.Series, pd.DataFrame)):\n        exog_cols = exog.columns if isinstance(exog, pd.DataFrame) else [exog.name]\n        exog_direct_names = [\n            f\"{col}_step_{i + 1}\" for i in range(steps) for col in exog_cols\n        ]\n        exog = exog.to_numpy()\n    else:\n        exog_direct_names = None\n        if not isinstance(exog, np.ndarray):\n            raise TypeError(\n                f\"`exog` must be a numpy ndarray, pandas Series or DataFrame. \"\n                f\"Got {type(exog)}.\"\n            )\n\n    if exog.ndim == 1:\n        exog = np.expand_dims(exog, axis=1)\n\n    n_rows = len(exog)\n    exog_direct = []\n    for i in range(steps):\n        exog_step = exog[i : n_rows - (steps - 1 - i)]\n        exog_direct.append(exog_step)\n\n    if len(exog_direct) > 1:\n        exog_direct = np.concatenate(exog_direct, axis=1)\n    else:\n        exog_direct = exog_direct[0]\n    \n    return exog_direct, exog_direct_names\n\n\ndef date_to_index_position(\n    index: pd.Index,\n    date_input: Union[int, str, pd.Timestamp],\n    date_literal: str = 'steps',\n    kwargs_pd_to_datetime: dict = {}\n) -> int:\n    \"\"\"\n    Transform a datetime string or pandas Timestamp to an integer. The integer\n    represents the position of the datetime in the index.\n    \n    Parameters\n    ----------\n    index : pandas Index\n        Original datetime index (must be a pandas DatetimeIndex if `date_input` \n        is not an int).\n    date_input : int, str, pandas Timestamp\n        Datetime to transform to integer.\n        \n        + If int, returns the same integer.\n        + If str or pandas Timestamp, it is converted and expanded into the index.\n    date_literal : str, default 'steps'\n        Variable name used in error messages.\n    kwargs_pd_to_datetime : dict, default {}\n        Additional keyword arguments to pass to `pd.to_datetime()`.\n    \n    Returns\n    -------\n    date_position : int\n        Integer representing the position of the datetime in the index.\n    \n    \"\"\"\n    \n    if isinstance(date_input, (str, pd.Timestamp)):\n        if not isinstance(index, pd.DatetimeIndex):\n            raise TypeError(\n                f\"Index must be a pandas DatetimeIndex when `{date_literal}` is \"\n                f\"not an integer. Check input series or last window.\"\n            )\n        \n        target_date = pd.to_datetime(date_input, **kwargs_pd_to_datetime)\n        last_date = pd.to_datetime(index[-1])\n        if target_date <= last_date:\n            raise ValueError(\n                \"The provided date must be later than the last date in the index.\"\n            )\n        \n        steps_diff = pd.date_range(start=last_date, end=target_date, freq=index.freq)\n        date_position = len(steps_diff) - 1\n    \n    elif isinstance(date_input, (int, np.integer)):\n        date_position = date_input\n    else:\n        raise TypeError(\n            f\"`{date_literal}` must be an integer, string, or pandas Timestamp.\"\n        )\n    \n    return date_position\n\n\ndef expand_index(\n    index: Union[pd.Index, None], \n    steps: int\n) -> pd.Index:\n    \"\"\"\n    Create a new index of length `steps` starting at the end of the index.\n    \n    Parameters\n    ----------\n    index : pandas Index, None\n        Original index.\n    steps : int\n        Number of steps to expand.\n\n    Returns\n    -------\n    new_index : pandas Index\n        New index.\n\n    \"\"\"\n\n    if not isinstance(steps, (int, np.integer)):\n        raise TypeError(f\"`steps` must be an integer. Got {type(steps)}.\")\n\n    if isinstance(index, pd.Index):\n        \n        if isinstance(index, pd.DatetimeIndex):\n            new_index = pd.date_range(\n                            start   = index[-1] + index.freq,\n                            periods = steps,\n                            freq    = index.freq\n                        )\n        elif isinstance(index, pd.RangeIndex):\n            new_index = pd.RangeIndex(\n                            start = index[-1] + 1,\n                            stop  = index[-1] + 1 + steps\n                        )\n        else:\n            raise TypeError(\n                \"Argument `index` must be a pandas DatetimeIndex or RangeIndex.\"\n            )\n    else:\n        new_index = pd.RangeIndex(\n                        start = 0,\n                        stop  = steps\n                    )\n    \n    return new_index\n\n\ndef transform_numpy(\n    array: np.ndarray,\n    transformer,\n    fit: bool = False,\n    inverse_transform: bool = False\n) -> np.ndarray:\n    \"\"\"\n    Transform raw values of a numpy ndarray with a scikit-learn alike \n    transformer, preprocessor or ColumnTransformer. The transformer used must \n    have the following methods: fit, transform, fit_transform and \n    inverse_transform. ColumnTransformers are not allowed since they do not \n    have inverse_transform method.\n\n    Parameters\n    ----------\n    array : numpy ndarray\n        Array to be transformed.\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\n        fit_transform and inverse_transform.\n    fit : bool, default `False`\n        Train the transformer before applying it.\n    inverse_transform : bool, default `False`\n        Transform back the data to the original representation. This is not available\n        when using transformers of class scikit-learn ColumnTransformers.\n\n    Returns\n    -------\n    array_transformed : numpy ndarray\n        Transformed array.\n\n    \"\"\"\n    \n    if not isinstance(array, np.ndarray):\n        raise TypeError(\n            f\"`array` argument must be a numpy ndarray. Got {type(array)}\"\n        )\n\n    if transformer is None:\n        return array\n    \n    array_ndim = array.ndim\n    if array_ndim == 1:\n        array = array.reshape(-1, 1)\n\n    if inverse_transform and isinstance(transformer, ColumnTransformer):\n        raise ValueError(\n            \"`inverse_transform` is not available when using ColumnTransformers.\"\n        )\n\n    if not inverse_transform:\n        if fit:\n            array_transformed = transformer.fit_transform(array)\n        else:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\n                    \"ignore\", \n                    message=\"X does not have valid feature names\", \n                    category=UserWarning\n                )\n                array_transformed = transformer.transform(array)\n    else:\n        array_transformed = transformer.inverse_transform(array)\n\n    if hasattr(array_transformed, 'toarray'):\n        # If the returned values are in sparse matrix format, it is converted to dense\n        array_transformed = array_transformed.toarray()\n\n    if array_ndim == 1:\n        array_transformed = array_transformed.ravel()\n\n    return array_transformed\n\n\ndef transform_series(\n    series: pd.Series,\n    transformer,\n    fit: bool = False,\n    inverse_transform: bool = False\n) -> Union[pd.Series, pd.DataFrame]:\n    \"\"\"\n    Transform raw values of pandas Series with a scikit-learn alike \n    transformer, preprocessor or ColumnTransformer. The transformer used must \n    have the following methods: fit, transform, fit_transform and \n    inverse_transform. ColumnTransformers are not allowed since they do not \n    have inverse_transform method.\n\n    Parameters\n    ----------\n    series : pandas Series\n        Series to be transformed.\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\n        fit_transform and inverse_transform.\n    fit : bool, default `False`\n        Train the transformer before applying it.\n    inverse_transform : bool, default `False`\n        Transform back the data to the original representation. This is not available\n        when using transformers of class scikit-learn ColumnTransformers.\n\n    Returns\n    -------\n    series_transformed : pandas Series, pandas DataFrame\n        Transformed Series. Depending on the transformer used, the output may \n        be a Series or a DataFrame.\n\n    \"\"\"\n    \n    if not isinstance(series, pd.Series):\n        raise TypeError(\n            (f\"`series` argument must be a pandas Series. Got {type(series)}.\")\n        )\n        \n    if transformer is None:\n        return series\n\n    if series.name is None:\n        series.name = 'no_name'\n        \n    data = series.to_frame()\n\n    if fit and hasattr(transformer, 'fit'):\n        transformer.fit(data)\n\n    # If argument feature_names_in_ exits, is overwritten to allow using the \n    # transformer on other series than those that were passed during fit.\n    if hasattr(transformer, 'feature_names_in_') and transformer.feature_names_in_[0] != data.columns[0]:\n        transformer = deepcopy(transformer)\n        transformer.feature_names_in_ = np.array([data.columns[0]], dtype=object)\n\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\", category=UserWarning)\n        if inverse_transform:\n            values_transformed = transformer.inverse_transform(data)\n        else:\n            values_transformed = transformer.transform(data)   \n\n    if hasattr(values_transformed, 'toarray'):\n        # If the returned values are in sparse matrix format, it is converted to dense array.\n        values_transformed = values_transformed.toarray()\n    \n    if isinstance(values_transformed, np.ndarray) and values_transformed.shape[1] == 1:\n        series_transformed = pd.Series(\n                                 data  = values_transformed.ravel(),\n                                 index = data.index,\n                                 name  = data.columns[0]\n                             )\n    elif isinstance(values_transformed, pd.DataFrame) and values_transformed.shape[1] == 1:\n        series_transformed = values_transformed.squeeze()\n    else:\n        series_transformed = pd.DataFrame(\n                                 data    = values_transformed,\n                                 index   = data.index,\n                                 columns = transformer.get_feature_names_out()\n                             )\n\n    return series_transformed\n\n\ndef transform_dataframe(\n    df: pd.DataFrame,\n    transformer,\n    fit: bool = False,\n    inverse_transform: bool = False\n) -> pd.DataFrame:\n    \"\"\"\n    Transform raw values of pandas DataFrame with a scikit-learn alike \n    transformer, preprocessor or ColumnTransformer. The transformer used must \n    have the following methods: fit, transform, fit_transform and \n    inverse_transform. ColumnTransformers are not allowed since they do not \n    have inverse_transform method.\n\n    Parameters\n    ----------\n    df : pandas DataFrame\n        DataFrame to be transformed.\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\n        fit_transform and inverse_transform.\n    fit : bool, default `False`\n        Train the transformer before applying it.\n    inverse_transform : bool, default `False`\n        Transform back the data to the original representation. This is not available\n        when using transformers of class scikit-learn ColumnTransformers.\n\n    Returns\n    -------\n    df_transformed : pandas DataFrame\n        Transformed DataFrame.\n\n    \"\"\"\n    \n    if not isinstance(df, pd.DataFrame):\n        raise TypeError(\n            f\"`df` argument must be a pandas DataFrame. Got {type(df)}\"\n        )\n\n    if transformer is None:\n        return df\n\n    if inverse_transform and isinstance(transformer, ColumnTransformer):\n        raise ValueError(\n            \"`inverse_transform` is not available when using ColumnTransformers.\"\n        )\n \n    if not inverse_transform:\n        if fit:\n            values_transformed = transformer.fit_transform(df)\n        else:\n            values_transformed = transformer.transform(df)\n    else:\n        values_transformed = transformer.inverse_transform(df)\n\n    if hasattr(values_transformed, 'toarray'):\n        # If the returned values are in sparse matrix format, it is converted to dense\n        values_transformed = values_transformed.toarray()\n\n    if hasattr(transformer, 'get_feature_names_out'):\n        feature_names_out = transformer.get_feature_names_out()\n    elif hasattr(transformer, 'categories_'):   \n        feature_names_out = transformer.categories_\n    else:\n        feature_names_out = df.columns\n\n    df_transformed = pd.DataFrame(\n                         data    = values_transformed,\n                         index   = df.index,\n                         columns = feature_names_out\n                     )\n\n    return df_transformed\n\n\ndef save_forecaster(\n    forecaster: object, \n    file_name: str,\n    save_custom_functions: bool = True, \n    verbose: bool = True\n) -> None:\n    \"\"\"\n    Save forecaster model using joblib. If custom functions are used to create\n    weights, they are saved as .py files.\n\n    Parameters\n    ----------\n    forecaster : Forecaster\n        Forecaster created with skforecast library.\n    file_name : str\n        File name given to the object. The save extension will be .joblib.\n    save_custom_functions : bool, default True\n        If True, save custom functions used in the forecaster (weight_func) as \n        .py files. Custom functions need to be available in the environment \n        where the forecaster is going to be loaded.\n    verbose : bool, default True\n        Print summary about the forecaster saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    \n    file_name = Path(file_name).with_suffix('.joblib')\n\n    # Save forecaster\n    joblib.dump(forecaster, filename=file_name)\n\n    if save_custom_functions:\n        # Save custom functions to create weights\n        if hasattr(forecaster, 'weight_func') and forecaster.weight_func is not None:\n            if isinstance(forecaster.weight_func, dict):\n                for fun in set(forecaster.weight_func.values()):\n                    file_name = fun.__name__ + '.py'\n                    with open(file_name, 'w') as file:\n                        file.write(inspect.getsource(fun))\n            else:\n                file_name = forecaster.weight_func.__name__ + '.py'\n                with open(file_name, 'w') as file:\n                    file.write(inspect.getsource(forecaster.weight_func))\n    else:\n        if hasattr(forecaster, 'weight_func') and forecaster.weight_func is not None:\n            warnings.warn(\n                \"Custom function(s) used to create weights are not saved. To save them, \"\n                \"set `save_custom_functions` to `True`.\",\n                SaveLoadSkforecastWarning\n            )\n\n    if hasattr(forecaster, 'window_features') and forecaster.window_features is not None:\n        skforecast_classes = {'RollingFeatures'}\n        custom_classes = set(forecaster.window_features_class_names) - skforecast_classes\n        if custom_classes:\n            warnings.warn(\n                \"The Forecaster includes custom user-defined classes in the \"\n                \"`window_features` argument. These classes are not saved automatically \"\n                \"when saving the Forecaster. Please ensure you save these classes \"\n                \"manually and import them before loading the Forecaster.\\n\"\n                \"    Custom classes: \" + ', '.join(custom_classes) + \"\\n\"\n                \"Visit the documentation for more information: \"\n                \"https://skforecast.org/latest/user_guides/save-load-forecaster.html#saving-and-loading-a-forecaster-model-with-custom-features\",\n                SaveLoadSkforecastWarning\n            )\n\n    if verbose:\n        forecaster.summary()\n\n\ndef load_forecaster(\n    file_name: str,\n    verbose: bool = True\n) -> object:\n    \"\"\"\n    Load forecaster model using joblib. If the forecaster was saved with \n    custom user-defined classes as as window features or custom\n    functions to create weights, these objects must be available\n    in the environment where the forecaster is going to be loaded.\n\n    Parameters\n    ----------\n    file_name: str\n        Object file name.\n    verbose: bool, default `True`\n        Print summary about the forecaster loaded.\n\n    Returns\n    -------\n    forecaster: Forecaster\n        Forecaster created with skforecast library.\n    \n    \"\"\"\n\n    forecaster = joblib.load(filename=Path(file_name))\n\n    skforecast_v = skforecast.__version__\n    forecaster_v = forecaster.skforecast_version\n\n    if forecaster_v != skforecast_v:\n        warnings.warn(\n            f\"The skforecast version installed in the environment differs \"\n            f\"from the version used to create the forecaster.\\n\"\n            f\"    Installed Version  : {skforecast_v}\\n\"\n            f\"    Forecaster Version : {forecaster_v}\\n\"\n            f\"This may create incompatibilities when using the library.\",\n             SkforecastVersionWarning\n        )\n\n    if verbose:\n        forecaster.summary()\n\n    return forecaster\n\n\ndef _find_optional_dependency(\n    package_name: str, \n    optional_dependencies: dict = optional_dependencies\n) -> Tuple[str, str]:\n    \"\"\"\n    Find if a package is an optional dependency. If True, find the version and \n    the extension it belongs to.\n\n    Parameters\n    ----------\n    package_name : str\n        Name of the package to check.\n    optional_dependencies : dict, default `optional_dependencies`\n        Skforecast optional dependencies.\n\n    Returns\n    -------\n    extra: str\n        Name of the extra extension where the optional dependency is needed.\n    package_version: srt\n        Name and versions of the dependency.\n\n    \"\"\"\n\n    for extra, packages in optional_dependencies.items():\n        package_version = [package for package in packages if package_name in package]\n        if package_version:\n            return extra, package_version[0]\n\n\ndef check_optional_dependency(\n    package_name: str\n) -> None:\n    \"\"\"\n    Check if an optional dependency is installed, if not raise an ImportError  \n    with installation instructions.\n\n    Parameters\n    ----------\n    package_name : str\n        Name of the package to check.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n\n    if importlib.util.find_spec(package_name) is None:\n        try:\n            extra, package_version = _find_optional_dependency(package_name=package_name)\n            msg = (\n                f\"\\n'{package_name}' is an optional dependency not included in the default \"\n                f\"skforecast installation. Please run: `pip install \\\"{package_version}\\\"` to install it.\"\n                f\"\\n\\nAlternately, you can install it by running `pip install skforecast[{extra}]`\"\n            )\n        except:\n            msg = f\"\\n'{package_name}' is needed but not installed. Please install it.\"\n        \n        raise ImportError(msg)\n\n\ndef multivariate_time_series_corr(\n    time_series: pd.Series,\n    other: pd.DataFrame,\n    lags: Union[int, list, np.array],\n    method: str = 'pearson'\n) -> pd.DataFrame:\n    \"\"\"\n    Compute correlation between a time_series and the lagged values of other \n    time series. \n\n    Parameters\n    ----------\n    time_series : pandas Series\n        Target time series.\n    other : pandas DataFrame\n        Time series whose lagged values are correlated to `time_series`.\n    lags : int, list, numpy ndarray\n        Lags to be included in the correlation analysis.\n    method : str, default 'pearson'\n        - 'pearson': standard correlation coefficient.\n        - 'kendall': Kendall Tau correlation coefficient.\n        - 'spearman': Spearman rank correlation.\n\n    Returns\n    -------\n    corr : pandas DataFrame\n        Correlation values.\n\n    \"\"\"\n\n    if not len(time_series) == len(other):\n        raise ValueError(\"`time_series` and `other` must have the same length.\")\n\n    if not (time_series.index == other.index).all():\n        raise ValueError(\"`time_series` and `other` must have the same index.\")\n\n    if isinstance(lags, int):\n        lags = range(lags)\n\n    corr = {}\n    for col in other.columns:\n        lag_values = {}\n        for lag in lags:\n            lag_values[lag] = other[col].shift(lag)\n\n        lag_values = pd.DataFrame(lag_values)\n        lag_values.insert(0, None, time_series)\n        corr[col] = lag_values.corr(method=method).iloc[1:, 0]\n\n    corr = pd.DataFrame(corr)\n    corr.index = corr.index.astype('int64')\n    corr.index.name = \"lag\"\n    \n    return corr\n\n\ndef select_n_jobs_fit_forecaster(\n    forecaster_name: str,\n    regressor: object,\n) -> int:\n    \"\"\"\n    Select the optimal number of jobs to use in the fitting process. This\n    selection is based on heuristics and is not guaranteed to be optimal. \n    \n    The number of jobs is chosen as follows:\n    \n    - If forecaster_name is 'ForecasterDirect' or 'ForecasterDirectMultiVariate'\n    and regressor_name is a linear regressor then `n_jobs = 1`, \n    otherwise `n_jobs = cpu_count() - 1`.\n    - If regressor is a `LGBMRegressor(n_jobs=1)`, then `n_jobs = cpu_count() - 1`.\n    - If regressor is a `LGBMRegressor` with internal n_jobs != 1, then `n_jobs = 1`.\n    This is because `lightgbm` is highly optimized for gradient boosting and\n    parallelizes operations at a very fine-grained level, making additional\n    parallelization unnecessary and potentially harmful due to resource contention.\n    \n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    regressor : regressor or pipeline compatible with the scikit-learn API\n        An instance of a regressor or pipeline compatible with the scikit-learn API.\n\n    Returns\n    -------\n    n_jobs : int\n        The number of jobs to run in parallel.\n    \n    \"\"\"\n\n    if isinstance(regressor, Pipeline):\n        regressor = regressor[-1]\n        regressor_name = type(regressor).__name__\n    else:\n        regressor_name = type(regressor).__name__\n\n    linear_regressors = [\n        regressor_name\n        for regressor_name in dir(sklearn.linear_model)\n        if not regressor_name.startswith('_')\n    ]\n\n    if forecaster_name in ['ForecasterDirect', \n                           'ForecasterDirectMultiVariate']:\n        if regressor_name in linear_regressors:\n            n_jobs = 1\n        elif regressor_name == 'LGBMRegressor':\n            n_jobs = joblib.cpu_count() - 1 if regressor.n_jobs == 1 else 1\n        else:\n            n_jobs = joblib.cpu_count() - 1\n    else:\n        n_jobs = 1\n\n    return n_jobs\n\n\ndef check_preprocess_series(\n    series: Union[pd.DataFrame, dict],\n) -> Tuple[dict, pd.Index]:\n    \"\"\"\n    Check and preprocess `series` argument in `ForecasterRecursiveMultiSeries` class.\n\n    - If `series` is a pandas DataFrame, it is converted to a dict of pandas \n    Series and index is overwritten according to the rules of preprocess_y.\n    - If `series` is a dict, all values are converted to pandas Series. Checks\n    if all index are pandas DatetimeIndex and, at least, one Series has a non-null\n    frequency. No multiple frequency is allowed.\n\n    Parameters\n    ----------\n    series : pandas DataFrame, dict\n        Training time series.\n\n    Returns\n    -------\n    series_dict : dict\n        Dictionary with the series used during training.\n    series_indexes : dict\n        Dictionary with the index of each series.\n    \n    \"\"\"\n\n    if isinstance(series, pd.DataFrame):\n\n        _, series_index = preprocess_y(y=series, return_values=False)\n        series = series.copy()\n        series.index = series_index\n        series_dict = series.to_dict(\"series\")\n\n    elif isinstance(series, dict):\n\n        not_valid_series = [\n            k \n            for k, v in series.items()\n            if not isinstance(v, (pd.Series, pd.DataFrame))\n        ]\n        if not_valid_series:\n            raise TypeError(\n                (f\"If `series` is a dictionary, all series must be a named \"\n                 f\"pandas Series or a pandas DataFrame with a single column. \"\n                 f\"Review series: {not_valid_series}\")\n            )\n\n        series_dict = {\n            k: v.copy()\n            for k, v in series.items()\n        }\n\n        for k, v in series_dict.items():\n            if isinstance(v, pd.DataFrame):\n                if v.shape[1] != 1:\n                    raise ValueError(\n                        (f\"If `series` is a dictionary, all series must be a named \"\n                         f\"pandas Series or a pandas DataFrame with a single column. \"\n                         f\"Review series: '{k}'\")\n                    )\n                series_dict[k] = v.iloc[:, 0]\n\n            series_dict[k].name = k\n\n        not_valid_index = [\n            k \n            for k, v in series_dict.items()\n            if not isinstance(v.index, pd.DatetimeIndex)\n        ]\n        if not_valid_index:\n            raise TypeError(\n                (f\"If `series` is a dictionary, all series must have a Pandas \"\n                 f\"DatetimeIndex as index with the same frequency. \"\n                 f\"Review series: {not_valid_index}\")\n            )\n\n        indexes_freq = [f\"{v.index.freq}\" for v in series_dict.values()]\n        indexes_freq = sorted(set(indexes_freq))\n        if not len(indexes_freq) == 1:\n            raise ValueError(\n                (f\"If `series` is a dictionary, all series must have a Pandas \"\n                 f\"DatetimeIndex as index with the same frequency. \"\n                 f\"Found frequencies: {indexes_freq}\")\n            )\n    else:\n        raise TypeError(\n            (f\"`series` must be a pandas DataFrame or a dict of DataFrames or Series. \"\n             f\"Got {type(series)}.\")\n        )\n\n    for k, v in series_dict.items():\n        if np.isnan(v).all():\n            raise ValueError(f\"All values of series '{k}' are NaN.\")\n\n    series_indexes = {\n        k: v.index\n        for k, v in series_dict.items()\n    }\n\n    return series_dict, series_indexes\n\n\ndef check_preprocess_exog_multiseries(\n    input_series_is_dict: bool,\n    series_indexes: dict,\n    series_names_in_: list,\n    exog: Union[pd.Series, pd.DataFrame, dict],\n    exog_dict: dict,\n) -> Tuple[dict, list]:\n    \"\"\"\n    Check and preprocess `exog` argument in `ForecasterRecursiveMultiSeries` class.\n\n    - If input series is a pandas DataFrame (input_series_is_dict = False),  \n    checks that input exog (pandas Series, DataFrame or dict) has the same index \n    (type, length and frequency). Index is overwritten according to the rules \n    of preprocess_exog. Create a dict of exog with the same keys as series.\n    - If input series is a dict (input_series_is_dict = True), then input \n    exog must be a dict. Check exog has a pandas DatetimeIndex and convert all\n    values to pandas DataFrames.\n\n    Parameters\n    ----------\n    input_series_is_dict : bool\n        Indicates if input series argument is a dict.\n    series_indexes : dict\n        Dictionary with the index of each series.\n    series_names_in_ : list\n        Names of the series (levels) used during training.\n    exog : pandas Series, pandas DataFrame, dict\n        Exogenous variable/s used during training.\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n\n    Returns\n    -------\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n    exog_names_in_ : list\n        Names of the exogenous variables used during training.\n    \n    \"\"\"\n\n    if not isinstance(exog, (pd.Series, pd.DataFrame, dict)):\n        raise TypeError(\n            (f\"`exog` must be a pandas Series, DataFrame, dictionary of pandas \"\n             f\"Series/DataFrames or None. Got {type(exog)}.\")\n        )\n\n    if not input_series_is_dict:\n        # If input series is a pandas DataFrame, all index are the same.\n        # Select the first index to check exog\n        series_index = series_indexes[series_names_in_[0]]\n\n    if isinstance(exog, (pd.Series, pd.DataFrame)): \n\n        if input_series_is_dict:\n            raise TypeError(\n                (f\"`exog` must be a dict of DataFrames or Series if \"\n                 f\"`series` is a dict. Got {type(exog)}.\")\n            )\n\n        _, exog_index = preprocess_exog(exog=exog, return_values=False)\n        exog = exog.copy().to_frame() if isinstance(exog, pd.Series) else exog.copy()\n        exog.index = exog_index\n\n        if len(exog) != len(series_index):\n            raise ValueError(\n                (f\"`exog` must have same number of samples as `series`. \"\n                 f\"length `exog`: ({len(exog)}), length `series`: ({len(series_index)})\")\n            )\n\n        if not (exog_index == series_index).all():\n            raise ValueError(\n                (\"Different index for `series` and `exog`. They must be equal \"\n                 \"to ensure the correct alignment of values.\")\n            )\n\n        exog_dict = {serie: exog for serie in series_names_in_}\n\n    else:\n\n        not_valid_exog = [\n            k \n            for k, v in exog.items()\n            if not isinstance(v, (pd.Series, pd.DataFrame, type(None)))\n        ]\n        if not_valid_exog:\n            raise TypeError(\n                (f\"If `exog` is a dictionary, all exog must be a named pandas \"\n                 f\"Series, a pandas DataFrame or None. Review exog: {not_valid_exog}\")\n            )\n\n        # Only elements already present in exog_dict are updated\n        exog_dict.update(\n            (k, v.copy())\n            for k, v in exog.items() \n            if k in exog_dict and v is not None\n        )\n\n        series_not_in_exog = set(series_names_in_) - set(exog.keys())\n        if series_not_in_exog:\n            warnings.warn(\n                (f\"{series_not_in_exog} not present in `exog`. All values \"\n                 f\"of the exogenous variables for these series will be NaN.\"),\n                 MissingExogWarning\n            )\n\n        for k, v in exog_dict.items():\n            if v is not None:\n                check_exog(exog=v, allow_nan=True)\n                if isinstance(v, pd.Series):\n                    v = v.to_frame()\n                exog_dict[k] = v\n\n        if not input_series_is_dict:\n            for k, v in exog_dict.items():\n                if v is not None:\n                    if len(v) != len(series_index):\n                        raise ValueError(\n                            (f\"`exog` for series '{k}' must have same number of \"\n                             f\"samples as `series`. length `exog`: ({len(v)}), \"\n                             f\"length `series`: ({len(series_index)})\")\n                        )\n\n                    _, v_index = preprocess_exog(exog=v, return_values=False)\n                    exog_dict[k].index = v_index\n                    if not (exog_dict[k].index == series_index).all():\n                        raise ValueError(\n                            (f\"Different index for series '{k}' and its exog. \"\n                             f\"When `series` is a pandas DataFrame, they must be \"\n                             f\"equal to ensure the correct alignment of values.\")\n                        )\n        else:\n            not_valid_index = [\n                k\n                for k, v in exog_dict.items()\n                if v is not None and not isinstance(v.index, pd.DatetimeIndex)\n            ]\n            if not_valid_index:\n                raise TypeError(\n                    (f\"All exog must have a Pandas DatetimeIndex as index with the \"\n                     f\"same frequency. Check exog for series: {not_valid_index}\")\n                )\n            \n        # Check that all exog have the same dtypes for common columns\n        exog_dtypes_buffer = [df.dtypes for df in exog_dict.values() if df is not None]\n        exog_dtypes_buffer = pd.concat(exog_dtypes_buffer, axis=1)\n        exog_dtypes_nunique = exog_dtypes_buffer.nunique(axis=1).eq(1)\n        if not exog_dtypes_nunique.all():\n            non_unique_dtyeps_exogs = exog_dtypes_nunique[exog_dtypes_nunique != 1].index.to_list()\n            raise TypeError(f\"Exog/s: {non_unique_dtyeps_exogs} have different dtypes in different series.\")\n\n    exog_names_in_ = list(\n        set(\n            column\n            for df in exog_dict.values()\n            if df is not None\n            for column in df.columns.to_list()\n        )\n    )\n\n    if len(set(exog_names_in_) - set(series_names_in_)) != len(exog_names_in_):\n        raise ValueError(\n            (f\"`exog` cannot contain a column named the same as one of the series.\\n\"\n             f\"    `series` columns : {series_names_in_}.\\n\"\n             f\"    `exog`   columns : {exog_names_in_}.\")\n        )\n\n    return exog_dict, exog_names_in_\n\n\ndef align_series_and_exog_multiseries(\n    series_dict: dict,\n    input_series_is_dict: bool,\n    exog_dict: dict = None\n) -> Tuple[Union[pd.Series, pd.DataFrame], Union[pd.Series, pd.DataFrame]]:\n    \"\"\"\n    Align series and exog according to their index. If needed, reindexing is\n    applied. Heading and trailing NaNs are removed from all series in \n    `series_dict`.\n\n    - If input series is a pandas DataFrame (input_series_is_dict = False),  \n    input exog (pandas Series, DataFrame or dict) must have the same index \n    (type, length and frequency). Reindexing is not applied.\n    - If input series is a dict (input_series_is_dict = True), then input \n    exog must be a dict. Both must have a pandas DatetimeIndex, but can have \n    different lengths. Reindexing is applied.\n\n    Parameters\n    ----------\n    series_dict : dict\n        Dictionary with the series used during training.\n    input_series_is_dict : bool\n        Indicates if input series argument is a dict.\n    exog_dict : dict, default `None`\n        Dictionary with the exogenous variable/s used during training.\n\n    Returns\n    -------\n    series_dict : dict\n        Dictionary with the series used during training.\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n    \n    \"\"\"\n\n    for k in series_dict.keys():\n\n        first_valid_index = series_dict[k].first_valid_index()\n        last_valid_index = series_dict[k].last_valid_index()\n\n        series_dict[k] = series_dict[k].loc[first_valid_index : last_valid_index]\n\n        if exog_dict[k] is not None:\n            if input_series_is_dict:\n                index_intersection = (\n                    series_dict[k].index.intersection(exog_dict[k].index)\n                )\n                if len(index_intersection) == 0:\n                    warnings.warn(\n                        (f\"Series '{k}' and its `exog` do not have the same index. \"\n                         f\"All exog values will be NaN for the period of the series.\"),\n                         MissingValuesWarning\n                    )\n                elif len(index_intersection) != len(series_dict[k]):\n                    warnings.warn(\n                        (f\"Series '{k}' and its `exog` do not have the same length. \"\n                         f\"Exog values will be NaN for the not matched period of the series.\"),\n                         MissingValuesWarning\n                    )  \n                exog_dict[k] = exog_dict[k].loc[index_intersection]\n                if len(index_intersection) != len(series_dict[k]):\n                    exog_dict[k] = exog_dict[k].reindex(\n                                       series_dict[k].index, \n                                       fill_value = np.nan\n                                   )\n            else:\n                exog_dict[k] = exog_dict[k].loc[first_valid_index : last_valid_index]\n\n    return series_dict, exog_dict\n\n\ndef prepare_levels_multiseries(\n    X_train_series_names_in_: list,\n    levels: Optional[Union[str, list]] = None\n) -> Tuple[list, bool]:\n    \"\"\"\n    Prepare list of levels to be predicted in multiseries Forecasters.\n\n    Parameters\n    ----------\n    X_train_series_names_in_ : list\n        Names of the series (levels) included in the matrix `X_train`.\n    levels : str, list, default `None`\n        Names of the series (levels) to be predicted.\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n\n    \"\"\"\n\n    input_levels_is_list = False\n    if levels is None:\n        levels = X_train_series_names_in_\n    elif isinstance(levels, str):\n        levels = [levels]\n    else:\n        input_levels_is_list = True\n\n    return levels, input_levels_is_list\n\n\ndef preprocess_levels_self_last_window_multiseries(\n    levels: list,\n    input_levels_is_list: bool,\n    last_window_: dict\n) -> Tuple[list, pd.DataFrame]:\n    \"\"\"\n    Preprocess `levels` and `last_window` (when using self.last_window_) arguments \n    in multiseries Forecasters when predicting. Only levels whose last window \n    ends at the same datetime index will be predicted together.\n\n    Parameters\n    ----------\n    levels : list\n        Names of the series (levels) to be predicted.\n    input_levels_is_list : bool\n        Indicates if input levels argument is a list.\n    last_window_ : dict\n        Dictionary with the last window of each series (self.last_window_).\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n    last_window : pandas DataFrame\n        Series values used to create the predictors (lags) needed in the \n        first iteration of the prediction (t + 1).\n\n    \"\"\"\n\n    available_last_windows = set() if last_window_ is None else set(last_window_.keys())\n    not_available_last_window = set(levels) - available_last_windows\n    if not_available_last_window:\n        levels = [level for level in levels \n                  if level not in not_available_last_window]\n        if not levels:\n            raise ValueError(\n                (f\"No series to predict. None of the series {not_available_last_window} \"\n                 f\"are present in `last_window_` attribute. Provide `last_window` \"\n                 f\"as argument in predict method.\")\n            )\n        else:\n            warnings.warn(\n                (f\"Levels {not_available_last_window} are excluded from \"\n                 f\"prediction since they were not stored in `last_window_` \"\n                 f\"attribute during training. If you don't want to retrain \"\n                 f\"the Forecaster, provide `last_window` as argument.\"),\n                 IgnoredArgumentWarning\n            )\n\n    last_index_levels = [\n        v.index[-1] \n        for k, v in last_window_.items()\n        if k in levels\n    ]\n    if len(set(last_index_levels)) > 1:\n        max_index_levels = max(last_index_levels)\n        selected_levels = [\n            k\n            for k, v in last_window_.items()\n            if k in levels and v.index[-1] == max_index_levels\n        ]\n\n        series_excluded_from_last_window = set(levels) - set(selected_levels)\n        levels = selected_levels\n\n        if input_levels_is_list and series_excluded_from_last_window:\n            warnings.warn(\n                (f\"Only series whose last window ends at the same index \"\n                 f\"can be predicted together. Series that do not reach \"\n                 f\"the maximum index, '{max_index_levels}', are excluded \"\n                 f\"from prediction: {series_excluded_from_last_window}.\"),\n                IgnoredArgumentWarning\n            )\n\n    last_window = pd.DataFrame(\n        {k: v \n         for k, v in last_window_.items() \n         if k in levels}\n    )\n\n    return levels, last_window\n\n\ndef prepare_residuals_multiseries(\n    levels: list,\n    use_in_sample_residuals: bool,\n    encoding: Optional[str] = None,\n    in_sample_residuals_: Optional[dict] = None,\n    out_sample_residuals_: Optional[dict] = None\n) -> Tuple[list, bool]:\n    \"\"\"\n    Prepare residuals for bootstrapping prediction in multiseries Forecasters.\n\n    Parameters\n    ----------\n    levels : list\n        Names of the series (levels) to be predicted.\n    use_in_sample_residuals : bool\n        Indicates if `forecaster.in_sample_residuals_` are used.\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n    in_sample_residuals_ : dict, default `None`\n        Residuals of the model when predicting training data. Only stored up to\n        1000 values in the form `{level: residuals}`. If `transformer_series` \n        is not `None`, residuals are stored in the transformed scale.\n    out_sample_residuals_ : dict, default `None`\n        Residuals of the model when predicting non-training data. Only stored\n        up to 1000 values in the form `{level: residuals}`. If `transformer_series` \n        is not `None`, residuals are assumed to be in the transformed scale. Use \n        `set_out_sample_residuals()` method to set values.\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n    residuals : dict\n        Residuals of the model for each level to use in bootstrapping prediction.\n\n    \"\"\"\n\n    if use_in_sample_residuals:\n        unknown_levels = set(levels) - set(in_sample_residuals_.keys())\n        if unknown_levels and encoding is not None:\n            warnings.warn(\n                (f\"`levels` {unknown_levels} are not present in `forecaster.in_sample_residuals_`, \"\n                 f\"most likely because they were not present in the training data. \"\n                 f\"A random sample of the residuals from other levels will be used. \"\n                 f\"This can lead to inaccurate intervals for the unknown levels.\"),\n                 UnknownLevelWarning\n            )\n        residuals = in_sample_residuals_.copy()\n    else:\n        if out_sample_residuals_ is None:\n            raise ValueError(\n                (\"`forecaster.out_sample_residuals_` is `None`. Use \"\n                 \"`use_in_sample_residuals=True` or the \"\n                 \"`set_out_sample_residuals()` method before predicting.\")\n            )\n        else:\n            unknown_levels = set(levels) - set(out_sample_residuals_.keys())\n            if unknown_levels and encoding is not None:\n                warnings.warn(\n                    (f\"`levels` {unknown_levels} are not present in `forecaster.out_sample_residuals_`. \"\n                     f\"A random sample of the residuals from other levels will be used. \"\n                     f\"This can lead to inaccurate intervals for the unknown levels. \"\n                     f\"Otherwise, Use the `set_out_sample_residuals()` method before \"\n                     f\"predicting to set the residuals for these levels.\"),\n                     UnknownLevelWarning\n                )\n            residuals = out_sample_residuals_.copy()\n\n    check_residuals = (\n        \"forecaster.in_sample_residuals_\" if use_in_sample_residuals\n        else \"forecaster.out_sample_residuals_\"\n    )\n    for level in levels:\n        if level in unknown_levels:\n            residuals[level] = residuals['_unknown_level']\n        if residuals[level] is None or len(residuals[level]) == 0:\n            raise ValueError(\n                (f\"Not available residuals for level '{level}'. \"\n                 f\"Check `{check_residuals}`.\")\n            )\n        elif (any(element is None for element in residuals[level]) or\n              np.any(np.isnan(residuals[level]))):\n            raise ValueError(\n                (f\"forecaster residuals for level '{level}' contains `None` \"\n                 f\"or `NaNs` values. Check `{check_residuals}`.\")\n            )\n        \n    return residuals\n\n\ndef prepare_steps_direct(\n    max_step: int,\n    steps: Optional[Union[int, list]] = None\n) -> list:\n    \"\"\"\n    Prepare list of steps to be predicted in Direct Forecasters.\n\n    Parameters\n    ----------\n    max_step : int\n        Maximum number of future steps the forecaster will predict \n        when using method `predict()`.\n    steps : int, list, None, default `None`\n        Predict n steps. The value of `steps` must be less than or equal to the \n        value of steps defined when initializing the forecaster. Starts at 1.\n    \n        - If `int`: Only steps within the range of 1 to int are predicted.\n        - If `list`: List of ints. Only the steps contained in the list \n        are predicted.\n        - If `None`: As many steps are predicted as were defined at \n        initialization.\n\n    Returns\n    -------\n    steps : list\n        Steps to be predicted.\n\n    \"\"\"\n\n    if isinstance(steps, int):\n        steps = list(np.arange(steps) + 1)\n    elif steps is None:\n        steps = list(np.arange(max_step) + 1)\n    elif isinstance(steps, list):\n        steps = list(np.array(steps))\n    \n    for step in steps:\n        if not isinstance(step, (int, np.int64, np.int32)):\n            raise TypeError(\n                (f\"`steps` argument must be an int, a list of ints or `None`. \"\n                 f\"Got {type(steps)}.\")\n            )\n    # Required since numpy 2.0\n    steps = [int(step) for step in steps if step is not None]\n\n    return steps\n\n\ndef set_skforecast_warnings(\n    suppress_warnings: bool,\n    action: str = 'default'\n) -> None:\n    \"\"\"\n    Set skforecast warnings action.\n\n    Parameters\n    ----------\n    suppress_warnings : bool\n        If `True`, skforecast warnings will be suppressed. If `False`, skforecast\n        warnings will be shown as default. See \n        skforecast.exceptions.warn_skforecast_categories for more information.\n    action : str, default `'default'`\n        Action to be taken when a warning is raised. See the warnings module\n        for more information.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n\n    if suppress_warnings:\n        for category in warn_skforecast_categories:\n            warnings.filterwarnings(action, category=category)\n"
  },
  "GT_src_dict": {
    "skforecast/utils/utils.py": {
      "transform_numpy": {
        "code": "def transform_numpy(array: np.ndarray, transformer, fit: bool=False, inverse_transform: bool=False) -> np.ndarray:\n    \"\"\"Transform raw values of a numpy ndarray using a scikit-learn compatible transformer or preprocessor. The function supports both transformation and inverse transformation, allowing for the retrieval of the original representation of the data if desired.\n\nParameters\n----------\narray : numpy.ndarray\n    The array to be transformed. It must be a numpy ndarray; otherwise, a TypeError will be raised.\ntransformer : object\n    A scikit-learn alike transformer or preprocessor that must implement the methods: fit, transform, fit_transform, and inverse_transform. ColumnTransformers are not supported for inverse transformation.\nfit : bool, default `False`\n    If set to True, the transformer is trained before applying the transformation.\ninverse_transform : bool, default `False`\n    If True, reverses the transformation and returns the data in its original form. This option is incompatible with ColumnTransformers.\n\nReturns\n-------\nnumpy.ndarray\n    The transformed array. If the input array is one-dimensional, the result will be flattened to maintain the original shape.\n\nRaises\n------\nTypeError\n    If the `array` parameter is not a numpy ndarray.\nValueError\n    If `inverse_transform` is True and a ColumnTransformer is provided.\n\nNotes\n-----\nThis function is primarily designed for use in preprocessing data for models that expect transformed inputs, especially in contexts where scikit-learn transformers are utilized. The behavior of the function is influenced by the shape and dimensionality of the input array, ensuring proper handling based on its structure.\"\"\"\n    '\\n    Transform raw values of a numpy ndarray with a scikit-learn alike \\n    transformer, preprocessor or ColumnTransformer. The transformer used must \\n    have the following methods: fit, transform, fit_transform and \\n    inverse_transform. ColumnTransformers are not allowed since they do not \\n    have inverse_transform method.\\n\\n    Parameters\\n    ----------\\n    array : numpy ndarray\\n        Array to be transformed.\\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\\n        fit_transform and inverse_transform.\\n    fit : bool, default `False`\\n        Train the transformer before applying it.\\n    inverse_transform : bool, default `False`\\n        Transform back the data to the original representation. This is not available\\n        when using transformers of class scikit-learn ColumnTransformers.\\n\\n    Returns\\n    -------\\n    array_transformed : numpy ndarray\\n        Transformed array.\\n\\n    '\n    if not isinstance(array, np.ndarray):\n        raise TypeError(f'`array` argument must be a numpy ndarray. Got {type(array)}')\n    if transformer is None:\n        return array\n    array_ndim = array.ndim\n    if array_ndim == 1:\n        array = array.reshape(-1, 1)\n    if inverse_transform and isinstance(transformer, ColumnTransformer):\n        raise ValueError('`inverse_transform` is not available when using ColumnTransformers.')\n    if not inverse_transform:\n        if fit:\n            array_transformed = transformer.fit_transform(array)\n        else:\n            with warnings.catch_warnings():\n                warnings.filterwarnings('ignore', message='X does not have valid feature names', category=UserWarning)\n                array_transformed = transformer.transform(array)\n    else:\n        array_transformed = transformer.inverse_transform(array)\n    if hasattr(array_transformed, 'toarray'):\n        array_transformed = array_transformed.toarray()\n    if array_ndim == 1:\n        array_transformed = array_transformed.ravel()\n    return array_transformed",
        "docstring": "Transform raw values of a numpy ndarray using a scikit-learn compatible transformer or preprocessor. The function supports both transformation and inverse transformation, allowing for the retrieval of the original representation of the data if desired.\n\nParameters\n----------\narray : numpy.ndarray\n    The array to be transformed. It must be a numpy ndarray; otherwise, a TypeError will be raised.\ntransformer : object\n    A scikit-learn alike transformer or preprocessor that must implement the methods: fit, transform, fit_transform, and inverse_transform. ColumnTransformers are not supported for inverse transformation.\nfit : bool, default `False`\n    If set to True, the transformer is trained before applying the transformation.\ninverse_transform : bool, default `False`\n    If True, reverses the transformation and returns the data in its original form. This option is incompatible with ColumnTransformers.\n\nReturns\n-------\nnumpy.ndarray\n    The transformed array. If the input array is one-dimensional, the result will be flattened to maintain the original shape.\n\nRaises\n------\nTypeError\n    If the `array` parameter is not a numpy ndarray.\nValueError\n    If `inverse_transform` is True and a ColumnTransformer is provided.\n\nNotes\n-----\nThis function is primarily designed for use in preprocessing data for models that expect transformed inputs, especially in contexts where scikit-learn transformers are utilized. The behavior of the function is influenced by the shape and dimensionality of the input array, ensuring proper handling based on its structure.",
        "signature": "def transform_numpy(array: np.ndarray, transformer, fit: bool=False, inverse_transform: bool=False) -> np.ndarray:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: skforecast-test_transform_numpy\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 skforecast/\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 utils.py\n            \u2514\u2500\u2500 transform_numpy\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and extend the functionality of the `transform_numpy` utility, which facilitates the transformation of data arrays using various preprocessing transformers. Its primary purpose is to ensure robust support for applying, fitting, and inverting transformations on `numpy` arrays using preprocessing tools such as `StandardScaler`, `OneHotEncoder`, and `ColumnTransformer` while handling edge cases and raising appropriate errors for invalid operations. The module provides key features to seamlessly transform arrays with scalability (e.g., standardization, encoding) or composite transformations while maintaining the flexibility to apply or bypass inverse transformations. This solves common challenges for developers and data practitioners by ensuring compatibility, correctness, and adaptability when preparing and preprocessing datasets for machine learning workflows, reducing the risk of misaligned transformations or unsupported data structures.\n\n## FILE 1: skforecast/utils/utils.py\n\n- FUNCTION NAME: transform_numpy\n  - SIGNATURE: def transform_numpy(array: np.ndarray, transformer, fit: bool=False, inverse_transform: bool=False) -> np.ndarray:\n  - DOCSTRING: \n```python\n\"\"\"\nTransform raw values of a numpy ndarray using a scikit-learn compatible transformer or preprocessor. The function supports both transformation and inverse transformation, allowing for the retrieval of the original representation of the data if desired.\n\nParameters\n----------\narray : numpy.ndarray\n    The array to be transformed. It must be a numpy ndarray; otherwise, a TypeError will be raised.\ntransformer : object\n    A scikit-learn alike transformer or preprocessor that must implement the methods: fit, transform, fit_transform, and inverse_transform. ColumnTransformers are not supported for inverse transformation.\nfit : bool, default `False`\n    If set to True, the transformer is trained before applying the transformation.\ninverse_transform : bool, default `False`\n    If True, reverses the transformation and returns the data in its original form. This option is incompatible with ColumnTransformers.\n\nReturns\n-------\nnumpy.ndarray\n    The transformed array. If the input array is one-dimensional, the result will be flattened to maintain the original shape.\n\nRaises\n------\nTypeError\n    If the `array` parameter is not a numpy ndarray.\nValueError\n    If `inverse_transform` is True and a ColumnTransformer is provided.\n\nNotes\n-----\nThis function is primarily designed for use in preprocessing data for models that expect transformed inputs, especially in contexts where scikit-learn transformers are utilized. The behavior of the function is influenced by the shape and dimensionality of the input array, ensuring proper handling based on its structure.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "skforecast/utils/utils.py": "import importlib\nimport inspect\nimport warnings\nfrom copy import deepcopy\nfrom typing import Any, Callable, Optional, Tuple, Union\nfrom pathlib import Path\nimport joblib\nimport numpy as np\nimport pandas as pd\nimport sklearn.linear_model\nfrom sklearn.base import clone\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.exceptions import NotFittedError\nimport skforecast\nfrom ..exceptions import warn_skforecast_categories\nfrom ..exceptions import MissingValuesWarning, MissingExogWarning, DataTypeWarning, UnknownLevelWarning, IgnoredArgumentWarning, SaveLoadSkforecastWarning, SkforecastVersionWarning\noptional_dependencies = {'sarimax': ['statsmodels>=0.12, <0.15'], 'deeplearning': ['matplotlib>=3.3, <3.10', 'keras>=2.6, <4.0'], 'plotting': ['matplotlib>=3.3, <3.10', 'seaborn>=0.11, <0.14', 'statsmodels>=0.12, <0.15']}\n\ndef initialize_lags(forecaster_name: str, lags: Any) -> Union[Optional[np.ndarray], Optional[list], Optional[int]]:\n    \"\"\"\n    Check lags argument input and generate the corresponding numpy ndarray.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    lags : Any\n        Lags used as predictors.\n\n    Returns\n    -------\n    lags : numpy ndarray, None\n        Lags used as predictors.\n    lags_names : list, None\n        Names of the lags used as predictors.\n    max_lag : int, None\n        Maximum value of the lags.\n    \n    \"\"\"\n    lags_names = None\n    max_lag = None\n    if lags is not None:\n        if isinstance(lags, int):\n            if lags < 1:\n                raise ValueError('Minimum value of lags allowed is 1.')\n            lags = np.arange(1, lags + 1)\n        if isinstance(lags, (list, tuple, range)):\n            lags = np.array(lags)\n        if isinstance(lags, np.ndarray):\n            if lags.size == 0:\n                return (None, None, None)\n            if lags.ndim != 1:\n                raise ValueError('`lags` must be a 1-dimensional array.')\n            if not np.issubdtype(lags.dtype, np.integer):\n                raise TypeError('All values in `lags` must be integers.')\n            if np.any(lags < 1):\n                raise ValueError('Minimum value of lags allowed is 1.')\n        elif forecaster_name != 'ForecasterDirectMultiVariate':\n            raise TypeError(f'`lags` argument must be an int, 1d numpy ndarray, range, tuple or list. Got {type(lags)}.')\n        else:\n            raise TypeError(f'`lags` argument must be a dict, int, 1d numpy ndarray, range, tuple or list. Got {type(lags)}.')\n        lags_names = [f'lag_{i}' for i in lags]\n        max_lag = max(lags)\n    return (lags, lags_names, max_lag)\n\ndef initialize_window_features(window_features: Any) -> Union[Optional[list], Optional[list], Optional[int]]:\n    \"\"\"\n    Check window_features argument input and generate the corresponding list.\n\n    Parameters\n    ----------\n    window_features : Any\n        Classes used to create window features.\n\n    Returns\n    -------\n    window_features : list, None\n        List of classes used to create window features.\n    window_features_names : list, None\n        List with all the features names of the window features.\n    max_size_window_features : int, None\n        Maximum value of the `window_sizes` attribute of all classes.\n    \n    \"\"\"\n    needed_atts = ['window_sizes', 'features_names']\n    needed_methods = ['transform_batch', 'transform']\n    max_window_sizes = None\n    window_features_names = None\n    max_size_window_features = None\n    if window_features is not None:\n        if isinstance(window_features, list) and len(window_features) < 1:\n            raise ValueError('Argument `window_features` must contain at least one element.')\n        if not isinstance(window_features, list):\n            window_features = [window_features]\n        link_to_docs = '\\nVisit the documentation for more information about how to create custom window features:\\nhttps://skforecast.org/latest/user_guides/window-features-and-custom-features.html#create-your-custom-window-features'\n        max_window_sizes = []\n        window_features_names = []\n        for wf in window_features:\n            wf_name = type(wf).__name__\n            atts_methods = set([a for a in dir(wf)])\n            if not set(needed_atts).issubset(atts_methods):\n                raise ValueError(f'{wf_name} must have the attributes: {needed_atts}.' + link_to_docs)\n            if not set(needed_methods).issubset(atts_methods):\n                raise ValueError(f'{wf_name} must have the methods: {needed_methods}.' + link_to_docs)\n            window_sizes = wf.window_sizes\n            if not isinstance(window_sizes, (int, list)):\n                raise TypeError(f'Attribute `window_sizes` of {wf_name} must be an int or a list of ints. Got {type(window_sizes)}.' + link_to_docs)\n            if isinstance(window_sizes, int):\n                if window_sizes < 1:\n                    raise ValueError(f'If argument `window_sizes` is an integer, it must be equal to or greater than 1. Got {window_sizes} from {wf_name}.' + link_to_docs)\n                max_window_sizes.append(window_sizes)\n            else:\n                if not all((isinstance(ws, int) for ws in window_sizes)) or not all((ws >= 1 for ws in window_sizes)):\n                    raise ValueError(f'If argument `window_sizes` is a list, all elements must be integers equal to or greater than 1. Got {window_sizes} from {wf_name}.' + link_to_docs)\n                max_window_sizes.append(max(window_sizes))\n            features_names = wf.features_names\n            if not isinstance(features_names, (str, list)):\n                raise TypeError(f'Attribute `features_names` of {wf_name} must be a str or a list of strings. Got {type(features_names)}.' + link_to_docs)\n            if isinstance(features_names, str):\n                window_features_names.append(features_names)\n            else:\n                if not all((isinstance(fn, str) for fn in features_names)):\n                    raise TypeError(f'If argument `features_names` is a list, all elements must be strings. Got {features_names} from {wf_name}.' + link_to_docs)\n                window_features_names.extend(features_names)\n        max_size_window_features = max(max_window_sizes)\n        if len(set(window_features_names)) != len(window_features_names):\n            raise ValueError(f'All window features names must be unique. Got {window_features_names}.')\n    return (window_features, window_features_names, max_size_window_features)\n\ndef initialize_weights(forecaster_name: str, regressor: object, weight_func: Union[Callable, dict], series_weights: dict) -> Tuple[Union[Callable, dict], Union[str, dict], dict]:\n    \"\"\"\n    Check weights arguments, `weight_func` and `series_weights` for the different \n    forecasters. Create `source_code_weight_func`, source code of the custom \n    function(s) used to create weights.\n    \n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    regressor : regressor or pipeline compatible with the scikit-learn API\n        Regressor of the forecaster.\n    weight_func : Callable, dict\n        Argument `weight_func` of the forecaster.\n    series_weights : dict\n        Argument `series_weights` of the forecaster.\n\n    Returns\n    -------\n    weight_func : Callable, dict\n        Argument `weight_func` of the forecaster.\n    source_code_weight_func : str, dict\n        Argument `source_code_weight_func` of the forecaster.\n    series_weights : dict\n        Argument `series_weights` of the forecaster.\n    \n    \"\"\"\n    source_code_weight_func = None\n    if weight_func is not None:\n        if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n            if not isinstance(weight_func, (Callable, dict)):\n                raise TypeError(f'Argument `weight_func` must be a Callable or a dict of Callables. Got {type(weight_func)}.')\n        elif not isinstance(weight_func, Callable):\n            raise TypeError(f'Argument `weight_func` must be a Callable. Got {type(weight_func)}.')\n        if isinstance(weight_func, dict):\n            source_code_weight_func = {}\n            for key in weight_func:\n                source_code_weight_func[key] = inspect.getsource(weight_func[key])\n        else:\n            source_code_weight_func = inspect.getsource(weight_func)\n        if 'sample_weight' not in inspect.signature(regressor.fit).parameters:\n            warnings.warn(f'Argument `weight_func` is ignored since regressor {regressor} does not accept `sample_weight` in its `fit` method.', IgnoredArgumentWarning)\n            weight_func = None\n            source_code_weight_func = None\n    if series_weights is not None:\n        if not isinstance(series_weights, dict):\n            raise TypeError(f'Argument `series_weights` must be a dict of floats or ints.Got {type(series_weights)}.')\n        if 'sample_weight' not in inspect.signature(regressor.fit).parameters:\n            warnings.warn(f'Argument `series_weights` is ignored since regressor {regressor} does not accept `sample_weight` in its `fit` method.', IgnoredArgumentWarning)\n            series_weights = None\n    return (weight_func, source_code_weight_func, series_weights)\n\ndef initialize_transformer_series(forecaster_name: str, series_names_in_: list, encoding: Optional[str]=None, transformer_series: Optional[Union[object, dict]]=None) -> dict:\n    \"\"\"\n    Initialize `transformer_series_` attribute for the Forecasters Multiseries.\n\n    - If `transformer_series` is `None`, no transformation is applied.\n    - If `transformer_series` is a scikit-learn transformer (object), the same \n    transformer is applied to all series (`series_names_in_`).\n    - If `transformer_series` is a `dict`, a different transformer can be\n    applied to each series. The keys of the dictionary must be the same as the\n    names of the series in `series_names_in_`.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    series_names_in_ : list\n        Names of the series (levels) used during training.\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n    transformer_series : object, dict, default `None`\n        An instance of a transformer (preprocessor) compatible with the scikit-learn\n        preprocessing API with methods: fit, transform, fit_transform and \n        inverse_transform. \n\n    Returns\n    -------\n    transformer_series_ : dict\n        Dictionary with the transformer for each series. It is created cloning the \n        objects in `transformer_series` and is used internally to avoid overwriting.\n    \n    \"\"\"\n    multiseries_forecasters = ['ForecasterRecursiveMultiSeries']\n    if forecaster_name in multiseries_forecasters:\n        if encoding is None:\n            series_names_in_ = ['_unknown_level']\n        else:\n            series_names_in_ = series_names_in_ + ['_unknown_level']\n    if transformer_series is None:\n        transformer_series_ = {serie: None for serie in series_names_in_}\n    elif not isinstance(transformer_series, dict):\n        transformer_series_ = {serie: clone(transformer_series) for serie in series_names_in_}\n    else:\n        transformer_series_ = {serie: None for serie in series_names_in_}\n        transformer_series_.update(((k, v) for k, v in deepcopy(transformer_series).items() if k in transformer_series_))\n        series_not_in_transformer_series = set(series_names_in_) - set(transformer_series.keys()) - {'_unknown_level'}\n        if series_not_in_transformer_series:\n            warnings.warn(f'{series_not_in_transformer_series} not present in `transformer_series`. No transformation is applied to these series.', IgnoredArgumentWarning)\n    return transformer_series_\n\ndef check_select_fit_kwargs(regressor: object, fit_kwargs: Optional[dict]=None) -> dict:\n    \"\"\"\n    Check if `fit_kwargs` is a dict and select only the keys that are used by\n    the `fit` method of the regressor.\n\n    Parameters\n    ----------\n    regressor : object\n        Regressor object.\n    fit_kwargs : dict, default `None`\n        Dictionary with the arguments to pass to the `fit' method of the forecaster.\n\n    Returns\n    -------\n    fit_kwargs : dict\n        Dictionary with the arguments to be passed to the `fit` method of the \n        regressor after removing the unused keys.\n    \n    \"\"\"\n    if fit_kwargs is None:\n        fit_kwargs = {}\n    else:\n        if not isinstance(fit_kwargs, dict):\n            raise TypeError(f'Argument `fit_kwargs` must be a dict. Got {type(fit_kwargs)}.')\n        non_used_keys = [k for k in fit_kwargs.keys() if k not in inspect.signature(regressor.fit).parameters]\n        if non_used_keys:\n            warnings.warn(f\"Argument/s {non_used_keys} ignored since they are not used by the regressor's `fit` method.\", IgnoredArgumentWarning)\n        if 'sample_weight' in fit_kwargs.keys():\n            warnings.warn('The `sample_weight` argument is ignored. Use `weight_func` to pass a function that defines the individual weights for each sample based on its index.', IgnoredArgumentWarning)\n            del fit_kwargs['sample_weight']\n        fit_kwargs = {k: v for k, v in fit_kwargs.items() if k in inspect.signature(regressor.fit).parameters}\n    return fit_kwargs\n\ndef check_y(y: Any, series_id: str='`y`') -> None:\n    \"\"\"\n    Raise Exception if `y` is not pandas Series or if it has missing values.\n    \n    Parameters\n    ----------\n    y : Any\n        Time series values.\n    series_id : str, default '`y`'\n        Identifier of the series used in the warning message.\n    \n    Returns\n    -------\n    None\n    \n    \"\"\"\n    if not isinstance(y, pd.Series):\n        raise TypeError(f'{series_id} must be a pandas Series.')\n    if y.isnull().any():\n        raise ValueError(f'{series_id} has missing values.')\n    return\n\ndef check_exog(exog: Union[pd.Series, pd.DataFrame], allow_nan: bool=True, series_id: str='`exog`') -> None:\n    \"\"\"\n    Raise Exception if `exog` is not pandas Series or pandas DataFrame.\n    If `allow_nan = True`, issue a warning if `exog` contains NaN values.\n    \n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n    allow_nan : bool, default `True`\n        If True, allows the presence of NaN values in `exog`. If False (default),\n        issue a warning if `exog` contains NaN values.\n    series_id : str, default '`exog`'\n        Identifier of the series for which the exogenous variable/s are used\n        in the warning message.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if not isinstance(exog, (pd.Series, pd.DataFrame)):\n        raise TypeError(f'{series_id} must be a pandas Series or DataFrame. Got {type(exog)}.')\n    if isinstance(exog, pd.Series) and exog.name is None:\n        raise ValueError(f'When {series_id} is a pandas Series, it must have a name.')\n    if not allow_nan:\n        if exog.isnull().any().any():\n            warnings.warn(f'{series_id} has missing values. Most machine learning models do not allow missing values. Fitting the forecaster may fail.', MissingValuesWarning)\n    return\n\ndef get_exog_dtypes(exog: Union[pd.DataFrame, pd.Series]) -> dict:\n    \"\"\"\n    Store dtypes of `exog`.\n\n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n\n    Returns\n    -------\n    exog_dtypes : dict\n        Dictionary with the dtypes in `exog`.\n    \n    \"\"\"\n    if isinstance(exog, pd.Series):\n        exog_dtypes = {exog.name: exog.dtypes}\n    else:\n        exog_dtypes = exog.dtypes.to_dict()\n    return exog_dtypes\n\ndef check_exog_dtypes(exog: Union[pd.DataFrame, pd.Series], call_check_exog: bool=True, series_id: str='`exog`') -> None:\n    \"\"\"\n    Raise Exception if `exog` has categorical columns with non integer values.\n    This is needed when using machine learning regressors that allow categorical\n    features.\n    Issue a Warning if `exog` has columns that are not `init`, `float`, or `category`.\n    \n    Parameters\n    ----------\n    exog : pandas DataFrame, pandas Series\n        Exogenous variable/s included as predictor/s.\n    call_check_exog : bool, default `True`\n        If `True`, call `check_exog` function.\n    series_id : str, default '`exog`'\n        Identifier of the series for which the exogenous variable/s are used\n        in the warning message.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if call_check_exog:\n        check_exog(exog=exog, allow_nan=False, series_id=series_id)\n    if isinstance(exog, pd.DataFrame):\n        if not exog.select_dtypes(exclude=[np.number, 'category']).columns.empty:\n            warnings.warn(f'{series_id} may contain only `int`, `float` or `category` dtypes. Most machine learning models do not allow other types of values. Fitting the forecaster may fail.', DataTypeWarning)\n        for col in exog.select_dtypes(include='category'):\n            if exog[col].cat.categories.dtype not in [int, np.int32, np.int64]:\n                raise TypeError('Categorical dtypes in exog must contain only integer values. See skforecast docs for more info about how to include categorical features https://skforecast.org/latest/user_guides/categorical-features.html')\n    else:\n        if exog.dtype.name not in ['int', 'int8', 'int16', 'int32', 'int64', 'float', 'float16', 'float32', 'float64', 'uint8', 'uint16', 'uint32', 'uint64', 'category']:\n            warnings.warn(f'{series_id} may contain only `int`, `float` or `category` dtypes. Most machine learning models do not allow other types of values. Fitting the forecaster may fail.', DataTypeWarning)\n        if exog.dtype.name == 'category' and exog.cat.categories.dtype not in [int, np.int32, np.int64]:\n            raise TypeError('Categorical dtypes in exog must contain only integer values. See skforecast docs for more info about how to include categorical features https://skforecast.org/latest/user_guides/categorical-features.html')\n    return\n\ndef check_interval(interval: list=None, quantiles: float=None, alpha: float=None) -> None:\n    \"\"\"\n    Check provided confidence interval sequence is valid.\n\n    Parameters\n    ----------\n    interval : list, default `None`\n        Confidence of the prediction interval estimated. Sequence of percentiles\n        to compute, which must be between 0 and 100 inclusive. For example, \n        interval of 95% should be as `interval = [2.5, 97.5]`.\n    quantiles : list, default `None`\n        Sequence of quantiles to compute, which must be between 0 and 1 \n        inclusive. For example, quantiles of 0.05, 0.5 and 0.95 should be as \n        `quantiles = [0.05, 0.5, 0.95]`.\n    alpha : float, default `None`\n        The confidence intervals used in ForecasterSarimax are (1 - alpha) %.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n    if interval is not None:\n        if not isinstance(interval, list):\n            raise TypeError('`interval` must be a `list`. For example, interval of 95% should be as `interval = [2.5, 97.5]`.')\n        if len(interval) != 2:\n            raise ValueError('`interval` must contain exactly 2 values, respectively the lower and upper interval bounds. For example, interval of 95% should be as `interval = [2.5, 97.5]`.')\n        if interval[0] < 0.0 or interval[0] >= 100.0:\n            raise ValueError(f'Lower interval bound ({interval[0]}) must be >= 0 and < 100.')\n        if interval[1] <= 0.0 or interval[1] > 100.0:\n            raise ValueError(f'Upper interval bound ({interval[1]}) must be > 0 and <= 100.')\n        if interval[0] >= interval[1]:\n            raise ValueError(f'Lower interval bound ({interval[0]}) must be less than the upper interval bound ({interval[1]}).')\n    if quantiles is not None:\n        if not isinstance(quantiles, list):\n            raise TypeError('`quantiles` must be a `list`. For example, quantiles 0.05, 0.5, and 0.95 should be as `quantiles = [0.05, 0.5, 0.95]`.')\n        for q in quantiles:\n            if q < 0.0 or q > 1.0:\n                raise ValueError('All elements in `quantiles` must be >= 0 and <= 1.')\n    if alpha is not None:\n        if not isinstance(alpha, float):\n            raise TypeError('`alpha` must be a `float`. For example, interval of 95% should be as `alpha = 0.05`.')\n        if alpha <= 0.0 or alpha >= 1:\n            raise ValueError(f'`alpha` must have a value between 0 and 1. Got {alpha}.')\n    return\n\ndef check_predict_input(forecaster_name: str, steps: Union[int, list], is_fitted: bool, exog_in_: bool, index_type_: type, index_freq_: str, window_size: int, last_window: Union[pd.Series, pd.DataFrame, None], last_window_exog: Optional[Union[pd.Series, pd.DataFrame]]=None, exog: Optional[Union[pd.Series, pd.DataFrame]]=None, exog_type_in_: Optional[type]=None, exog_names_in_: Optional[list]=None, interval: Optional[list]=None, alpha: Optional[float]=None, max_steps: Optional[int]=None, levels: Optional[Union[str, list]]=None, levels_forecaster: Optional[Union[str, list]]=None, series_names_in_: Optional[list]=None, encoding: Optional[str]=None) -> None:\n    \"\"\"\n    Check all inputs of predict method. This is a helper function to validate\n    that inputs used in predict method match attributes of a forecaster already\n    trained.\n\n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    steps : int, list\n        Number of future steps predicted.\n    is_fitted: bool\n        Tag to identify if the regressor has been fitted (trained).\n    exog_in_ : bool\n        If the forecaster has been trained using exogenous variable/s.\n    index_type_ : type\n        Type of index of the input used in training.\n    index_freq_ : str\n        Frequency of Index of the input used in training.\n    window_size: int\n        Size of the window needed to create the predictors. It is equal to \n        `max_lag`.\n    last_window : pandas Series, pandas DataFrame, None\n        Values of the series used to create the predictors (lags) need in the \n        first iteration of prediction (t + 1).\n    last_window_exog : pandas Series, pandas DataFrame, default `None`\n        Values of the exogenous variables aligned with `last_window` in \n        ForecasterSarimax predictions.\n    exog : pandas Series, pandas DataFrame, default `None`\n        Exogenous variable/s included as predictor/s.\n    exog_type_in_ : type, default `None`\n        Type of exogenous variable/s used in training.\n    exog_names_in_ : list, default `None`\n        Names of the exogenous variables used during training.\n    interval : list, default `None`\n        Confidence of the prediction interval estimated. Sequence of percentiles\n        to compute, which must be between 0 and 100 inclusive. For example, \n        interval of 95% should be as `interval = [2.5, 97.5]`.\n    alpha : float, default `None`\n        The confidence intervals used in ForecasterSarimax are (1 - alpha) %.\n    max_steps: int, default `None`\n        Maximum number of steps allowed (`ForecasterDirect` and \n        `ForecasterDirectMultiVariate`).\n    levels : str, list, default `None`\n        Time series to be predicted (`ForecasterRecursiveMultiSeries`\n        and `ForecasterRnn).\n    levels_forecaster : str, list, default `None`\n        Time series used as output data of a multiseries problem in a RNN problem\n        (`ForecasterRnn`).\n    series_names_in_ : list, default `None`\n        Names of the columns used during fit (`ForecasterRecursiveMultiSeries`, \n        `ForecasterDirectMultiVariate` and `ForecasterRnn`).\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    if not is_fitted:\n        raise NotFittedError('This Forecaster instance is not fitted yet. Call `fit` with appropriate arguments before using predict.')\n    if isinstance(steps, (int, np.integer)) and steps < 1:\n        raise ValueError(f'`steps` must be an integer greater than or equal to 1. Got {steps}.')\n    if isinstance(steps, list) and min(steps) < 1:\n        raise ValueError(f'The minimum value of `steps` must be equal to or greater than 1. Got {min(steps)}.')\n    if max_steps is not None:\n        if max(steps) > max_steps:\n            raise ValueError(f'The maximum value of `steps` must be less than or equal to the value of steps defined when initializing the forecaster. Got {max(steps)}, but the maximum is {max_steps}.')\n    if interval is not None or alpha is not None:\n        check_interval(interval=interval, alpha=alpha)\n    if forecaster_name in ['ForecasterRecursiveMultiSeries', 'ForecasterRnn']:\n        if not isinstance(levels, (type(None), str, list)):\n            raise TypeError('`levels` must be a `list` of column names, a `str` of a column name or `None`.')\n        levels_to_check = levels_forecaster if forecaster_name == 'ForecasterRnn' else series_names_in_\n        unknown_levels = set(levels) - set(levels_to_check)\n        if forecaster_name == 'ForecasterRnn':\n            if len(unknown_levels) != 0:\n                raise ValueError(f'`levels` names must be included in the series used during fit ({levels_to_check}). Got {levels}.')\n        elif len(unknown_levels) != 0 and last_window is not None and (encoding is not None):\n            if encoding == 'onehot':\n                warnings.warn(f'`levels` {unknown_levels} were not included in training. The resulting one-hot encoded columns for this feature will be all zeros.', UnknownLevelWarning)\n            else:\n                warnings.warn(f'`levels` {unknown_levels} were not included in training. Unknown levels are encoded as NaN, which may cause the prediction to fail if the regressor does not accept NaN values.', UnknownLevelWarning)\n    if exog is None and exog_in_:\n        raise ValueError('Forecaster trained with exogenous variable/s. Same variable/s must be provided when predicting.')\n    if exog is not None and (not exog_in_):\n        raise ValueError('Forecaster trained without exogenous variable/s. `exog` must be `None` when predicting.')\n    if isinstance(last_window, type(None)) and forecaster_name not in ['ForecasterRecursiveMultiSeries', 'ForecasterRnn']:\n        raise ValueError(\"`last_window` was not stored during training. If you don't want to retrain the Forecaster, provide `last_window` as argument.\")\n    if forecaster_name in ['ForecasterRecursiveMultiSeries', 'ForecasterDirectMultiVariate', 'ForecasterRnn']:\n        if not isinstance(last_window, pd.DataFrame):\n            raise TypeError(f'`last_window` must be a pandas DataFrame. Got {type(last_window)}.')\n        last_window_cols = last_window.columns.to_list()\n        if forecaster_name in ['ForecasterRecursiveMultiSeries', 'ForecasterRnn'] and len(set(levels) - set(last_window_cols)) != 0:\n            raise ValueError(f'`last_window` must contain a column(s) named as the level(s) to be predicted.\\n    `levels` : {levels}\\n    `last_window` columns : {last_window_cols}')\n        if forecaster_name == 'ForecasterDirectMultiVariate':\n            if len(set(series_names_in_) - set(last_window_cols)) > 0:\n                raise ValueError(f'`last_window` columns must be the same as the `series` column names used to create the X_train matrix.\\n    `last_window` columns    : {last_window_cols}\\n    `series` columns X train : {series_names_in_}')\n    elif not isinstance(last_window, (pd.Series, pd.DataFrame)):\n        raise TypeError(f'`last_window` must be a pandas Series or DataFrame. Got {type(last_window)}.')\n    if len(last_window) < window_size:\n        raise ValueError(f'`last_window` must have as many values as needed to generate the predictors. For this forecaster it is {window_size}.')\n    if last_window.isnull().any().all():\n        warnings.warn('`last_window` has missing values. Most of machine learning models do not allow missing values. Prediction method may fail.', MissingValuesWarning)\n    _, last_window_index = preprocess_last_window(last_window=last_window.iloc[:0], return_values=False)\n    if not isinstance(last_window_index, index_type_):\n        raise TypeError(f'Expected index of type {index_type_} for `last_window`. Got {type(last_window_index)}.')\n    if isinstance(last_window_index, pd.DatetimeIndex):\n        if not last_window_index.freqstr == index_freq_:\n            raise TypeError(f'Expected frequency of type {index_freq_} for `last_window`. Got {last_window_index.freqstr}.')\n    if exog is not None:\n        if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n            if not isinstance(exog, (pd.Series, pd.DataFrame, dict)):\n                raise TypeError(f'`exog` must be a pandas Series, DataFrame or dict. Got {type(exog)}.')\n            if exog_type_in_ == dict and (not isinstance(exog, dict)):\n                raise TypeError(f'Expected type for `exog`: {exog_type_in_}. Got {type(exog)}.')\n        elif not isinstance(exog, (pd.Series, pd.DataFrame)):\n            raise TypeError(f'`exog` must be a pandas Series or DataFrame. Got {type(exog)}.')\n        if isinstance(exog, dict):\n            no_exog_levels = set(levels) - set(exog.keys())\n            if no_exog_levels:\n                warnings.warn(f'`exog` does not contain keys for levels {no_exog_levels}. Missing levels are filled with NaN. Most of machine learning models do not allow missing values. Prediction method may fail.', MissingExogWarning)\n            exogs_to_check = [(f\"`exog` for series '{k}'\", v) for k, v in exog.items() if v is not None and k in levels]\n        else:\n            exogs_to_check = [('`exog`', exog)]\n        for exog_name, exog_to_check in exogs_to_check:\n            if not isinstance(exog_to_check, (pd.Series, pd.DataFrame)):\n                raise TypeError(f'{exog_name} must be a pandas Series or DataFrame. Got {type(exog_to_check)}')\n            if exog_to_check.isnull().any().any():\n                warnings.warn(f'{exog_name} has missing values. Most of machine learning models do not allow missing values. Prediction method may fail.', MissingValuesWarning)\n            last_step = max(steps) if isinstance(steps, list) else steps\n            if len(exog_to_check) < last_step:\n                if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                    warnings.warn(f\"{exog_name} doesn't have as many values as steps predicted, {last_step}. Missing values are filled with NaN. Most of machine learning models do not allow missing values. Prediction method may fail.\", MissingValuesWarning)\n                else:\n                    raise ValueError(f'{exog_name} must have at least as many values as steps predicted, {last_step}.')\n            if isinstance(exog_to_check, pd.DataFrame):\n                col_missing = set(exog_names_in_).difference(set(exog_to_check.columns))\n                if col_missing:\n                    if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                        warnings.warn(f'{col_missing} not present in {exog_name}. All values will be NaN.', MissingExogWarning)\n                    else:\n                        raise ValueError(f'Missing columns in {exog_name}. Expected {exog_names_in_}. Got {exog_to_check.columns.to_list()}.')\n            else:\n                if exog_to_check.name is None:\n                    raise ValueError(f'When {exog_name} is a pandas Series, it must have a name. Got None.')\n                if exog_to_check.name not in exog_names_in_:\n                    if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                        warnings.warn(f\"'{exog_to_check.name}' was not observed during training. {exog_name} is ignored. Exogenous variables must be one of: {exog_names_in_}.\", IgnoredArgumentWarning)\n                    else:\n                        raise ValueError(f\"'{exog_to_check.name}' was not observed during training. Exogenous variables must be: {exog_names_in_}.\")\n            _, exog_index = preprocess_exog(exog=exog_to_check.iloc[:0,], return_values=False)\n            if not isinstance(exog_index, index_type_):\n                raise TypeError(f'Expected index of type {index_type_} for {exog_name}. Got {type(exog_index)}.')\n            if forecaster_name not in ['ForecasterRecursiveMultiSeries']:\n                if isinstance(exog_index, pd.DatetimeIndex):\n                    if not exog_index.freqstr == index_freq_:\n                        raise TypeError(f'Expected frequency of type {index_freq_} for {exog_name}. Got {exog_index.freqstr}.')\n            expected_index = expand_index(last_window.index, 1)[0]\n            if expected_index != exog_to_check.index[0]:\n                if forecaster_name in ['ForecasterRecursiveMultiSeries']:\n                    warnings.warn(f'To make predictions {exog_name} must start one step ahead of `last_window`. Missing values are filled with NaN.\\n    `last_window` ends at : {last_window.index[-1]}.\\n    {exog_name} starts at : {exog_to_check.index[0]}.\\n     Expected index       : {expected_index}.', MissingValuesWarning)\n                else:\n                    raise ValueError(f'To make predictions {exog_name} must start one step ahead of `last_window`.\\n    `last_window` ends at : {last_window.index[-1]}.\\n    {exog_name} starts at : {exog_to_check.index[0]}.\\n     Expected index : {expected_index}.')\n    if forecaster_name == 'ForecasterSarimax':\n        if last_window_exog is not None:\n            if not exog_in_:\n                raise ValueError('Forecaster trained without exogenous variable/s. `last_window_exog` must be `None` when predicting.')\n            if not isinstance(last_window_exog, (pd.Series, pd.DataFrame)):\n                raise TypeError(f'`last_window_exog` must be a pandas Series or a pandas DataFrame. Got {type(last_window_exog)}.')\n            if len(last_window_exog) < window_size:\n                raise ValueError(f'`last_window_exog` must have as many values as needed to generate the predictors. For this forecaster it is {window_size}.')\n            if last_window_exog.isnull().any().all():\n                warnings.warn('`last_window_exog` has missing values. Most of machine learning models do not allow missing values. Prediction method may fail.', MissingValuesWarning)\n            _, last_window_exog_index = preprocess_last_window(last_window=last_window_exog.iloc[:0], return_values=False)\n            if not isinstance(last_window_exog_index, index_type_):\n                raise TypeError(f'Expected index of type {index_type_} for `last_window_exog`. Got {type(last_window_exog_index)}.')\n            if isinstance(last_window_exog_index, pd.DatetimeIndex):\n                if not last_window_exog_index.freqstr == index_freq_:\n                    raise TypeError(f'Expected frequency of type {index_freq_} for `last_window_exog`. Got {last_window_exog_index.freqstr}.')\n            if isinstance(last_window_exog, pd.DataFrame):\n                col_missing = set(exog_names_in_).difference(set(last_window_exog.columns))\n                if col_missing:\n                    raise ValueError(f'Missing columns in `last_window_exog`. Expected {exog_names_in_}. Got {last_window_exog.columns.to_list()}.')\n            else:\n                if last_window_exog.name is None:\n                    raise ValueError('When `last_window_exog` is a pandas Series, it must have a name. Got None.')\n                if last_window_exog.name not in exog_names_in_:\n                    raise ValueError(f\"'{last_window_exog.name}' was not observed during training. Exogenous variables must be: {exog_names_in_}.\")\n    return\n\ndef preprocess_y(y: Union[pd.Series, pd.DataFrame], return_values: bool=True) -> Tuple[Union[None, np.ndarray], pd.Index]:\n    \"\"\"\n    Return values and index of series separately. Index is overwritten \n    according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n    \n    Parameters\n    ----------\n    y : pandas Series, pandas DataFrame\n        Time series.\n    return_values : bool, default `True`\n        If `True` return the values of `y` as numpy ndarray. This option is \n        intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    y_values : None, numpy ndarray\n        Numpy array with values of `y`.\n    y_index : pandas Index\n        Index of `y` modified according to the rules.\n    \n    \"\"\"\n    if isinstance(y.index, pd.DatetimeIndex) and y.index.freq is not None:\n        y_index = y.index\n    elif isinstance(y.index, pd.RangeIndex):\n        y_index = y.index\n    elif isinstance(y.index, pd.DatetimeIndex) and y.index.freq is None:\n        warnings.warn('Series has DatetimeIndex index but no frequency. Index is overwritten with a RangeIndex of step 1.')\n        y_index = pd.RangeIndex(start=0, stop=len(y), step=1)\n    else:\n        warnings.warn('Series has no DatetimeIndex nor RangeIndex index. Index is overwritten with a RangeIndex.')\n        y_index = pd.RangeIndex(start=0, stop=len(y), step=1)\n    y_values = y.to_numpy(copy=True).ravel() if return_values else None\n    return (y_values, y_index)\n\ndef preprocess_last_window(last_window: Union[pd.Series, pd.DataFrame], return_values: bool=True) -> Tuple[np.ndarray, pd.Index]:\n    \"\"\"\n    Return values and index of series separately. Index is overwritten \n    according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n    \n    Parameters\n    ----------\n    last_window : pandas Series, pandas DataFrame\n        Time series values.\n    return_values : bool, default `True`\n        If `True` return the values of `last_window` as numpy ndarray. This option \n        is intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    last_window_values : numpy ndarray\n        Numpy array with values of `last_window`.\n    last_window_index : pandas Index\n        Index of `last_window` modified according to the rules.\n    \n    \"\"\"\n    if isinstance(last_window.index, pd.DatetimeIndex) and last_window.index.freq is not None:\n        last_window_index = last_window.index\n    elif isinstance(last_window.index, pd.RangeIndex):\n        last_window_index = last_window.index\n    elif isinstance(last_window.index, pd.DatetimeIndex) and last_window.index.freq is None:\n        warnings.warn('`last_window` has DatetimeIndex index but no frequency. Index is overwritten with a RangeIndex of step 1.')\n        last_window_index = pd.RangeIndex(start=0, stop=len(last_window), step=1)\n    else:\n        warnings.warn('`last_window` has no DatetimeIndex nor RangeIndex index. Index is overwritten with a RangeIndex.')\n        last_window_index = pd.RangeIndex(start=0, stop=len(last_window), step=1)\n    last_window_values = last_window.to_numpy(copy=True).ravel() if return_values else None\n    return (last_window_values, last_window_index)\n\ndef preprocess_exog(exog: Union[pd.Series, pd.DataFrame], return_values: bool=True) -> Tuple[Union[None, np.ndarray], pd.Index]:\n    \"\"\"\n    Return values and index of series or data frame separately. Index is\n    overwritten  according to the next rules:\n    \n    - If index is of type `DatetimeIndex` and has frequency, nothing is \n    changed.\n    - If index is of type `RangeIndex`, nothing is changed.\n    - If index is of type `DatetimeIndex` but has no frequency, a \n    `RangeIndex` is created.\n    - If index is not of type `DatetimeIndex`, a `RangeIndex` is created.\n\n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    return_values : bool, default `True`\n        If `True` return the values of `exog` as numpy ndarray. This option is \n        intended to avoid copying data when it is not necessary.\n\n    Returns\n    -------\n    exog_values : None, numpy ndarray\n        Numpy array with values of `exog`.\n    exog_index : pandas Index\n        Index of `exog` modified according to the rules.\n    \n    \"\"\"\n    if isinstance(exog.index, pd.DatetimeIndex) and exog.index.freq is not None:\n        exog_index = exog.index\n    elif isinstance(exog.index, pd.RangeIndex):\n        exog_index = exog.index\n    elif isinstance(exog.index, pd.DatetimeIndex) and exog.index.freq is None:\n        warnings.warn('`exog` has DatetimeIndex index but no frequency. Index is overwritten with a RangeIndex of step 1.')\n        exog_index = pd.RangeIndex(start=0, stop=len(exog), step=1)\n    else:\n        warnings.warn('`exog` has no DatetimeIndex nor RangeIndex index. Index is overwritten with a RangeIndex.')\n        exog_index = pd.RangeIndex(start=0, stop=len(exog), step=1)\n    exog_values = exog.to_numpy(copy=True) if return_values else None\n    return (exog_values, exog_index)\n\ndef input_to_frame(data: Union[pd.Series, pd.DataFrame], input_name: str) -> pd.DataFrame:\n    \"\"\"\n    Convert data to a pandas DataFrame. If data is a pandas Series, it is \n    converted to a DataFrame with a single column. If data is a DataFrame, \n    it is returned as is.\n\n    Parameters\n    ----------\n    data : pandas Series, pandas DataFrame\n        Input data.\n    input_name : str\n        Name of the input data. Accepted values are 'y', 'last_window' and 'exog'.\n\n    Returns\n    -------\n    data : pandas DataFrame\n        Input data as a DataFrame.\n\n    \"\"\"\n    output_col_name = {'y': 'y', 'last_window': 'y', 'exog': 'exog'}\n    if isinstance(data, pd.Series):\n        data = data.to_frame(name=data.name if data.name is not None else output_col_name[input_name])\n    return data\n\ndef cast_exog_dtypes(exog: Union[pd.Series, pd.DataFrame], exog_dtypes: dict) -> Union[pd.Series, pd.DataFrame]:\n    \"\"\"\n    Cast `exog` to a specified types. This is done because, for a forecaster to \n    accept a categorical exog, it must contain only integer values. Due to the \n    internal modifications of numpy, the values may be casted to `float`, so \n    they have to be re-converted to `int`.\n\n    - If `exog` is a pandas Series, `exog_dtypes` must be a dict with a \n    single value.\n    - If `exog_dtypes` is `category` but the current type of `exog` is `float`, \n    then the type is cast to `int` and then to `category`. \n\n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    exog_dtypes: dict\n        Dictionary with name and type of the series or data frame columns.\n\n    Returns\n    -------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables casted to the indicated dtypes.\n\n    \"\"\"\n    exog_dtypes = {k: v for k, v in exog_dtypes.items() if k in exog.columns}\n    if isinstance(exog, pd.Series) and exog.dtypes != list(exog_dtypes.values())[0]:\n        exog = exog.astype(list(exog_dtypes.values())[0])\n    elif isinstance(exog, pd.DataFrame):\n        for col, initial_dtype in exog_dtypes.items():\n            if exog[col].dtypes != initial_dtype:\n                if initial_dtype == 'category' and exog[col].dtypes == float:\n                    exog[col] = exog[col].astype(int).astype('category')\n                else:\n                    exog[col] = exog[col].astype(initial_dtype)\n    return exog\n\ndef exog_to_direct(exog: Union[pd.Series, pd.DataFrame], steps: int) -> Union[pd.DataFrame, list]:\n    \"\"\"\n    Transforms `exog` to a pandas DataFrame with the shape needed for Direct\n    forecasting.\n    \n    Parameters\n    ----------\n    exog : pandas Series, pandas DataFrame\n        Exogenous variables.\n    steps : int\n        Number of steps that will be predicted using exog.\n\n    Returns\n    -------\n    exog_direct : pandas DataFrame\n        Exogenous variables transformed.\n    exog_direct_names : list\n        Names of the columns of the exogenous variables transformed. Only \n        created if `exog` is a pandas Series or DataFrame.\n    \n    \"\"\"\n    if not isinstance(exog, (pd.Series, pd.DataFrame)):\n        raise TypeError(f'`exog` must be a pandas Series or DataFrame. Got {type(exog)}.')\n    if isinstance(exog, pd.Series):\n        exog = exog.to_frame()\n    n_rows = len(exog)\n    exog_idx = exog.index\n    exog_cols = exog.columns\n    exog_direct = []\n    for i in range(steps):\n        exog_step = exog.iloc[i:n_rows - (steps - 1 - i),]\n        exog_step.index = pd.RangeIndex(len(exog_step))\n        exog_step.columns = [f'{col}_step_{i + 1}' for col in exog_cols]\n        exog_direct.append(exog_step)\n    if len(exog_direct) > 1:\n        exog_direct = pd.concat(exog_direct, axis=1, copy=False)\n    else:\n        exog_direct = exog_direct[0]\n    exog_direct_names = exog_direct.columns.to_list()\n    exog_direct.index = exog_idx[-len(exog_direct):]\n    return (exog_direct, exog_direct_names)\n\ndef exog_to_direct_numpy(exog: Union[np.ndarray, pd.Series, pd.DataFrame], steps: int) -> Tuple[np.ndarray, Optional[list]]:\n    \"\"\"\n    Transforms `exog` to numpy ndarray with the shape needed for Direct\n    forecasting.\n    \n    Parameters\n    ----------\n    exog : numpy ndarray, pandas Series, pandas DataFrame\n        Exogenous variables, shape(samples,). If exog is a pandas format, the \n        direct exog names are created.\n    steps : int\n        Number of steps that will be predicted using exog.\n\n    Returns\n    -------\n    exog_direct : numpy ndarray\n        Exogenous variables transformed.\n    exog_direct_names : list, None\n        Names of the columns of the exogenous variables transformed. Only \n        created if `exog` is a pandas Series or DataFrame.\n\n    \"\"\"\n    if isinstance(exog, (pd.Series, pd.DataFrame)):\n        exog_cols = exog.columns if isinstance(exog, pd.DataFrame) else [exog.name]\n        exog_direct_names = [f'{col}_step_{i + 1}' for i in range(steps) for col in exog_cols]\n        exog = exog.to_numpy()\n    else:\n        exog_direct_names = None\n        if not isinstance(exog, np.ndarray):\n            raise TypeError(f'`exog` must be a numpy ndarray, pandas Series or DataFrame. Got {type(exog)}.')\n    if exog.ndim == 1:\n        exog = np.expand_dims(exog, axis=1)\n    n_rows = len(exog)\n    exog_direct = []\n    for i in range(steps):\n        exog_step = exog[i:n_rows - (steps - 1 - i)]\n        exog_direct.append(exog_step)\n    if len(exog_direct) > 1:\n        exog_direct = np.concatenate(exog_direct, axis=1)\n    else:\n        exog_direct = exog_direct[0]\n    return (exog_direct, exog_direct_names)\n\ndef date_to_index_position(index: pd.Index, date_input: Union[int, str, pd.Timestamp], date_literal: str='steps', kwargs_pd_to_datetime: dict={}) -> int:\n    \"\"\"\n    Transform a datetime string or pandas Timestamp to an integer. The integer\n    represents the position of the datetime in the index.\n    \n    Parameters\n    ----------\n    index : pandas Index\n        Original datetime index (must be a pandas DatetimeIndex if `date_input` \n        is not an int).\n    date_input : int, str, pandas Timestamp\n        Datetime to transform to integer.\n        \n        + If int, returns the same integer.\n        + If str or pandas Timestamp, it is converted and expanded into the index.\n    date_literal : str, default 'steps'\n        Variable name used in error messages.\n    kwargs_pd_to_datetime : dict, default {}\n        Additional keyword arguments to pass to `pd.to_datetime()`.\n    \n    Returns\n    -------\n    date_position : int\n        Integer representing the position of the datetime in the index.\n    \n    \"\"\"\n    if isinstance(date_input, (str, pd.Timestamp)):\n        if not isinstance(index, pd.DatetimeIndex):\n            raise TypeError(f'Index must be a pandas DatetimeIndex when `{date_literal}` is not an integer. Check input series or last window.')\n        target_date = pd.to_datetime(date_input, **kwargs_pd_to_datetime)\n        last_date = pd.to_datetime(index[-1])\n        if target_date <= last_date:\n            raise ValueError('The provided date must be later than the last date in the index.')\n        steps_diff = pd.date_range(start=last_date, end=target_date, freq=index.freq)\n        date_position = len(steps_diff) - 1\n    elif isinstance(date_input, (int, np.integer)):\n        date_position = date_input\n    else:\n        raise TypeError(f'`{date_literal}` must be an integer, string, or pandas Timestamp.')\n    return date_position\n\ndef expand_index(index: Union[pd.Index, None], steps: int) -> pd.Index:\n    \"\"\"\n    Create a new index of length `steps` starting at the end of the index.\n    \n    Parameters\n    ----------\n    index : pandas Index, None\n        Original index.\n    steps : int\n        Number of steps to expand.\n\n    Returns\n    -------\n    new_index : pandas Index\n        New index.\n\n    \"\"\"\n    if not isinstance(steps, (int, np.integer)):\n        raise TypeError(f'`steps` must be an integer. Got {type(steps)}.')\n    if isinstance(index, pd.Index):\n        if isinstance(index, pd.DatetimeIndex):\n            new_index = pd.date_range(start=index[-1] + index.freq, periods=steps, freq=index.freq)\n        elif isinstance(index, pd.RangeIndex):\n            new_index = pd.RangeIndex(start=index[-1] + 1, stop=index[-1] + 1 + steps)\n        else:\n            raise TypeError('Argument `index` must be a pandas DatetimeIndex or RangeIndex.')\n    else:\n        new_index = pd.RangeIndex(start=0, stop=steps)\n    return new_index\n\ndef transform_series(series: pd.Series, transformer, fit: bool=False, inverse_transform: bool=False) -> Union[pd.Series, pd.DataFrame]:\n    \"\"\"\n    Transform raw values of pandas Series with a scikit-learn alike \n    transformer, preprocessor or ColumnTransformer. The transformer used must \n    have the following methods: fit, transform, fit_transform and \n    inverse_transform. ColumnTransformers are not allowed since they do not \n    have inverse_transform method.\n\n    Parameters\n    ----------\n    series : pandas Series\n        Series to be transformed.\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\n        fit_transform and inverse_transform.\n    fit : bool, default `False`\n        Train the transformer before applying it.\n    inverse_transform : bool, default `False`\n        Transform back the data to the original representation. This is not available\n        when using transformers of class scikit-learn ColumnTransformers.\n\n    Returns\n    -------\n    series_transformed : pandas Series, pandas DataFrame\n        Transformed Series. Depending on the transformer used, the output may \n        be a Series or a DataFrame.\n\n    \"\"\"\n    if not isinstance(series, pd.Series):\n        raise TypeError(f'`series` argument must be a pandas Series. Got {type(series)}.')\n    if transformer is None:\n        return series\n    if series.name is None:\n        series.name = 'no_name'\n    data = series.to_frame()\n    if fit and hasattr(transformer, 'fit'):\n        transformer.fit(data)\n    if hasattr(transformer, 'feature_names_in_') and transformer.feature_names_in_[0] != data.columns[0]:\n        transformer = deepcopy(transformer)\n        transformer.feature_names_in_ = np.array([data.columns[0]], dtype=object)\n    with warnings.catch_warnings():\n        warnings.simplefilter('ignore', category=UserWarning)\n        if inverse_transform:\n            values_transformed = transformer.inverse_transform(data)\n        else:\n            values_transformed = transformer.transform(data)\n    if hasattr(values_transformed, 'toarray'):\n        values_transformed = values_transformed.toarray()\n    if isinstance(values_transformed, np.ndarray) and values_transformed.shape[1] == 1:\n        series_transformed = pd.Series(data=values_transformed.ravel(), index=data.index, name=data.columns[0])\n    elif isinstance(values_transformed, pd.DataFrame) and values_transformed.shape[1] == 1:\n        series_transformed = values_transformed.squeeze()\n    else:\n        series_transformed = pd.DataFrame(data=values_transformed, index=data.index, columns=transformer.get_feature_names_out())\n    return series_transformed\n\ndef transform_dataframe(df: pd.DataFrame, transformer, fit: bool=False, inverse_transform: bool=False) -> pd.DataFrame:\n    \"\"\"\n    Transform raw values of pandas DataFrame with a scikit-learn alike \n    transformer, preprocessor or ColumnTransformer. The transformer used must \n    have the following methods: fit, transform, fit_transform and \n    inverse_transform. ColumnTransformers are not allowed since they do not \n    have inverse_transform method.\n\n    Parameters\n    ----------\n    df : pandas DataFrame\n        DataFrame to be transformed.\n    transformer : scikit-learn alike transformer, preprocessor, or ColumnTransformer.\n        Scikit-learn alike transformer (preprocessor) with methods: fit, transform,\n        fit_transform and inverse_transform.\n    fit : bool, default `False`\n        Train the transformer before applying it.\n    inverse_transform : bool, default `False`\n        Transform back the data to the original representation. This is not available\n        when using transformers of class scikit-learn ColumnTransformers.\n\n    Returns\n    -------\n    df_transformed : pandas DataFrame\n        Transformed DataFrame.\n\n    \"\"\"\n    if not isinstance(df, pd.DataFrame):\n        raise TypeError(f'`df` argument must be a pandas DataFrame. Got {type(df)}')\n    if transformer is None:\n        return df\n    if inverse_transform and isinstance(transformer, ColumnTransformer):\n        raise ValueError('`inverse_transform` is not available when using ColumnTransformers.')\n    if not inverse_transform:\n        if fit:\n            values_transformed = transformer.fit_transform(df)\n        else:\n            values_transformed = transformer.transform(df)\n    else:\n        values_transformed = transformer.inverse_transform(df)\n    if hasattr(values_transformed, 'toarray'):\n        values_transformed = values_transformed.toarray()\n    if hasattr(transformer, 'get_feature_names_out'):\n        feature_names_out = transformer.get_feature_names_out()\n    elif hasattr(transformer, 'categories_'):\n        feature_names_out = transformer.categories_\n    else:\n        feature_names_out = df.columns\n    df_transformed = pd.DataFrame(data=values_transformed, index=df.index, columns=feature_names_out)\n    return df_transformed\n\ndef save_forecaster(forecaster: object, file_name: str, save_custom_functions: bool=True, verbose: bool=True) -> None:\n    \"\"\"\n    Save forecaster model using joblib. If custom functions are used to create\n    weights, they are saved as .py files.\n\n    Parameters\n    ----------\n    forecaster : Forecaster\n        Forecaster created with skforecast library.\n    file_name : str\n        File name given to the object. The save extension will be .joblib.\n    save_custom_functions : bool, default True\n        If True, save custom functions used in the forecaster (weight_func) as \n        .py files. Custom functions need to be available in the environment \n        where the forecaster is going to be loaded.\n    verbose : bool, default True\n        Print summary about the forecaster saved.\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n    file_name = Path(file_name).with_suffix('.joblib')\n    joblib.dump(forecaster, filename=file_name)\n    if save_custom_functions:\n        if hasattr(forecaster, 'weight_func') and forecaster.weight_func is not None:\n            if isinstance(forecaster.weight_func, dict):\n                for fun in set(forecaster.weight_func.values()):\n                    file_name = fun.__name__ + '.py'\n                    with open(file_name, 'w') as file:\n                        file.write(inspect.getsource(fun))\n            else:\n                file_name = forecaster.weight_func.__name__ + '.py'\n                with open(file_name, 'w') as file:\n                    file.write(inspect.getsource(forecaster.weight_func))\n    elif hasattr(forecaster, 'weight_func') and forecaster.weight_func is not None:\n        warnings.warn('Custom function(s) used to create weights are not saved. To save them, set `save_custom_functions` to `True`.', SaveLoadSkforecastWarning)\n    if hasattr(forecaster, 'window_features') and forecaster.window_features is not None:\n        skforecast_classes = {'RollingFeatures'}\n        custom_classes = set(forecaster.window_features_class_names) - skforecast_classes\n        if custom_classes:\n            warnings.warn('The Forecaster includes custom user-defined classes in the `window_features` argument. These classes are not saved automatically when saving the Forecaster. Please ensure you save these classes manually and import them before loading the Forecaster.\\n    Custom classes: ' + ', '.join(custom_classes) + '\\nVisit the documentation for more information: https://skforecast.org/latest/user_guides/save-load-forecaster.html#saving-and-loading-a-forecaster-model-with-custom-features', SaveLoadSkforecastWarning)\n    if verbose:\n        forecaster.summary()\n\ndef load_forecaster(file_name: str, verbose: bool=True) -> object:\n    \"\"\"\n    Load forecaster model using joblib. If the forecaster was saved with \n    custom user-defined classes as as window features or custom\n    functions to create weights, these objects must be available\n    in the environment where the forecaster is going to be loaded.\n\n    Parameters\n    ----------\n    file_name: str\n        Object file name.\n    verbose: bool, default `True`\n        Print summary about the forecaster loaded.\n\n    Returns\n    -------\n    forecaster: Forecaster\n        Forecaster created with skforecast library.\n    \n    \"\"\"\n    forecaster = joblib.load(filename=Path(file_name))\n    skforecast_v = skforecast.__version__\n    forecaster_v = forecaster.skforecast_version\n    if forecaster_v != skforecast_v:\n        warnings.warn(f'The skforecast version installed in the environment differs from the version used to create the forecaster.\\n    Installed Version  : {skforecast_v}\\n    Forecaster Version : {forecaster_v}\\nThis may create incompatibilities when using the library.', SkforecastVersionWarning)\n    if verbose:\n        forecaster.summary()\n    return forecaster\n\ndef _find_optional_dependency(package_name: str, optional_dependencies: dict=optional_dependencies) -> Tuple[str, str]:\n    \"\"\"\n    Find if a package is an optional dependency. If True, find the version and \n    the extension it belongs to.\n\n    Parameters\n    ----------\n    package_name : str\n        Name of the package to check.\n    optional_dependencies : dict, default `optional_dependencies`\n        Skforecast optional dependencies.\n\n    Returns\n    -------\n    extra: str\n        Name of the extra extension where the optional dependency is needed.\n    package_version: srt\n        Name and versions of the dependency.\n\n    \"\"\"\n    for extra, packages in optional_dependencies.items():\n        package_version = [package for package in packages if package_name in package]\n        if package_version:\n            return (extra, package_version[0])\n\ndef check_optional_dependency(package_name: str) -> None:\n    \"\"\"\n    Check if an optional dependency is installed, if not raise an ImportError  \n    with installation instructions.\n\n    Parameters\n    ----------\n    package_name : str\n        Name of the package to check.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n    if importlib.util.find_spec(package_name) is None:\n        try:\n            extra, package_version = _find_optional_dependency(package_name=package_name)\n            msg = f'''\\n'{package_name}' is an optional dependency not included in the default skforecast installation. Please run: `pip install \"{package_version}\"` to install it.\\n\\nAlternately, you can install it by running `pip install skforecast[{extra}]`'''\n        except:\n            msg = f\"\\n'{package_name}' is needed but not installed. Please install it.\"\n        raise ImportError(msg)\n\ndef multivariate_time_series_corr(time_series: pd.Series, other: pd.DataFrame, lags: Union[int, list, np.array], method: str='pearson') -> pd.DataFrame:\n    \"\"\"\n    Compute correlation between a time_series and the lagged values of other \n    time series. \n\n    Parameters\n    ----------\n    time_series : pandas Series\n        Target time series.\n    other : pandas DataFrame\n        Time series whose lagged values are correlated to `time_series`.\n    lags : int, list, numpy ndarray\n        Lags to be included in the correlation analysis.\n    method : str, default 'pearson'\n        - 'pearson': standard correlation coefficient.\n        - 'kendall': Kendall Tau correlation coefficient.\n        - 'spearman': Spearman rank correlation.\n\n    Returns\n    -------\n    corr : pandas DataFrame\n        Correlation values.\n\n    \"\"\"\n    if not len(time_series) == len(other):\n        raise ValueError('`time_series` and `other` must have the same length.')\n    if not (time_series.index == other.index).all():\n        raise ValueError('`time_series` and `other` must have the same index.')\n    if isinstance(lags, int):\n        lags = range(lags)\n    corr = {}\n    for col in other.columns:\n        lag_values = {}\n        for lag in lags:\n            lag_values[lag] = other[col].shift(lag)\n        lag_values = pd.DataFrame(lag_values)\n        lag_values.insert(0, None, time_series)\n        corr[col] = lag_values.corr(method=method).iloc[1:, 0]\n    corr = pd.DataFrame(corr)\n    corr.index = corr.index.astype('int64')\n    corr.index.name = 'lag'\n    return corr\n\ndef select_n_jobs_fit_forecaster(forecaster_name: str, regressor: object) -> int:\n    \"\"\"\n    Select the optimal number of jobs to use in the fitting process. This\n    selection is based on heuristics and is not guaranteed to be optimal. \n    \n    The number of jobs is chosen as follows:\n    \n    - If forecaster_name is 'ForecasterDirect' or 'ForecasterDirectMultiVariate'\n    and regressor_name is a linear regressor then `n_jobs = 1`, \n    otherwise `n_jobs = cpu_count() - 1`.\n    - If regressor is a `LGBMRegressor(n_jobs=1)`, then `n_jobs = cpu_count() - 1`.\n    - If regressor is a `LGBMRegressor` with internal n_jobs != 1, then `n_jobs = 1`.\n    This is because `lightgbm` is highly optimized for gradient boosting and\n    parallelizes operations at a very fine-grained level, making additional\n    parallelization unnecessary and potentially harmful due to resource contention.\n    \n    Parameters\n    ----------\n    forecaster_name : str\n        Forecaster name.\n    regressor : regressor or pipeline compatible with the scikit-learn API\n        An instance of a regressor or pipeline compatible with the scikit-learn API.\n\n    Returns\n    -------\n    n_jobs : int\n        The number of jobs to run in parallel.\n    \n    \"\"\"\n    if isinstance(regressor, Pipeline):\n        regressor = regressor[-1]\n        regressor_name = type(regressor).__name__\n    else:\n        regressor_name = type(regressor).__name__\n    linear_regressors = [regressor_name for regressor_name in dir(sklearn.linear_model) if not regressor_name.startswith('_')]\n    if forecaster_name in ['ForecasterDirect', 'ForecasterDirectMultiVariate']:\n        if regressor_name in linear_regressors:\n            n_jobs = 1\n        elif regressor_name == 'LGBMRegressor':\n            n_jobs = joblib.cpu_count() - 1 if regressor.n_jobs == 1 else 1\n        else:\n            n_jobs = joblib.cpu_count() - 1\n    else:\n        n_jobs = 1\n    return n_jobs\n\ndef check_preprocess_series(series: Union[pd.DataFrame, dict]) -> Tuple[dict, pd.Index]:\n    \"\"\"\n    Check and preprocess `series` argument in `ForecasterRecursiveMultiSeries` class.\n\n    - If `series` is a pandas DataFrame, it is converted to a dict of pandas \n    Series and index is overwritten according to the rules of preprocess_y.\n    - If `series` is a dict, all values are converted to pandas Series. Checks\n    if all index are pandas DatetimeIndex and, at least, one Series has a non-null\n    frequency. No multiple frequency is allowed.\n\n    Parameters\n    ----------\n    series : pandas DataFrame, dict\n        Training time series.\n\n    Returns\n    -------\n    series_dict : dict\n        Dictionary with the series used during training.\n    series_indexes : dict\n        Dictionary with the index of each series.\n    \n    \"\"\"\n    if isinstance(series, pd.DataFrame):\n        _, series_index = preprocess_y(y=series, return_values=False)\n        series = series.copy()\n        series.index = series_index\n        series_dict = series.to_dict('series')\n    elif isinstance(series, dict):\n        not_valid_series = [k for k, v in series.items() if not isinstance(v, (pd.Series, pd.DataFrame))]\n        if not_valid_series:\n            raise TypeError(f'If `series` is a dictionary, all series must be a named pandas Series or a pandas DataFrame with a single column. Review series: {not_valid_series}')\n        series_dict = {k: v.copy() for k, v in series.items()}\n        for k, v in series_dict.items():\n            if isinstance(v, pd.DataFrame):\n                if v.shape[1] != 1:\n                    raise ValueError(f\"If `series` is a dictionary, all series must be a named pandas Series or a pandas DataFrame with a single column. Review series: '{k}'\")\n                series_dict[k] = v.iloc[:, 0]\n            series_dict[k].name = k\n        not_valid_index = [k for k, v in series_dict.items() if not isinstance(v.index, pd.DatetimeIndex)]\n        if not_valid_index:\n            raise TypeError(f'If `series` is a dictionary, all series must have a Pandas DatetimeIndex as index with the same frequency. Review series: {not_valid_index}')\n        indexes_freq = [f'{v.index.freq}' for v in series_dict.values()]\n        indexes_freq = sorted(set(indexes_freq))\n        if not len(indexes_freq) == 1:\n            raise ValueError(f'If `series` is a dictionary, all series must have a Pandas DatetimeIndex as index with the same frequency. Found frequencies: {indexes_freq}')\n    else:\n        raise TypeError(f'`series` must be a pandas DataFrame or a dict of DataFrames or Series. Got {type(series)}.')\n    for k, v in series_dict.items():\n        if np.isnan(v).all():\n            raise ValueError(f\"All values of series '{k}' are NaN.\")\n    series_indexes = {k: v.index for k, v in series_dict.items()}\n    return (series_dict, series_indexes)\n\ndef check_preprocess_exog_multiseries(input_series_is_dict: bool, series_indexes: dict, series_names_in_: list, exog: Union[pd.Series, pd.DataFrame, dict], exog_dict: dict) -> Tuple[dict, list]:\n    \"\"\"\n    Check and preprocess `exog` argument in `ForecasterRecursiveMultiSeries` class.\n\n    - If input series is a pandas DataFrame (input_series_is_dict = False),  \n    checks that input exog (pandas Series, DataFrame or dict) has the same index \n    (type, length and frequency). Index is overwritten according to the rules \n    of preprocess_exog. Create a dict of exog with the same keys as series.\n    - If input series is a dict (input_series_is_dict = True), then input \n    exog must be a dict. Check exog has a pandas DatetimeIndex and convert all\n    values to pandas DataFrames.\n\n    Parameters\n    ----------\n    input_series_is_dict : bool\n        Indicates if input series argument is a dict.\n    series_indexes : dict\n        Dictionary with the index of each series.\n    series_names_in_ : list\n        Names of the series (levels) used during training.\n    exog : pandas Series, pandas DataFrame, dict\n        Exogenous variable/s used during training.\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n\n    Returns\n    -------\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n    exog_names_in_ : list\n        Names of the exogenous variables used during training.\n    \n    \"\"\"\n    if not isinstance(exog, (pd.Series, pd.DataFrame, dict)):\n        raise TypeError(f'`exog` must be a pandas Series, DataFrame, dictionary of pandas Series/DataFrames or None. Got {type(exog)}.')\n    if not input_series_is_dict:\n        series_index = series_indexes[series_names_in_[0]]\n    if isinstance(exog, (pd.Series, pd.DataFrame)):\n        if input_series_is_dict:\n            raise TypeError(f'`exog` must be a dict of DataFrames or Series if `series` is a dict. Got {type(exog)}.')\n        _, exog_index = preprocess_exog(exog=exog, return_values=False)\n        exog = exog.copy().to_frame() if isinstance(exog, pd.Series) else exog.copy()\n        exog.index = exog_index\n        if len(exog) != len(series_index):\n            raise ValueError(f'`exog` must have same number of samples as `series`. length `exog`: ({len(exog)}), length `series`: ({len(series_index)})')\n        if not (exog_index == series_index).all():\n            raise ValueError('Different index for `series` and `exog`. They must be equal to ensure the correct alignment of values.')\n        exog_dict = {serie: exog for serie in series_names_in_}\n    else:\n        not_valid_exog = [k for k, v in exog.items() if not isinstance(v, (pd.Series, pd.DataFrame, type(None)))]\n        if not_valid_exog:\n            raise TypeError(f'If `exog` is a dictionary, all exog must be a named pandas Series, a pandas DataFrame or None. Review exog: {not_valid_exog}')\n        exog_dict.update(((k, v.copy()) for k, v in exog.items() if k in exog_dict and v is not None))\n        series_not_in_exog = set(series_names_in_) - set(exog.keys())\n        if series_not_in_exog:\n            warnings.warn(f'{series_not_in_exog} not present in `exog`. All values of the exogenous variables for these series will be NaN.', MissingExogWarning)\n        for k, v in exog_dict.items():\n            if v is not None:\n                check_exog(exog=v, allow_nan=True)\n                if isinstance(v, pd.Series):\n                    v = v.to_frame()\n                exog_dict[k] = v\n        if not input_series_is_dict:\n            for k, v in exog_dict.items():\n                if v is not None:\n                    if len(v) != len(series_index):\n                        raise ValueError(f\"`exog` for series '{k}' must have same number of samples as `series`. length `exog`: ({len(v)}), length `series`: ({len(series_index)})\")\n                    _, v_index = preprocess_exog(exog=v, return_values=False)\n                    exog_dict[k].index = v_index\n                    if not (exog_dict[k].index == series_index).all():\n                        raise ValueError(f\"Different index for series '{k}' and its exog. When `series` is a pandas DataFrame, they must be equal to ensure the correct alignment of values.\")\n        else:\n            not_valid_index = [k for k, v in exog_dict.items() if v is not None and (not isinstance(v.index, pd.DatetimeIndex))]\n            if not_valid_index:\n                raise TypeError(f'All exog must have a Pandas DatetimeIndex as index with the same frequency. Check exog for series: {not_valid_index}')\n        exog_dtypes_buffer = [df.dtypes for df in exog_dict.values() if df is not None]\n        exog_dtypes_buffer = pd.concat(exog_dtypes_buffer, axis=1)\n        exog_dtypes_nunique = exog_dtypes_buffer.nunique(axis=1).eq(1)\n        if not exog_dtypes_nunique.all():\n            non_unique_dtyeps_exogs = exog_dtypes_nunique[exog_dtypes_nunique != 1].index.to_list()\n            raise TypeError(f'Exog/s: {non_unique_dtyeps_exogs} have different dtypes in different series.')\n    exog_names_in_ = list(set((column for df in exog_dict.values() if df is not None for column in df.columns.to_list())))\n    if len(set(exog_names_in_) - set(series_names_in_)) != len(exog_names_in_):\n        raise ValueError(f'`exog` cannot contain a column named the same as one of the series.\\n    `series` columns : {series_names_in_}.\\n    `exog`   columns : {exog_names_in_}.')\n    return (exog_dict, exog_names_in_)\n\ndef align_series_and_exog_multiseries(series_dict: dict, input_series_is_dict: bool, exog_dict: dict=None) -> Tuple[Union[pd.Series, pd.DataFrame], Union[pd.Series, pd.DataFrame]]:\n    \"\"\"\n    Align series and exog according to their index. If needed, reindexing is\n    applied. Heading and trailing NaNs are removed from all series in \n    `series_dict`.\n\n    - If input series is a pandas DataFrame (input_series_is_dict = False),  \n    input exog (pandas Series, DataFrame or dict) must have the same index \n    (type, length and frequency). Reindexing is not applied.\n    - If input series is a dict (input_series_is_dict = True), then input \n    exog must be a dict. Both must have a pandas DatetimeIndex, but can have \n    different lengths. Reindexing is applied.\n\n    Parameters\n    ----------\n    series_dict : dict\n        Dictionary with the series used during training.\n    input_series_is_dict : bool\n        Indicates if input series argument is a dict.\n    exog_dict : dict, default `None`\n        Dictionary with the exogenous variable/s used during training.\n\n    Returns\n    -------\n    series_dict : dict\n        Dictionary with the series used during training.\n    exog_dict : dict\n        Dictionary with the exogenous variable/s used during training.\n    \n    \"\"\"\n    for k in series_dict.keys():\n        first_valid_index = series_dict[k].first_valid_index()\n        last_valid_index = series_dict[k].last_valid_index()\n        series_dict[k] = series_dict[k].loc[first_valid_index:last_valid_index]\n        if exog_dict[k] is not None:\n            if input_series_is_dict:\n                index_intersection = series_dict[k].index.intersection(exog_dict[k].index)\n                if len(index_intersection) == 0:\n                    warnings.warn(f\"Series '{k}' and its `exog` do not have the same index. All exog values will be NaN for the period of the series.\", MissingValuesWarning)\n                elif len(index_intersection) != len(series_dict[k]):\n                    warnings.warn(f\"Series '{k}' and its `exog` do not have the same length. Exog values will be NaN for the not matched period of the series.\", MissingValuesWarning)\n                exog_dict[k] = exog_dict[k].loc[index_intersection]\n                if len(index_intersection) != len(series_dict[k]):\n                    exog_dict[k] = exog_dict[k].reindex(series_dict[k].index, fill_value=np.nan)\n            else:\n                exog_dict[k] = exog_dict[k].loc[first_valid_index:last_valid_index]\n    return (series_dict, exog_dict)\n\ndef prepare_levels_multiseries(X_train_series_names_in_: list, levels: Optional[Union[str, list]]=None) -> Tuple[list, bool]:\n    \"\"\"\n    Prepare list of levels to be predicted in multiseries Forecasters.\n\n    Parameters\n    ----------\n    X_train_series_names_in_ : list\n        Names of the series (levels) included in the matrix `X_train`.\n    levels : str, list, default `None`\n        Names of the series (levels) to be predicted.\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n\n    \"\"\"\n    input_levels_is_list = False\n    if levels is None:\n        levels = X_train_series_names_in_\n    elif isinstance(levels, str):\n        levels = [levels]\n    else:\n        input_levels_is_list = True\n    return (levels, input_levels_is_list)\n\ndef preprocess_levels_self_last_window_multiseries(levels: list, input_levels_is_list: bool, last_window_: dict) -> Tuple[list, pd.DataFrame]:\n    \"\"\"\n    Preprocess `levels` and `last_window` (when using self.last_window_) arguments \n    in multiseries Forecasters when predicting. Only levels whose last window \n    ends at the same datetime index will be predicted together.\n\n    Parameters\n    ----------\n    levels : list\n        Names of the series (levels) to be predicted.\n    input_levels_is_list : bool\n        Indicates if input levels argument is a list.\n    last_window_ : dict\n        Dictionary with the last window of each series (self.last_window_).\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n    last_window : pandas DataFrame\n        Series values used to create the predictors (lags) needed in the \n        first iteration of the prediction (t + 1).\n\n    \"\"\"\n    available_last_windows = set() if last_window_ is None else set(last_window_.keys())\n    not_available_last_window = set(levels) - available_last_windows\n    if not_available_last_window:\n        levels = [level for level in levels if level not in not_available_last_window]\n        if not levels:\n            raise ValueError(f'No series to predict. None of the series {not_available_last_window} are present in `last_window_` attribute. Provide `last_window` as argument in predict method.')\n        else:\n            warnings.warn(f\"Levels {not_available_last_window} are excluded from prediction since they were not stored in `last_window_` attribute during training. If you don't want to retrain the Forecaster, provide `last_window` as argument.\", IgnoredArgumentWarning)\n    last_index_levels = [v.index[-1] for k, v in last_window_.items() if k in levels]\n    if len(set(last_index_levels)) > 1:\n        max_index_levels = max(last_index_levels)\n        selected_levels = [k for k, v in last_window_.items() if k in levels and v.index[-1] == max_index_levels]\n        series_excluded_from_last_window = set(levels) - set(selected_levels)\n        levels = selected_levels\n        if input_levels_is_list and series_excluded_from_last_window:\n            warnings.warn(f\"Only series whose last window ends at the same index can be predicted together. Series that do not reach the maximum index, '{max_index_levels}', are excluded from prediction: {series_excluded_from_last_window}.\", IgnoredArgumentWarning)\n    last_window = pd.DataFrame({k: v for k, v in last_window_.items() if k in levels})\n    return (levels, last_window)\n\ndef prepare_residuals_multiseries(levels: list, use_in_sample_residuals: bool, encoding: Optional[str]=None, in_sample_residuals_: Optional[dict]=None, out_sample_residuals_: Optional[dict]=None) -> Tuple[list, bool]:\n    \"\"\"\n    Prepare residuals for bootstrapping prediction in multiseries Forecasters.\n\n    Parameters\n    ----------\n    levels : list\n        Names of the series (levels) to be predicted.\n    use_in_sample_residuals : bool\n        Indicates if `forecaster.in_sample_residuals_` are used.\n    encoding : str, default `None`\n        Encoding used to identify the different series (`ForecasterRecursiveMultiSeries`).\n    in_sample_residuals_ : dict, default `None`\n        Residuals of the model when predicting training data. Only stored up to\n        1000 values in the form `{level: residuals}`. If `transformer_series` \n        is not `None`, residuals are stored in the transformed scale.\n    out_sample_residuals_ : dict, default `None`\n        Residuals of the model when predicting non-training data. Only stored\n        up to 1000 values in the form `{level: residuals}`. If `transformer_series` \n        is not `None`, residuals are assumed to be in the transformed scale. Use \n        `set_out_sample_residuals()` method to set values.\n\n    Returns\n    -------\n    levels : list\n        Names of the series (levels) to be predicted.\n    residuals : dict\n        Residuals of the model for each level to use in bootstrapping prediction.\n\n    \"\"\"\n    if use_in_sample_residuals:\n        unknown_levels = set(levels) - set(in_sample_residuals_.keys())\n        if unknown_levels and encoding is not None:\n            warnings.warn(f'`levels` {unknown_levels} are not present in `forecaster.in_sample_residuals_`, most likely because they were not present in the training data. A random sample of the residuals from other levels will be used. This can lead to inaccurate intervals for the unknown levels.', UnknownLevelWarning)\n        residuals = in_sample_residuals_.copy()\n    elif out_sample_residuals_ is None:\n        raise ValueError('`forecaster.out_sample_residuals_` is `None`. Use `use_in_sample_residuals=True` or the `set_out_sample_residuals()` method before predicting.')\n    else:\n        unknown_levels = set(levels) - set(out_sample_residuals_.keys())\n        if unknown_levels and encoding is not None:\n            warnings.warn(f'`levels` {unknown_levels} are not present in `forecaster.out_sample_residuals_`. A random sample of the residuals from other levels will be used. This can lead to inaccurate intervals for the unknown levels. Otherwise, Use the `set_out_sample_residuals()` method before predicting to set the residuals for these levels.', UnknownLevelWarning)\n        residuals = out_sample_residuals_.copy()\n    check_residuals = 'forecaster.in_sample_residuals_' if use_in_sample_residuals else 'forecaster.out_sample_residuals_'\n    for level in levels:\n        if level in unknown_levels:\n            residuals[level] = residuals['_unknown_level']\n        if residuals[level] is None or len(residuals[level]) == 0:\n            raise ValueError(f\"Not available residuals for level '{level}'. Check `{check_residuals}`.\")\n        elif any((element is None for element in residuals[level])) or np.any(np.isnan(residuals[level])):\n            raise ValueError(f\"forecaster residuals for level '{level}' contains `None` or `NaNs` values. Check `{check_residuals}`.\")\n    return residuals\n\ndef prepare_steps_direct(max_step: int, steps: Optional[Union[int, list]]=None) -> list:\n    \"\"\"\n    Prepare list of steps to be predicted in Direct Forecasters.\n\n    Parameters\n    ----------\n    max_step : int\n        Maximum number of future steps the forecaster will predict \n        when using method `predict()`.\n    steps : int, list, None, default `None`\n        Predict n steps. The value of `steps` must be less than or equal to the \n        value of steps defined when initializing the forecaster. Starts at 1.\n    \n        - If `int`: Only steps within the range of 1 to int are predicted.\n        - If `list`: List of ints. Only the steps contained in the list \n        are predicted.\n        - If `None`: As many steps are predicted as were defined at \n        initialization.\n\n    Returns\n    -------\n    steps : list\n        Steps to be predicted.\n\n    \"\"\"\n    if isinstance(steps, int):\n        steps = list(np.arange(steps) + 1)\n    elif steps is None:\n        steps = list(np.arange(max_step) + 1)\n    elif isinstance(steps, list):\n        steps = list(np.array(steps))\n    for step in steps:\n        if not isinstance(step, (int, np.int64, np.int32)):\n            raise TypeError(f'`steps` argument must be an int, a list of ints or `None`. Got {type(steps)}.')\n    steps = [int(step) for step in steps if step is not None]\n    return steps\n\ndef set_skforecast_warnings(suppress_warnings: bool, action: str='default') -> None:\n    \"\"\"\n    Set skforecast warnings action.\n\n    Parameters\n    ----------\n    suppress_warnings : bool\n        If `True`, skforecast warnings will be suppressed. If `False`, skforecast\n        warnings will be shown as default. See \n        skforecast.exceptions.warn_skforecast_categories for more information.\n    action : str, default `'default'`\n        Action to be taken when a warning is raised. See the warnings module\n        for more information.\n\n    Returns\n    -------\n    None\n    \n    \"\"\"\n    if suppress_warnings:\n        for category in warn_skforecast_categories:\n            warnings.filterwarnings(action, category=category)"
  },
  "call_tree": {
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_TypeError_when_array_is_not_numpy_ndarray": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_when_transformer_is_None": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_ValueError_when_transformer_is_ColumnTransformer_and_inverse_transform_is_true": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_when_transformer_is_StandardScaler": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_when_transformer_is_StandardScaler_and_inverse_transform_is_True": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_when_transformer_is_OneHotEncoder": {
      "skforecast/utils/utils.py:transform_numpy": {}
    },
    "skforecast/utils/tests/tests_utils/test_transform_numpy.py:test_transform_numpy_when_transformer_is_ColumnTransformer": {
      "skforecast/utils/utils.py:transform_numpy": {}
    }
  }
}