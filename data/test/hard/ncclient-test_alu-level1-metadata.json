{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_alu",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_alu.py",
  "test_code": "import unittest\nfrom ncclient.devices.alu import *\nfrom ncclient.xml_ import *\nimport re\n\n\nxml = \"\"\"<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">\n<routing-engin>\n<name>reX</name>\n<commit-success/>\n<!-- This is a comment -->\n</routing-engin>\n<ok/>\n</rpc-reply>\"\"\"\n\n\nclass TestAluDevice(unittest.TestCase):\n    \n    def setUp(self):\n        self.obj = AluDeviceHandler({'name': 'alu'})\n\n    def test_remove_namespaces(self):\n        xmlObj = to_ele(xml)\n        expected = re.sub(r'<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">',\n                          r'<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc-reply>', xml)\n        self.assertEqual(expected, to_xml(remove_namespaces(xmlObj)))\n\n    def test_get_capabilities(self):\n        expected = [\"urn:ietf:params:netconf:base:1.0\", ]\n        self.assertListEqual(expected, self.obj.get_capabilities())\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.obj.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected[\"nsmap\"] = self.obj.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n\n    def test_add_additional_operations(self):\n        expected=dict()\n        expected[\"get_configuration\"] = GetConfiguration\n        expected[\"show_cli\"] = ShowCLI\n        expected[\"load_configuration\"] = LoadConfiguration\n        self.assertDictEqual(expected, self.obj.add_additional_operations())\n    \n    def test_transform_reply(self):\n        expected = re.sub(r'<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">',\n                          r'<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc-reply>', xml)\n        actual = self.obj.transform_reply()\n        xmlObj = to_ele(xml)\n        self.assertEqual(expected, to_xml(actual(xmlObj)))\n",
  "GT_file_code": {
    "ncclient/devices/alu.py": "from lxml import etree\n\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.alu.rpc import GetConfiguration, LoadConfiguration, ShowCLI\nfrom ncclient.xml_ import BASE_NS_1_0\n\n\ndef remove_namespaces(xml):\n\n    for elem in xml.getiterator():\n        if elem.tag is etree.Comment:\n            continue\n        i = elem.tag.find('}')\n        if i > 0:\n            elem.tag = elem.tag[i + 1:]\n\n    etree.cleanup_namespaces(xml)\n    return xml\n\n\nclass AluDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Alcatel-Lucent 7x50 handler for device specific information.\n    \"\"\"\n\n    def __init__(self, device_params):\n        super(AluDeviceHandler, self).__init__(device_params)\n\n    def get_capabilities(self):\n        return [\n            \"urn:ietf:params:netconf:base:1.0\",\n        ]\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def add_additional_operations(self):\n        dict = {}\n        dict[\"get_configuration\"] = GetConfiguration\n        dict[\"show_cli\"] = ShowCLI\n        dict[\"load_configuration\"] = LoadConfiguration\n        return dict\n\n    def transform_reply(self):\n        return remove_namespaces\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/xml_.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\n\n\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\n\n# In case issues come up with XML generation/parsing\n# make sure you have the ElementTree v1.2.7+ lib as\n# well as lxml v3.0+\n\nfrom ncclient import NCClientError\n\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\n\nclass XMLError(NCClientError):\n    pass\n\n### Namespace-related\n\n#: Base NETCONF namespace\nBASE_NS_1_0 = \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n#: YANG (RFC 6020/RFC 7950) namespace\nYANG_NS_1_0 = \"urn:ietf:params:xml:ns:yang:1\"\n#: NXOS_1_0\nNXOS_1_0 = \"http://www.cisco.com/nxos:1.0\"\n#: NXOS_IF\nNXOS_IF = \"http://www.cisco.com/nxos:1.0:if_manager\"\n#: Namespace for Tail-f core data model\nTAILF_AAA_1_1 = \"http://tail-f.com/ns/aaa/1.1\"\n#: Namespace for Tail-f execd data model\nTAILF_EXECD_1_1 = \"http://tail-f.com/ns/execd/1.1\"\n#: Namespace for Cisco data model\nCISCO_CPI_1_0 = \"http://www.cisco.com/cpi_10/schema\"\n#: Namespace for Flowmon data model\nFLOWMON_1_0 = \"http://www.liberouter.org/ns/netopeer/flowmon/1.0\"\n#: Namespace for Juniper 9.6R4. Tested with Junos 9.6R4+\nJUNIPER_1_1 = \"http://xml.juniper.net/xnm/1.1/xnm\"\n#: Namespace for Huawei data model\nHUAWEI_NS = \"http://www.huawei.com/netconf/vrp\"\n#: Namespace for Huawei private\nHW_PRIVATE_NS = \"http://www.huawei.com/netconf/capability/base/1.0\"\n#: Namespace for H3C data model\nH3C_DATA_1_0 = \"http://www.h3c.com/netconf/data:1.0\"\n#: Namespace for H3C config model\nH3C_CONFIG_1_0 = \"http://www.h3c.com/netconf/config:1.0\"\n#: Namespace for H3C action model\nH3C_ACTION_1_0 = \"http://www.h3c.com/netconf/action:1.0\"\n#: Namespace for netconf monitoring\nNETCONF_MONITORING_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\"\n#: Namespace for netconf notifications\nNETCONF_NOTIFICATION_NS = \"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n#: Namespace for netconf with-defaults (RFC 6243)\nNETCONF_WITH_DEFAULTS_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\"\n#: Namespace for Alcatel-Lucent SR OS Base r13 YANG models\nALU_CONFIG = \"urn:alcatel-lucent.com:sros:ns:yang:conf-r13\"\n#: Namespace for Nokia SR OS global operations\nSROS_GLOBAL_OPS_NS = \"urn:nokia.com:sros:ns:yang:sr:oper-global\"\n\n\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        # cElementTree uses ElementTree's _namespace_map, so that's ok\n        ElementTree._namespace_map[uri] = prefix\n\nfor (ns, pre) in six.iteritems({\n    BASE_NS_1_0: 'nc',\n    NETCONF_MONITORING_NS: 'ncm',\n    NXOS_1_0: 'nxos',\n    NXOS_IF: 'if',\n    TAILF_AAA_1_1: 'aaa',\n    TAILF_EXECD_1_1: 'execd',\n    CISCO_CPI_1_0: 'cpi',\n    FLOWMON_1_0: 'fm',\n    JUNIPER_1_1: 'junos',\n}):\n    register_namespace(pre, ns)\n\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else \"{%s}%s\" % (ns, tag)\n\"\"\"Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.\"\"\"\n\n\ndef to_xml(ele, encoding=\"UTF-8\", pretty_print=False):\n    \"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') \\\n            else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\n\ndef parse_root(raw):\n    \"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError(\"Element [%s] does not meet requirement\" % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)): req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError(\"Element [%s] does not have required attributes\" % ele.tag)\n    return ele\n\nXPATH_NAMESPACES = {\n    're':'http://exslt.org/regular-expressions'\n}\n\n\nclass NCElement(object):\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt=self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)),\n                                                                        parser=self.__parser))),\n                                       parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        # Comments don't have a namespace\n        if elem.tag is not etree.Comment:\n            # handle tag\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n\n            # handle attributes\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\n\n\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\n\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\n\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag,ns), attrs, **extra)\n\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\n\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)\n"
  },
  "GT_src_dict": {
    "ncclient/devices/alu.py": {
      "remove_namespaces": {
        "code": "def remove_namespaces(xml):\n    \"\"\"Remove namespaces from an XML element tree.\n\nThis function iterates through all elements in the provided XML tree, stripping any namespace qualifiers from the tags. It also performs cleanup of the namespaces after the modifications. XML comments are skipped during the processing. \n\nParameters:\n- xml (etree.ElementTree): An XML element tree from which namespaces should be removed.\n\nReturns:\n- etree.ElementTree: The modified XML element tree with namespaces removed.\n\nDependencies:\n- This function relies on the `etree` module from the `lxml` library for XML processing. The `cleanup_namespaces` method is used to clean up any unused namespace definitions after the modifications.\"\"\"\n    for elem in xml.getiterator():\n        if elem.tag is etree.Comment:\n            continue\n        i = elem.tag.find('}')\n        if i > 0:\n            elem.tag = elem.tag[i + 1:]\n    etree.cleanup_namespaces(xml)\n    return xml",
        "docstring": "Remove namespaces from an XML element tree.\n\nThis function iterates through all elements in the provided XML tree, stripping any namespace qualifiers from the tags. It also performs cleanup of the namespaces after the modifications. XML comments are skipped during the processing. \n\nParameters:\n- xml (etree.ElementTree): An XML element tree from which namespaces should be removed.\n\nReturns:\n- etree.ElementTree: The modified XML element tree with namespaces removed.\n\nDependencies:\n- This function relies on the `etree` module from the `lxml` library for XML processing. The `cleanup_namespaces` method is used to clean up any unused namespace definitions after the modifications.",
        "signature": "def remove_namespaces(xml):",
        "type": "Function",
        "class_signature": null
      },
      "AluDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initializes an instance of the AluDeviceHandler class, which is a specialized handler for the Alcatel-Lucent 7x50 devices. \n\nParameters:\n- device_params (dict): A dictionary containing parameters specific to the device configuration. This is passed to the superclass constructor to initialize common device handling attributes and functionality.\n\nReturns:\n- None: This constructor does not return a value but initializes the instance state.\n\nDependencies:\n- The constructor calls the superclass's initializer from the DefaultDeviceHandler class, which is expected to implement core device handling features. This establishes the context for any device operations that may be added later in the AluDeviceHandler class.\"\"\"\n        super(AluDeviceHandler, self).__init__(device_params)",
        "docstring": "Initializes an instance of the AluDeviceHandler class, which is a specialized handler for the Alcatel-Lucent 7x50 devices. \n\nParameters:\n- device_params (dict): A dictionary containing parameters specific to the device configuration. This is passed to the superclass constructor to initialize common device handling attributes and functionality.\n\nReturns:\n- None: This constructor does not return a value but initializes the instance state.\n\nDependencies:\n- The constructor calls the superclass's initializer from the DefaultDeviceHandler class, which is expected to implement core device handling features. This establishes the context for any device operations that may be added later in the AluDeviceHandler class.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Returns the capabilities of the Alcatel-Lucent 7x50 device in the context of NETCONF operations.\n\nThis method does not take any parameters and returns a list containing the capabilities that the device supports. In this implementation, the returned capability is the base namespace URI for NETCONF (urn:ietf:params:netconf:base:1.0), indicating compliance with the NETCONF protocol version 1.0. This capability allows for the negotiation of features and determines the functionality available when interacting with the device.\"\"\"\n        return ['urn:ietf:params:netconf:base:1.0']",
        "docstring": "Returns the capabilities of the Alcatel-Lucent 7x50 device in the context of NETCONF operations.\n\nThis method does not take any parameters and returns a list containing the capabilities that the device supports. In this implementation, the returned capability is the base namespace URI for NETCONF (urn:ietf:params:netconf:base:1.0), indicating compliance with the NETCONF protocol version 1.0. This capability allows for the negotiation of features and determines the functionality available when interacting with the device.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary mapping XML namespaces for the Alcatel-Lucent 7x50 device handler. The function creates a dictionary that associates the `None` key with the base XML namespace constant `BASE_NS_1_0`, imported from `ncclient.xml_`. This namespace is essential for ensuring that XML elements are appropriately defined according to the NETCONF protocol standards. The method expects no input parameters and returns a dictionary used in XML operations to maintain namespace integrity during requests and responses.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary mapping XML namespaces for the Alcatel-Lucent 7x50 device handler. The function creates a dictionary that associates the `None` key with the base XML namespace constant `BASE_NS_1_0`, imported from `ncclient.xml_`. This namespace is essential for ensuring that XML elements are appropriately defined according to the NETCONF protocol standards. The method expects no input parameters and returns a dictionary used in XML operations to maintain namespace integrity during requests and responses.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing XML namespace mappings for the Alcatel-Lucent device. This method retrieves base namespace information from the `get_xml_base_namespace_dict` method and prepares it in a format suitable for XML processing by returning a dictionary with the key `nsmap`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, provides the base namespace for NETCONF protocol operations, ensuring proper namespace handling in XML messages exchanged with the device.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing XML namespace mappings for the Alcatel-Lucent device. This method retrieves base namespace information from the `get_xml_base_namespace_dict` method and prepares it in a format suitable for XML processing by returning a dictionary with the key `nsmap`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, provides the base namespace for NETCONF protocol operations, ensuring proper namespace handling in XML messages exchanged with the device.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Add additional NETCONF operations specific to the Alcatel-Lucent 7x50 device.\n\nThis method defines and returns a dictionary of additional operations that can\nbe performed on the Alcatel-Lucent device. The dictionary maps operation names \nto their respective classes: GetConfiguration, ShowCLI, and LoadConfiguration.\n\nReturns:\n    dict: A dictionary with operation names as keys and their associated \n    operation classes as values.\n\nDependencies:\n- GetConfiguration, ShowCLI, LoadConfiguration: These are classes imported \n  from the `ncclient.operations.third_party.alu.rpc` module that represent \n  different NETCONF operations for device configuration and management.\"\"\"\n        dict = {}\n        dict['get_configuration'] = GetConfiguration\n        dict['show_cli'] = ShowCLI\n        dict['load_configuration'] = LoadConfiguration\n        return dict",
        "docstring": "Add additional NETCONF operations specific to the Alcatel-Lucent 7x50 device.\n\nThis method defines and returns a dictionary of additional operations that can\nbe performed on the Alcatel-Lucent device. The dictionary maps operation names \nto their respective classes: GetConfiguration, ShowCLI, and LoadConfiguration.\n\nReturns:\n    dict: A dictionary with operation names as keys and their associated \n    operation classes as values.\n\nDependencies:\n- GetConfiguration, ShowCLI, LoadConfiguration: These are classes imported \n  from the `ncclient.operations.third_party.alu.rpc` module that represent \n  different NETCONF operations for device configuration and management.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.transform_reply": {
        "code": "    def transform_reply(self):\n        \"\"\"Transforms the reply from the device by removing XML namespaces.\n\nThis method returns a reference to the `remove_namespaces` function, which is used to process XML data by stripping out any namespaces present in the elements, thus simplifying the XML structure for easier manipulation or analysis. \n\nNo input parameters are required for this method, and it does not produce a direct output, but instead provides a callable function that can be used to transform XML replies. The `remove_namespaces` function is defined outside of this class and operates on an XML object, ensuring that any namespaces are cleaned up before further processing of the device's configuration data.\"\"\"\n        return remove_namespaces",
        "docstring": "Transforms the reply from the device by removing XML namespaces.\n\nThis method returns a reference to the `remove_namespaces` function, which is used to process XML data by stripping out any namespaces present in the elements, thus simplifying the XML structure for easier manipulation or analysis. \n\nNo input parameters are required for this method, and it does not produce a direct output, but instead provides a callable function that can be used to transform XML replies. The `remove_namespaces` function is defined outside of this class and operates on an XML object, ensuring that any namespaces are cleaned up before further processing of the device's configuration data.",
        "signature": "def transform_reply(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/xml_.py": {
      "to_xml": {
        "code": "def to_xml(ele, encoding='UTF-8', pretty_print=False):\n    \"\"\"Convert an ElementTree element (*ele*) into a well-formed XML string with specified encoding and optional pretty printing.\n\nParameters:\n- ele: An instance of :class:`~xml.etree.ElementTree.Element` representing the XML element to be converted.\n- encoding: A string specifying the character encoding for the XML output (default is \"UTF-8\").\n- pretty_print: A boolean indicating whether to format the XML with indentation and newlines for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element. If the XML does not start with the XML declaration (e.g., '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'), it is prepended with the appropriate declaration based on the specified encoding.\n\nDependencies:\n- The function relies on the `etree` module from the `lxml` package for XML processing, particularly the `etree.tostring()` method for converting elements to strings.\n- It also checks `sys.version` to handle differences in string handling between Python 2 and Python 3, allowing for backward compatibility.\"\"\"\n    'Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.'\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))",
        "docstring": "Convert an ElementTree element (*ele*) into a well-formed XML string with specified encoding and optional pretty printing.\n\nParameters:\n- ele: An instance of :class:`~xml.etree.ElementTree.Element` representing the XML element to be converted.\n- encoding: A string specifying the character encoding for the XML output (default is \"UTF-8\").\n- pretty_print: A boolean indicating whether to format the XML with indentation and newlines for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element. If the XML does not start with the XML declaration (e.g., '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'), it is prepended with the appropriate declaration based on the specified encoding.\n\nDependencies:\n- The function relies on the `etree` module from the `lxml` package for XML processing, particularly the `etree.tostring()` method for converting elements to strings.\n- It also checks `sys.version` to handle differences in string handling between Python 2 and Python 3, allowing for backward compatibility.",
        "signature": "def to_xml(ele, encoding='UTF-8', pretty_print=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_ele": {
        "code": "def to_ele(x, huge_tree=False):\n    \"\"\"Converts a given XML document or an existing XML Element into an `ElementTree.Element`. If the input is already an `ElementTree.Element`, it is returned as is. The function supports parsing XML documents with very deep trees and long text content through the `huge_tree` parameter.\n\nParameters:\n- x: The XML document as a string or an already parsed `ElementTree.Element`.\n- huge_tree (bool): A flag indicating whether to allow parsing of extremely deep or complex XML structures (default is False).\n\nReturns:\n- An instance of `xml.etree.ElementTree.Element`, either from the parsed XML if it was a string or the original element if it was already of the correct type.\n\nThis function uses the `etree` module from `lxml` for parsing and depends on the `_get_parser` function, which utilizes `parser` and `huge_parser` constants to select the appropriate parser based on the `huge_tree` flag.\"\"\"\n    'Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\\n\\n    *huge_tree*: parse XML with very deep trees and very long text content\\n    '\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))",
        "docstring": "Converts a given XML document or an existing XML Element into an `ElementTree.Element`. If the input is already an `ElementTree.Element`, it is returned as is. The function supports parsing XML documents with very deep trees and long text content through the `huge_tree` parameter.\n\nParameters:\n- x: The XML document as a string or an already parsed `ElementTree.Element`.\n- huge_tree (bool): A flag indicating whether to allow parsing of extremely deep or complex XML structures (default is False).\n\nReturns:\n- An instance of `xml.etree.ElementTree.Element`, either from the parsed XML if it was a string or the original element if it was already of the correct type.\n\nThis function uses the `etree` module from `lxml` for parsing and depends on the `_get_parser` function, which utilizes `parser` and `huge_parser` constants to select the appropriate parser based on the `huge_tree` flag.",
        "signature": "def to_ele(x, huge_tree=False):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/alu.py:AluDeviceHandler:__init__": {
      "ncclient/devices/default.py": {
        "DefaultDeviceHandler.__init__": {
          "code": "    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
          "docstring": "",
          "signature": "def __init__(self, device_params=None):",
          "type": "Method",
          "class_signature": "class DefaultDeviceHandler(object):"
        }
      }
    },
    "ncclient/devices/alu.py:AluDeviceHandler:get_xml_extra_prefix_kwargs": {},
    "ncclient/xml_.py:to_ele": {
      "ncclient/xml_.py": {
        "_get_parser": {
          "code": "def _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser",
          "docstring": "",
          "signature": "def _get_parser(huge_tree=False):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:setUp": {
      "ncclient/devices/alu.py:AluDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_add_additional_operations": {
      "ncclient/devices/alu.py:AluDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_capabilities": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_capabilities": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_remove_namespaces": {
      "ncclient/xml_.py:to_ele": {
        "ncclient/xml_.py:_get_parser": {}
      },
      "ncclient/devices/alu.py:remove_namespaces": {},
      "ncclient/xml_.py:to_xml": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_transform_reply": {
      "ncclient/devices/alu.py:AluDeviceHandler:transform_reply": {},
      "ncclient/xml_.py:to_ele": {
        "ncclient/xml_.py:_get_parser": {}
      },
      "ncclient/devices/alu.py:remove_namespaces": {},
      "ncclient/xml_.py:to_xml": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_alu\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u2514\u2500\u2500 alu.py\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.get_capabilities\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2502       \u251c\u2500\u2500 AluDeviceHandler.transform_reply\n    \u2502       \u2514\u2500\u2500 remove_namespaces\n    \u251c\u2500\u2500 transport/\n    \u2502   \u2514\u2500\u2500 errors.py\n    \u2502       \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n    \u2514\u2500\u2500 xml_.py\n        \u251c\u2500\u2500 to_ele\n        \u2514\u2500\u2500 to_xml\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module serves as a testing framework for the AluDeviceHandler, a component that facilitates interactions with Alcatel-Lucent devices over NETCONF. It ensures the handler's correctness and functionality in core areas such as namespace management, capability retrieval, additional operation support, and XML transformation. The module validates critical features, including stripping unnecessary namespaces, managing XML namespaces, and defining additional operations like configuration loading and CLI execution. By automating the verification of these functionalities, the module ensures robust integration with XML-based NETCONF APIs, streamlining device management for developers and reducing errors in handling complex XML data.\n\n## FILE 1: ncclient/devices/alu.py\n\n- CLASS METHOD: AluDeviceHandler.__init__\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the AluDeviceHandler class, which is a specialized handler for the Alcatel-Lucent 7x50 devices. \n\nParameters:\n- device_params (dict): A dictionary containing parameters specific to the device configuration. This is passed to the superclass constructor to initialize common device handling attributes and functionality.\n\nReturns:\n- None: This constructor does not return a value but initializes the instance state.\n\nDependencies:\n- The constructor calls the superclass's initializer from the DefaultDeviceHandler class, which is expected to implement core device handling features. This establishes the context for any device operations that may be added later in the AluDeviceHandler class.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the capabilities of the Alcatel-Lucent 7x50 device in the context of NETCONF operations.\n\nThis method does not take any parameters and returns a list containing the capabilities that the device supports. In this implementation, the returned capability is the base namespace URI for NETCONF (urn:ietf:params:netconf:base:1.0), indicating compliance with the NETCONF protocol version 1.0. This capability allows for the negotiation of features and determines the functionality available when interacting with the device.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nAdd additional NETCONF operations specific to the Alcatel-Lucent 7x50 device.\n\nThis method defines and returns a dictionary of additional operations that can\nbe performed on the Alcatel-Lucent device. The dictionary maps operation names \nto their respective classes: GetConfiguration, ShowCLI, and LoadConfiguration.\n\nReturns:\n    dict: A dictionary with operation names as keys and their associated \n    operation classes as values.\n\nDependencies:\n- GetConfiguration, ShowCLI, LoadConfiguration: These are classes imported \n  from the `ncclient.operations.third_party.alu.rpc` module that represent \n  different NETCONF operations for device configuration and management.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing XML namespace mappings for the Alcatel-Lucent device. This method retrieves base namespace information from the `get_xml_base_namespace_dict` method and prepares it in a format suitable for XML processing by returning a dictionary with the key `nsmap`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, provides the base namespace for NETCONF protocol operations, ensuring proper namespace handling in XML messages exchanged with the device.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary mapping XML namespaces for the Alcatel-Lucent 7x50 device handler. The function creates a dictionary that associates the `None` key with the base XML namespace constant `BASE_NS_1_0`, imported from `ncclient.xml_`. This namespace is essential for ensuring that XML elements are appropriately defined according to the NETCONF protocol standards. The method expects no input parameters and returns a dictionary used in XML operations to maintain namespace integrity during requests and responses.\n\"\"\"\n```\n\n- FUNCTION NAME: remove_namespaces\n  - SIGNATURE: def remove_namespaces(xml):\n  - DOCSTRING: \n```python\n\"\"\"\nRemove namespaces from an XML element tree.\n\nThis function iterates through all elements in the provided XML tree, stripping any namespace qualifiers from the tags. It also performs cleanup of the namespaces after the modifications. XML comments are skipped during the processing. \n\nParameters:\n- xml (etree.ElementTree): An XML element tree from which namespaces should be removed.\n\nReturns:\n- etree.ElementTree: The modified XML element tree with namespaces removed.\n\nDependencies:\n- This function relies on the `etree` module from the `lxml` library for XML processing. The `cleanup_namespaces` method is used to clean up any unused namespace definitions after the modifications.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.transform_reply\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def transform_reply(self):\n  - DOCSTRING: \n```python\n\"\"\"\nTransforms the reply from the device by removing XML namespaces.\n\nThis method returns a reference to the `remove_namespaces` function, which is used to process XML data by stripping out any namespaces present in the elements, thus simplifying the XML structure for easier manipulation or analysis. \n\nNo input parameters are required for this method, and it does not produce a direct output, but instead provides a callable function that can be used to transform XML replies. The `remove_namespaces` function is defined outside of this class and operates on an XML object, ensuring that any namespaces are cleaned up before further processing of the device's configuration data.\n\"\"\"\n```\n\n## FILE 2: ncclient/transport/errors.py\n\n## FILE 3: ncclient/xml_.py\n\n- FUNCTION NAME: to_xml\n  - SIGNATURE: def to_xml(ele, encoding='UTF-8', pretty_print=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an ElementTree element (*ele*) into a well-formed XML string with specified encoding and optional pretty printing.\n\nParameters:\n- ele: An instance of :class:`~xml.etree.ElementTree.Element` representing the XML element to be converted.\n- encoding: A string specifying the character encoding for the XML output (default is \"UTF-8\").\n- pretty_print: A boolean indicating whether to format the XML with indentation and newlines for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element. If the XML does not start with the XML declaration (e.g., '<?xml version=\"1.0\" encoding=\"UTF-8\"?>'), it is prepended with the appropriate declaration based on the specified encoding.\n\nDependencies:\n- The function relies on the `etree` module from the `lxml` package for XML processing, particularly the `etree.tostring()` method for converting elements to strings.\n- It also checks `sys.version` to handle differences in string handling between Python 2 and Python 3, allowing for backward compatibility.\n\"\"\"\n```\n\n- FUNCTION NAME: to_ele\n  - SIGNATURE: def to_ele(x, huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given XML document or an existing XML Element into an `ElementTree.Element`. If the input is already an `ElementTree.Element`, it is returned as is. The function supports parsing XML documents with very deep trees and long text content through the `huge_tree` parameter.\n\nParameters:\n- x: The XML document as a string or an already parsed `ElementTree.Element`.\n- huge_tree (bool): A flag indicating whether to allow parsing of extremely deep or complex XML structures (default is False).\n\nReturns:\n- An instance of `xml.etree.ElementTree.Element`, either from the parsed XML if it was a string or the original element if it was already of the correct type.\n\nThis function uses the `etree` module from `lxml` for parsing and depends on the `_get_parser` function, which utilizes `parser` and `huge_parser` constants to select the appropriate parser based on the `huge_tree` flag.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:_get_parser\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/devices/alu.py": "from lxml import etree\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.alu.rpc import GetConfiguration, LoadConfiguration, ShowCLI\nfrom ncclient.xml_ import BASE_NS_1_0\n\nclass AluDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Alcatel-Lucent 7x50 handler for device specific information.\n    \"\"\"",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/xml_.py": "\"\"\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\"\"\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\nfrom ncclient import NCClientError\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\nclass XMLError(NCClientError):\n    pass\nBASE_NS_1_0 = 'urn:ietf:params:xml:ns:netconf:base:1.0'\nYANG_NS_1_0 = 'urn:ietf:params:xml:ns:yang:1'\nNXOS_1_0 = 'http://www.cisco.com/nxos:1.0'\nNXOS_IF = 'http://www.cisco.com/nxos:1.0:if_manager'\nTAILF_AAA_1_1 = 'http://tail-f.com/ns/aaa/1.1'\nTAILF_EXECD_1_1 = 'http://tail-f.com/ns/execd/1.1'\nCISCO_CPI_1_0 = 'http://www.cisco.com/cpi_10/schema'\nFLOWMON_1_0 = 'http://www.liberouter.org/ns/netopeer/flowmon/1.0'\nJUNIPER_1_1 = 'http://xml.juniper.net/xnm/1.1/xnm'\nHUAWEI_NS = 'http://www.huawei.com/netconf/vrp'\nHW_PRIVATE_NS = 'http://www.huawei.com/netconf/capability/base/1.0'\nH3C_DATA_1_0 = 'http://www.h3c.com/netconf/data:1.0'\nH3C_CONFIG_1_0 = 'http://www.h3c.com/netconf/config:1.0'\nH3C_ACTION_1_0 = 'http://www.h3c.com/netconf/action:1.0'\nNETCONF_MONITORING_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring'\nNETCONF_NOTIFICATION_NS = 'urn:ietf:params:xml:ns:netconf:notification:1.0'\nNETCONF_WITH_DEFAULTS_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults'\nALU_CONFIG = 'urn:alcatel-lucent.com:sros:ns:yang:conf-r13'\nSROS_GLOBAL_OPS_NS = 'urn:nokia.com:sros:ns:yang:sr:oper-global'\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        ElementTree._namespace_map[uri] = prefix\nfor ns, pre in six.iteritems({BASE_NS_1_0: 'nc', NETCONF_MONITORING_NS: 'ncm', NXOS_1_0: 'nxos', NXOS_IF: 'if', TAILF_AAA_1_1: 'aaa', TAILF_EXECD_1_1: 'execd', CISCO_CPI_1_0: 'cpi', FLOWMON_1_0: 'fm', JUNIPER_1_1: 'junos'}):\n    register_namespace(pre, ns)\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else '{%s}%s' % (ns, tag)\n'Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.'\n\ndef parse_root(raw):\n    \"\"\"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\"\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError('Element [%s] does not meet requirement' % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)):\n                req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError('Element [%s] does not have required attributes' % ele.tag)\n    return ele\nXPATH_NAMESPACES = {'re': 'http://exslt.org/regular-expressions'}\n\nclass NCElement(object):\n\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt = self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)), parser=self.__parser))), parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        if elem.tag is not etree.Comment:\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag, ns), attrs, **extra)\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)"
  }
}