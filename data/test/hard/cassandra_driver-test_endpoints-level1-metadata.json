{
  "dir_path": "/app/cassandra_driver",
  "package_name": "cassandra_driver",
  "sample_name": "cassandra_driver-test_endpoints",
  "src_dir": "cassandra/",
  "test_dir": "tests/",
  "test_file": "tests/unit/test_endpoints.py",
  "test_code": "# Copyright DataStax, Inc.\n#\n# Licensed under the DataStax DSE Driver License;\n# you may not use this file except in compliance with the License.\n#\n# You may obtain a copy of the License at\n#\n# http://www.datastax.com/terms/datastax-dse-driver-license-terms\nimport unittest\n\nimport itertools\n\nfrom cassandra.connection import DefaultEndPoint, SniEndPoint, SniEndPointFactory\n\nfrom unittest.mock import patch\n\n\ndef socket_getaddrinfo(*args):\n    return [\n        (0, 0, 0, '', ('127.0.0.1', 30002)),\n        (0, 0, 0, '', ('127.0.0.2', 30002)),\n        (0, 0, 0, '', ('127.0.0.3', 30002))\n    ]\n\n\n@patch('socket.getaddrinfo', socket_getaddrinfo)\nclass SniEndPointTest(unittest.TestCase):\n\n    endpoint_factory = SniEndPointFactory(\"proxy.datastax.com\", 30002)\n\n    def test_sni_endpoint_properties(self):\n\n        endpoint = self.endpoint_factory.create_from_sni('test')\n        self.assertEqual(endpoint.address, 'proxy.datastax.com')\n        self.assertEqual(endpoint.port, 30002)\n        self.assertEqual(endpoint._server_name, 'test')\n        self.assertEqual(str(endpoint), 'proxy.datastax.com:30002:test')\n\n    def test_endpoint_equality(self):\n        self.assertNotEqual(\n            DefaultEndPoint('10.0.0.1'),\n            self.endpoint_factory.create_from_sni('10.0.0.1')\n        )\n\n        self.assertEqual(\n            self.endpoint_factory.create_from_sni('10.0.0.1'),\n            self.endpoint_factory.create_from_sni('10.0.0.1')\n        )\n\n        self.assertNotEqual(\n            self.endpoint_factory.create_from_sni('10.0.0.1'),\n            self.endpoint_factory.create_from_sni('10.0.0.0')\n        )\n\n        self.assertNotEqual(\n            self.endpoint_factory.create_from_sni('10.0.0.1'),\n            SniEndPointFactory(\"proxy.datastax.com\", 9999).create_from_sni('10.0.0.1')\n        )\n\n    def test_endpoint_resolve(self):\n        ips = ['127.0.0.1', '127.0.0.2', '127.0.0.3']\n        it = itertools.cycle(ips)\n\n        endpoint = self.endpoint_factory.create_from_sni('test')\n        for i in range(10):\n            (address, _) = endpoint.resolve()\n            self.assertEqual(address, next(it))\n",
  "GT_file_code": {
    "cassandra/connection.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import absolute_import  # to enable import io from stdlib\nfrom collections import defaultdict, deque\nimport errno\nfrom functools import wraps, partial, total_ordering\nfrom heapq import heappush, heappop\nimport io\nimport logging\nimport socket\nimport struct\nimport sys\nfrom threading import Thread, Event, RLock, Condition\nimport time\nimport ssl\nimport weakref\n\n\nif 'gevent.monkey' in sys.modules:\n    from gevent.queue import Queue, Empty\nelse:\n    from queue import Queue, Empty  # noqa\n\nfrom cassandra import ConsistencyLevel, AuthenticationFailed, OperationTimedOut, ProtocolVersion\nfrom cassandra.marshal import int32_pack\nfrom cassandra.protocol import (ReadyMessage, AuthenticateMessage, OptionsMessage,\n                                StartupMessage, ErrorMessage, CredentialsMessage,\n                                QueryMessage, ResultMessage, ProtocolHandler,\n                                InvalidRequestException, SupportedMessage,\n                                AuthResponseMessage, AuthChallengeMessage,\n                                AuthSuccessMessage, ProtocolException,\n                                RegisterMessage, ReviseRequestMessage)\nfrom cassandra.segment import SegmentCodec, CrcException\nfrom cassandra.util import OrderedDict\n\n\nlog = logging.getLogger(__name__)\n\nsegment_codec_no_compression = SegmentCodec()\nsegment_codec_lz4 = None\n\n# We use an ordered dictionary and specifically add lz4 before\n# snappy so that lz4 will be preferred. Changing the order of this\n# will change the compression preferences for the driver.\nlocally_supported_compressions = OrderedDict()\n\ntry:\n    import lz4\nexcept ImportError:\n    pass\nelse:\n    # The compress and decompress functions we need were moved from the lz4 to\n    # the lz4.block namespace, so we try both here.\n    try:\n        from lz4 import block as lz4_block\n    except ImportError:\n        lz4_block = lz4\n\n    try:\n        lz4_block.compress\n        lz4_block.decompress\n    except AttributeError:\n        raise ImportError(\n            'lz4 not imported correctly. Imported object should have '\n            '.compress and and .decompress attributes but does not. '\n            'Please file a bug report on JIRA. (Imported object was '\n            '{lz4_block})'.format(lz4_block=repr(lz4_block))\n        )\n\n    # Cassandra writes the uncompressed message length in big endian order,\n    # but the lz4 lib requires little endian order, so we wrap these\n    # functions to handle that\n\n    def lz4_compress(byts):\n        # write length in big-endian instead of little-endian\n        return int32_pack(len(byts)) + lz4_block.compress(byts)[4:]\n\n    def lz4_decompress(byts):\n        # flip from big-endian to little-endian\n        return lz4_block.decompress(byts[3::-1] + byts[4:])\n\n    locally_supported_compressions['lz4'] = (lz4_compress, lz4_decompress)\n    segment_codec_lz4 = SegmentCodec(lz4_compress, lz4_decompress)\n\ntry:\n    import snappy\nexcept ImportError:\n    pass\nelse:\n    # work around apparently buggy snappy decompress\n    def decompress(byts):\n        if byts == '\\x00':\n            return ''\n        return snappy.decompress(byts)\n    locally_supported_compressions['snappy'] = (snappy.compress, decompress)\n\nDRIVER_NAME, DRIVER_VERSION = 'DataStax Python Driver', sys.modules['cassandra'].__version__\n\nPROTOCOL_VERSION_MASK = 0x7f\n\nHEADER_DIRECTION_FROM_CLIENT = 0x00\nHEADER_DIRECTION_TO_CLIENT = 0x80\nHEADER_DIRECTION_MASK = 0x80\n\nframe_header_v1_v2 = struct.Struct('>BbBi')\nframe_header_v3 = struct.Struct('>BhBi')\n\n\nclass EndPoint(object):\n    \"\"\"\n    Represents the information to connect to a cassandra node.\n    \"\"\"\n\n    @property\n    def address(self):\n        \"\"\"\n        The IP address of the node. This is the RPC address the driver uses when connecting to the node\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def port(self):\n        \"\"\"\n        The port of the node.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def ssl_options(self):\n        \"\"\"\n        SSL options specific to this endpoint.\n        \"\"\"\n        return None\n\n    @property\n    def socket_family(self):\n        \"\"\"\n        The socket family of the endpoint.\n        \"\"\"\n        return socket.AF_UNSPEC\n\n    def resolve(self):\n        \"\"\"\n        Resolve the endpoint to an address/port. This is called\n        only on socket connection.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass EndPointFactory(object):\n\n    cluster = None\n\n    def configure(self, cluster):\n        \"\"\"\n        This is called by the cluster during its initialization.\n        \"\"\"\n        self.cluster = cluster\n        return self\n\n    def create(self, row):\n        \"\"\"\n        Create an EndPoint from a system.peers row.\n        \"\"\"\n        raise NotImplementedError()\n\n\n@total_ordering\nclass DefaultEndPoint(EndPoint):\n    \"\"\"\n    Default EndPoint implementation, basically just an address and port.\n    \"\"\"\n\n    def __init__(self, address, port=9042):\n        self._address = address\n        self._port = port\n\n    @property\n    def address(self):\n        return self._address\n\n    @property\n    def port(self):\n        return self._port\n\n    def resolve(self):\n        return self._address, self._port\n\n    def __eq__(self, other):\n        return isinstance(other, DefaultEndPoint) and \\\n               self.address == other.address and self.port == other.port\n\n    def __hash__(self):\n        return hash((self.address, self.port))\n\n    def __lt__(self, other):\n        return (self.address, self.port) < (other.address, other.port)\n\n    def __str__(self):\n        return str(\"%s:%d\" % (self.address, self.port))\n\n    def __repr__(self):\n        return \"<%s: %s:%d>\" % (self.__class__.__name__, self.address, self.port)\n\n\nclass DefaultEndPointFactory(EndPointFactory):\n\n    port = None\n    \"\"\"\n    If no port is discovered in the row, this is the default port\n    used for endpoint creation. \n    \"\"\"\n\n    def __init__(self, port=None):\n        self.port = port\n\n    def create(self, row):\n        # TODO next major... move this class so we don't need this kind of hack\n        from cassandra.metadata import _NodeInfo\n        addr = _NodeInfo.get_broadcast_rpc_address(row)\n        port = _NodeInfo.get_broadcast_rpc_port(row)\n        if port is None:\n            port = self.port if self.port else 9042\n\n        # create the endpoint with the translated address\n        # TODO next major, create a TranslatedEndPoint type\n        return DefaultEndPoint(\n            self.cluster.address_translator.translate(addr),\n            port)\n\n\n@total_ordering\nclass SniEndPoint(EndPoint):\n    \"\"\"SNI Proxy EndPoint implementation.\"\"\"\n\n    def __init__(self, proxy_address, server_name, port=9042):\n        self._proxy_address = proxy_address\n        self._index = 0\n        self._resolved_address = None  # resolved address\n        self._port = port\n        self._server_name = server_name\n        self._ssl_options = {'server_hostname': server_name}\n\n    @property\n    def address(self):\n        return self._proxy_address\n\n    @property\n    def port(self):\n        return self._port\n\n    @property\n    def ssl_options(self):\n        return self._ssl_options\n\n    def resolve(self):\n        try:\n            resolved_addresses = socket.getaddrinfo(self._proxy_address, self._port,\n                                                    socket.AF_UNSPEC, socket.SOCK_STREAM)\n        except socket.gaierror:\n            log.debug('Could not resolve sni proxy hostname \"%s\" '\n                      'with port %d' % (self._proxy_address, self._port))\n            raise\n\n        # round-robin pick\n        self._resolved_address = sorted(addr[4][0] for addr in resolved_addresses)[self._index % len(resolved_addresses)]\n        self._index += 1\n\n        return self._resolved_address, self._port\n\n    def __eq__(self, other):\n        return (isinstance(other, SniEndPoint) and\n                self.address == other.address and self.port == other.port and\n                self._server_name == other._server_name)\n\n    def __hash__(self):\n        return hash((self.address, self.port, self._server_name))\n\n    def __lt__(self, other):\n        return ((self.address, self.port, self._server_name) <\n                (other.address, other.port, self._server_name))\n\n    def __str__(self):\n        return str(\"%s:%d:%s\" % (self.address, self.port, self._server_name))\n\n    def __repr__(self):\n        return \"<%s: %s:%d:%s>\" % (self.__class__.__name__,\n                                   self.address, self.port, self._server_name)\n\n\nclass SniEndPointFactory(EndPointFactory):\n\n    def __init__(self, proxy_address, port):\n        self._proxy_address = proxy_address\n        self._port = port\n\n    def create(self, row):\n        host_id = row.get(\"host_id\")\n        if host_id is None:\n            raise ValueError(\"No host_id to create the SniEndPoint\")\n\n        return SniEndPoint(self._proxy_address, str(host_id), self._port)\n\n    def create_from_sni(self, sni):\n        return SniEndPoint(self._proxy_address, sni, self._port)\n\n\n@total_ordering\nclass UnixSocketEndPoint(EndPoint):\n    \"\"\"\n    Unix Socket EndPoint implementation.\n    \"\"\"\n\n    def __init__(self, unix_socket_path):\n        self._unix_socket_path = unix_socket_path\n\n    @property\n    def address(self):\n        return self._unix_socket_path\n\n    @property\n    def port(self):\n        return None\n\n    @property\n    def socket_family(self):\n        return socket.AF_UNIX\n\n    def resolve(self):\n        return self.address, None\n\n    def __eq__(self, other):\n        return (isinstance(other, UnixSocketEndPoint) and\n                self._unix_socket_path == other._unix_socket_path)\n\n    def __hash__(self):\n        return hash(self._unix_socket_path)\n\n    def __lt__(self, other):\n        return self._unix_socket_path < other._unix_socket_path\n\n    def __str__(self):\n        return str(\"%s\" % (self._unix_socket_path,))\n\n    def __repr__(self):\n        return \"<%s: %s>\" % (self.__class__.__name__, self._unix_socket_path)\n\n\nclass _Frame(object):\n    def __init__(self, version, flags, stream, opcode, body_offset, end_pos):\n        self.version = version\n        self.flags = flags\n        self.stream = stream\n        self.opcode = opcode\n        self.body_offset = body_offset\n        self.end_pos = end_pos\n\n    def __eq__(self, other):  # facilitates testing\n        if isinstance(other, _Frame):\n            return (self.version == other.version and\n                    self.flags == other.flags and\n                    self.stream == other.stream and\n                    self.opcode == other.opcode and\n                    self.body_offset == other.body_offset and\n                    self.end_pos == other.end_pos)\n        return NotImplemented\n\n    def __str__(self):\n        return \"ver({0}); flags({1:04b}); stream({2}); op({3}); offset({4}); len({5})\".format(self.version, self.flags, self.stream, self.opcode, self.body_offset, self.end_pos - self.body_offset)\n\n\nNONBLOCKING = (errno.EAGAIN, errno.EWOULDBLOCK)\n\n\nclass ConnectionException(Exception):\n    \"\"\"\n    An unrecoverable error was hit when attempting to use a connection,\n    or the connection was already closed or defunct.\n    \"\"\"\n\n    def __init__(self, message, endpoint=None):\n        Exception.__init__(self, message)\n        self.endpoint = endpoint\n\n    @property\n    def host(self):\n        return self.endpoint.address\n\n\nclass ConnectionShutdown(ConnectionException):\n    \"\"\"\n    Raised when a connection has been marked as defunct or has been closed.\n    \"\"\"\n    pass\n\n\nclass ProtocolVersionUnsupported(ConnectionException):\n    \"\"\"\n    Server rejected startup message due to unsupported protocol version\n    \"\"\"\n    def __init__(self, endpoint, startup_version):\n        msg = \"Unsupported protocol version on %s: %d\" % (endpoint, startup_version)\n        super(ProtocolVersionUnsupported, self).__init__(msg, endpoint)\n        self.startup_version = startup_version\n\n\nclass ConnectionBusy(Exception):\n    \"\"\"\n    An attempt was made to send a message through a :class:`.Connection` that\n    was already at the max number of in-flight operations.\n    \"\"\"\n    pass\n\n\nclass ProtocolError(Exception):\n    \"\"\"\n    Communication did not match the protocol that this driver expects.\n    \"\"\"\n    pass\n\n\nclass CrcMismatchException(ConnectionException):\n    pass\n\n\nclass ContinuousPagingState(object):\n    \"\"\"\n     A class for specifying continuous paging state, only supported starting with DSE_V2.\n    \"\"\"\n\n    num_pages_requested = None\n    \"\"\"\n    How many pages we have already requested\n    \"\"\"\n\n    num_pages_received = None\n    \"\"\"\n    How many pages we have already received\n    \"\"\"\n\n    max_queue_size = None\n    \"\"\"\n    The max queue size chosen by the user via the options\n    \"\"\"\n\n    def __init__(self, max_queue_size):\n        self.num_pages_requested = max_queue_size  # the initial query requests max_queue_size\n        self.num_pages_received = 0\n        self.max_queue_size = max_queue_size\n\n\nclass ContinuousPagingSession(object):\n    def __init__(self, stream_id, decoder, row_factory, connection, state):\n        self.stream_id = stream_id\n        self.decoder = decoder\n        self.row_factory = row_factory\n        self.connection = connection\n        self._condition = Condition()\n        self._stop = False\n        self._page_queue = deque()\n        self._state = state\n        self.released = False\n\n    def on_message(self, result):\n        if isinstance(result, ResultMessage):\n            self.on_page(result)\n        elif isinstance(result, ErrorMessage):\n            self.on_error(result)\n\n    def on_page(self, result):\n        with self._condition:\n            if self._state:\n                self._state.num_pages_received += 1\n            self._page_queue.appendleft((result.column_names, result.parsed_rows, None))\n            self._stop |= result.continuous_paging_last\n            self._condition.notify()\n\n        if result.continuous_paging_last:\n            self.released = True\n\n    def on_error(self, error):\n        if isinstance(error, ErrorMessage):\n            error = error.to_exception()\n\n        log.debug(\"Got error %s for session %s\", error, self.stream_id)\n\n        with self._condition:\n            self._page_queue.appendleft((None, None, error))\n            self._stop = True\n            self._condition.notify()\n\n        self.released = True\n\n    def results(self):\n        try:\n            self._condition.acquire()\n            while True:\n                while not self._page_queue and not self._stop:\n                    self._condition.wait(timeout=5)\n                while self._page_queue:\n                    names, rows, err = self._page_queue.pop()\n                    if err:\n                        raise err\n                    self.maybe_request_more()\n                    self._condition.release()\n                    for row in self.row_factory(names, rows):\n                        yield row\n                    self._condition.acquire()\n                if self._stop:\n                    break\n        finally:\n            try:\n                self._condition.release()\n            except RuntimeError:\n                # This exception happens if the CP results are not entirely consumed\n                # and the session is terminated by the runtime. See PYTHON-1054\n                pass\n\n    def maybe_request_more(self):\n        if not self._state:\n            return\n\n        max_queue_size = self._state.max_queue_size\n        num_in_flight = self._state.num_pages_requested - self._state.num_pages_received\n        space_in_queue = max_queue_size - len(self._page_queue) - num_in_flight\n        log.debug(\"Session %s from %s, space in CP queue: %s, requested: %s, received: %s, num_in_flight: %s\",\n                  self.stream_id, self.connection.host, space_in_queue, self._state.num_pages_requested,\n                  self._state.num_pages_received, num_in_flight)\n\n        if space_in_queue >= max_queue_size / 2:\n            self.update_next_pages(space_in_queue)\n\n    def update_next_pages(self, num_next_pages):\n        try:\n            self._state.num_pages_requested += num_next_pages\n            log.debug(\"Updating backpressure for session %s from %s\", self.stream_id, self.connection.host)\n            with self.connection.lock:\n                self.connection.send_msg(ReviseRequestMessage(ReviseRequestMessage.RevisionType.PAGING_BACKPRESSURE,\n                                                              self.stream_id,\n                                                              next_pages=num_next_pages),\n                                         self.connection.get_request_id(),\n                                         self._on_backpressure_response)\n        except ConnectionShutdown as ex:\n            log.debug(\"Failed to update backpressure for session %s from %s, connection is shutdown\",\n                      self.stream_id, self.connection.host)\n            self.on_error(ex)\n\n    def _on_backpressure_response(self, response):\n        if isinstance(response, ResultMessage):\n            log.debug(\"Paging session %s backpressure updated.\", self.stream_id)\n        else:\n            log.error(\"Failed updating backpressure for session %s from %s: %s\", self.stream_id, self.connection.host,\n                      response.to_exception() if hasattr(response, 'to_exception') else response)\n            self.on_error(response)\n\n    def cancel(self):\n        try:\n            log.debug(\"Canceling paging session %s from %s\", self.stream_id, self.connection.host)\n            with self.connection.lock:\n                self.connection.send_msg(ReviseRequestMessage(ReviseRequestMessage.RevisionType.PAGING_CANCEL,\n                                                              self.stream_id),\n                                         self.connection.get_request_id(),\n                                         self._on_cancel_response)\n        except ConnectionShutdown:\n            log.debug(\"Failed to cancel session %s from %s, connection is shutdown\",\n                      self.stream_id, self.connection.host)\n\n        with self._condition:\n            self._stop = True\n            self._condition.notify()\n\n    def _on_cancel_response(self, response):\n        if isinstance(response, ResultMessage):\n            log.debug(\"Paging session %s canceled.\", self.stream_id)\n        else:\n            log.error(\"Failed canceling streaming session %s from %s: %s\", self.stream_id, self.connection.host,\n                      response.to_exception() if hasattr(response, 'to_exception') else response)\n        self.released = True\n\n\ndef defunct_on_error(f):\n\n    @wraps(f)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return f(self, *args, **kwargs)\n        except Exception as exc:\n            self.defunct(exc)\n    return wrapper\n\n\nDEFAULT_CQL_VERSION = '3.0.0'\n\n\nclass _ConnectionIOBuffer(object):\n    \"\"\"\n    Abstraction class to ease the use of the different connection io buffers. With\n    protocol V5 and checksumming, the data is read, validated and copied to another\n    cql frame buffer.\n    \"\"\"\n    _io_buffer = None\n    _cql_frame_buffer = None\n    _connection = None\n    _segment_consumed = False\n\n    def __init__(self, connection):\n        self._io_buffer = io.BytesIO()\n        self._connection = weakref.proxy(connection)\n\n    @property\n    def io_buffer(self):\n        return self._io_buffer\n\n    @property\n    def cql_frame_buffer(self):\n        return self._cql_frame_buffer if self.is_checksumming_enabled else \\\n            self._io_buffer\n\n    def set_checksumming_buffer(self):\n        self.reset_io_buffer()\n        self._cql_frame_buffer = io.BytesIO()\n\n    @property\n    def is_checksumming_enabled(self):\n        return self._connection._is_checksumming_enabled\n\n    @property\n    def has_consumed_segment(self):\n        return self._segment_consumed;\n\n    def readable_io_bytes(self):\n        return self.io_buffer.tell()\n\n    def readable_cql_frame_bytes(self):\n        return self.cql_frame_buffer.tell()\n\n    def reset_io_buffer(self):\n        self._io_buffer = io.BytesIO(self._io_buffer.read())\n        self._io_buffer.seek(0, 2)  # 2 == SEEK_END\n\n    def reset_cql_frame_buffer(self):\n        if self.is_checksumming_enabled:\n            self._cql_frame_buffer = io.BytesIO(self._cql_frame_buffer.read())\n            self._cql_frame_buffer.seek(0, 2)  # 2 == SEEK_END\n        else:\n            self.reset_io_buffer()\n\n\nclass Connection(object):\n\n    CALLBACK_ERR_THREAD_THRESHOLD = 100\n\n    in_buffer_size = 4096\n    out_buffer_size = 4096\n\n    cql_version = None\n    no_compact = False\n    protocol_version = ProtocolVersion.MAX_SUPPORTED\n\n    keyspace = None\n    compression = True\n    _compression_type = None\n    compressor = None\n    decompressor = None\n\n    endpoint = None\n    ssl_options = None\n    ssl_context = None\n    last_error = None\n\n    # The current number of operations that are in flight. More precisely,\n    # the number of request IDs that are currently in use.\n    # This includes orphaned requests.\n    in_flight = 0\n\n    # Max concurrent requests allowed per connection. This is set optimistically high, allowing\n    # all request ids to be used in protocol version 3+. Normally concurrency would be controlled\n    # at a higher level by the application or concurrent.execute_concurrent. This attribute\n    # is for lower-level integrations that want some upper bound without reimplementing.\n    max_in_flight = 2 ** 15\n\n    # A set of available request IDs.  When using the v3 protocol or higher,\n    # this will not initially include all request IDs in order to save memory,\n    # but the set will grow if it is exhausted.\n    request_ids = None\n\n    # Tracks the highest used request ID in order to help with growing the\n    # request_ids set\n    highest_request_id = 0\n\n    # Tracks the request IDs which are no longer waited on (timed out), but\n    # cannot be reused yet because the node might still send a response\n    # on this stream\n    orphaned_request_ids = None\n\n    # Set to true if the orphaned stream ID count cross configured threshold\n    # and the connection will be replaced\n    orphaned_threshold_reached = False\n\n    # If the number of orphaned streams reaches this threshold, this connection\n    # will become marked and will be replaced with a new connection by the\n    # owning pool (currently, only HostConnection supports this)\n    orphaned_threshold = 3  * max_in_flight // 4\n\n    is_defunct = False\n    is_closed = False\n    lock = None\n    user_type_map = None\n\n    msg_received = False\n\n    is_unsupported_proto_version = False\n\n    is_control_connection = False\n    signaled_error = False  # used for flagging at the pool level\n\n    allow_beta_protocol_version = False\n\n    _current_frame = None\n\n    _socket = None\n\n    _socket_impl = socket\n\n    _check_hostname = False\n    _product_type = None\n\n    _is_checksumming_enabled = False\n\n    _on_orphaned_stream_released = None\n\n    @property\n    def _iobuf(self):\n        # backward compatibility, to avoid any change in the reactors\n        return self._io_buffer.io_buffer\n\n    def __init__(self, host='127.0.0.1', port=9042, authenticator=None,\n                 ssl_options=None, sockopts=None, compression=True,\n                 cql_version=None, protocol_version=ProtocolVersion.MAX_SUPPORTED, is_control_connection=False,\n                 user_type_map=None, connect_timeout=None, allow_beta_protocol_version=False, no_compact=False,\n                 ssl_context=None, on_orphaned_stream_released=None):\n\n        # TODO next major rename host to endpoint and remove port kwarg.\n        self.endpoint = host if isinstance(host, EndPoint) else DefaultEndPoint(host, port)\n\n        self.authenticator = authenticator\n        self.ssl_options = ssl_options.copy() if ssl_options else {}\n        self.ssl_context = ssl_context\n        self.sockopts = sockopts\n        self.compression = compression\n        self.cql_version = cql_version\n        self.protocol_version = protocol_version\n        self.is_control_connection = is_control_connection\n        self.user_type_map = user_type_map\n        self.connect_timeout = connect_timeout\n        self.allow_beta_protocol_version = allow_beta_protocol_version\n        self.no_compact = no_compact\n        self._push_watchers = defaultdict(set)\n        self._requests = {}\n        self._io_buffer = _ConnectionIOBuffer(self)\n        self._continuous_paging_sessions = {}\n        self._socket_writable = True\n        self.orphaned_request_ids = set()\n        self._on_orphaned_stream_released = on_orphaned_stream_released\n\n        if ssl_options:\n            self.ssl_options.update(self.endpoint.ssl_options or {})\n        elif self.endpoint.ssl_options:\n            self.ssl_options = self.endpoint.ssl_options\n\n        # PYTHON-1331\n        #\n        # We always use SSLContext.wrap_socket() now but legacy configs may have other params that were passed to ssl.wrap_socket()...\n        # and either could have 'check_hostname'.  Remove these params into a separate map and use them to build an SSLContext if\n        # we need to do so.\n        #\n        # Note the use of pop() here; we are very deliberately removing these params from ssl_options if they're present.  After this\n        # operation ssl_options should contain only args needed for the ssl_context.wrap_socket() call.\n        if not self.ssl_context and self.ssl_options:\n            self.ssl_context = self._build_ssl_context_from_options()\n\n        if protocol_version >= 3:\n            self.max_request_id = min(self.max_in_flight - 1, (2 ** 15) - 1)\n            # Don't fill the deque with 2**15 items right away. Start with some and add\n            # more if needed.\n            initial_size = min(300, self.max_in_flight)\n            self.request_ids = deque(range(initial_size))\n            self.highest_request_id = initial_size - 1\n        else:\n            self.max_request_id = min(self.max_in_flight, (2 ** 7) - 1)\n            self.request_ids = deque(range(self.max_request_id + 1))\n            self.highest_request_id = self.max_request_id\n\n        self.lock = RLock()\n        self.connected_event = Event()\n\n    @property\n    def host(self):\n        return self.endpoint.address\n\n    @property\n    def port(self):\n        return self.endpoint.port\n\n    @classmethod\n    def initialize_reactor(cls):\n        \"\"\"\n        Called once by Cluster.connect().  This should be used by implementations\n        to set up any resources that will be shared across connections.\n        \"\"\"\n        pass\n\n    @classmethod\n    def handle_fork(cls):\n        \"\"\"\n        Called after a forking.  This should cleanup any remaining reactor state\n        from the parent process.\n        \"\"\"\n        pass\n\n    @classmethod\n    def create_timer(cls, timeout, callback):\n        raise NotImplementedError()\n\n    @classmethod\n    def factory(cls, endpoint, timeout, *args, **kwargs):\n        \"\"\"\n        A factory function which returns connections which have\n        succeeded in connecting and are ready for service (or\n        raises an exception otherwise).\n        \"\"\"\n        start = time.time()\n        kwargs['connect_timeout'] = timeout\n        conn = cls(endpoint, *args, **kwargs)\n        elapsed = time.time() - start\n        conn.connected_event.wait(timeout - elapsed)\n        if conn.last_error:\n            if conn.is_unsupported_proto_version:\n                raise ProtocolVersionUnsupported(endpoint, conn.protocol_version)\n            raise conn.last_error\n        elif not conn.connected_event.is_set():\n            conn.close()\n            raise OperationTimedOut(\"Timed out creating connection (%s seconds)\" % timeout)\n        else:\n            return conn\n\n    def _build_ssl_context_from_options(self):\n\n        # Extract a subset of names from self.ssl_options which apply to SSLContext creation\n        ssl_context_opt_names = ['ssl_version', 'cert_reqs', 'check_hostname', 'keyfile', 'certfile', 'ca_certs', 'ciphers']\n        opts = {k:self.ssl_options.get(k, None) for k in ssl_context_opt_names if k in self.ssl_options}\n\n        # Python >= 3.10 requires either PROTOCOL_TLS_CLIENT or PROTOCOL_TLS_SERVER so we'll get ahead of things by always\n        # being explicit\n        ssl_version = opts.get('ssl_version', None) or ssl.PROTOCOL_TLS_CLIENT\n        cert_reqs = opts.get('cert_reqs', None) or ssl.CERT_REQUIRED\n        rv = ssl.SSLContext(protocol=int(ssl_version))\n        rv.check_hostname = bool(opts.get('check_hostname', False))\n        rv.options = int(cert_reqs)\n\n        certfile = opts.get('certfile', None)\n        keyfile = opts.get('keyfile', None)\n        if certfile:\n            rv.load_cert_chain(certfile, keyfile)\n        ca_certs = opts.get('ca_certs', None)\n        if ca_certs:\n            rv.load_verify_locations(ca_certs)\n        ciphers = opts.get('ciphers', None)\n        if ciphers:\n            rv.set_ciphers(ciphers)\n\n        return rv\n\n    def _wrap_socket_from_context(self):\n\n        # Extract a subset of names from self.ssl_options which apply to SSLContext.wrap_socket (or at least the parts\n        # of it that don't involve building an SSLContext under the covers)\n        wrap_socket_opt_names = ['server_side', 'do_handshake_on_connect', 'suppress_ragged_eofs', 'server_hostname']\n        opts = {k:self.ssl_options.get(k, None) for k in wrap_socket_opt_names if k in self.ssl_options}\n\n        # PYTHON-1186: set the server_hostname only if the SSLContext has\n        # check_hostname enabled and it is not already provided by the EndPoint ssl options\n        #opts['server_hostname'] = self.endpoint.address\n        if (self.ssl_context.check_hostname and 'server_hostname' not in opts):\n            server_hostname = self.endpoint.address\n            opts['server_hostname'] = server_hostname\n\n        return self.ssl_context.wrap_socket(self._socket, **opts)\n\n    def _initiate_connection(self, sockaddr):\n        self._socket.connect(sockaddr)\n\n    # PYTHON-1331\n    #\n    # Allow implementations specific to an event loop to add additional behaviours\n    def _validate_hostname(self):\n        pass\n\n    def _get_socket_addresses(self):\n        address, port = self.endpoint.resolve()\n\n        if hasattr(socket, 'AF_UNIX') and self.endpoint.socket_family == socket.AF_UNIX:\n            return [(socket.AF_UNIX, socket.SOCK_STREAM, 0, None, address)]\n\n        addresses = socket.getaddrinfo(address, port, self.endpoint.socket_family, socket.SOCK_STREAM)\n        if not addresses:\n            raise ConnectionException(\"getaddrinfo returned empty list for %s\" % (self.endpoint,))\n\n        return addresses\n\n    def _connect_socket(self):\n        sockerr = None\n        addresses = self._get_socket_addresses()\n        for (af, socktype, proto, _, sockaddr) in addresses:\n            try:\n                self._socket = self._socket_impl.socket(af, socktype, proto)\n                if self.ssl_context:\n                    self._socket = self._wrap_socket_from_context()\n                self._socket.settimeout(self.connect_timeout)\n                self._initiate_connection(sockaddr)\n                self._socket.settimeout(None)\n\n                # PYTHON-1331\n                #\n                # Most checking is done via the check_hostname param on the SSLContext.\n                # Subclasses can add additional behaviours via _validate_hostname() so\n                # run that here.\n                if self._check_hostname:\n                    self._validate_hostname()\n                sockerr = None\n                break\n            except socket.error as err:\n                if self._socket:\n                    self._socket.close()\n                    self._socket = None\n                sockerr = err\n\n        if sockerr:\n            raise socket.error(sockerr.errno, \"Tried connecting to %s. Last error: %s\" %\n                               ([a[4] for a in addresses], sockerr.strerror or sockerr))\n\n        if self.sockopts:\n            for args in self.sockopts:\n                self._socket.setsockopt(*args)\n\n    def _enable_compression(self):\n        if self._compressor:\n            self.compressor = self._compressor\n\n    def _enable_checksumming(self):\n        self._io_buffer.set_checksumming_buffer()\n        self._is_checksumming_enabled = True\n        self._segment_codec = segment_codec_lz4 if self.compressor else segment_codec_no_compression\n        log.debug(\"Enabling protocol checksumming on connection (%s).\", id(self))\n\n    def close(self):\n        raise NotImplementedError()\n\n    def defunct(self, exc):\n        with self.lock:\n            if self.is_defunct or self.is_closed:\n                return\n            self.is_defunct = True\n\n        exc_info = sys.exc_info()\n        # if we are not handling an exception, just use the passed exception, and don't try to format exc_info with the message\n        if any(exc_info):\n            log.debug(\"Defuncting connection (%s) to %s:\",\n                      id(self), self.endpoint, exc_info=exc_info)\n        else:\n            log.debug(\"Defuncting connection (%s) to %s: %s\",\n                      id(self), self.endpoint, exc)\n\n        self.last_error = exc\n        self.close()\n        self.error_all_cp_sessions(exc)\n        self.error_all_requests(exc)\n        self.connected_event.set()\n        return exc\n\n    def error_all_cp_sessions(self, exc):\n        stream_ids = list(self._continuous_paging_sessions.keys())\n        for stream_id in stream_ids:\n            self._continuous_paging_sessions[stream_id].on_error(exc)\n\n    def error_all_requests(self, exc):\n        with self.lock:\n            requests = self._requests\n            self._requests = {}\n\n        if not requests:\n            return\n\n        new_exc = ConnectionShutdown(str(exc))\n\n        def try_callback(cb):\n            try:\n                cb(new_exc)\n            except Exception:\n                log.warning(\"Ignoring unhandled exception while erroring requests for a \"\n                            \"failed connection (%s) to host %s:\",\n                            id(self), self.endpoint, exc_info=True)\n\n        # run first callback from this thread to ensure pool state before leaving\n        cb, _, _ = requests.popitem()[1]\n        try_callback(cb)\n\n        if not requests:\n            return\n\n        # additional requests are optionally errored from a separate thread\n        # The default callback and retry logic is fairly expensive -- we don't\n        # want to tie up the event thread when there are many requests\n        def err_all_callbacks():\n            for cb, _, _ in requests.values():\n                try_callback(cb)\n        if len(requests) < Connection.CALLBACK_ERR_THREAD_THRESHOLD:\n            err_all_callbacks()\n        else:\n            # daemon thread here because we want to stay decoupled from the cluster TPE\n            # TODO: would it make sense to just have a driver-global TPE?\n            t = Thread(target=err_all_callbacks)\n            t.daemon = True\n            t.start()\n\n    def get_request_id(self):\n        \"\"\"\n        This must be called while self.lock is held.\n        \"\"\"\n        try:\n            return self.request_ids.popleft()\n        except IndexError:\n            new_request_id = self.highest_request_id + 1\n            # in_flight checks should guarantee this\n            assert new_request_id <= self.max_request_id\n            self.highest_request_id = new_request_id\n            return self.highest_request_id\n\n    def handle_pushed(self, response):\n        log.debug(\"Message pushed from server: %r\", response)\n        for cb in self._push_watchers.get(response.event_type, []):\n            try:\n                cb(response.event_args)\n            except Exception:\n                log.exception(\"Pushed event handler errored, ignoring:\")\n\n    def send_msg(self, msg, request_id, cb, encoder=ProtocolHandler.encode_message, decoder=ProtocolHandler.decode_message, result_metadata=None):\n        if self.is_defunct:\n            raise ConnectionShutdown(\"Connection to %s is defunct\" % self.endpoint)\n        elif self.is_closed:\n            raise ConnectionShutdown(\"Connection to %s is closed\" % self.endpoint)\n        elif not self._socket_writable:\n            raise ConnectionBusy(\"Connection %s is overloaded\" % self.endpoint)\n\n        # queue the decoder function with the request\n        # this allows us to inject custom functions per request to encode, decode messages\n        self._requests[request_id] = (cb, decoder, result_metadata)\n        msg = encoder(msg, request_id, self.protocol_version, compressor=self.compressor,\n                      allow_beta_protocol_version=self.allow_beta_protocol_version)\n\n        if self._is_checksumming_enabled:\n            buffer = io.BytesIO()\n            self._segment_codec.encode(buffer, msg)\n            msg = buffer.getvalue()\n\n        self.push(msg)\n        return len(msg)\n\n    def wait_for_response(self, msg, timeout=None, **kwargs):\n        return self.wait_for_responses(msg, timeout=timeout, **kwargs)[0]\n\n    def wait_for_responses(self, *msgs, **kwargs):\n        \"\"\"\n        Returns a list of (success, response) tuples.  If success\n        is False, response will be an Exception.  Otherwise, response\n        will be the normal query response.\n\n        If fail_on_error was left as True and one of the requests\n        failed, the corresponding Exception will be raised.\n        \"\"\"\n        if self.is_closed or self.is_defunct:\n            raise ConnectionShutdown(\"Connection %s is already closed\" % (self, ))\n        timeout = kwargs.get('timeout')\n        fail_on_error = kwargs.get('fail_on_error', True)\n        waiter = ResponseWaiter(self, len(msgs), fail_on_error)\n\n        # busy wait for sufficient space on the connection\n        messages_sent = 0\n        while True:\n            needed = len(msgs) - messages_sent\n            with self.lock:\n                available = min(needed, self.max_request_id - self.in_flight + 1)\n                request_ids = [self.get_request_id() for _ in range(available)]\n                self.in_flight += available\n\n            for i, request_id in enumerate(request_ids):\n                self.send_msg(msgs[messages_sent + i],\n                              request_id,\n                              partial(waiter.got_response, index=messages_sent + i))\n            messages_sent += available\n\n            if messages_sent == len(msgs):\n                break\n            else:\n                if timeout is not None:\n                    timeout -= 0.01\n                    if timeout <= 0.0:\n                        raise OperationTimedOut()\n                time.sleep(0.01)\n\n        try:\n            return waiter.deliver(timeout)\n        except OperationTimedOut:\n            raise\n        except Exception as exc:\n            self.defunct(exc)\n            raise\n\n    def register_watcher(self, event_type, callback, register_timeout=None):\n        \"\"\"\n        Register a callback for a given event type.\n        \"\"\"\n        self._push_watchers[event_type].add(callback)\n        self.wait_for_response(\n            RegisterMessage(event_list=[event_type]),\n            timeout=register_timeout)\n\n    def register_watchers(self, type_callback_dict, register_timeout=None):\n        \"\"\"\n        Register multiple callback/event type pairs, expressed as a dict.\n        \"\"\"\n        for event_type, callback in type_callback_dict.items():\n            self._push_watchers[event_type].add(callback)\n        self.wait_for_response(\n            RegisterMessage(event_list=type_callback_dict.keys()),\n            timeout=register_timeout)\n\n    def control_conn_disposed(self):\n        self.is_control_connection = False\n        self._push_watchers = {}\n\n    @defunct_on_error\n    def _read_frame_header(self):\n        buf = self._io_buffer.cql_frame_buffer.getvalue()\n        pos = len(buf)\n        if pos:\n            version = buf[0] & PROTOCOL_VERSION_MASK\n            if version not in ProtocolVersion.SUPPORTED_VERSIONS:\n                raise ProtocolError(\"This version of the driver does not support protocol version %d\" % version)\n            frame_header = frame_header_v3 if version >= 3 else frame_header_v1_v2\n            # this frame header struct is everything after the version byte\n            header_size = frame_header.size + 1\n            if pos >= header_size:\n                flags, stream, op, body_len = frame_header.unpack_from(buf, 1)\n                if body_len < 0:\n                    raise ProtocolError(\"Received negative body length: %r\" % body_len)\n                self._current_frame = _Frame(version, flags, stream, op, header_size, body_len + header_size)\n        return pos\n\n    @defunct_on_error\n    def _process_segment_buffer(self):\n        readable_bytes = self._io_buffer.readable_io_bytes()\n        if readable_bytes >= self._segment_codec.header_length_with_crc:\n            try:\n                self._io_buffer.io_buffer.seek(0)\n                segment_header = self._segment_codec.decode_header(self._io_buffer.io_buffer)\n\n                if readable_bytes >= segment_header.segment_length:\n                    segment = self._segment_codec.decode(self._iobuf, segment_header)\n                    self._io_buffer._segment_consumed = True\n                    self._io_buffer.cql_frame_buffer.write(segment.payload)\n                else:\n                    # not enough data to read the segment. reset the buffer pointer at the\n                    # beginning to not lose what we previously read (header).\n                    self._io_buffer._segment_consumed = False\n                    self._io_buffer.io_buffer.seek(0)\n            except CrcException as exc:\n                # re-raise an exception that inherits from ConnectionException\n                raise CrcMismatchException(str(exc), self.endpoint)\n        else:\n            self._io_buffer._segment_consumed = False\n\n    def process_io_buffer(self):\n        while True:\n            if self._is_checksumming_enabled and self._io_buffer.readable_io_bytes():\n                self._process_segment_buffer()\n                self._io_buffer.reset_io_buffer()\n\n            if self._is_checksumming_enabled and not self._io_buffer.has_consumed_segment:\n                # We couldn't read an entire segment from the io buffer, so return\n                # control to allow more bytes to be read off the wire\n                return\n\n            if not self._current_frame:\n                pos = self._read_frame_header()\n            else:\n                pos = self._io_buffer.readable_cql_frame_bytes()\n\n            if not self._current_frame or pos < self._current_frame.end_pos:\n                if self._is_checksumming_enabled and self._io_buffer.readable_io_bytes():\n                    # We have a multi-segments message and we need to read more\n                    # data to complete the current cql frame\n                    continue\n\n                # we don't have a complete header yet or we\n                # already saw a header, but we don't have a\n                # complete message yet\n                return\n            else:\n                frame = self._current_frame\n                self._io_buffer.cql_frame_buffer.seek(frame.body_offset)\n                msg = self._io_buffer.cql_frame_buffer.read(frame.end_pos - frame.body_offset)\n                self.process_msg(frame, msg)\n                self._io_buffer.reset_cql_frame_buffer()\n                self._current_frame = None\n\n    @defunct_on_error\n    def process_msg(self, header, body):\n        self.msg_received = True\n        stream_id = header.stream\n        if stream_id < 0:\n            callback = None\n            decoder = ProtocolHandler.decode_message\n            result_metadata = None\n        else:\n            if stream_id in self._continuous_paging_sessions:\n                paging_session = self._continuous_paging_sessions[stream_id]\n                callback = paging_session.on_message\n                decoder = paging_session.decoder\n                result_metadata = None\n            else:\n                need_notify_of_release = False\n                with self.lock:\n                    if stream_id in self.orphaned_request_ids:\n                        self.in_flight -= 1\n                        self.orphaned_request_ids.remove(stream_id)\n                        need_notify_of_release = True\n                if need_notify_of_release and self._on_orphaned_stream_released:\n                    self._on_orphaned_stream_released()\n\n                try:\n                    callback, decoder, result_metadata = self._requests.pop(stream_id)\n                # This can only happen if the stream_id was\n                # removed due to an OperationTimedOut\n                except KeyError:\n                    with self.lock:\n                        self.request_ids.append(stream_id)\n                    return\n\n        try:\n            response = decoder(header.version, self.user_type_map, stream_id,\n                               header.flags, header.opcode, body, self.decompressor, result_metadata)\n        except Exception as exc:\n            log.exception(\"Error decoding response from Cassandra. \"\n                          \"%s; buffer: %r\", header, self._iobuf.getvalue())\n            if callback is not None:\n                callback(exc)\n            self.defunct(exc)\n            return\n\n        try:\n            if stream_id >= 0:\n                if isinstance(response, ProtocolException):\n                    if 'unsupported protocol version' in response.message:\n                        self.is_unsupported_proto_version = True\n                    else:\n                        log.error(\"Closing connection %s due to protocol error: %s\", self, response.summary_msg())\n                    self.defunct(response)\n                if callback is not None:\n                    callback(response)\n            else:\n                self.handle_pushed(response)\n        except Exception:\n            log.exception(\"Callback handler errored, ignoring:\")\n\n        # done after callback because the callback might signal this as a paging session\n        if stream_id >= 0:\n            if stream_id in self._continuous_paging_sessions:\n                if self._continuous_paging_sessions[stream_id].released:\n                    self.remove_continuous_paging_session(stream_id)\n            else:\n                with self.lock:\n                    self.request_ids.append(stream_id)\n\n    def new_continuous_paging_session(self, stream_id, decoder, row_factory, state):\n        session = ContinuousPagingSession(stream_id, decoder, row_factory, self, state)\n        self._continuous_paging_sessions[stream_id] = session\n        return session\n\n    def remove_continuous_paging_session(self, stream_id):\n        try:\n            self._continuous_paging_sessions.pop(stream_id)\n            with self.lock:\n                log.debug(\"Returning cp session stream id %s\", stream_id)\n                self.request_ids.append(stream_id)\n        except KeyError:\n            pass\n\n    @defunct_on_error\n    def _send_options_message(self):\n        log.debug(\"Sending initial options message for new connection (%s) to %s\", id(self), self.endpoint)\n        self.send_msg(OptionsMessage(), self.get_request_id(), self._handle_options_response)\n\n    @defunct_on_error\n    def _handle_options_response(self, options_response):\n        if self.is_defunct:\n            return\n\n        if not isinstance(options_response, SupportedMessage):\n            if isinstance(options_response, ConnectionException):\n                raise options_response\n            else:\n                log.error(\"Did not get expected SupportedMessage response; \"\n                          \"instead, got: %s\", options_response)\n                raise ConnectionException(\"Did not get expected SupportedMessage \"\n                                          \"response; instead, got: %s\"\n                                          % (options_response,))\n\n        log.debug(\"Received options response on new connection (%s) from %s\",\n                  id(self), self.endpoint)\n        supported_cql_versions = options_response.cql_versions\n        remote_supported_compressions = options_response.options['COMPRESSION']\n        self._product_type = options_response.options.get('PRODUCT_TYPE', [None])[0]\n\n        if self.cql_version:\n            if self.cql_version not in supported_cql_versions:\n                raise ProtocolError(\n                    \"cql_version %r is not supported by remote (w/ native \"\n                    \"protocol). Supported versions: %r\"\n                    % (self.cql_version, supported_cql_versions))\n        else:\n            self.cql_version = supported_cql_versions[0]\n\n        self._compressor = None\n        compression_type = None\n        if self.compression:\n            overlap = (set(locally_supported_compressions.keys()) &\n                       set(remote_supported_compressions))\n            if len(overlap) == 0:\n                log.debug(\"No available compression types supported on both ends.\"\n                          \" locally supported: %r. remotely supported: %r\",\n                          locally_supported_compressions.keys(),\n                          remote_supported_compressions)\n            else:\n                compression_type = None\n                if isinstance(self.compression, str):\n                    # the user picked a specific compression type ('snappy' or 'lz4')\n                    if self.compression not in remote_supported_compressions:\n                        raise ProtocolError(\n                            \"The requested compression type (%s) is not supported by the Cassandra server at %s\"\n                            % (self.compression, self.endpoint))\n                    compression_type = self.compression\n                else:\n                    # our locally supported compressions are ordered to prefer\n                    # lz4, if available\n                    for k in locally_supported_compressions.keys():\n                        if k in overlap:\n                            compression_type = k\n                            break\n\n                # If snappy compression is selected with v5+checksumming, the connection\n                # will fail with OTO. Only lz4 is supported\n                if (compression_type == 'snappy' and\n                        ProtocolVersion.has_checksumming_support(self.protocol_version)):\n                    log.debug(\"Snappy compression is not supported with protocol version %s and \"\n                              \"checksumming. Consider installing lz4. Disabling compression.\", self.protocol_version)\n                    compression_type = None\n                else:\n                    # set the decompressor here, but set the compressor only after\n                    # a successful Ready message\n                    self._compression_type = compression_type\n                    self._compressor, self.decompressor = \\\n                        locally_supported_compressions[compression_type]\n\n        self._send_startup_message(compression_type, no_compact=self.no_compact)\n\n    @defunct_on_error\n    def _send_startup_message(self, compression=None, no_compact=False):\n        log.debug(\"Sending StartupMessage on %s\", self)\n        opts = {'DRIVER_NAME': DRIVER_NAME,\n                'DRIVER_VERSION': DRIVER_VERSION}\n        if compression:\n            opts['COMPRESSION'] = compression\n        if no_compact:\n            opts['NO_COMPACT'] = 'true'\n        sm = StartupMessage(cqlversion=self.cql_version, options=opts)\n        self.send_msg(sm, self.get_request_id(), cb=self._handle_startup_response)\n        log.debug(\"Sent StartupMessage on %s\", self)\n\n    @defunct_on_error\n    def _handle_startup_response(self, startup_response, did_authenticate=False):\n        if self.is_defunct:\n            return\n\n        if isinstance(startup_response, ReadyMessage):\n            if self.authenticator:\n                log.warning(\"An authentication challenge was not sent, \"\n                            \"this is suspicious because the driver expects \"\n                            \"authentication (configured authenticator = %s)\",\n                            self.authenticator.__class__.__name__)\n\n            log.debug(\"Got ReadyMessage on new connection (%s) from %s\", id(self), self.endpoint)\n            self._enable_compression()\n\n            if ProtocolVersion.has_checksumming_support(self.protocol_version):\n                self._enable_checksumming()\n\n            self.connected_event.set()\n        elif isinstance(startup_response, AuthenticateMessage):\n            log.debug(\"Got AuthenticateMessage on new connection (%s) from %s: %s\",\n                      id(self), self.endpoint, startup_response.authenticator)\n\n            if self.authenticator is None:\n                log.error(\"Failed to authenticate to %s. If you are trying to connect to a DSE cluster, \"\n                          \"consider using TransitionalModePlainTextAuthProvider \"\n                          \"if DSE authentication is configured with transitional mode\" % (self.host,))\n                raise AuthenticationFailed('Remote end requires authentication')\n\n            self._enable_compression()\n            if ProtocolVersion.has_checksumming_support(self.protocol_version):\n                self._enable_checksumming()\n\n            if isinstance(self.authenticator, dict):\n                log.debug(\"Sending credentials-based auth response on %s\", self)\n                cm = CredentialsMessage(creds=self.authenticator)\n                callback = partial(self._handle_startup_response, did_authenticate=True)\n                self.send_msg(cm, self.get_request_id(), cb=callback)\n            else:\n                log.debug(\"Sending SASL-based auth response on %s\", self)\n                self.authenticator.server_authenticator_class = startup_response.authenticator\n                initial_response = self.authenticator.initial_response()\n                initial_response = \"\" if initial_response is None else initial_response\n                self.send_msg(AuthResponseMessage(initial_response), self.get_request_id(),\n                              self._handle_auth_response)\n        elif isinstance(startup_response, ErrorMessage):\n            log.debug(\"Received ErrorMessage on new connection (%s) from %s: %s\",\n                      id(self), self.endpoint, startup_response.summary_msg())\n            if did_authenticate:\n                raise AuthenticationFailed(\n                    \"Failed to authenticate to %s: %s\" %\n                    (self.endpoint, startup_response.summary_msg()))\n            else:\n                raise ConnectionException(\n                    \"Failed to initialize new connection to %s: %s\"\n                    % (self.endpoint, startup_response.summary_msg()))\n        elif isinstance(startup_response, ConnectionShutdown):\n            log.debug(\"Connection to %s was closed during the startup handshake\", (self.endpoint))\n            raise startup_response\n        else:\n            msg = \"Unexpected response during Connection setup: %r\"\n            log.error(msg, startup_response)\n            raise ProtocolError(msg % (startup_response,))\n\n    @defunct_on_error\n    def _handle_auth_response(self, auth_response):\n        if self.is_defunct:\n            return\n\n        if isinstance(auth_response, AuthSuccessMessage):\n            log.debug(\"Connection %s successfully authenticated\", self)\n            self.authenticator.on_authentication_success(auth_response.token)\n            if self._compressor:\n                self.compressor = self._compressor\n            self.connected_event.set()\n        elif isinstance(auth_response, AuthChallengeMessage):\n            response = self.authenticator.evaluate_challenge(auth_response.challenge)\n            msg = AuthResponseMessage(\"\" if response is None else response)\n            log.debug(\"Responding to auth challenge on %s\", self)\n            self.send_msg(msg, self.get_request_id(), self._handle_auth_response)\n        elif isinstance(auth_response, ErrorMessage):\n            log.debug(\"Received ErrorMessage on new connection (%s) from %s: %s\",\n                      id(self), self.endpoint, auth_response.summary_msg())\n            raise AuthenticationFailed(\n                \"Failed to authenticate to %s: %s\" %\n                (self.endpoint, auth_response.summary_msg()))\n        elif isinstance(auth_response, ConnectionShutdown):\n            log.debug(\"Connection to %s was closed during the authentication process\", self.endpoint)\n            raise auth_response\n        else:\n            msg = \"Unexpected response during Connection authentication to %s: %r\"\n            log.error(msg, self.endpoint, auth_response)\n            raise ProtocolError(msg % (self.endpoint, auth_response))\n\n    def set_keyspace_blocking(self, keyspace):\n        if not keyspace or keyspace == self.keyspace:\n            return\n\n        query = QueryMessage(query='USE \"%s\"' % (keyspace,),\n                             consistency_level=ConsistencyLevel.ONE)\n        try:\n            result = self.wait_for_response(query)\n        except InvalidRequestException as ire:\n            # the keyspace probably doesn't exist\n            raise ire.to_exception()\n        except Exception as exc:\n            conn_exc = ConnectionException(\n                \"Problem while setting keyspace: %r\" % (exc,), self.endpoint)\n            self.defunct(conn_exc)\n            raise conn_exc\n\n        if isinstance(result, ResultMessage):\n            self.keyspace = keyspace\n        else:\n            conn_exc = ConnectionException(\n                \"Problem while setting keyspace: %r\" % (result,), self.endpoint)\n            self.defunct(conn_exc)\n            raise conn_exc\n\n    def set_keyspace_async(self, keyspace, callback):\n        \"\"\"\n        Use this in order to avoid deadlocking the event loop thread.\n        When the operation completes, `callback` will be called with\n        two arguments: this connection and an Exception if an error\n        occurred, otherwise :const:`None`.\n\n        This method will always increment :attr:`.in_flight` attribute, even if\n        it doesn't need to make a request, just to maintain an\n        \":attr:`.in_flight` is incremented\" invariant.\n        \"\"\"\n        # Here we increment in_flight unconditionally, whether we need to issue\n        # a request or not. This is bad, but allows callers -- specifically\n        # _set_keyspace_for_all_conns -- to assume that we increment\n        # self.in_flight during this call. This allows the passed callback to\n        # safely call HostConnection{Pool,}.return_connection on this\n        # Connection.\n        #\n        # We use a busy wait on the lock here because:\n        # - we'll only spin if the connection is at max capacity, which is very\n        #   unlikely for a set_keyspace call\n        # - it allows us to avoid signaling a condition every time a request completes\n        while True:\n            with self.lock:\n                if self.in_flight < self.max_request_id:\n                    self.in_flight += 1\n                    break\n            time.sleep(0.001)\n\n        if not keyspace or keyspace == self.keyspace:\n            callback(self, None)\n            return\n\n        query = QueryMessage(query='USE \"%s\"' % (keyspace,),\n                             consistency_level=ConsistencyLevel.ONE)\n\n        def process_result(result):\n            if isinstance(result, ResultMessage):\n                self.keyspace = keyspace\n                callback(self, None)\n            elif isinstance(result, InvalidRequestException):\n                callback(self, result.to_exception())\n            else:\n                callback(self, self.defunct(ConnectionException(\n                    \"Problem while setting keyspace: %r\" % (result,), self.endpoint)))\n\n        # We've incremented self.in_flight above, so we \"have permission\" to\n        # acquire a new request id\n        request_id = self.get_request_id()\n\n        self.send_msg(query, request_id, process_result)\n\n    @property\n    def is_idle(self):\n        return not self.msg_received\n\n    def reset_idle(self):\n        self.msg_received = False\n\n    def __str__(self):\n        status = \"\"\n        if self.is_defunct:\n            status = \" (defunct)\"\n        elif self.is_closed:\n            status = \" (closed)\"\n\n        return \"<%s(%r) %s%s>\" % (self.__class__.__name__, id(self), self.endpoint, status)\n    __repr__ = __str__\n\n\nclass ResponseWaiter(object):\n\n    def __init__(self, connection, num_responses, fail_on_error):\n        self.connection = connection\n        self.pending = num_responses\n        self.fail_on_error = fail_on_error\n        self.error = None\n        self.responses = [None] * num_responses\n        self.event = Event()\n\n    def got_response(self, response, index):\n        with self.connection.lock:\n            self.connection.in_flight -= 1\n        if isinstance(response, Exception):\n            if hasattr(response, 'to_exception'):\n                response = response.to_exception()\n            if self.fail_on_error:\n                self.error = response\n                self.event.set()\n            else:\n                self.responses[index] = (False, response)\n        else:\n            if not self.fail_on_error:\n                self.responses[index] = (True, response)\n            else:\n                self.responses[index] = response\n\n        self.pending -= 1\n        if not self.pending:\n            self.event.set()\n\n    def deliver(self, timeout=None):\n        \"\"\"\n        If fail_on_error was set to False, a list of (success, response)\n        tuples will be returned.  If success is False, response will be\n        an Exception.  Otherwise, response will be the normal query response.\n\n        If fail_on_error was left as True and one of the requests\n        failed, the corresponding Exception will be raised. Otherwise,\n        the normal response will be returned.\n        \"\"\"\n        self.event.wait(timeout)\n        if self.error:\n            raise self.error\n        elif not self.event.is_set():\n            raise OperationTimedOut()\n        else:\n            return self.responses\n\n\nclass HeartbeatFuture(object):\n    def __init__(self, connection, owner):\n        self._exception = None\n        self._event = Event()\n        self.connection = connection\n        self.owner = owner\n        log.debug(\"Sending options message heartbeat on idle connection (%s) %s\",\n                  id(connection), connection.endpoint)\n        with connection.lock:\n            if connection.in_flight < connection.max_request_id:\n                connection.in_flight += 1\n                connection.send_msg(OptionsMessage(), connection.get_request_id(), self._options_callback)\n            else:\n                self._exception = Exception(\"Failed to send heartbeat because connection 'in_flight' exceeds threshold\")\n                self._event.set()\n\n    def wait(self, timeout):\n        self._event.wait(timeout)\n        if self._event.is_set():\n            if self._exception:\n                raise self._exception\n        else:\n            raise OperationTimedOut(\"Connection heartbeat timeout after %s seconds\" % (timeout,), self.connection.endpoint)\n\n    def _options_callback(self, response):\n        if isinstance(response, SupportedMessage):\n            log.debug(\"Received options response on connection (%s) from %s\",\n                      id(self.connection), self.connection.endpoint)\n        else:\n            if isinstance(response, ConnectionException):\n                self._exception = response\n            else:\n                self._exception = ConnectionException(\"Received unexpected response to OptionsMessage: %s\"\n                                                      % (response,))\n        self._event.set()\n\n\nclass ConnectionHeartbeat(Thread):\n\n    def __init__(self, interval_sec, get_connection_holders, timeout):\n        Thread.__init__(self, name=\"Connection heartbeat\")\n        self._interval = interval_sec\n        self._timeout = timeout\n        self._get_connection_holders = get_connection_holders\n        self._shutdown_event = Event()\n        self.daemon = True\n        self.start()\n\n    class ShutdownException(Exception):\n        pass\n\n    def run(self):\n        self._shutdown_event.wait(self._interval)\n        while not self._shutdown_event.is_set():\n            start_time = time.time()\n\n            futures = []\n            failed_connections = []\n            try:\n                for connections, owner in [(o.get_connections(), o) for o in self._get_connection_holders()]:\n                    for connection in connections:\n                        self._raise_if_stopped()\n                        if not (connection.is_defunct or connection.is_closed):\n                            if connection.is_idle:\n                                try:\n                                    futures.append(HeartbeatFuture(connection, owner))\n                                except Exception as e:\n                                    log.warning(\"Failed sending heartbeat message on connection (%s) to %s\",\n                                                id(connection), connection.endpoint)\n                                    failed_connections.append((connection, owner, e))\n                            else:\n                                connection.reset_idle()\n                        else:\n                            log.debug(\"Cannot send heartbeat message on connection (%s) to %s\",\n                                      id(connection), connection.endpoint)\n                            # make sure the owner sees this defunt/closed connection\n                            owner.return_connection(connection)\n                    self._raise_if_stopped()\n\n                # Wait max `self._timeout` seconds for all HeartbeatFutures to complete\n                timeout = self._timeout\n                start_time = time.time()\n                for f in futures:\n                    self._raise_if_stopped()\n                    connection = f.connection\n                    try:\n                        f.wait(timeout)\n                        # TODO: move this, along with connection locks in pool, down into Connection\n                        with connection.lock:\n                            connection.in_flight -= 1\n                        connection.reset_idle()\n                    except Exception as e:\n                        log.warning(\"Heartbeat failed for connection (%s) to %s\",\n                                    id(connection), connection.endpoint)\n                        failed_connections.append((f.connection, f.owner, e))\n\n                    timeout = self._timeout - (time.time() - start_time)\n\n                for connection, owner, exc in failed_connections:\n                    self._raise_if_stopped()\n                    if not connection.is_control_connection:\n                        # Only HostConnection supports shutdown_on_error\n                        owner.shutdown_on_error = True\n                    connection.defunct(exc)\n                    owner.return_connection(connection)\n            except self.ShutdownException:\n                pass\n            except Exception:\n                log.error(\"Failed connection heartbeat\", exc_info=True)\n\n            elapsed = time.time() - start_time\n            self._shutdown_event.wait(max(self._interval - elapsed, 0.01))\n\n    def stop(self):\n        self._shutdown_event.set()\n        self.join()\n\n    def _raise_if_stopped(self):\n        if self._shutdown_event.is_set():\n            raise self.ShutdownException()\n\n\nclass Timer(object):\n\n    canceled = False\n\n    def __init__(self, timeout, callback):\n        self.end = time.time() + timeout\n        self.callback = callback\n\n    def __lt__(self, other):\n        return self.end < other.end\n\n    def cancel(self):\n        self.canceled = True\n\n    def finish(self, time_now):\n        if self.canceled:\n            return True\n\n        if time_now >= self.end:\n            self.callback()\n            return True\n\n        return False\n\n\nclass TimerManager(object):\n\n    def __init__(self):\n        self._queue = []\n        self._new_timers = []\n\n    def add_timer(self, timer):\n        \"\"\"\n        called from client thread with a Timer object\n        \"\"\"\n        self._new_timers.append((timer.end, timer))\n\n    def service_timeouts(self):\n        \"\"\"\n        run callbacks on all expired timers\n        Called from the event thread\n        :return: next end time, or None\n        \"\"\"\n        queue = self._queue\n        if self._new_timers:\n            new_timers = self._new_timers\n            while new_timers:\n                heappush(queue, new_timers.pop())\n\n        if queue:\n            now = time.time()\n            while queue:\n                try:\n                    timer = queue[0][1]\n                    if timer.finish(now):\n                        heappop(queue)\n                    else:\n                        return timer.end\n                except Exception:\n                    log.exception(\"Exception while servicing timeout callback: \")\n\n    @property\n    def next_timeout(self):\n        try:\n            return self._queue[0][0]\n        except IndexError:\n            pass\n",
    "cassandra/policies.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom collections import namedtuple\nfrom functools import lru_cache\nfrom itertools import islice, cycle, groupby, repeat\nimport logging\nfrom random import randint, shuffle\nfrom threading import Lock\nimport socket\nimport warnings\n\nlog = logging.getLogger(__name__)\n\nfrom cassandra import WriteType as WT\n\n# This is done this way because WriteType was originally\n# defined here and in order not to break the API.\n# It may removed in the next mayor.\nWriteType = WT\n\nfrom cassandra import ConsistencyLevel, OperationTimedOut\n\nclass HostDistance(object):\n    \"\"\"\n    A measure of how \"distant\" a node is from the client, which\n    may influence how the load balancer distributes requests\n    and how many connections are opened to the node.\n    \"\"\"\n\n    IGNORED = -1\n    \"\"\"\n    A node with this distance should never be queried or have\n    connections opened to it.\n    \"\"\"\n\n    LOCAL = 0\n    \"\"\"\n    Nodes with ``LOCAL`` distance will be preferred for operations\n    under some load balancing policies (such as :class:`.DCAwareRoundRobinPolicy`)\n    and will have a greater number of connections opened against\n    them by default.\n\n    This distance is typically used for nodes within the same\n    datacenter as the client.\n    \"\"\"\n\n    REMOTE = 1\n    \"\"\"\n    Nodes with ``REMOTE`` distance will be treated as a last resort\n    by some load balancing policies (such as :class:`.DCAwareRoundRobinPolicy`)\n    and will have a smaller number of connections opened against\n    them by default.\n\n    This distance is typically used for nodes outside of the\n    datacenter that the client is running in.\n    \"\"\"\n\n\nclass HostStateListener(object):\n\n    def on_up(self, host):\n        \"\"\" Called when a node is marked up. \"\"\"\n        raise NotImplementedError()\n\n    def on_down(self, host):\n        \"\"\" Called when a node is marked down. \"\"\"\n        raise NotImplementedError()\n\n    def on_add(self, host):\n        \"\"\"\n        Called when a node is added to the cluster.  The newly added node\n        should be considered up.\n        \"\"\"\n        raise NotImplementedError()\n\n    def on_remove(self, host):\n        \"\"\" Called when a node is removed from the cluster. \"\"\"\n        raise NotImplementedError()\n\n\nclass LoadBalancingPolicy(HostStateListener):\n    \"\"\"\n    Load balancing policies are used to decide how to distribute\n    requests among all possible coordinator nodes in the cluster.\n\n    In particular, they may focus on querying \"near\" nodes (those\n    in a local datacenter) or on querying nodes who happen to\n    be replicas for the requested data.\n\n    You may also use subclasses of :class:`.LoadBalancingPolicy` for\n    custom behavior.\n    \"\"\"\n\n    _hosts_lock = None\n\n    def __init__(self):\n        self._hosts_lock = Lock()\n\n    def distance(self, host):\n        \"\"\"\n        Returns a measure of how remote a :class:`~.pool.Host` is in\n        terms of the :class:`.HostDistance` enums.\n        \"\"\"\n        raise NotImplementedError()\n\n    def populate(self, cluster, hosts):\n        \"\"\"\n        This method is called to initialize the load balancing\n        policy with a set of :class:`.Host` instances before its\n        first use.  The `cluster` parameter is an instance of\n        :class:`.Cluster`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        \"\"\"\n        Given a :class:`~.query.Statement` instance, return a iterable\n        of :class:`.Host` instances which should be queried in that\n        order.  A generator may work well for custom implementations\n        of this method.\n\n        Note that the `query` argument may be :const:`None` when preparing\n        statements.\n\n        `working_keyspace` should be the string name of the current keyspace,\n        as set through :meth:`.Session.set_keyspace()` or with a ``USE``\n        statement.\n        \"\"\"\n        raise NotImplementedError()\n\n    def check_supported(self):\n        \"\"\"\n        This will be called after the cluster Metadata has been initialized.\n        If the load balancing policy implementation cannot be supported for\n        some reason (such as a missing C extension), this is the point at\n        which it should raise an exception.\n        \"\"\"\n        pass\n\n\nclass RoundRobinPolicy(LoadBalancingPolicy):\n    \"\"\"\n    A subclass of :class:`.LoadBalancingPolicy` which evenly\n    distributes queries across all nodes in the cluster,\n    regardless of what datacenter the nodes may be in.\n    \"\"\"\n    _live_hosts = frozenset(())\n    _position = 0\n\n    def populate(self, cluster, hosts):\n        self._live_hosts = frozenset(hosts)\n        if len(hosts) > 1:\n            self._position = randint(0, len(hosts) - 1)\n\n    def distance(self, host):\n        return HostDistance.LOCAL\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        # not thread-safe, but we don't care much about lost increments\n        # for the purposes of load balancing\n        pos = self._position\n        self._position += 1\n\n        hosts = self._live_hosts\n        length = len(hosts)\n        if length:\n            pos %= length\n            return islice(cycle(hosts), pos, pos + length)\n        else:\n            return []\n\n    def on_up(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.union((host, ))\n\n    def on_down(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.difference((host, ))\n\n    def on_add(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.union((host, ))\n\n    def on_remove(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.difference((host, ))\n\n\nclass DCAwareRoundRobinPolicy(LoadBalancingPolicy):\n    \"\"\"\n    Similar to :class:`.RoundRobinPolicy`, but prefers hosts\n    in the local datacenter and only uses nodes in remote\n    datacenters as a last resort.\n    \"\"\"\n\n    local_dc = None\n    used_hosts_per_remote_dc = 0\n\n    def __init__(self, local_dc='', used_hosts_per_remote_dc=0):\n        \"\"\"\n        The `local_dc` parameter should be the name of the datacenter\n        (such as is reported by ``nodetool ring``) that should\n        be considered local. If not specified, the driver will choose\n        a local_dc based on the first host among :attr:`.Cluster.contact_points`\n        having a valid DC. If relying on this mechanism, all specified\n        contact points should be nodes in a single, local DC.\n\n        `used_hosts_per_remote_dc` controls how many nodes in\n        each remote datacenter will have connections opened\n        against them. In other words, `used_hosts_per_remote_dc` hosts\n        will be considered :attr:`~.HostDistance.REMOTE` and the\n        rest will be considered :attr:`~.HostDistance.IGNORED`.\n        By default, all remote hosts are ignored.\n        \"\"\"\n        self.local_dc = local_dc\n        self.used_hosts_per_remote_dc = used_hosts_per_remote_dc\n        self._dc_live_hosts = {}\n        self._position = 0\n        self._endpoints = []\n        LoadBalancingPolicy.__init__(self)\n\n    def _dc(self, host):\n        return host.datacenter or self.local_dc\n\n    def populate(self, cluster, hosts):\n        for dc, dc_hosts in groupby(hosts, lambda h: self._dc(h)):\n            self._dc_live_hosts[dc] = tuple(set(dc_hosts))\n\n        if not self.local_dc:\n            self._endpoints = [\n                endpoint\n                for endpoint in cluster.endpoints_resolved]\n\n        self._position = randint(0, len(hosts) - 1) if hosts else 0\n\n    def distance(self, host):\n        dc = self._dc(host)\n        if dc == self.local_dc:\n            return HostDistance.LOCAL\n\n        if not self.used_hosts_per_remote_dc:\n            return HostDistance.IGNORED\n        else:\n            dc_hosts = self._dc_live_hosts.get(dc)\n            if not dc_hosts:\n                return HostDistance.IGNORED\n\n            if host in list(dc_hosts)[:self.used_hosts_per_remote_dc]:\n                return HostDistance.REMOTE\n            else:\n                return HostDistance.IGNORED\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        # not thread-safe, but we don't care much about lost increments\n        # for the purposes of load balancing\n        pos = self._position\n        self._position += 1\n\n        local_live = self._dc_live_hosts.get(self.local_dc, ())\n        pos = (pos % len(local_live)) if local_live else 0\n        for host in islice(cycle(local_live), pos, pos + len(local_live)):\n            yield host\n\n        # the dict can change, so get candidate DCs iterating over keys of a copy\n        other_dcs = [dc for dc in self._dc_live_hosts.copy().keys() if dc != self.local_dc]\n        for dc in other_dcs:\n            remote_live = self._dc_live_hosts.get(dc, ())\n            for host in remote_live[:self.used_hosts_per_remote_dc]:\n                yield host\n\n    def on_up(self, host):\n        # not worrying about threads because this will happen during\n        # control connection startup/refresh\n        if not self.local_dc and host.datacenter:\n            if host.endpoint in self._endpoints:\n                self.local_dc = host.datacenter\n                log.info(\"Using datacenter '%s' for DCAwareRoundRobinPolicy (via host '%s'); \"\n                         \"if incorrect, please specify a local_dc to the constructor, \"\n                         \"or limit contact points to local cluster nodes\" %\n                         (self.local_dc, host.endpoint))\n                del self._endpoints\n\n        dc = self._dc(host)\n        with self._hosts_lock:\n            current_hosts = self._dc_live_hosts.get(dc, ())\n            if host not in current_hosts:\n                self._dc_live_hosts[dc] = current_hosts + (host, )\n\n    def on_down(self, host):\n        dc = self._dc(host)\n        with self._hosts_lock:\n            current_hosts = self._dc_live_hosts.get(dc, ())\n            if host in current_hosts:\n                hosts = tuple(h for h in current_hosts if h != host)\n                if hosts:\n                    self._dc_live_hosts[dc] = hosts\n                else:\n                    del self._dc_live_hosts[dc]\n\n    def on_add(self, host):\n        self.on_up(host)\n\n    def on_remove(self, host):\n        self.on_down(host)\n\n\nclass TokenAwarePolicy(LoadBalancingPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` wrapper that adds token awareness to\n    a child policy.\n\n    This alters the child policy's behavior so that it first attempts to\n    send queries to :attr:`~.HostDistance.LOCAL` replicas (as determined\n    by the child policy) based on the :class:`.Statement`'s\n    :attr:`~.Statement.routing_key`. If :attr:`.shuffle_replicas` is\n    truthy, these replicas will be yielded in a random order. Once those\n    hosts are exhausted, the remaining hosts in the child policy's query\n    plan will be used in the order provided by the child policy.\n\n    If no :attr:`~.Statement.routing_key` is set on the query, the child\n    policy's query plan will be used as is.\n    \"\"\"\n\n    _child_policy = None\n    _cluster_metadata = None\n    shuffle_replicas = False\n    \"\"\"\n    Yield local replicas in a random order.\n    \"\"\"\n\n    def __init__(self, child_policy, shuffle_replicas=False):\n        self._child_policy = child_policy\n        self.shuffle_replicas = shuffle_replicas\n\n    def populate(self, cluster, hosts):\n        self._cluster_metadata = cluster.metadata\n        self._child_policy.populate(cluster, hosts)\n\n    def check_supported(self):\n        if not self._cluster_metadata.can_support_partitioner():\n            raise RuntimeError(\n                '%s cannot be used with the cluster partitioner (%s) because '\n                'the relevant C extension for this driver was not compiled. '\n                'See the installation instructions for details on building '\n                'and installing the C extensions.' %\n                (self.__class__.__name__, self._cluster_metadata.partitioner))\n\n    def distance(self, *args, **kwargs):\n        return self._child_policy.distance(*args, **kwargs)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        if query and query.keyspace:\n            keyspace = query.keyspace\n        else:\n            keyspace = working_keyspace\n\n        child = self._child_policy\n        if query is None:\n            for host in child.make_query_plan(keyspace, query):\n                yield host\n        else:\n            routing_key = query.routing_key\n            if routing_key is None or keyspace is None:\n                for host in child.make_query_plan(keyspace, query):\n                    yield host\n            else:\n                replicas = self._cluster_metadata.get_replicas(keyspace, routing_key)\n                if self.shuffle_replicas:\n                    shuffle(replicas)\n                for replica in replicas:\n                    if replica.is_up and \\\n                            child.distance(replica) == HostDistance.LOCAL:\n                        yield replica\n\n                for host in child.make_query_plan(keyspace, query):\n                    # skip if we've already listed this host\n                    if host not in replicas or \\\n                            child.distance(host) == HostDistance.REMOTE:\n                        yield host\n\n    def on_up(self, *args, **kwargs):\n        return self._child_policy.on_up(*args, **kwargs)\n\n    def on_down(self, *args, **kwargs):\n        return self._child_policy.on_down(*args, **kwargs)\n\n    def on_add(self, *args, **kwargs):\n        return self._child_policy.on_add(*args, **kwargs)\n\n    def on_remove(self, *args, **kwargs):\n        return self._child_policy.on_remove(*args, **kwargs)\n\n\nclass WhiteListRoundRobinPolicy(RoundRobinPolicy):\n    \"\"\"\n    A subclass of :class:`.RoundRobinPolicy` which evenly\n    distributes queries across all nodes in the cluster,\n    regardless of what datacenter the nodes may be in, but\n    only if that node exists in the list of allowed nodes\n\n    This policy is addresses the issue described in\n    https://datastax-oss.atlassian.net/browse/JAVA-145\n    Where connection errors occur when connection\n    attempts are made to private IP addresses remotely\n    \"\"\"\n\n    def __init__(self, hosts):\n        \"\"\"\n        The `hosts` parameter should be a sequence of hosts to permit\n        connections to.\n        \"\"\"\n        self._allowed_hosts = tuple(hosts)\n        self._allowed_hosts_resolved = [endpoint[4][0] for a in self._allowed_hosts\n                                        for endpoint in socket.getaddrinfo(a, None, socket.AF_UNSPEC, socket.SOCK_STREAM)]\n\n        RoundRobinPolicy.__init__(self)\n\n    def populate(self, cluster, hosts):\n        self._live_hosts = frozenset(h for h in hosts if h.address in self._allowed_hosts_resolved)\n\n        if len(hosts) <= 1:\n            self._position = 0\n        else:\n            self._position = randint(0, len(hosts) - 1)\n\n    def distance(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            return HostDistance.LOCAL\n        else:\n            return HostDistance.IGNORED\n\n    def on_up(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            RoundRobinPolicy.on_up(self, host)\n\n    def on_add(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            RoundRobinPolicy.on_add(self, host)\n\n\nclass HostFilterPolicy(LoadBalancingPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` subclass configured with a child policy,\n    and a single-argument predicate. This policy defers to the child policy for\n    hosts where ``predicate(host)`` is truthy. Hosts for which\n    ``predicate(host)`` is falsy will be considered :attr:`.IGNORED`, and will\n    not be used in a query plan.\n\n    This can be used in the cases where you need a whitelist or blacklist\n    policy, e.g. to prepare for decommissioning nodes or for testing:\n\n    .. code-block:: python\n\n        def address_is_ignored(host):\n            return host.address in [ignored_address0, ignored_address1]\n\n        blacklist_filter_policy = HostFilterPolicy(\n            child_policy=RoundRobinPolicy(),\n            predicate=address_is_ignored\n        )\n\n        cluster = Cluster(\n            primary_host,\n            load_balancing_policy=blacklist_filter_policy,\n        )\n\n    See the note in the :meth:`.make_query_plan` documentation for a caveat on\n    how wrapping ordering polices (e.g. :class:`.RoundRobinPolicy`) may break\n    desirable properties of the wrapped policy.\n\n    Please note that whitelist and blacklist policies are not recommended for\n    general, day-to-day use. You probably want something like\n    :class:`.DCAwareRoundRobinPolicy`, which prefers a local DC but has\n    fallbacks, over a brute-force method like whitelisting or blacklisting.\n    \"\"\"\n\n    def __init__(self, child_policy, predicate):\n        \"\"\"\n        :param child_policy: an instantiated :class:`.LoadBalancingPolicy`\n                             that this one will defer to.\n        :param predicate: a one-parameter function that takes a :class:`.Host`.\n                          If it returns a falsy value, the :class:`.Host` will\n                          be :attr:`.IGNORED` and not returned in query plans.\n        \"\"\"\n        super(HostFilterPolicy, self).__init__()\n        self._child_policy = child_policy\n        self._predicate = predicate\n\n    def on_up(self, host, *args, **kwargs):\n        return self._child_policy.on_up(host, *args, **kwargs)\n\n    def on_down(self, host, *args, **kwargs):\n        return self._child_policy.on_down(host, *args, **kwargs)\n\n    def on_add(self, host, *args, **kwargs):\n        return self._child_policy.on_add(host, *args, **kwargs)\n\n    def on_remove(self, host, *args, **kwargs):\n        return self._child_policy.on_remove(host, *args, **kwargs)\n\n    @property\n    def predicate(self):\n        \"\"\"\n        A predicate, set on object initialization, that takes a :class:`.Host`\n        and returns a value. If the value is falsy, the :class:`.Host` is\n        :class:`~HostDistance.IGNORED`. If the value is truthy,\n        :class:`.HostFilterPolicy` defers to the child policy to determine the\n        host's distance.\n\n        This is a read-only value set in ``__init__``, implemented as a\n        ``property``.\n        \"\"\"\n        return self._predicate\n\n    def distance(self, host):\n        \"\"\"\n        Checks if ``predicate(host)``, then returns\n        :attr:`~HostDistance.IGNORED` if falsy, and defers to the child policy\n        otherwise.\n        \"\"\"\n        if self.predicate(host):\n            return self._child_policy.distance(host)\n        else:\n            return HostDistance.IGNORED\n\n    def populate(self, cluster, hosts):\n        self._child_policy.populate(cluster=cluster, hosts=hosts)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        \"\"\"\n        Defers to the child policy's\n        :meth:`.LoadBalancingPolicy.make_query_plan` and filters the results.\n\n        Note that this filtering may break desirable properties of the wrapped\n        policy in some cases. For instance, imagine if you configure this\n        policy to filter out ``host2``, and to wrap a round-robin policy that\n        rotates through three hosts in the order ``host1, host2, host3``,\n        ``host2, host3, host1``, ``host3, host1, host2``, repeating. This\n        policy will yield ``host1, host3``, ``host3, host1``, ``host3, host1``,\n        disproportionately favoring ``host3``.\n        \"\"\"\n        child_qp = self._child_policy.make_query_plan(\n            working_keyspace=working_keyspace, query=query\n        )\n        for host in child_qp:\n            if self.predicate(host):\n                yield host\n\n    def check_supported(self):\n        return self._child_policy.check_supported()\n\n\nclass ConvictionPolicy(object):\n    \"\"\"\n    A policy which decides when hosts should be considered down\n    based on the types of failures and the number of failures.\n\n    If custom behavior is needed, this class may be subclassed.\n    \"\"\"\n\n    def __init__(self, host):\n        \"\"\"\n        `host` is an instance of :class:`.Host`.\n        \"\"\"\n        self.host = host\n\n    def add_failure(self, connection_exc):\n        \"\"\"\n        Implementations should return :const:`True` if the host should be\n        convicted, :const:`False` otherwise.\n        \"\"\"\n        raise NotImplementedError()\n\n    def reset(self):\n        \"\"\"\n        Implementations should clear out any convictions or state regarding\n        the host.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass SimpleConvictionPolicy(ConvictionPolicy):\n    \"\"\"\n    The default implementation of :class:`ConvictionPolicy`,\n    which simply marks a host as down after the first failure\n    of any kind.\n    \"\"\"\n\n    def add_failure(self, connection_exc):\n        return not isinstance(connection_exc, OperationTimedOut)\n\n    def reset(self):\n        pass\n\n\nclass ReconnectionPolicy(object):\n    \"\"\"\n    This class and its subclasses govern how frequently an attempt is made\n    to reconnect to nodes that are marked as dead.\n\n    If custom behavior is needed, this class may be subclassed.\n    \"\"\"\n\n    def new_schedule(self):\n        \"\"\"\n        This should return a finite or infinite iterable of delays (each as a\n        floating point number of seconds) in-between each failed reconnection\n        attempt.  Note that if the iterable is finite, reconnection attempts\n        will cease once the iterable is exhausted.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass ConstantReconnectionPolicy(ReconnectionPolicy):\n    \"\"\"\n    A :class:`.ReconnectionPolicy` subclass which sleeps for a fixed delay\n    in-between each reconnection attempt.\n    \"\"\"\n\n    def __init__(self, delay, max_attempts=64):\n        \"\"\"\n        `delay` should be a floating point number of seconds to wait in-between\n        each attempt.\n\n        `max_attempts` should be a total number of attempts to be made before\n        giving up, or :const:`None` to continue reconnection attempts forever.\n        The default is 64.\n        \"\"\"\n        if delay < 0:\n            raise ValueError(\"delay must not be negative\")\n        if max_attempts is not None and max_attempts < 0:\n            raise ValueError(\"max_attempts must not be negative\")\n\n        self.delay = delay\n        self.max_attempts = max_attempts\n\n    def new_schedule(self):\n        if self.max_attempts:\n            return repeat(self.delay, self.max_attempts)\n        return repeat(self.delay)\n\n\nclass ExponentialReconnectionPolicy(ReconnectionPolicy):\n    \"\"\"\n    A :class:`.ReconnectionPolicy` subclass which exponentially increases\n    the length of the delay in-between each reconnection attempt up to\n    a set maximum delay.\n\n    A random amount of jitter (+/- 15%) will be added to the pure exponential\n    delay value to avoid the situations where many reconnection handlers are\n    trying to reconnect at exactly the same time.\n    \"\"\"\n\n    # TODO: max_attempts is 64 to preserve legacy default behavior\n    # consider changing to None in major release to prevent the policy\n    # giving up forever\n    def __init__(self, base_delay, max_delay, max_attempts=64):\n        \"\"\"\n        `base_delay` and `max_delay` should be in floating point units of\n        seconds.\n\n        `max_attempts` should be a total number of attempts to be made before\n        giving up, or :const:`None` to continue reconnection attempts forever.\n        The default is 64.\n        \"\"\"\n        if base_delay < 0 or max_delay < 0:\n            raise ValueError(\"Delays may not be negative\")\n\n        if max_delay < base_delay:\n            raise ValueError(\"Max delay must be greater than base delay\")\n\n        if max_attempts is not None and max_attempts < 0:\n            raise ValueError(\"max_attempts must not be negative\")\n\n        self.base_delay = base_delay\n        self.max_delay = max_delay\n        self.max_attempts = max_attempts\n\n    def new_schedule(self):\n        i, overflowed = 0, False\n        while self.max_attempts is None or i < self.max_attempts:\n            if overflowed:\n                yield self.max_delay\n            else:\n                try:\n                    yield self._add_jitter(min(self.base_delay * (2 ** i), self.max_delay))\n                except OverflowError:\n                    overflowed = True\n                    yield self.max_delay\n\n            i += 1\n\n    # Adds -+ 15% to the delay provided\n    def _add_jitter(self, value):\n        jitter = randint(85, 115)\n        delay = (jitter * value) / 100\n        return min(max(self.base_delay, delay), self.max_delay)\n\n\nclass RetryPolicy(object):\n    \"\"\"\n    A policy that describes whether to retry, rethrow, or ignore coordinator\n    timeout and unavailable failures. These are failures reported from the\n    server side. Timeouts are configured by\n    `settings in cassandra.yaml <https://github.com/apache/cassandra/blob/cassandra-2.1.4/conf/cassandra.yaml#L568-L584>`_.\n    Unavailable failures occur when the coordinator cannot achieve the consistency\n    level for a request. For further information see the method descriptions\n    below.\n\n    To specify a default retry policy, set the\n    :attr:`.Cluster.default_retry_policy` attribute to an instance of this\n    class or one of its subclasses.\n\n    To specify a retry policy per query, set the :attr:`.Statement.retry_policy`\n    attribute to an instance of this class or one of its subclasses.\n\n    If custom behavior is needed for retrying certain operations,\n    this class may be subclassed.\n    \"\"\"\n\n    RETRY = 0\n    \"\"\"\n    This should be returned from the below methods if the operation\n    should be retried on the same connection.\n    \"\"\"\n\n    RETHROW = 1\n    \"\"\"\n    This should be returned from the below methods if the failure\n    should be propagated and no more retries attempted.\n    \"\"\"\n\n    IGNORE = 2\n    \"\"\"\n    This should be returned from the below methods if the failure\n    should be ignored but no more retries should be attempted.\n    \"\"\"\n\n    RETRY_NEXT_HOST = 3\n    \"\"\"\n    This should be returned from the below methods if the operation\n    should be retried on another connection.\n    \"\"\"\n\n    def on_read_timeout(self, query, consistency, required_responses,\n                        received_responses, data_retrieved, retry_num):\n        \"\"\"\n        This is called when a read operation times out from the coordinator's\n        perspective (i.e. a replica did not respond to the coordinator in time).\n        It should return a tuple with two items: one of the class enums (such\n        as :attr:`.RETRY`) and a :class:`.ConsistencyLevel` to retry the\n        operation at or :const:`None` to keep the same consistency level.\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        The `required_responses` and `received_responses` parameters describe\n        how many replicas needed to respond to meet the requested consistency\n        level and how many actually did respond before the coordinator timed\n        out the request. `data_retrieved` is a boolean indicating whether\n        any of those responses contained data (as opposed to just a digest).\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, operations will be retried at most once, and only if\n        a sufficient number of replicas responded (with data digests).\n        \"\"\"\n        if retry_num != 0:\n            return self.RETHROW, None\n        elif received_responses >= required_responses and not data_retrieved:\n            return self.RETRY, consistency\n        else:\n            return self.RETHROW, None\n\n    def on_write_timeout(self, query, consistency, write_type,\n                         required_responses, received_responses, retry_num):\n        \"\"\"\n        This is called when a write operation times out from the coordinator's\n        perspective (i.e. a replica did not respond to the coordinator in time).\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `write_type` is one of the :class:`.WriteType` enums describing the\n        type of write operation.\n\n        The `required_responses` and `received_responses` parameters describe\n        how many replicas needed to acknowledge the write to meet the requested\n        consistency level and how many replicas actually did acknowledge the\n        write before the coordinator timed out the request.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, failed write operations will retried at most once, and\n        they will only be retried if the `write_type` was\n        :attr:`~.WriteType.BATCH_LOG`.\n        \"\"\"\n        if retry_num != 0:\n            return self.RETHROW, None\n        elif write_type == WriteType.BATCH_LOG:\n            return self.RETRY, consistency\n        else:\n            return self.RETHROW, None\n\n    def on_unavailable(self, query, consistency, required_replicas, alive_replicas, retry_num):\n        \"\"\"\n        This is called when the coordinator node determines that a read or\n        write operation cannot be successful because the number of live\n        replicas are too low to meet the requested :class:`.ConsistencyLevel`.\n        This means that the read or write operation was never forwarded to\n        any replicas.\n\n        `query` is the :class:`.Statement` that failed.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `required_replicas` is the number of replicas that would have needed to\n        acknowledge the operation to meet the requested consistency level.\n        `alive_replicas` is the number of replicas that the coordinator\n        considered alive at the time of the request.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, if this is the first retry, it triggers a retry on the next\n        host in the query plan with the same consistency level. If this is not the\n        first retry, no retries will be attempted and the error will be re-raised.\n        \"\"\"\n        return (self.RETRY_NEXT_HOST, None) if retry_num == 0 else (self.RETHROW, None)\n\n    def on_request_error(self, query, consistency, error, retry_num):\n        \"\"\"\n        This is called when an unexpected error happens. This can be in the\n        following situations:\n\n        * On a connection error\n        * On server errors: overloaded, isBootstrapping, serverError, etc.\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `error` the instance of the exception.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, it triggers a retry on the next host in the query plan\n        with the same consistency level.\n        \"\"\"\n        # TODO revisit this for the next major\n        # To preserve the same behavior than before, we don't take retry_num into account\n        return self.RETRY_NEXT_HOST, None\n\n\nclass FallthroughRetryPolicy(RetryPolicy):\n    \"\"\"\n    A retry policy that never retries and always propagates failures to\n    the application.\n    \"\"\"\n\n    def on_read_timeout(self, *args, **kwargs):\n        return self.RETHROW, None\n\n    def on_write_timeout(self, *args, **kwargs):\n        return self.RETHROW, None\n\n    def on_unavailable(self, *args, **kwargs):\n        return self.RETHROW, None\n\n    def on_request_error(self, *args, **kwargs):\n        return self.RETHROW, None\n\n\nclass DowngradingConsistencyRetryPolicy(RetryPolicy):\n    \"\"\"\n    *Deprecated:* This retry policy will be removed in the next major release.\n\n    A retry policy that sometimes retries with a lower consistency level than\n    the one initially requested.\n\n    **BEWARE**: This policy may retry queries using a lower consistency\n    level than the one initially requested. By doing so, it may break\n    consistency guarantees. In other words, if you use this retry policy,\n    there are cases (documented below) where a read at :attr:`~.QUORUM`\n    *may not* see a preceding write at :attr:`~.QUORUM`. Do not use this\n    policy unless you have understood the cases where this can happen and\n    are ok with that. It is also recommended to subclass this class so\n    that queries that required a consistency level downgrade can be\n    recorded (so that repairs can be made later, etc).\n\n    This policy implements the same retries as :class:`.RetryPolicy`,\n    but on top of that, it also retries in the following cases:\n\n    * On a read timeout: if the number of replicas that responded is\n      greater than one but lower than is required by the requested\n      consistency level, the operation is retried at a lower consistency\n      level.\n    * On a write timeout: if the operation is an :attr:`~.UNLOGGED_BATCH`\n      and at least one replica acknowledged the write, the operation is\n      retried at a lower consistency level.  Furthermore, for other\n      write types, if at least one replica acknowledged the write, the\n      timeout is ignored.\n    * On an unavailable exception: if at least one replica is alive, the\n      operation is retried at a lower consistency level.\n\n    The reasoning behind this retry policy is as follows: if, based\n    on the information the Cassandra coordinator node returns, retrying the\n    operation with the initially requested consistency has a chance to\n    succeed, do it. Otherwise, if based on that information we know the\n    initially requested consistency level cannot be achieved currently, then:\n\n    * For writes, ignore the exception (thus silently failing the\n      consistency requirement) if we know the write has been persisted on at\n      least one replica.\n    * For reads, try reading at a lower consistency level (thus silently\n      failing the consistency requirement).\n\n    In other words, this policy implements the idea that if the requested\n    consistency level cannot be achieved, the next best thing for writes is\n    to make sure the data is persisted, and that reading something is better\n    than reading nothing, even if there is a risk of reading stale data.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super(DowngradingConsistencyRetryPolicy, self).__init__(*args, **kwargs)\n        warnings.warn('DowngradingConsistencyRetryPolicy is deprecated '\n                      'and will be removed in the next major release.',\n                      DeprecationWarning)\n\n    def _pick_consistency(self, num_responses):\n        if num_responses >= 3:\n            return self.RETRY, ConsistencyLevel.THREE\n        elif num_responses >= 2:\n            return self.RETRY, ConsistencyLevel.TWO\n        elif num_responses >= 1:\n            return self.RETRY, ConsistencyLevel.ONE\n        else:\n            return self.RETHROW, None\n\n    def on_read_timeout(self, query, consistency, required_responses,\n                        received_responses, data_retrieved, retry_num):\n        if retry_num != 0:\n            return self.RETHROW, None\n        elif ConsistencyLevel.is_serial(consistency):\n            # Downgrading does not make sense for a CAS read query\n            return self.RETHROW, None\n        elif received_responses < required_responses:\n            return self._pick_consistency(received_responses)\n        elif not data_retrieved:\n            return self.RETRY, consistency\n        else:\n            return self.RETHROW, None\n\n    def on_write_timeout(self, query, consistency, write_type,\n                         required_responses, received_responses, retry_num):\n        if retry_num != 0:\n            return self.RETHROW, None\n\n        if write_type in (WriteType.SIMPLE, WriteType.BATCH, WriteType.COUNTER):\n            if received_responses > 0:\n                # persisted on at least one replica\n                return self.IGNORE, None\n            else:\n                return self.RETHROW, None\n        elif write_type == WriteType.UNLOGGED_BATCH:\n            return self._pick_consistency(received_responses)\n        elif write_type == WriteType.BATCH_LOG:\n            return self.RETRY, consistency\n\n        return self.RETHROW, None\n\n    def on_unavailable(self, query, consistency, required_replicas, alive_replicas, retry_num):\n        if retry_num != 0:\n            return self.RETHROW, None\n        elif ConsistencyLevel.is_serial(consistency):\n            # failed at the paxos phase of a LWT, retry on the next host\n            return self.RETRY_NEXT_HOST, None\n        else:\n            return self._pick_consistency(alive_replicas)\n\n\nclass AddressTranslator(object):\n    \"\"\"\n    Interface for translating cluster-defined endpoints.\n\n    The driver discovers nodes using server metadata and topology change events. Normally,\n    the endpoint defined by the server is the right way to connect to a node. In some environments,\n    these addresses may not be reachable, or not preferred (public vs. private IPs in cloud environments,\n    suboptimal routing, etc). This interface allows for translating from server defined endpoints to\n    preferred addresses for driver connections.\n\n    *Note:* :attr:`~Cluster.contact_points` provided while creating the :class:`~.Cluster` instance are not\n    translated using this mechanism -- only addresses received from Cassandra nodes are.\n    \"\"\"\n    def translate(self, addr):\n        \"\"\"\n        Accepts the node ip address, and returns a translated address to be used connecting to this node.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass IdentityTranslator(AddressTranslator):\n    \"\"\"\n    Returns the endpoint with no translation\n    \"\"\"\n    def translate(self, addr):\n        return addr\n\n\nclass EC2MultiRegionTranslator(AddressTranslator):\n    \"\"\"\n    Resolves private ips of the hosts in the same datacenter as the client, and public ips of hosts in other datacenters.\n    \"\"\"\n    def translate(self, addr):\n        \"\"\"\n        Reverse DNS the public broadcast_address, then lookup that hostname to get the AWS-resolved IP, which\n        will point to the private IP address within the same datacenter.\n        \"\"\"\n        # get family of this address so we translate to the same\n        family = socket.getaddrinfo(addr, 0, socket.AF_UNSPEC, socket.SOCK_STREAM)[0][0]\n        host = socket.getfqdn(addr)\n        for a in socket.getaddrinfo(host, 0, family, socket.SOCK_STREAM):\n            try:\n                return a[4][0]\n            except Exception:\n                pass\n        return addr\n\n\nclass SpeculativeExecutionPolicy(object):\n    \"\"\"\n    Interface for specifying speculative execution plans\n    \"\"\"\n\n    def new_plan(self, keyspace, statement):\n        \"\"\"\n        Returns\n\n        :param keyspace:\n        :param statement:\n        :return:\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass SpeculativeExecutionPlan(object):\n    def next_execution(self, host):\n        raise NotImplementedError()\n\n\nclass NoSpeculativeExecutionPlan(SpeculativeExecutionPlan):\n    def next_execution(self, host):\n        return -1\n\n\nclass NoSpeculativeExecutionPolicy(SpeculativeExecutionPolicy):\n\n    def new_plan(self, keyspace, statement):\n        return NoSpeculativeExecutionPlan()\n\n\nclass ConstantSpeculativeExecutionPolicy(SpeculativeExecutionPolicy):\n    \"\"\"\n    A speculative execution policy that sends a new query every X seconds (**delay**) for a maximum of Y attempts (**max_attempts**).\n    \"\"\"\n\n    def __init__(self, delay, max_attempts):\n        self.delay = delay\n        self.max_attempts = max_attempts\n\n    class ConstantSpeculativeExecutionPlan(SpeculativeExecutionPlan):\n        def __init__(self, delay, max_attempts):\n            self.delay = delay\n            self.remaining = max_attempts\n\n        def next_execution(self, host):\n            if self.remaining > 0:\n                self.remaining -= 1\n                return self.delay\n            else:\n                return -1\n\n    def new_plan(self, keyspace, statement):\n        return self.ConstantSpeculativeExecutionPlan(self.delay, self.max_attempts)\n\n\nclass WrapperPolicy(LoadBalancingPolicy):\n\n    def __init__(self, child_policy):\n        self._child_policy = child_policy\n\n    def distance(self, *args, **kwargs):\n        return self._child_policy.distance(*args, **kwargs)\n\n    def populate(self, cluster, hosts):\n        self._child_policy.populate(cluster, hosts)\n\n    def on_up(self, *args, **kwargs):\n        return self._child_policy.on_up(*args, **kwargs)\n\n    def on_down(self, *args, **kwargs):\n        return self._child_policy.on_down(*args, **kwargs)\n\n    def on_add(self, *args, **kwargs):\n        return self._child_policy.on_add(*args, **kwargs)\n\n    def on_remove(self, *args, **kwargs):\n        return self._child_policy.on_remove(*args, **kwargs)\n\n\nclass DefaultLoadBalancingPolicy(WrapperPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` wrapper that adds the ability to target a specific host first.\n\n    If no host is set on the query, the child policy's query plan will be used as is.\n    \"\"\"\n\n    _cluster_metadata = None\n\n    def populate(self, cluster, hosts):\n        self._cluster_metadata = cluster.metadata\n        self._child_policy.populate(cluster, hosts)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        if query and query.keyspace:\n            keyspace = query.keyspace\n        else:\n            keyspace = working_keyspace\n\n        # TODO remove next major since execute(..., host=XXX) is now available\n        addr = getattr(query, 'target_host', None) if query else None\n        target_host = self._cluster_metadata.get_host(addr)\n\n        child = self._child_policy\n        if target_host and target_host.is_up:\n            yield target_host\n            for h in child.make_query_plan(keyspace, query):\n                if h != target_host:\n                    yield h\n        else:\n            for h in child.make_query_plan(keyspace, query):\n                yield h\n\n\n# TODO for backward compatibility, remove in next major\nclass DSELoadBalancingPolicy(DefaultLoadBalancingPolicy):\n    \"\"\"\n    *Deprecated:* This will be removed in the next major release,\n    consider using :class:`.DefaultLoadBalancingPolicy`.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super(DSELoadBalancingPolicy, self).__init__(*args, **kwargs)\n        warnings.warn(\"DSELoadBalancingPolicy will be removed in 4.0. Consider using \"\n                      \"DefaultLoadBalancingPolicy.\", DeprecationWarning)\n\n\nclass NeverRetryPolicy(RetryPolicy):\n    def _rethrow(self, *args, **kwargs):\n        return self.RETHROW, None\n\n    on_read_timeout = _rethrow\n    on_write_timeout = _rethrow\n    on_unavailable = _rethrow\n\n\nColDesc = namedtuple('ColDesc', ['ks', 'table', 'col'])\n\nclass ColumnEncryptionPolicy(object):\n    \"\"\"\n    A policy enabling (mostly) transparent encryption and decryption of data before it is\n    sent to the cluster.\n\n    Key materials and other configurations are specified on a per-column basis.  This policy can\n    then be used by driver structures which are aware of the underlying columns involved in their\n    work.  In practice this includes the following cases:\n\n    * Prepared statements - data for columns specified by the cluster's policy will be transparently\n      encrypted before they are sent\n    * Rows returned from any query - data for columns specified by the cluster's policy will be\n      transparently decrypted before they are returned to the user\n\n    To enable this functionality, create an instance of this class (or more likely a subclass)\n    before creating a cluster.  This policy should then be configured and supplied to the Cluster\n    at creation time via the :attr:`.Cluster.column_encryption_policy` attribute.\n    \"\"\"\n\n    def encrypt(self, coldesc, obj_bytes):\n        \"\"\"\n        Encrypt the specified bytes using the cryptography materials for the specified column.\n        Largely used internally, although this could also be used to encrypt values supplied\n        to non-prepared statements in a way that is consistent with this policy.\n        \"\"\"\n        raise NotImplementedError()\n\n    def decrypt(self, coldesc, encrypted_bytes):\n        \"\"\"\n        Decrypt the specified (encrypted) bytes using the cryptography materials for the\n        specified column.  Used internally; could be used externally as well but there's\n        not currently an obvious use case.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_column(self, coldesc, key):\n        \"\"\"\n        Provide cryptography materials to be used when encrypted and/or decrypting data\n        for the specified column.\n        \"\"\"\n        raise NotImplementedError()\n\n    def contains_column(self, coldesc):\n        \"\"\"\n        Predicate to determine if a specific column is supported by this policy.\n        Currently only used internally.\n        \"\"\"\n        raise NotImplementedError()\n\n    def encode_and_encrypt(self, coldesc, obj):\n        \"\"\"\n        Helper function to enable use of this policy on simple (i.e. non-prepared)\n        statements.\n        \"\"\"\n        raise NotImplementedError()\n",
    "cassandra/__init__.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\n\nlogging.getLogger('cassandra').addHandler(NullHandler())\n\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n\n    ANY = 0\n    \"\"\"\n    Only requires that one replica receives the write *or* the coordinator\n    stores a hint to replay later. Valid only for writes.\n    \"\"\"\n\n    ONE = 1\n    \"\"\"\n    Only one replica needs to respond to consider the operation a success\n    \"\"\"\n\n    TWO = 2\n    \"\"\"\n    Two replicas must respond to consider the operation a success\n    \"\"\"\n\n    THREE = 3\n    \"\"\"\n    Three replicas must respond to consider the operation a success\n    \"\"\"\n\n    QUORUM = 4\n    \"\"\"\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\n    \"\"\"\n\n    ALL = 5\n    \"\"\"\n    All replicas must respond to consider the operation a success\n    \"\"\"\n\n    LOCAL_QUORUM = 6\n    \"\"\"\n    Requires a quorum of replicas in the local datacenter\n    \"\"\"\n\n    EACH_QUORUM = 7\n    \"\"\"\n    Requires a quorum of replicas in each datacenter\n    \"\"\"\n\n    SERIAL = 8\n    \"\"\"\n    For conditional inserts/updates that utilize Cassandra's lightweight\n    transactions, this requires consensus among all replicas for the\n    modified data.\n    \"\"\"\n\n    LOCAL_SERIAL = 9\n    \"\"\"\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\n    among replicas in the local datacenter.\n    \"\"\"\n\n    LOCAL_ONE = 10\n    \"\"\"\n    Sends a request only to replicas in the local datacenter and waits for\n    one response.\n    \"\"\"\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\n\n\nConsistencyLevel.value_to_name = {\n    ConsistencyLevel.ANY: 'ANY',\n    ConsistencyLevel.ONE: 'ONE',\n    ConsistencyLevel.TWO: 'TWO',\n    ConsistencyLevel.THREE: 'THREE',\n    ConsistencyLevel.QUORUM: 'QUORUM',\n    ConsistencyLevel.ALL: 'ALL',\n    ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM',\n    ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM',\n    ConsistencyLevel.SERIAL: 'SERIAL',\n    ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL',\n    ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'\n}\n\nConsistencyLevel.name_to_value = {\n    'ANY': ConsistencyLevel.ANY,\n    'ONE': ConsistencyLevel.ONE,\n    'TWO': ConsistencyLevel.TWO,\n    'THREE': ConsistencyLevel.THREE,\n    'QUORUM': ConsistencyLevel.QUORUM,\n    'ALL': ConsistencyLevel.ALL,\n    'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM,\n    'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM,\n    'SERIAL': ConsistencyLevel.SERIAL,\n    'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL,\n    'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE\n}\n\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else \"Not Set\"\n\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    \"\"\"\n    v1, supported in Cassandra 1.2-->2.2\n    \"\"\"\n\n    V2 = 2\n    \"\"\"\n    v2, supported in Cassandra 2.0-->2.2;\n    added support for lightweight transactions, batch operations, and automatic query paging.\n    \"\"\"\n\n    V3 = 3\n    \"\"\"\n    v3, supported in Cassandra 2.1-->3.x+;\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\n    \"\"\"\n\n    V4 = 4\n    \"\"\"\n    v4, supported in Cassandra 2.2-->3.x+;\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\n    \"\"\"\n\n    V5 = 5\n    \"\"\"\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\n    \"\"\"\n\n    V6 = 6\n    \"\"\"\n    v6, in beta from 4.0-beta5\n    \"\"\"\n\n    DSE_V1 = 0x41\n    \"\"\"\n    DSE private protocol v1, supported in DSE 5.1+\n    \"\"\"\n\n    DSE_V2 = 0x42\n    \"\"\"\n    DSE private protocol v2, supported in DSE 6.0+\n    \"\"\"\n\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    \"\"\"\n    A tuple of all supported protocol versions\n    \"\"\"\n\n    BETA_VERSIONS = (V6,)\n    \"\"\"\n    A tuple of all beta protocol versions\n    \"\"\"\n\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    \"\"\"\n    Minimum protocol version supported by this driver.\n    \"\"\"\n\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    \"\"\"\n    Maximum protocol version supported by this driver.\n    \"\"\"\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next(v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if\n                           v not in ProtocolVersion.BETA_VERSIONS and v < previous_version)\n        except StopIteration:\n            version = 0\n\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n\n    SIMPLE = 0\n    \"\"\"\n    A write to a single partition key. Such writes are guaranteed to be atomic\n    and isolated.\n    \"\"\"\n\n    BATCH = 1\n    \"\"\"\n    A write to multiple partition keys that used the distributed batch log to\n    ensure atomicity.\n    \"\"\"\n\n    UNLOGGED_BATCH = 2\n    \"\"\"\n    A write to multiple partition keys that did not use the distributed batch\n    log. Atomicity for such writes is not guaranteed.\n    \"\"\"\n\n    COUNTER = 3\n    \"\"\"\n    A counter write (for one or multiple partition keys). Such writes should\n    not be replayed in order to avoid overcount.\n    \"\"\"\n\n    BATCH_LOG = 4\n    \"\"\"\n    The initial write to the distributed batch log that Cassandra performs\n    internally before a BATCH write.\n    \"\"\"\n\n    CAS = 5\n    \"\"\"\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\n    \"\"\"\n\n    VIEW = 6\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete MV operations.\n    \"\"\"\n\n    CDC = 7\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete CDC operations.\n    \"\"\"\n\n\nWriteType.name_to_value = {\n    'SIMPLE': WriteType.SIMPLE,\n    'BATCH': WriteType.BATCH,\n    'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH,\n    'COUNTER': WriteType.COUNTER,\n    'BATCH_LOG': WriteType.BATCH_LOG,\n    'CAS': WriteType.CAS,\n    'VIEW': WriteType.VIEW,\n    'CDC': WriteType.CDC\n}\n\n\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return \"%s(%s)\" % (name, ','.join(t for t in argument_types))\n\n    def __repr__(self):\n        return \"%s(%s, %s)\" % (self.__class__.__name__, self.name, self.argument_types)\n\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the function\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the aggregate\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_replicas = None\n    \"\"\" The number of replicas that needed to be live to complete the operation \"\"\"\n\n    alive_replicas = None\n    \"\"\" The number of replicas that were actually alive \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' +\n                           repr({'consistency': consistency_value_to_name(consistency),\n                                 'required_replicas': required_replicas,\n                                 'alive_replicas': alive_replicas}))\n\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n\n        if \"write_type\" in kwargs:\n            kwargs[\"write_type\"] = WriteType.value_to_name[kwargs[\"write_type\"]]\n\n        info = {'consistency': consistency_value_to_name(consistency),\n                'required_responses': required_responses,\n                'received_responses': received_responses}\n        info.update(kwargs)\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs[\"write_type\"] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    failures = None\n    \"\"\"\n    The number of replicas that sent a failure message\n    \"\"\"\n\n    error_code_map = None\n    \"\"\"\n    A map of inet addresses to error codes representing replicas that sent\n    a failure message.  Only set when `protocol_version` is 5 or higher.\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n\n        info_dict = {\n            'consistency': consistency_value_to_name(consistency),\n            'required_responses': required_responses,\n            'received_responses': received_responses,\n            'failures': failures\n        }\n\n        if error_code_map is not None:\n            # make error codes look like \"0x002a\"\n            formatted_map = dict((addr, '0x%04x' % err_code)\n                                 for (addr, err_code) in error_code_map.items())\n            info_dict['error_code_map'] = formatted_map\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    Keyspace of the function\n    \"\"\"\n\n    function = None\n    \"\"\"\n    Name of the function\n    \"\"\"\n\n    arg_types = None\n    \"\"\"\n    List of argument type names of the function\n    \"\"\"\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    The name of the keyspace that already exists, or, if an attempt was\n    made to create a new table, the keyspace that the table is in.\n    \"\"\"\n\n    table = None\n    \"\"\"\n    The name of the table that already exists, or, if an attempt was\n    make to create a keyspace, :const:`None`.\n    \"\"\"\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n\n    errors = None\n    \"\"\"\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\n    \"\"\"\n\n    last_host = None\n    \"\"\"\n    The last :class:`~.Host` this operation was attempted against.\n    \"\"\"\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = \"errors=%s, last_host=%s\" % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n\n    excs = []\n    \"\"\"\n    A sequence of child exceptions\n    \"\"\"\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += (\"\\nThe following exceptions were observed: \\n - \" + '\\n - '.join(str(e) for e in excs))\n        Exception.__init__(self, complete_msg)\n"
  },
  "GT_src_dict": {
    "cassandra/connection.py": {
      "DefaultEndPoint.__init__": {
        "code": "    def __init__(self, address, port=9042):\n        \"\"\"Initializes a DefaultEndPoint instance, which represents an endpoint for connecting to a Cassandra node with a specified address and port.\n\nParameters:\n- address (str): The IP address of the Cassandra node.\n- port (int, optional): The port number for the connection. Defaults to 9042, which is the standard port used by Cassandra.\n\nThe class utilizes the address and port to construct a complete endpoint for establishing connections, enabling the driver to communicate with the specified Cassandra node. There are no return values from the constructor, as it is responsible for setting up instance attributes for the object.\"\"\"\n        self._address = address\n        self._port = port",
        "docstring": "Initializes a DefaultEndPoint instance, which represents an endpoint for connecting to a Cassandra node with a specified address and port.\n\nParameters:\n- address (str): The IP address of the Cassandra node.\n- port (int, optional): The port number for the connection. Defaults to 9042, which is the standard port used by Cassandra.\n\nThe class utilizes the address and port to construct a complete endpoint for establishing connections, enabling the driver to communicate with the specified Cassandra node. There are no return values from the constructor, as it is responsible for setting up instance attributes for the object.",
        "signature": "def __init__(self, address, port=9042):",
        "type": "Method",
        "class_signature": "class DefaultEndPoint(EndPoint):"
      },
      "DefaultEndPoint.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks the equality of two DefaultEndPoint instances. \n\nParameters:\n- other (object): The object to compare against this DefaultEndPoint instance.\n\nReturns:\n- bool: True if the other object is an instance of DefaultEndPoint and has the same address and port as this instance; otherwise, False.\n\nThis method leverages the `address` and `port` properties defined in the DefaultEndPoint class to perform the comparison. These properties represent the network address and port number of the Cassandra node, which are essential for establishing connections in distributed systems like Cassandra. The method ensures that two endpoints are considered equal only if both their address and port match.\"\"\"\n        return isinstance(other, DefaultEndPoint) and self.address == other.address and (self.port == other.port)",
        "docstring": "Checks the equality of two DefaultEndPoint instances. \n\nParameters:\n- other (object): The object to compare against this DefaultEndPoint instance.\n\nReturns:\n- bool: True if the other object is an instance of DefaultEndPoint and has the same address and port as this instance; otherwise, False.\n\nThis method leverages the `address` and `port` properties defined in the DefaultEndPoint class to perform the comparison. These properties represent the network address and port number of the Cassandra node, which are essential for establishing connections in distributed systems like Cassandra. The method ensures that two endpoints are considered equal only if both their address and port match.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class DefaultEndPoint(EndPoint):"
      },
      "SniEndPoint.address": {
        "code": "    def address(self):\n        \"\"\"Returns the proxy address of the SNI (Server Name Indication) endpoint. This address is used to connect to the designated proxy for handling secure (SSL/TLS) connections to the intended backend server identified by the server_name attribute. The address is stored in the private attribute `_proxy_address`, which is set during the instantiation of the SniEndPoint class. This method does not take any parameters and directly accesses the internal state of the instance.\"\"\"\n        return self._proxy_address",
        "docstring": "Returns the proxy address of the SNI (Server Name Indication) endpoint. This address is used to connect to the designated proxy for handling secure (SSL/TLS) connections to the intended backend server identified by the server_name attribute. The address is stored in the private attribute `_proxy_address`, which is set during the instantiation of the SniEndPoint class. This method does not take any parameters and directly accesses the internal state of the instance.",
        "signature": "def address(self):",
        "type": "Method",
        "class_signature": "class SniEndPoint(EndPoint):"
      },
      "SniEndPoint.port": {
        "code": "    def port(self):\n        \"\"\"Returns the port number associated with this SNI (Server Name Indication) Endpoint.\n\nThis method retrieves the `_port` attribute, which is initialized when an instance of the `SniEndPoint` class is created. The port is used for establishing SSL/TLS connections to the proxy address specified in the endpoint.\n\nReturns:\n    int: The port number for the SNI endpoint.\n\nDependencies:\n- The `_port` attribute is set during the initialization of the `SniEndPoint` instance, specifically in the `__init__` method, which takes the `port` argument with a default value of 9042.\"\"\"\n        return self._port",
        "docstring": "Returns the port number associated with this SNI (Server Name Indication) Endpoint.\n\nThis method retrieves the `_port` attribute, which is initialized when an instance of the `SniEndPoint` class is created. The port is used for establishing SSL/TLS connections to the proxy address specified in the endpoint.\n\nReturns:\n    int: The port number for the SNI endpoint.\n\nDependencies:\n- The `_port` attribute is set during the initialization of the `SniEndPoint` instance, specifically in the `__init__` method, which takes the `port` argument with a default value of 9042.",
        "signature": "def port(self):",
        "type": "Method",
        "class_signature": "class SniEndPoint(EndPoint):"
      },
      "SniEndPoint.resolve": {
        "code": "    def resolve(self):\n        \"\"\"Resolve the endpoint to its actual address and port for the SNI (Server Name Indication) proxy.\n\nThis method uses the `socket.getaddrinfo` function to resolve the `_proxy_address` along with `_port`. It handles both IPv4 and IPv6, as indicated by `socket.AF_UNSPEC`. If the resolution fails, it logs a debug message and raises a `socket.gaierror`.\n\nUpon successful resolution, it selects one of the resolved addresses using a round-robin approach and increments the index for future calls, ensuring that subsequent resolutions can potentially return different IPs if multiple are available.\n\nReturns:\n    Tuple[str, int]: A tuple containing the resolved address (str) and the port (int).\n\nAttributes:\n    - `_proxy_address`: The hostname of the SNI proxy, set during initialization.\n    - `_port`: The port number to connect to, set during initialization.\n    - `_resolved_address`: The last resolved address, updated each time this method is called.\n    - `_index`: An internal counter used to select the address in a round-robin manner from the resolved addresses.\n\nDependencies:\n    - `socket`: Required for performing hostname resolution.\n    - `log`: Used to log debug messages on resolution failure.\"\"\"\n        try:\n            resolved_addresses = socket.getaddrinfo(self._proxy_address, self._port, socket.AF_UNSPEC, socket.SOCK_STREAM)\n        except socket.gaierror:\n            log.debug('Could not resolve sni proxy hostname \"%s\" with port %d' % (self._proxy_address, self._port))\n            raise\n        self._resolved_address = sorted((addr[4][0] for addr in resolved_addresses))[self._index % len(resolved_addresses)]\n        self._index += 1\n        return (self._resolved_address, self._port)",
        "docstring": "Resolve the endpoint to its actual address and port for the SNI (Server Name Indication) proxy.\n\nThis method uses the `socket.getaddrinfo` function to resolve the `_proxy_address` along with `_port`. It handles both IPv4 and IPv6, as indicated by `socket.AF_UNSPEC`. If the resolution fails, it logs a debug message and raises a `socket.gaierror`.\n\nUpon successful resolution, it selects one of the resolved addresses using a round-robin approach and increments the index for future calls, ensuring that subsequent resolutions can potentially return different IPs if multiple are available.\n\nReturns:\n    Tuple[str, int]: A tuple containing the resolved address (str) and the port (int).\n\nAttributes:\n    - `_proxy_address`: The hostname of the SNI proxy, set during initialization.\n    - `_port`: The port number to connect to, set during initialization.\n    - `_resolved_address`: The last resolved address, updated each time this method is called.\n    - `_index`: An internal counter used to select the address in a round-robin manner from the resolved addresses.\n\nDependencies:\n    - `socket`: Required for performing hostname resolution.\n    - `log`: Used to log debug messages on resolution failure.",
        "signature": "def resolve(self):",
        "type": "Method",
        "class_signature": "class SniEndPoint(EndPoint):"
      },
      "SniEndPoint.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two SniEndPoint instances.\n\nParameters:\n- other (object): The instance to compare against.\n\nReturns:\n- bool: True if the other instance is a SniEndPoint with the same address, port, and server name as this instance; otherwise, False.\n\nThe method relies on the attributes `address`, `port`, and `_server_name`, which hold respectively the network address, port number, and server name associated with the SniEndPoint. This allows for a robust equality comparison semantically relevant in the context of network endpoints for SNI (Server Name Indication) proxies. The method ensures that only another SniEndPoint can be considered equal based on these three attributes.\"\"\"\n        return isinstance(other, SniEndPoint) and self.address == other.address and (self.port == other.port) and (self._server_name == other._server_name)",
        "docstring": "Checks for equality between two SniEndPoint instances.\n\nParameters:\n- other (object): The instance to compare against.\n\nReturns:\n- bool: True if the other instance is a SniEndPoint with the same address, port, and server name as this instance; otherwise, False.\n\nThe method relies on the attributes `address`, `port`, and `_server_name`, which hold respectively the network address, port number, and server name associated with the SniEndPoint. This allows for a robust equality comparison semantically relevant in the context of network endpoints for SNI (Server Name Indication) proxies. The method ensures that only another SniEndPoint can be considered equal based on these three attributes.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class SniEndPoint(EndPoint):"
      },
      "SniEndPoint.__str__": {
        "code": "    def __str__(self):\n        \"\"\"Returns a string representation of the SniEndPoint instance, formatted as \"address:port:server_name\".\n\nThe method accesses the `address`, `port`, and `_server_name` attributes of the SniEndPoint class, which represent the proxy address, the port number for the connection, and the server name used for SNI (Server Name Indication) respectively. This string format is useful for logging and debugging purposes, allowing for a quick overview of the endpoint's details.\n\nThe `address` and `port` properties are defined in the `EndPoint` base class, while `_server_name` is specific to the `SniEndPoint` class, initialized during its construction.\"\"\"\n        return str('%s:%d:%s' % (self.address, self.port, self._server_name))",
        "docstring": "Returns a string representation of the SniEndPoint instance, formatted as \"address:port:server_name\".\n\nThe method accesses the `address`, `port`, and `_server_name` attributes of the SniEndPoint class, which represent the proxy address, the port number for the connection, and the server name used for SNI (Server Name Indication) respectively. This string format is useful for logging and debugging purposes, allowing for a quick overview of the endpoint's details.\n\nThe `address` and `port` properties are defined in the `EndPoint` base class, while `_server_name` is specific to the `SniEndPoint` class, initialized during its construction.",
        "signature": "def __str__(self):",
        "type": "Method",
        "class_signature": "class SniEndPoint(EndPoint):"
      },
      "SniEndPointFactory.__init__": {
        "code": "    def __init__(self, proxy_address, port):\n        \"\"\"Initializes the SniEndPointFactory with the specified proxy address and port.\n\n    Parameters:\n    proxy_address (str): The address of the SNI (Server Name Indication) proxy server.\n    port (int): The port number associated with the SNI proxy. Defaults to None.\n\n    Attributes:\n    _proxy_address (str): Stores the provided proxy address.\n    _port (int): Stores the provided port. This port is used when creating SniEndPoint instances.\n\n    This constructor is part of the SniEndPointFactory class, which is responsible for creating SniEndPoint objects that encapsulate details needed to create connections through SNI proxies. The SniEndPoint instances leverage the provided proxy address and port when establishing connectivity.\"\"\"\n        self._proxy_address = proxy_address\n        self._port = port",
        "docstring": "Initializes the SniEndPointFactory with the specified proxy address and port.\n\nParameters:\nproxy_address (str): The address of the SNI (Server Name Indication) proxy server.\nport (int): The port number associated with the SNI proxy. Defaults to None.\n\nAttributes:\n_proxy_address (str): Stores the provided proxy address.\n_port (int): Stores the provided port. This port is used when creating SniEndPoint instances.\n\nThis constructor is part of the SniEndPointFactory class, which is responsible for creating SniEndPoint objects that encapsulate details needed to create connections through SNI proxies. The SniEndPoint instances leverage the provided proxy address and port when establishing connectivity.",
        "signature": "def __init__(self, proxy_address, port):",
        "type": "Method",
        "class_signature": "class SniEndPointFactory(EndPointFactory):"
      },
      "SniEndPointFactory.create_from_sni": {
        "code": "    def create_from_sni(self, sni):\n        \"\"\"Create a `SniEndPoint` instance using the specified Server Name Indicator (SNI).\n\nParameters:\n- `sni` (str): The server name identifier to be used for the SNI proxy. This is typically the hostname of the server the connection will attempt to reach.\n\nReturns:\n- `SniEndPoint`: An instance of the `SniEndPoint` class, initialized with the `_proxy_address`, the specified `sni`, and the port (`_port`) of the factory.\n\nThis method allows the creation of an endpoint for connections that require SNI support, particularly when connecting through a proxy that uses TLS. The constants like `_proxy_address` and `_port` are defined in the class `SniEndPointFactory` and are used to set up the endpoint configuration properly.\"\"\"\n        return SniEndPoint(self._proxy_address, sni, self._port)",
        "docstring": "Create a `SniEndPoint` instance using the specified Server Name Indicator (SNI).\n\nParameters:\n- `sni` (str): The server name identifier to be used for the SNI proxy. This is typically the hostname of the server the connection will attempt to reach.\n\nReturns:\n- `SniEndPoint`: An instance of the `SniEndPoint` class, initialized with the `_proxy_address`, the specified `sni`, and the port (`_port`) of the factory.\n\nThis method allows the creation of an endpoint for connections that require SNI support, particularly when connecting through a proxy that uses TLS. The constants like `_proxy_address` and `_port` are defined in the class `SniEndPointFactory` and are used to set up the endpoint configuration properly.",
        "signature": "def create_from_sni(self, sni):",
        "type": "Method",
        "class_signature": "class SniEndPointFactory(EndPointFactory):"
      }
    },
    "cassandra/policies.py": {},
    "cassandra/__init__.py": {}
  },
  "dependency_dict": {
    "cassandra/connection.py:SniEndPointFactory:create_from_sni": {
      "cassandra/connection.py": {
        "SniEndPoint.__init__": {
          "code": "    def __init__(self, proxy_address, server_name, port=9042):\n        self._proxy_address = proxy_address\n        self._index = 0\n        self._resolved_address = None\n        self._port = port\n        self._server_name = server_name\n        self._ssl_options = {'server_hostname': server_name}",
          "docstring": "",
          "signature": "def __init__(self, proxy_address, server_name, port=9042):",
          "type": "Method",
          "class_signature": "class SniEndPoint(EndPoint):"
        }
      }
    },
    "cassandra/connection.py:DefaultEndPoint:__eq__": {},
    "cassandra/connection.py:SniEndPoint:__eq__": {},
    "cassandra/connection.py:SniEndPoint:resolve": {
      "tests/unit/test_endpoints.py": {
        "socket_getaddrinfo": {
          "code": "def socket_getaddrinfo(*args):\n    return [\n        (0, 0, 0, '', ('127.0.0.1', 30002)),\n        (0, 0, 0, '', ('127.0.0.2', 30002)),\n        (0, 0, 0, '', ('127.0.0.3', 30002))\n    ]",
          "docstring": "",
          "signature": "def socket_getaddrinfo(*args):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "cassandra/connection.py:SniEndPoint:__str__": {}
  },
  "call_tree": {
    "tests/unit/test_endpoints.py:SniEndPointTest:SniEndPointTest": {
      "cassandra/connection.py:SniEndPointFactory:__init__": {}
    },
    "tests/unit/test_endpoints.py:SniEndPointTest:test_endpoint_equality": {
      "cassandra/connection.py:DefaultEndPoint:__init__": {},
      "cassandra/connection.py:SniEndPointFactory:create_from_sni": {
        "cassandra/connection.py:SniEndPoint:__init__": {}
      },
      "cassandra/connection.py:DefaultEndPoint:__eq__": {
        "cassandra/connection.py:DefaultEndPoint": {}
      },
      "cassandra/connection.py:SniEndPoint:__eq__": {
        "cassandra/connection.py:SniEndPoint": {},
        "cassandra/connection.py:SniEndPoint:address": {},
        "cassandra/connection.py:SniEndPoint:port": {}
      },
      "cassandra/connection.py:SniEndPointFactory:__init__": {}
    },
    "tests/unit/test_endpoints.py:SniEndPointTest:test_endpoint_resolve": {
      "cassandra/connection.py:SniEndPointFactory:create_from_sni": {
        "cassandra/connection.py:SniEndPoint:__init__": {}
      },
      "cassandra/connection.py:SniEndPoint:resolve": {
        "tests/unit/test_endpoints.py:socket_getaddrinfo": {}
      }
    },
    "tests/unit/test_endpoints.py:SniEndPointTest:test_sni_endpoint_properties": {
      "cassandra/connection.py:SniEndPointFactory:create_from_sni": {
        "cassandra/connection.py:SniEndPoint:__init__": {}
      },
      "cassandra/connection.py:SniEndPoint:address": {},
      "cassandra/connection.py:SniEndPoint:port": {},
      "cassandra/connection.py:SniEndPoint:__str__": {
        "cassandra/connection.py:SniEndPoint:address": {},
        "cassandra/connection.py:SniEndPoint:port": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/cassandra_driver-image-test_endpoints/cassandra_driver-test_endpoints/tests/integration/long/test_loadbalancingpolicies.py:LoadBalancingPolicyTests:test_token_aware_is_used_by_default": {
      "cassandra/policies.py:TokenAwarePolicy:TokenAwarePolicy": {},
      "cassandra/policies.py:DCAwareRoundRobinPolicy:DCAwareRoundRobinPolicy": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/cassandra_driver-image-test_endpoints/cassandra_driver-test_endpoints/tests/integration/advanced/graph/test_graph.py:GraphTimeoutTests:test_server_timeout_less_then_request": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/cassandra_driver-image-test_endpoints/cassandra_driver-test_endpoints/tests/integration/advanced/graph/test_graph.py:GraphProfileTests:test_graph_profile": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    }
  },
  "PRD": "# PROJECT NAME: cassandra_driver-test_endpoints\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 cassandra/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 InvalidRequest.InvalidRequest\n    \u2502   \u2514\u2500\u2500 OperationTimedOut.OperationTimedOut\n    \u251c\u2500\u2500 connection.py\n    \u2502   \u251c\u2500\u2500 DefaultEndPoint.__eq__\n    \u2502   \u251c\u2500\u2500 DefaultEndPoint.__init__\n    \u2502   \u251c\u2500\u2500 SniEndPoint.__eq__\n    \u2502   \u251c\u2500\u2500 SniEndPoint.__str__\n    \u2502   \u251c\u2500\u2500 SniEndPoint.address\n    \u2502   \u251c\u2500\u2500 SniEndPoint.port\n    \u2502   \u251c\u2500\u2500 SniEndPoint.resolve\n    \u2502   \u251c\u2500\u2500 SniEndPointFactory.__init__\n    \u2502   \u2514\u2500\u2500 SniEndPointFactory.create_from_sni\n    \u2514\u2500\u2500 policies.py\n        \u251c\u2500\u2500 DCAwareRoundRobinPolicy.DCAwareRoundRobinPolicy\n        \u2514\u2500\u2500 TokenAwarePolicy.TokenAwarePolicy\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for handling Server Name Indication (SNI)-based endpoints within a distributed environment, specifically for proxying traffic via a designated host. It enables the creation and management of SNI-specific endpoints by associating server names with a proxy address and port, ensuring distinct endpoint representation and comparability. Additionally, the module implements endpoint resolution capabilities, supporting the cycling of IP addresses to distribute load or connectivity. This functionality simplifies and standardizes the process of managing and resolving SNI-based connections, addressing the needs of developers working with environments requiring fine-grained control over connection routing.\n\n## FILE 1: cassandra/connection.py\n\n- CLASS METHOD: SniEndPointFactory.create_from_sni\n  - CLASS SIGNATURE: class SniEndPointFactory(EndPointFactory):\n  - SIGNATURE: def create_from_sni(self, sni):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a `SniEndPoint` instance using the specified Server Name Indicator (SNI).\n\nParameters:\n- `sni` (str): The server name identifier to be used for the SNI proxy. This is typically the hostname of the server the connection will attempt to reach.\n\nReturns:\n- `SniEndPoint`: An instance of the `SniEndPoint` class, initialized with the `_proxy_address`, the specified `sni`, and the port (`_port`) of the factory.\n\nThis method allows the creation of an endpoint for connections that require SNI support, particularly when connecting through a proxy that uses TLS. The constants like `_proxy_address` and `_port` are defined in the class `SniEndPointFactory` and are used to set up the endpoint configuration properly.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPoint.port\n  - CLASS SIGNATURE: class SniEndPoint(EndPoint):\n  - SIGNATURE: def port(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the port number associated with this SNI (Server Name Indication) Endpoint.\n\nThis method retrieves the `_port` attribute, which is initialized when an instance of the `SniEndPoint` class is created. The port is used for establishing SSL/TLS connections to the proxy address specified in the endpoint.\n\nReturns:\n    int: The port number for the SNI endpoint.\n\nDependencies:\n- The `_port` attribute is set during the initialization of the `SniEndPoint` instance, specifically in the `__init__` method, which takes the `port` argument with a default value of 9042.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPointFactory.__init__\n  - CLASS SIGNATURE: class SniEndPointFactory(EndPointFactory):\n  - SIGNATURE: def __init__(self, proxy_address, port):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes the SniEndPointFactory with the specified proxy address and port.\n\nParameters:\nproxy_address (str): The address of the SNI (Server Name Indication) proxy server.\nport (int): The port number associated with the SNI proxy. Defaults to None.\n\nAttributes:\n_proxy_address (str): Stores the provided proxy address.\n_port (int): Stores the provided port. This port is used when creating SniEndPoint instances.\n\nThis constructor is part of the SniEndPointFactory class, which is responsible for creating SniEndPoint objects that encapsulate details needed to create connections through SNI proxies. The SniEndPoint instances leverage the provided proxy address and port when establishing connectivity.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPoint.address\n  - CLASS SIGNATURE: class SniEndPoint(EndPoint):\n  - SIGNATURE: def address(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the proxy address of the SNI (Server Name Indication) endpoint. This address is used to connect to the designated proxy for handling secure (SSL/TLS) connections to the intended backend server identified by the server_name attribute. The address is stored in the private attribute `_proxy_address`, which is set during the instantiation of the SniEndPoint class. This method does not take any parameters and directly accesses the internal state of the instance.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultEndPoint.__eq__\n  - CLASS SIGNATURE: class DefaultEndPoint(EndPoint):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks the equality of two DefaultEndPoint instances. \n\nParameters:\n- other (object): The object to compare against this DefaultEndPoint instance.\n\nReturns:\n- bool: True if the other object is an instance of DefaultEndPoint and has the same address and port as this instance; otherwise, False.\n\nThis method leverages the `address` and `port` properties defined in the DefaultEndPoint class to perform the comparison. These properties represent the network address and port number of the Cassandra node, which are essential for establishing connections in distributed systems like Cassandra. The method ensures that two endpoints are considered equal only if both their address and port match.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPoint.resolve\n  - CLASS SIGNATURE: class SniEndPoint(EndPoint):\n  - SIGNATURE: def resolve(self):\n  - DOCSTRING: \n```python\n\"\"\"\nResolve the endpoint to its actual address and port for the SNI (Server Name Indication) proxy.\n\nThis method uses the `socket.getaddrinfo` function to resolve the `_proxy_address` along with `_port`. It handles both IPv4 and IPv6, as indicated by `socket.AF_UNSPEC`. If the resolution fails, it logs a debug message and raises a `socket.gaierror`.\n\nUpon successful resolution, it selects one of the resolved addresses using a round-robin approach and increments the index for future calls, ensuring that subsequent resolutions can potentially return different IPs if multiple are available.\n\nReturns:\n    Tuple[str, int]: A tuple containing the resolved address (str) and the port (int).\n\nAttributes:\n    - `_proxy_address`: The hostname of the SNI proxy, set during initialization.\n    - `_port`: The port number to connect to, set during initialization.\n    - `_resolved_address`: The last resolved address, updated each time this method is called.\n    - `_index`: An internal counter used to select the address in a round-robin manner from the resolved addresses.\n\nDependencies:\n    - `socket`: Required for performing hostname resolution.\n    - `log`: Used to log debug messages on resolution failure.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultEndPoint.__init__\n  - CLASS SIGNATURE: class DefaultEndPoint(EndPoint):\n  - SIGNATURE: def __init__(self, address, port=9042):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DefaultEndPoint instance, which represents an endpoint for connecting to a Cassandra node with a specified address and port.\n\nParameters:\n- address (str): The IP address of the Cassandra node.\n- port (int, optional): The port number for the connection. Defaults to 9042, which is the standard port used by Cassandra.\n\nThe class utilizes the address and port to construct a complete endpoint for establishing connections, enabling the driver to communicate with the specified Cassandra node. There are no return values from the constructor, as it is responsible for setting up instance attributes for the object.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPoint.__eq__\n  - CLASS SIGNATURE: class SniEndPoint(EndPoint):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two SniEndPoint instances.\n\nParameters:\n- other (object): The instance to compare against.\n\nReturns:\n- bool: True if the other instance is a SniEndPoint with the same address, port, and server name as this instance; otherwise, False.\n\nThe method relies on the attributes `address`, `port`, and `_server_name`, which hold respectively the network address, port number, and server name associated with the SniEndPoint. This allows for a robust equality comparison semantically relevant in the context of network endpoints for SNI (Server Name Indication) proxies. The method ensures that only another SniEndPoint can be considered equal based on these three attributes.\n\"\"\"\n```\n\n- CLASS METHOD: SniEndPoint.__str__\n  - CLASS SIGNATURE: class SniEndPoint(EndPoint):\n  - SIGNATURE: def __str__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the SniEndPoint instance, formatted as \"address:port:server_name\".\n\nThe method accesses the `address`, `port`, and `_server_name` attributes of the SniEndPoint class, which represent the proxy address, the port number for the connection, and the server name used for SNI (Server Name Indication) respectively. This string format is useful for logging and debugging purposes, allowing for a quick overview of the endpoint's details.\n\nThe `address` and `port` properties are defined in the `EndPoint` base class, while `_server_name` is specific to the `SniEndPoint` class, initialized during its construction.\n\"\"\"\n```\n\n## FILE 2: cassandra/policies.py\n\n## FILE 3: cassandra/__init__.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "cassandra/connection.py": "from __future__ import absolute_import\nfrom collections import defaultdict, deque\nimport errno\nfrom functools import wraps, partial, total_ordering\nfrom heapq import heappush, heappop\nimport io\nimport logging\nimport socket\nimport struct\nimport sys\nfrom threading import Thread, Event, RLock, Condition\nimport time\nimport ssl\nimport weakref\nif 'gevent.monkey' in sys.modules:\n    from gevent.queue import Queue, Empty\nelse:\n    from queue import Queue, Empty\nfrom cassandra import ConsistencyLevel, AuthenticationFailed, OperationTimedOut, ProtocolVersion\nfrom cassandra.marshal import int32_pack\nfrom cassandra.protocol import ReadyMessage, AuthenticateMessage, OptionsMessage, StartupMessage, ErrorMessage, CredentialsMessage, QueryMessage, ResultMessage, ProtocolHandler, InvalidRequestException, SupportedMessage, AuthResponseMessage, AuthChallengeMessage, AuthSuccessMessage, ProtocolException, RegisterMessage, ReviseRequestMessage\nfrom cassandra.segment import SegmentCodec, CrcException\nfrom cassandra.util import OrderedDict\nlog = logging.getLogger(__name__)\nsegment_codec_no_compression = SegmentCodec()\nsegment_codec_lz4 = None\nlocally_supported_compressions = OrderedDict()\ntry:\n    import lz4\nexcept ImportError:\n    pass\nelse:\n    try:\n        from lz4 import block as lz4_block\n    except ImportError:\n        lz4_block = lz4\n    try:\n        lz4_block.compress\n        lz4_block.decompress\n    except AttributeError:\n        raise ImportError('lz4 not imported correctly. Imported object should have .compress and and .decompress attributes but does not. Please file a bug report on JIRA. (Imported object was {lz4_block})'.format(lz4_block=repr(lz4_block)))\n\n    def lz4_compress(byts):\n        return int32_pack(len(byts)) + lz4_block.compress(byts)[4:]\n\n    def lz4_decompress(byts):\n        return lz4_block.decompress(byts[3::-1] + byts[4:])\n    locally_supported_compressions['lz4'] = (lz4_compress, lz4_decompress)\n    segment_codec_lz4 = SegmentCodec(lz4_compress, lz4_decompress)\ntry:\n    import snappy\nexcept ImportError:\n    pass\nelse:\n\n    def decompress(byts):\n        if byts == '\\x00':\n            return ''\n        return snappy.decompress(byts)\n    locally_supported_compressions['snappy'] = (snappy.compress, decompress)\nDRIVER_NAME, DRIVER_VERSION = ('DataStax Python Driver', sys.modules['cassandra'].__version__)\nPROTOCOL_VERSION_MASK = 127\nHEADER_DIRECTION_FROM_CLIENT = 0\nHEADER_DIRECTION_TO_CLIENT = 128\nHEADER_DIRECTION_MASK = 128\nframe_header_v1_v2 = struct.Struct('>BbBi')\nframe_header_v3 = struct.Struct('>BhBi')\n\nclass EndPoint(object):\n    \"\"\"\n    Represents the information to connect to a cassandra node.\n    \"\"\"\n\n    @property\n    def address(self):\n        \"\"\"\n        The IP address of the node. This is the RPC address the driver uses when connecting to the node\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def port(self):\n        \"\"\"\n        The port of the node.\n        \"\"\"\n        raise NotImplementedError()\n\n    @property\n    def ssl_options(self):\n        \"\"\"\n        SSL options specific to this endpoint.\n        \"\"\"\n        return None\n\n    @property\n    def socket_family(self):\n        \"\"\"\n        The socket family of the endpoint.\n        \"\"\"\n        return socket.AF_UNSPEC\n\n    def resolve(self):\n        \"\"\"\n        Resolve the endpoint to an address/port. This is called\n        only on socket connection.\n        \"\"\"\n        raise NotImplementedError()\n\nclass EndPointFactory(object):\n    cluster = None\n\n    def configure(self, cluster):\n        \"\"\"\n        This is called by the cluster during its initialization.\n        \"\"\"\n        self.cluster = cluster\n        return self\n\n    def create(self, row):\n        \"\"\"\n        Create an EndPoint from a system.peers row.\n        \"\"\"\n        raise NotImplementedError()\n\n@total_ordering\nclass DefaultEndPoint(EndPoint):\n    \"\"\"\n    Default EndPoint implementation, basically just an address and port.\n    \"\"\"\n\n    @property\n    def address(self):\n        return self._address\n\n    @property\n    def port(self):\n        return self._port\n\n    def resolve(self):\n        return (self._address, self._port)\n\n    def __hash__(self):\n        return hash((self.address, self.port))\n\n    def __lt__(self, other):\n        return (self.address, self.port) < (other.address, other.port)\n\n    def __str__(self):\n        return str('%s:%d' % (self.address, self.port))\n\n    def __repr__(self):\n        return '<%s: %s:%d>' % (self.__class__.__name__, self.address, self.port)\n\nclass DefaultEndPointFactory(EndPointFactory):\n    port = None\n    '\\n    If no port is discovered in the row, this is the default port\\n    used for endpoint creation. \\n    '\n\n    def __init__(self, port=None):\n        self.port = port\n\n    def create(self, row):\n        from cassandra.metadata import _NodeInfo\n        addr = _NodeInfo.get_broadcast_rpc_address(row)\n        port = _NodeInfo.get_broadcast_rpc_port(row)\n        if port is None:\n            port = self.port if self.port else 9042\n        return DefaultEndPoint(self.cluster.address_translator.translate(addr), port)\n\n@total_ordering\nclass SniEndPoint(EndPoint):\n    \"\"\"SNI Proxy EndPoint implementation.\"\"\"\n\n    def __init__(self, proxy_address, server_name, port=9042):\n        self._proxy_address = proxy_address\n        self._index = 0\n        self._resolved_address = None\n        self._port = port\n        self._server_name = server_name\n        self._ssl_options = {'server_hostname': server_name}\n\n    @property\n    def ssl_options(self):\n        return self._ssl_options\n\n    def __hash__(self):\n        return hash((self.address, self.port, self._server_name))\n\n    def __lt__(self, other):\n        return (self.address, self.port, self._server_name) < (other.address, other.port, self._server_name)\n\n    def __repr__(self):\n        return '<%s: %s:%d:%s>' % (self.__class__.__name__, self.address, self.port, self._server_name)\n\nclass SniEndPointFactory(EndPointFactory):\n\n    def create(self, row):\n        host_id = row.get('host_id')\n        if host_id is None:\n            raise ValueError('No host_id to create the SniEndPoint')\n        return SniEndPoint(self._proxy_address, str(host_id), self._port)\n\n@total_ordering\nclass UnixSocketEndPoint(EndPoint):\n    \"\"\"\n    Unix Socket EndPoint implementation.\n    \"\"\"\n\n    def __init__(self, unix_socket_path):\n        self._unix_socket_path = unix_socket_path\n\n    @property\n    def address(self):\n        return self._unix_socket_path\n\n    @property\n    def port(self):\n        return None\n\n    @property\n    def socket_family(self):\n        return socket.AF_UNIX\n\n    def resolve(self):\n        return (self.address, None)\n\n    def __eq__(self, other):\n        return isinstance(other, UnixSocketEndPoint) and self._unix_socket_path == other._unix_socket_path\n\n    def __hash__(self):\n        return hash(self._unix_socket_path)\n\n    def __lt__(self, other):\n        return self._unix_socket_path < other._unix_socket_path\n\n    def __str__(self):\n        return str('%s' % (self._unix_socket_path,))\n\n    def __repr__(self):\n        return '<%s: %s>' % (self.__class__.__name__, self._unix_socket_path)\n\nclass _Frame(object):\n\n    def __init__(self, version, flags, stream, opcode, body_offset, end_pos):\n        self.version = version\n        self.flags = flags\n        self.stream = stream\n        self.opcode = opcode\n        self.body_offset = body_offset\n        self.end_pos = end_pos\n\n    def __eq__(self, other):\n        if isinstance(other, _Frame):\n            return self.version == other.version and self.flags == other.flags and (self.stream == other.stream) and (self.opcode == other.opcode) and (self.body_offset == other.body_offset) and (self.end_pos == other.end_pos)\n        return NotImplemented\n\n    def __str__(self):\n        return 'ver({0}); flags({1:04b}); stream({2}); op({3}); offset({4}); len({5})'.format(self.version, self.flags, self.stream, self.opcode, self.body_offset, self.end_pos - self.body_offset)\nNONBLOCKING = (errno.EAGAIN, errno.EWOULDBLOCK)\n\nclass ConnectionException(Exception):\n    \"\"\"\n    An unrecoverable error was hit when attempting to use a connection,\n    or the connection was already closed or defunct.\n    \"\"\"\n\n    def __init__(self, message, endpoint=None):\n        Exception.__init__(self, message)\n        self.endpoint = endpoint\n\n    @property\n    def host(self):\n        return self.endpoint.address\n\nclass ConnectionShutdown(ConnectionException):\n    \"\"\"\n    Raised when a connection has been marked as defunct or has been closed.\n    \"\"\"\n    pass\n\nclass ProtocolVersionUnsupported(ConnectionException):\n    \"\"\"\n    Server rejected startup message due to unsupported protocol version\n    \"\"\"\n\n    def __init__(self, endpoint, startup_version):\n        msg = 'Unsupported protocol version on %s: %d' % (endpoint, startup_version)\n        super(ProtocolVersionUnsupported, self).__init__(msg, endpoint)\n        self.startup_version = startup_version\n\nclass ConnectionBusy(Exception):\n    \"\"\"\n    An attempt was made to send a message through a :class:`.Connection` that\n    was already at the max number of in-flight operations.\n    \"\"\"\n    pass\n\nclass ProtocolError(Exception):\n    \"\"\"\n    Communication did not match the protocol that this driver expects.\n    \"\"\"\n    pass\n\nclass CrcMismatchException(ConnectionException):\n    pass\n\nclass ContinuousPagingState(object):\n    \"\"\"\n     A class for specifying continuous paging state, only supported starting with DSE_V2.\n    \"\"\"\n    num_pages_requested = None\n    '\\n    How many pages we have already requested\\n    '\n    num_pages_received = None\n    '\\n    How many pages we have already received\\n    '\n    max_queue_size = None\n    '\\n    The max queue size chosen by the user via the options\\n    '\n\n    def __init__(self, max_queue_size):\n        self.num_pages_requested = max_queue_size\n        self.num_pages_received = 0\n        self.max_queue_size = max_queue_size\n\nclass ContinuousPagingSession(object):\n\n    def __init__(self, stream_id, decoder, row_factory, connection, state):\n        self.stream_id = stream_id\n        self.decoder = decoder\n        self.row_factory = row_factory\n        self.connection = connection\n        self._condition = Condition()\n        self._stop = False\n        self._page_queue = deque()\n        self._state = state\n        self.released = False\n\n    def on_message(self, result):\n        if isinstance(result, ResultMessage):\n            self.on_page(result)\n        elif isinstance(result, ErrorMessage):\n            self.on_error(result)\n\n    def on_page(self, result):\n        with self._condition:\n            if self._state:\n                self._state.num_pages_received += 1\n            self._page_queue.appendleft((result.column_names, result.parsed_rows, None))\n            self._stop |= result.continuous_paging_last\n            self._condition.notify()\n        if result.continuous_paging_last:\n            self.released = True\n\n    def on_error(self, error):\n        if isinstance(error, ErrorMessage):\n            error = error.to_exception()\n        log.debug('Got error %s for session %s', error, self.stream_id)\n        with self._condition:\n            self._page_queue.appendleft((None, None, error))\n            self._stop = True\n            self._condition.notify()\n        self.released = True\n\n    def results(self):\n        try:\n            self._condition.acquire()\n            while True:\n                while not self._page_queue and (not self._stop):\n                    self._condition.wait(timeout=5)\n                while self._page_queue:\n                    names, rows, err = self._page_queue.pop()\n                    if err:\n                        raise err\n                    self.maybe_request_more()\n                    self._condition.release()\n                    for row in self.row_factory(names, rows):\n                        yield row\n                    self._condition.acquire()\n                if self._stop:\n                    break\n        finally:\n            try:\n                self._condition.release()\n            except RuntimeError:\n                pass\n\n    def maybe_request_more(self):\n        if not self._state:\n            return\n        max_queue_size = self._state.max_queue_size\n        num_in_flight = self._state.num_pages_requested - self._state.num_pages_received\n        space_in_queue = max_queue_size - len(self._page_queue) - num_in_flight\n        log.debug('Session %s from %s, space in CP queue: %s, requested: %s, received: %s, num_in_flight: %s', self.stream_id, self.connection.host, space_in_queue, self._state.num_pages_requested, self._state.num_pages_received, num_in_flight)\n        if space_in_queue >= max_queue_size / 2:\n            self.update_next_pages(space_in_queue)\n\n    def update_next_pages(self, num_next_pages):\n        try:\n            self._state.num_pages_requested += num_next_pages\n            log.debug('Updating backpressure for session %s from %s', self.stream_id, self.connection.host)\n            with self.connection.lock:\n                self.connection.send_msg(ReviseRequestMessage(ReviseRequestMessage.RevisionType.PAGING_BACKPRESSURE, self.stream_id, next_pages=num_next_pages), self.connection.get_request_id(), self._on_backpressure_response)\n        except ConnectionShutdown as ex:\n            log.debug('Failed to update backpressure for session %s from %s, connection is shutdown', self.stream_id, self.connection.host)\n            self.on_error(ex)\n\n    def _on_backpressure_response(self, response):\n        if isinstance(response, ResultMessage):\n            log.debug('Paging session %s backpressure updated.', self.stream_id)\n        else:\n            log.error('Failed updating backpressure for session %s from %s: %s', self.stream_id, self.connection.host, response.to_exception() if hasattr(response, 'to_exception') else response)\n            self.on_error(response)\n\n    def cancel(self):\n        try:\n            log.debug('Canceling paging session %s from %s', self.stream_id, self.connection.host)\n            with self.connection.lock:\n                self.connection.send_msg(ReviseRequestMessage(ReviseRequestMessage.RevisionType.PAGING_CANCEL, self.stream_id), self.connection.get_request_id(), self._on_cancel_response)\n        except ConnectionShutdown:\n            log.debug('Failed to cancel session %s from %s, connection is shutdown', self.stream_id, self.connection.host)\n        with self._condition:\n            self._stop = True\n            self._condition.notify()\n\n    def _on_cancel_response(self, response):\n        if isinstance(response, ResultMessage):\n            log.debug('Paging session %s canceled.', self.stream_id)\n        else:\n            log.error('Failed canceling streaming session %s from %s: %s', self.stream_id, self.connection.host, response.to_exception() if hasattr(response, 'to_exception') else response)\n        self.released = True\n\ndef defunct_on_error(f):\n\n    @wraps(f)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return f(self, *args, **kwargs)\n        except Exception as exc:\n            self.defunct(exc)\n    return wrapper\nDEFAULT_CQL_VERSION = '3.0.0'\n\nclass _ConnectionIOBuffer(object):\n    \"\"\"\n    Abstraction class to ease the use of the different connection io buffers. With\n    protocol V5 and checksumming, the data is read, validated and copied to another\n    cql frame buffer.\n    \"\"\"\n    _io_buffer = None\n    _cql_frame_buffer = None\n    _connection = None\n    _segment_consumed = False\n\n    def __init__(self, connection):\n        self._io_buffer = io.BytesIO()\n        self._connection = weakref.proxy(connection)\n\n    @property\n    def io_buffer(self):\n        return self._io_buffer\n\n    @property\n    def cql_frame_buffer(self):\n        return self._cql_frame_buffer if self.is_checksumming_enabled else self._io_buffer\n\n    def set_checksumming_buffer(self):\n        self.reset_io_buffer()\n        self._cql_frame_buffer = io.BytesIO()\n\n    @property\n    def is_checksumming_enabled(self):\n        return self._connection._is_checksumming_enabled\n\n    @property\n    def has_consumed_segment(self):\n        return self._segment_consumed\n\n    def readable_io_bytes(self):\n        return self.io_buffer.tell()\n\n    def readable_cql_frame_bytes(self):\n        return self.cql_frame_buffer.tell()\n\n    def reset_io_buffer(self):\n        self._io_buffer = io.BytesIO(self._io_buffer.read())\n        self._io_buffer.seek(0, 2)\n\n    def reset_cql_frame_buffer(self):\n        if self.is_checksumming_enabled:\n            self._cql_frame_buffer = io.BytesIO(self._cql_frame_buffer.read())\n            self._cql_frame_buffer.seek(0, 2)\n        else:\n            self.reset_io_buffer()\n\nclass Connection(object):\n    CALLBACK_ERR_THREAD_THRESHOLD = 100\n    in_buffer_size = 4096\n    out_buffer_size = 4096\n    cql_version = None\n    no_compact = False\n    protocol_version = ProtocolVersion.MAX_SUPPORTED\n    keyspace = None\n    compression = True\n    _compression_type = None\n    compressor = None\n    decompressor = None\n    endpoint = None\n    ssl_options = None\n    ssl_context = None\n    last_error = None\n    in_flight = 0\n    max_in_flight = 2 ** 15\n    request_ids = None\n    highest_request_id = 0\n    orphaned_request_ids = None\n    orphaned_threshold_reached = False\n    orphaned_threshold = 3 * max_in_flight // 4\n    is_defunct = False\n    is_closed = False\n    lock = None\n    user_type_map = None\n    msg_received = False\n    is_unsupported_proto_version = False\n    is_control_connection = False\n    signaled_error = False\n    allow_beta_protocol_version = False\n    _current_frame = None\n    _socket = None\n    _socket_impl = socket\n    _check_hostname = False\n    _product_type = None\n    _is_checksumming_enabled = False\n    _on_orphaned_stream_released = None\n\n    @property\n    def _iobuf(self):\n        return self._io_buffer.io_buffer\n\n    def __init__(self, host='127.0.0.1', port=9042, authenticator=None, ssl_options=None, sockopts=None, compression=True, cql_version=None, protocol_version=ProtocolVersion.MAX_SUPPORTED, is_control_connection=False, user_type_map=None, connect_timeout=None, allow_beta_protocol_version=False, no_compact=False, ssl_context=None, on_orphaned_stream_released=None):\n        self.endpoint = host if isinstance(host, EndPoint) else DefaultEndPoint(host, port)\n        self.authenticator = authenticator\n        self.ssl_options = ssl_options.copy() if ssl_options else {}\n        self.ssl_context = ssl_context\n        self.sockopts = sockopts\n        self.compression = compression\n        self.cql_version = cql_version\n        self.protocol_version = protocol_version\n        self.is_control_connection = is_control_connection\n        self.user_type_map = user_type_map\n        self.connect_timeout = connect_timeout\n        self.allow_beta_protocol_version = allow_beta_protocol_version\n        self.no_compact = no_compact\n        self._push_watchers = defaultdict(set)\n        self._requests = {}\n        self._io_buffer = _ConnectionIOBuffer(self)\n        self._continuous_paging_sessions = {}\n        self._socket_writable = True\n        self.orphaned_request_ids = set()\n        self._on_orphaned_stream_released = on_orphaned_stream_released\n        if ssl_options:\n            self.ssl_options.update(self.endpoint.ssl_options or {})\n        elif self.endpoint.ssl_options:\n            self.ssl_options = self.endpoint.ssl_options\n        if not self.ssl_context and self.ssl_options:\n            self.ssl_context = self._build_ssl_context_from_options()\n        if protocol_version >= 3:\n            self.max_request_id = min(self.max_in_flight - 1, 2 ** 15 - 1)\n            initial_size = min(300, self.max_in_flight)\n            self.request_ids = deque(range(initial_size))\n            self.highest_request_id = initial_size - 1\n        else:\n            self.max_request_id = min(self.max_in_flight, 2 ** 7 - 1)\n            self.request_ids = deque(range(self.max_request_id + 1))\n            self.highest_request_id = self.max_request_id\n        self.lock = RLock()\n        self.connected_event = Event()\n\n    @property\n    def host(self):\n        return self.endpoint.address\n\n    @property\n    def port(self):\n        return self.endpoint.port\n\n    @classmethod\n    def initialize_reactor(cls):\n        \"\"\"\n        Called once by Cluster.connect().  This should be used by implementations\n        to set up any resources that will be shared across connections.\n        \"\"\"\n        pass\n\n    @classmethod\n    def handle_fork(cls):\n        \"\"\"\n        Called after a forking.  This should cleanup any remaining reactor state\n        from the parent process.\n        \"\"\"\n        pass\n\n    @classmethod\n    def create_timer(cls, timeout, callback):\n        raise NotImplementedError()\n\n    @classmethod\n    def factory(cls, endpoint, timeout, *args, **kwargs):\n        \"\"\"\n        A factory function which returns connections which have\n        succeeded in connecting and are ready for service (or\n        raises an exception otherwise).\n        \"\"\"\n        start = time.time()\n        kwargs['connect_timeout'] = timeout\n        conn = cls(endpoint, *args, **kwargs)\n        elapsed = time.time() - start\n        conn.connected_event.wait(timeout - elapsed)\n        if conn.last_error:\n            if conn.is_unsupported_proto_version:\n                raise ProtocolVersionUnsupported(endpoint, conn.protocol_version)\n            raise conn.last_error\n        elif not conn.connected_event.is_set():\n            conn.close()\n            raise OperationTimedOut('Timed out creating connection (%s seconds)' % timeout)\n        else:\n            return conn\n\n    def _build_ssl_context_from_options(self):\n        ssl_context_opt_names = ['ssl_version', 'cert_reqs', 'check_hostname', 'keyfile', 'certfile', 'ca_certs', 'ciphers']\n        opts = {k: self.ssl_options.get(k, None) for k in ssl_context_opt_names if k in self.ssl_options}\n        ssl_version = opts.get('ssl_version', None) or ssl.PROTOCOL_TLS_CLIENT\n        cert_reqs = opts.get('cert_reqs', None) or ssl.CERT_REQUIRED\n        rv = ssl.SSLContext(protocol=int(ssl_version))\n        rv.check_hostname = bool(opts.get('check_hostname', False))\n        rv.options = int(cert_reqs)\n        certfile = opts.get('certfile', None)\n        keyfile = opts.get('keyfile', None)\n        if certfile:\n            rv.load_cert_chain(certfile, keyfile)\n        ca_certs = opts.get('ca_certs', None)\n        if ca_certs:\n            rv.load_verify_locations(ca_certs)\n        ciphers = opts.get('ciphers', None)\n        if ciphers:\n            rv.set_ciphers(ciphers)\n        return rv\n\n    def _wrap_socket_from_context(self):\n        wrap_socket_opt_names = ['server_side', 'do_handshake_on_connect', 'suppress_ragged_eofs', 'server_hostname']\n        opts = {k: self.ssl_options.get(k, None) for k in wrap_socket_opt_names if k in self.ssl_options}\n        if self.ssl_context.check_hostname and 'server_hostname' not in opts:\n            server_hostname = self.endpoint.address\n            opts['server_hostname'] = server_hostname\n        return self.ssl_context.wrap_socket(self._socket, **opts)\n\n    def _initiate_connection(self, sockaddr):\n        self._socket.connect(sockaddr)\n\n    def _validate_hostname(self):\n        pass\n\n    def _get_socket_addresses(self):\n        address, port = self.endpoint.resolve()\n        if hasattr(socket, 'AF_UNIX') and self.endpoint.socket_family == socket.AF_UNIX:\n            return [(socket.AF_UNIX, socket.SOCK_STREAM, 0, None, address)]\n        addresses = socket.getaddrinfo(address, port, self.endpoint.socket_family, socket.SOCK_STREAM)\n        if not addresses:\n            raise ConnectionException('getaddrinfo returned empty list for %s' % (self.endpoint,))\n        return addresses\n\n    def _connect_socket(self):\n        sockerr = None\n        addresses = self._get_socket_addresses()\n        for af, socktype, proto, _, sockaddr in addresses:\n            try:\n                self._socket = self._socket_impl.socket(af, socktype, proto)\n                if self.ssl_context:\n                    self._socket = self._wrap_socket_from_context()\n                self._socket.settimeout(self.connect_timeout)\n                self._initiate_connection(sockaddr)\n                self._socket.settimeout(None)\n                if self._check_hostname:\n                    self._validate_hostname()\n                sockerr = None\n                break\n            except socket.error as err:\n                if self._socket:\n                    self._socket.close()\n                    self._socket = None\n                sockerr = err\n        if sockerr:\n            raise socket.error(sockerr.errno, 'Tried connecting to %s. Last error: %s' % ([a[4] for a in addresses], sockerr.strerror or sockerr))\n        if self.sockopts:\n            for args in self.sockopts:\n                self._socket.setsockopt(*args)\n\n    def _enable_compression(self):\n        if self._compressor:\n            self.compressor = self._compressor\n\n    def _enable_checksumming(self):\n        self._io_buffer.set_checksumming_buffer()\n        self._is_checksumming_enabled = True\n        self._segment_codec = segment_codec_lz4 if self.compressor else segment_codec_no_compression\n        log.debug('Enabling protocol checksumming on connection (%s).', id(self))\n\n    def close(self):\n        raise NotImplementedError()\n\n    def defunct(self, exc):\n        with self.lock:\n            if self.is_defunct or self.is_closed:\n                return\n            self.is_defunct = True\n        exc_info = sys.exc_info()\n        if any(exc_info):\n            log.debug('Defuncting connection (%s) to %s:', id(self), self.endpoint, exc_info=exc_info)\n        else:\n            log.debug('Defuncting connection (%s) to %s: %s', id(self), self.endpoint, exc)\n        self.last_error = exc\n        self.close()\n        self.error_all_cp_sessions(exc)\n        self.error_all_requests(exc)\n        self.connected_event.set()\n        return exc\n\n    def error_all_cp_sessions(self, exc):\n        stream_ids = list(self._continuous_paging_sessions.keys())\n        for stream_id in stream_ids:\n            self._continuous_paging_sessions[stream_id].on_error(exc)\n\n    def error_all_requests(self, exc):\n        with self.lock:\n            requests = self._requests\n            self._requests = {}\n        if not requests:\n            return\n        new_exc = ConnectionShutdown(str(exc))\n\n        def try_callback(cb):\n            try:\n                cb(new_exc)\n            except Exception:\n                log.warning('Ignoring unhandled exception while erroring requests for a failed connection (%s) to host %s:', id(self), self.endpoint, exc_info=True)\n        cb, _, _ = requests.popitem()[1]\n        try_callback(cb)\n        if not requests:\n            return\n\n        def err_all_callbacks():\n            for cb, _, _ in requests.values():\n                try_callback(cb)\n        if len(requests) < Connection.CALLBACK_ERR_THREAD_THRESHOLD:\n            err_all_callbacks()\n        else:\n            t = Thread(target=err_all_callbacks)\n            t.daemon = True\n            t.start()\n\n    def get_request_id(self):\n        \"\"\"\n        This must be called while self.lock is held.\n        \"\"\"\n        try:\n            return self.request_ids.popleft()\n        except IndexError:\n            new_request_id = self.highest_request_id + 1\n            assert new_request_id <= self.max_request_id\n            self.highest_request_id = new_request_id\n            return self.highest_request_id\n\n    def handle_pushed(self, response):\n        log.debug('Message pushed from server: %r', response)\n        for cb in self._push_watchers.get(response.event_type, []):\n            try:\n                cb(response.event_args)\n            except Exception:\n                log.exception('Pushed event handler errored, ignoring:')\n\n    def send_msg(self, msg, request_id, cb, encoder=ProtocolHandler.encode_message, decoder=ProtocolHandler.decode_message, result_metadata=None):\n        if self.is_defunct:\n            raise ConnectionShutdown('Connection to %s is defunct' % self.endpoint)\n        elif self.is_closed:\n            raise ConnectionShutdown('Connection to %s is closed' % self.endpoint)\n        elif not self._socket_writable:\n            raise ConnectionBusy('Connection %s is overloaded' % self.endpoint)\n        self._requests[request_id] = (cb, decoder, result_metadata)\n        msg = encoder(msg, request_id, self.protocol_version, compressor=self.compressor, allow_beta_protocol_version=self.allow_beta_protocol_version)\n        if self._is_checksumming_enabled:\n            buffer = io.BytesIO()\n            self._segment_codec.encode(buffer, msg)\n            msg = buffer.getvalue()\n        self.push(msg)\n        return len(msg)\n\n    def wait_for_response(self, msg, timeout=None, **kwargs):\n        return self.wait_for_responses(msg, timeout=timeout, **kwargs)[0]\n\n    def wait_for_responses(self, *msgs, **kwargs):\n        \"\"\"\n        Returns a list of (success, response) tuples.  If success\n        is False, response will be an Exception.  Otherwise, response\n        will be the normal query response.\n\n        If fail_on_error was left as True and one of the requests\n        failed, the corresponding Exception will be raised.\n        \"\"\"\n        if self.is_closed or self.is_defunct:\n            raise ConnectionShutdown('Connection %s is already closed' % (self,))\n        timeout = kwargs.get('timeout')\n        fail_on_error = kwargs.get('fail_on_error', True)\n        waiter = ResponseWaiter(self, len(msgs), fail_on_error)\n        messages_sent = 0\n        while True:\n            needed = len(msgs) - messages_sent\n            with self.lock:\n                available = min(needed, self.max_request_id - self.in_flight + 1)\n                request_ids = [self.get_request_id() for _ in range(available)]\n                self.in_flight += available\n            for i, request_id in enumerate(request_ids):\n                self.send_msg(msgs[messages_sent + i], request_id, partial(waiter.got_response, index=messages_sent + i))\n            messages_sent += available\n            if messages_sent == len(msgs):\n                break\n            else:\n                if timeout is not None:\n                    timeout -= 0.01\n                    if timeout <= 0.0:\n                        raise OperationTimedOut()\n                time.sleep(0.01)\n        try:\n            return waiter.deliver(timeout)\n        except OperationTimedOut:\n            raise\n        except Exception as exc:\n            self.defunct(exc)\n            raise\n\n    def register_watcher(self, event_type, callback, register_timeout=None):\n        \"\"\"\n        Register a callback for a given event type.\n        \"\"\"\n        self._push_watchers[event_type].add(callback)\n        self.wait_for_response(RegisterMessage(event_list=[event_type]), timeout=register_timeout)\n\n    def register_watchers(self, type_callback_dict, register_timeout=None):\n        \"\"\"\n        Register multiple callback/event type pairs, expressed as a dict.\n        \"\"\"\n        for event_type, callback in type_callback_dict.items():\n            self._push_watchers[event_type].add(callback)\n        self.wait_for_response(RegisterMessage(event_list=type_callback_dict.keys()), timeout=register_timeout)\n\n    def control_conn_disposed(self):\n        self.is_control_connection = False\n        self._push_watchers = {}\n\n    @defunct_on_error\n    def _read_frame_header(self):\n        buf = self._io_buffer.cql_frame_buffer.getvalue()\n        pos = len(buf)\n        if pos:\n            version = buf[0] & PROTOCOL_VERSION_MASK\n            if version not in ProtocolVersion.SUPPORTED_VERSIONS:\n                raise ProtocolError('This version of the driver does not support protocol version %d' % version)\n            frame_header = frame_header_v3 if version >= 3 else frame_header_v1_v2\n            header_size = frame_header.size + 1\n            if pos >= header_size:\n                flags, stream, op, body_len = frame_header.unpack_from(buf, 1)\n                if body_len < 0:\n                    raise ProtocolError('Received negative body length: %r' % body_len)\n                self._current_frame = _Frame(version, flags, stream, op, header_size, body_len + header_size)\n        return pos\n\n    @defunct_on_error\n    def _process_segment_buffer(self):\n        readable_bytes = self._io_buffer.readable_io_bytes()\n        if readable_bytes >= self._segment_codec.header_length_with_crc:\n            try:\n                self._io_buffer.io_buffer.seek(0)\n                segment_header = self._segment_codec.decode_header(self._io_buffer.io_buffer)\n                if readable_bytes >= segment_header.segment_length:\n                    segment = self._segment_codec.decode(self._iobuf, segment_header)\n                    self._io_buffer._segment_consumed = True\n                    self._io_buffer.cql_frame_buffer.write(segment.payload)\n                else:\n                    self._io_buffer._segment_consumed = False\n                    self._io_buffer.io_buffer.seek(0)\n            except CrcException as exc:\n                raise CrcMismatchException(str(exc), self.endpoint)\n        else:\n            self._io_buffer._segment_consumed = False\n\n    def process_io_buffer(self):\n        while True:\n            if self._is_checksumming_enabled and self._io_buffer.readable_io_bytes():\n                self._process_segment_buffer()\n                self._io_buffer.reset_io_buffer()\n            if self._is_checksumming_enabled and (not self._io_buffer.has_consumed_segment):\n                return\n            if not self._current_frame:\n                pos = self._read_frame_header()\n            else:\n                pos = self._io_buffer.readable_cql_frame_bytes()\n            if not self._current_frame or pos < self._current_frame.end_pos:\n                if self._is_checksumming_enabled and self._io_buffer.readable_io_bytes():\n                    continue\n                return\n            else:\n                frame = self._current_frame\n                self._io_buffer.cql_frame_buffer.seek(frame.body_offset)\n                msg = self._io_buffer.cql_frame_buffer.read(frame.end_pos - frame.body_offset)\n                self.process_msg(frame, msg)\n                self._io_buffer.reset_cql_frame_buffer()\n                self._current_frame = None\n\n    @defunct_on_error\n    def process_msg(self, header, body):\n        self.msg_received = True\n        stream_id = header.stream\n        if stream_id < 0:\n            callback = None\n            decoder = ProtocolHandler.decode_message\n            result_metadata = None\n        elif stream_id in self._continuous_paging_sessions:\n            paging_session = self._continuous_paging_sessions[stream_id]\n            callback = paging_session.on_message\n            decoder = paging_session.decoder\n            result_metadata = None\n        else:\n            need_notify_of_release = False\n            with self.lock:\n                if stream_id in self.orphaned_request_ids:\n                    self.in_flight -= 1\n                    self.orphaned_request_ids.remove(stream_id)\n                    need_notify_of_release = True\n            if need_notify_of_release and self._on_orphaned_stream_released:\n                self._on_orphaned_stream_released()\n            try:\n                callback, decoder, result_metadata = self._requests.pop(stream_id)\n            except KeyError:\n                with self.lock:\n                    self.request_ids.append(stream_id)\n                return\n        try:\n            response = decoder(header.version, self.user_type_map, stream_id, header.flags, header.opcode, body, self.decompressor, result_metadata)\n        except Exception as exc:\n            log.exception('Error decoding response from Cassandra. %s; buffer: %r', header, self._iobuf.getvalue())\n            if callback is not None:\n                callback(exc)\n            self.defunct(exc)\n            return\n        try:\n            if stream_id >= 0:\n                if isinstance(response, ProtocolException):\n                    if 'unsupported protocol version' in response.message:\n                        self.is_unsupported_proto_version = True\n                    else:\n                        log.error('Closing connection %s due to protocol error: %s', self, response.summary_msg())\n                    self.defunct(response)\n                if callback is not None:\n                    callback(response)\n            else:\n                self.handle_pushed(response)\n        except Exception:\n            log.exception('Callback handler errored, ignoring:')\n        if stream_id >= 0:\n            if stream_id in self._continuous_paging_sessions:\n                if self._continuous_paging_sessions[stream_id].released:\n                    self.remove_continuous_paging_session(stream_id)\n            else:\n                with self.lock:\n                    self.request_ids.append(stream_id)\n\n    def new_continuous_paging_session(self, stream_id, decoder, row_factory, state):\n        session = ContinuousPagingSession(stream_id, decoder, row_factory, self, state)\n        self._continuous_paging_sessions[stream_id] = session\n        return session\n\n    def remove_continuous_paging_session(self, stream_id):\n        try:\n            self._continuous_paging_sessions.pop(stream_id)\n            with self.lock:\n                log.debug('Returning cp session stream id %s', stream_id)\n                self.request_ids.append(stream_id)\n        except KeyError:\n            pass\n\n    @defunct_on_error\n    def _send_options_message(self):\n        log.debug('Sending initial options message for new connection (%s) to %s', id(self), self.endpoint)\n        self.send_msg(OptionsMessage(), self.get_request_id(), self._handle_options_response)\n\n    @defunct_on_error\n    def _handle_options_response(self, options_response):\n        if self.is_defunct:\n            return\n        if not isinstance(options_response, SupportedMessage):\n            if isinstance(options_response, ConnectionException):\n                raise options_response\n            else:\n                log.error('Did not get expected SupportedMessage response; instead, got: %s', options_response)\n                raise ConnectionException('Did not get expected SupportedMessage response; instead, got: %s' % (options_response,))\n        log.debug('Received options response on new connection (%s) from %s', id(self), self.endpoint)\n        supported_cql_versions = options_response.cql_versions\n        remote_supported_compressions = options_response.options['COMPRESSION']\n        self._product_type = options_response.options.get('PRODUCT_TYPE', [None])[0]\n        if self.cql_version:\n            if self.cql_version not in supported_cql_versions:\n                raise ProtocolError('cql_version %r is not supported by remote (w/ native protocol). Supported versions: %r' % (self.cql_version, supported_cql_versions))\n        else:\n            self.cql_version = supported_cql_versions[0]\n        self._compressor = None\n        compression_type = None\n        if self.compression:\n            overlap = set(locally_supported_compressions.keys()) & set(remote_supported_compressions)\n            if len(overlap) == 0:\n                log.debug('No available compression types supported on both ends. locally supported: %r. remotely supported: %r', locally_supported_compressions.keys(), remote_supported_compressions)\n            else:\n                compression_type = None\n                if isinstance(self.compression, str):\n                    if self.compression not in remote_supported_compressions:\n                        raise ProtocolError('The requested compression type (%s) is not supported by the Cassandra server at %s' % (self.compression, self.endpoint))\n                    compression_type = self.compression\n                else:\n                    for k in locally_supported_compressions.keys():\n                        if k in overlap:\n                            compression_type = k\n                            break\n                if compression_type == 'snappy' and ProtocolVersion.has_checksumming_support(self.protocol_version):\n                    log.debug('Snappy compression is not supported with protocol version %s and checksumming. Consider installing lz4. Disabling compression.', self.protocol_version)\n                    compression_type = None\n                else:\n                    self._compression_type = compression_type\n                    self._compressor, self.decompressor = locally_supported_compressions[compression_type]\n        self._send_startup_message(compression_type, no_compact=self.no_compact)\n\n    @defunct_on_error\n    def _send_startup_message(self, compression=None, no_compact=False):\n        log.debug('Sending StartupMessage on %s', self)\n        opts = {'DRIVER_NAME': DRIVER_NAME, 'DRIVER_VERSION': DRIVER_VERSION}\n        if compression:\n            opts['COMPRESSION'] = compression\n        if no_compact:\n            opts['NO_COMPACT'] = 'true'\n        sm = StartupMessage(cqlversion=self.cql_version, options=opts)\n        self.send_msg(sm, self.get_request_id(), cb=self._handle_startup_response)\n        log.debug('Sent StartupMessage on %s', self)\n\n    @defunct_on_error\n    def _handle_startup_response(self, startup_response, did_authenticate=False):\n        if self.is_defunct:\n            return\n        if isinstance(startup_response, ReadyMessage):\n            if self.authenticator:\n                log.warning('An authentication challenge was not sent, this is suspicious because the driver expects authentication (configured authenticator = %s)', self.authenticator.__class__.__name__)\n            log.debug('Got ReadyMessage on new connection (%s) from %s', id(self), self.endpoint)\n            self._enable_compression()\n            if ProtocolVersion.has_checksumming_support(self.protocol_version):\n                self._enable_checksumming()\n            self.connected_event.set()\n        elif isinstance(startup_response, AuthenticateMessage):\n            log.debug('Got AuthenticateMessage on new connection (%s) from %s: %s', id(self), self.endpoint, startup_response.authenticator)\n            if self.authenticator is None:\n                log.error('Failed to authenticate to %s. If you are trying to connect to a DSE cluster, consider using TransitionalModePlainTextAuthProvider if DSE authentication is configured with transitional mode' % (self.host,))\n                raise AuthenticationFailed('Remote end requires authentication')\n            self._enable_compression()\n            if ProtocolVersion.has_checksumming_support(self.protocol_version):\n                self._enable_checksumming()\n            if isinstance(self.authenticator, dict):\n                log.debug('Sending credentials-based auth response on %s', self)\n                cm = CredentialsMessage(creds=self.authenticator)\n                callback = partial(self._handle_startup_response, did_authenticate=True)\n                self.send_msg(cm, self.get_request_id(), cb=callback)\n            else:\n                log.debug('Sending SASL-based auth response on %s', self)\n                self.authenticator.server_authenticator_class = startup_response.authenticator\n                initial_response = self.authenticator.initial_response()\n                initial_response = '' if initial_response is None else initial_response\n                self.send_msg(AuthResponseMessage(initial_response), self.get_request_id(), self._handle_auth_response)\n        elif isinstance(startup_response, ErrorMessage):\n            log.debug('Received ErrorMessage on new connection (%s) from %s: %s', id(self), self.endpoint, startup_response.summary_msg())\n            if did_authenticate:\n                raise AuthenticationFailed('Failed to authenticate to %s: %s' % (self.endpoint, startup_response.summary_msg()))\n            else:\n                raise ConnectionException('Failed to initialize new connection to %s: %s' % (self.endpoint, startup_response.summary_msg()))\n        elif isinstance(startup_response, ConnectionShutdown):\n            log.debug('Connection to %s was closed during the startup handshake', self.endpoint)\n            raise startup_response\n        else:\n            msg = 'Unexpected response during Connection setup: %r'\n            log.error(msg, startup_response)\n            raise ProtocolError(msg % (startup_response,))\n\n    @defunct_on_error\n    def _handle_auth_response(self, auth_response):\n        if self.is_defunct:\n            return\n        if isinstance(auth_response, AuthSuccessMessage):\n            log.debug('Connection %s successfully authenticated', self)\n            self.authenticator.on_authentication_success(auth_response.token)\n            if self._compressor:\n                self.compressor = self._compressor\n            self.connected_event.set()\n        elif isinstance(auth_response, AuthChallengeMessage):\n            response = self.authenticator.evaluate_challenge(auth_response.challenge)\n            msg = AuthResponseMessage('' if response is None else response)\n            log.debug('Responding to auth challenge on %s', self)\n            self.send_msg(msg, self.get_request_id(), self._handle_auth_response)\n        elif isinstance(auth_response, ErrorMessage):\n            log.debug('Received ErrorMessage on new connection (%s) from %s: %s', id(self), self.endpoint, auth_response.summary_msg())\n            raise AuthenticationFailed('Failed to authenticate to %s: %s' % (self.endpoint, auth_response.summary_msg()))\n        elif isinstance(auth_response, ConnectionShutdown):\n            log.debug('Connection to %s was closed during the authentication process', self.endpoint)\n            raise auth_response\n        else:\n            msg = 'Unexpected response during Connection authentication to %s: %r'\n            log.error(msg, self.endpoint, auth_response)\n            raise ProtocolError(msg % (self.endpoint, auth_response))\n\n    def set_keyspace_blocking(self, keyspace):\n        if not keyspace or keyspace == self.keyspace:\n            return\n        query = QueryMessage(query='USE \"%s\"' % (keyspace,), consistency_level=ConsistencyLevel.ONE)\n        try:\n            result = self.wait_for_response(query)\n        except InvalidRequestException as ire:\n            raise ire.to_exception()\n        except Exception as exc:\n            conn_exc = ConnectionException('Problem while setting keyspace: %r' % (exc,), self.endpoint)\n            self.defunct(conn_exc)\n            raise conn_exc\n        if isinstance(result, ResultMessage):\n            self.keyspace = keyspace\n        else:\n            conn_exc = ConnectionException('Problem while setting keyspace: %r' % (result,), self.endpoint)\n            self.defunct(conn_exc)\n            raise conn_exc\n\n    def set_keyspace_async(self, keyspace, callback):\n        \"\"\"\n        Use this in order to avoid deadlocking the event loop thread.\n        When the operation completes, `callback` will be called with\n        two arguments: this connection and an Exception if an error\n        occurred, otherwise :const:`None`.\n\n        This method will always increment :attr:`.in_flight` attribute, even if\n        it doesn't need to make a request, just to maintain an\n        \":attr:`.in_flight` is incremented\" invariant.\n        \"\"\"\n        while True:\n            with self.lock:\n                if self.in_flight < self.max_request_id:\n                    self.in_flight += 1\n                    break\n            time.sleep(0.001)\n        if not keyspace or keyspace == self.keyspace:\n            callback(self, None)\n            return\n        query = QueryMessage(query='USE \"%s\"' % (keyspace,), consistency_level=ConsistencyLevel.ONE)\n\n        def process_result(result):\n            if isinstance(result, ResultMessage):\n                self.keyspace = keyspace\n                callback(self, None)\n            elif isinstance(result, InvalidRequestException):\n                callback(self, result.to_exception())\n            else:\n                callback(self, self.defunct(ConnectionException('Problem while setting keyspace: %r' % (result,), self.endpoint)))\n        request_id = self.get_request_id()\n        self.send_msg(query, request_id, process_result)\n\n    @property\n    def is_idle(self):\n        return not self.msg_received\n\n    def reset_idle(self):\n        self.msg_received = False\n\n    def __str__(self):\n        status = ''\n        if self.is_defunct:\n            status = ' (defunct)'\n        elif self.is_closed:\n            status = ' (closed)'\n        return '<%s(%r) %s%s>' % (self.__class__.__name__, id(self), self.endpoint, status)\n    __repr__ = __str__\n\nclass ResponseWaiter(object):\n\n    def __init__(self, connection, num_responses, fail_on_error):\n        self.connection = connection\n        self.pending = num_responses\n        self.fail_on_error = fail_on_error\n        self.error = None\n        self.responses = [None] * num_responses\n        self.event = Event()\n\n    def got_response(self, response, index):\n        with self.connection.lock:\n            self.connection.in_flight -= 1\n        if isinstance(response, Exception):\n            if hasattr(response, 'to_exception'):\n                response = response.to_exception()\n            if self.fail_on_error:\n                self.error = response\n                self.event.set()\n            else:\n                self.responses[index] = (False, response)\n        elif not self.fail_on_error:\n            self.responses[index] = (True, response)\n        else:\n            self.responses[index] = response\n        self.pending -= 1\n        if not self.pending:\n            self.event.set()\n\n    def deliver(self, timeout=None):\n        \"\"\"\n        If fail_on_error was set to False, a list of (success, response)\n        tuples will be returned.  If success is False, response will be\n        an Exception.  Otherwise, response will be the normal query response.\n\n        If fail_on_error was left as True and one of the requests\n        failed, the corresponding Exception will be raised. Otherwise,\n        the normal response will be returned.\n        \"\"\"\n        self.event.wait(timeout)\n        if self.error:\n            raise self.error\n        elif not self.event.is_set():\n            raise OperationTimedOut()\n        else:\n            return self.responses\n\nclass HeartbeatFuture(object):\n\n    def __init__(self, connection, owner):\n        self._exception = None\n        self._event = Event()\n        self.connection = connection\n        self.owner = owner\n        log.debug('Sending options message heartbeat on idle connection (%s) %s', id(connection), connection.endpoint)\n        with connection.lock:\n            if connection.in_flight < connection.max_request_id:\n                connection.in_flight += 1\n                connection.send_msg(OptionsMessage(), connection.get_request_id(), self._options_callback)\n            else:\n                self._exception = Exception(\"Failed to send heartbeat because connection 'in_flight' exceeds threshold\")\n                self._event.set()\n\n    def wait(self, timeout):\n        self._event.wait(timeout)\n        if self._event.is_set():\n            if self._exception:\n                raise self._exception\n        else:\n            raise OperationTimedOut('Connection heartbeat timeout after %s seconds' % (timeout,), self.connection.endpoint)\n\n    def _options_callback(self, response):\n        if isinstance(response, SupportedMessage):\n            log.debug('Received options response on connection (%s) from %s', id(self.connection), self.connection.endpoint)\n        elif isinstance(response, ConnectionException):\n            self._exception = response\n        else:\n            self._exception = ConnectionException('Received unexpected response to OptionsMessage: %s' % (response,))\n        self._event.set()\n\nclass ConnectionHeartbeat(Thread):\n\n    def __init__(self, interval_sec, get_connection_holders, timeout):\n        Thread.__init__(self, name='Connection heartbeat')\n        self._interval = interval_sec\n        self._timeout = timeout\n        self._get_connection_holders = get_connection_holders\n        self._shutdown_event = Event()\n        self.daemon = True\n        self.start()\n\n    class ShutdownException(Exception):\n        pass\n\n    def run(self):\n        self._shutdown_event.wait(self._interval)\n        while not self._shutdown_event.is_set():\n            start_time = time.time()\n            futures = []\n            failed_connections = []\n            try:\n                for connections, owner in [(o.get_connections(), o) for o in self._get_connection_holders()]:\n                    for connection in connections:\n                        self._raise_if_stopped()\n                        if not (connection.is_defunct or connection.is_closed):\n                            if connection.is_idle:\n                                try:\n                                    futures.append(HeartbeatFuture(connection, owner))\n                                except Exception as e:\n                                    log.warning('Failed sending heartbeat message on connection (%s) to %s', id(connection), connection.endpoint)\n                                    failed_connections.append((connection, owner, e))\n                            else:\n                                connection.reset_idle()\n                        else:\n                            log.debug('Cannot send heartbeat message on connection (%s) to %s', id(connection), connection.endpoint)\n                            owner.return_connection(connection)\n                    self._raise_if_stopped()\n                timeout = self._timeout\n                start_time = time.time()\n                for f in futures:\n                    self._raise_if_stopped()\n                    connection = f.connection\n                    try:\n                        f.wait(timeout)\n                        with connection.lock:\n                            connection.in_flight -= 1\n                        connection.reset_idle()\n                    except Exception as e:\n                        log.warning('Heartbeat failed for connection (%s) to %s', id(connection), connection.endpoint)\n                        failed_connections.append((f.connection, f.owner, e))\n                    timeout = self._timeout - (time.time() - start_time)\n                for connection, owner, exc in failed_connections:\n                    self._raise_if_stopped()\n                    if not connection.is_control_connection:\n                        owner.shutdown_on_error = True\n                    connection.defunct(exc)\n                    owner.return_connection(connection)\n            except self.ShutdownException:\n                pass\n            except Exception:\n                log.error('Failed connection heartbeat', exc_info=True)\n            elapsed = time.time() - start_time\n            self._shutdown_event.wait(max(self._interval - elapsed, 0.01))\n\n    def stop(self):\n        self._shutdown_event.set()\n        self.join()\n\n    def _raise_if_stopped(self):\n        if self._shutdown_event.is_set():\n            raise self.ShutdownException()\n\nclass Timer(object):\n    canceled = False\n\n    def __init__(self, timeout, callback):\n        self.end = time.time() + timeout\n        self.callback = callback\n\n    def __lt__(self, other):\n        return self.end < other.end\n\n    def cancel(self):\n        self.canceled = True\n\n    def finish(self, time_now):\n        if self.canceled:\n            return True\n        if time_now >= self.end:\n            self.callback()\n            return True\n        return False\n\nclass TimerManager(object):\n\n    def __init__(self):\n        self._queue = []\n        self._new_timers = []\n\n    def add_timer(self, timer):\n        \"\"\"\n        called from client thread with a Timer object\n        \"\"\"\n        self._new_timers.append((timer.end, timer))\n\n    def service_timeouts(self):\n        \"\"\"\n        run callbacks on all expired timers\n        Called from the event thread\n        :return: next end time, or None\n        \"\"\"\n        queue = self._queue\n        if self._new_timers:\n            new_timers = self._new_timers\n            while new_timers:\n                heappush(queue, new_timers.pop())\n        if queue:\n            now = time.time()\n            while queue:\n                try:\n                    timer = queue[0][1]\n                    if timer.finish(now):\n                        heappop(queue)\n                    else:\n                        return timer.end\n                except Exception:\n                    log.exception('Exception while servicing timeout callback: ')\n\n    @property\n    def next_timeout(self):\n        try:\n            return self._queue[0][0]\n        except IndexError:\n            pass",
    "cassandra/policies.py": "from collections import namedtuple\nfrom functools import lru_cache\nfrom itertools import islice, cycle, groupby, repeat\nimport logging\nfrom random import randint, shuffle\nfrom threading import Lock\nimport socket\nimport warnings\nlog = logging.getLogger(__name__)\nfrom cassandra import WriteType as WT\nWriteType = WT\nfrom cassandra import ConsistencyLevel, OperationTimedOut\n\nclass HostDistance(object):\n    \"\"\"\n    A measure of how \"distant\" a node is from the client, which\n    may influence how the load balancer distributes requests\n    and how many connections are opened to the node.\n    \"\"\"\n    IGNORED = -1\n    '\\n    A node with this distance should never be queried or have\\n    connections opened to it.\\n    '\n    LOCAL = 0\n    '\\n    Nodes with ``LOCAL`` distance will be preferred for operations\\n    under some load balancing policies (such as :class:`.DCAwareRoundRobinPolicy`)\\n    and will have a greater number of connections opened against\\n    them by default.\\n\\n    This distance is typically used for nodes within the same\\n    datacenter as the client.\\n    '\n    REMOTE = 1\n    '\\n    Nodes with ``REMOTE`` distance will be treated as a last resort\\n    by some load balancing policies (such as :class:`.DCAwareRoundRobinPolicy`)\\n    and will have a smaller number of connections opened against\\n    them by default.\\n\\n    This distance is typically used for nodes outside of the\\n    datacenter that the client is running in.\\n    '\n\nclass HostStateListener(object):\n\n    def on_up(self, host):\n        \"\"\" Called when a node is marked up. \"\"\"\n        raise NotImplementedError()\n\n    def on_down(self, host):\n        \"\"\" Called when a node is marked down. \"\"\"\n        raise NotImplementedError()\n\n    def on_add(self, host):\n        \"\"\"\n        Called when a node is added to the cluster.  The newly added node\n        should be considered up.\n        \"\"\"\n        raise NotImplementedError()\n\n    def on_remove(self, host):\n        \"\"\" Called when a node is removed from the cluster. \"\"\"\n        raise NotImplementedError()\n\nclass LoadBalancingPolicy(HostStateListener):\n    \"\"\"\n    Load balancing policies are used to decide how to distribute\n    requests among all possible coordinator nodes in the cluster.\n\n    In particular, they may focus on querying \"near\" nodes (those\n    in a local datacenter) or on querying nodes who happen to\n    be replicas for the requested data.\n\n    You may also use subclasses of :class:`.LoadBalancingPolicy` for\n    custom behavior.\n    \"\"\"\n    _hosts_lock = None\n\n    def __init__(self):\n        self._hosts_lock = Lock()\n\n    def distance(self, host):\n        \"\"\"\n        Returns a measure of how remote a :class:`~.pool.Host` is in\n        terms of the :class:`.HostDistance` enums.\n        \"\"\"\n        raise NotImplementedError()\n\n    def populate(self, cluster, hosts):\n        \"\"\"\n        This method is called to initialize the load balancing\n        policy with a set of :class:`.Host` instances before its\n        first use.  The `cluster` parameter is an instance of\n        :class:`.Cluster`.\n        \"\"\"\n        raise NotImplementedError()\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        \"\"\"\n        Given a :class:`~.query.Statement` instance, return a iterable\n        of :class:`.Host` instances which should be queried in that\n        order.  A generator may work well for custom implementations\n        of this method.\n\n        Note that the `query` argument may be :const:`None` when preparing\n        statements.\n\n        `working_keyspace` should be the string name of the current keyspace,\n        as set through :meth:`.Session.set_keyspace()` or with a ``USE``\n        statement.\n        \"\"\"\n        raise NotImplementedError()\n\n    def check_supported(self):\n        \"\"\"\n        This will be called after the cluster Metadata has been initialized.\n        If the load balancing policy implementation cannot be supported for\n        some reason (such as a missing C extension), this is the point at\n        which it should raise an exception.\n        \"\"\"\n        pass\n\nclass RoundRobinPolicy(LoadBalancingPolicy):\n    \"\"\"\n    A subclass of :class:`.LoadBalancingPolicy` which evenly\n    distributes queries across all nodes in the cluster,\n    regardless of what datacenter the nodes may be in.\n    \"\"\"\n    _live_hosts = frozenset(())\n    _position = 0\n\n    def populate(self, cluster, hosts):\n        self._live_hosts = frozenset(hosts)\n        if len(hosts) > 1:\n            self._position = randint(0, len(hosts) - 1)\n\n    def distance(self, host):\n        return HostDistance.LOCAL\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        pos = self._position\n        self._position += 1\n        hosts = self._live_hosts\n        length = len(hosts)\n        if length:\n            pos %= length\n            return islice(cycle(hosts), pos, pos + length)\n        else:\n            return []\n\n    def on_up(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.union((host,))\n\n    def on_down(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.difference((host,))\n\n    def on_add(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.union((host,))\n\n    def on_remove(self, host):\n        with self._hosts_lock:\n            self._live_hosts = self._live_hosts.difference((host,))\n\nclass DCAwareRoundRobinPolicy(LoadBalancingPolicy):\n    \"\"\"\n    Similar to :class:`.RoundRobinPolicy`, but prefers hosts\n    in the local datacenter and only uses nodes in remote\n    datacenters as a last resort.\n    \"\"\"\n    local_dc = None\n    used_hosts_per_remote_dc = 0\n\n    def __init__(self, local_dc='', used_hosts_per_remote_dc=0):\n        \"\"\"\n        The `local_dc` parameter should be the name of the datacenter\n        (such as is reported by ``nodetool ring``) that should\n        be considered local. If not specified, the driver will choose\n        a local_dc based on the first host among :attr:`.Cluster.contact_points`\n        having a valid DC. If relying on this mechanism, all specified\n        contact points should be nodes in a single, local DC.\n\n        `used_hosts_per_remote_dc` controls how many nodes in\n        each remote datacenter will have connections opened\n        against them. In other words, `used_hosts_per_remote_dc` hosts\n        will be considered :attr:`~.HostDistance.REMOTE` and the\n        rest will be considered :attr:`~.HostDistance.IGNORED`.\n        By default, all remote hosts are ignored.\n        \"\"\"\n        self.local_dc = local_dc\n        self.used_hosts_per_remote_dc = used_hosts_per_remote_dc\n        self._dc_live_hosts = {}\n        self._position = 0\n        self._endpoints = []\n        LoadBalancingPolicy.__init__(self)\n\n    def _dc(self, host):\n        return host.datacenter or self.local_dc\n\n    def populate(self, cluster, hosts):\n        for dc, dc_hosts in groupby(hosts, lambda h: self._dc(h)):\n            self._dc_live_hosts[dc] = tuple(set(dc_hosts))\n        if not self.local_dc:\n            self._endpoints = [endpoint for endpoint in cluster.endpoints_resolved]\n        self._position = randint(0, len(hosts) - 1) if hosts else 0\n\n    def distance(self, host):\n        dc = self._dc(host)\n        if dc == self.local_dc:\n            return HostDistance.LOCAL\n        if not self.used_hosts_per_remote_dc:\n            return HostDistance.IGNORED\n        else:\n            dc_hosts = self._dc_live_hosts.get(dc)\n            if not dc_hosts:\n                return HostDistance.IGNORED\n            if host in list(dc_hosts)[:self.used_hosts_per_remote_dc]:\n                return HostDistance.REMOTE\n            else:\n                return HostDistance.IGNORED\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        pos = self._position\n        self._position += 1\n        local_live = self._dc_live_hosts.get(self.local_dc, ())\n        pos = pos % len(local_live) if local_live else 0\n        for host in islice(cycle(local_live), pos, pos + len(local_live)):\n            yield host\n        other_dcs = [dc for dc in self._dc_live_hosts.copy().keys() if dc != self.local_dc]\n        for dc in other_dcs:\n            remote_live = self._dc_live_hosts.get(dc, ())\n            for host in remote_live[:self.used_hosts_per_remote_dc]:\n                yield host\n\n    def on_up(self, host):\n        if not self.local_dc and host.datacenter:\n            if host.endpoint in self._endpoints:\n                self.local_dc = host.datacenter\n                log.info(\"Using datacenter '%s' for DCAwareRoundRobinPolicy (via host '%s'); if incorrect, please specify a local_dc to the constructor, or limit contact points to local cluster nodes\" % (self.local_dc, host.endpoint))\n                del self._endpoints\n        dc = self._dc(host)\n        with self._hosts_lock:\n            current_hosts = self._dc_live_hosts.get(dc, ())\n            if host not in current_hosts:\n                self._dc_live_hosts[dc] = current_hosts + (host,)\n\n    def on_down(self, host):\n        dc = self._dc(host)\n        with self._hosts_lock:\n            current_hosts = self._dc_live_hosts.get(dc, ())\n            if host in current_hosts:\n                hosts = tuple((h for h in current_hosts if h != host))\n                if hosts:\n                    self._dc_live_hosts[dc] = hosts\n                else:\n                    del self._dc_live_hosts[dc]\n\n    def on_add(self, host):\n        self.on_up(host)\n\n    def on_remove(self, host):\n        self.on_down(host)\n\nclass TokenAwarePolicy(LoadBalancingPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` wrapper that adds token awareness to\n    a child policy.\n\n    This alters the child policy's behavior so that it first attempts to\n    send queries to :attr:`~.HostDistance.LOCAL` replicas (as determined\n    by the child policy) based on the :class:`.Statement`'s\n    :attr:`~.Statement.routing_key`. If :attr:`.shuffle_replicas` is\n    truthy, these replicas will be yielded in a random order. Once those\n    hosts are exhausted, the remaining hosts in the child policy's query\n    plan will be used in the order provided by the child policy.\n\n    If no :attr:`~.Statement.routing_key` is set on the query, the child\n    policy's query plan will be used as is.\n    \"\"\"\n    _child_policy = None\n    _cluster_metadata = None\n    shuffle_replicas = False\n    '\\n    Yield local replicas in a random order.\\n    '\n\n    def __init__(self, child_policy, shuffle_replicas=False):\n        self._child_policy = child_policy\n        self.shuffle_replicas = shuffle_replicas\n\n    def populate(self, cluster, hosts):\n        self._cluster_metadata = cluster.metadata\n        self._child_policy.populate(cluster, hosts)\n\n    def check_supported(self):\n        if not self._cluster_metadata.can_support_partitioner():\n            raise RuntimeError('%s cannot be used with the cluster partitioner (%s) because the relevant C extension for this driver was not compiled. See the installation instructions for details on building and installing the C extensions.' % (self.__class__.__name__, self._cluster_metadata.partitioner))\n\n    def distance(self, *args, **kwargs):\n        return self._child_policy.distance(*args, **kwargs)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        if query and query.keyspace:\n            keyspace = query.keyspace\n        else:\n            keyspace = working_keyspace\n        child = self._child_policy\n        if query is None:\n            for host in child.make_query_plan(keyspace, query):\n                yield host\n        else:\n            routing_key = query.routing_key\n            if routing_key is None or keyspace is None:\n                for host in child.make_query_plan(keyspace, query):\n                    yield host\n            else:\n                replicas = self._cluster_metadata.get_replicas(keyspace, routing_key)\n                if self.shuffle_replicas:\n                    shuffle(replicas)\n                for replica in replicas:\n                    if replica.is_up and child.distance(replica) == HostDistance.LOCAL:\n                        yield replica\n                for host in child.make_query_plan(keyspace, query):\n                    if host not in replicas or child.distance(host) == HostDistance.REMOTE:\n                        yield host\n\n    def on_up(self, *args, **kwargs):\n        return self._child_policy.on_up(*args, **kwargs)\n\n    def on_down(self, *args, **kwargs):\n        return self._child_policy.on_down(*args, **kwargs)\n\n    def on_add(self, *args, **kwargs):\n        return self._child_policy.on_add(*args, **kwargs)\n\n    def on_remove(self, *args, **kwargs):\n        return self._child_policy.on_remove(*args, **kwargs)\n\nclass WhiteListRoundRobinPolicy(RoundRobinPolicy):\n    \"\"\"\n    A subclass of :class:`.RoundRobinPolicy` which evenly\n    distributes queries across all nodes in the cluster,\n    regardless of what datacenter the nodes may be in, but\n    only if that node exists in the list of allowed nodes\n\n    This policy is addresses the issue described in\n    https://datastax-oss.atlassian.net/browse/JAVA-145\n    Where connection errors occur when connection\n    attempts are made to private IP addresses remotely\n    \"\"\"\n\n    def __init__(self, hosts):\n        \"\"\"\n        The `hosts` parameter should be a sequence of hosts to permit\n        connections to.\n        \"\"\"\n        self._allowed_hosts = tuple(hosts)\n        self._allowed_hosts_resolved = [endpoint[4][0] for a in self._allowed_hosts for endpoint in socket.getaddrinfo(a, None, socket.AF_UNSPEC, socket.SOCK_STREAM)]\n        RoundRobinPolicy.__init__(self)\n\n    def populate(self, cluster, hosts):\n        self._live_hosts = frozenset((h for h in hosts if h.address in self._allowed_hosts_resolved))\n        if len(hosts) <= 1:\n            self._position = 0\n        else:\n            self._position = randint(0, len(hosts) - 1)\n\n    def distance(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            return HostDistance.LOCAL\n        else:\n            return HostDistance.IGNORED\n\n    def on_up(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            RoundRobinPolicy.on_up(self, host)\n\n    def on_add(self, host):\n        if host.address in self._allowed_hosts_resolved:\n            RoundRobinPolicy.on_add(self, host)\n\nclass HostFilterPolicy(LoadBalancingPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` subclass configured with a child policy,\n    and a single-argument predicate. This policy defers to the child policy for\n    hosts where ``predicate(host)`` is truthy. Hosts for which\n    ``predicate(host)`` is falsy will be considered :attr:`.IGNORED`, and will\n    not be used in a query plan.\n\n    This can be used in the cases where you need a whitelist or blacklist\n    policy, e.g. to prepare for decommissioning nodes or for testing:\n\n    .. code-block:: python\n\n        def address_is_ignored(host):\n            return host.address in [ignored_address0, ignored_address1]\n\n        blacklist_filter_policy = HostFilterPolicy(\n            child_policy=RoundRobinPolicy(),\n            predicate=address_is_ignored\n        )\n\n        cluster = Cluster(\n            primary_host,\n            load_balancing_policy=blacklist_filter_policy,\n        )\n\n    See the note in the :meth:`.make_query_plan` documentation for a caveat on\n    how wrapping ordering polices (e.g. :class:`.RoundRobinPolicy`) may break\n    desirable properties of the wrapped policy.\n\n    Please note that whitelist and blacklist policies are not recommended for\n    general, day-to-day use. You probably want something like\n    :class:`.DCAwareRoundRobinPolicy`, which prefers a local DC but has\n    fallbacks, over a brute-force method like whitelisting or blacklisting.\n    \"\"\"\n\n    def __init__(self, child_policy, predicate):\n        \"\"\"\n        :param child_policy: an instantiated :class:`.LoadBalancingPolicy`\n                             that this one will defer to.\n        :param predicate: a one-parameter function that takes a :class:`.Host`.\n                          If it returns a falsy value, the :class:`.Host` will\n                          be :attr:`.IGNORED` and not returned in query plans.\n        \"\"\"\n        super(HostFilterPolicy, self).__init__()\n        self._child_policy = child_policy\n        self._predicate = predicate\n\n    def on_up(self, host, *args, **kwargs):\n        return self._child_policy.on_up(host, *args, **kwargs)\n\n    def on_down(self, host, *args, **kwargs):\n        return self._child_policy.on_down(host, *args, **kwargs)\n\n    def on_add(self, host, *args, **kwargs):\n        return self._child_policy.on_add(host, *args, **kwargs)\n\n    def on_remove(self, host, *args, **kwargs):\n        return self._child_policy.on_remove(host, *args, **kwargs)\n\n    @property\n    def predicate(self):\n        \"\"\"\n        A predicate, set on object initialization, that takes a :class:`.Host`\n        and returns a value. If the value is falsy, the :class:`.Host` is\n        :class:`~HostDistance.IGNORED`. If the value is truthy,\n        :class:`.HostFilterPolicy` defers to the child policy to determine the\n        host's distance.\n\n        This is a read-only value set in ``__init__``, implemented as a\n        ``property``.\n        \"\"\"\n        return self._predicate\n\n    def distance(self, host):\n        \"\"\"\n        Checks if ``predicate(host)``, then returns\n        :attr:`~HostDistance.IGNORED` if falsy, and defers to the child policy\n        otherwise.\n        \"\"\"\n        if self.predicate(host):\n            return self._child_policy.distance(host)\n        else:\n            return HostDistance.IGNORED\n\n    def populate(self, cluster, hosts):\n        self._child_policy.populate(cluster=cluster, hosts=hosts)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        \"\"\"\n        Defers to the child policy's\n        :meth:`.LoadBalancingPolicy.make_query_plan` and filters the results.\n\n        Note that this filtering may break desirable properties of the wrapped\n        policy in some cases. For instance, imagine if you configure this\n        policy to filter out ``host2``, and to wrap a round-robin policy that\n        rotates through three hosts in the order ``host1, host2, host3``,\n        ``host2, host3, host1``, ``host3, host1, host2``, repeating. This\n        policy will yield ``host1, host3``, ``host3, host1``, ``host3, host1``,\n        disproportionately favoring ``host3``.\n        \"\"\"\n        child_qp = self._child_policy.make_query_plan(working_keyspace=working_keyspace, query=query)\n        for host in child_qp:\n            if self.predicate(host):\n                yield host\n\n    def check_supported(self):\n        return self._child_policy.check_supported()\n\nclass ConvictionPolicy(object):\n    \"\"\"\n    A policy which decides when hosts should be considered down\n    based on the types of failures and the number of failures.\n\n    If custom behavior is needed, this class may be subclassed.\n    \"\"\"\n\n    def __init__(self, host):\n        \"\"\"\n        `host` is an instance of :class:`.Host`.\n        \"\"\"\n        self.host = host\n\n    def add_failure(self, connection_exc):\n        \"\"\"\n        Implementations should return :const:`True` if the host should be\n        convicted, :const:`False` otherwise.\n        \"\"\"\n        raise NotImplementedError()\n\n    def reset(self):\n        \"\"\"\n        Implementations should clear out any convictions or state regarding\n        the host.\n        \"\"\"\n        raise NotImplementedError()\n\nclass SimpleConvictionPolicy(ConvictionPolicy):\n    \"\"\"\n    The default implementation of :class:`ConvictionPolicy`,\n    which simply marks a host as down after the first failure\n    of any kind.\n    \"\"\"\n\n    def add_failure(self, connection_exc):\n        return not isinstance(connection_exc, OperationTimedOut)\n\n    def reset(self):\n        pass\n\nclass ReconnectionPolicy(object):\n    \"\"\"\n    This class and its subclasses govern how frequently an attempt is made\n    to reconnect to nodes that are marked as dead.\n\n    If custom behavior is needed, this class may be subclassed.\n    \"\"\"\n\n    def new_schedule(self):\n        \"\"\"\n        This should return a finite or infinite iterable of delays (each as a\n        floating point number of seconds) in-between each failed reconnection\n        attempt.  Note that if the iterable is finite, reconnection attempts\n        will cease once the iterable is exhausted.\n        \"\"\"\n        raise NotImplementedError()\n\nclass ConstantReconnectionPolicy(ReconnectionPolicy):\n    \"\"\"\n    A :class:`.ReconnectionPolicy` subclass which sleeps for a fixed delay\n    in-between each reconnection attempt.\n    \"\"\"\n\n    def __init__(self, delay, max_attempts=64):\n        \"\"\"\n        `delay` should be a floating point number of seconds to wait in-between\n        each attempt.\n\n        `max_attempts` should be a total number of attempts to be made before\n        giving up, or :const:`None` to continue reconnection attempts forever.\n        The default is 64.\n        \"\"\"\n        if delay < 0:\n            raise ValueError('delay must not be negative')\n        if max_attempts is not None and max_attempts < 0:\n            raise ValueError('max_attempts must not be negative')\n        self.delay = delay\n        self.max_attempts = max_attempts\n\n    def new_schedule(self):\n        if self.max_attempts:\n            return repeat(self.delay, self.max_attempts)\n        return repeat(self.delay)\n\nclass ExponentialReconnectionPolicy(ReconnectionPolicy):\n    \"\"\"\n    A :class:`.ReconnectionPolicy` subclass which exponentially increases\n    the length of the delay in-between each reconnection attempt up to\n    a set maximum delay.\n\n    A random amount of jitter (+/- 15%) will be added to the pure exponential\n    delay value to avoid the situations where many reconnection handlers are\n    trying to reconnect at exactly the same time.\n    \"\"\"\n\n    def __init__(self, base_delay, max_delay, max_attempts=64):\n        \"\"\"\n        `base_delay` and `max_delay` should be in floating point units of\n        seconds.\n\n        `max_attempts` should be a total number of attempts to be made before\n        giving up, or :const:`None` to continue reconnection attempts forever.\n        The default is 64.\n        \"\"\"\n        if base_delay < 0 or max_delay < 0:\n            raise ValueError('Delays may not be negative')\n        if max_delay < base_delay:\n            raise ValueError('Max delay must be greater than base delay')\n        if max_attempts is not None and max_attempts < 0:\n            raise ValueError('max_attempts must not be negative')\n        self.base_delay = base_delay\n        self.max_delay = max_delay\n        self.max_attempts = max_attempts\n\n    def new_schedule(self):\n        i, overflowed = (0, False)\n        while self.max_attempts is None or i < self.max_attempts:\n            if overflowed:\n                yield self.max_delay\n            else:\n                try:\n                    yield self._add_jitter(min(self.base_delay * 2 ** i, self.max_delay))\n                except OverflowError:\n                    overflowed = True\n                    yield self.max_delay\n            i += 1\n\n    def _add_jitter(self, value):\n        jitter = randint(85, 115)\n        delay = jitter * value / 100\n        return min(max(self.base_delay, delay), self.max_delay)\n\nclass RetryPolicy(object):\n    \"\"\"\n    A policy that describes whether to retry, rethrow, or ignore coordinator\n    timeout and unavailable failures. These are failures reported from the\n    server side. Timeouts are configured by\n    `settings in cassandra.yaml <https://github.com/apache/cassandra/blob/cassandra-2.1.4/conf/cassandra.yaml#L568-L584>`_.\n    Unavailable failures occur when the coordinator cannot achieve the consistency\n    level for a request. For further information see the method descriptions\n    below.\n\n    To specify a default retry policy, set the\n    :attr:`.Cluster.default_retry_policy` attribute to an instance of this\n    class or one of its subclasses.\n\n    To specify a retry policy per query, set the :attr:`.Statement.retry_policy`\n    attribute to an instance of this class or one of its subclasses.\n\n    If custom behavior is needed for retrying certain operations,\n    this class may be subclassed.\n    \"\"\"\n    RETRY = 0\n    '\\n    This should be returned from the below methods if the operation\\n    should be retried on the same connection.\\n    '\n    RETHROW = 1\n    '\\n    This should be returned from the below methods if the failure\\n    should be propagated and no more retries attempted.\\n    '\n    IGNORE = 2\n    '\\n    This should be returned from the below methods if the failure\\n    should be ignored but no more retries should be attempted.\\n    '\n    RETRY_NEXT_HOST = 3\n    '\\n    This should be returned from the below methods if the operation\\n    should be retried on another connection.\\n    '\n\n    def on_read_timeout(self, query, consistency, required_responses, received_responses, data_retrieved, retry_num):\n        \"\"\"\n        This is called when a read operation times out from the coordinator's\n        perspective (i.e. a replica did not respond to the coordinator in time).\n        It should return a tuple with two items: one of the class enums (such\n        as :attr:`.RETRY`) and a :class:`.ConsistencyLevel` to retry the\n        operation at or :const:`None` to keep the same consistency level.\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        The `required_responses` and `received_responses` parameters describe\n        how many replicas needed to respond to meet the requested consistency\n        level and how many actually did respond before the coordinator timed\n        out the request. `data_retrieved` is a boolean indicating whether\n        any of those responses contained data (as opposed to just a digest).\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, operations will be retried at most once, and only if\n        a sufficient number of replicas responded (with data digests).\n        \"\"\"\n        if retry_num != 0:\n            return (self.RETHROW, None)\n        elif received_responses >= required_responses and (not data_retrieved):\n            return (self.RETRY, consistency)\n        else:\n            return (self.RETHROW, None)\n\n    def on_write_timeout(self, query, consistency, write_type, required_responses, received_responses, retry_num):\n        \"\"\"\n        This is called when a write operation times out from the coordinator's\n        perspective (i.e. a replica did not respond to the coordinator in time).\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `write_type` is one of the :class:`.WriteType` enums describing the\n        type of write operation.\n\n        The `required_responses` and `received_responses` parameters describe\n        how many replicas needed to acknowledge the write to meet the requested\n        consistency level and how many replicas actually did acknowledge the\n        write before the coordinator timed out the request.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, failed write operations will retried at most once, and\n        they will only be retried if the `write_type` was\n        :attr:`~.WriteType.BATCH_LOG`.\n        \"\"\"\n        if retry_num != 0:\n            return (self.RETHROW, None)\n        elif write_type == WriteType.BATCH_LOG:\n            return (self.RETRY, consistency)\n        else:\n            return (self.RETHROW, None)\n\n    def on_unavailable(self, query, consistency, required_replicas, alive_replicas, retry_num):\n        \"\"\"\n        This is called when the coordinator node determines that a read or\n        write operation cannot be successful because the number of live\n        replicas are too low to meet the requested :class:`.ConsistencyLevel`.\n        This means that the read or write operation was never forwarded to\n        any replicas.\n\n        `query` is the :class:`.Statement` that failed.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `required_replicas` is the number of replicas that would have needed to\n        acknowledge the operation to meet the requested consistency level.\n        `alive_replicas` is the number of replicas that the coordinator\n        considered alive at the time of the request.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, if this is the first retry, it triggers a retry on the next\n        host in the query plan with the same consistency level. If this is not the\n        first retry, no retries will be attempted and the error will be re-raised.\n        \"\"\"\n        return (self.RETRY_NEXT_HOST, None) if retry_num == 0 else (self.RETHROW, None)\n\n    def on_request_error(self, query, consistency, error, retry_num):\n        \"\"\"\n        This is called when an unexpected error happens. This can be in the\n        following situations:\n\n        * On a connection error\n        * On server errors: overloaded, isBootstrapping, serverError, etc.\n\n        `query` is the :class:`.Statement` that timed out.\n\n        `consistency` is the :class:`.ConsistencyLevel` that the operation was\n        attempted at.\n\n        `error` the instance of the exception.\n\n        `retry_num` counts how many times the operation has been retried, so\n        the first time this method is called, `retry_num` will be 0.\n\n        By default, it triggers a retry on the next host in the query plan\n        with the same consistency level.\n        \"\"\"\n        return (self.RETRY_NEXT_HOST, None)\n\nclass FallthroughRetryPolicy(RetryPolicy):\n    \"\"\"\n    A retry policy that never retries and always propagates failures to\n    the application.\n    \"\"\"\n\n    def on_read_timeout(self, *args, **kwargs):\n        return (self.RETHROW, None)\n\n    def on_write_timeout(self, *args, **kwargs):\n        return (self.RETHROW, None)\n\n    def on_unavailable(self, *args, **kwargs):\n        return (self.RETHROW, None)\n\n    def on_request_error(self, *args, **kwargs):\n        return (self.RETHROW, None)\n\nclass DowngradingConsistencyRetryPolicy(RetryPolicy):\n    \"\"\"\n    *Deprecated:* This retry policy will be removed in the next major release.\n\n    A retry policy that sometimes retries with a lower consistency level than\n    the one initially requested.\n\n    **BEWARE**: This policy may retry queries using a lower consistency\n    level than the one initially requested. By doing so, it may break\n    consistency guarantees. In other words, if you use this retry policy,\n    there are cases (documented below) where a read at :attr:`~.QUORUM`\n    *may not* see a preceding write at :attr:`~.QUORUM`. Do not use this\n    policy unless you have understood the cases where this can happen and\n    are ok with that. It is also recommended to subclass this class so\n    that queries that required a consistency level downgrade can be\n    recorded (so that repairs can be made later, etc).\n\n    This policy implements the same retries as :class:`.RetryPolicy`,\n    but on top of that, it also retries in the following cases:\n\n    * On a read timeout: if the number of replicas that responded is\n      greater than one but lower than is required by the requested\n      consistency level, the operation is retried at a lower consistency\n      level.\n    * On a write timeout: if the operation is an :attr:`~.UNLOGGED_BATCH`\n      and at least one replica acknowledged the write, the operation is\n      retried at a lower consistency level.  Furthermore, for other\n      write types, if at least one replica acknowledged the write, the\n      timeout is ignored.\n    * On an unavailable exception: if at least one replica is alive, the\n      operation is retried at a lower consistency level.\n\n    The reasoning behind this retry policy is as follows: if, based\n    on the information the Cassandra coordinator node returns, retrying the\n    operation with the initially requested consistency has a chance to\n    succeed, do it. Otherwise, if based on that information we know the\n    initially requested consistency level cannot be achieved currently, then:\n\n    * For writes, ignore the exception (thus silently failing the\n      consistency requirement) if we know the write has been persisted on at\n      least one replica.\n    * For reads, try reading at a lower consistency level (thus silently\n      failing the consistency requirement).\n\n    In other words, this policy implements the idea that if the requested\n    consistency level cannot be achieved, the next best thing for writes is\n    to make sure the data is persisted, and that reading something is better\n    than reading nothing, even if there is a risk of reading stale data.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(DowngradingConsistencyRetryPolicy, self).__init__(*args, **kwargs)\n        warnings.warn('DowngradingConsistencyRetryPolicy is deprecated and will be removed in the next major release.', DeprecationWarning)\n\n    def _pick_consistency(self, num_responses):\n        if num_responses >= 3:\n            return (self.RETRY, ConsistencyLevel.THREE)\n        elif num_responses >= 2:\n            return (self.RETRY, ConsistencyLevel.TWO)\n        elif num_responses >= 1:\n            return (self.RETRY, ConsistencyLevel.ONE)\n        else:\n            return (self.RETHROW, None)\n\n    def on_read_timeout(self, query, consistency, required_responses, received_responses, data_retrieved, retry_num):\n        if retry_num != 0:\n            return (self.RETHROW, None)\n        elif ConsistencyLevel.is_serial(consistency):\n            return (self.RETHROW, None)\n        elif received_responses < required_responses:\n            return self._pick_consistency(received_responses)\n        elif not data_retrieved:\n            return (self.RETRY, consistency)\n        else:\n            return (self.RETHROW, None)\n\n    def on_write_timeout(self, query, consistency, write_type, required_responses, received_responses, retry_num):\n        if retry_num != 0:\n            return (self.RETHROW, None)\n        if write_type in (WriteType.SIMPLE, WriteType.BATCH, WriteType.COUNTER):\n            if received_responses > 0:\n                return (self.IGNORE, None)\n            else:\n                return (self.RETHROW, None)\n        elif write_type == WriteType.UNLOGGED_BATCH:\n            return self._pick_consistency(received_responses)\n        elif write_type == WriteType.BATCH_LOG:\n            return (self.RETRY, consistency)\n        return (self.RETHROW, None)\n\n    def on_unavailable(self, query, consistency, required_replicas, alive_replicas, retry_num):\n        if retry_num != 0:\n            return (self.RETHROW, None)\n        elif ConsistencyLevel.is_serial(consistency):\n            return (self.RETRY_NEXT_HOST, None)\n        else:\n            return self._pick_consistency(alive_replicas)\n\nclass AddressTranslator(object):\n    \"\"\"\n    Interface for translating cluster-defined endpoints.\n\n    The driver discovers nodes using server metadata and topology change events. Normally,\n    the endpoint defined by the server is the right way to connect to a node. In some environments,\n    these addresses may not be reachable, or not preferred (public vs. private IPs in cloud environments,\n    suboptimal routing, etc). This interface allows for translating from server defined endpoints to\n    preferred addresses for driver connections.\n\n    *Note:* :attr:`~Cluster.contact_points` provided while creating the :class:`~.Cluster` instance are not\n    translated using this mechanism -- only addresses received from Cassandra nodes are.\n    \"\"\"\n\n    def translate(self, addr):\n        \"\"\"\n        Accepts the node ip address, and returns a translated address to be used connecting to this node.\n        \"\"\"\n        raise NotImplementedError()\n\nclass IdentityTranslator(AddressTranslator):\n    \"\"\"\n    Returns the endpoint with no translation\n    \"\"\"\n\n    def translate(self, addr):\n        return addr\n\nclass EC2MultiRegionTranslator(AddressTranslator):\n    \"\"\"\n    Resolves private ips of the hosts in the same datacenter as the client, and public ips of hosts in other datacenters.\n    \"\"\"\n\n    def translate(self, addr):\n        \"\"\"\n        Reverse DNS the public broadcast_address, then lookup that hostname to get the AWS-resolved IP, which\n        will point to the private IP address within the same datacenter.\n        \"\"\"\n        family = socket.getaddrinfo(addr, 0, socket.AF_UNSPEC, socket.SOCK_STREAM)[0][0]\n        host = socket.getfqdn(addr)\n        for a in socket.getaddrinfo(host, 0, family, socket.SOCK_STREAM):\n            try:\n                return a[4][0]\n            except Exception:\n                pass\n        return addr\n\nclass SpeculativeExecutionPolicy(object):\n    \"\"\"\n    Interface for specifying speculative execution plans\n    \"\"\"\n\n    def new_plan(self, keyspace, statement):\n        \"\"\"\n        Returns\n\n        :param keyspace:\n        :param statement:\n        :return:\n        \"\"\"\n        raise NotImplementedError()\n\nclass SpeculativeExecutionPlan(object):\n\n    def next_execution(self, host):\n        raise NotImplementedError()\n\nclass NoSpeculativeExecutionPlan(SpeculativeExecutionPlan):\n\n    def next_execution(self, host):\n        return -1\n\nclass NoSpeculativeExecutionPolicy(SpeculativeExecutionPolicy):\n\n    def new_plan(self, keyspace, statement):\n        return NoSpeculativeExecutionPlan()\n\nclass ConstantSpeculativeExecutionPolicy(SpeculativeExecutionPolicy):\n    \"\"\"\n    A speculative execution policy that sends a new query every X seconds (**delay**) for a maximum of Y attempts (**max_attempts**).\n    \"\"\"\n\n    def __init__(self, delay, max_attempts):\n        self.delay = delay\n        self.max_attempts = max_attempts\n\n    class ConstantSpeculativeExecutionPlan(SpeculativeExecutionPlan):\n\n        def __init__(self, delay, max_attempts):\n            self.delay = delay\n            self.remaining = max_attempts\n\n        def next_execution(self, host):\n            if self.remaining > 0:\n                self.remaining -= 1\n                return self.delay\n            else:\n                return -1\n\n    def new_plan(self, keyspace, statement):\n        return self.ConstantSpeculativeExecutionPlan(self.delay, self.max_attempts)\n\nclass WrapperPolicy(LoadBalancingPolicy):\n\n    def __init__(self, child_policy):\n        self._child_policy = child_policy\n\n    def distance(self, *args, **kwargs):\n        return self._child_policy.distance(*args, **kwargs)\n\n    def populate(self, cluster, hosts):\n        self._child_policy.populate(cluster, hosts)\n\n    def on_up(self, *args, **kwargs):\n        return self._child_policy.on_up(*args, **kwargs)\n\n    def on_down(self, *args, **kwargs):\n        return self._child_policy.on_down(*args, **kwargs)\n\n    def on_add(self, *args, **kwargs):\n        return self._child_policy.on_add(*args, **kwargs)\n\n    def on_remove(self, *args, **kwargs):\n        return self._child_policy.on_remove(*args, **kwargs)\n\nclass DefaultLoadBalancingPolicy(WrapperPolicy):\n    \"\"\"\n    A :class:`.LoadBalancingPolicy` wrapper that adds the ability to target a specific host first.\n\n    If no host is set on the query, the child policy's query plan will be used as is.\n    \"\"\"\n    _cluster_metadata = None\n\n    def populate(self, cluster, hosts):\n        self._cluster_metadata = cluster.metadata\n        self._child_policy.populate(cluster, hosts)\n\n    def make_query_plan(self, working_keyspace=None, query=None):\n        if query and query.keyspace:\n            keyspace = query.keyspace\n        else:\n            keyspace = working_keyspace\n        addr = getattr(query, 'target_host', None) if query else None\n        target_host = self._cluster_metadata.get_host(addr)\n        child = self._child_policy\n        if target_host and target_host.is_up:\n            yield target_host\n            for h in child.make_query_plan(keyspace, query):\n                if h != target_host:\n                    yield h\n        else:\n            for h in child.make_query_plan(keyspace, query):\n                yield h\n\nclass DSELoadBalancingPolicy(DefaultLoadBalancingPolicy):\n    \"\"\"\n    *Deprecated:* This will be removed in the next major release,\n    consider using :class:`.DefaultLoadBalancingPolicy`.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(DSELoadBalancingPolicy, self).__init__(*args, **kwargs)\n        warnings.warn('DSELoadBalancingPolicy will be removed in 4.0. Consider using DefaultLoadBalancingPolicy.', DeprecationWarning)\n\nclass NeverRetryPolicy(RetryPolicy):\n\n    def _rethrow(self, *args, **kwargs):\n        return (self.RETHROW, None)\n    on_read_timeout = _rethrow\n    on_write_timeout = _rethrow\n    on_unavailable = _rethrow\nColDesc = namedtuple('ColDesc', ['ks', 'table', 'col'])\n\nclass ColumnEncryptionPolicy(object):\n    \"\"\"\n    A policy enabling (mostly) transparent encryption and decryption of data before it is\n    sent to the cluster.\n\n    Key materials and other configurations are specified on a per-column basis.  This policy can\n    then be used by driver structures which are aware of the underlying columns involved in their\n    work.  In practice this includes the following cases:\n\n    * Prepared statements - data for columns specified by the cluster's policy will be transparently\n      encrypted before they are sent\n    * Rows returned from any query - data for columns specified by the cluster's policy will be\n      transparently decrypted before they are returned to the user\n\n    To enable this functionality, create an instance of this class (or more likely a subclass)\n    before creating a cluster.  This policy should then be configured and supplied to the Cluster\n    at creation time via the :attr:`.Cluster.column_encryption_policy` attribute.\n    \"\"\"\n\n    def encrypt(self, coldesc, obj_bytes):\n        \"\"\"\n        Encrypt the specified bytes using the cryptography materials for the specified column.\n        Largely used internally, although this could also be used to encrypt values supplied\n        to non-prepared statements in a way that is consistent with this policy.\n        \"\"\"\n        raise NotImplementedError()\n\n    def decrypt(self, coldesc, encrypted_bytes):\n        \"\"\"\n        Decrypt the specified (encrypted) bytes using the cryptography materials for the\n        specified column.  Used internally; could be used externally as well but there's\n        not currently an obvious use case.\n        \"\"\"\n        raise NotImplementedError()\n\n    def add_column(self, coldesc, key):\n        \"\"\"\n        Provide cryptography materials to be used when encrypted and/or decrypting data\n        for the specified column.\n        \"\"\"\n        raise NotImplementedError()\n\n    def contains_column(self, coldesc):\n        \"\"\"\n        Predicate to determine if a specific column is supported by this policy.\n        Currently only used internally.\n        \"\"\"\n        raise NotImplementedError()\n\n    def encode_and_encrypt(self, coldesc, obj):\n        \"\"\"\n        Helper function to enable use of this policy on simple (i.e. non-prepared)\n        statements.\n        \"\"\"\n        raise NotImplementedError()",
    "cassandra/__init__.py": "import logging\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\nlogging.getLogger('cassandra').addHandler(NullHandler())\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n    ANY = 0\n    '\\n    Only requires that one replica receives the write *or* the coordinator\\n    stores a hint to replay later. Valid only for writes.\\n    '\n    ONE = 1\n    '\\n    Only one replica needs to respond to consider the operation a success\\n    '\n    TWO = 2\n    '\\n    Two replicas must respond to consider the operation a success\\n    '\n    THREE = 3\n    '\\n    Three replicas must respond to consider the operation a success\\n    '\n    QUORUM = 4\n    '\\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\\n    '\n    ALL = 5\n    '\\n    All replicas must respond to consider the operation a success\\n    '\n    LOCAL_QUORUM = 6\n    '\\n    Requires a quorum of replicas in the local datacenter\\n    '\n    EACH_QUORUM = 7\n    '\\n    Requires a quorum of replicas in each datacenter\\n    '\n    SERIAL = 8\n    \"\\n    For conditional inserts/updates that utilize Cassandra's lightweight\\n    transactions, this requires consensus among all replicas for the\\n    modified data.\\n    \"\n    LOCAL_SERIAL = 9\n    '\\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\\n    among replicas in the local datacenter.\\n    '\n    LOCAL_ONE = 10\n    '\\n    Sends a request only to replicas in the local datacenter and waits for\\n    one response.\\n    '\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\nConsistencyLevel.value_to_name = {ConsistencyLevel.ANY: 'ANY', ConsistencyLevel.ONE: 'ONE', ConsistencyLevel.TWO: 'TWO', ConsistencyLevel.THREE: 'THREE', ConsistencyLevel.QUORUM: 'QUORUM', ConsistencyLevel.ALL: 'ALL', ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM', ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM', ConsistencyLevel.SERIAL: 'SERIAL', ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL', ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'}\nConsistencyLevel.name_to_value = {'ANY': ConsistencyLevel.ANY, 'ONE': ConsistencyLevel.ONE, 'TWO': ConsistencyLevel.TWO, 'THREE': ConsistencyLevel.THREE, 'QUORUM': ConsistencyLevel.QUORUM, 'ALL': ConsistencyLevel.ALL, 'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM, 'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM, 'SERIAL': ConsistencyLevel.SERIAL, 'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL, 'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE}\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else 'Not Set'\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    '\\n    v1, supported in Cassandra 1.2-->2.2\\n    '\n    V2 = 2\n    '\\n    v2, supported in Cassandra 2.0-->2.2;\\n    added support for lightweight transactions, batch operations, and automatic query paging.\\n    '\n    V3 = 3\n    '\\n    v3, supported in Cassandra 2.1-->3.x+;\\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\\n    '\n    V4 = 4\n    '\\n    v4, supported in Cassandra 2.2-->3.x+;\\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\\n    '\n    V5 = 5\n    '\\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\\n    '\n    V6 = 6\n    '\\n    v6, in beta from 4.0-beta5\\n    '\n    DSE_V1 = 65\n    '\\n    DSE private protocol v1, supported in DSE 5.1+\\n    '\n    DSE_V2 = 66\n    '\\n    DSE private protocol v2, supported in DSE 6.0+\\n    '\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    '\\n    A tuple of all supported protocol versions\\n    '\n    BETA_VERSIONS = (V6,)\n    '\\n    A tuple of all beta protocol versions\\n    '\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    '\\n    Minimum protocol version supported by this driver.\\n    '\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    '\\n    Maximum protocol version supported by this driver.\\n    '\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next((v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if v not in ProtocolVersion.BETA_VERSIONS and v < previous_version))\n        except StopIteration:\n            version = 0\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n    SIMPLE = 0\n    '\\n    A write to a single partition key. Such writes are guaranteed to be atomic\\n    and isolated.\\n    '\n    BATCH = 1\n    '\\n    A write to multiple partition keys that used the distributed batch log to\\n    ensure atomicity.\\n    '\n    UNLOGGED_BATCH = 2\n    '\\n    A write to multiple partition keys that did not use the distributed batch\\n    log. Atomicity for such writes is not guaranteed.\\n    '\n    COUNTER = 3\n    '\\n    A counter write (for one or multiple partition keys). Such writes should\\n    not be replayed in order to avoid overcount.\\n    '\n    BATCH_LOG = 4\n    '\\n    The initial write to the distributed batch log that Cassandra performs\\n    internally before a BATCH write.\\n    '\n    CAS = 5\n    '\\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\\n    '\n    VIEW = 6\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete MV operations.\\n    '\n    CDC = 7\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete CDC operations.\\n    '\nWriteType.name_to_value = {'SIMPLE': WriteType.SIMPLE, 'BATCH': WriteType.BATCH, 'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH, 'COUNTER': WriteType.COUNTER, 'BATCH_LOG': WriteType.BATCH_LOG, 'CAS': WriteType.CAS, 'VIEW': WriteType.VIEW, 'CDC': WriteType.CDC}\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return '%s(%s)' % (name, ','.join((t for t in argument_types)))\n\n    def __repr__(self):\n        return '%s(%s, %s)' % (self.__class__.__name__, self.name, self.argument_types)\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the function\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the aggregate\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_replicas = None\n    ' The number of replicas that needed to be live to complete the operation '\n    alive_replicas = None\n    ' The number of replicas that were actually alive '\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' + repr({'consistency': consistency_value_to_name(consistency), 'required_replicas': required_replicas, 'alive_replicas': alive_replicas}))\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        if 'write_type' in kwargs:\n            kwargs['write_type'] = WriteType.value_to_name[kwargs['write_type']]\n        info = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses}\n        info.update(kwargs)\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs['write_type'] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n    failures = None\n    '\\n    The number of replicas that sent a failure message\\n    '\n    error_code_map = None\n    '\\n    A map of inet addresses to error codes representing replicas that sent\\n    a failure message.  Only set when `protocol_version` is 5 or higher.\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n        info_dict = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses, 'failures': failures}\n        if error_code_map is not None:\n            formatted_map = dict(((addr, '0x%04x' % err_code) for addr, err_code in error_code_map.items()))\n            info_dict['error_code_map'] = formatted_map\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n    keyspace = None\n    '\\n    Keyspace of the function\\n    '\n    function = None\n    '\\n    Name of the function\\n    '\n    arg_types = None\n    '\\n    List of argument type names of the function\\n    '\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n    keyspace = None\n    '\\n    The name of the keyspace that already exists, or, if an attempt was\\n    made to create a new table, the keyspace that the table is in.\\n    '\n    table = None\n    '\\n    The name of the table that already exists, or, if an attempt was\\n    make to create a keyspace, :const:`None`.\\n    '\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n    errors = None\n    '\\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\\n    '\n    last_host = None\n    '\\n    The last :class:`~.Host` this operation was attempted against.\\n    '\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = 'errors=%s, last_host=%s' % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n    excs = []\n    '\\n    A sequence of child exceptions\\n    '\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += '\\nThe following exceptions were observed: \\n - ' + '\\n - '.join((str(e) for e in excs))\n        Exception.__init__(self, complete_msg)"
  }
}