{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_lock",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/operations/test_lock.py",
  "test_code": "from ncclient.operations.lock import *\nimport unittest\ntry:\n    from unittest.mock import patch  # Python 3.4 and later\nexcept ImportError:\n    from mock import patch\nfrom ncclient import manager\nimport ncclient.manager\nimport ncclient.transport\nfrom ncclient.xml_ import *\nfrom ncclient.operations import RaiseMode\nfrom xml.etree import ElementTree\n\n\nclass TestLock(unittest.TestCase):\n\n    def setUp(self):\n        self.device_handler = manager.make_device_handler({'name': 'junos'})\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_lock_default_param(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = Lock(session, self.device_handler, raise_mode=RaiseMode.ALL)\n        obj.request()\n        node = new_ele(\"lock\")\n        sub_ele(sub_ele(node, \"target\"), \"candidate\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_lock(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = Lock(session, self.device_handler, raise_mode=RaiseMode.ALL)\n        obj.request(target=\"running\")\n        node = new_ele(\"lock\")\n        sub_ele(sub_ele(node, \"target\"), \"running\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_unlock_default_param(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = Unlock(session, self.device_handler, raise_mode=RaiseMode.ALL)\n        obj.request()\n        node = new_ele(\"unlock\")\n        sub_ele(sub_ele(node, \"target\"), \"candidate\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_unlock(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = Unlock(session, self.device_handler, raise_mode=RaiseMode.ALL)\n        obj.request(target=\"running\")\n        node = new_ele(\"unlock\")\n        sub_ele(sub_ele(node, \"target\"), \"running\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_lock_context_enter(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = LockContext(session, self.device_handler, \"candidate\")\n        self.assertEqual(obj.__enter__(), obj)\n        node = new_ele(\"lock\")\n        sub_ele(sub_ele(node, \"target\"), \"candidate\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n\n    @patch('ncclient.transport.SSHSession')\n    @patch('ncclient.operations.RPC._request')\n    def test_lock_context_exit(self, mock_request, mock_session):\n        session = ncclient.transport.SSHSession(self.device_handler)\n        obj = LockContext(session, self.device_handler, \"running\")\n        self.assertFalse(obj.__exit__())\n        node = new_ele(\"unlock\")\n        sub_ele(sub_ele(node, \"target\"), \"running\")\n        xml = ElementTree.tostring(node)\n        call = mock_request.call_args_list[0][0][0]\n        call = ElementTree.tostring(call)\n        self.assertEqual(call, xml)\n",
  "GT_file_code": {
    "ncclient/operations/lock.py": "# Copyright 2h009 Shikhar Bhushan\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Locking-related NETCONF operations\"\n\nfrom ncclient.xml_ import *\n\nfrom ncclient.operations.rpc import RaiseMode, RPC\n\n# TODO: parse session-id from a lock-denied error, and raise a tailored exception?\n\nclass Lock(RPC):\n\n    \"`lock` RPC\"\n\n\n    def request(self, target=\"candidate\"):\n        \"\"\"Allows the client to lock the configuration system of a device.\n\n        *target* is the name of the configuration datastore to lock\n        \"\"\"\n        node = new_ele(\"lock\")\n        sub_ele(sub_ele(node, \"target\"), target)\n        return self._request(node)\n\n\nclass Unlock(RPC):\n\n    \"`unlock` RPC\"\n\n    def request(self, target=\"candidate\"):\n        \"\"\"Release a configuration lock, previously obtained with the lock operation.\n\n        *target* is the name of the configuration datastore to unlock\n        \"\"\"\n        node = new_ele(\"unlock\")\n        sub_ele(sub_ele(node, \"target\"), target)\n        return self._request(node)\n\n\nclass LockContext(object):\n\n    \"\"\"A context manager for the :class:`Lock` / :class:`Unlock` pair of RPC's.\n\n    Any `rpc-error` will be raised as an exception.\n\n    Initialise with (:class:`Session <ncclient.transport.Session>`) instance and lock target.\n    \"\"\"\n\n    def __init__(self, session, device_handler, target):\n        self.session = session\n        self.target = target\n        self.device_handler = device_handler\n\n    def __enter__(self):\n        Lock(self.session, self.device_handler, raise_mode=RaiseMode.ERRORS).request(self.target)\n        return self\n\n    def __exit__(self, *args):\n        Unlock(self.session, self.device_handler, raise_mode=RaiseMode.ERRORS).request(self.target)\n        return False\n",
    "ncclient/xml_.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\n\n\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\n\n# In case issues come up with XML generation/parsing\n# make sure you have the ElementTree v1.2.7+ lib as\n# well as lxml v3.0+\n\nfrom ncclient import NCClientError\n\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\n\nclass XMLError(NCClientError):\n    pass\n\n### Namespace-related\n\n#: Base NETCONF namespace\nBASE_NS_1_0 = \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n#: YANG (RFC 6020/RFC 7950) namespace\nYANG_NS_1_0 = \"urn:ietf:params:xml:ns:yang:1\"\n#: NXOS_1_0\nNXOS_1_0 = \"http://www.cisco.com/nxos:1.0\"\n#: NXOS_IF\nNXOS_IF = \"http://www.cisco.com/nxos:1.0:if_manager\"\n#: Namespace for Tail-f core data model\nTAILF_AAA_1_1 = \"http://tail-f.com/ns/aaa/1.1\"\n#: Namespace for Tail-f execd data model\nTAILF_EXECD_1_1 = \"http://tail-f.com/ns/execd/1.1\"\n#: Namespace for Cisco data model\nCISCO_CPI_1_0 = \"http://www.cisco.com/cpi_10/schema\"\n#: Namespace for Flowmon data model\nFLOWMON_1_0 = \"http://www.liberouter.org/ns/netopeer/flowmon/1.0\"\n#: Namespace for Juniper 9.6R4. Tested with Junos 9.6R4+\nJUNIPER_1_1 = \"http://xml.juniper.net/xnm/1.1/xnm\"\n#: Namespace for Huawei data model\nHUAWEI_NS = \"http://www.huawei.com/netconf/vrp\"\n#: Namespace for Huawei private\nHW_PRIVATE_NS = \"http://www.huawei.com/netconf/capability/base/1.0\"\n#: Namespace for H3C data model\nH3C_DATA_1_0 = \"http://www.h3c.com/netconf/data:1.0\"\n#: Namespace for H3C config model\nH3C_CONFIG_1_0 = \"http://www.h3c.com/netconf/config:1.0\"\n#: Namespace for H3C action model\nH3C_ACTION_1_0 = \"http://www.h3c.com/netconf/action:1.0\"\n#: Namespace for netconf monitoring\nNETCONF_MONITORING_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\"\n#: Namespace for netconf notifications\nNETCONF_NOTIFICATION_NS = \"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n#: Namespace for netconf with-defaults (RFC 6243)\nNETCONF_WITH_DEFAULTS_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\"\n#: Namespace for Alcatel-Lucent SR OS Base r13 YANG models\nALU_CONFIG = \"urn:alcatel-lucent.com:sros:ns:yang:conf-r13\"\n#: Namespace for Nokia SR OS global operations\nSROS_GLOBAL_OPS_NS = \"urn:nokia.com:sros:ns:yang:sr:oper-global\"\n\n\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        # cElementTree uses ElementTree's _namespace_map, so that's ok\n        ElementTree._namespace_map[uri] = prefix\n\nfor (ns, pre) in six.iteritems({\n    BASE_NS_1_0: 'nc',\n    NETCONF_MONITORING_NS: 'ncm',\n    NXOS_1_0: 'nxos',\n    NXOS_IF: 'if',\n    TAILF_AAA_1_1: 'aaa',\n    TAILF_EXECD_1_1: 'execd',\n    CISCO_CPI_1_0: 'cpi',\n    FLOWMON_1_0: 'fm',\n    JUNIPER_1_1: 'junos',\n}):\n    register_namespace(pre, ns)\n\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else \"{%s}%s\" % (ns, tag)\n\"\"\"Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.\"\"\"\n\n\ndef to_xml(ele, encoding=\"UTF-8\", pretty_print=False):\n    \"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') \\\n            else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\n\ndef parse_root(raw):\n    \"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError(\"Element [%s] does not meet requirement\" % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)): req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError(\"Element [%s] does not have required attributes\" % ele.tag)\n    return ele\n\nXPATH_NAMESPACES = {\n    're':'http://exslt.org/regular-expressions'\n}\n\n\nclass NCElement(object):\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt=self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)),\n                                                                        parser=self.__parser))),\n                                       parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        # Comments don't have a namespace\n        if elem.tag is not etree.Comment:\n            # handle tag\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n\n            # handle attributes\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\n\n\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\n\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\n\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag,ns), attrs, **extra)\n\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\n\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)\n",
    "ncclient/manager.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nThis module is a thin layer of abstraction around the library.\nIt exposes all core functionality.\n\"\"\"\n\nfrom ncclient import operations\nfrom ncclient import transport\nimport socket\nimport logging\nimport functools\n\nfrom ncclient.xml_ import *\n\nlogger = logging.getLogger('ncclient.manager')\n\nOPERATIONS = {\n    \"get\": operations.Get,\n    \"get_config\": operations.GetConfig,\n    \"get_schema\": operations.GetSchema,\n    \"dispatch\": operations.Dispatch,\n    \"edit_config\": operations.EditConfig,\n    \"copy_config\": operations.CopyConfig,\n    \"validate\": operations.Validate,\n    \"commit\": operations.Commit,\n    \"discard_changes\": operations.DiscardChanges,\n    \"cancel_commit\": operations.CancelCommit,\n    \"delete_config\": operations.DeleteConfig,\n    \"lock\": operations.Lock,\n    \"unlock\": operations.Unlock,\n    \"create_subscription\": operations.CreateSubscription,\n    \"close_session\": operations.CloseSession,\n    \"kill_session\": operations.KillSession,\n    \"poweroff_machine\": operations.PoweroffMachine,\n    \"reboot_machine\": operations.RebootMachine,\n    \"rpc\": operations.GenericRPC,\n}\n\n\"\"\"\nDictionary of base method names and corresponding :class:`~ncclient.operations.RPC`\nsubclasses. It is used to lookup operations, e.g. `get_config` is mapped to\n:class:`~ncclient.operations.GetConfig`. It is thus possible to add additional\noperations to the :class:`Manager` API.\n\"\"\"\n\n\ndef make_device_handler(device_params):\n    \"\"\"\n    Create a device handler object that provides device specific parameters and\n    functions, which are called in various places throughout our code.\n\n    If no device_params are defined or the \"name\" in the parameter dict is not\n    known then a default handler will be returned.\n\n    \"\"\"\n    if device_params is None:\n        device_params = {}\n\n    handler = device_params.get('handler', None)\n    if handler:\n        return handler(device_params)\n\n    device_name = device_params.get(\"name\", \"default\")\n    # Attempt to import device handler class. All device handlers are\n    # in a module called \"ncclient.devices.<devicename>\" and in a class named\n    # \"<devicename>DeviceHandler\", with the first letter capitalized.\n    class_name          = \"%sDeviceHandler\" % device_name.capitalize()\n    devices_module_name = \"ncclient.devices.%s\" % device_name\n    dev_module_obj      = __import__(devices_module_name)\n    handler_module_obj  = getattr(getattr(dev_module_obj, \"devices\"), device_name)\n    class_obj           = getattr(handler_module_obj, class_name)\n    handler_obj         = class_obj(device_params)\n    return handler_obj\n\n\ndef _extract_device_params(kwds):\n    device_params = kwds.pop(\"device_params\", None)\n\n    return device_params\n\ndef _extract_manager_params(kwds):\n    manager_params = kwds.pop(\"manager_params\", {})\n\n    # To maintain backward compatibility\n    if 'timeout' not in manager_params and 'timeout' in kwds:\n        manager_params['timeout'] = kwds['timeout']\n    return manager_params\n\ndef _extract_nc_params(kwds):\n    nc_params = kwds.pop(\"nc_params\", {})\n\n    return nc_params\n\ndef connect_ssh(*args, **kwds):\n    \"\"\"Initialize a :class:`Manager` over the SSH transport.\n    For documentation of arguments see :meth:`ncclient.transport.SSHSession.connect`.\n\n    The underlying :class:`ncclient.transport.SSHSession` is created with\n    :data:`CAPABILITIES`. All the provided arguments are passed directly to its\n    implementation of :meth:`~ncclient.transport.SSHSession.connect`.\n\n    To customize the :class:`Manager`, add a `manager_params` dictionary in connection\n    parameters (e.g. `manager_params={'timeout': 60}` for a bigger RPC timeout parameter)\n\n    To invoke advanced vendor related operation add\n    `device_params={'name': '<vendor_alias>'}` in connection parameters. For the time,\n    'junos' and 'nexus' are supported for Juniper and Cisco Nexus respectively.\n\n    A custom device handler can be provided with\n    `device_params={'handler':<handler class>}` in connection parameters.\n\n    \"\"\"\n    # Extract device/manager/netconf parameter dictionaries, if they were passed into this function.\n    # Remove them from kwds (which should keep only session.connect() parameters).\n    device_params = _extract_device_params(kwds)\n    manager_params = _extract_manager_params(kwds)\n    nc_params = _extract_nc_params(kwds)\n\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_ssh_connect_params(kwds)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.SSHSession(device_handler)\n\n    try:\n       session.connect(*args, **kwds)\n    except Exception as ex:\n        if session.transport:\n            session.close()\n        raise\n    return Manager(session, device_handler, **manager_params)\n\n\ndef connect_tls(*args, **kwargs):\n    \"\"\"Initialize a :class:`Manager` over the TLS transport.\"\"\"\n    device_params = _extract_device_params(kwargs)\n    manager_params = _extract_manager_params(kwargs)\n    nc_params = _extract_nc_params(kwargs)\n\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.TLSSession(device_handler)\n\n    session.connect(*args, **kwargs)\n\n    return Manager(session, device_handler, **manager_params)\n\ndef connect_uds(*args, **kwargs):\n    \"\"\"Initialize a :class:`Manager` over the Unix Socket transport.\"\"\"\n    device_params = _extract_device_params(kwargs)\n    manager_params = _extract_manager_params(kwargs)\n    nc_params = _extract_nc_params(kwargs)\n\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.UnixSocketSession(device_handler)\n\n    session.connect(*args, **kwargs)\n\n    return Manager(session, device_handler, **manager_params)\n\ndef connect_ioproc(*args, **kwds):\n    device_params = _extract_device_params(kwds)\n    manager_params = _extract_manager_params(kwds)\n\n    if device_params:\n        import_string = 'ncclient.transport.third_party.'\n        import_string += device_params['name'] + '.ioproc'\n        third_party_import = __import__(import_string, fromlist=['IOProc'])\n\n    device_handler = make_device_handler(device_params)\n\n    session = third_party_import.IOProc(device_handler)\n    session.connect()\n\n    return Manager(session, device_handler, **manager_params)\n\n\ndef connect(*args, **kwds):\n    if \"host\" in kwds:\n        host = kwds[\"host\"]\n        device_params = kwds.get('device_params', {})\n        if host == 'localhost' and device_params.get('name') == 'junos' \\\n                and device_params.get('local'):\n            return connect_ioproc(*args, **kwds)\n        else:\n            return connect_ssh(*args, **kwds)\n\ndef call_home(*args, **kwds):\n    host = kwds[\"host\"]\n    port = kwds.get(\"port\",4334)\n    srv_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    srv_socket.bind((host, port))\n    srv_socket.settimeout(kwds.get(\"timeout\", 10))\n    srv_socket.listen()\n\n    sock, remote_host = srv_socket.accept()\n    logger.info('Callhome connection initiated from remote host {0}'.format(remote_host))\n    kwds['sock'] = sock\n    return connect_ssh(*args, **kwds)\n\nclass Manager(object):\n\n    \"\"\"\n    For details on the expected behavior of the operations and their\n        parameters refer to :rfc:`6241`.\n\n    Manager instances are also context managers so you can use it like this::\n\n        with manager.connect(\"host\") as m:\n            # do your stuff\n\n    ... or like this::\n\n        m = manager.connect(\"host\")\n        try:\n            # do your stuff\n        finally:\n            m.close_session()\n    \"\"\"\n\n   # __metaclass__ = OpExecutor\n\n\n    HUGE_TREE_DEFAULT = False\n    \"\"\"Default for `huge_tree` support for XML parsing of RPC replies (defaults to False)\"\"\"\n\n    def __init__(self, session, device_handler, timeout=30):\n        self._session = session\n        self._async_mode = False\n        self._timeout = timeout\n        self._raise_mode = operations.RaiseMode.ALL\n        self._huge_tree = self.HUGE_TREE_DEFAULT\n        self._device_handler = device_handler\n        self._vendor_operations = {}\n        if device_handler:\n            self._vendor_operations.update(device_handler.add_additional_operations())\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.close_session()\n        return False\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n\n    def __set_async_mode(self, mode):\n        self._async_mode = mode\n\n    def __set_raise_mode(self, mode):\n        assert(mode in (operations.RaiseMode.NONE, operations.RaiseMode.ERRORS, operations.RaiseMode.ALL))\n        self._raise_mode = mode\n\n    def execute(self, cls, *args, **kwds):\n        return cls(self._session,\n                   device_handler=self._device_handler,\n                   async_mode=self._async_mode,\n                   timeout=self._timeout,\n                   raise_mode=self._raise_mode,\n                   huge_tree=self._huge_tree).request(*args, **kwds)\n\n    def locked(self, target):\n        \"\"\"Returns a context manager for a lock on a datastore, where\n        *target* is the name of the configuration datastore to lock, e.g.::\n\n            with m.locked(\"running\"):\n                # do your stuff\n\n        ... instead of::\n\n            m.lock(\"running\")\n            try:\n                # do your stuff\n            finally:\n                m.unlock(\"running\")\n        \"\"\"\n        return operations.LockContext(self._session, self._device_handler, target)\n\n    def scp(self):\n        return self._session.scp()\n\n    def session(self):\n        raise NotImplementedError\n\n    def __getattr__(self, method):\n        if method in self._vendor_operations:\n            return functools.partial(self.execute, self._vendor_operations[method])\n        elif method in OPERATIONS:\n            return functools.partial(self.execute, OPERATIONS[method])\n        else:\n            \"\"\"Parse args/kwargs correctly in order to build XML element\"\"\"\n            def _missing(*args, **kwargs):\n                m = method.replace('_', '-')\n                root = new_ele(m)\n                if args:\n                    for arg in args:\n                        sub_ele(root, arg)\n                r = self.rpc(root)\n                return r\n            return _missing\n\n    def take_notification(self, block=True, timeout=None):\n        \"\"\"Attempt to retrieve one notification from the queue of received\n        notifications.\n\n        If block is True, the call will wait until a notification is\n        received.\n\n        If timeout is a number greater than 0, the call will wait that\n        many seconds to receive a notification before timing out.\n\n        If there is no notification available when block is False or\n        when the timeout has elapse, None will be returned.\n\n        Otherwise a :class:`~ncclient.operations.notify.Notification`\n        object will be returned.\n        \"\"\"\n        return self._session.take_notification(block, timeout)\n\n    @property\n    def client_capabilities(self):\n        \"\"\":class:`~ncclient.capabilities.Capabilities` object representing\n        the client's capabilities.\"\"\"\n        return self._session._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"\"\":class:`~ncclient.capabilities.Capabilities` object representing\n        the server's capabilities.\"\"\"\n        return self._session._server_capabilities\n\n    @property\n    def channel_id(self):\n        return self._session._channel_id\n\n    @property\n    def channel_name(self):\n        return self._session._channel_name\n\n    @property\n    def session_id(self):\n        \"\"\"`session-id` assigned by the NETCONF server.\"\"\"\n        return self._session.id\n\n    @property\n    def connected(self):\n        \"\"\"Whether currently connected to the NETCONF server.\"\"\"\n        return self._session.connected\n\n    async_mode = property(fget=lambda self: self._async_mode,\n                          fset=__set_async_mode)\n    \"\"\"Specify whether operations are executed asynchronously (`True`) or\n    synchronously (`False`) (the default).\"\"\"\n\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    \"\"\"Specify the timeout for synchronous RPC requests.\"\"\"\n\n    raise_mode = property(fget=lambda self: self._raise_mode,\n                          fset=__set_raise_mode)\n    \"\"\"Specify which errors are raised as :exc:`~ncclient.operations.RPCError`\n    exceptions. Valid values are the constants defined in\n    :class:`~ncclient.operations.RaiseMode`.\n    The default value is :attr:`~ncclient.operations.RaiseMode.ALL`.\"\"\"\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\n        The default value is configurable through :attr:`~ncclient.manager.Manager.HUGE_TREE_DEFAULT`\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x\n",
    "ncclient/operations/rpc.py": "# Copyright 2009 Shikhar Bhushan\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import Event, Lock\nfrom uuid import uuid4\n\nfrom ncclient.xml_ import *\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport import SessionListener\nfrom ncclient.operations import util\nfrom ncclient.operations.errors import OperationError, TimeoutExpiredError, MissingCapabilityError\n\nimport logging\nlogger = logging.getLogger(\"ncclient.operations.rpc\")\n\n\nclass RPCError(OperationError):\n\n    \"Represents an `rpc-error`. It is a type of :exc:`OperationError` and can be raised as such.\"\n\n    tag_to_attr = {\n        qualify(\"error-type\"): \"_type\",\n        qualify(\"error-tag\"): \"_tag\",\n        qualify(\"error-app-tag\"): \"_app_tag\",\n        qualify(\"error-severity\"): \"_severity\",\n        qualify(\"error-info\"): \"_info\",\n        qualify(\"error-path\"): \"_path\",\n        qualify(\"error-message\"): \"_message\"\n    }\n\n    def __init__(self, raw, errs=None):\n        self._raw = raw\n        if errs is None:\n            # Single RPCError\n            self._errlist = None\n            for attr in six.itervalues(RPCError.tag_to_attr):\n                setattr(self, attr, None)\n            for subele in raw:\n                attr = RPCError.tag_to_attr.get(subele.tag, None)\n                if attr is not None:\n                    setattr(self, attr, subele.text if attr != \"_info\" else to_xml(subele) )\n            if self.message is not None:\n                OperationError.__init__(self, self.message)\n            else:\n                OperationError.__init__(self, self.to_dict())\n        else:\n            # Multiple errors returned. Errors is a list of RPCError objs\n            self._errlist = errs\n            errlist = []\n            for err in errs:\n                if err.severity:\n                    errsev = err.severity\n                else:\n                    errsev = 'undefined'\n                if err.message:\n                    errmsg = err.message\n                else:\n                    errmsg = 'not an error message in the reply. Enable debug'\n                errordict = {\"severity\": errsev, \"message\":errmsg}\n                errlist.append(errordict)\n            # We are interested in the severity and the message\n            self._severity = 'warning'\n            self._message = \"\\n\".join([\"%s: %s\" %(err['severity'].strip(), err['message'].strip()) for err in errlist])\n            self.errors = errs\n            has_error = filter(lambda higherr: higherr['severity'] == 'error', errlist)\n            if has_error:\n                self._severity = 'error'\n            OperationError.__init__(self, self.message)\n\n    def to_dict(self):\n        return dict([ (attr[1:], getattr(self, attr)) for attr in six.itervalues(RPCError.tag_to_attr) ])\n\n    @property\n    def xml(self):\n        \"The `rpc-error` element as returned in XML. \\\n        Multiple errors are returned as list of RPC errors\"\n        return self._raw\n\n    @property\n    def type(self):\n        \"The contents of the `error-type` element.\"\n        return self._type\n\n    @property\n    def tag(self):\n        \"The contents of the `error-tag` element.\"\n        return self._tag\n\n    @property\n    def app_tag(self):\n        \"The contents of the `error-app-tag` element.\"\n        return self._app_tag\n\n    @property\n    def severity(self):\n        \"The contents of the `error-severity` element.\"\n        return self._severity\n\n    @property\n    def path(self):\n        \"The contents of the `error-path` element if present or `None`.\"\n        return self._path\n\n    @property\n    def message(self):\n        \"The contents of the `error-message` element if present or `None`.\"\n        return self._message\n\n    @property\n    def info(self):\n        \"XML string or `None`; representing the `error-info` element.\"\n        return self._info\n\n    @property\n    def errlist(self):\n        \"List of errors if this represents multiple errors, otherwise None.\"\n        return self._errlist\n\n\nclass RPCReply(object):\n\n    \"\"\"Represents an *rpc-reply*. Only concerns itself with whether the operation was successful.\n\n    *raw*: the raw unparsed reply\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n\n    .. note::\n        If the reply has not yet been parsed there is an implicit, one-time parsing overhead to\n        accessing some of the attributes defined by this class.\n    \"\"\"\n\n    ERROR_CLS = RPCError\n    \"Subclasses can specify a different error class, but it should be a subclass of `RPCError`.\"\n\n    def __init__(self, raw, huge_tree=False, parsing_error_transform=None):\n        self._raw = raw\n        self._parsing_error_transform = parsing_error_transform\n        self._parsed = False\n        self._root = None\n        self._errors = []\n        self._huge_tree = huge_tree\n\n    def __repr__(self):\n        return self._raw\n\n    def parse(self):\n        \"Parses the *rpc-reply*.\"\n        if self._parsed: return\n        root = self._root = to_ele(self._raw, huge_tree=self._huge_tree) # The <rpc-reply> element\n        # Per RFC 4741 an <ok/> tag is sent when there are no errors or warnings\n        ok = root.find(qualify(\"ok\"))\n        if ok is None:\n            # Create RPCError objects from <rpc-error> elements\n            error = root.find('.//'+qualify('rpc-error'))\n            if error is not None:\n                for err in root.getiterator(error.tag):\n                    # Process a particular <rpc-error>\n                    self._errors.append(self.ERROR_CLS(err))\n        try:\n            self._parsing_hook(root)\n        except Exception as e:\n            if self._parsing_error_transform is None:\n                # re-raise as we have no workaround\n                exc_type, exc_value, exc_traceback = sys.exc_info()\n                six.reraise(exc_type, exc_value, exc_traceback)\n\n            # Apply device specific workaround and try again\n            self._parsing_error_transform(root)\n            self._parsing_hook(root)\n\n        self._parsed = True\n\n    def _parsing_hook(self, root):\n        \"No-op by default. Gets passed the *root* element for the reply.\"\n        pass\n\n    def set_parsing_error_transform(self, transform_function):\n        self._parsing_error_transform = transform_function\n\n    @property\n    def xml(self):\n        \"*rpc-reply* element as returned.\"\n        return self._raw\n\n    @property\n    def ok(self):\n        \"Boolean value indicating if there were no errors.\"\n        self.parse()\n        return not self.errors # empty list => false\n\n    @property\n    def error(self):\n        \"Returns the first :class:`RPCError` and `None` if there were no errors.\"\n        self.parse()\n        if self._errors:\n            return self._errors[0]\n        else:\n            return None\n\n    @property\n    def errors(self):\n        \"List of `RPCError` objects. Will be empty if there were no *rpc-error* elements in reply.\"\n        self.parse()\n        return self._errors\n\n\nclass RPCReplyListener(SessionListener): # internal use\n\n    creation_lock = Lock()\n\n    # one instance per session -- maybe there is a better way??\n    def __new__(cls, session, device_handler):\n        with RPCReplyListener.creation_lock:\n            instance = session.get_listener_instance(cls)\n            if instance is None:\n                instance = object.__new__(cls)\n                instance._lock = Lock()\n                instance._id2rpc = {}\n                instance._device_handler = device_handler\n                #instance._pipelined = session.can_pipeline\n                session.add_listener(instance)\n                instance.logger = SessionLoggerAdapter(logger,\n                                                       {'session': session})\n            return instance\n\n    def register(self, id, rpc):\n        with self._lock:\n            self._id2rpc[id] = rpc\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if self._device_handler.perform_qualify_check():\n            if tag != qualify(\"rpc-reply\"):\n                return\n        if \"message-id\" not in attrs:\n            # required attribute so raise OperationError\n            raise OperationError(\"Could not find 'message-id' attribute in <rpc-reply>\")\n        else:\n            id = attrs[\"message-id\"]  # get the msgid\n            with self._lock:\n                try:\n                    rpc = self._id2rpc[id]  # the corresponding rpc\n                    self.logger.debug(\"Delivering to %r\", rpc)\n                    rpc.deliver_reply(raw)\n                except KeyError:\n                    raise OperationError(\"Unknown 'message-id': %s\" % id)\n                # no catching other exceptions, fail loudly if must\n                else:\n                    # if no error delivering, can del the reference to the RPC\n                    del self._id2rpc[id]\n\n    def errback(self, err):\n        try:\n            for rpc in six.itervalues(self._id2rpc):\n                rpc.deliver_error(err)\n        finally:\n            self._id2rpc.clear()\n\n\nclass RaiseMode(object):\n    \"\"\"\n    Define how errors indicated by RPC should be handled.\n\n    Note that any error_filters defined in the device handler will still be\n    applied, even if ERRORS or ALL is defined: If the filter matches, an exception\n    will NOT be raised.\n\n    \"\"\"\n    NONE = 0\n    \"Don't attempt to raise any type of `rpc-error` as :exc:`RPCError`.\"\n\n    ERRORS = 1\n    \"Raise only when the `error-type` indicates it is an honest-to-god error.\"\n\n    ALL = 2\n    \"Don't look at the `error-type`, always raise.\"\n\n\nclass RPC(object):\n\n    \"\"\"Base class for all operations, directly corresponding to *rpc* requests. Handles making the request, and taking delivery of the reply.\"\"\"\n\n    DEPENDS = []\n    \"\"\"Subclasses can specify their dependencies on capabilities as a list of URI's or abbreviated names, e.g. ':writable-running'. These are verified at the time of instantiation. If the capability is not available, :exc:`MissingCapabilityError` is raised.\"\"\"\n\n    REPLY_CLS = RPCReply\n    \"By default :class:`RPCReply`. Subclasses can specify a :class:`RPCReply` subclass.\"\n\n\n    def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):\n        \"\"\"\n        *session* is the :class:`~ncclient.transport.Session` instance\n\n        *device_handler\" is the :class:`~ncclient.devices.*.*DeviceHandler` instance\n\n        *async* specifies whether the request is to be made asynchronously, see :attr:`is_async`\n\n        *timeout* is the timeout for a synchronous request, see :attr:`timeout`\n\n        *raise_mode* specifies the exception raising mode, see :attr:`raise_mode`\n\n        *huge_tree* parse xml with huge_tree support (e.g. for large text config retrieval), see :attr:`huge_tree`\n        \"\"\"\n        self._session = session\n        try:\n            for cap in self.DEPENDS:\n                self._assert(cap)\n        except AttributeError:\n            pass\n        self._async = async_mode\n        self._timeout = timeout\n        self._raise_mode = raise_mode\n        self._huge_tree = huge_tree\n        self._id = uuid4().urn # Keeps things simple instead of having a class attr with running ID that has to be locked\n        self._listener = RPCReplyListener(session, device_handler)\n        self._listener.register(self._id, self)\n        self._reply = None\n        self._error = None\n        self._event = Event()\n        self._device_handler = device_handler\n        self.logger = SessionLoggerAdapter(logger, {'session': session})\n\n\n    def _wrap(self, subele):\n        # internal use\n        ele = new_ele(\"rpc\", {\"message-id\": self._id},\n                      **self._device_handler.get_xml_extra_prefix_kwargs())\n        ele.append(subele)\n        return to_xml(ele)\n\n    def _request(self, op):\n        \"\"\"Implementations of :meth:`request` call this method to send the request and process the reply.\n\n        In synchronous mode, blocks until the reply is received and returns :class:`RPCReply`. Depending on the :attr:`raise_mode` a `rpc-error` element in the reply may lead to an :exc:`RPCError` exception.\n\n        In asynchronous mode, returns immediately, returning `self`. The :attr:`event` attribute will be set when the reply has been received (see :attr:`reply`) or an error occured (see :attr:`error`).\n\n        *op* is the operation to be requested as an :class:`~xml.etree.ElementTree.Element`\n        \"\"\"\n        self.logger.info('Requesting %r', self.__class__.__name__)\n        req = self._wrap(op)\n        self._session.send(req)\n        if self._async:\n            self.logger.debug('Async request, returning %r', self)\n            return self\n        else:\n            self.logger.debug('Sync request, will wait for timeout=%r', self._timeout)\n            self._event.wait(self._timeout)\n            if self._event.is_set():\n                if self._error:\n                    # Error that prevented reply delivery\n                    raise self._error\n                self._reply.parse()\n                if self._reply.error is not None and not self._device_handler.is_rpc_error_exempt(self._reply.error.message):\n                    # <rpc-error>'s [ RPCError ]\n\n                    if self._raise_mode == RaiseMode.ALL or (self._raise_mode == RaiseMode.ERRORS and self._reply.error.severity == \"error\"):\n                        errlist = []\n                        errors = self._reply.errors\n                        if len(errors) > 1:\n                            raise RPCError(to_ele(self._reply._raw), errs=errors)\n                        else:\n                            raise self._reply.error\n                if self._device_handler.transform_reply():\n                    return NCElement(self._reply, self._device_handler.transform_reply(), huge_tree=self._huge_tree)\n                else:\n                    return self._reply\n            else:\n                raise TimeoutExpiredError('ncclient timed out while waiting for an rpc reply.')\n\n    def request(self):\n        \"\"\"Subclasses must implement this method. Typically only the request needs to be built as an\n        :class:`~xml.etree.ElementTree.Element` and everything else can be handed off to\n        :meth:`_request`.\"\"\"\n        pass\n\n    def _assert(self, capability):\n        \"\"\"Subclasses can use this method to verify that a capability is available with the NETCONF\n        server, before making a request that requires it. A :exc:`MissingCapabilityError` will be\n        raised if the capability is not available.\"\"\"\n        if capability not in self._session.server_capabilities:\n            raise MissingCapabilityError('Server does not support [%s]' % capability)\n\n    def deliver_reply(self, raw):\n        # internal use\n        self._reply = self.REPLY_CLS(raw, huge_tree=self._huge_tree)\n\n        # Set the reply_parsing_error transform outside the constructor, to keep compatibility for\n        # third party reply classes outside of ncclient\n        self._reply.set_parsing_error_transform(\n            self._device_handler.reply_parsing_error_transform(self.REPLY_CLS)\n        )\n\n        self._event.set()\n\n    def deliver_error(self, err):\n        # internal use\n        self._error = err\n        self._event.set()\n\n    @property\n    def reply(self):\n        \":class:`RPCReply` element if reply has been received or `None`\"\n        return self._reply\n\n    @property\n    def error(self):\n        \"\"\":exc:`Exception` type if an error occured or `None`.\n\n        .. note::\n            This represents an error which prevented a reply from being received. An *rpc-error*\n            does not fall in that category -- see `RPCReply` for that.\n        \"\"\"\n        return self._error\n\n    @property\n    def id(self):\n        \"The *message-id* for this RPC.\"\n        return self._id\n\n    @property\n    def session(self):\n        \"The `~ncclient.transport.Session` object associated with this RPC.\"\n        return self._session\n\n    @property\n    def event(self):\n        \"\"\":class:`~threading.Event` that is set when reply has been received or when an error preventing\n        delivery of the reply occurs.\n        \"\"\"\n        return self._event\n\n    def __set_async(self, async_mode=True):\n        self._async = async_mode\n        if async_mode and not self._session.can_pipeline:\n            raise UserWarning('Asynchronous mode not supported for this device/session')\n\n    def __set_raise_mode(self, mode):\n        assert(mode in (RaiseMode.NONE, RaiseMode.ERRORS, RaiseMode.ALL))\n        self._raise_mode = mode\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n\n    raise_mode = property(fget=lambda self: self._raise_mode, fset=__set_raise_mode)\n    \"\"\"Depending on this exception raising mode, an `rpc-error` in the reply may be raised as an :exc:`RPCError` exception. Valid values are the constants defined in :class:`RaiseMode`. \"\"\"\n\n    is_async = property(fget=lambda self: self._async, fset=__set_async)\n    \"\"\"Specifies whether this RPC will be / was requested asynchronously. By default RPC's are synchronous.\"\"\"\n\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    \"\"\"Timeout in seconds for synchronous waiting defining how long the RPC request will block on a reply before raising :exc:`TimeoutExpiredError`.\n\n    Irrelevant for asynchronous usage.\n    \"\"\"\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x\n\nclass GenericRPC(RPC):\n    \"\"\"Generic rpc commands wrapper\"\"\"\n    REPLY_CLS = RPCReply\n    \"\"\"See :class:`RPCReply`.\"\"\"\n\n    def request(self, rpc_command, source=None, filter=None, config=None, target=None, format=None):\n        \"\"\"\n        *rpc_command* specifies rpc command to be dispatched either in plain text or in xml element format (depending on command)\n\n        *target* name of the configuration datastore being edited\n\n        *source* name of the configuration datastore being queried\n\n        *config* is the configuration, which must be rooted in the `config` element. It can be specified either as a string or an :class:`~xml.etree.ElementTree.Element`.\n\n        *filter* specifies the portion of the configuration to retrieve (by default entire configuration is retrieved)\n\n        :seealso: :ref:`filter_params`\n\n        Examples of usage::\n\n            m.rpc('rpc_command')\n\n        or dispatch element like ::\n\n            rpc_command = new_ele('get-xnm-information')\n            sub_ele(rpc_command, 'type').text = \"xml-schema\"\n            m.rpc(rpc_command)\n        \"\"\"\n\n        if etree.iselement(rpc_command):\n            node = rpc_command\n        else:\n            node = new_ele(rpc_command)\n        if target is not None:\n            node.append(util.datastore_or_url(\"target\", target, self._assert))\n        if source is not None:\n            node.append(util.datastore_or_url(\"source\", source, self._assert))\n        if filter is not None:\n            node.append(util.build_filter(filter))\n        if config is not None:\n            node.append(validated_element(config, (\"config\", qualify(\"config\"))))\n\n        return self._request(node)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n"
  },
  "GT_src_dict": {
    "ncclient/operations/lock.py": {
      "Lock.request": {
        "code": "    def request(self, target='candidate'):\n        \"\"\"Allows the client to lock a specified configuration datastore in a device's configuration system.\n\nParameters:\n    target (str): The name of the configuration datastore to lock. Defaults to \"candidate\".\n\nReturns:\n    The result of the lock request as defined by the parent class's `_request` method.\n\nThis method utilizes the `new_ele` and `sub_ele` functions to create the appropriate XML format for the lock request. It constructs an XML element named \"lock\" with a nested \"target\" element indicating which datastore to lock. The request is then sent to the device, and any `rpc-error` will be handled in the broader context where this method is utilized.\"\"\"\n        'Allows the client to lock the configuration system of a device.\\n\\n        *target* is the name of the configuration datastore to lock\\n        '\n        node = new_ele('lock')\n        sub_ele(sub_ele(node, 'target'), target)\n        return self._request(node)",
        "docstring": "Allows the client to lock a specified configuration datastore in a device's configuration system.\n\nParameters:\n    target (str): The name of the configuration datastore to lock. Defaults to \"candidate\".\n\nReturns:\n    The result of the lock request as defined by the parent class's `_request` method.\n\nThis method utilizes the `new_ele` and `sub_ele` functions to create the appropriate XML format for the lock request. It constructs an XML element named \"lock\" with a nested \"target\" element indicating which datastore to lock. The request is then sent to the device, and any `rpc-error` will be handled in the broader context where this method is utilized.",
        "signature": "def request(self, target='candidate'):",
        "type": "Method",
        "class_signature": "class Lock(RPC):"
      },
      "Unlock.request": {
        "code": "    def request(self, target='candidate'):\n        \"\"\"Releases a previously obtained configuration lock for the specified datastore.\n\nParameters:\n- target (str): The name of the configuration datastore to unlock. Defaults to \"candidate\".\n\nReturns:\n- The result of the unlock operation as an XML element, indicating success or failure.\n\nInteractions:\nThis method constructs an XML element for the `<unlock>` RPC operation and uses the `_request` method inherited from the `RPC` class to send the request over the NETCONF session. The `new_ele` and `sub_ele` functions are used for XML element creation and manipulation, which are imported from the `ncclient.xml_` module.\"\"\"\n        'Release a configuration lock, previously obtained with the lock operation.\\n\\n        *target* is the name of the configuration datastore to unlock\\n        '\n        node = new_ele('unlock')\n        sub_ele(sub_ele(node, 'target'), target)\n        return self._request(node)",
        "docstring": "Releases a previously obtained configuration lock for the specified datastore.\n\nParameters:\n- target (str): The name of the configuration datastore to unlock. Defaults to \"candidate\".\n\nReturns:\n- The result of the unlock operation as an XML element, indicating success or failure.\n\nInteractions:\nThis method constructs an XML element for the `<unlock>` RPC operation and uses the `_request` method inherited from the `RPC` class to send the request over the NETCONF session. The `new_ele` and `sub_ele` functions are used for XML element creation and manipulation, which are imported from the `ncclient.xml_` module.",
        "signature": "def request(self, target='candidate'):",
        "type": "Method",
        "class_signature": "class Unlock(RPC):"
      },
      "LockContext.__init__": {
        "code": "    def __init__(self, session, device_handler, target):\n        \"\"\"Initializes the LockContext manager, which handles the locking and unlocking of a configuration datastore during a NETCONF session.\n\nParameters:\n- session (Session): An instance of the Session class from the ncclient.transport module, representing the NETCONF session.\n- device_handler: An object that handles device-specific operations.\n- target (str): The name of the configuration datastore to lock, with a default value of \"candidate\".\n\nThis constructor sets up the LockContext with the provided session, device handler, and target datastore for future lock and unlock operations during the context management lifecycle. It primarily interacts with the Lock and Unlock RPC classes for managing configuration locks, ensuring that any rpc-errors are handled properly as exceptions.\"\"\"\n        self.session = session\n        self.target = target\n        self.device_handler = device_handler",
        "docstring": "Initializes the LockContext manager, which handles the locking and unlocking of a configuration datastore during a NETCONF session.\n\nParameters:\n- session (Session): An instance of the Session class from the ncclient.transport module, representing the NETCONF session.\n- device_handler: An object that handles device-specific operations.\n- target (str): The name of the configuration datastore to lock, with a default value of \"candidate\".\n\nThis constructor sets up the LockContext with the provided session, device handler, and target datastore for future lock and unlock operations during the context management lifecycle. It primarily interacts with the Lock and Unlock RPC classes for managing configuration locks, ensuring that any rpc-errors are handled properly as exceptions.",
        "signature": "def __init__(self, session, device_handler, target):",
        "type": "Method",
        "class_signature": "class LockContext(object):"
      },
      "LockContext.__enter__": {
        "code": "    def __enter__(self):\n        \"\"\"Handles the entry into the lock context by attempting to lock the specified configuration datastore\nusing the `Lock` RPC. It uses the provided `session`, `device_handler`, and `target` attributes\nto establish the lock. If the lock operation fails, it raises an `rpc-error` as an exception. On success,\nthe context manager can be used to ensure proper resource management.\n\nParameters:\n- self: Reference to the instance of `LockContext`.\n  \nReturns:\n- self: The instance of `LockContext`, allowing for chaining within the context manager.\n\nDependencies:\n- `Lock`: Initiates the locking operation based on the `session` and `device_handler`.\n- `RaiseMode`: A constant from `ncclient.operations.rpc` set to `ERRORS`, indicating that errors during \n  the locking process should raise exceptions if encountered.\n- `target`: A string representing the name of the configuration datastore to be locked, defaulting to \"candidate\".\"\"\"\n        Lock(self.session, self.device_handler, raise_mode=RaiseMode.ERRORS).request(self.target)\n        return self",
        "docstring": "Handles the entry into the lock context by attempting to lock the specified configuration datastore\nusing the `Lock` RPC. It uses the provided `session`, `device_handler`, and `target` attributes\nto establish the lock. If the lock operation fails, it raises an `rpc-error` as an exception. On success,\nthe context manager can be used to ensure proper resource management.\n\nParameters:\n- self: Reference to the instance of `LockContext`.\n  \nReturns:\n- self: The instance of `LockContext`, allowing for chaining within the context manager.\n\nDependencies:\n- `Lock`: Initiates the locking operation based on the `session` and `device_handler`.\n- `RaiseMode`: A constant from `ncclient.operations.rpc` set to `ERRORS`, indicating that errors during \n  the locking process should raise exceptions if encountered.\n- `target`: A string representing the name of the configuration datastore to be locked, defaulting to \"candidate\".",
        "signature": "def __enter__(self):",
        "type": "Method",
        "class_signature": "class LockContext(object):"
      },
      "LockContext.__exit__": {
        "code": "    def __exit__(self, *args):\n        \"\"\"Handles the cleanup operation when exiting the `LockContext` manager by releasing a lock on the specified configuration datastore.\n\nParameters:\n- `*args`: Variable length argument list that captures any exceptions raised in the block managed by the context manager (not used in this implementation).\n\nReturns:\n- `False`: Indicates that any exceptions raised should not be suppressed, allowing them to propagate.\n\nThe method interacts with the `Unlock` class, calling its `request` method to perform the unlock operation on the datastore specified by the `target` attribute. The `raise_mode` is set to `RaiseMode.ERRORS`, ensuring that any errors encountered during the unlock operation will raise exceptions. This functionality relies on the `self.session` and `self.device_handler` attributes initialized in the `LockContext` class.\"\"\"\n        Unlock(self.session, self.device_handler, raise_mode=RaiseMode.ERRORS).request(self.target)\n        return False",
        "docstring": "Handles the cleanup operation when exiting the `LockContext` manager by releasing a lock on the specified configuration datastore.\n\nParameters:\n- `*args`: Variable length argument list that captures any exceptions raised in the block managed by the context manager (not used in this implementation).\n\nReturns:\n- `False`: Indicates that any exceptions raised should not be suppressed, allowing them to propagate.\n\nThe method interacts with the `Unlock` class, calling its `request` method to perform the unlock operation on the datastore specified by the `target` attribute. The `raise_mode` is set to `RaiseMode.ERRORS`, ensuring that any errors encountered during the unlock operation will raise exceptions. This functionality relies on the `self.session` and `self.device_handler` attributes initialized in the `LockContext` class.",
        "signature": "def __exit__(self, *args):",
        "type": "Method",
        "class_signature": "class LockContext(object):"
      }
    },
    "ncclient/xml_.py": {
      "parent_ns": {
        "code": "def parent_ns(node):\n    \"\"\"Retrieve the parent namespace URI of a given XML node.\n\nArgs:\n    node (lxml.etree._Element): The XML element whose parent namespace is to be accessed. This element must be part of an XML tree that utilizes namespaces.\n\nReturns:\n    str or None: The namespace URI associated with the element's prefix if it exists; otherwise, returns None.\n\nThis function interacts with the `nsmap` attribute of the `lxml.etree._Element` class, which is a mapping of prefixes to their corresponding namespace URIs for the XML document. The use of `node.prefix` allows the function to check if the node is associated with a namespace and retrieve the corresponding URI.\"\"\"\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None",
        "docstring": "Retrieve the parent namespace URI of a given XML node.\n\nArgs:\n    node (lxml.etree._Element): The XML element whose parent namespace is to be accessed. This element must be part of an XML tree that utilizes namespaces.\n\nReturns:\n    str or None: The namespace URI associated with the element's prefix if it exists; otherwise, returns None.\n\nThis function interacts with the `nsmap` attribute of the `lxml.etree._Element` class, which is a mapping of prefixes to their corresponding namespace URIs for the XML document. The use of `node.prefix` allows the function to check if the node is associated with a namespace and retrieve the corresponding URI.",
        "signature": "def parent_ns(node):",
        "type": "Function",
        "class_signature": null
      }
    },
    "ncclient/manager.py": {
      "make_device_handler": {
        "code": "def make_device_handler(device_params):\n    \"\"\"Create a device handler object based on provided device parameters.\n\nParameters:\n- device_params (dict): A dictionary containing device-specific parameters. It may include:\n  - 'handler': A custom handler class to be instantiated (optional).\n  - 'name': A string representing the device name (default is \"default\").\n\nReturns:\n- An instance of the appropriate device handler class that provides device-specific functionality. If no handler is found, a default handler will be returned.\n\nDependencies:\n- The function imports device handler classes dynamically based on the device name from the `ncclient.devices` module, expecting the class name to follow the format `<DeviceName>DeviceHandler`. If the specified device name is not found in the module, a default handler is returned.\"\"\"\n    '\\n    Create a device handler object that provides device specific parameters and\\n    functions, which are called in various places throughout our code.\\n\\n    If no device_params are defined or the \"name\" in the parameter dict is not\\n    known then a default handler will be returned.\\n\\n    '\n    if device_params is None:\n        device_params = {}\n    handler = device_params.get('handler', None)\n    if handler:\n        return handler(device_params)\n    device_name = device_params.get('name', 'default')\n    class_name = '%sDeviceHandler' % device_name.capitalize()\n    devices_module_name = 'ncclient.devices.%s' % device_name\n    dev_module_obj = __import__(devices_module_name)\n    handler_module_obj = getattr(getattr(dev_module_obj, 'devices'), device_name)\n    class_obj = getattr(handler_module_obj, class_name)\n    handler_obj = class_obj(device_params)\n    return handler_obj",
        "docstring": "Create a device handler object based on provided device parameters.\n\nParameters:\n- device_params (dict): A dictionary containing device-specific parameters. It may include:\n  - 'handler': A custom handler class to be instantiated (optional).\n  - 'name': A string representing the device name (default is \"default\").\n\nReturns:\n- An instance of the appropriate device handler class that provides device-specific functionality. If no handler is found, a default handler will be returned.\n\nDependencies:\n- The function imports device handler classes dynamically based on the device name from the `ncclient.devices` module, expecting the class name to follow the format `<DeviceName>DeviceHandler`. If the specified device name is not found in the module, a default handler is returned.",
        "signature": "def make_device_handler(device_params):",
        "type": "Function",
        "class_signature": null
      }
    },
    "ncclient/operations/rpc.py": {
      "RPC.__init__": {
        "code": "    def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):\n        \"\"\"Initializes an instance of the RPC class, which serves as a base for all RPC requests in the context of network communications via NETCONF.\n\nParameters:\n- session (Session): An instance of the `~ncclient.transport.Session` class, representing the current session to the NETCONF server.\n- device_handler (DeviceHandler): An instance of the `~ncclient.devices.*.*DeviceHandler` class, responsible for managing device-specific operations.\n- async_mode (bool, optional): Indicates whether the RPC request should be handled asynchronously (default is False).\n- timeout (int, optional): The maximum time to wait for a synchronous response before raising a timeout error (default is 30 seconds).\n- raise_mode (RaiseMode, optional): Specifies the mode for raising exceptions based on the returned RPC error (default is `RaiseMode.NONE`).\n- huge_tree (bool, optional): Flag to enable support for parsing large XML trees, useful for extensive configuration retrieval (default is False).\n\nAttributes:\n- _id (str): A unique identifier for the RPC request, generated using `uuid4().urn`.\n- _listener (RPCReplyListener): An instance of `RPCReplyListener`, which listens for replies related to this RPC request.\n- _reply (RPCReply): Stores the response received from the server, initialized to None.\n- _error (Exception): Stores any error encountered while processing the request, initialized to None.\n- _event (Event): A threading event that is set when a reply is received or an error occurs.\n\nDependencies:\n- This initializer checks for any required capabilities specified in the `DEPENDS` attribute and asserts their availability using the `_assert` method. If capabilities are missing, a `MissingCapabilityError` may be raised.\"\"\"\n        '\\n        *session* is the :class:`~ncclient.transport.Session` instance\\n\\n        *device_handler\" is the :class:`~ncclient.devices.*.*DeviceHandler` instance\\n\\n        *async* specifies whether the request is to be made asynchronously, see :attr:`is_async`\\n\\n        *timeout* is the timeout for a synchronous request, see :attr:`timeout`\\n\\n        *raise_mode* specifies the exception raising mode, see :attr:`raise_mode`\\n\\n        *huge_tree* parse xml with huge_tree support (e.g. for large text config retrieval), see :attr:`huge_tree`\\n        '\n        self._session = session\n        try:\n            for cap in self.DEPENDS:\n                self._assert(cap)\n        except AttributeError:\n            pass\n        self._async = async_mode\n        self._timeout = timeout\n        self._raise_mode = raise_mode\n        self._huge_tree = huge_tree\n        self._id = uuid4().urn\n        self._listener = RPCReplyListener(session, device_handler)\n        self._listener.register(self._id, self)\n        self._reply = None\n        self._error = None\n        self._event = Event()\n        self._device_handler = device_handler\n        self.logger = SessionLoggerAdapter(logger, {'session': session})",
        "docstring": "Initializes an instance of the RPC class, which serves as a base for all RPC requests in the context of network communications via NETCONF.\n\nParameters:\n- session (Session): An instance of the `~ncclient.transport.Session` class, representing the current session to the NETCONF server.\n- device_handler (DeviceHandler): An instance of the `~ncclient.devices.*.*DeviceHandler` class, responsible for managing device-specific operations.\n- async_mode (bool, optional): Indicates whether the RPC request should be handled asynchronously (default is False).\n- timeout (int, optional): The maximum time to wait for a synchronous response before raising a timeout error (default is 30 seconds).\n- raise_mode (RaiseMode, optional): Specifies the mode for raising exceptions based on the returned RPC error (default is `RaiseMode.NONE`).\n- huge_tree (bool, optional): Flag to enable support for parsing large XML trees, useful for extensive configuration retrieval (default is False).\n\nAttributes:\n- _id (str): A unique identifier for the RPC request, generated using `uuid4().urn`.\n- _listener (RPCReplyListener): An instance of `RPCReplyListener`, which listens for replies related to this RPC request.\n- _reply (RPCReply): Stores the response received from the server, initialized to None.\n- _error (Exception): Stores any error encountered while processing the request, initialized to None.\n- _event (Event): A threading event that is set when a reply is received or an error occurs.\n\nDependencies:\n- This initializer checks for any required capabilities specified in the `DEPENDS` attribute and asserts their availability using the `_assert` method. If capabilities are missing, a `MissingCapabilityError` may be raised.",
        "signature": "def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):",
        "type": "Method",
        "class_signature": "class RPC(object):"
      }
    },
    "ncclient/transport/errors.py": {}
  },
  "dependency_dict": {
    "ncclient/manager.py:make_device_handler": {
      "ncclient/devices/junos.py": {
        "JunosDeviceHandler.__init__": {
          "code": "    def __init__(self, device_params):\n        super(JunosDeviceHandler, self).__init__(device_params)\n        self.__reply_parsing_error_transform_by_cls = {\n            GetSchemaReply: fix_get_schema_reply\n        }",
          "docstring": "",
          "signature": "def __init__(self, device_params):",
          "type": "Method",
          "class_signature": "class JunosDeviceHandler(DefaultDeviceHandler):"
        }
      }
    },
    "ncclient/operations/rpc.py:RPC:__init__": {
      "ncclient/operations/rpc.py": {
        "RPCReplyListener.__new__": {
          "code": "    def __new__(cls, session, device_handler):\n        with RPCReplyListener.creation_lock:\n            instance = session.get_listener_instance(cls)\n            if instance is None:\n                instance = object.__new__(cls)\n                instance._lock = Lock()\n                instance._id2rpc = {}\n                instance._device_handler = device_handler\n                session.add_listener(instance)\n                instance.logger = SessionLoggerAdapter(logger, {'session': session})\n            return instance",
          "docstring": "",
          "signature": "def __new__(cls, session, device_handler):",
          "type": "Method",
          "class_signature": "class RPCReplyListener(SessionListener):"
        }
      }
    },
    "ncclient/operations/lock.py:Lock:request": {},
    "ncclient/operations/lock.py:LockContext:__enter__": {},
    "ncclient/operations/lock.py:LockContext:__exit__": {},
    "ncclient/operations/lock.py:Unlock:request": {}
  },
  "call_tree": {
    "modified_testcases/unit/operations/test_lock.py:TestLock:setUp": {
      "ncclient/manager.py:make_device_handler": {
        "ncclient/devices/default.py:DefaultDeviceHandler:DefaultDeviceHandler": {},
        "ncclient/operations/third_party/juniper/rpc.py:GetConfiguration:GetConfiguration": {},
        "ncclient/operations/third_party/juniper/rpc.py:LoadConfiguration:LoadConfiguration": {},
        "ncclient/operations/third_party/juniper/rpc.py:CompareConfiguration:CompareConfiguration": {},
        "ncclient/operations/third_party/juniper/rpc.py:ExecuteRpc:ExecuteRpc": {},
        "ncclient/operations/third_party/juniper/rpc.py:Command:Command": {},
        "ncclient/operations/third_party/juniper/rpc.py:Reboot:Reboot": {},
        "ncclient/operations/third_party/juniper/rpc.py:Halt:Halt": {},
        "ncclient/operations/third_party/juniper/rpc.py:Commit:Commit": {},
        "ncclient/operations/third_party/juniper/rpc.py:Rollback:Rollback": {},
        "ncclient/transport/third_party/junos/parser.py:JunosXMLParser:JunosXMLParser": {},
        "ncclient/transport/third_party/junos/parser.py:SAXParser:SAXParser": {},
        "ncclient/devices/junos.py:JunosDeviceHandler:JunosDeviceHandler": {},
        "ncclient/devices/junos.py:JunosDeviceHandler:__init__": {
          "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
        }
      }
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_lock": {
      "ncclient/operations/rpc.py:RPC:__init__": {
        "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
      },
      "ncclient/operations/lock.py:Lock:request": {
        "ncclient/xml_.py:parent_ns": {}
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_lock_context_enter": {
      "ncclient/operations/lock.py:LockContext:__init__": {},
      "ncclient/operations/lock.py:LockContext:__enter__": {
        "ncclient/operations/rpc.py:RPC:__init__": {
          "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
        },
        "ncclient/operations/lock.py:Lock:request": {
          "ncclient/xml_.py:parent_ns": {}
        }
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_lock_context_exit": {
      "ncclient/operations/lock.py:LockContext:__init__": {},
      "ncclient/operations/lock.py:LockContext:__exit__": {
        "ncclient/operations/rpc.py:RPC:__init__": {
          "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
        },
        "ncclient/operations/lock.py:Unlock:request": {
          "ncclient/xml_.py:parent_ns": {}
        }
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_lock_default_param": {
      "ncclient/operations/rpc.py:RPC:__init__": {
        "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
      },
      "ncclient/operations/lock.py:Lock:request": {
        "ncclient/xml_.py:parent_ns": {}
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_unlock": {
      "ncclient/operations/rpc.py:RPC:__init__": {
        "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
      },
      "ncclient/operations/lock.py:Unlock:request": {
        "ncclient/xml_.py:parent_ns": {}
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "modified_testcases/unit/operations/test_lock.py:TestLock:test_unlock_default_param": {
      "ncclient/operations/rpc.py:RPC:__init__": {
        "ncclient/operations/rpc.py:RPCReplyListener:__new__": {}
      },
      "ncclient/operations/lock.py:Unlock:request": {
        "ncclient/xml_.py:parent_ns": {}
      },
      "ncclient/xml_.py:parent_ns": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_lock/ncclient-test_lock/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_lock\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 manager.py\n    \u2502   \u2514\u2500\u2500 make_device_handler\n    \u251c\u2500\u2500 operations/\n    \u2502   \u251c\u2500\u2500 lock.py\n    \u2502   \u2502   \u251c\u2500\u2500 Lock.request\n    \u2502   \u2502   \u251c\u2500\u2500 LockContext.__enter__\n    \u2502   \u2502   \u251c\u2500\u2500 LockContext.__exit__\n    \u2502   \u2502   \u251c\u2500\u2500 LockContext.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 Unlock.request\n    \u2502   \u2514\u2500\u2500 rpc.py\n    \u2502       \u2514\u2500\u2500 RPC.__init__\n    \u251c\u2500\u2500 transport/\n    \u2502   \u2514\u2500\u2500 errors.py\n    \u2502       \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n    \u2514\u2500\u2500 xml_.py\n        \u2514\u2500\u2500 parent_ns\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the testing and validation of NETCONF lock and unlock operations on configuration data stores (e.g., \"candidate\" and \"running\") for devices managed using the `ncclient` library. Its primary purpose is to ensure that the locking mechanisms operate correctly by issuing and verifying XML-based NETCONF requests, emulating device interactions within a unit test environment. It provides capabilities to test default and custom lock/unlock targets, as well as context management for locks, ensuring robust handling of configuration operations. By providing this functionality, the module helps developers verify the reliability and correctness of lock-related operations in NETCONF-based device management, reducing the risk of configuration conflicts or issues in multi-client environments.\n\n## FILE 1: ncclient/operations/lock.py\n\n- CLASS METHOD: LockContext.__enter__\n  - CLASS SIGNATURE: class LockContext(object):\n  - SIGNATURE: def __enter__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nHandles the entry into the lock context by attempting to lock the specified configuration datastore\nusing the `Lock` RPC. It uses the provided `session`, `device_handler`, and `target` attributes\nto establish the lock. If the lock operation fails, it raises an `rpc-error` as an exception. On success,\nthe context manager can be used to ensure proper resource management.\n\nParameters:\n- self: Reference to the instance of `LockContext`.\n  \nReturns:\n- self: The instance of `LockContext`, allowing for chaining within the context manager.\n\nDependencies:\n- `Lock`: Initiates the locking operation based on the `session` and `device_handler`.\n- `RaiseMode`: A constant from `ncclient.operations.rpc` set to `ERRORS`, indicating that errors during \n  the locking process should raise exceptions if encountered.\n- `target`: A string representing the name of the configuration datastore to be locked, defaulting to \"candidate\".\n\"\"\"\n```\n\n- CLASS METHOD: Lock.request\n  - CLASS SIGNATURE: class Lock(RPC):\n  - SIGNATURE: def request(self, target='candidate'):\n  - DOCSTRING: \n```python\n\"\"\"\nAllows the client to lock a specified configuration datastore in a device's configuration system.\n\nParameters:\n    target (str): The name of the configuration datastore to lock. Defaults to \"candidate\".\n\nReturns:\n    The result of the lock request as defined by the parent class's `_request` method.\n\nThis method utilizes the `new_ele` and `sub_ele` functions to create the appropriate XML format for the lock request. It constructs an XML element named \"lock\" with a nested \"target\" element indicating which datastore to lock. The request is then sent to the device, and any `rpc-error` will be handled in the broader context where this method is utilized.\n\"\"\"\n```\n\n- CLASS METHOD: Unlock.request\n  - CLASS SIGNATURE: class Unlock(RPC):\n  - SIGNATURE: def request(self, target='candidate'):\n  - DOCSTRING: \n```python\n\"\"\"\nReleases a previously obtained configuration lock for the specified datastore.\n\nParameters:\n- target (str): The name of the configuration datastore to unlock. Defaults to \"candidate\".\n\nReturns:\n- The result of the unlock operation as an XML element, indicating success or failure.\n\nInteractions:\nThis method constructs an XML element for the `<unlock>` RPC operation and uses the `_request` method inherited from the `RPC` class to send the request over the NETCONF session. The `new_ele` and `sub_ele` functions are used for XML element creation and manipulation, which are imported from the `ncclient.xml_` module.\n\"\"\"\n```\n\n- CLASS METHOD: LockContext.__exit__\n  - CLASS SIGNATURE: class LockContext(object):\n  - SIGNATURE: def __exit__(self, *args):\n  - DOCSTRING: \n```python\n\"\"\"\nHandles the cleanup operation when exiting the `LockContext` manager by releasing a lock on the specified configuration datastore.\n\nParameters:\n- `*args`: Variable length argument list that captures any exceptions raised in the block managed by the context manager (not used in this implementation).\n\nReturns:\n- `False`: Indicates that any exceptions raised should not be suppressed, allowing them to propagate.\n\nThe method interacts with the `Unlock` class, calling its `request` method to perform the unlock operation on the datastore specified by the `target` attribute. The `raise_mode` is set to `RaiseMode.ERRORS`, ensuring that any errors encountered during the unlock operation will raise exceptions. This functionality relies on the `self.session` and `self.device_handler` attributes initialized in the `LockContext` class.\n\"\"\"\n```\n\n- CLASS METHOD: LockContext.__init__\n  - CLASS SIGNATURE: class LockContext(object):\n  - SIGNATURE: def __init__(self, session, device_handler, target):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes the LockContext manager, which handles the locking and unlocking of a configuration datastore during a NETCONF session.\n\nParameters:\n- session (Session): An instance of the Session class from the ncclient.transport module, representing the NETCONF session.\n- device_handler: An object that handles device-specific operations.\n- target (str): The name of the configuration datastore to lock, with a default value of \"candidate\".\n\nThis constructor sets up the LockContext with the provided session, device handler, and target datastore for future lock and unlock operations during the context management lifecycle. It primarily interacts with the Lock and Unlock RPC classes for managing configuration locks, ensuring that any rpc-errors are handled properly as exceptions.\n\"\"\"\n```\n\n## FILE 2: ncclient/xml_.py\n\n- FUNCTION NAME: parent_ns\n  - SIGNATURE: def parent_ns(node):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the parent namespace URI of a given XML node.\n\nArgs:\n    node (lxml.etree._Element): The XML element whose parent namespace is to be accessed. This element must be part of an XML tree that utilizes namespaces.\n\nReturns:\n    str or None: The namespace URI associated with the element's prefix if it exists; otherwise, returns None.\n\nThis function interacts with the `nsmap` attribute of the `lxml.etree._Element` class, which is a mapping of prefixes to their corresponding namespace URIs for the XML document. The use of `node.prefix` allows the function to check if the node is associated with a namespace and retrieve the corresponding URI.\n\"\"\"\n```\n\n## FILE 3: ncclient/manager.py\n\n- FUNCTION NAME: make_device_handler\n  - SIGNATURE: def make_device_handler(device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a device handler object based on provided device parameters.\n\nParameters:\n- device_params (dict): A dictionary containing device-specific parameters. It may include:\n  - 'handler': A custom handler class to be instantiated (optional).\n  - 'name': A string representing the device name (default is \"default\").\n\nReturns:\n- An instance of the appropriate device handler class that provides device-specific functionality. If no handler is found, a default handler will be returned.\n\nDependencies:\n- The function imports device handler classes dynamically based on the device name from the `ncclient.devices` module, expecting the class name to follow the format `<DeviceName>DeviceHandler`. If the specified device name is not found in the module, a default handler is returned.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/operations/third_party/juniper/rpc.py:Command:Command\n    - ncclient/operations/third_party/juniper/rpc.py:Reboot:Reboot\n    - ncclient/operations/third_party/juniper/rpc.py:LoadConfiguration:LoadConfiguration\n    - ncclient/transport/third_party/junos/parser.py:SAXParser:SAXParser\n    - ncclient/devices/junos.py:JunosDeviceHandler:__init__\n    - ncclient/devices/junos.py:JunosDeviceHandler:JunosDeviceHandler\n    - ncclient/operations/third_party/juniper/rpc.py:Halt:Halt\n    - ncclient/operations/third_party/juniper/rpc.py:ExecuteRpc:ExecuteRpc\n    - ncclient/operations/third_party/juniper/rpc.py:GetConfiguration:GetConfiguration\n    - ncclient/transport/third_party/junos/parser.py:JunosXMLParser:JunosXMLParser\n    - ncclient/operations/third_party/juniper/rpc.py:CompareConfiguration:CompareConfiguration\n    - ncclient/operations/third_party/juniper/rpc.py:Commit:Commit\n    - ncclient/devices/default.py:DefaultDeviceHandler:DefaultDeviceHandler\n    - ncclient/operations/third_party/juniper/rpc.py:Rollback:Rollback\n\n## FILE 4: ncclient/operations/rpc.py\n\n- CLASS METHOD: RPC.__init__\n  - CLASS SIGNATURE: class RPC(object):\n  - SIGNATURE: def __init__(self, session, device_handler, async_mode=False, timeout=30, raise_mode=RaiseMode.NONE, huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the RPC class, which serves as a base for all RPC requests in the context of network communications via NETCONF.\n\nParameters:\n- session (Session): An instance of the `~ncclient.transport.Session` class, representing the current session to the NETCONF server.\n- device_handler (DeviceHandler): An instance of the `~ncclient.devices.*.*DeviceHandler` class, responsible for managing device-specific operations.\n- async_mode (bool, optional): Indicates whether the RPC request should be handled asynchronously (default is False).\n- timeout (int, optional): The maximum time to wait for a synchronous response before raising a timeout error (default is 30 seconds).\n- raise_mode (RaiseMode, optional): Specifies the mode for raising exceptions based on the returned RPC error (default is `RaiseMode.NONE`).\n- huge_tree (bool, optional): Flag to enable support for parsing large XML trees, useful for extensive configuration retrieval (default is False).\n\nAttributes:\n- _id (str): A unique identifier for the RPC request, generated using `uuid4().urn`.\n- _listener (RPCReplyListener): An instance of `RPCReplyListener`, which listens for replies related to this RPC request.\n- _reply (RPCReply): Stores the response received from the server, initialized to None.\n- _error (Exception): Stores any error encountered while processing the request, initialized to None.\n- _event (Event): A threading event that is set when a reply is received or an error occurs.\n\nDependencies:\n- This initializer checks for any required capabilities specified in the `DEPENDS` attribute and asserts their availability using the `_assert` method. If capabilities are missing, a `MissingCapabilityError` may be raised.\n\"\"\"\n```\n\n## FILE 5: ncclient/transport/errors.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/operations/lock.py": "\"\"\"Locking-related NETCONF operations\"\"\"\nfrom ncclient.xml_ import *\nfrom ncclient.operations.rpc import RaiseMode, RPC\n\nclass Lock(RPC):\n    \"\"\"`lock` RPC\"\"\"\n\nclass Unlock(RPC):\n    \"\"\"`unlock` RPC\"\"\"\n\nclass LockContext(object):\n    \"\"\"A context manager for the :class:`Lock` / :class:`Unlock` pair of RPC's.\n\n    Any `rpc-error` will be raised as an exception.\n\n    Initialise with (:class:`Session <ncclient.transport.Session>`) instance and lock target.\n    \"\"\"",
    "ncclient/xml_.py": "\"\"\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\"\"\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\nfrom ncclient import NCClientError\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\nclass XMLError(NCClientError):\n    pass\nBASE_NS_1_0 = 'urn:ietf:params:xml:ns:netconf:base:1.0'\nYANG_NS_1_0 = 'urn:ietf:params:xml:ns:yang:1'\nNXOS_1_0 = 'http://www.cisco.com/nxos:1.0'\nNXOS_IF = 'http://www.cisco.com/nxos:1.0:if_manager'\nTAILF_AAA_1_1 = 'http://tail-f.com/ns/aaa/1.1'\nTAILF_EXECD_1_1 = 'http://tail-f.com/ns/execd/1.1'\nCISCO_CPI_1_0 = 'http://www.cisco.com/cpi_10/schema'\nFLOWMON_1_0 = 'http://www.liberouter.org/ns/netopeer/flowmon/1.0'\nJUNIPER_1_1 = 'http://xml.juniper.net/xnm/1.1/xnm'\nHUAWEI_NS = 'http://www.huawei.com/netconf/vrp'\nHW_PRIVATE_NS = 'http://www.huawei.com/netconf/capability/base/1.0'\nH3C_DATA_1_0 = 'http://www.h3c.com/netconf/data:1.0'\nH3C_CONFIG_1_0 = 'http://www.h3c.com/netconf/config:1.0'\nH3C_ACTION_1_0 = 'http://www.h3c.com/netconf/action:1.0'\nNETCONF_MONITORING_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring'\nNETCONF_NOTIFICATION_NS = 'urn:ietf:params:xml:ns:netconf:notification:1.0'\nNETCONF_WITH_DEFAULTS_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults'\nALU_CONFIG = 'urn:alcatel-lucent.com:sros:ns:yang:conf-r13'\nSROS_GLOBAL_OPS_NS = 'urn:nokia.com:sros:ns:yang:sr:oper-global'\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        ElementTree._namespace_map[uri] = prefix\nfor ns, pre in six.iteritems({BASE_NS_1_0: 'nc', NETCONF_MONITORING_NS: 'ncm', NXOS_1_0: 'nxos', NXOS_IF: 'if', TAILF_AAA_1_1: 'aaa', TAILF_EXECD_1_1: 'execd', CISCO_CPI_1_0: 'cpi', FLOWMON_1_0: 'fm', JUNIPER_1_1: 'junos'}):\n    register_namespace(pre, ns)\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else '{%s}%s' % (ns, tag)\n'Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.'\n\ndef to_xml(ele, encoding='UTF-8', pretty_print=False):\n    \"\"\"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\"\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\ndef parse_root(raw):\n    \"\"\"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\"\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError('Element [%s] does not meet requirement' % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)):\n                req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError('Element [%s] does not have required attributes' % ele.tag)\n    return ele\nXPATH_NAMESPACES = {'re': 'http://exslt.org/regular-expressions'}\n\nclass NCElement(object):\n\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt = self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)), parser=self.__parser))), parser=self.__parser)\n        return self.__root\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        if elem.tag is not etree.Comment:\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag, ns), attrs, **extra)\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)",
    "ncclient/manager.py": "\"\"\"\nThis module is a thin layer of abstraction around the library.\nIt exposes all core functionality.\n\"\"\"\nfrom ncclient import operations\nfrom ncclient import transport\nimport socket\nimport logging\nimport functools\nfrom ncclient.xml_ import *\nlogger = logging.getLogger('ncclient.manager')\nOPERATIONS = {'get': operations.Get, 'get_config': operations.GetConfig, 'get_schema': operations.GetSchema, 'dispatch': operations.Dispatch, 'edit_config': operations.EditConfig, 'copy_config': operations.CopyConfig, 'validate': operations.Validate, 'commit': operations.Commit, 'discard_changes': operations.DiscardChanges, 'cancel_commit': operations.CancelCommit, 'delete_config': operations.DeleteConfig, 'lock': operations.Lock, 'unlock': operations.Unlock, 'create_subscription': operations.CreateSubscription, 'close_session': operations.CloseSession, 'kill_session': operations.KillSession, 'poweroff_machine': operations.PoweroffMachine, 'reboot_machine': operations.RebootMachine, 'rpc': operations.GenericRPC}\n'\\nDictionary of base method names and corresponding :class:`~ncclient.operations.RPC`\\nsubclasses. It is used to lookup operations, e.g. `get_config` is mapped to\\n:class:`~ncclient.operations.GetConfig`. It is thus possible to add additional\\noperations to the :class:`Manager` API.\\n'\n\ndef _extract_device_params(kwds):\n    device_params = kwds.pop('device_params', None)\n    return device_params\n\ndef _extract_manager_params(kwds):\n    manager_params = kwds.pop('manager_params', {})\n    if 'timeout' not in manager_params and 'timeout' in kwds:\n        manager_params['timeout'] = kwds['timeout']\n    return manager_params\n\ndef _extract_nc_params(kwds):\n    nc_params = kwds.pop('nc_params', {})\n    return nc_params\n\ndef connect_ssh(*args, **kwds):\n    \"\"\"Initialize a :class:`Manager` over the SSH transport.\n    For documentation of arguments see :meth:`ncclient.transport.SSHSession.connect`.\n\n    The underlying :class:`ncclient.transport.SSHSession` is created with\n    :data:`CAPABILITIES`. All the provided arguments are passed directly to its\n    implementation of :meth:`~ncclient.transport.SSHSession.connect`.\n\n    To customize the :class:`Manager`, add a `manager_params` dictionary in connection\n    parameters (e.g. `manager_params={'timeout': 60}` for a bigger RPC timeout parameter)\n\n    To invoke advanced vendor related operation add\n    `device_params={'name': '<vendor_alias>'}` in connection parameters. For the time,\n    'junos' and 'nexus' are supported for Juniper and Cisco Nexus respectively.\n\n    A custom device handler can be provided with\n    `device_params={'handler':<handler class>}` in connection parameters.\n\n    \"\"\"\n    device_params = _extract_device_params(kwds)\n    manager_params = _extract_manager_params(kwds)\n    nc_params = _extract_nc_params(kwds)\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_ssh_connect_params(kwds)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.SSHSession(device_handler)\n    try:\n        session.connect(*args, **kwds)\n    except Exception as ex:\n        if session.transport:\n            session.close()\n        raise\n    return Manager(session, device_handler, **manager_params)\n\ndef connect_tls(*args, **kwargs):\n    \"\"\"Initialize a :class:`Manager` over the TLS transport.\"\"\"\n    device_params = _extract_device_params(kwargs)\n    manager_params = _extract_manager_params(kwargs)\n    nc_params = _extract_nc_params(kwargs)\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.TLSSession(device_handler)\n    session.connect(*args, **kwargs)\n    return Manager(session, device_handler, **manager_params)\n\ndef connect_uds(*args, **kwargs):\n    \"\"\"Initialize a :class:`Manager` over the Unix Socket transport.\"\"\"\n    device_params = _extract_device_params(kwargs)\n    manager_params = _extract_manager_params(kwargs)\n    nc_params = _extract_nc_params(kwargs)\n    device_handler = make_device_handler(device_params)\n    device_handler.add_additional_netconf_params(nc_params)\n    session = transport.UnixSocketSession(device_handler)\n    session.connect(*args, **kwargs)\n    return Manager(session, device_handler, **manager_params)\n\ndef connect_ioproc(*args, **kwds):\n    device_params = _extract_device_params(kwds)\n    manager_params = _extract_manager_params(kwds)\n    if device_params:\n        import_string = 'ncclient.transport.third_party.'\n        import_string += device_params['name'] + '.ioproc'\n        third_party_import = __import__(import_string, fromlist=['IOProc'])\n    device_handler = make_device_handler(device_params)\n    session = third_party_import.IOProc(device_handler)\n    session.connect()\n    return Manager(session, device_handler, **manager_params)\n\ndef connect(*args, **kwds):\n    if 'host' in kwds:\n        host = kwds['host']\n        device_params = kwds.get('device_params', {})\n        if host == 'localhost' and device_params.get('name') == 'junos' and device_params.get('local'):\n            return connect_ioproc(*args, **kwds)\n        else:\n            return connect_ssh(*args, **kwds)\n\ndef call_home(*args, **kwds):\n    host = kwds['host']\n    port = kwds.get('port', 4334)\n    srv_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    srv_socket.bind((host, port))\n    srv_socket.settimeout(kwds.get('timeout', 10))\n    srv_socket.listen()\n    sock, remote_host = srv_socket.accept()\n    logger.info('Callhome connection initiated from remote host {0}'.format(remote_host))\n    kwds['sock'] = sock\n    return connect_ssh(*args, **kwds)\n\nclass Manager(object):\n    \"\"\"\n    For details on the expected behavior of the operations and their\n        parameters refer to :rfc:`6241`.\n\n    Manager instances are also context managers so you can use it like this::\n\n        with manager.connect(\"host\") as m:\n            # do your stuff\n\n    ... or like this::\n\n        m = manager.connect(\"host\")\n        try:\n            # do your stuff\n        finally:\n            m.close_session()\n    \"\"\"\n    HUGE_TREE_DEFAULT = False\n    'Default for `huge_tree` support for XML parsing of RPC replies (defaults to False)'\n\n    def __init__(self, session, device_handler, timeout=30):\n        self._session = session\n        self._async_mode = False\n        self._timeout = timeout\n        self._raise_mode = operations.RaiseMode.ALL\n        self._huge_tree = self.HUGE_TREE_DEFAULT\n        self._device_handler = device_handler\n        self._vendor_operations = {}\n        if device_handler:\n            self._vendor_operations.update(device_handler.add_additional_operations())\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.close_session()\n        return False\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n\n    def __set_async_mode(self, mode):\n        self._async_mode = mode\n\n    def __set_raise_mode(self, mode):\n        assert mode in (operations.RaiseMode.NONE, operations.RaiseMode.ERRORS, operations.RaiseMode.ALL)\n        self._raise_mode = mode\n\n    def execute(self, cls, *args, **kwds):\n        return cls(self._session, device_handler=self._device_handler, async_mode=self._async_mode, timeout=self._timeout, raise_mode=self._raise_mode, huge_tree=self._huge_tree).request(*args, **kwds)\n\n    def locked(self, target):\n        \"\"\"Returns a context manager for a lock on a datastore, where\n        *target* is the name of the configuration datastore to lock, e.g.::\n\n            with m.locked(\"running\"):\n                # do your stuff\n\n        ... instead of::\n\n            m.lock(\"running\")\n            try:\n                # do your stuff\n            finally:\n                m.unlock(\"running\")\n        \"\"\"\n        return operations.LockContext(self._session, self._device_handler, target)\n\n    def scp(self):\n        return self._session.scp()\n\n    def session(self):\n        raise NotImplementedError\n\n    def __getattr__(self, method):\n        if method in self._vendor_operations:\n            return functools.partial(self.execute, self._vendor_operations[method])\n        elif method in OPERATIONS:\n            return functools.partial(self.execute, OPERATIONS[method])\n        else:\n            'Parse args/kwargs correctly in order to build XML element'\n\n            def _missing(*args, **kwargs):\n                m = method.replace('_', '-')\n                root = new_ele(m)\n                if args:\n                    for arg in args:\n                        sub_ele(root, arg)\n                r = self.rpc(root)\n                return r\n            return _missing\n\n    def take_notification(self, block=True, timeout=None):\n        \"\"\"Attempt to retrieve one notification from the queue of received\n        notifications.\n\n        If block is True, the call will wait until a notification is\n        received.\n\n        If timeout is a number greater than 0, the call will wait that\n        many seconds to receive a notification before timing out.\n\n        If there is no notification available when block is False or\n        when the timeout has elapse, None will be returned.\n\n        Otherwise a :class:`~ncclient.operations.notify.Notification`\n        object will be returned.\n        \"\"\"\n        return self._session.take_notification(block, timeout)\n\n    @property\n    def client_capabilities(self):\n        \"\"\":class:`~ncclient.capabilities.Capabilities` object representing\n        the client's capabilities.\"\"\"\n        return self._session._client_capabilities\n\n    @property\n    def server_capabilities(self):\n        \"\"\":class:`~ncclient.capabilities.Capabilities` object representing\n        the server's capabilities.\"\"\"\n        return self._session._server_capabilities\n\n    @property\n    def channel_id(self):\n        return self._session._channel_id\n\n    @property\n    def channel_name(self):\n        return self._session._channel_name\n\n    @property\n    def session_id(self):\n        \"\"\"`session-id` assigned by the NETCONF server.\"\"\"\n        return self._session.id\n\n    @property\n    def connected(self):\n        \"\"\"Whether currently connected to the NETCONF server.\"\"\"\n        return self._session.connected\n    async_mode = property(fget=lambda self: self._async_mode, fset=__set_async_mode)\n    'Specify whether operations are executed asynchronously (`True`) or\\n    synchronously (`False`) (the default).'\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    'Specify the timeout for synchronous RPC requests.'\n    raise_mode = property(fget=lambda self: self._raise_mode, fset=__set_raise_mode)\n    'Specify which errors are raised as :exc:`~ncclient.operations.RPCError`\\n    exceptions. Valid values are the constants defined in\\n    :class:`~ncclient.operations.RaiseMode`.\\n    The default value is :attr:`~ncclient.operations.RaiseMode.ALL`.'\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\n        The default value is configurable through :attr:`~ncclient.manager.Manager.HUGE_TREE_DEFAULT`\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x",
    "ncclient/operations/rpc.py": "from threading import Event, Lock\nfrom uuid import uuid4\nfrom ncclient.xml_ import *\nfrom ncclient.logging_ import SessionLoggerAdapter\nfrom ncclient.transport import SessionListener\nfrom ncclient.operations import util\nfrom ncclient.operations.errors import OperationError, TimeoutExpiredError, MissingCapabilityError\nimport logging\nlogger = logging.getLogger('ncclient.operations.rpc')\n\nclass RPCError(OperationError):\n    \"\"\"Represents an `rpc-error`. It is a type of :exc:`OperationError` and can be raised as such.\"\"\"\n    tag_to_attr = {qualify('error-type'): '_type', qualify('error-tag'): '_tag', qualify('error-app-tag'): '_app_tag', qualify('error-severity'): '_severity', qualify('error-info'): '_info', qualify('error-path'): '_path', qualify('error-message'): '_message'}\n\n    def __init__(self, raw, errs=None):\n        self._raw = raw\n        if errs is None:\n            self._errlist = None\n            for attr in six.itervalues(RPCError.tag_to_attr):\n                setattr(self, attr, None)\n            for subele in raw:\n                attr = RPCError.tag_to_attr.get(subele.tag, None)\n                if attr is not None:\n                    setattr(self, attr, subele.text if attr != '_info' else to_xml(subele))\n            if self.message is not None:\n                OperationError.__init__(self, self.message)\n            else:\n                OperationError.__init__(self, self.to_dict())\n        else:\n            self._errlist = errs\n            errlist = []\n            for err in errs:\n                if err.severity:\n                    errsev = err.severity\n                else:\n                    errsev = 'undefined'\n                if err.message:\n                    errmsg = err.message\n                else:\n                    errmsg = 'not an error message in the reply. Enable debug'\n                errordict = {'severity': errsev, 'message': errmsg}\n                errlist.append(errordict)\n            self._severity = 'warning'\n            self._message = '\\n'.join(['%s: %s' % (err['severity'].strip(), err['message'].strip()) for err in errlist])\n            self.errors = errs\n            has_error = filter(lambda higherr: higherr['severity'] == 'error', errlist)\n            if has_error:\n                self._severity = 'error'\n            OperationError.__init__(self, self.message)\n\n    def to_dict(self):\n        return dict([(attr[1:], getattr(self, attr)) for attr in six.itervalues(RPCError.tag_to_attr)])\n\n    @property\n    def xml(self):\n        \"\"\"The `rpc-error` element as returned in XML.         Multiple errors are returned as list of RPC errors\"\"\"\n        return self._raw\n\n    @property\n    def type(self):\n        \"\"\"The contents of the `error-type` element.\"\"\"\n        return self._type\n\n    @property\n    def tag(self):\n        \"\"\"The contents of the `error-tag` element.\"\"\"\n        return self._tag\n\n    @property\n    def app_tag(self):\n        \"\"\"The contents of the `error-app-tag` element.\"\"\"\n        return self._app_tag\n\n    @property\n    def severity(self):\n        \"\"\"The contents of the `error-severity` element.\"\"\"\n        return self._severity\n\n    @property\n    def path(self):\n        \"\"\"The contents of the `error-path` element if present or `None`.\"\"\"\n        return self._path\n\n    @property\n    def message(self):\n        \"\"\"The contents of the `error-message` element if present or `None`.\"\"\"\n        return self._message\n\n    @property\n    def info(self):\n        \"\"\"XML string or `None`; representing the `error-info` element.\"\"\"\n        return self._info\n\n    @property\n    def errlist(self):\n        \"\"\"List of errors if this represents multiple errors, otherwise None.\"\"\"\n        return self._errlist\n\nclass RPCReply(object):\n    \"\"\"Represents an *rpc-reply*. Only concerns itself with whether the operation was successful.\n\n    *raw*: the raw unparsed reply\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n\n    .. note::\n        If the reply has not yet been parsed there is an implicit, one-time parsing overhead to\n        accessing some of the attributes defined by this class.\n    \"\"\"\n    ERROR_CLS = RPCError\n    'Subclasses can specify a different error class, but it should be a subclass of `RPCError`.'\n\n    def __init__(self, raw, huge_tree=False, parsing_error_transform=None):\n        self._raw = raw\n        self._parsing_error_transform = parsing_error_transform\n        self._parsed = False\n        self._root = None\n        self._errors = []\n        self._huge_tree = huge_tree\n\n    def __repr__(self):\n        return self._raw\n\n    def parse(self):\n        \"\"\"Parses the *rpc-reply*.\"\"\"\n        if self._parsed:\n            return\n        root = self._root = to_ele(self._raw, huge_tree=self._huge_tree)\n        ok = root.find(qualify('ok'))\n        if ok is None:\n            error = root.find('.//' + qualify('rpc-error'))\n            if error is not None:\n                for err in root.getiterator(error.tag):\n                    self._errors.append(self.ERROR_CLS(err))\n        try:\n            self._parsing_hook(root)\n        except Exception as e:\n            if self._parsing_error_transform is None:\n                exc_type, exc_value, exc_traceback = sys.exc_info()\n                six.reraise(exc_type, exc_value, exc_traceback)\n            self._parsing_error_transform(root)\n            self._parsing_hook(root)\n        self._parsed = True\n\n    def _parsing_hook(self, root):\n        \"\"\"No-op by default. Gets passed the *root* element for the reply.\"\"\"\n        pass\n\n    def set_parsing_error_transform(self, transform_function):\n        self._parsing_error_transform = transform_function\n\n    @property\n    def xml(self):\n        \"\"\"*rpc-reply* element as returned.\"\"\"\n        return self._raw\n\n    @property\n    def ok(self):\n        \"\"\"Boolean value indicating if there were no errors.\"\"\"\n        self.parse()\n        return not self.errors\n\n    @property\n    def error(self):\n        \"\"\"Returns the first :class:`RPCError` and `None` if there were no errors.\"\"\"\n        self.parse()\n        if self._errors:\n            return self._errors[0]\n        else:\n            return None\n\n    @property\n    def errors(self):\n        \"\"\"List of `RPCError` objects. Will be empty if there were no *rpc-error* elements in reply.\"\"\"\n        self.parse()\n        return self._errors\n\nclass RPCReplyListener(SessionListener):\n    creation_lock = Lock()\n\n    def __new__(cls, session, device_handler):\n        with RPCReplyListener.creation_lock:\n            instance = session.get_listener_instance(cls)\n            if instance is None:\n                instance = object.__new__(cls)\n                instance._lock = Lock()\n                instance._id2rpc = {}\n                instance._device_handler = device_handler\n                session.add_listener(instance)\n                instance.logger = SessionLoggerAdapter(logger, {'session': session})\n            return instance\n\n    def register(self, id, rpc):\n        with self._lock:\n            self._id2rpc[id] = rpc\n\n    def callback(self, root, raw):\n        tag, attrs = root\n        if self._device_handler.perform_qualify_check():\n            if tag != qualify('rpc-reply'):\n                return\n        if 'message-id' not in attrs:\n            raise OperationError(\"Could not find 'message-id' attribute in <rpc-reply>\")\n        else:\n            id = attrs['message-id']\n            with self._lock:\n                try:\n                    rpc = self._id2rpc[id]\n                    self.logger.debug('Delivering to %r', rpc)\n                    rpc.deliver_reply(raw)\n                except KeyError:\n                    raise OperationError(\"Unknown 'message-id': %s\" % id)\n                else:\n                    del self._id2rpc[id]\n\n    def errback(self, err):\n        try:\n            for rpc in six.itervalues(self._id2rpc):\n                rpc.deliver_error(err)\n        finally:\n            self._id2rpc.clear()\n\nclass RaiseMode(object):\n    \"\"\"\n    Define how errors indicated by RPC should be handled.\n\n    Note that any error_filters defined in the device handler will still be\n    applied, even if ERRORS or ALL is defined: If the filter matches, an exception\n    will NOT be raised.\n\n    \"\"\"\n    NONE = 0\n    \"Don't attempt to raise any type of `rpc-error` as :exc:`RPCError`.\"\n    ERRORS = 1\n    'Raise only when the `error-type` indicates it is an honest-to-god error.'\n    ALL = 2\n    \"Don't look at the `error-type`, always raise.\"\n\nclass RPC(object):\n    \"\"\"Base class for all operations, directly corresponding to *rpc* requests. Handles making the request, and taking delivery of the reply.\"\"\"\n    DEPENDS = []\n    \"Subclasses can specify their dependencies on capabilities as a list of URI's or abbreviated names, e.g. ':writable-running'. These are verified at the time of instantiation. If the capability is not available, :exc:`MissingCapabilityError` is raised.\"\n    REPLY_CLS = RPCReply\n    'By default :class:`RPCReply`. Subclasses can specify a :class:`RPCReply` subclass.'\n\n    def _wrap(self, subele):\n        ele = new_ele('rpc', {'message-id': self._id}, **self._device_handler.get_xml_extra_prefix_kwargs())\n        ele.append(subele)\n        return to_xml(ele)\n\n    def _request(self, op):\n        \"\"\"Implementations of :meth:`request` call this method to send the request and process the reply.\n\n        In synchronous mode, blocks until the reply is received and returns :class:`RPCReply`. Depending on the :attr:`raise_mode` a `rpc-error` element in the reply may lead to an :exc:`RPCError` exception.\n\n        In asynchronous mode, returns immediately, returning `self`. The :attr:`event` attribute will be set when the reply has been received (see :attr:`reply`) or an error occured (see :attr:`error`).\n\n        *op* is the operation to be requested as an :class:`~xml.etree.ElementTree.Element`\n        \"\"\"\n        self.logger.info('Requesting %r', self.__class__.__name__)\n        req = self._wrap(op)\n        self._session.send(req)\n        if self._async:\n            self.logger.debug('Async request, returning %r', self)\n            return self\n        else:\n            self.logger.debug('Sync request, will wait for timeout=%r', self._timeout)\n            self._event.wait(self._timeout)\n            if self._event.is_set():\n                if self._error:\n                    raise self._error\n                self._reply.parse()\n                if self._reply.error is not None and (not self._device_handler.is_rpc_error_exempt(self._reply.error.message)):\n                    if self._raise_mode == RaiseMode.ALL or (self._raise_mode == RaiseMode.ERRORS and self._reply.error.severity == 'error'):\n                        errlist = []\n                        errors = self._reply.errors\n                        if len(errors) > 1:\n                            raise RPCError(to_ele(self._reply._raw), errs=errors)\n                        else:\n                            raise self._reply.error\n                if self._device_handler.transform_reply():\n                    return NCElement(self._reply, self._device_handler.transform_reply(), huge_tree=self._huge_tree)\n                else:\n                    return self._reply\n            else:\n                raise TimeoutExpiredError('ncclient timed out while waiting for an rpc reply.')\n\n    def request(self):\n        \"\"\"Subclasses must implement this method. Typically only the request needs to be built as an\n        :class:`~xml.etree.ElementTree.Element` and everything else can be handed off to\n        :meth:`_request`.\"\"\"\n        pass\n\n    def _assert(self, capability):\n        \"\"\"Subclasses can use this method to verify that a capability is available with the NETCONF\n        server, before making a request that requires it. A :exc:`MissingCapabilityError` will be\n        raised if the capability is not available.\"\"\"\n        if capability not in self._session.server_capabilities:\n            raise MissingCapabilityError('Server does not support [%s]' % capability)\n\n    def deliver_reply(self, raw):\n        self._reply = self.REPLY_CLS(raw, huge_tree=self._huge_tree)\n        self._reply.set_parsing_error_transform(self._device_handler.reply_parsing_error_transform(self.REPLY_CLS))\n        self._event.set()\n\n    def deliver_error(self, err):\n        self._error = err\n        self._event.set()\n\n    @property\n    def reply(self):\n        \"\"\":class:`RPCReply` element if reply has been received or `None`\"\"\"\n        return self._reply\n\n    @property\n    def error(self):\n        \"\"\":exc:`Exception` type if an error occured or `None`.\n\n        .. note::\n            This represents an error which prevented a reply from being received. An *rpc-error*\n            does not fall in that category -- see `RPCReply` for that.\n        \"\"\"\n        return self._error\n\n    @property\n    def id(self):\n        \"\"\"The *message-id* for this RPC.\"\"\"\n        return self._id\n\n    @property\n    def session(self):\n        \"\"\"The `~ncclient.transport.Session` object associated with this RPC.\"\"\"\n        return self._session\n\n    @property\n    def event(self):\n        \"\"\":class:`~threading.Event` that is set when reply has been received or when an error preventing\n        delivery of the reply occurs.\n        \"\"\"\n        return self._event\n\n    def __set_async(self, async_mode=True):\n        self._async = async_mode\n        if async_mode and (not self._session.can_pipeline):\n            raise UserWarning('Asynchronous mode not supported for this device/session')\n\n    def __set_raise_mode(self, mode):\n        assert mode in (RaiseMode.NONE, RaiseMode.ERRORS, RaiseMode.ALL)\n        self._raise_mode = mode\n\n    def __set_timeout(self, timeout):\n        self._timeout = timeout\n    raise_mode = property(fget=lambda self: self._raise_mode, fset=__set_raise_mode)\n    'Depending on this exception raising mode, an `rpc-error` in the reply may be raised as an :exc:`RPCError` exception. Valid values are the constants defined in :class:`RaiseMode`. '\n    is_async = property(fget=lambda self: self._async, fset=__set_async)\n    \"Specifies whether this RPC will be / was requested asynchronously. By default RPC's are synchronous.\"\n    timeout = property(fget=lambda self: self._timeout, fset=__set_timeout)\n    'Timeout in seconds for synchronous waiting defining how long the RPC request will block on a reply before raising :exc:`TimeoutExpiredError`.\\n\\n    Irrelevant for asynchronous usage.\\n    '\n\n    @property\n    def huge_tree(self):\n        \"\"\"Whether `huge_tree` support for XML parsing of RPC replies is enabled (default=False)\"\"\"\n        return self._huge_tree\n\n    @huge_tree.setter\n    def huge_tree(self, x):\n        self._huge_tree = x\n\nclass GenericRPC(RPC):\n    \"\"\"Generic rpc commands wrapper\"\"\"\n    REPLY_CLS = RPCReply\n    'See :class:`RPCReply`.'\n\n    def request(self, rpc_command, source=None, filter=None, config=None, target=None, format=None):\n        \"\"\"\n        *rpc_command* specifies rpc command to be dispatched either in plain text or in xml element format (depending on command)\n\n        *target* name of the configuration datastore being edited\n\n        *source* name of the configuration datastore being queried\n\n        *config* is the configuration, which must be rooted in the `config` element. It can be specified either as a string or an :class:`~xml.etree.ElementTree.Element`.\n\n        *filter* specifies the portion of the configuration to retrieve (by default entire configuration is retrieved)\n\n        :seealso: :ref:`filter_params`\n\n        Examples of usage::\n\n            m.rpc('rpc_command')\n\n        or dispatch element like ::\n\n            rpc_command = new_ele('get-xnm-information')\n            sub_ele(rpc_command, 'type').text = \"xml-schema\"\n            m.rpc(rpc_command)\n        \"\"\"\n        if etree.iselement(rpc_command):\n            node = rpc_command\n        else:\n            node = new_ele(rpc_command)\n        if target is not None:\n            node.append(util.datastore_or_url('target', target, self._assert))\n        if source is not None:\n            node.append(util.datastore_or_url('source', source, self._assert))\n        if filter is not None:\n            node.append(util.build_filter(filter))\n        if config is not None:\n            node.append(validated_element(config, ('config', qualify('config'))))\n        return self._request(node)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass"
  }
}