{
  "dir_path": "/app/datashader",
  "package_name": "datashader",
  "sample_name": "datashader-test_utils",
  "src_dir": "datashader/",
  "test_dir": "datashader/tests/",
  "test_file": "datashader/tests/test_utils.py",
  "test_code": "from __future__ import annotations\nimport numpy as np\nfrom xarray import DataArray\n\nfrom datashader.datashape import dshape\nfrom datashader.utils import Dispatcher, apply, calc_res, isreal, orient_array\n\n\ndef test_Dispatcher():\n    foo = Dispatcher()\n    foo.register(int, lambda a, b, c=1: a + b + c)\n    foo.register(float, lambda a, b, c=1: a - b + c)\n    foo.register(object, lambda a, b, c=1: 10)\n\n    class Bar:\n        pass\n    b = Bar()\n    assert foo(1, 2) == 4\n    assert foo(1, 2.0, 3.0) == 6.0\n    assert foo(1.0, 2.0, 3.0) == 2.0\n    assert foo(b, 2) == 10\n\n\ndef test_isreal():\n    assert isreal('int32')\n    assert isreal(dshape('int32'))\n    assert isreal('?int32')\n    assert isreal('float64')\n    assert not isreal('complex64')\n    assert not isreal('{x: int64, y: float64}')\n\n\ndef test_apply():\n    def f(a, b, c=1, d=2):\n        return a + b + c + d\n    assert apply(f, (1, 2,)) == 6\n    assert apply(f, (1, 2,), dict(c=3)) == 8\n\n\ndef test_calc_res():\n    x = [5, 7]\n    y = [0, 1]\n    z = [[0, 0], [0, 0]]\n    dims = ('y', 'x')\n\n    # x and y increasing\n    xarr = DataArray(z, coords=dict(x=x, y=y), dims=dims)\n    xres, yres = calc_res(xarr)\n    assert xres == 2\n    assert yres == -1\n\n    # x increasing, y decreasing\n    xarr = DataArray(z, coords=dict(x=x, y=y[::-1]), dims=dims)\n    xres, yres = calc_res(xarr)\n    assert xres == 2\n    assert yres == 1\n\n    # x decreasing, y increasing\n    xarr = DataArray(z, coords=dict(x=x[::-1], y=y), dims=dims)\n    xres, yres = calc_res(xarr)\n    assert xres == -2\n    assert yres == -1\n\n    # x and y decreasing\n    xarr = DataArray(z, coords=dict(x=x[::-1], y=y[::-1]), dims=dims)\n    xres, yres = calc_res(xarr)\n    assert xres == -2\n    assert yres == 1\n\n\ndef test_orient_array():\n    x = [5, 7]\n    y = [0, 1]\n    z = np.array([[0, 1], [2, 3]])\n    dims = ('y', 'x')\n\n    # x and y increasing\n    xarr = DataArray(z, coords=dict(x=x, y=y), dims=dims)\n    arr = orient_array(xarr)\n    assert np.array_equal(arr, z)\n\n    # x increasing, y decreasing\n    xarr = DataArray(z, coords=dict(x=x, y=y[::-1]), dims=dims)\n    arr = orient_array(xarr)\n    assert np.array_equal(arr, z[::-1])\n\n    # x decreasing, y increasing\n    xarr = DataArray(z, coords=dict(x=x[::-1], y=y), dims=dims)\n    arr = orient_array(xarr)\n    assert np.array_equal(arr, z[:, ::-1])\n\n    # x and y decreasing\n    xarr = DataArray(z, coords=dict(x=x[::-1], y=y[::-1]), dims=dims)\n    arr = orient_array(xarr)\n    assert np.array_equal(arr, z[::-1, ::-1])\n",
  "GT_file_code": {
    "datashader/datashape/typesets.py": "\"\"\"\nTraits constituting sets of types.\n\"\"\"\n\nfrom itertools import chain\n\nfrom .coretypes import (Unit, int8, int16, int32, int64, uint8, uint16, uint32,\n                        uint64, float16, float32, float64, complex64,\n                        complex128, bool_, Decimal, TimeDelta, Option)\n\n\n__all__ = ['TypeSet', 'matches_typeset', 'signed', 'unsigned', 'integral',\n           'floating', 'complexes', 'boolean', 'numeric', 'scalar',\n           'maxtype']\n\n\nclass TypeSet(Unit):\n    \"\"\"\n    Create a new set of types. Keyword argument 'name' may create a registered\n    typeset for use in datashape type strings.\n    \"\"\"\n    __slots__ = '_order', 'name'\n\n    def __init__(self, *args, **kwds):\n        self._order = args\n        self.name = kwds.get('name')\n        if self.name:\n            register_typeset(self.name, self)\n\n    @property\n    def _set(self):\n        return set(self._order)\n\n    @property\n    def types(self):\n        return self._order\n\n    def __eq__(self, other):\n        return (isinstance(other, type(self)) and\n                self.name == other.name and self.types == other.types)\n\n    def __hash__(self):\n        return hash((self.name, self.types))\n\n    def __contains__(self, val):\n        return val in self._set\n\n    def __repr__(self):\n        if self.name:\n            return '{%s}' % (self.name,)\n        return \"%s(%s, name=%s)\" % (self.__class__.__name__, self._set,\n                                    self.name)\n\n    def __or__(self, other):\n        return TypeSet(*chain(self, other))\n\n    def __iter__(self):\n        return iter(self._order)\n\n    def __len__(self):\n        return len(self._set)\n\n\ndef matches_typeset(types, signature):\n    \"\"\"Match argument types to the parameter types of a signature\n\n    >>> matches_typeset(int32, integral)\n    True\n    >>> matches_typeset(float32, integral)\n    False\n    >>> matches_typeset(integral, real)\n    True\n    \"\"\"\n    if types in signature:\n        return True\n    match = True\n    for a, b in zip(types, signature):\n        check = isinstance(b, TypeSet)\n        if check and (a not in b) or (not check and a != b):\n            match = False\n            break\n    return match\n\n\nclass TypesetRegistry:\n    def __init__(self):\n        self.registry = {}\n        self.lookup = self.registry.get\n\n    def register_typeset(self, name, typeset):\n        if name in self.registry:\n            raise TypeError(\"TypeSet %s already defined with types %s\" %\n                            (name, self.registry[name].types))\n        self.registry[name] = typeset\n        return typeset\n\n    def __getitem__(self, key):\n        value = self.lookup(key)\n        if value is None:\n            raise KeyError(key)\n        return value\n\nregistry = TypesetRegistry()\nregister_typeset = registry.register_typeset\nlookup = registry.lookup\n\n#------------------------------------------------------------------------\n# Default Type Sets\n#------------------------------------------------------------------------\n\nsigned = TypeSet(int8, int16, int32, int64, name='signed')\nunsigned = TypeSet(uint8, uint16, uint32, uint64, name='unsigned')\nintegral = TypeSet(*[x for t in zip(signed, unsigned) for x in t],\n                   name='integral')\nfloating = TypeSet(float16, float32, float64, name='floating')\ncomplexes = TypeSet(complex64, complex128, name='complexes')\nboolean = TypeSet(bool_, name='boolean')\n\nreal = TypeSet(*integral | floating, name='real')\nnumeric = TypeSet(*integral | floating | complexes, name='numeric')\nscalar = TypeSet(*boolean | numeric, name='scalar')\n\n\nsupertype_map = {\n    int8: signed,\n    int16: signed,\n    int32: signed,\n    int64: signed,\n    uint8: unsigned,\n    uint16: unsigned,\n    uint32: unsigned,\n    uint64: unsigned,\n    float16: floating,\n    float32: floating,\n    float64: floating,\n    complex64: complexes,\n    complex128: complexes,\n    bool_: boolean\n}\n\n\ndef supertype(measure):\n    \"\"\"Get the super type of a concrete numeric type\n\n    Examples\n    --------\n    >>> supertype(int8)\n    {signed}\n\n    >>> supertype(float32)\n    {floating}\n\n    >>> supertype(complex128)\n    {complexes}\n\n    >>> supertype(bool_)\n    {boolean}\n\n    >>> supertype(Option(bool_))\n    {boolean}\n    \"\"\"\n    if isinstance(measure, Option):\n        measure = measure.ty\n    assert matches_typeset(measure, scalar), 'measure must be numeric'\n    return supertype_map[measure]\n\n\ndef maxtype(measure):\n    \"\"\"Get the maximum width for a particular numeric type\n\n    Examples\n    --------\n    >>> maxtype(int8)\n    ctype(\"int64\")\n\n    >>> maxtype(Option(float64))\n    Option(ty=ctype(\"float64\"))\n\n    >>> maxtype(bool_)\n    ctype(\"bool\")\n\n    >>> maxtype(Decimal(11, 2))\n    Decimal(precision=11, scale=2)\n\n    >>> maxtype(Option(Decimal(11, 2)))\n    Option(ty=Decimal(precision=11, scale=2))\n\n    >>> maxtype(TimeDelta(unit='ms'))\n    TimeDelta(unit='ms')\n\n    >>> maxtype(Option(TimeDelta(unit='ms')))\n    Option(ty=TimeDelta(unit='ms'))\n    \"\"\"\n    measure = measure.measure\n    isoption = isinstance(measure, Option)\n    if isoption:\n        measure = measure.ty\n    if (not matches_typeset(measure, scalar) and\n        not isinstance(measure, (Decimal, TimeDelta))):\n\n        raise TypeError('measure must be numeric')\n\n    if measure == bool_:\n        result = bool_\n    elif isinstance(measure, (Decimal, TimeDelta)):\n        result = measure\n    else:\n        result = max(supertype(measure).types, key=lambda x: x.itemsize)\n    return Option(result) if isoption else result\n",
    "datashader/utils.py": "from __future__ import annotations\n\nimport os\nimport re\n\nfrom inspect import getmro\n\nimport numba as nb\nimport numpy as np\nimport pandas as pd\n\nfrom toolz import memoize\nfrom xarray import DataArray\n\nimport datashader.datashape as datashape\n\ntry:\n    import dask.dataframe as dd\nexcept ImportError:\n    dd = None\n\ntry:\n    from datashader.datatypes import RaggedDtype\nexcept ImportError:\n    RaggedDtype = type(None)\n\ntry:\n    import cudf\nexcept Exception:\n    cudf = None\n\ntry:\n    from geopandas.array import GeometryDtype as gpd_GeometryDtype\nexcept ImportError:\n    gpd_GeometryDtype = type(None)\n\ntry:\n    from spatialpandas.geometry import GeometryDtype\nexcept ImportError:\n    GeometryDtype = type(None)\n\n\nclass VisibleDeprecationWarning(UserWarning):\n    \"\"\"Visible deprecation warning.\n\n    By default, python will not show deprecation warnings, so this class\n    can be used when a very visible warning is helpful, for example because\n    the usage is most likely a user bug.\n    \"\"\"\n\n\nngjit = nb.jit(nopython=True, nogil=True)\nngjit_parallel = nb.jit(nopython=True, nogil=True, parallel=True)\n\n# Get and save the Numba version, will be used to limit functionality\nnumba_version = tuple([int(x) for x in re.match(\n                            r\"([0-9]+)\\.([0-9]+)\\.([0-9]+)\",\n                            nb.__version__).groups()])\n\n\nclass Expr:\n    \"\"\"Base class for expression-like objects.\n\n    Implements hashing and equality checks. Subclasses should implement an\n    ``inputs`` attribute/property, containing a tuple of everything that fully\n    defines that expression.\n    \"\"\"\n    def __hash__(self):\n        return hash((type(self), self._hashable_inputs()))\n\n    def __eq__(self, other):\n        return (type(self) is type(other) and\n                self._hashable_inputs() == other._hashable_inputs())\n\n    def __ne__(self, other):\n        return not self == other\n\n    def _hashable_inputs(self):\n        \"\"\"\n        Return a version of the inputs tuple that is suitable for hashing and\n        equality comparisons\n        \"\"\"\n        result = []\n        for ip in self.inputs:\n            if isinstance(ip, (list, set)):\n                result.append(tuple(ip))\n            elif isinstance(ip, np.ndarray):\n                result.append(ip.tobytes())\n            else:\n                result.append(ip)\n\n        return tuple(result)\n\n\nclass Dispatcher:\n    \"\"\"Simple single dispatch.\"\"\"\n    def __init__(self):\n        self._lookup = {}\n\n    def register(self, typ, func=None):\n        \"\"\"Register dispatch of `func` on arguments of type `typ`\"\"\"\n        if func is None:\n            return lambda f: self.register(typ, f)\n        if isinstance(typ, tuple):\n            for t in typ:\n                self.register(t, func)\n        else:\n            self._lookup[typ] = func\n        return func\n\n    def __call__(self, head, *rest, **kwargs):\n        # We dispatch first on type(head), and fall back to iterating through\n        # the mro. This is significantly faster in the common case where\n        # type(head) is in the lookup, with only a small penalty on fall back.\n        lk = self._lookup\n        typ = type(head)\n        if typ in lk:\n            return lk[typ](head, *rest, **kwargs)\n        for cls in getmro(typ)[1:]:\n            if cls in lk:\n                return lk[cls](head, *rest, **kwargs)\n        raise TypeError(\"No dispatch for {0} type\".format(typ))\n\n\ndef isrealfloat(dt):\n    \"\"\"Check if a datashape is numeric and real.\n\n    Example\n    -------\n    >>> isrealfloat('int32')\n    False\n    >>> isrealfloat('float64')\n    True\n    >>> isrealfloat('string')\n    False\n    >>> isrealfloat('complex64')\n    False\n    \"\"\"\n    dt = datashape.predicates.launder(dt)\n    return isinstance(dt, datashape.Unit) and dt in datashape.typesets.floating\n\n\ndef isreal(dt):\n    \"\"\"Check if a datashape is numeric and real.\n\n    Example\n    -------\n    >>> isreal('int32')\n    True\n    >>> isreal('float64')\n    True\n    >>> isreal('string')\n    False\n    >>> isreal('complex64')\n    False\n    \"\"\"\n    dt = datashape.predicates.launder(dt)\n    return isinstance(dt, datashape.Unit) and dt in datashape.typesets.real\n\n\ndef nansum_missing(array, axis):\n    \"\"\"nansum where all-NaN values remain NaNs.\n\n    Note: In NumPy <=1.9 NaN is returned for slices that are\n    all NaN, while later versions return 0. This function emulates\n    the older behavior, which allows using NaN as a missing value\n    indicator.\n\n    Parameters\n    ----------\n    array: Array to sum over\n    axis:  Axis to sum over\n    \"\"\"\n    T = list(range(array.ndim))\n    T.remove(axis)\n    T.insert(0, axis)\n    array = array.transpose(T)\n    missing_vals = np.isnan(array)\n    all_empty = np.all(missing_vals, axis=0)\n    set_to_zero = missing_vals & ~all_empty\n    return np.where(set_to_zero, 0, array).sum(axis=0)\n\n\ndef calc_res(raster):\n    \"\"\"Calculate the resolution of xarray.DataArray raster and return it as the\n    two-tuple (xres, yres). yres is positive if it is decreasing.\n    \"\"\"\n    h, w = raster.shape[-2:]\n    ydim, xdim = raster.dims[-2:]\n    xcoords = raster[xdim].values\n    ycoords = raster[ydim].values\n    xres = (xcoords[-1] - xcoords[0]) / (w - 1)\n    yres = (ycoords[0] - ycoords[-1]) / (h - 1)\n    return xres, yres\n\n\ndef calc_bbox(xs, ys, res):\n    \"\"\"Calculate the bounding box of a raster, and return it in a four-element\n    tuple: (xmin, ymin, xmax, ymax). This calculation assumes the raster is\n    uniformly sampled (equivalent to a flat-earth assumption, for geographic\n    data) so that an affine transform (using the \"Augmented Matrix\" approach)\n    suffices:\n    https://en.wikipedia.org/wiki/Affine_transformation#Augmented_matrix\n\n    Parameters\n    ----------\n    xs : numpy.array\n        1D NumPy array of floats representing the x-values of a raster. This\n        likely originated from an xarray.DataArray or xarray.Dataset object\n        (xr.open_rasterio).\n    ys : numpy.array\n        1D NumPy array of floats representing the y-values of a raster. This\n        likely originated from an xarray.DataArray or xarray.Dataset object\n        (xr.open_rasterio).\n    res : tuple\n        Two-tuple (int, int) which includes x and y resolutions (aka \"grid/cell\n        sizes\"), respectively.\n    \"\"\"\n    xbound = xs.max() if res[0] < 0 else xs.min()\n    ybound = ys.min() if res[1] < 0 else ys.max()\n\n    xmin = ymin = np.inf\n    xmax = ymax = -np.inf\n    Ab = np.array([[res[0],  0.,      xbound],\n                   [0.,      -res[1], ybound],\n                   [0.,      0.,      1.]])\n    for x_, y_ in [(0, 0), (0, len(ys)), (len(xs), 0), (len(xs), len(ys))]:\n        x, y, _ = np.dot(Ab, np.array([x_, y_, 1.]))\n        if x < xmin:\n            xmin = x\n        if x > xmax:\n            xmax = x\n        if y < ymin:\n            ymin = y\n        if y > ymax:\n            ymax = y\n    xpad, ypad = res[0]/2., res[1]/2.\n    return xmin-xpad, ymin+ypad, xmax-xpad, ymax+ypad\n\n\ndef get_indices(start, end, coords, res):\n    \"\"\"\n    Transform continuous start and end coordinates into array indices.\n\n    Parameters\n    ----------\n    start : float\n        coordinate of the lower bound.\n    end : float\n        coordinate of the upper bound.\n    coords : numpy.ndarray\n        coordinate values along the axis.\n    res : tuple\n        Resolution along an axis (aka \"grid/cell sizes\")\n    \"\"\"\n    size = len(coords)\n    half = abs(res)/2.\n    vmin, vmax = coords.min(), coords.max()\n    span = vmax-vmin\n    start, end = start+half-vmin, end-half-vmin\n    sidx, eidx = int((start/span)*size), int((end/span)*size)\n    if eidx < sidx:\n        return sidx, sidx\n    return sidx, eidx\n\n\ndef _flip_array(array, xflip, yflip):\n    # array may have 2 or 3 dimensions, last one is x-dimension, last but one is y-dimension.\n    if yflip:\n        array = array[..., ::-1, :]\n    if xflip:\n        array = array[..., :, ::-1]\n    return array\n\n\ndef orient_array(raster, res=None, layer=None):\n    \"\"\"\n    Reorients the array to a canonical orientation depending on\n    whether the x and y-resolution values are positive or negative.\n\n    Parameters\n    ----------\n    raster : DataArray\n        xarray DataArray to be reoriented\n    res : tuple\n        Two-tuple (int, int) which includes x and y resolutions (aka \"grid/cell\n        sizes\"), respectively.\n    layer : int\n        Index of the raster layer to be reoriented (optional)\n\n    Returns\n    -------\n    array : numpy.ndarray\n        Reoriented 2d NumPy ndarray\n    \"\"\"\n    if res is None:\n        res = calc_res(raster)\n    array = raster.data\n    if layer is not None:\n        array = array[layer-1]\n    r0zero = np.timedelta64(0, 'ns') if isinstance(res[0], np.timedelta64) else 0\n    r1zero = np.timedelta64(0, 'ns') if isinstance(res[1], np.timedelta64) else 0\n    xflip = res[0] < r0zero\n    yflip = res[1] > r1zero\n    array = _flip_array(array, xflip, yflip)\n    return array\n\n\ndef downsample_aggregate(aggregate, factor, how='mean'):\n    \"\"\"Create downsampled aggregate factor in pixels units\"\"\"\n    ys, xs = aggregate.shape[:2]\n    crarr = aggregate[:ys-(ys % int(factor)), :xs-(xs % int(factor))]\n    concat = np.concatenate([[crarr[i::factor, j::factor]\n                            for i in range(factor)]\n                            for j in range(factor)])\n\n    if how == 'mean':\n        return np.nanmean(concat, axis=0)\n    elif how == 'sum':\n        return np.nansum(concat, axis=0)\n    elif how == 'max':\n        return np.nanmax(concat, axis=0)\n    elif how == 'min':\n        return np.nanmin(concat, axis=0)\n    elif how == 'median':\n        return np.nanmedian(concat, axis=0)\n    elif how == 'std':\n        return np.nanstd(concat, axis=0)\n    elif how == 'var':\n        return np.nanvar(concat, axis=0)\n    else:\n        raise ValueError(\"Invalid 'how' downsample method. Options mean, sum, max, min, median, \"\n                         \"std, var\")\n\n\ndef summarize_aggregate_values(aggregate, how='linear', num=180):\n    \"\"\"Helper function similar to np.linspace which return values from aggregate min value to\n    aggregate max value in either linear or log space.\n    \"\"\"\n\n    max_val = np.nanmax(aggregate.values)\n    min_val = np.nanmin(aggregate.values)\n\n    if min_val == 0:\n        min_val = aggregate.data[aggregate.data > 0].min()\n\n    if how == 'linear':\n        vals = np.linspace(min_val, max_val, num)[None, :]\n    else:\n        vals = (np.logspace(0,\n                            np.log1p(max_val - min_val),\n                            base=np.e, num=num,\n                            dtype=min_val.dtype) + min_val)[None, :]\n\n    return DataArray(vals), min_val, max_val\n\n\ndef hold(f):\n    '''\n    simple arg caching decorator\n    '''\n    last = []\n\n    def _(*args):\n        if not last or last[0] != args:\n            last[:] = args, f(*args)\n        return last[1]\n    return _\n\n\ndef export_image(img, filename, fmt=\".png\", _return=True, export_path=\".\", background=\"\"):\n    \"\"\"Given a datashader Image object, saves it to a disk file in the requested format\"\"\"\n\n    from datashader.transfer_functions import set_background\n\n    if not os.path.exists(export_path):\n        os.mkdir(export_path)\n\n    if background:\n        img = set_background(img, background)\n\n    img.to_pil().save(os.path.join(export_path, filename + fmt))\n    return img if _return else None\n\n\ndef lnglat_to_meters(longitude, latitude):\n    \"\"\"\n    Projects the given (longitude, latitude) values into Web Mercator\n    coordinates (meters East of Greenwich and meters North of the Equator).\n\n    Longitude and latitude can be provided as scalars, Pandas columns,\n    or Numpy arrays, and will be returned in the same form.  Lists\n    or tuples will be converted to Numpy arrays.\n\n    Examples:\n       easting, northing = lnglat_to_meters(-74,40.71)\n\n       easting, northing = lnglat_to_meters(np.array([-74]),np.array([40.71]))\n\n       df=pandas.DataFrame(dict(longitude=np.array([-74]),latitude=np.array([40.71])))\n       df.loc[:, 'longitude'], df.loc[:, 'latitude'] = lnglat_to_meters(df.longitude,df.latitude)\n    \"\"\"\n    if isinstance(longitude, (list, tuple)):\n        longitude = np.array(longitude)\n    if isinstance(latitude, (list, tuple)):\n        latitude = np.array(latitude)\n\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n    return (easting, northing)\n\n\n# Heavily inspired by odo\ndef dshape_from_pandas_helper(col):\n    \"\"\"Return an object from datashader.datashape.coretypes given a column from a pandas\n    dataframe.\n    \"\"\"\n    if (isinstance(col.dtype, type(pd.Categorical.dtype)) or\n            isinstance(col.dtype, pd.api.types.CategoricalDtype) or\n            cudf and isinstance(col.dtype, cudf.core.dtypes.CategoricalDtype)):\n        # Compute category dtype\n        pd_categories = col.cat.categories\n        if dd and isinstance(pd_categories, dd.Index):\n            pd_categories = pd_categories.compute()\n        if cudf and isinstance(pd_categories, cudf.Index):\n            pd_categories = pd_categories.to_pandas()\n\n        categories = np.array(pd_categories)\n\n        if categories.dtype.kind == 'U':\n            categories = categories.astype('object')\n\n        cat_dshape = datashape.dshape('{} * {}'.format(\n            len(col.cat.categories),\n            categories.dtype,\n        ))\n        return datashape.Categorical(categories,\n                                     type=cat_dshape,\n                                     ordered=col.cat.ordered)\n    elif col.dtype.kind == 'M':\n        tz = getattr(col.dtype, 'tz', None)\n        if tz is not None:\n            # Pandas stores this as a pytz.tzinfo, but DataShape wants a string\n            tz = str(tz)\n        return datashape.Option(datashape.DateTime(tz=tz))\n    elif isinstance(col.dtype, (RaggedDtype, GeometryDtype)):\n        return col.dtype\n    elif gpd_GeometryDtype and isinstance(col.dtype, gpd_GeometryDtype):\n        return col.dtype\n    dshape = datashape.CType.from_numpy_dtype(col.dtype)\n    dshape = datashape.string if dshape == datashape.object_ else dshape\n    if dshape in (datashape.string, datashape.datetime_):\n        return datashape.Option(dshape)\n    return dshape\n\n\ndef dshape_from_pandas(df):\n    \"\"\"Return a datashape.DataShape object given a pandas dataframe.\"\"\"\n    return len(df) * datashape.Record([(k, dshape_from_pandas_helper(df[k]))\n                                       for k in df.columns])\n\n\n@memoize(key=lambda args, kwargs: tuple(args[0].__dask_keys__()))\ndef dshape_from_dask(df):\n    \"\"\"Return a datashape.DataShape object given a dask dataframe.\"\"\"\n    cat_columns = [\n        col for col in df.columns\n        if (isinstance(df[col].dtype, type(pd.Categorical.dtype)) or\n            isinstance(df[col].dtype, pd.api.types.CategoricalDtype))\n           and not getattr(df[col].cat, 'known', True)]\n    df = df.categorize(cat_columns, index=False)\n    # get_partition(0) used below because categories are sometimes repeated\n    # for dask-cudf DataFrames with multiple partitions\n    return datashape.var * datashape.Record([\n        (k, dshape_from_pandas_helper(df[k].get_partition(0))) for k in df.columns\n    ]), df\n\n\ndef dshape_from_xarray_dataset(xr_ds):\n    \"\"\"Return a datashape.DataShape object given a xarray Dataset.\"\"\"\n    return datashape.var * datashape.Record([\n        (k, dshape_from_pandas_helper(xr_ds[k]))\n        for k in list(xr_ds.data_vars) + list(xr_ds.coords)\n    ])\n\n\ndef dataframe_from_multiple_sequences(x_values, y_values):\n   \"\"\"\n   Converts a set of multiple sequences (eg: time series), stored as a 2 dimensional\n   numpy array into a pandas dataframe that can be plotted by datashader.\n   The pandas dataframe eventually contains two columns ('x' and 'y') with the data.\n   Each time series is separated by a row of NaNs.\n   Discussion at: https://github.com/bokeh/datashader/issues/286#issuecomment-334619499\n\n   x_values: 1D numpy array with the values to be plotted on the x axis (eg: time)\n   y_values: 2D numpy array with the sequences to be plotted of shape (num sequences X length of\n             each sequence)\n\n   \"\"\"\n\n   # Add a NaN at the end of the array of x values\n   x = np.zeros(x_values.shape[0] + 1)\n   x[-1] = np.nan\n   x[:-1] = x_values\n\n   # Tile this array of x values: number of repeats = number of sequences/time series in the data\n   x = np.tile(x, y_values.shape[0])\n\n   # Add a NaN at the end of every sequence in y_values\n   y = np.zeros((y_values.shape[0], y_values.shape[1] + 1))\n   y[:, -1] = np.nan\n   y[:, :-1] = y_values\n\n   # Return a dataframe with this new set of x and y values\n   return pd.DataFrame({'x': x, 'y': y.flatten()})\n\n\ndef _pd_mesh(vertices, simplices):\n    \"\"\"Helper for ``datashader.utils.mesh()``. Both arguments are assumed to be\n    Pandas DataFrame objects.\n    \"\"\"\n    # Winding auto-detect\n    winding = [0, 1, 2]\n    first_tri = vertices.values[simplices.values[0, winding].astype(np.int64), :2]\n    a, b, c = first_tri\n    p1, p2 = b - a, c - a\n    cross_product = p1[0] * p2[1] - p1[1] * p2[0]\n    if cross_product >= 0:\n        winding = [0, 2, 1]\n\n    # Construct mesh by indexing into vertices with simplex indices\n    vertex_idxs = simplices.values[:, winding]\n    if not vertex_idxs.dtype == 'int64':\n        vertex_idxs = vertex_idxs.astype(np.int64)\n    vals = np.take(vertices.values, vertex_idxs, axis=0)\n    vals = vals.reshape(np.prod(vals.shape[:2]), vals.shape[2])\n    res = pd.DataFrame(vals, columns=vertices.columns)\n\n    # If vertices don't have weights, use simplex weights\n    verts_have_weights = len(vertices.columns) > 2\n    if not verts_have_weights:\n        weight_col = simplices.columns[3]\n        res[weight_col] = simplices.values[:, 3].repeat(3)\n\n    return res\n\n\ndef _dd_mesh(vertices, simplices):\n    \"\"\"Helper for ``datashader.utils.mesh()``. Both arguments are assumed to be\n    Dask DataFrame objects.\n    \"\"\"\n    # Construct mesh by indexing into vertices with simplex indices\n    # TODO: For dask: avoid .compute() calls\n    res = _pd_mesh(vertices.compute(), simplices.compute())\n\n    # Compute a chunksize that will not split the vertices of a single\n    # triangle across partitions\n    approx_npartitions = max(vertices.npartitions, simplices.npartitions)\n    chunksize = int(np.ceil(len(res) / (3*approx_npartitions)) * 3)\n\n    # Create dask dataframe\n    res = dd.from_pandas(res, chunksize=chunksize)\n    return res\n\n\ndef mesh(vertices, simplices):\n    \"\"\"Merge vertices and simplices into a triangular mesh, suitable to be\n    passed into the ``Canvas.trimesh()`` method via the ``mesh``\n    keyword-argument. Both arguments are assumed to be Dask DataFrame\n    objects.\n    \"\"\"\n    # Verify the simplex data structure\n    assert simplices.values.shape[1] >= 3, ('At least three vertex columns '\n                                            'are required for the triangle '\n                                            'definition')\n    simplices_all_ints = simplices.dtypes.iloc[:3].map(\n        lambda dt: np.issubdtype(dt, np.integer)\n    ).all()\n    assert simplices_all_ints, ('Simplices must be integral. You may '\n                                'consider casting simplices to integers '\n                                'with \".astype(int)\"')\n\n    assert len(vertices.columns) > 2 or simplices.values.shape[1] > 3, \\\n        'If no vertex weight column is provided, a triangle weight column is required.'\n\n\n    if dd and isinstance(vertices, dd.DataFrame) and isinstance(simplices, dd.DataFrame):\n        return _dd_mesh(vertices, simplices)\n\n    return _pd_mesh(vertices, simplices)\n\n\ndef apply(func, args, kwargs=None):\n    if kwargs:\n        return func(*args, **kwargs)\n    else:\n        return func(*args)\n\n\n@ngjit\ndef isnull(val):\n    \"\"\"\n    Equivalent to isnan for floats, but also numba compatible with integers\n    \"\"\"\n    return not (val <= 0 or val > 0)\n\n\n@ngjit\ndef isminus1(val):\n    \"\"\"\n    Check for -1 which is equivalent to NaN for some integer aggregations\n    \"\"\"\n    return val == -1\n\n\n@ngjit_parallel\ndef nanfirst_in_place(ret, other):\n    \"\"\"First of 2 arrays but taking nans into account.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]) and not isnull(other[i]):\n            ret[i] = other[i]\n\n\n@ngjit_parallel\ndef nanlast_in_place(ret, other):\n    \"\"\"Last of 2 arrays but taking nans into account.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if not isnull(other[i]):\n            ret[i] = other[i]\n\n\n@ngjit_parallel\ndef nanmax_in_place(ret, other):\n    \"\"\"Max of 2 arrays but taking nans into account.  Could use np.nanmax but\n    would need to replace zeros with nans where both arrays are nans.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]) and other[i] > ret[i]:\n            ret[i] = other[i]\n\n\n@ngjit_parallel\ndef nanmin_in_place(ret, other):\n    \"\"\"Min of 2 arrays but taking nans into account.  Could use np.nanmin but\n    would need to replace zeros with nans where both arrays are nans.\n    Accepts 3D (ny, nx, ncat) and 2D (ny, nx) arrays.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]) and other[i] < ret[i]:\n            ret[i] = other[i]\n\n\n@ngjit\ndef shift_and_insert(target, value, index):\n    \"\"\"Insert a value into a 1D array at a particular index, but before doing\n    that shift the previous values along one to make room. For use in\n    ``FloatingNReduction`` classes such as ``max_n`` and ``first_n`` which\n    store ``n`` values per pixel.\n\n    Parameters\n    ----------\n    target : 1d numpy array\n        Target pixel array.\n\n    value : float\n        Value to insert into target pixel array.\n\n    index : int\n        Index to insert at.\n\n    Returns\n    -------\n    Index beyond insertion, i.e. where the first shifted value now sits.\n    \"\"\"\n    n = len(target)\n    for i in range(n-1, index, -1):\n        target[i] = target[i-1]\n    target[index] = value\n    return index + 1\n\n\n@ngjit\ndef _nanfirst_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanfirst_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]):\n                    #\u00a0Always insert after existing values, so no shifting required.\n                    ret_pixel[i] = other_value\n                    istart = i+1\n                    break\n\n\n@ngjit_parallel\ndef nanfirst_n_in_place_4d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanfirst_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit_parallel\ndef nanfirst_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanfirst_n_impl(ret[y, x], other[y, x])\n\n\n@ngjit\ndef _nanlast_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanlast_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                # Always insert at istart index.\n                istart = shift_and_insert(ret_pixel, other_value, istart)\n                break\n\n\n@ngjit_parallel\ndef nanlast_n_in_place_4d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanlast_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit_parallel\ndef nanlast_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanlast_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanlast_n_impl(ret[y, x], other[y, x])\n\n\n@ngjit\ndef _nanmax_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanmax_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]) or other_value > ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n\n@ngjit_parallel\ndef nanmax_n_in_place_4d(ret, other):\n    \"\"\"Combine two max-n arrays, taking nans into account. Max-n arrays are 4D\n    with shape (ny, nx, ncat, n) where ny and nx are the number of pixels,\n    ncat the number of categories (will be 1 if not using a categorical\n    reduction) and the last axis containing n values in descending order.\n    If there are fewer than n values it is padded with nans.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanmax_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit_parallel\ndef nanmax_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanmax_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanmax_n_impl(ret[y, x], other[y, x])\n\n\n@ngjit\ndef _nanmin_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanmin_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]) or other_value < ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n\n@ngjit_parallel\ndef nanmin_n_in_place_4d(ret, other):\n    \"\"\"Combine two min-n arrays, taking nans into account. Min-n arrays are 4D\n    with shape (ny, nx, ncat, n) where ny and nx are the number of pixels,\n    ncat the number of categories (will be 1 if not using a categorical\n    reduction) and the last axis containing n values in ascending order.\n    If there are fewer than n values it is padded with nans.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanmin_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit_parallel\ndef nanmin_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanmin_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanmin_n_impl(ret[y, x], other[y, x])\n\n\n@ngjit_parallel\ndef nansum_in_place(ret, other):\n    \"\"\"Sum of 2 arrays but taking nans into account.  Could use np.nansum but\n    would need to replace zeros with nans where both arrays are nans.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]):\n            ret[i] += other[i]\n\n\n@ngjit\ndef row_max_in_place(ret, other):\n    \"\"\"Maximum of 2 arrays of row indexes.\n    Row indexes are integers from 0 upwards, missing data is -1.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in range(len(ret)):\n        if other[i] > -1 and (ret[i] == -1 or other[i] > ret[i]):\n            ret[i] = other[i]\n\n\n@ngjit\ndef row_min_in_place(ret, other):\n    \"\"\"Minimum of 2 arrays of row indexes.\n    Row indexes are integers from 0 upwards, missing data is -1.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in range(len(ret)):\n        if other[i] > -1 and (ret[i] == -1 or other[i] < ret[i]):\n            ret[i] = other[i]\n\n\n@ngjit\ndef _row_max_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of row_max_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if other_value == -1:\n            break\n        else:\n            for i in range(istart, n):\n                if ret_pixel[i] == -1 or other_value > ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n\n@ngjit\ndef row_max_n_in_place_4d(ret, other):\n    \"\"\"Combine two row_max_n signed integer arrays.\n    Equivalent to nanmax_n_in_place with -1 replacing NaN for missing data.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _row_max_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit\ndef row_max_n_in_place_3d(ret, other):\n    ny, nx, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            _row_max_n_impl(ret[y, x], other[y, x])\n\n\n@ngjit\ndef _row_min_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of row_min_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if other_value == -1:\n            break\n        else:\n            for i in range(istart, n):\n                if ret_pixel[i] == -1 or other_value < ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n\n@ngjit\ndef row_min_n_in_place_4d(ret, other):\n    \"\"\"Combine two row_min_n signed integer arrays.\n    Equivalent to nanmin_n_in_place with -1 replacing NaN for missing data.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _row_min_n_impl(ret[y, x, cat], other[y, x, cat])\n\n\n@ngjit\ndef row_min_n_in_place_3d(ret, other):\n    ny, nx, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            _row_min_n_impl(ret[y, x], other[y, x])\n",
    "datashader/datashape/parser.py": "\"\"\"\nParser for the datashape grammar.\n\"\"\"\n\n\nfrom . import lexer, error\n# TODO: Remove coretypes dependency, make 100% of interaction through\n#       the type symbol table\nfrom . import coretypes\n\n__all__ = ['parse']\n\n\nclass DataShapeParser:\n    \"\"\"A DataShape parser object.\"\"\"\n    def __init__(self, ds_str, sym):\n        # The datashape string being parsed\n        self.ds_str = ds_str\n        # Symbol tables for dimensions, dtypes, and type constructors for each\n        self.sym = sym\n        # The lexer\n        self.lex = lexer.lex(ds_str)\n        # The array of tokens self.lex has already produced\n        self.tokens = []\n        # The token currently being examined, and\n        # the end position, set when self.lex is exhausted\n        self.pos = -1\n        self.end_pos = None\n        # Advance to the first token\n        self.advance_tok()\n\n    def advance_tok(self):\n        \"\"\"Advances self.pos by one, if it is not already at the end.\"\"\"\n        if self.pos != self.end_pos:\n            self.pos = self.pos + 1\n            try:\n                # If self.pos has not been backtracked,\n                # we need to request a new token from the lexer\n                if self.pos >= len(self.tokens):\n                    self.tokens.append(next(self.lex))\n            except StopIteration:\n                # Create an EOF token, whose span starts at the\n                # end of the last token to use for error messages\n                if len(self.tokens) > 0:\n                    span = (self.tokens[self.pos-1].span[1],)*2\n                else:\n                    span = (0, 0)\n                self.tokens.append(lexer.Token(None, None, span, None))\n                self.end_pos = self.pos\n\n    @property\n    def tok(self):\n        return self.tokens[self.pos]\n\n    def raise_error(self, errmsg):\n        raise error.DataShapeSyntaxError(self.tok.span[0], '<nofile>',\n                                         self.ds_str, errmsg)\n\n    def parse_homogeneous_list(self, parse_item, sep_tok_id, errmsg,\n                               trailing_sep=False):\n        \"\"\"\n        <item>_list : <item> <SEP> <item>_list\n                    | <item>\n\n        Returns a list of <item>s, or None.\n        \"\"\"\n        saved_pos = self.pos\n        # Parse zero or more \"<item> <SEP>\" repetitions\n        items = []\n        item = True\n        while item is not None:\n            # Parse the <item>\n            item = parse_item()\n            if item is not None:\n                items.append(item)\n                if self.tok.id == sep_tok_id:\n                    # If a <SEP> is next, there are more items\n                    self.advance_tok()\n                else:\n                    # Otherwise we've reached the end\n                    return items\n            else:\n                if len(items) > 0:\n                    if trailing_sep:\n                        return items\n                    else:\n                        # If we already saw \"<item> <SEP>\" at least once,\n                        # we can point at the more specific position within\n                        # the list of <item>s where the error occurred\n                        self.raise_error(errmsg)\n                else:\n                    self.pos = saved_pos\n                    return None\n\n    def syntactic_sugar(self, symdict, name, dshapemsg, error_pos=None):\n        \"\"\"\n        Looks up a symbol in the provided symbol table dictionary for\n        syntactic sugar, raising a standard error message if the symbol\n        is missing.\n\n        Parameters\n        ----------\n        symdict : symbol table dictionary\n            One of self.sym.dtype, self.sym.dim,\n            self.sym.dtype_constr, or self.sym.dim_constr.\n        name : str\n            The name of the symbol to look up.\n        dshapemsg : str\n            The datashape construct this lookup is for, e.g.\n            '{...} dtype constructor'.\n        error_pos : int, optional\n            The position in the token stream at which to flag the error.\n        \"\"\"\n        entry = symdict.get(name)\n        if entry is not None:\n            return entry\n        else:\n            if error_pos is not None:\n                self.pos = error_pos\n            self.raise_error(('Symbol table missing \"%s\" ' +\n                             'entry for %s') % (name, dshapemsg))\n\n    def parse_datashape(self):\n        \"\"\"\n        datashape : datashape_nooption\n                  | QUESTIONMARK datashape_nooption\n                  | EXCLAMATIONMARK datashape_nooption\n\n        Returns a datashape object or None.\n        \"\"\"\n        tok = self.tok\n        constructors = {lexer.QUESTIONMARK: 'option'}\n        if tok.id in constructors:\n            self.advance_tok()\n            saved_pos = self.pos\n            ds = self.parse_datashape_nooption()\n            if ds is not None:\n                # Look in the dtype symbol table for the option type constructor\n                option = self.syntactic_sugar(self.sym.dtype_constr,\n                                              constructors[tok.id],\n                                              '%s dtype construction' %\n                                              constructors[tok.id],\n                                              saved_pos - 1)\n                return coretypes.DataShape(option(ds))\n        else:\n            return self.parse_datashape_nooption()\n\n    def parse_datashape_nooption(self):\n        \"\"\"\n        datashape_nooption : dim ASTERISK datashape\n                           | dtype\n\n        Returns a datashape object or None.\n        \"\"\"\n        saved_pos = self.pos\n        # Try dim ASTERISK datashape\n        dim = self.parse_dim()\n        if dim is not None:\n            if self.tok.id == lexer.ASTERISK:\n                # If an asterisk is next, we're good\n                self.advance_tok()\n                saved_pos = self.pos\n                dshape = self.parse_datashape()\n                if dshape is None:\n                    self.pos = saved_pos\n                    self.raise_error('Expected a dim or a dtype')\n                return coretypes.DataShape(dim, *dshape.parameters)\n        # Try dtype\n        dtype = self.parse_dtype()\n        if dtype:\n            return coretypes.DataShape(dtype)\n        else:\n            return None\n\n    def parse_dim(self):\n        \"\"\"\n        dim : typevar\n            | ellipsis_typevar\n            | type\n            | type_constr\n            | INTEGER\n            | ELLIPSIS\n        typevar : NAME_UPPER\n        ellipsis_typevar : NAME_UPPER ELLIPSIS\n        type : NAME_LOWER\n        type_constr : NAME_LOWER LBRACKET type_arg_list RBRACKET\n\n        Returns a the dim object, or None.\n        TODO: Support type constructors\n        \"\"\"\n        saved_pos = self.pos\n        tok = self.tok\n        if tok.id == lexer.NAME_UPPER:\n            val = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.ELLIPSIS:\n                self.advance_tok()\n                # TypeVars ellipses are treated as the \"ellipsis\" dim\n                tconstr = self.syntactic_sugar(self.sym.dim_constr, 'ellipsis',\n                                               'TypeVar... dim constructor',\n                                               saved_pos)\n                return tconstr(val)\n            elif self.tok.id == lexer.ASTERISK:\n                # Using a lookahead check for '*' after the TypeVar, so that\n                # the error message would be about a dtype problem instead\n                # of a dim problem when 'typevar' isn't in the symbol table\n                #\n                # TypeVars are treated as the \"typevar\" dim\n                tconstr = self.syntactic_sugar(self.sym.dim_constr, 'typevar',\n                                               'TypeVar dim constructor',\n                                               saved_pos)\n                return tconstr(val)\n            else:\n                self.pos = saved_pos\n                return None\n        elif tok.id == lexer.NAME_LOWER:\n            name = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.LBRACKET:\n                dim_constr = self.sym.dim_constr.get(name)\n                if dim_constr is None:\n                    self.pos = saved_pos\n                    return None\n                self.advance_tok()\n                args = self.parse_type_arg_list()   # noqa: F841\n                if self.tok.id == lexer.RBRACKET:\n                    self.advance_tok()\n                    raise NotImplementedError(\n                        'dim type constructors not actually supported yet')\n                else:\n                    self.raise_error('Expected a closing \"]\"')\n            else:\n                dim = self.sym.dim.get(name)\n                if dim is not None:\n                    return dim\n                else:\n                    self.pos = saved_pos\n                    return None\n        elif tok.id == lexer.INTEGER:\n            val = tok.val\n            self.advance_tok()\n            # If the token after the INTEGER is not ASTERISK,\n            # it cannot be a dim, so skip it\n            if self.tok.id != lexer.ASTERISK:\n                self.pos = saved_pos\n                return None\n            # Integers are treated as \"fixed\" dimensions\n            tconstr = self.syntactic_sugar(self.sym.dim_constr, 'fixed',\n                                           'integer dimensions')\n            return tconstr(val)\n        elif tok.id == lexer.ELLIPSIS:\n            self.advance_tok()\n            # Ellipses are treated as the \"ellipsis\" dim\n            dim = self.syntactic_sugar(self.sym.dim, 'ellipsis',\n                                           '... dim',\n                                           saved_pos)\n            return dim\n        else:\n            return None\n\n    def parse_dtype(self):\n        \"\"\"\n        dtype : typevar\n              | type\n              | type_constr\n              | struct_type\n              | funcproto_or_tuple_type\n        typevar : NAME_UPPER\n        ellipsis_typevar : NAME_UPPER ELLIPSIS\n        type : NAME_LOWER\n        type_constr : NAME_LOWER LBRACKET type_arg_list RBRACKET\n        struct_type : LBRACE ...\n        funcproto_or_tuple_type : LPAREN ...\n\n        Returns a the dtype object, or None.\n        \"\"\"\n        saved_pos = self.pos\n        tok = self.tok\n        if tok.id == lexer.NAME_UPPER:\n            val = tok.val\n            self.advance_tok()\n            # TypeVars are treated as the \"typevar\" dtype\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'typevar',\n                                           'TypeVar dtype constructor',\n                                           saved_pos)\n            return tconstr(val)\n        elif tok.id == lexer.NAME_LOWER:\n            name = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.LBRACKET:\n                dtype_constr = self.sym.dtype_constr.get(name)\n                if dtype_constr is None:\n                    self.pos = saved_pos\n                    return None\n                self.advance_tok()\n                args, kwargs = self.parse_type_arg_list()\n                if self.tok.id == lexer.RBRACKET:\n                    if len(args) == 0 and len(kwargs) == 0:\n                        self.raise_error('Expected at least one type ' +\n                                         'constructor argument')\n                    self.advance_tok()\n                    return dtype_constr(*args, **kwargs)\n                else:\n                    self.raise_error('Invalid type constructor argument')\n            else:\n                dtype = self.sym.dtype.get(name)\n                if dtype is not None:\n                    return dtype\n                else:\n                    self.pos = saved_pos\n                    return None\n        elif tok.id == lexer.LBRACE:\n            return self.parse_struct_type()\n        elif tok.id == lexer.LPAREN:\n            return self.parse_funcproto_or_tuple_type()\n        else:\n            return None\n\n    def parse_type_arg_list(self):\n        \"\"\"\n        type_arg_list : type_arg COMMA type_arg_list\n                      | type_kwarg_list\n                      | type_arg\n        type_kwarg_list : type_kwarg COMMA type_kwarg_list\n                        | type_kwarg\n\n        Returns a tuple (args, kwargs), or (None, None).\n        \"\"\"\n        # Parse zero or more \"type_arg COMMA\" repetitions\n        args = []\n        arg = True\n        while arg is not None:\n            # Parse the type_arg\n            arg = self.parse_type_arg()\n            if arg is not None:\n                if self.tok.id == lexer.COMMA:\n                    # If a comma is next, there are more args\n                    self.advance_tok()\n                    args.append(arg)\n                else:\n                    # Otherwise we've reached the end, and there\n                    # were no keyword args\n                    args.append(arg)\n                    return (args, {})\n            else:\n                break\n        kwargs = self.parse_homogeneous_list(self.parse_type_kwarg, lexer.COMMA,\n                                           'Expected another keyword argument, ' +\n                                           'positional arguments cannot follow ' +\n                                           'keyword arguments')\n        return (args, dict(kwargs) if kwargs else {})\n\n    def parse_type_arg(self):\n        \"\"\"\n        type_arg : datashape\n                 | INTEGER\n                 | STRING\n                 | BOOLEAN\n                 | list_type_arg\n        list_type_arg : LBRACKET RBRACKET\n                      | LBRACKET datashape_list RBRACKET\n                      | LBRACKET integer_list RBRACKET\n                      | LBRACKET string_list RBRACKET\n\n        Returns a type_arg value, or None.\n        \"\"\"\n        ds = self.parse_datashape()\n        if ds is not None:\n            return ds\n        if self.tok.id in [lexer.INTEGER, lexer.STRING, lexer.BOOLEAN]:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        elif self.tok.id == lexer.LBRACKET:\n            self.advance_tok()\n            val = self.parse_datashape_list()\n            if val is None:\n                val = self.parse_integer_list()\n            if val is None:\n                val = self.parse_string_list()\n            if val is None:\n                val = self.parse_boolean_list()\n            if self.tok.id == lexer.RBRACKET:\n                self.advance_tok()\n                return [] if val is None else val\n            else:\n                if val is None:\n                    self.raise_error('Expected a type constructor argument ' +\n                                     'or a closing \"]\"')\n                else:\n                    self.raise_error('Expected a \",\" or a closing \"]\"')\n        else:\n            return None\n\n    def parse_type_kwarg(self):\n        \"\"\"\n        type_kwarg : NAME_LOWER EQUAL type_arg\n\n        Returns a (name, type_arg) tuple, or None.\n        \"\"\"\n        if self.tok.id != lexer.NAME_LOWER:\n            return None\n        saved_pos = self.pos\n        name = self.tok.val\n        self.advance_tok()\n        if self.tok.id != lexer.EQUAL:\n            self.pos = saved_pos\n            return None\n        self.advance_tok()\n        arg = self.parse_type_arg()\n        if arg is not None:\n            return (name, arg)\n        else:\n            # After \"NAME_LOWER EQUAL\", a type_arg is required.\n            self.raise_error('Expected a type constructor argument')\n\n    def parse_datashape_list(self):\n        \"\"\"\n        datashape_list : datashape COMMA datashape_list\n                       | datashape\n\n        Returns a list of datashape type objects, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_datashape, lexer.COMMA,\n                                           'Expected another datashape, ' +\n                                           'type constructor parameter ' +\n                                           'lists must have uniform type')\n\n    def parse_integer(self):\n        \"\"\"\n        integer : INTEGER\n        \"\"\"\n        if self.tok.id == lexer.INTEGER:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_integer_list(self):\n        \"\"\"\n        integer_list : INTEGER COMMA integer_list\n                     | INTEGER\n\n        Returns a list of integers, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_integer, lexer.COMMA,\n                                           'Expected another integer, ' +\n                                           'type constructor parameter ' +\n                                           'lists must have uniform type')\n\n    def parse_boolean(self):\n        \"\"\"\n        boolean : BOOLEAN\n        \"\"\"\n        if self.tok.id == lexer.BOOLEAN:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_boolean_list(self):\n        \"\"\"\n        boolean_list : boolean COMMA boolean_list\n                     | boolean\n\n        Returns a list of booleans, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_boolean, lexer.COMMA,\n                                           'Expected another boolean, ' +\n                                           'type constructor parameter ' +\n                                           'lists must have uniform type')\n\n    def parse_string(self):\n        \"\"\"\n        string : STRING\n        \"\"\"\n        if self.tok.id == lexer.STRING:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_string_list(self):\n        \"\"\"\n        string_list : STRING COMMA string_list\n                    | STRING\n\n        Returns a list of strings, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_string, lexer.COMMA,\n                                           'Expected another string, ' +\n                                           'type constructor parameter ' +\n                                           'lists must have uniform type')\n\n    def parse_struct_type(self):\n        \"\"\"\n        struct_type : LBRACE struct_field_list RBRACE\n                    | LBRACE struct_field_list COMMA RBRACE\n\n        Returns a struct type, or None.\n        \"\"\"\n        if self.tok.id != lexer.LBRACE:\n            return None\n        saved_pos = self.pos\n        self.advance_tok()\n        fields = self.parse_homogeneous_list(self.parse_struct_field, lexer.COMMA,\n                                             'Invalid field in struct',\n                                             trailing_sep=True) or []\n        if self.tok.id != lexer.RBRACE:\n            self.raise_error('Invalid field in struct')\n        self.advance_tok()\n        # Split apart the names and types into separate lists,\n        # compatible with type constructor parameters\n        names = [f[0] for f in fields]\n        types = [f[1] for f in fields]\n        # Structs are treated as the \"struct\" dtype\n        tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'struct',\n                                       '{...} dtype constructor', saved_pos)\n        return tconstr(names, types)\n\n    def parse_struct_field(self):\n        \"\"\"\n        struct_field : struct_field_name COLON datashape\n        struct_field_name : NAME_LOWER\n                          | NAME_UPPER\n                          | NAME_OTHER\n                          | STRING\n\n        Returns a tuple (name, datashape object) or None\n        \"\"\"\n        if self.tok.id not in [lexer.NAME_LOWER, lexer.NAME_UPPER,\n                               lexer.NAME_OTHER, lexer.STRING]:\n            return None\n        name = self.tok.val\n        self.advance_tok()\n        if self.tok.id != lexer.COLON:\n            self.raise_error('Expected a \":\" separating the field ' +\n                             'name from its datashape')\n        self.advance_tok()\n        ds = self.parse_datashape()\n        if ds is None:\n            self.raise_error('Expected the datashape of the field')\n        return (name, ds)\n\n    def parse_funcproto_or_tuple_type(self):\n        \"\"\"\n        funcproto_or_tuple_type : tuple_type RARROW datashape\n                                | tuple_type\n        tuple_type : LPAREN tuple_item_list RPAREN\n                   | LPAREN tuple_item_list COMMA RPAREN\n                   | LPAREN RPAREN\n        tuple_item_list : datashape COMMA tuple_item_list\n                        | datashape\n\n        Returns a tuple type object, a function prototype, or None.\n        \"\"\"\n        if self.tok.id != lexer.LPAREN:\n            return None\n        saved_pos = self.pos\n        self.advance_tok()\n        dshapes = self.parse_homogeneous_list(\n            self.parse_datashape,\n            lexer.COMMA,\n            'Invalid datashape in tuple',\n            trailing_sep=True,\n        ) or ()\n        if self.tok.id != lexer.RPAREN:\n            self.raise_error('Invalid datashape in tuple')\n        self.advance_tok()\n        if self.tok.id != lexer.RARROW:\n            # Tuples are treated as the \"tuple\" dtype\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'tuple',\n                                           '(...) dtype constructor', saved_pos)\n            return tconstr(dshapes)\n        else:\n            # Get the return datashape after the right arrow\n            self.advance_tok()\n            ret_dshape = self.parse_datashape()\n            if ret_dshape is None:\n                self.raise_error('Expected function prototype return ' +\n                                 'datashape')\n            # Function Prototypes are treated as the \"funcproto\" dtype\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'funcproto',\n                                           '(...) -> ... dtype constructor',\n                                           saved_pos)\n            return tconstr(dshapes, ret_dshape)\n\n\ndef parse(ds_str, sym):\n    \"\"\"Parses a single datashape from a string.\n\n    Parameters\n    ----------\n    ds_str : string\n        The datashape string to parse.\n    sym : TypeSymbolTable\n        The symbol tables of dimensions, dtypes, and type constructors for each.\n\n    \"\"\"\n    dsp = DataShapeParser(ds_str, sym)\n    ds = dsp.parse_datashape()\n    # If no datashape could be found\n    if ds is None:\n        dsp.raise_error('Invalid datashape')\n\n    # Make sure there's no garbage at the end\n    if dsp.pos != dsp.end_pos:\n        dsp.raise_error('Unexpected token in datashape')\n    return ds\n",
    "datashader/datashape/validation.py": "\"\"\"\nDatashape validation.\n\"\"\"\n\nfrom . import coretypes as T\n\n\ndef traverse(f, t):\n    \"\"\"\n    Map `f` over `t`, calling `f` with type `t` and the map result of the\n    mapping `f` over `t` 's parameters.\n\n    Parameters\n    ----------\n    f : callable\n    t : DataShape\n\n    Returns\n    -------\n    DataShape\n    \"\"\"\n    if isinstance(t, T.Mono) and not isinstance(t, T.Unit):\n        return f(t, [traverse(f, p) for p in t.parameters])\n    return t\n\n\ndef validate(ds):\n    \"\"\"\n    Validate a datashape to see whether it is well-formed.\n\n    Parameters\n    ----------\n    ds : DataShape\n\n    Examples\n    --------\n    >>> from datashader.datashape import dshape\n    >>> dshape('10 * int32')\n    dshape(\"10 * int32\")\n    >>> dshape('... * int32')\n    dshape(\"... * int32\")\n    >>> dshape('... * ... * int32') # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    TypeError: Can only use a single wildcard\n    >>> dshape('T * ... * X * ... * X') # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    TypeError: Can only use a single wildcard\n    >>> dshape('T * ...') # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n        ...\n    DataShapeSyntaxError: Expected a dtype\n    \"\"\"\n    traverse(_validate, ds)\n\n\ndef _validate(ds, params):\n    if isinstance(ds, T.DataShape):\n        # Check ellipses\n        ellipses = [x for x in ds.parameters if isinstance(x, T.Ellipsis)]\n        if len(ellipses) > 1:\n            raise TypeError(\"Can only use a single wildcard\")\n        elif isinstance(ds.parameters[-1], T.Ellipsis):\n            raise TypeError(\"Measure may not be an Ellipsis (...)\")\n",
    "datashader/datashape/util/__init__.py": "\nfrom itertools import chain\nimport operator\n\nfrom .. import parser\nfrom .. import type_symbol_table\nfrom ..validation import validate\nfrom .. import coretypes\n\n\n__all__ = 'dshape', 'dshapes', 'has_var_dim', 'has_ellipsis', 'cat_dshapes'\n\nsubclasses = operator.methodcaller('__subclasses__')\n\n#------------------------------------------------------------------------\n# Utility Functions for DataShapes\n#------------------------------------------------------------------------\n\ndef dshapes(*args):\n    \"\"\"\n    Parse a bunch of datashapes all at once.\n\n    >>> a, b = dshapes('3 * int32', '2 * var * float64')\n    \"\"\"\n    return [dshape(arg) for arg in args]\n\n\ndef dshape(o):\n    \"\"\"\n    Parse a datashape. For a thorough description see\n    https://datashape.readthedocs.io/en/latest/\n\n    >>> ds = dshape('2 * int32')\n    >>> ds[1]\n    ctype(\"int32\")\n    \"\"\"\n    if isinstance(o, coretypes.DataShape):\n        return o\n    if isinstance(o, str):\n        ds = parser.parse(o, type_symbol_table.sym)\n    elif isinstance(o, (coretypes.CType, coretypes.String,\n                        coretypes.Record, coretypes.JSON,\n                        coretypes.Date, coretypes.Time, coretypes.DateTime,\n                        coretypes.Unit)):\n        ds = coretypes.DataShape(o)\n    elif isinstance(o, coretypes.Mono):\n        ds = o\n    elif isinstance(o, (list, tuple)):\n        ds = coretypes.DataShape(*o)\n    else:\n        raise TypeError('Cannot create dshape from object of type %s' % type(o))\n    validate(ds)\n    return ds\n\n\ndef cat_dshapes(dslist):\n    \"\"\"\n    Concatenates a list of dshapes together along\n    the first axis. Raises an error if there is\n    a mismatch along another axis or the measures\n    are different.\n\n    Requires that the leading dimension be a known\n    size for all data shapes.\n    TODO: Relax this restriction to support\n          streaming dimensions.\n\n    >>> cat_dshapes(dshapes('10 * int32', '5 * int32'))\n    dshape(\"15 * int32\")\n    \"\"\"\n    if len(dslist) == 0:\n        raise ValueError('Cannot concatenate an empty list of dshapes')\n    elif len(dslist) == 1:\n        return dslist[0]\n\n    outer_dim_size = operator.index(dslist[0][0])\n    inner_ds = dslist[0][1:]\n    for ds in dslist[1:]:\n        outer_dim_size += operator.index(ds[0])\n        if ds[1:] != inner_ds:\n            raise ValueError(('The datashapes to concatenate much'\n                              ' all match after'\n                              ' the first dimension (%s vs %s)') %\n                              (inner_ds, ds[1:]))\n    return coretypes.DataShape(*[coretypes.Fixed(outer_dim_size)] + list(inner_ds))\n\n\ndef collect(pred, expr):\n    \"\"\" Collect terms in expression that match predicate\n\n    >>> from datashader.datashape import Unit, dshape\n    >>> predicate = lambda term: isinstance(term, Unit)\n    >>> dshape = dshape('var * {value: int64, loc: 2 * int32}')\n    >>> sorted(set(collect(predicate, dshape)), key=str)\n    [Fixed(val=2), ctype(\"int32\"), ctype(\"int64\"), Var()]\n    >>> from datashader.datashape import var, int64\n    >>> sorted(set(collect(predicate, [var, int64])), key=str)\n    [ctype(\"int64\"), Var()]\n    \"\"\"\n    if pred(expr):\n        return [expr]\n    if isinstance(expr, coretypes.Record):\n        return chain.from_iterable(collect(pred, typ) for typ in expr.types)\n    if isinstance(expr, coretypes.Mono):\n        return chain.from_iterable(collect(pred, typ) for typ in expr.parameters)\n    if isinstance(expr, (list, tuple)):\n        return chain.from_iterable(collect(pred, item) for item in expr)\n\n\ndef has_var_dim(ds):\n    \"\"\"Returns True if datashape has a variable dimension\n\n    Note currently treats variable length string as scalars.\n\n    >>> has_var_dim(dshape('2 * int32'))\n    False\n    >>> has_var_dim(dshape('var * 2 * int32'))\n    True\n    \"\"\"\n    return has((coretypes.Ellipsis, coretypes.Var), ds)\n\n\ndef has(typ, ds):\n    if isinstance(ds, typ):\n        return True\n    if isinstance(ds, coretypes.Record):\n        return any(has(typ, t) for t in ds.types)\n    if isinstance(ds, coretypes.Mono):\n        return any(has(typ, p) for p in ds.parameters)\n    if isinstance(ds, (list, tuple)):\n        return any(has(typ, item) for item in ds)\n    return False\n\n\ndef has_ellipsis(ds):\n    \"\"\"Returns True if the datashape has an ellipsis\n\n    >>> has_ellipsis(dshape('2 * int'))\n    False\n    >>> has_ellipsis(dshape('... * int'))\n    True\n    \"\"\"\n    return has(coretypes.Ellipsis, ds)\n",
    "datashader/datashape/predicates.py": "import numpy as np\n\nfrom .util import collect, dshape\nfrom .internal_utils import remove\nfrom .coretypes import (DataShape, Fixed, Var, Ellipsis, Record, Unit,\n                        date_, datetime_, TypeVar, to_numpy_dtype,\n                        Categorical)\nfrom .typesets import floating, boolean\n\n# https://github.com/blaze/datashape/blob/master/docs/source/types.rst\n\n__all__ = ['isdimension', 'ishomogeneous', 'istabular', 'isfixed', 'isscalar',\n           'isrecord', 'iscollection', 'isnumeric', 'isboolean', 'isdatelike',\n           'isreal']\n\ndimension_types = Fixed, Var, Ellipsis, int\n\n\ndef isscalar(ds):\n    \"\"\" Is this dshape a single dtype?\n\n    >>> isscalar('int')\n    True\n    >>> isscalar('?int')\n    True\n    >>> isscalar('{name: string, amount: int}')\n    False\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape) and len(ds) == 1:\n        ds = ds[0]\n    return isinstance(getattr(ds, 'ty', ds), (Unit, Categorical))\n\n\ndef isrecord(ds):\n    \"\"\" Is this dshape a record type?\n\n    >>> isrecord('{name: string, amount: int}')\n    True\n    >>> isrecord('int')\n    False\n    >>> isrecord('?{name: string, amount: int}')\n    True\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape) and len(ds) == 1:\n        ds = ds[0]\n    return isinstance(getattr(ds, 'ty', ds), Record)\n\n\ndef isdimension(ds):\n    \"\"\" Is a component a dimension?\n\n    >>> from datashader.datashape import int32\n    >>> isdimension(Fixed(10))\n    True\n    >>> isdimension(Var())\n    True\n    >>> isdimension(int32)\n    False\n    \"\"\"\n    return isinstance(ds, dimension_types)\n\n\ndef ishomogeneous(ds):\n    \"\"\" Does datashape contain only one dtype?\n\n    >>> from datashader.datashape import int32\n    >>> ishomogeneous(int32)\n    True\n    >>> ishomogeneous('var * 3 * string')\n    True\n    >>> ishomogeneous('var * {name: string, amount: int}')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    return len(set(remove(isdimension, collect(isscalar, ds)))) == 1\n\n\ndef _dimensions(ds):\n    \"\"\"Number of dimensions of datashape\n    \"\"\"\n    return len(dshape(ds).shape)\n\n\ndef isfixed(ds):\n    \"\"\" Contains no variable dimensions\n\n    >>> isfixed('10 * int')\n    True\n    >>> isfixed('var * int')\n    False\n    >>> isfixed('10 * {name: string, amount: int}')\n    True\n    >>> isfixed('10 * {name: string, amounts: var * int}')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    if isinstance(ds[0], TypeVar):\n        return None  # don't know\n    if isinstance(ds[0], Var):\n        return False\n    if isinstance(ds[0], Record):\n        return all(map(isfixed, ds[0].types))\n    if len(ds) > 1:\n        return isfixed(ds.subarray(1))\n    return True\n\n\ndef istabular(ds):\n    \"\"\" A collection of records\n\n    >>> istabular('var * {name: string, amount: int}')\n    True\n    >>> istabular('var * 10 * 3 * int')\n    False\n    >>> istabular('10 * var * int')\n    False\n    >>> istabular('var * (int64, string, ?float64)')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    return _dimensions(ds) == 1 and isrecord(ds.measure)\n\n\ndef iscollection(ds):\n    \"\"\" Is a collection of items, has dimension\n\n    >>> iscollection('5 * int32')\n    True\n    >>> iscollection('int32')\n    False\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    return isdimension(ds[0])\n\n\ndef isnumeric(ds):\n    \"\"\" Has a numeric measure\n\n    >>> isnumeric('int32')\n    True\n    >>> isnumeric('3 * ?real')\n    True\n    >>> isnumeric('string')\n    False\n    >>> isnumeric('var * {amount: ?int32}')\n    False\n    \"\"\"\n    ds = launder(ds)\n\n    try:\n        npdtype = to_numpy_dtype(ds)\n    except TypeError:\n        return False\n    else:\n        return isinstance(ds, Unit) and np.issubdtype(npdtype, np.number)\n\n\ndef launder(ds):\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape):\n        ds = ds.measure\n    return getattr(ds, 'ty', ds)\n\n\ndef isreal(ds):\n    \"\"\" Has a numeric measure\n\n    >>> isreal('float32')\n    True\n    >>> isreal('3 * ?real')\n    True\n    >>> isreal('string')\n    False\n    \"\"\"\n    ds = launder(ds)\n    return isinstance(ds, Unit) and ds in floating\n\n\ndef isboolean(ds):\n    \"\"\" Has a boolean measure\n\n    >>> isboolean('bool')\n    True\n    >>> isboolean('3 * ?bool')\n    True\n    >>> isboolean('int')\n    False\n    \"\"\"\n    return launder(ds) in boolean\n\n\ndef isdatelike(ds):\n    \"\"\" Has a date or datetime measure\n\n    >>> isdatelike('int32')\n    False\n    >>> isdatelike('3 * datetime')\n    True\n    >>> isdatelike('?datetime')\n    True\n    \"\"\"\n    ds = launder(ds)\n    return ds == date_ or ds == datetime_\n"
  },
  "GT_src_dict": {
    "datashader/datashape/typesets.py": {
      "TypeSet.__contains__": {
        "code": "    def __contains__(self, val):\n        \"\"\"Check if a value is part of the TypeSet.\n\nParameters\n----------\nval : type\n    The value to check for membership in the TypeSet.\n\nReturns\n-------\nbool\n    Returns True if the specified value is contained in the TypeSet, otherwise returns False.\n\nNotes\n-----\nThis method utilizes the `_set` property, which is a set of types encapsulated in the TypeSet, to determine membership. The `__contains__` method is part of the `TypeSet` class, which represents a collection of data types defined for use in a type system.\"\"\"\n        return val in self._set",
        "docstring": "Check if a value is part of the TypeSet.\n\nParameters\n----------\nval : type\n    The value to check for membership in the TypeSet.\n\nReturns\n-------\nbool\n    Returns True if the specified value is contained in the TypeSet, otherwise returns False.\n\nNotes\n-----\nThis method utilizes the `_set` property, which is a set of types encapsulated in the TypeSet, to determine membership. The `__contains__` method is part of the `TypeSet` class, which represents a collection of data types defined for use in a type system.",
        "signature": "def __contains__(self, val):",
        "type": "Method",
        "class_signature": "class TypeSet(Unit):"
      }
    },
    "datashader/utils.py": {
      "Dispatcher.__init__": {
        "code": "    def __init__(self):\n        \"\"\"Initialize the Dispatcher instance.\n\n    This constructor creates the `_lookup` attribute, which is a dictionary that will \n    store type-function mappings for single dispatching. The primary function of this \n    class is to facilitate the registration and calling of functions based on the \n    type of the first argument provided during the invocation. \n\n    Attributes\n    ----------\n    _lookup : dict\n        A dictionary to map argument types to corresponding functions\n        for type-based dispatching.\"\"\"\n        self._lookup = {}",
        "docstring": "Initialize the Dispatcher instance.\n\nThis constructor creates the `_lookup` attribute, which is a dictionary that will \nstore type-function mappings for single dispatching. The primary function of this \nclass is to facilitate the registration and calling of functions based on the \ntype of the first argument provided during the invocation. \n\nAttributes\n----------\n_lookup : dict\n    A dictionary to map argument types to corresponding functions\n    for type-based dispatching.",
        "signature": "def __init__(self):",
        "type": "Method",
        "class_signature": "class Dispatcher:"
      },
      "Dispatcher.register": {
        "code": "    def register(self, typ, func=None):\n        \"\"\"Register a function for single dispatch on a specified type.\n\nParameters\n----------\ntyp : type or tuple of types\n    The type or tuple of types on which to dispatch the specified function.\nfunc : callable or None, optional\n    The function to register for the dispatch. If None, returns a decorator\n    that can be used to register a function.\n\nReturns\n-------\ncallable\n    The registered function, allowing for further chaining or reuse.\n\nNotes\n-----\nWhen `func` is None, the method returns a decorator to register the function \npassed into it. If `typ` is a tuple, the function is registered for each \ntype in the tuple. The registered functions are stored in the \n`self._lookup` dictionary for efficient dispatching based on the type of \nthe first argument.\n\nThis method enables dynamic method registration and retrieval based on \ntype-checking, allowing for flexible handling of various input types.\"\"\"\n        'Register dispatch of `func` on arguments of type `typ`'\n        if func is None:\n            return lambda f: self.register(typ, f)\n        if isinstance(typ, tuple):\n            for t in typ:\n                self.register(t, func)\n        else:\n            self._lookup[typ] = func\n        return func",
        "docstring": "Register a function for single dispatch on a specified type.\n\nParameters\n----------\ntyp : type or tuple of types\n    The type or tuple of types on which to dispatch the specified function.\nfunc : callable or None, optional\n    The function to register for the dispatch. If None, returns a decorator\n    that can be used to register a function.\n\nReturns\n-------\ncallable\n    The registered function, allowing for further chaining or reuse.\n\nNotes\n-----\nWhen `func` is None, the method returns a decorator to register the function \npassed into it. If `typ` is a tuple, the function is registered for each \ntype in the tuple. The registered functions are stored in the \n`self._lookup` dictionary for efficient dispatching based on the type of \nthe first argument.\n\nThis method enables dynamic method registration and retrieval based on \ntype-checking, allowing for flexible handling of various input types.",
        "signature": "def register(self, typ, func=None):",
        "type": "Method",
        "class_signature": "class Dispatcher:"
      },
      "Dispatcher.__call__": {
        "code": "    def __call__(self, head, *rest, **kwargs):\n        \"\"\"Dispatches a function based on the type of the first argument (`head`).\n\n    This method checks if the type of `head` is registered in the dispatcher. If found, it invokes the associated function with `head` and any additional arguments (`rest` and `kwargs`). If not, it iterates through the method resolution order (MRO) of `head`'s type to find a matching dispatcher. If no match is found, a `TypeError` is raised.\n\n    Parameters\n    ----------\n    head: Any\n        The first argument used to determine the dispatch function based on its type.\n    *rest: Any\n        Additional positional arguments passed to the dispatched function.\n    **kwargs: Any\n        Additional keyword arguments passed to the dispatched function.\n\n    Returns\n    -------\n    Any\n        The result of the dispatched function call.\n\n    Raises\n    ------\n    TypeError\n        If no registered function matches the type of `head` or its MRO.\n\n    Notes\n    -----\n    The method uses the `_lookup` attribute, a dictionary that stores type-function mappings,\n    to efficiently find the appropriate function. The `getmro` function from the `inspect` module\n    is utilized to access the MRO of `head`'s type, facilitating fallback dispatching.\"\"\"\n        lk = self._lookup\n        typ = type(head)\n        if typ in lk:\n            return lk[typ](head, *rest, **kwargs)\n        for cls in getmro(typ)[1:]:\n            if cls in lk:\n                return lk[cls](head, *rest, **kwargs)\n        raise TypeError('No dispatch for {0} type'.format(typ))",
        "docstring": "Dispatches a function based on the type of the first argument (`head`).\n\nThis method checks if the type of `head` is registered in the dispatcher. If found, it invokes the associated function with `head` and any additional arguments (`rest` and `kwargs`). If not, it iterates through the method resolution order (MRO) of `head`'s type to find a matching dispatcher. If no match is found, a `TypeError` is raised.\n\nParameters\n----------\nhead: Any\n    The first argument used to determine the dispatch function based on its type.\n*rest: Any\n    Additional positional arguments passed to the dispatched function.\n**kwargs: Any\n    Additional keyword arguments passed to the dispatched function.\n\nReturns\n-------\nAny\n    The result of the dispatched function call.\n\nRaises\n------\nTypeError\n    If no registered function matches the type of `head` or its MRO.\n\nNotes\n-----\nThe method uses the `_lookup` attribute, a dictionary that stores type-function mappings,\nto efficiently find the appropriate function. The `getmro` function from the `inspect` module\nis utilized to access the MRO of `head`'s type, facilitating fallback dispatching.",
        "signature": "def __call__(self, head, *rest, **kwargs):",
        "type": "Method",
        "class_signature": "class Dispatcher:"
      },
      "isreal": {
        "code": "def isreal(dt):\n    \"\"\"Check if a datashape is numeric and real.\n\nParameters\n----------\ndt : str or datashape.Type\n    The datashape representation (e.g., a string like 'int32', 'float64', etc.) to be checked.\n\nReturns\n-------\nbool\n    Returns True if the datashape is a numeric type and specifically a real number, \n    otherwise returns False.\n\nNotes\n-----\nThis function uses `datashape.predicates.launder` to normalize the input, \nand it checks its membership in `datashape.typesets.real`, which is defined\nin the `datashape` module imported at the beginning of the code. It is\nimportant for ensuring that the datashape type is properly classified.\"\"\"\n    \"Check if a datashape is numeric and real.\\n\\n    Example\\n    -------\\n    >>> isreal('int32')\\n    True\\n    >>> isreal('float64')\\n    True\\n    >>> isreal('string')\\n    False\\n    >>> isreal('complex64')\\n    False\\n    \"\n    dt = datashape.predicates.launder(dt)\n    return isinstance(dt, datashape.Unit) and dt in datashape.typesets.real",
        "docstring": "Check if a datashape is numeric and real.\n\nParameters\n----------\ndt : str or datashape.Type\n    The datashape representation (e.g., a string like 'int32', 'float64', etc.) to be checked.\n\nReturns\n-------\nbool\n    Returns True if the datashape is a numeric type and specifically a real number, \n    otherwise returns False.\n\nNotes\n-----\nThis function uses `datashape.predicates.launder` to normalize the input, \nand it checks its membership in `datashape.typesets.real`, which is defined\nin the `datashape` module imported at the beginning of the code. It is\nimportant for ensuring that the datashape type is properly classified.",
        "signature": "def isreal(dt):",
        "type": "Function",
        "class_signature": null
      },
      "calc_res": {
        "code": "def calc_res(raster):\n    \"\"\"Calculate the resolution of an xarray.DataArray raster.\n\nParameters\n----------\nraster : xarray.DataArray\n    The input raster from which resolution is to be calculated. The raster \n    should have dimensions that include coordinate axes, typically representing \n    geographical data.\n\nReturns\n-------\ntuple\n    A two-tuple (xres, yres) representing the resolutions in the x and y \n    dimensions, respectively. The y-resolution is positive if the y-coordinates \n    are decreasing.\n\nNotes\n-----\nThis function interprets the raster's last two dimensions to determine its \nshape and extracts coordinate values using the specified dimension names. \nIt is typically used in conjunction with raster processing steps within the \nlarger context of data handling for geographical visualizations or analyses.\"\"\"\n    'Calculate the resolution of xarray.DataArray raster and return it as the\\n    two-tuple (xres, yres). yres is positive if it is decreasing.\\n    '\n    h, w = raster.shape[-2:]\n    ydim, xdim = raster.dims[-2:]\n    xcoords = raster[xdim].values\n    ycoords = raster[ydim].values\n    xres = (xcoords[-1] - xcoords[0]) / (w - 1)\n    yres = (ycoords[0] - ycoords[-1]) / (h - 1)\n    return (xres, yres)",
        "docstring": "Calculate the resolution of an xarray.DataArray raster.\n\nParameters\n----------\nraster : xarray.DataArray\n    The input raster from which resolution is to be calculated. The raster \n    should have dimensions that include coordinate axes, typically representing \n    geographical data.\n\nReturns\n-------\ntuple\n    A two-tuple (xres, yres) representing the resolutions in the x and y \n    dimensions, respectively. The y-resolution is positive if the y-coordinates \n    are decreasing.\n\nNotes\n-----\nThis function interprets the raster's last two dimensions to determine its \nshape and extracts coordinate values using the specified dimension names. \nIt is typically used in conjunction with raster processing steps within the \nlarger context of data handling for geographical visualizations or analyses.",
        "signature": "def calc_res(raster):",
        "type": "Function",
        "class_signature": null
      },
      "_flip_array": {
        "code": "def _flip_array(array, xflip, yflip):\n    \"\"\"Helper function to flip a multidimensional array either horizontally (x-axis) or vertically (y-axis) based on specified flags.\n\nParameters\n----------\narray : numpy.ndarray\n    The input array to be flipped. It can have 2 or 3 dimensions where the last dimension corresponds to the x-axis and the second-to-last to the y-axis.\nxflip : bool\n    A flag indicating whether to flip the array along the x-axis (horizontal flip).\nyflip : bool\n    A flag indicating whether to flip the array along the y-axis (vertical flip).\n\nReturns\n-------\nnumpy.ndarray\n    The flipped version of the input array based on the specified flags.\n\nThis function is primarily utilized in the `orient_array` function to ensure that raster data is oriented correctly for further processing or visualization. It interacts with other functions that may adjust array orientations based on geospatial or raster data requirements.\"\"\"\n    if yflip:\n        array = array[..., ::-1, :]\n    if xflip:\n        array = array[..., :, ::-1]\n    return array",
        "docstring": "Helper function to flip a multidimensional array either horizontally (x-axis) or vertically (y-axis) based on specified flags.\n\nParameters\n----------\narray : numpy.ndarray\n    The input array to be flipped. It can have 2 or 3 dimensions where the last dimension corresponds to the x-axis and the second-to-last to the y-axis.\nxflip : bool\n    A flag indicating whether to flip the array along the x-axis (horizontal flip).\nyflip : bool\n    A flag indicating whether to flip the array along the y-axis (vertical flip).\n\nReturns\n-------\nnumpy.ndarray\n    The flipped version of the input array based on the specified flags.\n\nThis function is primarily utilized in the `orient_array` function to ensure that raster data is oriented correctly for further processing or visualization. It interacts with other functions that may adjust array orientations based on geospatial or raster data requirements.",
        "signature": "def _flip_array(array, xflip, yflip):",
        "type": "Function",
        "class_signature": null
      },
      "orient_array": {
        "code": "def orient_array(raster, res=None, layer=None):\n    \"\"\"Reorients a 2D NumPy array representing a raster based on the resolution values for x and y axes.\n\nParameters\n----------\nraster : DataArray\n    An xarray DataArray containing the raster data to be reoriented.\nres : tuple, optional\n    A two-tuple (int, int) representing x and y resolutions (grid/cell sizes).\n    If not provided, the function calculates the resolution using `calc_res`.\nlayer : int, optional\n    The index of the specific layer within the raster to be reoriented (1-based index).\n\nReturns\n-------\narray : numpy.ndarray\n    A 2D NumPy ndarray that represents the reoriented raster data.\n\nNotes\n-----\nThis function checks the signs of the resolution components to determine if the array needs to be flipped along the x or y axes. The function relies on the helper function `_flip_array` to perform the actual flipping, as needed. It uses `calc_res` to obtain resolution information if not supplied directly. The dimensions and orientation of the output array will depend on the resolution values provided, ensuring the spatial orientation of the raster data is consistent with its geographic context.\"\"\"\n    '\\n    Reorients the array to a canonical orientation depending on\\n    whether the x and y-resolution values are positive or negative.\\n\\n    Parameters\\n    ----------\\n    raster : DataArray\\n        xarray DataArray to be reoriented\\n    res : tuple\\n        Two-tuple (int, int) which includes x and y resolutions (aka \"grid/cell\\n        sizes\"), respectively.\\n    layer : int\\n        Index of the raster layer to be reoriented (optional)\\n\\n    Returns\\n    -------\\n    array : numpy.ndarray\\n        Reoriented 2d NumPy ndarray\\n    '\n    if res is None:\n        res = calc_res(raster)\n    array = raster.data\n    if layer is not None:\n        array = array[layer - 1]\n    r0zero = np.timedelta64(0, 'ns') if isinstance(res[0], np.timedelta64) else 0\n    r1zero = np.timedelta64(0, 'ns') if isinstance(res[1], np.timedelta64) else 0\n    xflip = res[0] < r0zero\n    yflip = res[1] > r1zero\n    array = _flip_array(array, xflip, yflip)\n    return array",
        "docstring": "Reorients a 2D NumPy array representing a raster based on the resolution values for x and y axes.\n\nParameters\n----------\nraster : DataArray\n    An xarray DataArray containing the raster data to be reoriented.\nres : tuple, optional\n    A two-tuple (int, int) representing x and y resolutions (grid/cell sizes).\n    If not provided, the function calculates the resolution using `calc_res`.\nlayer : int, optional\n    The index of the specific layer within the raster to be reoriented (1-based index).\n\nReturns\n-------\narray : numpy.ndarray\n    A 2D NumPy ndarray that represents the reoriented raster data.\n\nNotes\n-----\nThis function checks the signs of the resolution components to determine if the array needs to be flipped along the x or y axes. The function relies on the helper function `_flip_array` to perform the actual flipping, as needed. It uses `calc_res` to obtain resolution information if not supplied directly. The dimensions and orientation of the output array will depend on the resolution values provided, ensuring the spatial orientation of the raster data is consistent with its geographic context.",
        "signature": "def orient_array(raster, res=None, layer=None):",
        "type": "Function",
        "class_signature": null
      },
      "apply": {
        "code": "def apply(func, args, kwargs=None):\n    \"\"\"Apply a function with specified arguments and optional keyword arguments.\n\nParameters\n----------\nfunc : callable\n    The function to be applied.\nargs : tuple\n    A tuple of positional arguments to pass to the function.\nkwargs : dict, optional\n    A dictionary of keyword arguments to pass to the function.\n\nReturns\n-------\nThe return value of the function `func` when called with `args` and `kwargs`. \nIf `kwargs` is not provided, the function is invoked with only `args`.\n\nThis function is a utility that simplifies the invocation of callable objects with varying numbers of arguments, helping to maintain cleaner and more flexible code. No significant constants or variables are defined within this function; it relies on the provided parameters for its operation and outputs the result of the executed function.\"\"\"\n    if kwargs:\n        return func(*args, **kwargs)\n    else:\n        return func(*args)",
        "docstring": "Apply a function with specified arguments and optional keyword arguments.\n\nParameters\n----------\nfunc : callable\n    The function to be applied.\nargs : tuple\n    A tuple of positional arguments to pass to the function.\nkwargs : dict, optional\n    A dictionary of keyword arguments to pass to the function.\n\nReturns\n-------\nThe return value of the function `func` when called with `args` and `kwargs`. \nIf `kwargs` is not provided, the function is invoked with only `args`.\n\nThis function is a utility that simplifies the invocation of callable objects with varying numbers of arguments, helping to maintain cleaner and more flexible code. No significant constants or variables are defined within this function; it relies on the provided parameters for its operation and outputs the result of the executed function.",
        "signature": "def apply(func, args, kwargs=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "datashader/datashape/parser.py": {
      "parse": {
        "code": "def parse(ds_str, sym):\n    \"\"\"Parses a datashape from a given string representation. The parse function creates an instance of DataShapeParser that utilizes a lexer to tokenize the input datashape string and to process it according to the defined grammar rules.\n\nParameters\n----------\nds_str : str\n    The datashape string that needs to be parsed into a structured data representation.\nsym : TypeSymbolTable\n    An instance representing the symbol tables for dimension types, data types (dtypes), and type constructors utilized during parsing.\n\nReturns\n-------\ncoretypes.DataShape\n    A structured representation of the parsed datashape. Raises a DataShapeSyntaxError if the parsing encounters an invalid datashape or if unrecognized tokens are found at the end of the input.\n\nNotes\n-----\nThe function relies on the DataShapeParser class to handle parsing logic, utilizing methods such as parse_datashape() to interpret the input string according to the syntax rules outlined in the provided code. The `sym` parameter is critical as it provides necessary context for resolving types and dimensions through the symbol table.\"\"\"\n    'Parses a single datashape from a string.\\n\\n    Parameters\\n    ----------\\n    ds_str : string\\n        The datashape string to parse.\\n    sym : TypeSymbolTable\\n        The symbol tables of dimensions, dtypes, and type constructors for each.\\n\\n    '\n    dsp = DataShapeParser(ds_str, sym)\n    ds = dsp.parse_datashape()\n    if ds is None:\n        dsp.raise_error('Invalid datashape')\n    if dsp.pos != dsp.end_pos:\n        dsp.raise_error('Unexpected token in datashape')\n    return ds",
        "docstring": "Parses a datashape from a given string representation. The parse function creates an instance of DataShapeParser that utilizes a lexer to tokenize the input datashape string and to process it according to the defined grammar rules.\n\nParameters\n----------\nds_str : str\n    The datashape string that needs to be parsed into a structured data representation.\nsym : TypeSymbolTable\n    An instance representing the symbol tables for dimension types, data types (dtypes), and type constructors utilized during parsing.\n\nReturns\n-------\ncoretypes.DataShape\n    A structured representation of the parsed datashape. Raises a DataShapeSyntaxError if the parsing encounters an invalid datashape or if unrecognized tokens are found at the end of the input.\n\nNotes\n-----\nThe function relies on the DataShapeParser class to handle parsing logic, utilizing methods such as parse_datashape() to interpret the input string according to the syntax rules outlined in the provided code. The `sym` parameter is critical as it provides necessary context for resolving types and dimensions through the symbol table.",
        "signature": "def parse(ds_str, sym):",
        "type": "Function",
        "class_signature": null
      }
    },
    "datashader/datashape/validation.py": {
      "validate": {
        "code": "def validate(ds):\n    \"\"\"Validate a DataShape to ensure it is well-formed.\n\nParameters\n----------\nds : DataShape\n    A DataShape instance to be validated for proper structure and format.\n\nReturns\n-------\nNone\n    The function raises exceptions if the DataShape is not well-formed, \n    but does not return a value.\n\nRaises\n------\nTypeError\n    If there are multiple ellipses ('...') in the DataShape, or if the measure \n    is an ellipsis.\nDataShapeSyntaxError\n    If the DataShape ends with an ellipsis without a valid data type.\n\nNotes\n-----\nThis function relies on the auxiliary function `traverse`, which applies a \nvalidation function (_validate) recursively to the parameters of the DataShape. \nThe validation checks for specific rules regarding the use of ellipses in \nDataShapes, defined in the coretypes module (imported as T).\"\"\"\n    '\\n    Validate a datashape to see whether it is well-formed.\\n\\n    Parameters\\n    ----------\\n    ds : DataShape\\n\\n    Examples\\n    --------\\n    >>> from datashader.datashape import dshape\\n    >>> dshape(\\'10 * int32\\')\\n    dshape(\"10 * int32\")\\n    >>> dshape(\\'... * int32\\')\\n    dshape(\"... * int32\")\\n    >>> dshape(\\'... * ... * int32\\') # doctest: +IGNORE_EXCEPTION_DETAIL\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Can only use a single wildcard\\n    >>> dshape(\\'T * ... * X * ... * X\\') # doctest: +IGNORE_EXCEPTION_DETAIL\\n    Traceback (most recent call last):\\n        ...\\n    TypeError: Can only use a single wildcard\\n    >>> dshape(\\'T * ...\\') # doctest: +IGNORE_EXCEPTION_DETAIL\\n    Traceback (most recent call last):\\n        ...\\n    DataShapeSyntaxError: Expected a dtype\\n    '\n    traverse(_validate, ds)",
        "docstring": "Validate a DataShape to ensure it is well-formed.\n\nParameters\n----------\nds : DataShape\n    A DataShape instance to be validated for proper structure and format.\n\nReturns\n-------\nNone\n    The function raises exceptions if the DataShape is not well-formed, \n    but does not return a value.\n\nRaises\n------\nTypeError\n    If there are multiple ellipses ('...') in the DataShape, or if the measure \n    is an ellipsis.\nDataShapeSyntaxError\n    If the DataShape ends with an ellipsis without a valid data type.\n\nNotes\n-----\nThis function relies on the auxiliary function `traverse`, which applies a \nvalidation function (_validate) recursively to the parameters of the DataShape. \nThe validation checks for specific rules regarding the use of ellipses in \nDataShapes, defined in the coretypes module (imported as T).",
        "signature": "def validate(ds):",
        "type": "Function",
        "class_signature": null
      }
    },
    "datashader/datashape/util/__init__.py": {
      "dshape": {
        "code": "def dshape(o):\n    \"\"\"Parse a datashape from various input types.\n\nParameters:\n- o: This can be a string representation of a datashape, an instance of coretypes.DataShape, or various coretypes (such as CType, String, Record, JSON, Date, Time, DateTime, Unit, or Mono). It can also be a list or tuple of types.\n\nReturns:\n- An instance of coretypes.DataShape, which represents the parsed datashape.\n\nRaises:\n- TypeError: If the input parameter `o` is of an unsupported type.\n- Validation errors are raised if the resulting datashape does not meet predefined criteria checked by the `validate` function.\n\nDependencies:\n- The function relies on the `parser` module to parse string representations and `validate` from the `validation` module to ensure correctness. \n- Core types used in constructing the datashape are imported from the `coretypes` module.\"\"\"\n    '\\n    Parse a datashape. For a thorough description see\\n    https://datashape.readthedocs.io/en/latest/\\n\\n    >>> ds = dshape(\\'2 * int32\\')\\n    >>> ds[1]\\n    ctype(\"int32\")\\n    '\n    if isinstance(o, coretypes.DataShape):\n        return o\n    if isinstance(o, str):\n        ds = parser.parse(o, type_symbol_table.sym)\n    elif isinstance(o, (coretypes.CType, coretypes.String, coretypes.Record, coretypes.JSON, coretypes.Date, coretypes.Time, coretypes.DateTime, coretypes.Unit)):\n        ds = coretypes.DataShape(o)\n    elif isinstance(o, coretypes.Mono):\n        ds = o\n    elif isinstance(o, (list, tuple)):\n        ds = coretypes.DataShape(*o)\n    else:\n        raise TypeError('Cannot create dshape from object of type %s' % type(o))\n    validate(ds)\n    return ds",
        "docstring": "Parse a datashape from various input types.\n\nParameters:\n- o: This can be a string representation of a datashape, an instance of coretypes.DataShape, or various coretypes (such as CType, String, Record, JSON, Date, Time, DateTime, Unit, or Mono). It can also be a list or tuple of types.\n\nReturns:\n- An instance of coretypes.DataShape, which represents the parsed datashape.\n\nRaises:\n- TypeError: If the input parameter `o` is of an unsupported type.\n- Validation errors are raised if the resulting datashape does not meet predefined criteria checked by the `validate` function.\n\nDependencies:\n- The function relies on the `parser` module to parse string representations and `validate` from the `validation` module to ensure correctness. \n- Core types used in constructing the datashape are imported from the `coretypes` module.",
        "signature": "def dshape(o):",
        "type": "Function",
        "class_signature": null
      }
    },
    "datashader/datashape/predicates.py": {
      "launder": {
        "code": "def launder(ds):\n    \"\"\"Launders a given input into its effective data type representation within a DataShape context.\n\nParameters:\n- ds: This can be a string representing a data shape or an instance of DataShape. If it's a string, it will be converted to a DataShape using the `dshape` function.\n\nReturns:\n- The function returns the underlying type of the data shape or its measure. Specifically, if the input is of type DataShape, it retrieves the measure of that shape. If the measure has an attribute `ty`, it returns that; otherwise, it returns the input itself.\n\nDependencies:\n- This function utilizes the `dshape` function to convert strings into DataShape objects. It assumes that `DataShape` and its associated attributes (like `measure` and `ty`) are defined within the broader module context.\"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape):\n        ds = ds.measure\n    return getattr(ds, 'ty', ds)",
        "docstring": "Launders a given input into its effective data type representation within a DataShape context.\n\nParameters:\n- ds: This can be a string representing a data shape or an instance of DataShape. If it's a string, it will be converted to a DataShape using the `dshape` function.\n\nReturns:\n- The function returns the underlying type of the data shape or its measure. Specifically, if the input is of type DataShape, it retrieves the measure of that shape. If the measure has an attribute `ty`, it returns that; otherwise, it returns the input itself.\n\nDependencies:\n- This function utilizes the `dshape` function to convert strings into DataShape objects. It assumes that `DataShape` and its associated attributes (like `measure` and `ty`) are defined within the broader module context.",
        "signature": "def launder(ds):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "datashader/utils.py:isreal": {},
    "datashader/datashape/predicates.py:launder": {
      "datashader/datashape/coretypes.py": {
        "DataShape.measure": {
          "code": "    def measure(self):\n        return self.parameters[-1]",
          "docstring": "",
          "signature": "def measure(self):",
          "type": "Method",
          "class_signature": "class DataShape(Mono):"
        }
      }
    },
    "datashader/datashape/typesets.py:TypeSet:__contains__": {
      "datashader/datashape/typesets.py": {
        "TypeSet._set": {
          "code": "    def _set(self):\n        return set(self._order)",
          "docstring": "",
          "signature": "def _set(self):",
          "type": "Method",
          "class_signature": "class TypeSet(Unit):"
        }
      },
      "datashader/datashape/coretypes.py": {
        "Mono.__hash__": {
          "code": "    def __hash__(self):\n        try:\n            h = self._hash\n        except AttributeError:\n            h = self._hash = hash(self.shape) ^ hash(self.measure.info())\n        return h",
          "docstring": "",
          "signature": "def __hash__(self):",
          "type": "Method",
          "class_signature": "class Mono(metaclass=Type):"
        }
      }
    },
    "datashader/datashape/util/__init__.py:dshape": {},
    "datashader/datashape/parser.py:parse": {
      "datashader/datashape/parser.py": {
        "DataShapeParser.__init__": {
          "code": "    def __init__(self, ds_str, sym):\n        self.ds_str = ds_str\n        self.sym = sym\n        self.lex = lexer.lex(ds_str)\n        self.tokens = []\n        self.pos = -1\n        self.end_pos = None\n        self.advance_tok()",
          "docstring": "",
          "signature": "def __init__(self, ds_str, sym):",
          "type": "Method",
          "class_signature": "class DataShapeParser:"
        },
        "DataShapeParser.parse_datashape": {
          "code": "    def parse_datashape(self):\n        \"\"\"\n        datashape : datashape_nooption\n                  | QUESTIONMARK datashape_nooption\n                  | EXCLAMATIONMARK datashape_nooption\n\n        Returns a datashape object or None.\n        \"\"\"\n        tok = self.tok\n        constructors = {lexer.QUESTIONMARK: 'option'}\n        if tok.id in constructors:\n            self.advance_tok()\n            saved_pos = self.pos\n            ds = self.parse_datashape_nooption()\n            if ds is not None:\n                option = self.syntactic_sugar(self.sym.dtype_constr, constructors[tok.id], '%s dtype construction' % constructors[tok.id], saved_pos - 1)\n                return coretypes.DataShape(option(ds))\n        else:\n            return self.parse_datashape_nooption()",
          "docstring": "datashape : datashape_nooption\n          | QUESTIONMARK datashape_nooption\n          | EXCLAMATIONMARK datashape_nooption\n\nReturns a datashape object or None.",
          "signature": "def parse_datashape(self):",
          "type": "Method",
          "class_signature": "class DataShapeParser:"
        }
      }
    },
    "datashader/datashape/validation.py:validate": {
      "datashader/datashape/validation.py": {
        "traverse": {
          "code": "def traverse(f, t):\n    \"\"\"\n    Map `f` over `t`, calling `f` with type `t` and the map result of the\n    mapping `f` over `t` 's parameters.\n\n    Parameters\n    ----------\n    f : callable\n    t : DataShape\n\n    Returns\n    -------\n    DataShape\n    \"\"\"\n    if isinstance(t, T.Mono) and (not isinstance(t, T.Unit)):\n        return f(t, [traverse(f, p) for p in t.parameters])\n    return t",
          "docstring": "Map `f` over `t`, calling `f` with type `t` and the map result of the\nmapping `f` over `t` 's parameters.\n\nParameters\n----------\nf : callable\nt : DataShape\n\nReturns\n-------\nDataShape",
          "signature": "def traverse(f, t):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "datashader/utils.py:apply": {
      "datashader/tests/test_utils.py": {
        "f": {
          "code": "    def f(a, b, c=1, d=2):\n        return a + b + c + d",
          "docstring": "",
          "signature": "def f(a, b, c=1, d=2):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "datashader/utils.py:orient_array": {},
    "datashader/utils.py:calc_res": {},
    "datashader/utils.py:_flip_array": {}
  },
  "call_tree": {
    "datashader/tests/test_utils.py:test_Dispatcher": {
      "datashader/utils.py:Dispatcher:__init__": {},
      "datashader/utils.py:Dispatcher:register": {},
      "datashader/tests/test_utils.py:Bar": {},
      "datashader/utils.py:Dispatcher:__call__": {}
    },
    "datashader/tests/test_utils.py:test_isreal": {
      "datashader/utils.py:isreal": {
        "datashader/datashape/predicates.py:launder": {
          "datashader/datashape/util/__init__.py:dshape": {
            "datashader/datashape/parser.py:parse": {
              "datashader/datashape/parser.py:DataShapeParser:__init__": {
                "datashader/datashape/parser.py:DataShapeParser:advance_tok": {
                  "datashader/datashape/lexer.py:lex": {}
                }
              },
              "datashader/datashape/parser.py:DataShapeParser:parse_datashape": {
                "datashader/datashape/parser.py:DataShapeParser:tok": {},
                "datashader/datashape/parser.py:DataShapeParser:parse_datashape_nooption": {
                  "datashader/datashape/parser.py:DataShapeParser:parse_dim": {
                    "datashader/datashape/parser.py:DataShapeParser:tok": {},
                    "datashader/datashape/parser.py:DataShapeParser:advance_tok": {
                      "datashader/datashape/lexer.py:lex": {}
                    }
                  },
                  "datashader/datashape/parser.py:DataShapeParser:parse_dtype": {
                    "datashader/datashape/parser.py:DataShapeParser:tok": {},
                    "datashader/datashape/parser.py:DataShapeParser:advance_tok": {},
                    "datashader/datashape/parser.py:DataShapeParser:parse_struct_type": {
                      "datashader/datashape/parser.py:DataShapeParser:tok": {},
                      "datashader/datashape/parser.py:DataShapeParser:advance_tok": {},
                      "datashader/datashape/parser.py:DataShapeParser:parse_homogeneous_list": {},
                      "datashader/datashape/parser.py:DataShapeParser:syntactic_sugar": {},
                      "datashader/datashape/type_symbol_table.py:_struct": {}
                    }
                  },
                  "datashader/datashape/coretypes.py:Mono:__len__": {},
                  "datashader/datashape/coretypes.py:DataShape:__init__": {
                    "datashader/datashape/coretypes.py:_launder": {}
                  }
                },
                "datashader/datashape/parser.py:DataShapeParser:advance_tok": {
                  "datashader/datashape/lexer.py:lex": {}
                },
                "datashader/datashape/parser.py:DataShapeParser:syntactic_sugar": {},
                "datashader/datashape/coretypes.py:Option:__init__": {
                  "datashader/datashape/coretypes.py:_launder": {
                    "datashader/datashape/coretypes.py:DataShape:__len__": {
                      "datashader/datashape/coretypes.py:Mono:parameters": {}
                    },
                    "datashader/datashape/coretypes.py:DataShape:__getitem__": {
                      "datashader/datashape/coretypes.py:Mono:parameters": {}
                    }
                  }
                },
                "datashader/datashape/coretypes.py:DataShape:__init__": {
                  "datashader/datashape/coretypes.py:_launder": {}
                }
              }
            },
            "datashader/datashape/validation.py:validate": {
              "datashader/datashape/validation.py:traverse": {
                "datashader/datashape/coretypes.py:Mono:parameters": {
                  "datashader/datashape/coretypes.py:Mono:_slotted": {}
                },
                "datashader/datashape/validation.py:traverse": {
                  "[ignored_or_cut_off]": "..."
                },
                "datashader/datashape/validation.py:_validate": {
                  "datashader/datashape/coretypes.py:Mono:parameters": {
                    "datashader/datashape/coretypes.py:Mono:_slotted": {}
                  }
                }
              }
            }
          },
          "datashader/datashape/coretypes.py:DataShape:measure": {
            "datashader/datashape/coretypes.py:Mono:parameters": {
              "datashader/datashape/coretypes.py:Mono:_slotted": {}
            }
          }
        },
        "datashader/datashape/typesets.py:TypeSet:__contains__": {
          "datashader/datashape/typesets.py:TypeSet:_set": {
            "datashader/datashape/coretypes.py:Mono:__hash__": {}
          },
          "datashader/datashape/coretypes.py:Mono:__hash__": {}
        }
      },
      "datashader/datashape/util/__init__.py:dshape": {
        "datashader/datashape/parser.py:parse": {
          "datashader/datashape/parser.py:DataShapeParser:__init__": {
            "datashader/datashape/parser.py:DataShapeParser:advance_tok": {
              "datashader/datashape/lexer.py:lex": {}
            }
          },
          "datashader/datashape/parser.py:DataShapeParser:parse_datashape": {
            "datashader/datashape/parser.py:DataShapeParser:tok": {},
            "datashader/datashape/parser.py:DataShapeParser:parse_datashape_nooption": {
              "datashader/datashape/parser.py:DataShapeParser:parse_dim": {
                "datashader/datashape/parser.py:DataShapeParser:tok": {},
                "datashader/datashape/parser.py:DataShapeParser:advance_tok": {
                  "datashader/datashape/lexer.py:lex": {}
                }
              },
              "datashader/datashape/parser.py:DataShapeParser:parse_dtype": {
                "datashader/datashape/parser.py:DataShapeParser:tok": {},
                "datashader/datashape/parser.py:DataShapeParser:advance_tok": {}
              },
              "datashader/datashape/coretypes.py:Mono:__len__": {},
              "datashader/datashape/coretypes.py:DataShape:__init__": {
                "datashader/datashape/coretypes.py:_launder": {}
              }
            }
          }
        },
        "datashader/datashape/validation.py:validate": {
          "datashader/datashape/validation.py:traverse": {
            "datashader/datashape/coretypes.py:Mono:parameters": {
              "datashader/datashape/coretypes.py:Mono:_slotted": {}
            },
            "datashader/datashape/validation.py:traverse": {
              "[ignored_or_cut_off]": "..."
            },
            "datashader/datashape/validation.py:_validate": {
              "datashader/datashape/coretypes.py:Mono:parameters": {
                "datashader/datashape/coretypes.py:Mono:_slotted": {}
              }
            }
          }
        }
      }
    },
    "datashader/tests/test_utils.py:test_apply": {
      "datashader/utils.py:apply": {
        "datashader/tests/test_utils.py:f": {}
      }
    },
    "datashader/tests/test_utils.py:test_calc_res": {
      "datashader/utils.py:calc_res": {}
    },
    "datashader/tests/test_utils.py:test_orient_array": {
      "datashader/utils.py:orient_array": {
        "datashader/utils.py:calc_res": {},
        "datashader/utils.py:_flip_array": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: datashader-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 datashader/\n    \u251c\u2500\u2500 datashape/\n    \u2502   \u251c\u2500\u2500 parser.py\n    \u2502   \u2502   \u2514\u2500\u2500 parse\n    \u2502   \u251c\u2500\u2500 predicates.py\n    \u2502   \u2502   \u2514\u2500\u2500 launder\n    \u2502   \u251c\u2500\u2500 typesets.py\n    \u2502   \u2502   \u2514\u2500\u2500 TypeSet.__contains__\n    \u2502   \u251c\u2500\u2500 util/\n    \u2502   \u2502   \u2514\u2500\u2500 __init__.py\n    \u2502   \u2502       \u2514\u2500\u2500 dshape\n    \u2502   \u2514\u2500\u2500 validation.py\n    \u2502       \u2514\u2500\u2500 validate\n    \u2514\u2500\u2500 utils.py\n        \u251c\u2500\u2500 Dispatcher.__call__\n        \u251c\u2500\u2500 Dispatcher.__init__\n        \u251c\u2500\u2500 Dispatcher.register\n        \u251c\u2500\u2500 _flip_array\n        \u251c\u2500\u2500 apply\n        \u251c\u2500\u2500 calc_res\n        \u251c\u2500\u2500 isreal\n        \u2514\u2500\u2500 orient_array\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides utility functions and tools to facilitate data transformation, resolution calculation, and array orientation for structured data, particularly focusing on enhancing data manipulation workflows with libraries like xarray and datashader. Its primary functionality includes dynamic function dispatching based on input data types, validation of numerical data types, efficient parameter application to functions, resolution computation for grid-based data, and re-orientation of arrays to conform to specific coordinate alignments. These capabilities streamline processes for developers working with multidimensional datasets, enabling easier data preprocessing, analysis, and consistency in spatial or numerical workflows. By abstracting these common patterns, the module reduces complexity and improves code reuse, making it a valuable component for handling structured data transformations.\n\n## FILE 1: datashader/datashape/typesets.py\n\n- CLASS METHOD: TypeSet.__contains__\n  - CLASS SIGNATURE: class TypeSet(Unit):\n  - SIGNATURE: def __contains__(self, val):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a value is part of the TypeSet.\n\nParameters\n----------\nval : type\n    The value to check for membership in the TypeSet.\n\nReturns\n-------\nbool\n    Returns True if the specified value is contained in the TypeSet, otherwise returns False.\n\nNotes\n-----\nThis method utilizes the `_set` property, which is a set of types encapsulated in the TypeSet, to determine membership. The `__contains__` method is part of the `TypeSet` class, which represents a collection of data types defined for use in a type system.\n\"\"\"\n```\n\n## FILE 2: datashader/utils.py\n\n- FUNCTION NAME: isreal\n  - SIGNATURE: def isreal(dt):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a datashape is numeric and real.\n\nParameters\n----------\ndt : str or datashape.Type\n    The datashape representation (e.g., a string like 'int32', 'float64', etc.) to be checked.\n\nReturns\n-------\nbool\n    Returns True if the datashape is a numeric type and specifically a real number, \n    otherwise returns False.\n\nNotes\n-----\nThis function uses `datashape.predicates.launder` to normalize the input, \nand it checks its membership in `datashape.typesets.real`, which is defined\nin the `datashape` module imported at the beginning of the code. It is\nimportant for ensuring that the datashape type is properly classified.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/datashape/typesets.py:TypeSet:__contains__\n    - datashader/datashape/predicates.py:launder\n\n- FUNCTION NAME: calc_res\n  - SIGNATURE: def calc_res(raster):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the resolution of an xarray.DataArray raster.\n\nParameters\n----------\nraster : xarray.DataArray\n    The input raster from which resolution is to be calculated. The raster \n    should have dimensions that include coordinate axes, typically representing \n    geographical data.\n\nReturns\n-------\ntuple\n    A two-tuple (xres, yres) representing the resolutions in the x and y \n    dimensions, respectively. The y-resolution is positive if the y-coordinates \n    are decreasing.\n\nNotes\n-----\nThis function interprets the raster's last two dimensions to determine its \nshape and extracts coordinate values using the specified dimension names. \nIt is typically used in conjunction with raster processing steps within the \nlarger context of data handling for geographical visualizations or analyses.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/utils.py:orient_array\n\n- CLASS METHOD: Dispatcher.register\n  - CLASS SIGNATURE: class Dispatcher:\n  - SIGNATURE: def register(self, typ, func=None):\n  - DOCSTRING: \n```python\n\"\"\"\nRegister a function for single dispatch on a specified type.\n\nParameters\n----------\ntyp : type or tuple of types\n    The type or tuple of types on which to dispatch the specified function.\nfunc : callable or None, optional\n    The function to register for the dispatch. If None, returns a decorator\n    that can be used to register a function.\n\nReturns\n-------\ncallable\n    The registered function, allowing for further chaining or reuse.\n\nNotes\n-----\nWhen `func` is None, the method returns a decorator to register the function \npassed into it. If `typ` is a tuple, the function is registered for each \ntype in the tuple. The registered functions are stored in the \n`self._lookup` dictionary for efficient dispatching based on the type of \nthe first argument.\n\nThis method enables dynamic method registration and retrieval based on \ntype-checking, allowing for flexible handling of various input types.\n\"\"\"\n```\n\n- CLASS METHOD: Dispatcher.__call__\n  - CLASS SIGNATURE: class Dispatcher:\n  - SIGNATURE: def __call__(self, head, *rest, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nDispatches a function based on the type of the first argument (`head`).\n\nThis method checks if the type of `head` is registered in the dispatcher. If found, it invokes the associated function with `head` and any additional arguments (`rest` and `kwargs`). If not, it iterates through the method resolution order (MRO) of `head`'s type to find a matching dispatcher. If no match is found, a `TypeError` is raised.\n\nParameters\n----------\nhead: Any\n    The first argument used to determine the dispatch function based on its type.\n*rest: Any\n    Additional positional arguments passed to the dispatched function.\n**kwargs: Any\n    Additional keyword arguments passed to the dispatched function.\n\nReturns\n-------\nAny\n    The result of the dispatched function call.\n\nRaises\n------\nTypeError\n    If no registered function matches the type of `head` or its MRO.\n\nNotes\n-----\nThe method uses the `_lookup` attribute, a dictionary that stores type-function mappings,\nto efficiently find the appropriate function. The `getmro` function from the `inspect` module\nis utilized to access the MRO of `head`'s type, facilitating fallback dispatching.\n\"\"\"\n```\n\n- FUNCTION NAME: orient_array\n  - SIGNATURE: def orient_array(raster, res=None, layer=None):\n  - DOCSTRING: \n```python\n\"\"\"\nReorients a 2D NumPy array representing a raster based on the resolution values for x and y axes.\n\nParameters\n----------\nraster : DataArray\n    An xarray DataArray containing the raster data to be reoriented.\nres : tuple, optional\n    A two-tuple (int, int) representing x and y resolutions (grid/cell sizes).\n    If not provided, the function calculates the resolution using `calc_res`.\nlayer : int, optional\n    The index of the specific layer within the raster to be reoriented (1-based index).\n\nReturns\n-------\narray : numpy.ndarray\n    A 2D NumPy ndarray that represents the reoriented raster data.\n\nNotes\n-----\nThis function checks the signs of the resolution components to determine if the array needs to be flipped along the x or y axes. The function relies on the helper function `_flip_array` to perform the actual flipping, as needed. It uses `calc_res` to obtain resolution information if not supplied directly. The dimensions and orientation of the output array will depend on the resolution values provided, ensuring the spatial orientation of the raster data is consistent with its geographic context.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/utils.py:_flip_array\n    - datashader/utils.py:calc_res\n\n- FUNCTION NAME: _flip_array\n  - SIGNATURE: def _flip_array(array, xflip, yflip):\n  - DOCSTRING: \n```python\n\"\"\"\nHelper function to flip a multidimensional array either horizontally (x-axis) or vertically (y-axis) based on specified flags.\n\nParameters\n----------\narray : numpy.ndarray\n    The input array to be flipped. It can have 2 or 3 dimensions where the last dimension corresponds to the x-axis and the second-to-last to the y-axis.\nxflip : bool\n    A flag indicating whether to flip the array along the x-axis (horizontal flip).\nyflip : bool\n    A flag indicating whether to flip the array along the y-axis (vertical flip).\n\nReturns\n-------\nnumpy.ndarray\n    The flipped version of the input array based on the specified flags.\n\nThis function is primarily utilized in the `orient_array` function to ensure that raster data is oriented correctly for further processing or visualization. It interacts with other functions that may adjust array orientations based on geospatial or raster data requirements.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/utils.py:orient_array\n\n- CLASS METHOD: Dispatcher.__init__\n  - CLASS SIGNATURE: class Dispatcher:\n  - SIGNATURE: def __init__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the Dispatcher instance.\n\nThis constructor creates the `_lookup` attribute, which is a dictionary that will \nstore type-function mappings for single dispatching. The primary function of this \nclass is to facilitate the registration and calling of functions based on the \ntype of the first argument provided during the invocation. \n\nAttributes\n----------\n_lookup : dict\n    A dictionary to map argument types to corresponding functions\n    for type-based dispatching.\n\"\"\"\n```\n\n- FUNCTION NAME: apply\n  - SIGNATURE: def apply(func, args, kwargs=None):\n  - DOCSTRING: \n```python\n\"\"\"\nApply a function with specified arguments and optional keyword arguments.\n\nParameters\n----------\nfunc : callable\n    The function to be applied.\nargs : tuple\n    A tuple of positional arguments to pass to the function.\nkwargs : dict, optional\n    A dictionary of keyword arguments to pass to the function.\n\nReturns\n-------\nThe return value of the function `func` when called with `args` and `kwargs`. \nIf `kwargs` is not provided, the function is invoked with only `args`.\n\nThis function is a utility that simplifies the invocation of callable objects with varying numbers of arguments, helping to maintain cleaner and more flexible code. No significant constants or variables are defined within this function; it relies on the provided parameters for its operation and outputs the result of the executed function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/tests/test_utils.py:f\n\n## FILE 3: datashader/datashape/parser.py\n\n- FUNCTION NAME: parse\n  - SIGNATURE: def parse(ds_str, sym):\n  - DOCSTRING: \n```python\n\"\"\"\nParses a datashape from a given string representation. The parse function creates an instance of DataShapeParser that utilizes a lexer to tokenize the input datashape string and to process it according to the defined grammar rules.\n\nParameters\n----------\nds_str : str\n    The datashape string that needs to be parsed into a structured data representation.\nsym : TypeSymbolTable\n    An instance representing the symbol tables for dimension types, data types (dtypes), and type constructors utilized during parsing.\n\nReturns\n-------\ncoretypes.DataShape\n    A structured representation of the parsed datashape. Raises a DataShapeSyntaxError if the parsing encounters an invalid datashape or if unrecognized tokens are found at the end of the input.\n\nNotes\n-----\nThe function relies on the DataShapeParser class to handle parsing logic, utilizing methods such as parse_datashape() to interpret the input string according to the syntax rules outlined in the provided code. The `sym` parameter is critical as it provides necessary context for resolving types and dimensions through the symbol table.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/datashape/util/__init__.py:dshape\n    - datashader/datashape/parser.py:DataShapeParser:__init__\n    - datashader/datashape/parser.py:DataShapeParser:parse_datashape\n\n## FILE 4: datashader/datashape/validation.py\n\n- FUNCTION NAME: validate\n  - SIGNATURE: def validate(ds):\n  - DOCSTRING: \n```python\n\"\"\"\nValidate a DataShape to ensure it is well-formed.\n\nParameters\n----------\nds : DataShape\n    A DataShape instance to be validated for proper structure and format.\n\nReturns\n-------\nNone\n    The function raises exceptions if the DataShape is not well-formed, \n    but does not return a value.\n\nRaises\n------\nTypeError\n    If there are multiple ellipses ('...') in the DataShape, or if the measure \n    is an ellipsis.\nDataShapeSyntaxError\n    If the DataShape ends with an ellipsis without a valid data type.\n\nNotes\n-----\nThis function relies on the auxiliary function `traverse`, which applies a \nvalidation function (_validate) recursively to the parameters of the DataShape. \nThe validation checks for specific rules regarding the use of ellipses in \nDataShapes, defined in the coretypes module (imported as T).\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/datashape/validation.py:traverse\n    - datashader/datashape/util/__init__.py:dshape\n\n## FILE 5: datashader/datashape/util/__init__.py\n\n- FUNCTION NAME: dshape\n  - SIGNATURE: def dshape(o):\n  - DOCSTRING: \n```python\n\"\"\"\nParse a datashape from various input types.\n\nParameters:\n- o: This can be a string representation of a datashape, an instance of coretypes.DataShape, or various coretypes (such as CType, String, Record, JSON, Date, Time, DateTime, Unit, or Mono). It can also be a list or tuple of types.\n\nReturns:\n- An instance of coretypes.DataShape, which represents the parsed datashape.\n\nRaises:\n- TypeError: If the input parameter `o` is of an unsupported type.\n- Validation errors are raised if the resulting datashape does not meet predefined criteria checked by the `validate` function.\n\nDependencies:\n- The function relies on the `parser` module to parse string representations and `validate` from the `validation` module to ensure correctness. \n- Core types used in constructing the datashape are imported from the `coretypes` module.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/datashape/validation.py:validate\n    - datashader/datashape/parser.py:parse\n\n## FILE 6: datashader/datashape/predicates.py\n\n- FUNCTION NAME: launder\n  - SIGNATURE: def launder(ds):\n  - DOCSTRING: \n```python\n\"\"\"\nLaunders a given input into its effective data type representation within a DataShape context.\n\nParameters:\n- ds: This can be a string representing a data shape or an instance of DataShape. If it's a string, it will be converted to a DataShape using the `dshape` function.\n\nReturns:\n- The function returns the underlying type of the data shape or its measure. Specifically, if the input is of type DataShape, it retrieves the measure of that shape. If the measure has an attribute `ty`, it returns that; otherwise, it returns the input itself.\n\nDependencies:\n- This function utilizes the `dshape` function to convert strings into DataShape objects. It assumes that `DataShape` and its associated attributes (like `measure` and `ty`) are defined within the broader module context.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/utils.py:isreal\n    - datashader/datashape/util/__init__.py:dshape\n    - datashader/datashape/coretypes.py:DataShape:measure\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "datashader/datashape/typesets.py": "\"\"\"\nTraits constituting sets of types.\n\"\"\"\nfrom itertools import chain\nfrom .coretypes import Unit, int8, int16, int32, int64, uint8, uint16, uint32, uint64, float16, float32, float64, complex64, complex128, bool_, Decimal, TimeDelta, Option\n__all__ = ['TypeSet', 'matches_typeset', 'signed', 'unsigned', 'integral', 'floating', 'complexes', 'boolean', 'numeric', 'scalar', 'maxtype']\n\nclass TypeSet(Unit):\n    \"\"\"\n    Create a new set of types. Keyword argument 'name' may create a registered\n    typeset for use in datashape type strings.\n    \"\"\"\n    __slots__ = ('_order', 'name')\n\n    def __init__(self, *args, **kwds):\n        self._order = args\n        self.name = kwds.get('name')\n        if self.name:\n            register_typeset(self.name, self)\n\n    @property\n    def _set(self):\n        return set(self._order)\n\n    @property\n    def types(self):\n        return self._order\n\n    def __eq__(self, other):\n        return isinstance(other, type(self)) and self.name == other.name and (self.types == other.types)\n\n    def __hash__(self):\n        return hash((self.name, self.types))\n\n    def __repr__(self):\n        if self.name:\n            return '{%s}' % (self.name,)\n        return '%s(%s, name=%s)' % (self.__class__.__name__, self._set, self.name)\n\n    def __or__(self, other):\n        return TypeSet(*chain(self, other))\n\n    def __iter__(self):\n        return iter(self._order)\n\n    def __len__(self):\n        return len(self._set)\n\ndef matches_typeset(types, signature):\n    \"\"\"Match argument types to the parameter types of a signature\n\n    >>> matches_typeset(int32, integral)\n    True\n    >>> matches_typeset(float32, integral)\n    False\n    >>> matches_typeset(integral, real)\n    True\n    \"\"\"\n    if types in signature:\n        return True\n    match = True\n    for a, b in zip(types, signature):\n        check = isinstance(b, TypeSet)\n        if check and a not in b or (not check and a != b):\n            match = False\n            break\n    return match\n\nclass TypesetRegistry:\n\n    def __init__(self):\n        self.registry = {}\n        self.lookup = self.registry.get\n\n    def register_typeset(self, name, typeset):\n        if name in self.registry:\n            raise TypeError('TypeSet %s already defined with types %s' % (name, self.registry[name].types))\n        self.registry[name] = typeset\n        return typeset\n\n    def __getitem__(self, key):\n        value = self.lookup(key)\n        if value is None:\n            raise KeyError(key)\n        return value\nregistry = TypesetRegistry()\nregister_typeset = registry.register_typeset\nlookup = registry.lookup\nsigned = TypeSet(int8, int16, int32, int64, name='signed')\nunsigned = TypeSet(uint8, uint16, uint32, uint64, name='unsigned')\nintegral = TypeSet(*[x for t in zip(signed, unsigned) for x in t], name='integral')\nfloating = TypeSet(float16, float32, float64, name='floating')\ncomplexes = TypeSet(complex64, complex128, name='complexes')\nboolean = TypeSet(bool_, name='boolean')\nreal = TypeSet(*integral | floating, name='real')\nnumeric = TypeSet(*integral | floating | complexes, name='numeric')\nscalar = TypeSet(*boolean | numeric, name='scalar')\nsupertype_map = {int8: signed, int16: signed, int32: signed, int64: signed, uint8: unsigned, uint16: unsigned, uint32: unsigned, uint64: unsigned, float16: floating, float32: floating, float64: floating, complex64: complexes, complex128: complexes, bool_: boolean}\n\ndef supertype(measure):\n    \"\"\"Get the super type of a concrete numeric type\n\n    Examples\n    --------\n    >>> supertype(int8)\n    {signed}\n\n    >>> supertype(float32)\n    {floating}\n\n    >>> supertype(complex128)\n    {complexes}\n\n    >>> supertype(bool_)\n    {boolean}\n\n    >>> supertype(Option(bool_))\n    {boolean}\n    \"\"\"\n    if isinstance(measure, Option):\n        measure = measure.ty\n    assert matches_typeset(measure, scalar), 'measure must be numeric'\n    return supertype_map[measure]\n\ndef maxtype(measure):\n    \"\"\"Get the maximum width for a particular numeric type\n\n    Examples\n    --------\n    >>> maxtype(int8)\n    ctype(\"int64\")\n\n    >>> maxtype(Option(float64))\n    Option(ty=ctype(\"float64\"))\n\n    >>> maxtype(bool_)\n    ctype(\"bool\")\n\n    >>> maxtype(Decimal(11, 2))\n    Decimal(precision=11, scale=2)\n\n    >>> maxtype(Option(Decimal(11, 2)))\n    Option(ty=Decimal(precision=11, scale=2))\n\n    >>> maxtype(TimeDelta(unit='ms'))\n    TimeDelta(unit='ms')\n\n    >>> maxtype(Option(TimeDelta(unit='ms')))\n    Option(ty=TimeDelta(unit='ms'))\n    \"\"\"\n    measure = measure.measure\n    isoption = isinstance(measure, Option)\n    if isoption:\n        measure = measure.ty\n    if not matches_typeset(measure, scalar) and (not isinstance(measure, (Decimal, TimeDelta))):\n        raise TypeError('measure must be numeric')\n    if measure == bool_:\n        result = bool_\n    elif isinstance(measure, (Decimal, TimeDelta)):\n        result = measure\n    else:\n        result = max(supertype(measure).types, key=lambda x: x.itemsize)\n    return Option(result) if isoption else result",
    "datashader/utils.py": "from __future__ import annotations\nimport os\nimport re\nfrom inspect import getmro\nimport numba as nb\nimport numpy as np\nimport pandas as pd\nfrom toolz import memoize\nfrom xarray import DataArray\nimport datashader.datashape as datashape\ntry:\n    import dask.dataframe as dd\nexcept ImportError:\n    dd = None\ntry:\n    from datashader.datatypes import RaggedDtype\nexcept ImportError:\n    RaggedDtype = type(None)\ntry:\n    import cudf\nexcept Exception:\n    cudf = None\ntry:\n    from geopandas.array import GeometryDtype as gpd_GeometryDtype\nexcept ImportError:\n    gpd_GeometryDtype = type(None)\ntry:\n    from spatialpandas.geometry import GeometryDtype\nexcept ImportError:\n    GeometryDtype = type(None)\n\nclass VisibleDeprecationWarning(UserWarning):\n    \"\"\"Visible deprecation warning.\n\n    By default, python will not show deprecation warnings, so this class\n    can be used when a very visible warning is helpful, for example because\n    the usage is most likely a user bug.\n    \"\"\"\nngjit = nb.jit(nopython=True, nogil=True)\nngjit_parallel = nb.jit(nopython=True, nogil=True, parallel=True)\nnumba_version = tuple([int(x) for x in re.match('([0-9]+)\\\\.([0-9]+)\\\\.([0-9]+)', nb.__version__).groups()])\n\nclass Expr:\n    \"\"\"Base class for expression-like objects.\n\n    Implements hashing and equality checks. Subclasses should implement an\n    ``inputs`` attribute/property, containing a tuple of everything that fully\n    defines that expression.\n    \"\"\"\n\n    def __hash__(self):\n        return hash((type(self), self._hashable_inputs()))\n\n    def __eq__(self, other):\n        return type(self) is type(other) and self._hashable_inputs() == other._hashable_inputs()\n\n    def __ne__(self, other):\n        return not self == other\n\n    def _hashable_inputs(self):\n        \"\"\"\n        Return a version of the inputs tuple that is suitable for hashing and\n        equality comparisons\n        \"\"\"\n        result = []\n        for ip in self.inputs:\n            if isinstance(ip, (list, set)):\n                result.append(tuple(ip))\n            elif isinstance(ip, np.ndarray):\n                result.append(ip.tobytes())\n            else:\n                result.append(ip)\n        return tuple(result)\n\nclass Dispatcher:\n    \"\"\"Simple single dispatch.\"\"\"\n\ndef isrealfloat(dt):\n    \"\"\"Check if a datashape is numeric and real.\n\n    Example\n    -------\n    >>> isrealfloat('int32')\n    False\n    >>> isrealfloat('float64')\n    True\n    >>> isrealfloat('string')\n    False\n    >>> isrealfloat('complex64')\n    False\n    \"\"\"\n    dt = datashape.predicates.launder(dt)\n    return isinstance(dt, datashape.Unit) and dt in datashape.typesets.floating\n\ndef nansum_missing(array, axis):\n    \"\"\"nansum where all-NaN values remain NaNs.\n\n    Note: In NumPy <=1.9 NaN is returned for slices that are\n    all NaN, while later versions return 0. This function emulates\n    the older behavior, which allows using NaN as a missing value\n    indicator.\n\n    Parameters\n    ----------\n    array: Array to sum over\n    axis:  Axis to sum over\n    \"\"\"\n    T = list(range(array.ndim))\n    T.remove(axis)\n    T.insert(0, axis)\n    array = array.transpose(T)\n    missing_vals = np.isnan(array)\n    all_empty = np.all(missing_vals, axis=0)\n    set_to_zero = missing_vals & ~all_empty\n    return np.where(set_to_zero, 0, array).sum(axis=0)\n\ndef calc_bbox(xs, ys, res):\n    \"\"\"Calculate the bounding box of a raster, and return it in a four-element\n    tuple: (xmin, ymin, xmax, ymax). This calculation assumes the raster is\n    uniformly sampled (equivalent to a flat-earth assumption, for geographic\n    data) so that an affine transform (using the \"Augmented Matrix\" approach)\n    suffices:\n    https://en.wikipedia.org/wiki/Affine_transformation#Augmented_matrix\n\n    Parameters\n    ----------\n    xs : numpy.array\n        1D NumPy array of floats representing the x-values of a raster. This\n        likely originated from an xarray.DataArray or xarray.Dataset object\n        (xr.open_rasterio).\n    ys : numpy.array\n        1D NumPy array of floats representing the y-values of a raster. This\n        likely originated from an xarray.DataArray or xarray.Dataset object\n        (xr.open_rasterio).\n    res : tuple\n        Two-tuple (int, int) which includes x and y resolutions (aka \"grid/cell\n        sizes\"), respectively.\n    \"\"\"\n    xbound = xs.max() if res[0] < 0 else xs.min()\n    ybound = ys.min() if res[1] < 0 else ys.max()\n    xmin = ymin = np.inf\n    xmax = ymax = -np.inf\n    Ab = np.array([[res[0], 0.0, xbound], [0.0, -res[1], ybound], [0.0, 0.0, 1.0]])\n    for x_, y_ in [(0, 0), (0, len(ys)), (len(xs), 0), (len(xs), len(ys))]:\n        x, y, _ = np.dot(Ab, np.array([x_, y_, 1.0]))\n        if x < xmin:\n            xmin = x\n        if x > xmax:\n            xmax = x\n        if y < ymin:\n            ymin = y\n        if y > ymax:\n            ymax = y\n    xpad, ypad = (res[0] / 2.0, res[1] / 2.0)\n    return (xmin - xpad, ymin + ypad, xmax - xpad, ymax + ypad)\n\ndef get_indices(start, end, coords, res):\n    \"\"\"\n    Transform continuous start and end coordinates into array indices.\n\n    Parameters\n    ----------\n    start : float\n        coordinate of the lower bound.\n    end : float\n        coordinate of the upper bound.\n    coords : numpy.ndarray\n        coordinate values along the axis.\n    res : tuple\n        Resolution along an axis (aka \"grid/cell sizes\")\n    \"\"\"\n    size = len(coords)\n    half = abs(res) / 2.0\n    vmin, vmax = (coords.min(), coords.max())\n    span = vmax - vmin\n    start, end = (start + half - vmin, end - half - vmin)\n    sidx, eidx = (int(start / span * size), int(end / span * size))\n    if eidx < sidx:\n        return (sidx, sidx)\n    return (sidx, eidx)\n\ndef downsample_aggregate(aggregate, factor, how='mean'):\n    \"\"\"Create downsampled aggregate factor in pixels units\"\"\"\n    ys, xs = aggregate.shape[:2]\n    crarr = aggregate[:ys - ys % int(factor), :xs - xs % int(factor)]\n    concat = np.concatenate([[crarr[i::factor, j::factor] for i in range(factor)] for j in range(factor)])\n    if how == 'mean':\n        return np.nanmean(concat, axis=0)\n    elif how == 'sum':\n        return np.nansum(concat, axis=0)\n    elif how == 'max':\n        return np.nanmax(concat, axis=0)\n    elif how == 'min':\n        return np.nanmin(concat, axis=0)\n    elif how == 'median':\n        return np.nanmedian(concat, axis=0)\n    elif how == 'std':\n        return np.nanstd(concat, axis=0)\n    elif how == 'var':\n        return np.nanvar(concat, axis=0)\n    else:\n        raise ValueError(\"Invalid 'how' downsample method. Options mean, sum, max, min, median, std, var\")\n\ndef summarize_aggregate_values(aggregate, how='linear', num=180):\n    \"\"\"Helper function similar to np.linspace which return values from aggregate min value to\n    aggregate max value in either linear or log space.\n    \"\"\"\n    max_val = np.nanmax(aggregate.values)\n    min_val = np.nanmin(aggregate.values)\n    if min_val == 0:\n        min_val = aggregate.data[aggregate.data > 0].min()\n    if how == 'linear':\n        vals = np.linspace(min_val, max_val, num)[None, :]\n    else:\n        vals = (np.logspace(0, np.log1p(max_val - min_val), base=np.e, num=num, dtype=min_val.dtype) + min_val)[None, :]\n    return (DataArray(vals), min_val, max_val)\n\ndef hold(f):\n    \"\"\"\n    simple arg caching decorator\n    \"\"\"\n    last = []\n\n    def _(*args):\n        if not last or last[0] != args:\n            last[:] = (args, f(*args))\n        return last[1]\n    return _\n\ndef export_image(img, filename, fmt='.png', _return=True, export_path='.', background=''):\n    \"\"\"Given a datashader Image object, saves it to a disk file in the requested format\"\"\"\n    from datashader.transfer_functions import set_background\n    if not os.path.exists(export_path):\n        os.mkdir(export_path)\n    if background:\n        img = set_background(img, background)\n    img.to_pil().save(os.path.join(export_path, filename + fmt))\n    return img if _return else None\n\ndef lnglat_to_meters(longitude, latitude):\n    \"\"\"\n    Projects the given (longitude, latitude) values into Web Mercator\n    coordinates (meters East of Greenwich and meters North of the Equator).\n\n    Longitude and latitude can be provided as scalars, Pandas columns,\n    or Numpy arrays, and will be returned in the same form.  Lists\n    or tuples will be converted to Numpy arrays.\n\n    Examples:\n       easting, northing = lnglat_to_meters(-74,40.71)\n\n       easting, northing = lnglat_to_meters(np.array([-74]),np.array([40.71]))\n\n       df=pandas.DataFrame(dict(longitude=np.array([-74]),latitude=np.array([40.71])))\n       df.loc[:, 'longitude'], df.loc[:, 'latitude'] = lnglat_to_meters(df.longitude,df.latitude)\n    \"\"\"\n    if isinstance(longitude, (list, tuple)):\n        longitude = np.array(longitude)\n    if isinstance(latitude, (list, tuple)):\n        latitude = np.array(latitude)\n    origin_shift = np.pi * 6378137\n    easting = longitude * origin_shift / 180.0\n    northing = np.log(np.tan((90 + latitude) * np.pi / 360.0)) * origin_shift / np.pi\n    return (easting, northing)\n\ndef dshape_from_pandas_helper(col):\n    \"\"\"Return an object from datashader.datashape.coretypes given a column from a pandas\n    dataframe.\n    \"\"\"\n    if isinstance(col.dtype, type(pd.Categorical.dtype)) or isinstance(col.dtype, pd.api.types.CategoricalDtype) or (cudf and isinstance(col.dtype, cudf.core.dtypes.CategoricalDtype)):\n        pd_categories = col.cat.categories\n        if dd and isinstance(pd_categories, dd.Index):\n            pd_categories = pd_categories.compute()\n        if cudf and isinstance(pd_categories, cudf.Index):\n            pd_categories = pd_categories.to_pandas()\n        categories = np.array(pd_categories)\n        if categories.dtype.kind == 'U':\n            categories = categories.astype('object')\n        cat_dshape = datashape.dshape('{} * {}'.format(len(col.cat.categories), categories.dtype))\n        return datashape.Categorical(categories, type=cat_dshape, ordered=col.cat.ordered)\n    elif col.dtype.kind == 'M':\n        tz = getattr(col.dtype, 'tz', None)\n        if tz is not None:\n            tz = str(tz)\n        return datashape.Option(datashape.DateTime(tz=tz))\n    elif isinstance(col.dtype, (RaggedDtype, GeometryDtype)):\n        return col.dtype\n    elif gpd_GeometryDtype and isinstance(col.dtype, gpd_GeometryDtype):\n        return col.dtype\n    dshape = datashape.CType.from_numpy_dtype(col.dtype)\n    dshape = datashape.string if dshape == datashape.object_ else dshape\n    if dshape in (datashape.string, datashape.datetime_):\n        return datashape.Option(dshape)\n    return dshape\n\ndef dshape_from_pandas(df):\n    \"\"\"Return a datashape.DataShape object given a pandas dataframe.\"\"\"\n    return len(df) * datashape.Record([(k, dshape_from_pandas_helper(df[k])) for k in df.columns])\n\n@memoize(key=lambda args, kwargs: tuple(args[0].__dask_keys__()))\ndef dshape_from_dask(df):\n    \"\"\"Return a datashape.DataShape object given a dask dataframe.\"\"\"\n    cat_columns = [col for col in df.columns if (isinstance(df[col].dtype, type(pd.Categorical.dtype)) or isinstance(df[col].dtype, pd.api.types.CategoricalDtype)) and (not getattr(df[col].cat, 'known', True))]\n    df = df.categorize(cat_columns, index=False)\n    return (datashape.var * datashape.Record([(k, dshape_from_pandas_helper(df[k].get_partition(0))) for k in df.columns]), df)\n\ndef dshape_from_xarray_dataset(xr_ds):\n    \"\"\"Return a datashape.DataShape object given a xarray Dataset.\"\"\"\n    return datashape.var * datashape.Record([(k, dshape_from_pandas_helper(xr_ds[k])) for k in list(xr_ds.data_vars) + list(xr_ds.coords)])\n\ndef dataframe_from_multiple_sequences(x_values, y_values):\n    \"\"\"\n   Converts a set of multiple sequences (eg: time series), stored as a 2 dimensional\n   numpy array into a pandas dataframe that can be plotted by datashader.\n   The pandas dataframe eventually contains two columns ('x' and 'y') with the data.\n   Each time series is separated by a row of NaNs.\n   Discussion at: https://github.com/bokeh/datashader/issues/286#issuecomment-334619499\n\n   x_values: 1D numpy array with the values to be plotted on the x axis (eg: time)\n   y_values: 2D numpy array with the sequences to be plotted of shape (num sequences X length of\n             each sequence)\n\n   \"\"\"\n    x = np.zeros(x_values.shape[0] + 1)\n    x[-1] = np.nan\n    x[:-1] = x_values\n    x = np.tile(x, y_values.shape[0])\n    y = np.zeros((y_values.shape[0], y_values.shape[1] + 1))\n    y[:, -1] = np.nan\n    y[:, :-1] = y_values\n    return pd.DataFrame({'x': x, 'y': y.flatten()})\n\ndef _pd_mesh(vertices, simplices):\n    \"\"\"Helper for ``datashader.utils.mesh()``. Both arguments are assumed to be\n    Pandas DataFrame objects.\n    \"\"\"\n    winding = [0, 1, 2]\n    first_tri = vertices.values[simplices.values[0, winding].astype(np.int64), :2]\n    a, b, c = first_tri\n    p1, p2 = (b - a, c - a)\n    cross_product = p1[0] * p2[1] - p1[1] * p2[0]\n    if cross_product >= 0:\n        winding = [0, 2, 1]\n    vertex_idxs = simplices.values[:, winding]\n    if not vertex_idxs.dtype == 'int64':\n        vertex_idxs = vertex_idxs.astype(np.int64)\n    vals = np.take(vertices.values, vertex_idxs, axis=0)\n    vals = vals.reshape(np.prod(vals.shape[:2]), vals.shape[2])\n    res = pd.DataFrame(vals, columns=vertices.columns)\n    verts_have_weights = len(vertices.columns) > 2\n    if not verts_have_weights:\n        weight_col = simplices.columns[3]\n        res[weight_col] = simplices.values[:, 3].repeat(3)\n    return res\n\ndef _dd_mesh(vertices, simplices):\n    \"\"\"Helper for ``datashader.utils.mesh()``. Both arguments are assumed to be\n    Dask DataFrame objects.\n    \"\"\"\n    res = _pd_mesh(vertices.compute(), simplices.compute())\n    approx_npartitions = max(vertices.npartitions, simplices.npartitions)\n    chunksize = int(np.ceil(len(res) / (3 * approx_npartitions)) * 3)\n    res = dd.from_pandas(res, chunksize=chunksize)\n    return res\n\ndef mesh(vertices, simplices):\n    \"\"\"Merge vertices and simplices into a triangular mesh, suitable to be\n    passed into the ``Canvas.trimesh()`` method via the ``mesh``\n    keyword-argument. Both arguments are assumed to be Dask DataFrame\n    objects.\n    \"\"\"\n    assert simplices.values.shape[1] >= 3, 'At least three vertex columns are required for the triangle definition'\n    simplices_all_ints = simplices.dtypes.iloc[:3].map(lambda dt: np.issubdtype(dt, np.integer)).all()\n    assert simplices_all_ints, 'Simplices must be integral. You may consider casting simplices to integers with \".astype(int)\"'\n    assert len(vertices.columns) > 2 or simplices.values.shape[1] > 3, 'If no vertex weight column is provided, a triangle weight column is required.'\n    if dd and isinstance(vertices, dd.DataFrame) and isinstance(simplices, dd.DataFrame):\n        return _dd_mesh(vertices, simplices)\n    return _pd_mesh(vertices, simplices)\n\n@ngjit\ndef isnull(val):\n    \"\"\"\n    Equivalent to isnan for floats, but also numba compatible with integers\n    \"\"\"\n    return not (val <= 0 or val > 0)\n\n@ngjit\ndef isminus1(val):\n    \"\"\"\n    Check for -1 which is equivalent to NaN for some integer aggregations\n    \"\"\"\n    return val == -1\n\n@ngjit_parallel\ndef nanfirst_in_place(ret, other):\n    \"\"\"First of 2 arrays but taking nans into account.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]) and (not isnull(other[i])):\n            ret[i] = other[i]\n\n@ngjit_parallel\ndef nanlast_in_place(ret, other):\n    \"\"\"Last of 2 arrays but taking nans into account.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if not isnull(other[i]):\n            ret[i] = other[i]\n\n@ngjit_parallel\ndef nanmax_in_place(ret, other):\n    \"\"\"Max of 2 arrays but taking nans into account.  Could use np.nanmax but\n    would need to replace zeros with nans where both arrays are nans.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]) and other[i] > ret[i]:\n            ret[i] = other[i]\n\n@ngjit_parallel\ndef nanmin_in_place(ret, other):\n    \"\"\"Min of 2 arrays but taking nans into account.  Could use np.nanmin but\n    would need to replace zeros with nans where both arrays are nans.\n    Accepts 3D (ny, nx, ncat) and 2D (ny, nx) arrays.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]) and other[i] < ret[i]:\n            ret[i] = other[i]\n\n@ngjit\ndef shift_and_insert(target, value, index):\n    \"\"\"Insert a value into a 1D array at a particular index, but before doing\n    that shift the previous values along one to make room. For use in\n    ``FloatingNReduction`` classes such as ``max_n`` and ``first_n`` which\n    store ``n`` values per pixel.\n\n    Parameters\n    ----------\n    target : 1d numpy array\n        Target pixel array.\n\n    value : float\n        Value to insert into target pixel array.\n\n    index : int\n        Index to insert at.\n\n    Returns\n    -------\n    Index beyond insertion, i.e. where the first shifted value now sits.\n    \"\"\"\n    n = len(target)\n    for i in range(n - 1, index, -1):\n        target[i] = target[i - 1]\n    target[index] = value\n    return index + 1\n\n@ngjit\ndef _nanfirst_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanfirst_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]):\n                    ret_pixel[i] = other_value\n                    istart = i + 1\n                    break\n\n@ngjit_parallel\ndef nanfirst_n_in_place_4d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanfirst_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit_parallel\ndef nanfirst_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanfirst_n_impl(ret[y, x], other[y, x])\n\n@ngjit\ndef _nanlast_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanlast_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                istart = shift_and_insert(ret_pixel, other_value, istart)\n                break\n\n@ngjit_parallel\ndef nanlast_n_in_place_4d(ret, other):\n    \"\"\"3d version of nanfirst_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanlast_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit_parallel\ndef nanlast_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanlast_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanlast_n_impl(ret[y, x], other[y, x])\n\n@ngjit\ndef _nanmax_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanmax_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]) or other_value > ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n@ngjit_parallel\ndef nanmax_n_in_place_4d(ret, other):\n    \"\"\"Combine two max-n arrays, taking nans into account. Max-n arrays are 4D\n    with shape (ny, nx, ncat, n) where ny and nx are the number of pixels,\n    ncat the number of categories (will be 1 if not using a categorical\n    reduction) and the last axis containing n values in descending order.\n    If there are fewer than n values it is padded with nans.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanmax_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit_parallel\ndef nanmax_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanmax_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanmax_n_impl(ret[y, x], other[y, x])\n\n@ngjit\ndef _nanmin_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of nanmin_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if isnull(other_value):\n            break\n        else:\n            for i in range(istart, n):\n                if isnull(ret_pixel[i]) or other_value < ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n@ngjit_parallel\ndef nanmin_n_in_place_4d(ret, other):\n    \"\"\"Combine two min-n arrays, taking nans into account. Min-n arrays are 4D\n    with shape (ny, nx, ncat, n) where ny and nx are the number of pixels,\n    ncat the number of categories (will be 1 if not using a categorical\n    reduction) and the last axis containing n values in ascending order.\n    If there are fewer than n values it is padded with nans.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _nanmin_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit_parallel\ndef nanmin_n_in_place_3d(ret, other):\n    \"\"\"3d version of nanmin_n_in_place_4d, taking arrays of shape (ny, nx, n).\n    \"\"\"\n    ny, nx, _n = ret.shape\n    for y in nb.prange(ny):\n        for x in range(nx):\n            _nanmin_n_impl(ret[y, x], other[y, x])\n\n@ngjit_parallel\ndef nansum_in_place(ret, other):\n    \"\"\"Sum of 2 arrays but taking nans into account.  Could use np.nansum but\n    would need to replace zeros with nans where both arrays are nans.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in nb.prange(len(ret)):\n        if isnull(ret[i]):\n            if not isnull(other[i]):\n                ret[i] = other[i]\n        elif not isnull(other[i]):\n            ret[i] += other[i]\n\n@ngjit\ndef row_max_in_place(ret, other):\n    \"\"\"Maximum of 2 arrays of row indexes.\n    Row indexes are integers from 0 upwards, missing data is -1.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in range(len(ret)):\n        if other[i] > -1 and (ret[i] == -1 or other[i] > ret[i]):\n            ret[i] = other[i]\n\n@ngjit\ndef row_min_in_place(ret, other):\n    \"\"\"Minimum of 2 arrays of row indexes.\n    Row indexes are integers from 0 upwards, missing data is -1.\n    Return the first array.\n    \"\"\"\n    ret = ret.ravel()\n    other = other.ravel()\n    for i in range(len(ret)):\n        if other[i] > -1 and (ret[i] == -1 or other[i] < ret[i]):\n            ret[i] = other[i]\n\n@ngjit\ndef _row_max_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of row_max_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if other_value == -1:\n            break\n        else:\n            for i in range(istart, n):\n                if ret_pixel[i] == -1 or other_value > ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n@ngjit\ndef row_max_n_in_place_4d(ret, other):\n    \"\"\"Combine two row_max_n signed integer arrays.\n    Equivalent to nanmax_n_in_place with -1 replacing NaN for missing data.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _row_max_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit\ndef row_max_n_in_place_3d(ret, other):\n    ny, nx, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            _row_max_n_impl(ret[y, x], other[y, x])\n\n@ngjit\ndef _row_min_n_impl(ret_pixel, other_pixel):\n    \"\"\"Single pixel implementation of row_min_n_in_place.\n    ret_pixel and other_pixel are both 1D arrays of the same length.\n\n    Walk along other_pixel a value at a time, find insertion index in\n    ret_pixel and shift values along to insert.  Next other_pixel value is\n    inserted at a higher index, so this walks the two pixel arrays just once\n    each.\n    \"\"\"\n    n = len(ret_pixel)\n    istart = 0\n    for other_value in other_pixel:\n        if other_value == -1:\n            break\n        else:\n            for i in range(istart, n):\n                if ret_pixel[i] == -1 or other_value < ret_pixel[i]:\n                    istart = shift_and_insert(ret_pixel, other_value, i)\n                    break\n\n@ngjit\ndef row_min_n_in_place_4d(ret, other):\n    \"\"\"Combine two row_min_n signed integer arrays.\n    Equivalent to nanmin_n_in_place with -1 replacing NaN for missing data.\n    Return the first array.\n    \"\"\"\n    ny, nx, ncat, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            for cat in range(ncat):\n                _row_min_n_impl(ret[y, x, cat], other[y, x, cat])\n\n@ngjit\ndef row_min_n_in_place_3d(ret, other):\n    ny, nx, _n = ret.shape\n    for y in range(ny):\n        for x in range(nx):\n            _row_min_n_impl(ret[y, x], other[y, x])",
    "datashader/datashape/parser.py": "\"\"\"\nParser for the datashape grammar.\n\"\"\"\nfrom . import lexer, error\nfrom . import coretypes\n__all__ = ['parse']\n\nclass DataShapeParser:\n    \"\"\"A DataShape parser object.\"\"\"\n\n    def __init__(self, ds_str, sym):\n        self.ds_str = ds_str\n        self.sym = sym\n        self.lex = lexer.lex(ds_str)\n        self.tokens = []\n        self.pos = -1\n        self.end_pos = None\n        self.advance_tok()\n\n    def advance_tok(self):\n        \"\"\"Advances self.pos by one, if it is not already at the end.\"\"\"\n        if self.pos != self.end_pos:\n            self.pos = self.pos + 1\n            try:\n                if self.pos >= len(self.tokens):\n                    self.tokens.append(next(self.lex))\n            except StopIteration:\n                if len(self.tokens) > 0:\n                    span = (self.tokens[self.pos - 1].span[1],) * 2\n                else:\n                    span = (0, 0)\n                self.tokens.append(lexer.Token(None, None, span, None))\n                self.end_pos = self.pos\n\n    @property\n    def tok(self):\n        return self.tokens[self.pos]\n\n    def raise_error(self, errmsg):\n        raise error.DataShapeSyntaxError(self.tok.span[0], '<nofile>', self.ds_str, errmsg)\n\n    def parse_homogeneous_list(self, parse_item, sep_tok_id, errmsg, trailing_sep=False):\n        \"\"\"\n        <item>_list : <item> <SEP> <item>_list\n                    | <item>\n\n        Returns a list of <item>s, or None.\n        \"\"\"\n        saved_pos = self.pos\n        items = []\n        item = True\n        while item is not None:\n            item = parse_item()\n            if item is not None:\n                items.append(item)\n                if self.tok.id == sep_tok_id:\n                    self.advance_tok()\n                else:\n                    return items\n            elif len(items) > 0:\n                if trailing_sep:\n                    return items\n                else:\n                    self.raise_error(errmsg)\n            else:\n                self.pos = saved_pos\n                return None\n\n    def syntactic_sugar(self, symdict, name, dshapemsg, error_pos=None):\n        \"\"\"\n        Looks up a symbol in the provided symbol table dictionary for\n        syntactic sugar, raising a standard error message if the symbol\n        is missing.\n\n        Parameters\n        ----------\n        symdict : symbol table dictionary\n            One of self.sym.dtype, self.sym.dim,\n            self.sym.dtype_constr, or self.sym.dim_constr.\n        name : str\n            The name of the symbol to look up.\n        dshapemsg : str\n            The datashape construct this lookup is for, e.g.\n            '{...} dtype constructor'.\n        error_pos : int, optional\n            The position in the token stream at which to flag the error.\n        \"\"\"\n        entry = symdict.get(name)\n        if entry is not None:\n            return entry\n        else:\n            if error_pos is not None:\n                self.pos = error_pos\n            self.raise_error(('Symbol table missing \"%s\" ' + 'entry for %s') % (name, dshapemsg))\n\n    def parse_datashape(self):\n        \"\"\"\n        datashape : datashape_nooption\n                  | QUESTIONMARK datashape_nooption\n                  | EXCLAMATIONMARK datashape_nooption\n\n        Returns a datashape object or None.\n        \"\"\"\n        tok = self.tok\n        constructors = {lexer.QUESTIONMARK: 'option'}\n        if tok.id in constructors:\n            self.advance_tok()\n            saved_pos = self.pos\n            ds = self.parse_datashape_nooption()\n            if ds is not None:\n                option = self.syntactic_sugar(self.sym.dtype_constr, constructors[tok.id], '%s dtype construction' % constructors[tok.id], saved_pos - 1)\n                return coretypes.DataShape(option(ds))\n        else:\n            return self.parse_datashape_nooption()\n\n    def parse_datashape_nooption(self):\n        \"\"\"\n        datashape_nooption : dim ASTERISK datashape\n                           | dtype\n\n        Returns a datashape object or None.\n        \"\"\"\n        saved_pos = self.pos\n        dim = self.parse_dim()\n        if dim is not None:\n            if self.tok.id == lexer.ASTERISK:\n                self.advance_tok()\n                saved_pos = self.pos\n                dshape = self.parse_datashape()\n                if dshape is None:\n                    self.pos = saved_pos\n                    self.raise_error('Expected a dim or a dtype')\n                return coretypes.DataShape(dim, *dshape.parameters)\n        dtype = self.parse_dtype()\n        if dtype:\n            return coretypes.DataShape(dtype)\n        else:\n            return None\n\n    def parse_dim(self):\n        \"\"\"\n        dim : typevar\n            | ellipsis_typevar\n            | type\n            | type_constr\n            | INTEGER\n            | ELLIPSIS\n        typevar : NAME_UPPER\n        ellipsis_typevar : NAME_UPPER ELLIPSIS\n        type : NAME_LOWER\n        type_constr : NAME_LOWER LBRACKET type_arg_list RBRACKET\n\n        Returns a the dim object, or None.\n        TODO: Support type constructors\n        \"\"\"\n        saved_pos = self.pos\n        tok = self.tok\n        if tok.id == lexer.NAME_UPPER:\n            val = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.ELLIPSIS:\n                self.advance_tok()\n                tconstr = self.syntactic_sugar(self.sym.dim_constr, 'ellipsis', 'TypeVar... dim constructor', saved_pos)\n                return tconstr(val)\n            elif self.tok.id == lexer.ASTERISK:\n                tconstr = self.syntactic_sugar(self.sym.dim_constr, 'typevar', 'TypeVar dim constructor', saved_pos)\n                return tconstr(val)\n            else:\n                self.pos = saved_pos\n                return None\n        elif tok.id == lexer.NAME_LOWER:\n            name = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.LBRACKET:\n                dim_constr = self.sym.dim_constr.get(name)\n                if dim_constr is None:\n                    self.pos = saved_pos\n                    return None\n                self.advance_tok()\n                args = self.parse_type_arg_list()\n                if self.tok.id == lexer.RBRACKET:\n                    self.advance_tok()\n                    raise NotImplementedError('dim type constructors not actually supported yet')\n                else:\n                    self.raise_error('Expected a closing \"]\"')\n            else:\n                dim = self.sym.dim.get(name)\n                if dim is not None:\n                    return dim\n                else:\n                    self.pos = saved_pos\n                    return None\n        elif tok.id == lexer.INTEGER:\n            val = tok.val\n            self.advance_tok()\n            if self.tok.id != lexer.ASTERISK:\n                self.pos = saved_pos\n                return None\n            tconstr = self.syntactic_sugar(self.sym.dim_constr, 'fixed', 'integer dimensions')\n            return tconstr(val)\n        elif tok.id == lexer.ELLIPSIS:\n            self.advance_tok()\n            dim = self.syntactic_sugar(self.sym.dim, 'ellipsis', '... dim', saved_pos)\n            return dim\n        else:\n            return None\n\n    def parse_dtype(self):\n        \"\"\"\n        dtype : typevar\n              | type\n              | type_constr\n              | struct_type\n              | funcproto_or_tuple_type\n        typevar : NAME_UPPER\n        ellipsis_typevar : NAME_UPPER ELLIPSIS\n        type : NAME_LOWER\n        type_constr : NAME_LOWER LBRACKET type_arg_list RBRACKET\n        struct_type : LBRACE ...\n        funcproto_or_tuple_type : LPAREN ...\n\n        Returns a the dtype object, or None.\n        \"\"\"\n        saved_pos = self.pos\n        tok = self.tok\n        if tok.id == lexer.NAME_UPPER:\n            val = tok.val\n            self.advance_tok()\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'typevar', 'TypeVar dtype constructor', saved_pos)\n            return tconstr(val)\n        elif tok.id == lexer.NAME_LOWER:\n            name = tok.val\n            self.advance_tok()\n            if self.tok.id == lexer.LBRACKET:\n                dtype_constr = self.sym.dtype_constr.get(name)\n                if dtype_constr is None:\n                    self.pos = saved_pos\n                    return None\n                self.advance_tok()\n                args, kwargs = self.parse_type_arg_list()\n                if self.tok.id == lexer.RBRACKET:\n                    if len(args) == 0 and len(kwargs) == 0:\n                        self.raise_error('Expected at least one type ' + 'constructor argument')\n                    self.advance_tok()\n                    return dtype_constr(*args, **kwargs)\n                else:\n                    self.raise_error('Invalid type constructor argument')\n            else:\n                dtype = self.sym.dtype.get(name)\n                if dtype is not None:\n                    return dtype\n                else:\n                    self.pos = saved_pos\n                    return None\n        elif tok.id == lexer.LBRACE:\n            return self.parse_struct_type()\n        elif tok.id == lexer.LPAREN:\n            return self.parse_funcproto_or_tuple_type()\n        else:\n            return None\n\n    def parse_type_arg_list(self):\n        \"\"\"\n        type_arg_list : type_arg COMMA type_arg_list\n                      | type_kwarg_list\n                      | type_arg\n        type_kwarg_list : type_kwarg COMMA type_kwarg_list\n                        | type_kwarg\n\n        Returns a tuple (args, kwargs), or (None, None).\n        \"\"\"\n        args = []\n        arg = True\n        while arg is not None:\n            arg = self.parse_type_arg()\n            if arg is not None:\n                if self.tok.id == lexer.COMMA:\n                    self.advance_tok()\n                    args.append(arg)\n                else:\n                    args.append(arg)\n                    return (args, {})\n            else:\n                break\n        kwargs = self.parse_homogeneous_list(self.parse_type_kwarg, lexer.COMMA, 'Expected another keyword argument, ' + 'positional arguments cannot follow ' + 'keyword arguments')\n        return (args, dict(kwargs) if kwargs else {})\n\n    def parse_type_arg(self):\n        \"\"\"\n        type_arg : datashape\n                 | INTEGER\n                 | STRING\n                 | BOOLEAN\n                 | list_type_arg\n        list_type_arg : LBRACKET RBRACKET\n                      | LBRACKET datashape_list RBRACKET\n                      | LBRACKET integer_list RBRACKET\n                      | LBRACKET string_list RBRACKET\n\n        Returns a type_arg value, or None.\n        \"\"\"\n        ds = self.parse_datashape()\n        if ds is not None:\n            return ds\n        if self.tok.id in [lexer.INTEGER, lexer.STRING, lexer.BOOLEAN]:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        elif self.tok.id == lexer.LBRACKET:\n            self.advance_tok()\n            val = self.parse_datashape_list()\n            if val is None:\n                val = self.parse_integer_list()\n            if val is None:\n                val = self.parse_string_list()\n            if val is None:\n                val = self.parse_boolean_list()\n            if self.tok.id == lexer.RBRACKET:\n                self.advance_tok()\n                return [] if val is None else val\n            elif val is None:\n                self.raise_error('Expected a type constructor argument ' + 'or a closing \"]\"')\n            else:\n                self.raise_error('Expected a \",\" or a closing \"]\"')\n        else:\n            return None\n\n    def parse_type_kwarg(self):\n        \"\"\"\n        type_kwarg : NAME_LOWER EQUAL type_arg\n\n        Returns a (name, type_arg) tuple, or None.\n        \"\"\"\n        if self.tok.id != lexer.NAME_LOWER:\n            return None\n        saved_pos = self.pos\n        name = self.tok.val\n        self.advance_tok()\n        if self.tok.id != lexer.EQUAL:\n            self.pos = saved_pos\n            return None\n        self.advance_tok()\n        arg = self.parse_type_arg()\n        if arg is not None:\n            return (name, arg)\n        else:\n            self.raise_error('Expected a type constructor argument')\n\n    def parse_datashape_list(self):\n        \"\"\"\n        datashape_list : datashape COMMA datashape_list\n                       | datashape\n\n        Returns a list of datashape type objects, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_datashape, lexer.COMMA, 'Expected another datashape, ' + 'type constructor parameter ' + 'lists must have uniform type')\n\n    def parse_integer(self):\n        \"\"\"\n        integer : INTEGER\n        \"\"\"\n        if self.tok.id == lexer.INTEGER:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_integer_list(self):\n        \"\"\"\n        integer_list : INTEGER COMMA integer_list\n                     | INTEGER\n\n        Returns a list of integers, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_integer, lexer.COMMA, 'Expected another integer, ' + 'type constructor parameter ' + 'lists must have uniform type')\n\n    def parse_boolean(self):\n        \"\"\"\n        boolean : BOOLEAN\n        \"\"\"\n        if self.tok.id == lexer.BOOLEAN:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_boolean_list(self):\n        \"\"\"\n        boolean_list : boolean COMMA boolean_list\n                     | boolean\n\n        Returns a list of booleans, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_boolean, lexer.COMMA, 'Expected another boolean, ' + 'type constructor parameter ' + 'lists must have uniform type')\n\n    def parse_string(self):\n        \"\"\"\n        string : STRING\n        \"\"\"\n        if self.tok.id == lexer.STRING:\n            val = self.tok.val\n            self.advance_tok()\n            return val\n        else:\n            return None\n\n    def parse_string_list(self):\n        \"\"\"\n        string_list : STRING COMMA string_list\n                    | STRING\n\n        Returns a list of strings, or None.\n        \"\"\"\n        return self.parse_homogeneous_list(self.parse_string, lexer.COMMA, 'Expected another string, ' + 'type constructor parameter ' + 'lists must have uniform type')\n\n    def parse_struct_type(self):\n        \"\"\"\n        struct_type : LBRACE struct_field_list RBRACE\n                    | LBRACE struct_field_list COMMA RBRACE\n\n        Returns a struct type, or None.\n        \"\"\"\n        if self.tok.id != lexer.LBRACE:\n            return None\n        saved_pos = self.pos\n        self.advance_tok()\n        fields = self.parse_homogeneous_list(self.parse_struct_field, lexer.COMMA, 'Invalid field in struct', trailing_sep=True) or []\n        if self.tok.id != lexer.RBRACE:\n            self.raise_error('Invalid field in struct')\n        self.advance_tok()\n        names = [f[0] for f in fields]\n        types = [f[1] for f in fields]\n        tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'struct', '{...} dtype constructor', saved_pos)\n        return tconstr(names, types)\n\n    def parse_struct_field(self):\n        \"\"\"\n        struct_field : struct_field_name COLON datashape\n        struct_field_name : NAME_LOWER\n                          | NAME_UPPER\n                          | NAME_OTHER\n                          | STRING\n\n        Returns a tuple (name, datashape object) or None\n        \"\"\"\n        if self.tok.id not in [lexer.NAME_LOWER, lexer.NAME_UPPER, lexer.NAME_OTHER, lexer.STRING]:\n            return None\n        name = self.tok.val\n        self.advance_tok()\n        if self.tok.id != lexer.COLON:\n            self.raise_error('Expected a \":\" separating the field ' + 'name from its datashape')\n        self.advance_tok()\n        ds = self.parse_datashape()\n        if ds is None:\n            self.raise_error('Expected the datashape of the field')\n        return (name, ds)\n\n    def parse_funcproto_or_tuple_type(self):\n        \"\"\"\n        funcproto_or_tuple_type : tuple_type RARROW datashape\n                                | tuple_type\n        tuple_type : LPAREN tuple_item_list RPAREN\n                   | LPAREN tuple_item_list COMMA RPAREN\n                   | LPAREN RPAREN\n        tuple_item_list : datashape COMMA tuple_item_list\n                        | datashape\n\n        Returns a tuple type object, a function prototype, or None.\n        \"\"\"\n        if self.tok.id != lexer.LPAREN:\n            return None\n        saved_pos = self.pos\n        self.advance_tok()\n        dshapes = self.parse_homogeneous_list(self.parse_datashape, lexer.COMMA, 'Invalid datashape in tuple', trailing_sep=True) or ()\n        if self.tok.id != lexer.RPAREN:\n            self.raise_error('Invalid datashape in tuple')\n        self.advance_tok()\n        if self.tok.id != lexer.RARROW:\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'tuple', '(...) dtype constructor', saved_pos)\n            return tconstr(dshapes)\n        else:\n            self.advance_tok()\n            ret_dshape = self.parse_datashape()\n            if ret_dshape is None:\n                self.raise_error('Expected function prototype return ' + 'datashape')\n            tconstr = self.syntactic_sugar(self.sym.dtype_constr, 'funcproto', '(...) -> ... dtype constructor', saved_pos)\n            return tconstr(dshapes, ret_dshape)",
    "datashader/datashape/validation.py": "\"\"\"\nDatashape validation.\n\"\"\"\nfrom . import coretypes as T\n\ndef traverse(f, t):\n    \"\"\"\n    Map `f` over `t`, calling `f` with type `t` and the map result of the\n    mapping `f` over `t` 's parameters.\n\n    Parameters\n    ----------\n    f : callable\n    t : DataShape\n\n    Returns\n    -------\n    DataShape\n    \"\"\"\n    if isinstance(t, T.Mono) and (not isinstance(t, T.Unit)):\n        return f(t, [traverse(f, p) for p in t.parameters])\n    return t\n\ndef _validate(ds, params):\n    if isinstance(ds, T.DataShape):\n        ellipses = [x for x in ds.parameters if isinstance(x, T.Ellipsis)]\n        if len(ellipses) > 1:\n            raise TypeError('Can only use a single wildcard')\n        elif isinstance(ds.parameters[-1], T.Ellipsis):\n            raise TypeError('Measure may not be an Ellipsis (...)')",
    "datashader/datashape/util/__init__.py": "from itertools import chain\nimport operator\nfrom .. import parser\nfrom .. import type_symbol_table\nfrom ..validation import validate\nfrom .. import coretypes\n__all__ = ('dshape', 'dshapes', 'has_var_dim', 'has_ellipsis', 'cat_dshapes')\nsubclasses = operator.methodcaller('__subclasses__')\n\ndef dshapes(*args):\n    \"\"\"\n    Parse a bunch of datashapes all at once.\n\n    >>> a, b = dshapes('3 * int32', '2 * var * float64')\n    \"\"\"\n    return [dshape(arg) for arg in args]\n\ndef cat_dshapes(dslist):\n    \"\"\"\n    Concatenates a list of dshapes together along\n    the first axis. Raises an error if there is\n    a mismatch along another axis or the measures\n    are different.\n\n    Requires that the leading dimension be a known\n    size for all data shapes.\n    TODO: Relax this restriction to support\n          streaming dimensions.\n\n    >>> cat_dshapes(dshapes('10 * int32', '5 * int32'))\n    dshape(\"15 * int32\")\n    \"\"\"\n    if len(dslist) == 0:\n        raise ValueError('Cannot concatenate an empty list of dshapes')\n    elif len(dslist) == 1:\n        return dslist[0]\n    outer_dim_size = operator.index(dslist[0][0])\n    inner_ds = dslist[0][1:]\n    for ds in dslist[1:]:\n        outer_dim_size += operator.index(ds[0])\n        if ds[1:] != inner_ds:\n            raise ValueError('The datashapes to concatenate much all match after the first dimension (%s vs %s)' % (inner_ds, ds[1:]))\n    return coretypes.DataShape(*[coretypes.Fixed(outer_dim_size)] + list(inner_ds))\n\ndef collect(pred, expr):\n    \"\"\" Collect terms in expression that match predicate\n\n    >>> from datashader.datashape import Unit, dshape\n    >>> predicate = lambda term: isinstance(term, Unit)\n    >>> dshape = dshape('var * {value: int64, loc: 2 * int32}')\n    >>> sorted(set(collect(predicate, dshape)), key=str)\n    [Fixed(val=2), ctype(\"int32\"), ctype(\"int64\"), Var()]\n    >>> from datashader.datashape import var, int64\n    >>> sorted(set(collect(predicate, [var, int64])), key=str)\n    [ctype(\"int64\"), Var()]\n    \"\"\"\n    if pred(expr):\n        return [expr]\n    if isinstance(expr, coretypes.Record):\n        return chain.from_iterable((collect(pred, typ) for typ in expr.types))\n    if isinstance(expr, coretypes.Mono):\n        return chain.from_iterable((collect(pred, typ) for typ in expr.parameters))\n    if isinstance(expr, (list, tuple)):\n        return chain.from_iterable((collect(pred, item) for item in expr))\n\ndef has_var_dim(ds):\n    \"\"\"Returns True if datashape has a variable dimension\n\n    Note currently treats variable length string as scalars.\n\n    >>> has_var_dim(dshape('2 * int32'))\n    False\n    >>> has_var_dim(dshape('var * 2 * int32'))\n    True\n    \"\"\"\n    return has((coretypes.Ellipsis, coretypes.Var), ds)\n\ndef has(typ, ds):\n    if isinstance(ds, typ):\n        return True\n    if isinstance(ds, coretypes.Record):\n        return any((has(typ, t) for t in ds.types))\n    if isinstance(ds, coretypes.Mono):\n        return any((has(typ, p) for p in ds.parameters))\n    if isinstance(ds, (list, tuple)):\n        return any((has(typ, item) for item in ds))\n    return False\n\ndef has_ellipsis(ds):\n    \"\"\"Returns True if the datashape has an ellipsis\n\n    >>> has_ellipsis(dshape('2 * int'))\n    False\n    >>> has_ellipsis(dshape('... * int'))\n    True\n    \"\"\"\n    return has(coretypes.Ellipsis, ds)",
    "datashader/datashape/predicates.py": "import numpy as np\nfrom .util import collect, dshape\nfrom .internal_utils import remove\nfrom .coretypes import DataShape, Fixed, Var, Ellipsis, Record, Unit, date_, datetime_, TypeVar, to_numpy_dtype, Categorical\nfrom .typesets import floating, boolean\n__all__ = ['isdimension', 'ishomogeneous', 'istabular', 'isfixed', 'isscalar', 'isrecord', 'iscollection', 'isnumeric', 'isboolean', 'isdatelike', 'isreal']\ndimension_types = (Fixed, Var, Ellipsis, int)\n\ndef isscalar(ds):\n    \"\"\" Is this dshape a single dtype?\n\n    >>> isscalar('int')\n    True\n    >>> isscalar('?int')\n    True\n    >>> isscalar('{name: string, amount: int}')\n    False\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape) and len(ds) == 1:\n        ds = ds[0]\n    return isinstance(getattr(ds, 'ty', ds), (Unit, Categorical))\n\ndef isrecord(ds):\n    \"\"\" Is this dshape a record type?\n\n    >>> isrecord('{name: string, amount: int}')\n    True\n    >>> isrecord('int')\n    False\n    >>> isrecord('?{name: string, amount: int}')\n    True\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    if isinstance(ds, DataShape) and len(ds) == 1:\n        ds = ds[0]\n    return isinstance(getattr(ds, 'ty', ds), Record)\n\ndef isdimension(ds):\n    \"\"\" Is a component a dimension?\n\n    >>> from datashader.datashape import int32\n    >>> isdimension(Fixed(10))\n    True\n    >>> isdimension(Var())\n    True\n    >>> isdimension(int32)\n    False\n    \"\"\"\n    return isinstance(ds, dimension_types)\n\ndef ishomogeneous(ds):\n    \"\"\" Does datashape contain only one dtype?\n\n    >>> from datashader.datashape import int32\n    >>> ishomogeneous(int32)\n    True\n    >>> ishomogeneous('var * 3 * string')\n    True\n    >>> ishomogeneous('var * {name: string, amount: int}')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    return len(set(remove(isdimension, collect(isscalar, ds)))) == 1\n\ndef _dimensions(ds):\n    \"\"\"Number of dimensions of datashape\n    \"\"\"\n    return len(dshape(ds).shape)\n\ndef isfixed(ds):\n    \"\"\" Contains no variable dimensions\n\n    >>> isfixed('10 * int')\n    True\n    >>> isfixed('var * int')\n    False\n    >>> isfixed('10 * {name: string, amount: int}')\n    True\n    >>> isfixed('10 * {name: string, amounts: var * int}')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    if isinstance(ds[0], TypeVar):\n        return None\n    if isinstance(ds[0], Var):\n        return False\n    if isinstance(ds[0], Record):\n        return all(map(isfixed, ds[0].types))\n    if len(ds) > 1:\n        return isfixed(ds.subarray(1))\n    return True\n\ndef istabular(ds):\n    \"\"\" A collection of records\n\n    >>> istabular('var * {name: string, amount: int}')\n    True\n    >>> istabular('var * 10 * 3 * int')\n    False\n    >>> istabular('10 * var * int')\n    False\n    >>> istabular('var * (int64, string, ?float64)')\n    False\n    \"\"\"\n    ds = dshape(ds)\n    return _dimensions(ds) == 1 and isrecord(ds.measure)\n\ndef iscollection(ds):\n    \"\"\" Is a collection of items, has dimension\n\n    >>> iscollection('5 * int32')\n    True\n    >>> iscollection('int32')\n    False\n    \"\"\"\n    if isinstance(ds, str):\n        ds = dshape(ds)\n    return isdimension(ds[0])\n\ndef isnumeric(ds):\n    \"\"\" Has a numeric measure\n\n    >>> isnumeric('int32')\n    True\n    >>> isnumeric('3 * ?real')\n    True\n    >>> isnumeric('string')\n    False\n    >>> isnumeric('var * {amount: ?int32}')\n    False\n    \"\"\"\n    ds = launder(ds)\n    try:\n        npdtype = to_numpy_dtype(ds)\n    except TypeError:\n        return False\n    else:\n        return isinstance(ds, Unit) and np.issubdtype(npdtype, np.number)\n\ndef isreal(ds):\n    \"\"\" Has a numeric measure\n\n    >>> isreal('float32')\n    True\n    >>> isreal('3 * ?real')\n    True\n    >>> isreal('string')\n    False\n    \"\"\"\n    ds = launder(ds)\n    return isinstance(ds, Unit) and ds in floating\n\ndef isboolean(ds):\n    \"\"\" Has a boolean measure\n\n    >>> isboolean('bool')\n    True\n    >>> isboolean('3 * ?bool')\n    True\n    >>> isboolean('int')\n    False\n    \"\"\"\n    return launder(ds) in boolean\n\ndef isdatelike(ds):\n    \"\"\" Has a date or datetime measure\n\n    >>> isdatelike('int32')\n    False\n    >>> isdatelike('3 * datetime')\n    True\n    >>> isdatelike('?datetime')\n    True\n    \"\"\"\n    ds = launder(ds)\n    return ds == date_ or ds == datetime_"
  }
}