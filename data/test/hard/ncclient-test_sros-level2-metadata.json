{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_sros",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_sros.py",
  "test_code": "import unittest\n\nfrom ncclient.devices.sros import SrosDeviceHandler, ConfigMode\nfrom ncclient.xml_ import to_ele, to_xml, BASE_NS_1_0\nfrom ncclient.operations.third_party.sros.rpc import MdCliRawCommand, Commit\n\ncapabilities = ['urn:ietf:params:netconf:base:1.0',\n                'urn:ietf:params:netconf:base:1.1',\n                'urn:ietf:params:netconf:capability:writable-running:1.0',\n                'urn:ietf:params:netconf:capability:candidate:1.0',\n                'urn:ietf:params:netconf:capability:confirmed-commit:1.0',\n                'urn:ietf:params:netconf:capability:rollback-on-error:1.0',\n                'urn:ietf:params:netconf:capability:startup:1.0',\n                'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp',\n                'urn:ietf:params:netconf:capability:validate:1.0',\n                'urn:ietf:params:netconf:capability:xpath:1.0',\n                'urn:ietf:params:netconf:capability:notification:1.0',\n                'urn:ietf:params:netconf:capability:interleave:1.0',\n                'urn:ietf:params:netconf:capability:with-defaults:1.0',\n                'urn:ietf:params:xml:ns:netconf:base:1.0',\n                'urn:ietf:params:xml:ns:yang:1',\n                'urn:ietf:params:netconf:capability:confirmed-commit:1.1',\n                'urn:ietf:params:netconf:capability:validate:1.1']\n\nxml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc-reply xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id=\"urn:uuid:4db8afe2-fbd9-4c13-abaf-f39ef678f63c\">\n<results xmlns=\"urn:nokia.com:sros:ns:yang:sr:oper-global\">\n<md-cli-output-block>TiMOS-B-20.10.B1-5 both/x86_64 Nokia 7750 SR Copyright (c) 2000-2020 Nokia.\n\nAll rights reserved. All use subject to applicable license agreements.\n\nBuilt on Fri Oct 2 18:11:20 PDT 2020 by builder in /builds/c/2010B/B1-5/panos/main/sros\n\n</md-cli-output-block>\n</results>\n</rpc-reply>\"\"\"\n\nclass TestSrosDevice(unittest.TestCase):\n\n    def setUp(self):\n        self.device_handler = SrosDeviceHandler({'name': 'sros'})\n\n    def test_add_additional_operations(self):\n        expected = {\n            'md_cli_raw_command': MdCliRawCommand,\n            'commit': Commit,\n        }\n        self.assertDictEqual(expected, self.device_handler.add_additional_operations())\n\n    def test_transform_reply(self):\n        expected = xml\n        actual = self.device_handler.transform_reply()\n        ele = to_ele(xml)\n        self.assertEqual(expected, to_xml(actual(ele)))\n\n    def test_get_capabilities_without_config_mode(self):\n        \"\"\"Test capabilities without 'config_mode' set\"\"\"\n        self.assertListEqual(capabilities, self.device_handler.get_capabilities())\n\n    def test_get_capabilities_with_config_mode_private(self):\n        \"\"\"Test capabilities when 'config_mode' is set to 'private'\"\"\"\n        device_handler = SrosDeviceHandler({'name': 'sros', 'config_mode': ConfigMode.PRIVATE})\n        expected_capabilities = capabilities + ['urn:nokia.com:nc:pc']\n        self.assertListEqual(expected_capabilities, device_handler.get_capabilities())\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.device_handler.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected['nsmap'] = self.device_handler.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.device_handler.get_xml_extra_prefix_kwargs())\n\n    def test_perform_qualify_check(self):\n        self.assertFalse(self.device_handler.perform_qualify_check())\n",
  "GT_file_code": {
    "ncclient/devices/sros.py": "from .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.sros.rpc import MdCliRawCommand, Commit\nfrom ncclient.xml_ import BASE_NS_1_0\n\n\nclass ConfigMode:\n    PRIVATE = 'private'\n\ndef passthrough(xml):\n    return xml\n\nclass SrosDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Nokia SR OS handler for device specific information.\n    \"\"\"\n\n    def __init__(self, device_params):\n        super(SrosDeviceHandler, self).__init__(device_params)\n\n    def get_capabilities(self):\n        \"\"\"Set SR OS device handler client capabilities\n\n        Set additional capabilities beyond the default device handler.\n\n        Returns:\n            A list of strings representing NETCONF capabilities to be\n            sent to the server.\n        \"\"\"\n        base = super(SrosDeviceHandler, self).get_capabilities()\n        additional = [\n            'urn:ietf:params:xml:ns:netconf:base:1.0',\n            'urn:ietf:params:xml:ns:yang:1',\n            'urn:ietf:params:netconf:capability:confirmed-commit:1.1',\n            'urn:ietf:params:netconf:capability:validate:1.1',\n        ]\n        if self.device_params.get('config_mode') == ConfigMode.PRIVATE:\n            additional.append('urn:nokia.com:nc:pc')\n\n        return base + additional\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def add_additional_operations(self):\n        operations = {\n            'md_cli_raw_command': MdCliRawCommand,\n            'commit': Commit,\n        }\n        return operations\n\n    def perform_qualify_check(self):\n        return False\n\n    def transform_reply(self):\n        return passthrough\n",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/xml_.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\n\n\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\n\n# In case issues come up with XML generation/parsing\n# make sure you have the ElementTree v1.2.7+ lib as\n# well as lxml v3.0+\n\nfrom ncclient import NCClientError\n\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\n\nclass XMLError(NCClientError):\n    pass\n\n### Namespace-related\n\n#: Base NETCONF namespace\nBASE_NS_1_0 = \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n#: YANG (RFC 6020/RFC 7950) namespace\nYANG_NS_1_0 = \"urn:ietf:params:xml:ns:yang:1\"\n#: NXOS_1_0\nNXOS_1_0 = \"http://www.cisco.com/nxos:1.0\"\n#: NXOS_IF\nNXOS_IF = \"http://www.cisco.com/nxos:1.0:if_manager\"\n#: Namespace for Tail-f core data model\nTAILF_AAA_1_1 = \"http://tail-f.com/ns/aaa/1.1\"\n#: Namespace for Tail-f execd data model\nTAILF_EXECD_1_1 = \"http://tail-f.com/ns/execd/1.1\"\n#: Namespace for Cisco data model\nCISCO_CPI_1_0 = \"http://www.cisco.com/cpi_10/schema\"\n#: Namespace for Flowmon data model\nFLOWMON_1_0 = \"http://www.liberouter.org/ns/netopeer/flowmon/1.0\"\n#: Namespace for Juniper 9.6R4. Tested with Junos 9.6R4+\nJUNIPER_1_1 = \"http://xml.juniper.net/xnm/1.1/xnm\"\n#: Namespace for Huawei data model\nHUAWEI_NS = \"http://www.huawei.com/netconf/vrp\"\n#: Namespace for Huawei private\nHW_PRIVATE_NS = \"http://www.huawei.com/netconf/capability/base/1.0\"\n#: Namespace for H3C data model\nH3C_DATA_1_0 = \"http://www.h3c.com/netconf/data:1.0\"\n#: Namespace for H3C config model\nH3C_CONFIG_1_0 = \"http://www.h3c.com/netconf/config:1.0\"\n#: Namespace for H3C action model\nH3C_ACTION_1_0 = \"http://www.h3c.com/netconf/action:1.0\"\n#: Namespace for netconf monitoring\nNETCONF_MONITORING_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\"\n#: Namespace for netconf notifications\nNETCONF_NOTIFICATION_NS = \"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n#: Namespace for netconf with-defaults (RFC 6243)\nNETCONF_WITH_DEFAULTS_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\"\n#: Namespace for Alcatel-Lucent SR OS Base r13 YANG models\nALU_CONFIG = \"urn:alcatel-lucent.com:sros:ns:yang:conf-r13\"\n#: Namespace for Nokia SR OS global operations\nSROS_GLOBAL_OPS_NS = \"urn:nokia.com:sros:ns:yang:sr:oper-global\"\n\n\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        # cElementTree uses ElementTree's _namespace_map, so that's ok\n        ElementTree._namespace_map[uri] = prefix\n\nfor (ns, pre) in six.iteritems({\n    BASE_NS_1_0: 'nc',\n    NETCONF_MONITORING_NS: 'ncm',\n    NXOS_1_0: 'nxos',\n    NXOS_IF: 'if',\n    TAILF_AAA_1_1: 'aaa',\n    TAILF_EXECD_1_1: 'execd',\n    CISCO_CPI_1_0: 'cpi',\n    FLOWMON_1_0: 'fm',\n    JUNIPER_1_1: 'junos',\n}):\n    register_namespace(pre, ns)\n\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else \"{%s}%s\" % (ns, tag)\n\"\"\"Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.\"\"\"\n\n\ndef to_xml(ele, encoding=\"UTF-8\", pretty_print=False):\n    \"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') \\\n            else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\n\ndef parse_root(raw):\n    \"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError(\"Element [%s] does not meet requirement\" % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)): req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError(\"Element [%s] does not have required attributes\" % ele.tag)\n    return ele\n\nXPATH_NAMESPACES = {\n    're':'http://exslt.org/regular-expressions'\n}\n\n\nclass NCElement(object):\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt=self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)),\n                                                                        parser=self.__parser))),\n                                       parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        # Comments don't have a namespace\n        if elem.tag is not etree.Comment:\n            # handle tag\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n\n            # handle attributes\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\n\n\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\n\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\n\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag,ns), attrs, **extra)\n\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\n\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)\n"
  },
  "GT_src_dict": {
    "ncclient/devices/sros.py": {
      "passthrough": {
        "code": "def passthrough(xml):\n    \"\"\"Returns the input XML unchanged.\n\nThis function takes an XML input and returns it without any modification. It serves as a simple passthrough utility, primarily used where a transformation might be needed but currently, no changes to the XML data are required. \n\nParameters:\n    xml: Any XML structure that is to be returned.\n\nReturns:\n    The same XML that was input, without alteration.\n\nThis function does not have any dependencies on external variables or constants.\"\"\"\n    return xml",
        "docstring": "Returns the input XML unchanged.\n\nThis function takes an XML input and returns it without any modification. It serves as a simple passthrough utility, primarily used where a transformation might be needed but currently, no changes to the XML data are required. \n\nParameters:\n    xml: Any XML structure that is to be returned.\n\nReturns:\n    The same XML that was input, without alteration.\n\nThis function does not have any dependencies on external variables or constants.",
        "signature": "def passthrough(xml):",
        "type": "Function",
        "class_signature": null
      },
      "SrosDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initialize the SrosDeviceHandler class, which extends the DefaultDeviceHandler, to manage device-specific information for Nokia SR OS.\n\nParameters:\n    device_params (dict): A dictionary containing parameters required for configuring the device handler. This may include attributes necessary for establishing a NETCONF connection and other device-specific settings.\n\nReturns:\n    None: This constructor does not return a value, but it initializes the instance of SrosDeviceHandler using the provided device parameters.\n\nDependencies:\n    - Inherits from DefaultDeviceHandler, which handles basic device operations.\n    - Utilizes the device_params to configure capabilities specific to Nokia SR OS devices.\"\"\"\n        super(SrosDeviceHandler, self).__init__(device_params)",
        "docstring": "Initialize the SrosDeviceHandler class, which extends the DefaultDeviceHandler, to manage device-specific information for Nokia SR OS.\n\nParameters:\n    device_params (dict): A dictionary containing parameters required for configuring the device handler. This may include attributes necessary for establishing a NETCONF connection and other device-specific settings.\n\nReturns:\n    None: This constructor does not return a value, but it initializes the instance of SrosDeviceHandler using the provided device parameters.\n\nDependencies:\n    - Inherits from DefaultDeviceHandler, which handles basic device operations.\n    - Utilizes the device_params to configure capabilities specific to Nokia SR OS devices.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Set additional NETCONF capabilities specific to the SR OS device handler.\n\nThis method overrides the default capabilities of the parent class, combining them with device-specific capabilities based on the device parameters. It checks if the device's configuration mode is set to 'private' (defined as `ConfigMode.PRIVATE`), in which case it adds a specific capability related to Nokia devices. The returned capabilities will be sent to the NETCONF server for establishing a connection.\n\nReturns:\n    list: A list of strings representing the NETCONF capabilities, which include standard and device-specific capabilities.\n\nDependencies:\n- Inherits from `DefaultDeviceHandler.get_capabilities()` to obtain the base capabilities.\n- Utilizes `ConfigMode.PRIVATE` to conditionally add a specific capability based on the configuration mode of the device.\"\"\"\n        'Set SR OS device handler client capabilities\\n\\n        Set additional capabilities beyond the default device handler.\\n\\n        Returns:\\n            A list of strings representing NETCONF capabilities to be\\n            sent to the server.\\n        '\n        base = super(SrosDeviceHandler, self).get_capabilities()\n        additional = ['urn:ietf:params:xml:ns:netconf:base:1.0', 'urn:ietf:params:xml:ns:yang:1', 'urn:ietf:params:netconf:capability:confirmed-commit:1.1', 'urn:ietf:params:netconf:capability:validate:1.1']\n        if self.device_params.get('config_mode') == ConfigMode.PRIVATE:\n            additional.append('urn:nokia.com:nc:pc')\n        return base + additional",
        "docstring": "Set additional NETCONF capabilities specific to the SR OS device handler.\n\nThis method overrides the default capabilities of the parent class, combining them with device-specific capabilities based on the device parameters. It checks if the device's configuration mode is set to 'private' (defined as `ConfigMode.PRIVATE`), in which case it adds a specific capability related to Nokia devices. The returned capabilities will be sent to the NETCONF server for establishing a connection.\n\nReturns:\n    list: A list of strings representing the NETCONF capabilities, which include standard and device-specific capabilities.\n\nDependencies:\n- Inherits from `DefaultDeviceHandler.get_capabilities()` to obtain the base capabilities.\n- Utilizes `ConfigMode.PRIVATE` to conditionally add a specific capability based on the configuration mode of the device.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary that maps XML namespaces for the Nokia SR OS device handler.\n\nThis method constructs and returns a dictionary with a single entry, where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, represents the base namespace defined in the NETCONF protocol. This namespace is essential for ensuring that the XML messages exchanged with the device conform to the expected structure and standards.\n\nReturns:\n    dict: A dictionary containing the base XML namespace mapping.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary that maps XML namespaces for the Nokia SR OS device handler.\n\nThis method constructs and returns a dictionary with a single entry, where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, represents the base namespace defined in the NETCONF protocol. This namespace is essential for ensuring that the XML messages exchanged with the device conform to the expected structure and standards.\n\nReturns:\n    dict: A dictionary containing the base XML namespace mapping.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing XML namespace mappings for NETCONF operations.\n\nThis method calls `get_xml_base_namespace_dict()` to retrieve the base namespace dictionary and updates it to form a complete `nsmap` for XML processing. The returned dictionary is structured for use in XML serialization, facilitating operations related to NETCONF on Nokia SR OS devices.\n\nReturns:\n    dict: A dictionary with a single key `\"nsmap\"` mapping to the XML base namespace dictionary.\n\nDependencies:\n    - `BASE_NS_1_0`: A constant defined in `ncclient.xml_` that represents the base namespace for NETCONF operations, used to ensure compatibility with the NETCONF protocol.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing XML namespace mappings for NETCONF operations.\n\nThis method calls `get_xml_base_namespace_dict()` to retrieve the base namespace dictionary and updates it to form a complete `nsmap` for XML processing. The returned dictionary is structured for use in XML serialization, facilitating operations related to NETCONF on Nokia SR OS devices.\n\nReturns:\n    dict: A dictionary with a single key `\"nsmap\"` mapping to the XML base namespace dictionary.\n\nDependencies:\n    - `BASE_NS_1_0`: A constant defined in `ncclient.xml_` that represents the base namespace for NETCONF operations, used to ensure compatibility with the NETCONF protocol.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Add additional NETCONF operations specific to the Nokia SR OS.\n\nThis method defines a dictionary of additional operations that can be performed on the SROS device. It includes the 'md_cli_raw_command' for executing raw CLI commands and 'commit' for confirming changes made in the configuration context.\n\nReturns:\n    dict: A dictionary mapping operation names to their corresponding classes or functions, including:\n        - 'md_cli_raw_command': MdCliRawCommand\n        - 'commit': Commit\n\nDependencies:\n    - MdCliRawCommand and Commit are imported from the 'ncclient.operations.third_party.sros.rpc' module.\"\"\"\n        operations = {'md_cli_raw_command': MdCliRawCommand, 'commit': Commit}\n        return operations",
        "docstring": "Add additional NETCONF operations specific to the Nokia SR OS.\n\nThis method defines a dictionary of additional operations that can be performed on the SROS device. It includes the 'md_cli_raw_command' for executing raw CLI commands and 'commit' for confirming changes made in the configuration context.\n\nReturns:\n    dict: A dictionary mapping operation names to their corresponding classes or functions, including:\n        - 'md_cli_raw_command': MdCliRawCommand\n        - 'commit': Commit\n\nDependencies:\n    - MdCliRawCommand and Commit are imported from the 'ncclient.operations.third_party.sros.rpc' module.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.perform_qualify_check": {
        "code": "    def perform_qualify_check(self):\n        \"\"\"Checks whether the SROS device is qualified for specific operations.\n\nThis method is part of the SrosDeviceHandler class, which is designed to handle Nokia SR OS device-specific operations. It currently always returns False, indicating that qualification checks are not necessary or applicable for this specific implementation.\n\nReturns:\n    bool: Always returns False, indicating no qualification check is performed.\n\nDependencies:\n    This method does not interact with any constants or external variables, nor does it have any side effects. It serves as a placeholder for potential future functionality regarding operation qualification.\"\"\"\n        return False",
        "docstring": "Checks whether the SROS device is qualified for specific operations.\n\nThis method is part of the SrosDeviceHandler class, which is designed to handle Nokia SR OS device-specific operations. It currently always returns False, indicating that qualification checks are not necessary or applicable for this specific implementation.\n\nReturns:\n    bool: Always returns False, indicating no qualification check is performed.\n\nDependencies:\n    This method does not interact with any constants or external variables, nor does it have any side effects. It serves as a placeholder for potential future functionality regarding operation qualification.",
        "signature": "def perform_qualify_check(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      },
      "SrosDeviceHandler.transform_reply": {
        "code": "    def transform_reply(self):\n        \"\"\"Transforms the reply received from a NETCONF operation by passing it through the passthrough function.\n\nThis method is part of the SrosDeviceHandler class, which specializes in handling device-specific operations for Nokia SR OS. It directly returns the output of the passthrough function, which is a placeholder for further processing of the XML response.\n\nReturns:\n    A callable function (passthrough) that takes an XML input and returns it unchanged.\n\nDependencies:\n    - passthrough: A function defined in the same module that simply returns the input XML as is, without any modifications.\"\"\"\n        return passthrough",
        "docstring": "Transforms the reply received from a NETCONF operation by passing it through the passthrough function.\n\nThis method is part of the SrosDeviceHandler class, which specializes in handling device-specific operations for Nokia SR OS. It directly returns the output of the passthrough function, which is a placeholder for further processing of the XML response.\n\nReturns:\n    A callable function (passthrough) that takes an XML input and returns it unchanged.\n\nDependencies:\n    - passthrough: A function defined in the same module that simply returns the input XML as is, without any modifications.",
        "signature": "def transform_reply(self):",
        "type": "Method",
        "class_signature": "class SrosDeviceHandler(DefaultDeviceHandler):"
      }
    },
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initialize the DefaultDeviceHandler instance.\n\nThis constructor sets up the device parameters and initializes internal attributes for handling exempt error messages. It processes the _EXEMPT_ERRORS constant, turning them into lowercase and categorizing them into four lists based on their wildcard characteristics (exact match, start with wildcard, end with wildcard, and full wildcard match). This allows for efficient checking of exempt errors when handling RPC errors later in the device communication process.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device, which may be utilized by specific device handlers that subclass DefaultDeviceHandler.\n\nAttributes:\n- device_params: Stores the device parameters provided during initialization.\n- capabilities: A list initialized to store additional capabilities specific to the device after instantiation.\n- _exempt_errors_exact_match: A list of exempt error messages that require an exact match (case insensitive).\n- _exempt_errors_startwith_wildcard_match: A list of exempt error messages that start with wildcard characters.\n- _exempt_errors_endwith_wildcard_match: A list of exempt error messages that end with wildcard characters.\n- _exempt_errors_full_wildcard_match: A list of exempt error messages that contain wildcards at both ends.\n\nConstants:\n- _EXEMPT_ERRORS: Defined at the class level, this list allows for specifying custom error messages that should be exempt from raising exceptions, accommodating specific device behaviors.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initialize the DefaultDeviceHandler instance.\n\nThis constructor sets up the device parameters and initializes internal attributes for handling exempt error messages. It processes the _EXEMPT_ERRORS constant, turning them into lowercase and categorizing them into four lists based on their wildcard characteristics (exact match, start with wildcard, end with wildcard, and full wildcard match). This allows for efficient checking of exempt errors when handling RPC errors later in the device communication process.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device, which may be utilized by specific device handlers that subclass DefaultDeviceHandler.\n\nAttributes:\n- device_params: Stores the device parameters provided during initialization.\n- capabilities: A list initialized to store additional capabilities specific to the device after instantiation.\n- _exempt_errors_exact_match: A list of exempt error messages that require an exact match (case insensitive).\n- _exempt_errors_startwith_wildcard_match: A list of exempt error messages that start with wildcard characters.\n- _exempt_errors_endwith_wildcard_match: A list of exempt error messages that end with wildcard characters.\n- _exempt_errors_full_wildcard_match: A list of exempt error messages that contain wildcards at both ends.\n\nConstants:\n- _EXEMPT_ERRORS: Defined at the class level, this list allows for specifying custom error messages that should be exempt from raising exceptions, accommodating specific device behaviors.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      },
      "DefaultDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Return the list of NETCONF capabilities supported by the device.\n\nThis method compiles a comprehensive list of capability URIs that the device supports. It combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities specified for the device instance. This list is essential during the initial capability exchange in NETCONF communication to inform the server about the client's capabilities.\n\nReturns:\n    list: A concatenated list of base and device-specific capability URIs.\n\nDependencies:\n    - _BASE_CAPABILITIES: A class-level constant that contains a standard list of NETCONF capabilities, essential for defining the device's basic operational features.\n    - self.capabilities: An instance variable that can be modified to include additional capabilities specific to the device handler.\"\"\"\n        \"\\n        Return the capability list.\\n\\n        A list of URI's representing the client's capabilities. This is used during\\n        the initial capability exchange. Modify (in a new device-handler subclass)\\n        as needed.\\n\\n        \"\n        return self._BASE_CAPABILITIES + self.capabilities",
        "docstring": "Return the list of NETCONF capabilities supported by the device.\n\nThis method compiles a comprehensive list of capability URIs that the device supports. It combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities specified for the device instance. This list is essential during the initial capability exchange in NETCONF communication to inform the server about the client's capabilities.\n\nReturns:\n    list: A concatenated list of base and device-specific capability URIs.\n\nDependencies:\n    - _BASE_CAPABILITIES: A class-level constant that contains a standard list of NETCONF capabilities, essential for defining the device's basic operational features.\n    - self.capabilities: An instance variable that can be modified to include additional capabilities specific to the device handler.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/xml_.py": {
      "_get_parser": {
        "code": "def _get_parser(huge_tree=False):\n    \"\"\"Retrieves the appropriate XML parser based on the specified tree size.\n\nParameters:\n- huge_tree (bool): If set to True, returns a parser configured to handle very deep trees and long text contents. Defaults to False.\n\nReturns:\n- etree.XMLParser: An instance of an XML parser, either the standard parser or the huge_parser, defined at the module level.\n\nDependencies:\n- The function utilizes two parser constants, `parser` and `huge_parser`, which are instances of `etree.XMLParser`. The choice of parser depends on the complexity of the XML structure to be processed, allowing for efficient parsing based on the needs of the application.\"\"\"\n    return huge_parser if huge_tree else parser",
        "docstring": "Retrieves the appropriate XML parser based on the specified tree size.\n\nParameters:\n- huge_tree (bool): If set to True, returns a parser configured to handle very deep trees and long text contents. Defaults to False.\n\nReturns:\n- etree.XMLParser: An instance of an XML parser, either the standard parser or the huge_parser, defined at the module level.\n\nDependencies:\n- The function utilizes two parser constants, `parser` and `huge_parser`, which are instances of `etree.XMLParser`. The choice of parser depends on the complexity of the XML structure to be processed, allowing for efficient parsing based on the needs of the application.",
        "signature": "def _get_parser(huge_tree=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_xml": {
        "code": "def to_xml(ele, encoding='UTF-8', pretty_print=False):\n    \"\"\"Convert and return the XML representation of an `ElementTree.Element` object.\n\nParameters:\n- ele: An instance of `~xml.etree.ElementTree.Element` that represents the XML element to be converted.\n- encoding (str, optional): The character encoding to use for the output XML string (default is \"UTF-8\").\n- pretty_print (bool, optional): If set to True, the output XML will be formatted for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element `ele`, encoded in the specified character encoding. If the XML does not start with an XML declaration, one will be prepended.\n\nNotes:\n- This function leverages the `etree.tostring` method from the `lxml` library to serialize the XML. It checks the Python version to determine how to handle strings and byte strings appropriately.\n- There are no direct constants defined within the `to_xml` function, but it is dependent on the external `etree` object imported from `lxml` and the `sys` module to determine the Python version for string handling.\"\"\"\n    'Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.'\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))",
        "docstring": "Convert and return the XML representation of an `ElementTree.Element` object.\n\nParameters:\n- ele: An instance of `~xml.etree.ElementTree.Element` that represents the XML element to be converted.\n- encoding (str, optional): The character encoding to use for the output XML string (default is \"UTF-8\").\n- pretty_print (bool, optional): If set to True, the output XML will be formatted for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element `ele`, encoded in the specified character encoding. If the XML does not start with an XML declaration, one will be prepended.\n\nNotes:\n- This function leverages the `etree.tostring` method from the `lxml` library to serialize the XML. It checks the Python version to determine how to handle strings and byte strings appropriately.\n- There are no direct constants defined within the `to_xml` function, but it is dependent on the external `etree` object imported from `lxml` and the `sys` module to determine the Python version for string handling.",
        "signature": "def to_xml(ele, encoding='UTF-8', pretty_print=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_ele": {
        "code": "def to_ele(x, huge_tree=False):\n    \"\"\"Convert an XML document or string *x* into an `Element` object from `xml.etree.ElementTree`. If *x* is already an `Element`, it is returned unchanged. The function supports parsing of very deep XML trees and long text content when the *huge_tree* parameter is set to True.\n\nParameters:\n- x: A string representation of the XML or an `Element` object to be converted.\n- huge_tree (bool): When set to True, allows parsing of XML documents with deep trees and lengthy text content.\n\nReturns:\n- An `Element` object corresponding to the XML document or the input `Element` if no conversion is needed.\n\nNotes:\n- This function uses the `etree` module from the `lxml` library and is compatible with both Python 2 and 3. The version check ensures proper handling of strings in different Python versions, as well as utilizing the `_get_parser` function to retrieve the appropriate XML parser based on the *huge_tree* flag.\"\"\"\n    'Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\\n\\n    *huge_tree*: parse XML with very deep trees and very long text content\\n    '\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))",
        "docstring": "Convert an XML document or string *x* into an `Element` object from `xml.etree.ElementTree`. If *x* is already an `Element`, it is returned unchanged. The function supports parsing of very deep XML trees and long text content when the *huge_tree* parameter is set to True.\n\nParameters:\n- x: A string representation of the XML or an `Element` object to be converted.\n- huge_tree (bool): When set to True, allows parsing of XML documents with deep trees and lengthy text content.\n\nReturns:\n- An `Element` object corresponding to the XML document or the input `Element` if no conversion is needed.\n\nNotes:\n- This function uses the `etree` module from the `lxml` library and is compatible with both Python 2 and 3. The version check ensures proper handling of strings in different Python versions, as well as utilizing the `_get_parser` function to retrieve the appropriate XML parser based on the *huge_tree* flag.",
        "signature": "def to_ele(x, huge_tree=False):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/sros.py:SrosDeviceHandler:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {},
    "ncclient/devices/sros.py:SrosDeviceHandler:get_capabilities": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {},
    "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_extra_prefix_kwargs": {},
    "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_base_namespace_dict": {},
    "ncclient/xml_.py:to_ele": {},
    "ncclient/xml_.py:_get_parser": {}
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:setUp": {
      "ncclient/devices/sros.py:SrosDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_add_additional_operations": {
      "ncclient/devices/sros.py:SrosDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_get_capabilities_with_config_mode_private": {
      "ncclient/devices/sros.py:SrosDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      },
      "ncclient/devices/sros.py:SrosDeviceHandler:get_capabilities": {
        "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {}
      }
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_get_capabilities_without_config_mode": {
      "ncclient/devices/sros.py:SrosDeviceHandler:get_capabilities": {
        "ncclient/devices/default.py:DefaultDeviceHandler:get_capabilities": {}
      }
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/sros.py:SrosDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_perform_qualify_check": {
      "ncclient/devices/sros.py:SrosDeviceHandler:perform_qualify_check": {}
    },
    "modified_testcases/unit/devices/test_sros.py:TestSrosDevice:test_transform_reply": {
      "ncclient/devices/sros.py:SrosDeviceHandler:transform_reply": {},
      "ncclient/xml_.py:to_ele": {
        "ncclient/xml_.py:_get_parser": {}
      },
      "ncclient/devices/sros.py:passthrough": {},
      "ncclient/xml_.py:to_xml": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_sros/ncclient-test_sros/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_sros\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 default.py\n    \u2502   \u2502   \u251c\u2500\u2500 DefaultDeviceHandler.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultDeviceHandler.get_capabilities\n    \u2502   \u2514\u2500\u2500 sros.py\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.get_capabilities\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.perform_qualify_check\n    \u2502       \u251c\u2500\u2500 SrosDeviceHandler.transform_reply\n    \u2502       \u2514\u2500\u2500 passthrough\n    \u251c\u2500\u2500 transport/\n    \u2502   \u2514\u2500\u2500 errors.py\n    \u2502       \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n    \u2514\u2500\u2500 xml_.py\n        \u251c\u2500\u2500 _get_parser\n        \u251c\u2500\u2500 to_ele\n        \u2514\u2500\u2500 to_xml\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to facilitate interactions with Nokia's SR OS devices via the NETCONF protocol, enabling developers to manage, configure, and retrieve operational data seamlessly. It provides robust functionality for handling device-specific operations, such as executing raw management CLI commands, committing configuration changes, and transforming XML-based replies into a standardized format. The module also supports the discovery of device capabilities, allows for the extension of operation sets, and integrates specific configurations like private-mode operations. By abstracting the complexity of device communication and ensuring compatibility with various NETCONF capabilities, the module simplifies network management and enhances developer efficiency when working with SR OS environments.\n\n## FILE 1: ncclient/devices/sros.py\n\n- CLASS METHOD: SrosDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nAdd additional NETCONF operations specific to the Nokia SR OS.\n\nThis method defines a dictionary of additional operations that can be performed on the SROS device. It includes the 'md_cli_raw_command' for executing raw CLI commands and 'commit' for confirming changes made in the configuration context.\n\nReturns:\n    dict: A dictionary mapping operation names to their corresponding classes or functions, including:\n        - 'md_cli_raw_command': MdCliRawCommand\n        - 'commit': Commit\n\nDependencies:\n    - MdCliRawCommand and Commit are imported from the 'ncclient.operations.third_party.sros.rpc' module.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.__init__\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the SrosDeviceHandler class, which extends the DefaultDeviceHandler, to manage device-specific information for Nokia SR OS.\n\nParameters:\n    device_params (dict): A dictionary containing parameters required for configuring the device handler. This may include attributes necessary for establishing a NETCONF connection and other device-specific settings.\n\nReturns:\n    None: This constructor does not return a value, but it initializes the instance of SrosDeviceHandler using the provided device parameters.\n\nDependencies:\n    - Inherits from DefaultDeviceHandler, which handles basic device operations.\n    - Utilizes the device_params to configure capabilities specific to Nokia SR OS devices.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary that maps XML namespaces for the Nokia SR OS device handler.\n\nThis method constructs and returns a dictionary with a single entry, where the key is `None` and the value is `BASE_NS_1_0`. The `BASE_NS_1_0` constant, imported from `ncclient.xml_`, represents the base namespace defined in the NETCONF protocol. This namespace is essential for ensuring that the XML messages exchanged with the device conform to the expected structure and standards.\n\nReturns:\n    dict: A dictionary containing the base XML namespace mapping.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing XML namespace mappings for NETCONF operations.\n\nThis method calls `get_xml_base_namespace_dict()` to retrieve the base namespace dictionary and updates it to form a complete `nsmap` for XML processing. The returned dictionary is structured for use in XML serialization, facilitating operations related to NETCONF on Nokia SR OS devices.\n\nReturns:\n    dict: A dictionary with a single key `\"nsmap\"` mapping to the XML base namespace dictionary.\n\nDependencies:\n    - `BASE_NS_1_0`: A constant defined in `ncclient.xml_` that represents the base namespace for NETCONF operations, used to ensure compatibility with the NETCONF protocol.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.perform_qualify_check\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def perform_qualify_check(self):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks whether the SROS device is qualified for specific operations.\n\nThis method is part of the SrosDeviceHandler class, which is designed to handle Nokia SR OS device-specific operations. It currently always returns False, indicating that qualification checks are not necessary or applicable for this specific implementation.\n\nReturns:\n    bool: Always returns False, indicating no qualification check is performed.\n\nDependencies:\n    This method does not interact with any constants or external variables, nor does it have any side effects. It serves as a placeholder for potential future functionality regarding operation qualification.\n\"\"\"\n```\n\n- FUNCTION NAME: passthrough\n  - SIGNATURE: def passthrough(xml):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the input XML unchanged.\n\nThis function takes an XML input and returns it without any modification. It serves as a simple passthrough utility, primarily used where a transformation might be needed but currently, no changes to the XML data are required. \n\nParameters:\n    xml: Any XML structure that is to be returned.\n\nReturns:\n    The same XML that was input, without alteration.\n\nThis function does not have any dependencies on external variables or constants.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nSet additional NETCONF capabilities specific to the SR OS device handler.\n\nThis method overrides the default capabilities of the parent class, combining them with device-specific capabilities based on the device parameters. It checks if the device's configuration mode is set to 'private' (defined as `ConfigMode.PRIVATE`), in which case it adds a specific capability related to Nokia devices. The returned capabilities will be sent to the NETCONF server for establishing a connection.\n\nReturns:\n    list: A list of strings representing the NETCONF capabilities, which include standard and device-specific capabilities.\n\nDependencies:\n- Inherits from `DefaultDeviceHandler.get_capabilities()` to obtain the base capabilities.\n- Utilizes `ConfigMode.PRIVATE` to conditionally add a specific capability based on the configuration mode of the device.\n\"\"\"\n```\n\n- CLASS METHOD: SrosDeviceHandler.transform_reply\n  - CLASS SIGNATURE: class SrosDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def transform_reply(self):\n  - DOCSTRING: \n```python\n\"\"\"\nTransforms the reply received from a NETCONF operation by passing it through the passthrough function.\n\nThis method is part of the SrosDeviceHandler class, which specializes in handling device-specific operations for Nokia SR OS. It directly returns the output of the passthrough function, which is a placeholder for further processing of the XML response.\n\nReturns:\n    A callable function (passthrough) that takes an XML input and returns it unchanged.\n\nDependencies:\n    - passthrough: A function defined in the same module that simply returns the input XML as is, without any modifications.\n\"\"\"\n```\n\n## FILE 2: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the DefaultDeviceHandler instance.\n\nThis constructor sets up the device parameters and initializes internal attributes for handling exempt error messages. It processes the _EXEMPT_ERRORS constant, turning them into lowercase and categorizing them into four lists based on their wildcard characteristics (exact match, start with wildcard, end with wildcard, and full wildcard match). This allows for efficient checking of exempt errors when handling RPC errors later in the device communication process.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device, which may be utilized by specific device handlers that subclass DefaultDeviceHandler.\n\nAttributes:\n- device_params: Stores the device parameters provided during initialization.\n- capabilities: A list initialized to store additional capabilities specific to the device after instantiation.\n- _exempt_errors_exact_match: A list of exempt error messages that require an exact match (case insensitive).\n- _exempt_errors_startwith_wildcard_match: A list of exempt error messages that start with wildcard characters.\n- _exempt_errors_endwith_wildcard_match: A list of exempt error messages that end with wildcard characters.\n- _exempt_errors_full_wildcard_match: A list of exempt error messages that contain wildcards at both ends.\n\nConstants:\n- _EXEMPT_ERRORS: Defined at the class level, this list allows for specifying custom error messages that should be exempt from raising exceptions, accommodating specific device behaviors.\n\"\"\"\n```\n\n- CLASS METHOD: DefaultDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the list of NETCONF capabilities supported by the device.\n\nThis method compiles a comprehensive list of capability URIs that the device supports. It combines the base capabilities defined in the class constant _BASE_CAPABILITIES with any additional capabilities specified for the device instance. This list is essential during the initial capability exchange in NETCONF communication to inform the server about the client's capabilities.\n\nReturns:\n    list: A concatenated list of base and device-specific capability URIs.\n\nDependencies:\n    - _BASE_CAPABILITIES: A class-level constant that contains a standard list of NETCONF capabilities, essential for defining the device's basic operational features.\n    - self.capabilities: An instance variable that can be modified to include additional capabilities specific to the device handler.\n\"\"\"\n```\n\n## FILE 3: ncclient/transport/errors.py\n\n## FILE 4: ncclient/xml_.py\n\n- FUNCTION NAME: to_xml\n  - SIGNATURE: def to_xml(ele, encoding='UTF-8', pretty_print=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert and return the XML representation of an `ElementTree.Element` object.\n\nParameters:\n- ele: An instance of `~xml.etree.ElementTree.Element` that represents the XML element to be converted.\n- encoding (str, optional): The character encoding to use for the output XML string (default is \"UTF-8\").\n- pretty_print (bool, optional): If set to True, the output XML will be formatted for readability (default is False).\n\nReturns:\n- A string containing the XML representation of the input element `ele`, encoded in the specified character encoding. If the XML does not start with an XML declaration, one will be prepended.\n\nNotes:\n- This function leverages the `etree.tostring` method from the `lxml` library to serialize the XML. It checks the Python version to determine how to handle strings and byte strings appropriately.\n- There are no direct constants defined within the `to_xml` function, but it is dependent on the external `etree` object imported from `lxml` and the `sys` module to determine the Python version for string handling.\n\"\"\"\n```\n\n- FUNCTION NAME: to_ele\n  - SIGNATURE: def to_ele(x, huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an XML document or string *x* into an `Element` object from `xml.etree.ElementTree`. If *x* is already an `Element`, it is returned unchanged. The function supports parsing of very deep XML trees and long text content when the *huge_tree* parameter is set to True.\n\nParameters:\n- x: A string representation of the XML or an `Element` object to be converted.\n- huge_tree (bool): When set to True, allows parsing of XML documents with deep trees and lengthy text content.\n\nReturns:\n- An `Element` object corresponding to the XML document or the input `Element` if no conversion is needed.\n\nNotes:\n- This function uses the `etree` module from the `lxml` library and is compatible with both Python 2 and 3. The version check ensures proper handling of strings in different Python versions, as well as utilizing the `_get_parser` function to retrieve the appropriate XML parser based on the *huge_tree* flag.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:_get_parser\n\n- FUNCTION NAME: _get_parser\n  - SIGNATURE: def _get_parser(huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the appropriate XML parser based on the specified tree size.\n\nParameters:\n- huge_tree (bool): If set to True, returns a parser configured to handle very deep trees and long text contents. Defaults to False.\n\nReturns:\n- etree.XMLParser: An instance of an XML parser, either the standard parser or the huge_parser, defined at the module level.\n\nDependencies:\n- The function utilizes two parser constants, `parser` and `huge_parser`, which are instances of `etree.XMLParser`. The choice of parser depends on the complexity of the XML structure to be processed, allowing for efficient parsing based on the needs of the application.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:to_ele\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/devices/sros.py": "from .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.sros.rpc import MdCliRawCommand, Commit\nfrom ncclient.xml_ import BASE_NS_1_0\n\nclass ConfigMode:\n    PRIVATE = 'private'\n\nclass SrosDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Nokia SR OS handler for device specific information.\n    \"\"\"",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/xml_.py": "\"\"\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\"\"\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\nfrom ncclient import NCClientError\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\nclass XMLError(NCClientError):\n    pass\nBASE_NS_1_0 = 'urn:ietf:params:xml:ns:netconf:base:1.0'\nYANG_NS_1_0 = 'urn:ietf:params:xml:ns:yang:1'\nNXOS_1_0 = 'http://www.cisco.com/nxos:1.0'\nNXOS_IF = 'http://www.cisco.com/nxos:1.0:if_manager'\nTAILF_AAA_1_1 = 'http://tail-f.com/ns/aaa/1.1'\nTAILF_EXECD_1_1 = 'http://tail-f.com/ns/execd/1.1'\nCISCO_CPI_1_0 = 'http://www.cisco.com/cpi_10/schema'\nFLOWMON_1_0 = 'http://www.liberouter.org/ns/netopeer/flowmon/1.0'\nJUNIPER_1_1 = 'http://xml.juniper.net/xnm/1.1/xnm'\nHUAWEI_NS = 'http://www.huawei.com/netconf/vrp'\nHW_PRIVATE_NS = 'http://www.huawei.com/netconf/capability/base/1.0'\nH3C_DATA_1_0 = 'http://www.h3c.com/netconf/data:1.0'\nH3C_CONFIG_1_0 = 'http://www.h3c.com/netconf/config:1.0'\nH3C_ACTION_1_0 = 'http://www.h3c.com/netconf/action:1.0'\nNETCONF_MONITORING_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring'\nNETCONF_NOTIFICATION_NS = 'urn:ietf:params:xml:ns:netconf:notification:1.0'\nNETCONF_WITH_DEFAULTS_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults'\nALU_CONFIG = 'urn:alcatel-lucent.com:sros:ns:yang:conf-r13'\nSROS_GLOBAL_OPS_NS = 'urn:nokia.com:sros:ns:yang:sr:oper-global'\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        ElementTree._namespace_map[uri] = prefix\nfor ns, pre in six.iteritems({BASE_NS_1_0: 'nc', NETCONF_MONITORING_NS: 'ncm', NXOS_1_0: 'nxos', NXOS_IF: 'if', TAILF_AAA_1_1: 'aaa', TAILF_EXECD_1_1: 'execd', CISCO_CPI_1_0: 'cpi', FLOWMON_1_0: 'fm', JUNIPER_1_1: 'junos'}):\n    register_namespace(pre, ns)\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else '{%s}%s' % (ns, tag)\n'Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.'\n\ndef parse_root(raw):\n    \"\"\"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\"\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError('Element [%s] does not meet requirement' % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)):\n                req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError('Element [%s] does not have required attributes' % ele.tag)\n    return ele\nXPATH_NAMESPACES = {'re': 'http://exslt.org/regular-expressions'}\n\nclass NCElement(object):\n\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt = self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)), parser=self.__parser))), parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        if elem.tag is not etree.Comment:\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag, ns), attrs, **extra)\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)"
  }
}