{
  "dir_path": "/app/typish",
  "package_name": "typish",
  "sample_name": "typish-test_is_optional_type",
  "src_dir": "test_resources/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/functions/test_is_optional_type.py",
  "test_code": "from typing import Optional, Union\nfrom unittest import TestCase\n\nfrom typish import (\n    NoneType,\n)\nfrom typish.functions._is_optional_type import is_optional_type\n\n\nclass TestIsOptionalType(TestCase):\n    def test_is_optional_type(self):\n        self.assertTrue(is_optional_type(Optional[str]))\n        self.assertTrue(is_optional_type(Union[str, None]))\n        self.assertTrue(is_optional_type(Union[str, NoneType]))\n        self.assertTrue(not is_optional_type(str))\n        self.assertTrue(not is_optional_type(Union[str, int]))\n",
  "GT_file_code": {
    "typish/functions/_is_optional_type.py": "import typing\n\nfrom typish import get_origin, get_args, NoneType\n\n\ndef is_optional_type(cls: type) -> bool:\n    \"\"\"\n    Return True if the given class is an optional type. A type is considered to\n    be optional if it allows ``None`` as value.\n\n    Example:\n\n    is_optional_type(Optional[str])  # True\n    is_optional_type(Union[str, int, None])  # True\n    is_optional_type(str)  # False\n    is_optional_type(Union[str, int])  # False\n\n    :param cls: a type.\n    :return: True if cls is an optional type.\n    \"\"\"\n    origin = get_origin(cls)\n    args = get_args(cls)\n    return origin == typing.Union and NoneType in args\n"
  },
  "GT_src_dict": {
    "typish/functions/_is_optional_type.py": {
      "is_optional_type": {
        "code": "def is_optional_type(cls: type) -> bool:\n    \"\"\"Determine if a given type is optional, meaning it can include None as a valid value. This function utilizes `get_origin` and `get_args` from the `typish` library to inspect the type's characteristics. An optional type is identified as a Union type that includes NoneType.\n\nParameters:\n- cls (type): The type to be checked.\n\nReturns:\n- bool: True if the type is optional; otherwise, False.\n\nDependencies:\n- `typing.Union`: Used to check if the type is a union type.\n- `NoneType`: A helper from `typish` that represents the None type, used to identify optional types.\"\"\"\n    '\\n    Return True if the given class is an optional type. A type is considered to\\n    be optional if it allows ``None`` as value.\\n\\n    Example:\\n\\n    is_optional_type(Optional[str])  # True\\n    is_optional_type(Union[str, int, None])  # True\\n    is_optional_type(str)  # False\\n    is_optional_type(Union[str, int])  # False\\n\\n    :param cls: a type.\\n    :return: True if cls is an optional type.\\n    '\n    origin = get_origin(cls)\n    args = get_args(cls)\n    return origin == typing.Union and NoneType in args",
        "docstring": "Determine if a given type is optional, meaning it can include None as a valid value. This function utilizes `get_origin` and `get_args` from the `typish` library to inspect the type's characteristics. An optional type is identified as a Union type that includes NoneType.\n\nParameters:\n- cls (type): The type to be checked.\n\nReturns:\n- bool: True if the type is optional; otherwise, False.\n\nDependencies:\n- `typing.Union`: Used to check if the type is a union type.\n- `NoneType`: A helper from `typish` that represents the None type, used to identify optional types.",
        "signature": "def is_optional_type(cls: type) -> bool:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "typish/functions/_is_optional_type.py:is_optional_type": {
      "typish/functions/_get_args.py": {
        "get_args": {
          "code": "def get_args(t: type) -> typing.Tuple[type, ...]:\n    \"\"\"\n    Get the arguments from a collection type (e.g. ``typing.List[int]``) as a\n    ``tuple``.\n    :param t: the collection type.\n    :return: a ``tuple`` containing types.\n    \"\"\"\n    args_ = getattr(t, '__args__', tuple()) or tuple()\n    args = tuple([attr for attr in args_\n                  if type(attr) != typing.TypeVar])\n    return args",
          "docstring": "Get the arguments from a collection type (e.g. ``typing.List[int]``) as a\n``tuple``.\n:param t: the collection type.\n:return: a ``tuple`` containing types.",
          "signature": "def get_args(t: type) -> typing.Tuple[type, ...]:",
          "type": "Function",
          "class_signature": null
        }
      },
      "typish/functions/_get_origin.py": {
        "get_origin": {
          "code": "def get_origin(t: type) -> type:\n    \"\"\"\n    Return the origin of the given (generic) type. For example, for\n    ``t=List[str]``, the result would be ``list``.\n    :param t: the type of which the origin is to be found.\n    :return: the origin of ``t`` or ``t`` if it is not generic.\n    \"\"\"\n    from typish.functions._get_simple_name import get_simple_name\n\n    simple_name = get_simple_name(t)\n    result = _type_per_alias.get(simple_name, None)\n    if isclass(t) and not is_from_typing(t):\n        # Get the origin in case of a parameterized generic.\n        result = getattr(t, '__origin__', t)\n    elif not result:\n        result = getattr(typing, simple_name, t)\n    return result",
          "docstring": "Return the origin of the given (generic) type. For example, for\n``t=List[str]``, the result would be ``list``.\n:param t: the type of which the origin is to be found.\n:return: the origin of ``t`` or ``t`` if it is not generic.",
          "signature": "def get_origin(t: type) -> type:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: typish-test_is_optional_type\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 typish/\n    \u2514\u2500\u2500 functions/\n        \u2514\u2500\u2500 _is_optional_type.py\n            \u2514\u2500\u2500 is_optional_type\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to identify and verify whether a given type is an optional type in Python, where an optional type allows a variable to hold either a specific type or `None`. It provides functionality to evaluate complex type annotations, such as `Optional` or `Union` constructs, and determine their optionality programmatically. This capability streamlines type validation and enhances type-checking workflows for developers working with dynamic or statically typed Python codebases, addressing the challenge of correctly interpreting and handling optional type annotations in development or testing scenarios.\n\n## FILE 1: typish/functions/_is_optional_type.py\n\n- FUNCTION NAME: is_optional_type\n  - SIGNATURE: def is_optional_type(cls: type) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if a given type is optional, meaning it can include None as a valid value. This function utilizes `get_origin` and `get_args` from the `typish` library to inspect the type's characteristics. An optional type is identified as a Union type that includes NoneType.\n\nParameters:\n- cls (type): The type to be checked.\n\nReturns:\n- bool: True if the type is optional; otherwise, False.\n\nDependencies:\n- `typing.Union`: Used to check if the type is a union type.\n- `NoneType`: A helper from `typish` that represents the None type, used to identify optional types.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - typish/functions/_get_args.py:get_args\n    - typish/functions/_get_origin.py:get_origin\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "typish/functions/_is_optional_type.py": "import typing\nfrom typish import get_origin, get_args, NoneType"
  },
  "call_tree": {
    "modified_testcases/functions/test_is_optional_type.py:TestIsOptionalType:test_is_optional_type": {
      "typish/functions/_is_optional_type.py:is_optional_type": {
        "typish/functions/_get_origin.py:get_origin": {
          "typish/functions/_get_simple_name.py:get_simple_name": {},
          "typish/functions/_is_from_typing.py:is_from_typing": {}
        },
        "typish/functions/_get_args.py:get_args": {}
      }
    }
  }
}