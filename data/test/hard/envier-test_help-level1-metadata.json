{
  "dir_path": "/app/envier",
  "package_name": "envier",
  "sample_name": "envier-test_help",
  "src_dir": "envier/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_help.py",
  "test_code": "from envier import Env\nfrom envier import HelpInfo\n\n\nclass GlobalConfig(Env):\n    __prefix__ = \"myapp\"\n\n    debug_mode = Env.var(\n        bool,\n        \"debug\",\n        default=False,\n        help_type=\"Boolean\",\n        help=\"Whether to enable debug logging\",\n    )\n    url = Env.var(\n        str,\n        \"url\",\n        default=\"http://localhost:5000\",\n        help_type=\"String\",\n        help=\"The URL of the application.\",\n    )\n    no_default = Env.var(\n        str,\n        \"no_default\",\n        help_type=\"Boolean\",\n        help=\"A variable with no default value, which makes it mandatory\",\n    )\n\n    class ServiceConfig(Env):\n        __item__ = __prefix__ = \"service\"\n\n        host = Env.var(\n            str,\n            \"host\",\n            default=\"localhost\",\n            help=\"The host of the service.\",\n        )\n        port = Env.var(\n            int,\n            \"port\",\n            default=3000,\n            help=\"The port of the service.\",\n        )\n\n\ndef test_help_info(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info() == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n    ]\n\n\ndef test_help_info_recursive(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info(recursive=True) == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n        HelpInfo(\"MYAPP_SERVICE_HOST\", \"str\", \"localhost\", \"The host of the service.\"),\n        HelpInfo(\"MYAPP_SERVICE_PORT\", \"int\", \"3000\", \"The port of the service.\"),\n    ]\n",
  "GT_file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\n\nclass NoDefaultType(object):\n    def __str__(self):\n        return \"\"\n\n\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\n\n\nT = t.TypeVar(\"T\")\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple(\"HelpInfo\", (\"name\", \"type\", \"default\", \"help\"))\n\n\ndef _normalized(name: str) -> str:\n    return name.upper().replace(\".\", \"_\").rstrip(\"_\")\n\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, \"__origin__\"):\n        return isinstance(value, _type.__args__)  # type: ignore[attr-defined,union-attr]\n\n    return isinstance(value, _type)  # type: ignore[arg-type]\n\n\nclass EnvVariable(t.Generic[T]):\n    def __init__(\n        self,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> None:\n        if hasattr(type, \"__origin__\") and type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            if not isinstance(default, type.__args__):  # type: ignore[attr-defined,union-attr]\n                raise TypeError(\n                    \"default must be either of these types {}\".format(type.__args__)  # type: ignore[attr-defined,union-attr]\n                )\n        elif default is not NoDefault and not isinstance(default, type):  # type: ignore[arg-type]\n            raise TypeError(\"default must be of type {}\".format(type))\n\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n\n        self._full_name = _normalized(name)  # Will be set by the EnvMeta metaclass\n\n    @property\n    def full_name(self) -> str:\n        return f\"_{self._full_name}\" if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: \"Env\") -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(\n                T,\n                _type(  # type: ignore[operator]\n                    collection if self.map is None else map(self.map, collection)  # type: ignore[arg-type]\n                ),\n            )\n        elif _type is dict:\n            d = dict(\n                _.split(env.__value_separator__, 1)\n                for _ in raw.split(env.__item_separator__)\n            )\n            if self.map is not None:\n                d = dict(self.map(*_) for _ in d.items())\n            return t.cast(T, d)\n\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f\"cannot cast {raw} to {self.type}\"\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: \"Env\", prefix: str) -> T:\n        source = env.source\n\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f\"_{full_deprecated_name}\"\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = (\n                        \" in version %s\" % deprecated_when\n                        if deprecated_when is not None\n                        else \"\"\n                    )\n                    removed_when_message = (\n                        \" and will be removed in version %s\" % removed_when\n                        if removed_when is not None\n                        else \"\"\n                    )\n                    warnings.warn(\n                        \"%s has been deprecated%s%s. Use %s instead\"\n                        % (\n                            full_deprecated_name,\n                            deprecated_when_message,\n                            removed_when_message,\n                            full_name,\n                        ),\n                        DeprecationWarning,\n                    )\n                    break\n\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n\n            raise KeyError(\n                \"Mandatory environment variable {} is not set\".format(full_name)\n            )\n\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError(\n                    \"parser returned type {} instead of {}\".format(\n                        type(parsed), self.type\n                    )\n                )\n            return parsed\n\n        if hasattr(self.type, \"__origin__\") and self.type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            for ot in self.type.__args__:  # type: ignore[attr-defined,union-attr]\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: \"Env\", prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f\"Invalid value for environment variable {self.full_name}: {e}\"\n                raise ValueError(msg)\n\n        return value\n\n\nclass DerivedVariable(t.Generic[T]):\n    def __init__(self, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: \"Env\") -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError(\n                \"derivation returned type {} instead of {}\".format(\n                    type(value), self.type\n                )\n            )\n        return value\n\n\nclass EnvMeta(type):\n    def __new__(\n        cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]\n    ) -> t.Any:\n        env = t.cast(\"Env\", super().__new__(cls, name, bases, ns))\n\n        prefix = ns.get(\"__prefix__\")\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f\"{_normalized(prefix)}_{v._full_name}\".upper()\n\n        return env\n\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n\n    __truthy__ = frozenset({\"1\", \"true\", \"yes\", \"on\"})\n    __prefix__ = \"\"\n    __item__: t.Optional[str] = None\n    __item_separator__ = \",\"\n    __value_separator__ = \":\"\n\n    def __init__(\n        self,\n        source: t.Optional[t.Dict[str, str]] = None,\n        parent: t.Optional[\"Env\"] = None,\n        dynamic: t.Optional[t.Dict[str, str]] = None,\n    ) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = (\n            {k.upper(): v.upper() for k, v in dynamic.items()}\n            if dynamic is not None\n            else {}\n        )\n\n        self._full_prefix: str = (\n            parent._full_prefix if parent is not None else \"\"\n        ) + _normalized(self.__prefix__)\n        if self._full_prefix and not self._full_prefix.endswith(\"_\"):\n            self._full_prefix += \"_\"\n\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    # Move the subclass to the __item__ attribute\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def var(\n        cls,\n        type: t.Type[T],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def v(\n        cls,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def der(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type[\"Env\"]]] = deque()\n        path: t.Tuple[str] = tuple()  # type: ignore[assignment]\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield (\n                        \".\".join((*path, k)),\n                        t.cast(t.Union[EnvVariable, DerivedVariable], v),\n                    )\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, \"__item__\", k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))  # type: ignore[arg-type]\n\n    @classmethod\n    def keys(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(\n        cls,\n        env_spec: t.Type[\"Env\"],\n        namespace: t.Optional[str] = None,\n        overwrite: bool = False,\n    ) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        # Pick only the attributes that define variables.\n        to_include = {\n            k: v\n            for k, v in env_spec.__dict__.items()\n            if isinstance(v, (EnvVariable, DerivedVariable))\n            or isinstance(v, type)\n            and issubclass(v, Env)\n        }\n\n        own_prefix = _normalized(getattr(cls, \"__prefix__\", \"\"))\n\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError(\"Namespace already in use: {}\".format(namespace))\n\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n            return None\n\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError(\"Configuration clashes detected: {}\".format(overlap))\n\n        other_prefix = getattr(env_spec, \"__prefix__\", \"\")\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1 :]  # noqa\n                    if own_prefix:\n                        v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n    @classmethod\n    def help_info(\n        cls, recursive: bool = False, include_private: bool = False\n    ) -> t.List[HelpInfo]:\n        \"\"\"Extract the help information from the class.\n\n        Returns a list of all the environment variables declared by the class.\n        The format of each entry is a t.Tuple consisting of the variable name (in\n        double backtics quotes), the type, the default value, and the help text.\n\n        Set ``recursive`` to ``True`` to include variables from nested Env\n        classes.\n\n        Set ``include_private`` to ``True`` to include variables that are\n        marked as private (i.e. their name starts with an underscore).\n        \"\"\"\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted(\n                (_ for _ in config.values() if isinstance(_, EnvVariable)),\n                key=lambda v: v.name,\n            )\n\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n\n                # Add a period at the end if necessary.\n                help_message = v.help.strip() if v.help is not None else \"\"\n                if help_message and not help_message.endswith(\".\"):\n                    help_message += \".\"\n\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__  # type: ignore[attr-defined]\n                    except AttributeError:\n                        # typing.t.Union[<type>, NoneType]\n                        help_type = v.type.__args__[0].__name__  # type: ignore[attr-defined]\n\n                private_prefix = \"_\" if v.private else \"\"\n\n                entries.append(\n                    HelpInfo(\n                        f\"{private_prefix}{full_prefix}{_normalized(v.name)}\",\n                        help_type,  # type: ignore[attr-defined]\n                        (\n                            v.help_default\n                            if v.help_default is not None\n                            else str(v.default)\n                        ),\n                        help_message,\n                    )\n                )\n\n        configs = [(\"\", cls)]\n\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and not new_prefix.endswith(\"_\"):\n                new_prefix += \"_\"\n            add_entries(new_prefix, config)\n\n            if not recursive:\n                break\n\n            subconfigs = sorted(\n                (\n                    (new_prefix, v)\n                    for k, v in config.__dict__.items()\n                    if isinstance(v, type) and issubclass(v, Env) and k != \"parent\"\n                ),\n                key=lambda _: _[1].__prefix__,\n            )\n\n            configs[0:0] = subconfigs  # DFS\n\n        return entries\n"
  },
  "GT_src_dict": {
    "envier/env.py": {
      "EnvMeta.__new__": {
        "code": "    def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n        \"\"\"This method is responsible for creating a new instance of the `Env` class, using its metaclass `EnvMeta`. It overrides the default behavior to modify the fully normalized environment variable names by incorporating a prefix, if specified. The method retrieves the class-level namespace dictionary (`ns`) to check for an `__prefix__`. If found, it iterates through all `EnvVariable` instances in the environment and updates their `_full_name` attribute to include the normalized prefix, transforming the names into uppercase format.\n\nParameters:\n- `name` (str): The name of the new class being created.\n- `bases` (Tuple[t.Type]): A tuple containing the base classes for the class being created.\n- `ns` (Dict[str, t.Any]): A dictionary representing the namespace of the new class, containing attributes defined in the class.\n\nReturns:\n- t.Any: The newly created instance of the `Env` class.\n\nSide Effects:\n- Modifies `_full_name` of `EnvVariable` instances by prefixing their names with a normalized version of the `__prefix__`, if one exists.\n\nConstants:\n- `_normalized`: A utility function defined outside the class, used to standardize the prefix by converting it to uppercase and replacing dots with underscores, ensuring consistent naming for environment variables.\"\"\"\n        env = t.cast('Env', super().__new__(cls, name, bases, ns))\n        prefix = ns.get('__prefix__')\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f'{_normalized(prefix)}_{v._full_name}'.upper()\n        return env",
        "docstring": "This method is responsible for creating a new instance of the `Env` class, using its metaclass `EnvMeta`. It overrides the default behavior to modify the fully normalized environment variable names by incorporating a prefix, if specified. The method retrieves the class-level namespace dictionary (`ns`) to check for an `__prefix__`. If found, it iterates through all `EnvVariable` instances in the environment and updates their `_full_name` attribute to include the normalized prefix, transforming the names into uppercase format.\n\nParameters:\n- `name` (str): The name of the new class being created.\n- `bases` (Tuple[t.Type]): A tuple containing the base classes for the class being created.\n- `ns` (Dict[str, t.Any]): A dictionary representing the namespace of the new class, containing attributes defined in the class.\n\nReturns:\n- t.Any: The newly created instance of the `Env` class.\n\nSide Effects:\n- Modifies `_full_name` of `EnvVariable` instances by prefixing their names with a normalized version of the `__prefix__`, if one exists.\n\nConstants:\n- `_normalized`: A utility function defined outside the class, used to standardize the prefix by converting it to uppercase and replacing dots with underscores, ensuring consistent naming for environment variables.",
        "signature": "def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:",
        "type": "Method",
        "class_signature": "class EnvMeta(type):"
      },
      "Env.var": {
        "code": "    def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        \"\"\"Declare a new environment variable for the `Env` subclass.\n\nThis method creates an instance of `EnvVariable`, which represents an environment variable that can be parsed, validated, and retrieved within the `Env` context. The variable can be configured with various options such as parsing logic, default values, and deprecation information.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable value.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value from the environment into the specified type.\n- validator (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function for modifying the input values, if dealing with collections.\n- default (Union[T, NoDefaultType]): The default value to use if the environment variable is not set. Defaults to `NoDefault`.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): If `True`, the variable is treated as private (prefixing its name with an underscore).\n- help (Optional[str]): An optional help text for the variable.\n- help_type (Optional[str]): An optional description of the variable's type for help documentation.\n- help_default (Optional[str]): An optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` representing the configured environment variable.\n\nThe method helps to manage environment variables efficiently and allows for custom behaviors related to their handling and documentation within the `Env` framework.\"\"\"\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)",
        "docstring": "Declare a new environment variable for the `Env` subclass.\n\nThis method creates an instance of `EnvVariable`, which represents an environment variable that can be parsed, validated, and retrieved within the `Env` context. The variable can be configured with various options such as parsing logic, default values, and deprecation information.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable value.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value from the environment into the specified type.\n- validator (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function for modifying the input values, if dealing with collections.\n- default (Union[T, NoDefaultType]): The default value to use if the environment variable is not set. Defaults to `NoDefault`.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): If `True`, the variable is treated as private (prefixing its name with an underscore).\n- help (Optional[str]): An optional help text for the variable.\n- help_type (Optional[str]): An optional description of the variable's type for help documentation.\n- help_default (Optional[str]): An optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` representing the configured environment variable.\n\nThe method helps to manage environment variables efficiently and allows for custom behaviors related to their handling and documentation within the `Env` framework.",
        "signature": "def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.help_info": {
        "code": "    def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n        \"\"\"Extract and return help information for environment variables declared in the Env class. This method provides a structured list of environment variable metadata, including each variable's name, type, default value, and help text. The help information can include variables from nested Env classes if the `recursive` parameter is set to `True`. Additionally, setting `include_private` to `True` will include variables designated as private (starting with an underscore).\n\nParameters:\n- `cls`: The class itself (in practice, the Env subclass).\n- `recursive` (bool): If `True`, includes environment variables from nested Env classes. Default is `False`.\n- `include_private` (bool): If `True`, includes private environment variables. Default is `False`.\n\nReturns:\n- A list of `HelpInfo` namedtuples, each containing the variable's formatted name, type, default value (or help default if specified), and help message.\n\nDependencies:\n- This method relies on the `EnvVariable` class to define and hold the configuration variables and their help information. \n- The `_normalized` function is used to standardize variable names for formatting purposes. The method traverses the class's attributes to find instances of `EnvVariable` and retrieves their attributes to construct the help information.\"\"\"\n        'Extract the help information from the class.\\n\\n        Returns a list of all the environment variables declared by the class.\\n        The format of each entry is a t.Tuple consisting of the variable name (in\\n        double backtics quotes), the type, the default value, and the help text.\\n\\n        Set ``recursive`` to ``True`` to include variables from nested Env\\n        classes.\\n\\n        Set ``include_private`` to ``True`` to include variables that are\\n        marked as private (i.e. their name starts with an underscore).\\n        '\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted((_ for _ in config.values() if isinstance(_, EnvVariable)), key=lambda v: v.name)\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n                help_message = v.help.strip() if v.help is not None else ''\n                if help_message and (not help_message.endswith('.')):\n                    help_message += '.'\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__\n                    except AttributeError:\n                        help_type = v.type.__args__[0].__name__\n                private_prefix = '_' if v.private else ''\n                entries.append(HelpInfo(f'{private_prefix}{full_prefix}{_normalized(v.name)}', help_type, v.help_default if v.help_default is not None else str(v.default), help_message))\n        configs = [('', cls)]\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and (not new_prefix.endswith('_')):\n                new_prefix += '_'\n            add_entries(new_prefix, config)\n            if not recursive:\n                break\n            subconfigs = sorted(((new_prefix, v) for k, v in config.__dict__.items() if isinstance(v, type) and issubclass(v, Env) and (k != 'parent')), key=lambda _: _[1].__prefix__)\n            configs[0:0] = subconfigs\n        return entries",
        "docstring": "Extract and return help information for environment variables declared in the Env class. This method provides a structured list of environment variable metadata, including each variable's name, type, default value, and help text. The help information can include variables from nested Env classes if the `recursive` parameter is set to `True`. Additionally, setting `include_private` to `True` will include variables designated as private (starting with an underscore).\n\nParameters:\n- `cls`: The class itself (in practice, the Env subclass).\n- `recursive` (bool): If `True`, includes environment variables from nested Env classes. Default is `False`.\n- `include_private` (bool): If `True`, includes private environment variables. Default is `False`.\n\nReturns:\n- A list of `HelpInfo` namedtuples, each containing the variable's formatted name, type, default value (or help default if specified), and help message.\n\nDependencies:\n- This method relies on the `EnvVariable` class to define and hold the configuration variables and their help information. \n- The `_normalized` function is used to standardize variable names for formatting purposes. The method traverses the class's attributes to find instances of `EnvVariable` and retrieves their attributes to construct the help information.",
        "signature": "def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: envier-test_help\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 envier/\n    \u2514\u2500\u2500 env.py\n        \u251c\u2500\u2500 Env.help_info\n        \u251c\u2500\u2500 Env.var\n        \u2514\u2500\u2500 EnvMeta.__new__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a centralized configuration management system designed for applications that rely on environment variables for runtime configuration. It enables developers to define and manage configuration variables with support for default values, type enforcement, and comprehensive metadata such as descriptions and data types. The module also offers an introspection feature that generates structured help documentation, allowing developers or system administrators to quickly understand and validate all required and optional environment variables, including their defaults and purposes. By streamlining the management of configuration values and ensuring their clarity and correctness, the module simplifies the process of deploying and maintaining applications across various environments.\n\n## FILE 1: envier/env.py\n\n- CLASS METHOD: Env.var\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n  - DOCSTRING: \n```python\n\"\"\"\nDeclare a new environment variable for the `Env` subclass.\n\nThis method creates an instance of `EnvVariable`, which represents an environment variable that can be parsed, validated, and retrieved within the `Env` context. The variable can be configured with various options such as parsing logic, default values, and deprecation information.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable value.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value from the environment into the specified type.\n- validator (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (Optional[MapType]): An optional mapping function for modifying the input values, if dealing with collections.\n- default (Union[T, NoDefaultType]): The default value to use if the environment variable is not set. Defaults to `NoDefault`.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of tuples containing deprecation information.\n- private (bool): If `True`, the variable is treated as private (prefixing its name with an underscore).\n- help (Optional[str]): An optional help text for the variable.\n- help_type (Optional[str]): An optional description of the variable's type for help documentation.\n- help_default (Optional[str]): An optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` representing the configured environment variable.\n\nThe method helps to manage environment variables efficiently and allows for custom behaviors related to their handling and documentation within the `Env` framework.\n\"\"\"\n```\n\n- CLASS METHOD: EnvMeta.__new__\n  - CLASS SIGNATURE: class EnvMeta(type):\n  - SIGNATURE: def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n  - DOCSTRING: \n```python\n\"\"\"\nThis method is responsible for creating a new instance of the `Env` class, using its metaclass `EnvMeta`. It overrides the default behavior to modify the fully normalized environment variable names by incorporating a prefix, if specified. The method retrieves the class-level namespace dictionary (`ns`) to check for an `__prefix__`. If found, it iterates through all `EnvVariable` instances in the environment and updates their `_full_name` attribute to include the normalized prefix, transforming the names into uppercase format.\n\nParameters:\n- `name` (str): The name of the new class being created.\n- `bases` (Tuple[t.Type]): A tuple containing the base classes for the class being created.\n- `ns` (Dict[str, t.Any]): A dictionary representing the namespace of the new class, containing attributes defined in the class.\n\nReturns:\n- t.Any: The newly created instance of the `Env` class.\n\nSide Effects:\n- Modifies `_full_name` of `EnvVariable` instances by prefixing their names with a normalized version of the `__prefix__`, if one exists.\n\nConstants:\n- `_normalized`: A utility function defined outside the class, used to standardize the prefix by converting it to uppercase and replacing dots with underscores, ensuring consistent naming for environment variables.\n\"\"\"\n```\n\n- CLASS METHOD: Env.help_info\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n  - DOCSTRING: \n```python\n\"\"\"\nExtract and return help information for environment variables declared in the Env class. This method provides a structured list of environment variable metadata, including each variable's name, type, default value, and help text. The help information can include variables from nested Env classes if the `recursive` parameter is set to `True`. Additionally, setting `include_private` to `True` will include variables designated as private (starting with an underscore).\n\nParameters:\n- `cls`: The class itself (in practice, the Env subclass).\n- `recursive` (bool): If `True`, includes environment variables from nested Env classes. Default is `False`.\n- `include_private` (bool): If `True`, includes private environment variables. Default is `False`.\n\nReturns:\n- A list of `HelpInfo` namedtuples, each containing the variable's formatted name, type, default value (or help default if specified), and help message.\n\nDependencies:\n- This method relies on the `EnvVariable` class to define and hold the configuration variables and their help information. \n- The `_normalized` function is used to standardize variable names for formatting purposes. The method traverses the class's attributes to find instances of `EnvVariable` and retrieves their attributes to construct the help information.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\nclass NoDefaultType(object):\n\n    def __str__(self):\n        return ''\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\nT = t.TypeVar('T')\nK = t.TypeVar('K')\nV = t.TypeVar('V')\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple('HelpInfo', ('name', 'type', 'default', 'help'))\n\ndef _normalized(name: str) -> str:\n    return name.upper().replace('.', '_').rstrip('_')\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, '__origin__'):\n        return isinstance(value, _type.__args__)\n    return isinstance(value, _type)\n\nclass EnvVariable(t.Generic[T]):\n\n    def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n        if hasattr(type, '__origin__') and type.__origin__ is t.Union:\n            if not isinstance(default, type.__args__):\n                raise TypeError('default must be either of these types {}'.format(type.__args__))\n        elif default is not NoDefault and (not isinstance(default, type)):\n            raise TypeError('default must be of type {}'.format(type))\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n        self._full_name = _normalized(name)\n\n    @property\n    def full_name(self) -> str:\n        return f'_{self._full_name}' if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: 'Env') -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(T, _type(collection if self.map is None else map(self.map, collection)))\n        elif _type is dict:\n            d = dict((_.split(env.__value_separator__, 1) for _ in raw.split(env.__item_separator__)))\n            if self.map is not None:\n                d = dict((self.map(*_) for _ in d.items()))\n            return t.cast(T, d)\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f'cannot cast {raw} to {self.type}'\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: 'Env', prefix: str) -> T:\n        source = env.source\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f'_{full_deprecated_name}'\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = ' in version %s' % deprecated_when if deprecated_when is not None else ''\n                    removed_when_message = ' and will be removed in version %s' % removed_when if removed_when is not None else ''\n                    warnings.warn('%s has been deprecated%s%s. Use %s instead' % (full_deprecated_name, deprecated_when_message, removed_when_message, full_name), DeprecationWarning)\n                    break\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n            raise KeyError('Mandatory environment variable {} is not set'.format(full_name))\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError('parser returned type {} instead of {}'.format(type(parsed), self.type))\n            return parsed\n        if hasattr(self.type, '__origin__') and self.type.__origin__ is t.Union:\n            for ot in self.type.__args__:\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: 'Env', prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f'Invalid value for environment variable {self.full_name}: {e}'\n                raise ValueError(msg)\n        return value\n\nclass DerivedVariable(t.Generic[T]):\n\n    def __init__(self, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: 'Env') -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError('derivation returned type {} instead of {}'.format(type(value), self.type))\n        return value\n\nclass EnvMeta(type):\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n    __truthy__ = frozenset({'1', 'true', 'yes', 'on'})\n    __prefix__ = ''\n    __item__: t.Optional[str] = None\n    __item_separator__ = ','\n    __value_separator__ = ':'\n\n    def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = {k.upper(): v.upper() for k, v in dynamic.items()} if dynamic is not None else {}\n        self._full_prefix: str = (parent._full_prefix if parent is not None else '') + _normalized(self.__prefix__)\n        if self._full_prefix and (not self._full_prefix.endswith('_')):\n            self._full_prefix += '_'\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)\n\n    @classmethod\n    def der(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type['Env']]] = deque()\n        path: t.Tuple[str] = tuple()\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield ('.'.join((*path, k)), t.cast(t.Union[EnvVariable, DerivedVariable], v))\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, '__item__', k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))\n\n    @classmethod\n    def keys(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(cls, env_spec: t.Type['Env'], namespace: t.Optional[str]=None, overwrite: bool=False) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        to_include = {k: v for k, v in env_spec.__dict__.items() if isinstance(v, (EnvVariable, DerivedVariable)) or (isinstance(v, type) and issubclass(v, Env))}\n        own_prefix = _normalized(getattr(cls, '__prefix__', ''))\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError('Namespace already in use: {}'.format(namespace))\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f'{own_prefix}_{v._full_name}'\n            return None\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError('Configuration clashes detected: {}'.format(overlap))\n        other_prefix = getattr(env_spec, '__prefix__', '')\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1:]\n                    if own_prefix:\n                        v._full_name = f'{own_prefix}_{v._full_name}'"
  },
  "call_tree": {
    "modified_testcases/test_help.py:ServiceConfig:GlobalConfig": {
      "envier/env.py:Env:var": {
        "envier/env.py:EnvVariable:__init__": {
          "envier/env.py:_normalized": {}
        }
      },
      "modified_testcases/test_help.py:ServiceConfig:ServiceConfig": {
        "envier/env.py:Env:var": {
          "envier/env.py:EnvVariable:__init__": {
            "envier/env.py:_normalized": {}
          }
        }
      },
      "envier/env.py:EnvMeta:__new__": {
        "envier/env.py:Env:values": {
          "envier/env.py:Env:items": {}
        },
        "envier/env.py:_normalized": {}
      }
    },
    "modified_testcases/test_help.py:test_help_info": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:EnvVariable:EnvVariable": {},
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    },
    "modified_testcases/test_help.py:test_help_info_recursive": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    }
  }
}