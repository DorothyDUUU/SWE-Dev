{
  "dir_path": "/app/cassandra_driver",
  "package_name": "cassandra_driver",
  "sample_name": "cassandra_driver-test_columns",
  "src_dir": "cassandra/",
  "test_dir": "tests/",
  "test_file": "tests/unit/cqlengine/test_columns.py",
  "test_code": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n\nfrom cassandra.cqlengine.columns import Column\n\n\nclass ColumnTest(unittest.TestCase):\n\n    def test_comparisons(self):\n        c0 = Column()\n        c1 = Column()\n        self.assertEqual(c1.position - c0.position, 1)\n\n        # __ne__\n        self.assertNotEqual(c0, c1)\n        self.assertNotEqual(c0, object())\n\n        # __eq__\n        self.assertEqual(c0, c0)\n        self.assertFalse(c0 == object())\n\n        # __lt__\n        self.assertLess(c0, c1)\n        try:\n            c0 < object()  # this raises for Python 3\n        except TypeError:\n            pass\n\n        # __le__\n        self.assertLessEqual(c0, c1)\n        self.assertLessEqual(c0, c0)\n        try:\n            c0 <= object()  # this raises for Python 3\n        except TypeError:\n            pass\n\n        # __gt__\n        self.assertGreater(c1, c0)\n        try:\n            c1 > object()  # this raises for Python 3\n        except TypeError:\n            pass\n\n        # __ge__\n        self.assertGreaterEqual(c1, c0)\n        self.assertGreaterEqual(c1, c1)\n        try:\n            c1 >= object()  # this raises for Python 3\n        except TypeError:\n            pass\n\n    def test_hash(self):\n        c0 = Column()\n        self.assertEqual(id(c0), c0.__hash__())\n\n",
  "GT_file_code": {
    "cassandra/cqlengine/columns.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom copy import deepcopy, copy\nfrom datetime import date, datetime, timedelta, timezone\nimport logging\nfrom uuid import UUID as _UUID\n\nfrom cassandra import util\nfrom cassandra.cqltypes import SimpleDateType, _cqltypes, UserType\nfrom cassandra.cqlengine import ValidationError\nfrom cassandra.cqlengine.functions import get_total_seconds\nfrom cassandra.util import Duration as _Duration\n\nlog = logging.getLogger(__name__)\n\n\nclass BaseValueManager(object):\n\n    def __init__(self, instance, column, value):\n        self.instance = instance\n        self.column = column\n        self.value = value\n        self.previous_value = None\n        self.explicit = False\n\n    @property\n    def deleted(self):\n        return self.column._val_is_null(self.value) and (self.explicit or not self.column._val_is_null(self.previous_value))\n\n    @property\n    def changed(self):\n        \"\"\"\n        Indicates whether or not this value has changed.\n\n        :rtype: boolean\n\n        \"\"\"\n        if self.explicit:\n            return self.value != self.previous_value\n\n        if isinstance(self.column, BaseContainerColumn):\n            default_value = self.column.get_default()\n            if self.column._val_is_null(default_value):\n                return not self.column._val_is_null(self.value) and self.value != self.previous_value\n            elif self.previous_value is None:\n                return self.value != default_value\n\n            return self.value != self.previous_value\n\n        return False\n\n    def reset_previous_value(self):\n        self.previous_value = deepcopy(self.value)\n\n    def getval(self):\n        return self.value\n\n    def setval(self, val):\n        self.value = val\n        self.explicit = True\n\n    def delval(self):\n        self.value = None\n\n    def get_property(self):\n        _get = lambda slf: self.getval()\n        _set = lambda slf, val: self.setval(val)\n        _del = lambda slf: self.delval()\n\n        if self.column.can_delete:\n            return property(_get, _set, _del)\n        else:\n            return property(_get, _set)\n\n\nclass Column(object):\n\n    # the cassandra type this column maps to\n    db_type = None\n    value_manager = BaseValueManager\n\n    instance_counter = 0\n\n    _python_type_hashable = True\n\n    primary_key = False\n    \"\"\"\n    bool flag, indicates this column is a primary key. The first primary key defined\n    on a model is the partition key (unless partition keys are set), all others are cluster keys\n    \"\"\"\n\n    partition_key = False\n\n    \"\"\"\n    indicates that this column should be the partition key, defining\n    more than one partition key column creates a compound partition key\n    \"\"\"\n\n    index = False\n    \"\"\"\n    bool flag, indicates an index should be created for this column\n    \"\"\"\n\n    custom_index = False\n    \"\"\"\n    bool flag, indicates an index is managed outside of cqlengine. This is\n    useful if you want to do filter queries on fields that have custom\n    indexes.\n    \"\"\"\n\n    db_field = None\n    \"\"\"\n    the fieldname this field will map to in the database\n    \"\"\"\n\n    default = None\n    \"\"\"\n    the default value, can be a value or a callable (no args)\n    \"\"\"\n\n    required = False\n    \"\"\"\n    boolean, is the field required? Model validation will raise and\n    exception if required is set to True and there is a None value assigned\n    \"\"\"\n\n    clustering_order = None\n    \"\"\"\n    only applicable on clustering keys (primary keys that are not partition keys)\n    determines the order that the clustering keys are sorted on disk\n    \"\"\"\n\n    discriminator_column = False\n    \"\"\"\n    boolean, if set to True, this column will be used for discriminating records\n    of inherited models.\n\n    Should only be set on a column of an abstract model being used for inheritance.\n\n    There may only be one discriminator column per model. See :attr:`~.__discriminator_value__`\n    for how to specify the value of this column on specialized models.\n    \"\"\"\n\n    static = False\n    \"\"\"\n    boolean, if set to True, this is a static column, with a single value per partition\n    \"\"\"\n\n    def __init__(self,\n                 primary_key=False,\n                 partition_key=False,\n                 index=False,\n                 db_field=None,\n                 default=None,\n                 required=False,\n                 clustering_order=None,\n                 discriminator_column=False,\n                 static=False,\n                 custom_index=False):\n        self.partition_key = partition_key\n        self.primary_key = partition_key or primary_key\n        self.index = index\n        self.custom_index = custom_index\n        self.db_field = db_field\n        self.default = default\n        self.required = required\n        self.clustering_order = clustering_order\n        self.discriminator_column = discriminator_column\n\n        # the column name in the model definition\n        self.column_name = None\n        self._partition_key_index = None\n        self.static = static\n\n        self.value = None\n\n        # keep track of instantiation order\n        self.position = Column.instance_counter\n        Column.instance_counter += 1\n\n    def __ne__(self, other):\n        if isinstance(other, Column):\n            return self.position != other.position\n        return NotImplemented\n\n    def __eq__(self, other):\n        if isinstance(other, Column):\n            return self.position == other.position\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Column):\n            return self.position < other.position\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, Column):\n            return self.position <= other.position\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, Column):\n            return self.position > other.position\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, Column):\n            return self.position >= other.position\n        return NotImplemented\n\n    def __hash__(self):\n        return id(self)\n\n    def validate(self, value):\n        \"\"\"\n        Returns a cleaned and validated value. Raises a ValidationError\n        if there's a problem\n        \"\"\"\n        if value is None:\n            if self.required:\n                raise ValidationError('{0} - None values are not allowed'.format(self.column_name or self.db_field))\n        return value\n\n    def to_python(self, value):\n        \"\"\"\n        Converts data from the database into python values\n        raises a ValidationError if the value can't be converted\n        \"\"\"\n        return value\n\n    def to_database(self, value):\n        \"\"\"\n        Converts python value into database value\n        \"\"\"\n        return value\n\n    @property\n    def has_default(self):\n        return self.default is not None\n\n    @property\n    def is_primary_key(self):\n        return self.primary_key\n\n    @property\n    def can_delete(self):\n        return not self.primary_key\n\n    def get_default(self):\n        if self.has_default:\n            if callable(self.default):\n                return self.default()\n            else:\n                return self.default\n\n    def get_column_def(self):\n        \"\"\"\n        Returns a column definition for CQL table definition\n        \"\"\"\n        static = \"static\" if self.static else \"\"\n        return '{0} {1} {2}'.format(self.cql, self.db_type, static)\n\n    # TODO: make columns use cqltypes under the hood\n    # until then, this bridges the gap in using types along with cassandra.metadata for CQL generation\n    def cql_parameterized_type(self):\n        return self.db_type\n\n    def set_column_name(self, name):\n        \"\"\"\n        Sets the column name during document class construction\n        This value will be ignored if db_field is set in __init__\n        \"\"\"\n        self.column_name = name\n\n    @property\n    def db_field_name(self):\n        \"\"\" Returns the name of the cql name of this column \"\"\"\n        return self.db_field if self.db_field is not None else self.column_name\n\n    @property\n    def db_index_name(self):\n        \"\"\" Returns the name of the cql index \"\"\"\n        return 'index_{0}'.format(self.db_field_name)\n\n    @property\n    def has_index(self):\n        return self.index or self.custom_index\n\n    @property\n    def cql(self):\n        return self.get_cql()\n\n    def get_cql(self):\n        return '\"{0}\"'.format(self.db_field_name)\n\n    def _val_is_null(self, val):\n        \"\"\" determines if the given value equates to a null value for the given column type \"\"\"\n        return val is None\n\n    @property\n    def sub_types(self):\n        return []\n\n    @property\n    def cql_type(self):\n        return _cqltypes[self.db_type]\n\n\nclass Blob(Column):\n    \"\"\"\n    Stores a raw binary value\n    \"\"\"\n    db_type = 'blob'\n\n    def to_database(self, value):\n\n        if not isinstance(value, (bytes, bytearray)):\n            raise Exception(\"expecting a binary, got a %s\" % type(value))\n\n        val = super(Bytes, self).to_database(value)\n        return bytearray(val)\n\n\nBytes = Blob\n\n\nclass Inet(Column):\n    \"\"\"\n    Stores an IP address in IPv4 or IPv6 format\n    \"\"\"\n    db_type = 'inet'\n\n\nclass Text(Column):\n    \"\"\"\n    Stores a UTF-8 encoded string\n    \"\"\"\n    db_type = 'text'\n\n    def __init__(self, min_length=None, max_length=None, **kwargs):\n        \"\"\"\n        :param int min_length: Sets the minimum length of this string, for validation purposes.\n            Defaults to 1 if this is a ``required`` column. Otherwise, None.\n        :param int max_length: Sets the maximum length of this string, for validation purposes.\n        \"\"\"\n        self.min_length = (\n            1 if min_length is None and kwargs.get('required', False)\n            else min_length)\n        self.max_length = max_length\n\n        if self.min_length is not None:\n            if self.min_length < 0:\n                raise ValueError(\n                    'Minimum length is not allowed to be negative.')\n\n        if self.max_length is not None:\n            if self.max_length < 0:\n                raise ValueError(\n                    'Maximum length is not allowed to be negative.')\n\n        if self.min_length is not None and self.max_length is not None:\n            if self.max_length < self.min_length:\n                raise ValueError(\n                    'Maximum length must be greater or equal '\n                    'to minimum length.')\n\n        super(Text, self).__init__(**kwargs)\n\n    def validate(self, value):\n        value = super(Text, self).validate(value)\n        if not isinstance(value, (str, bytearray)) and value is not None:\n            raise ValidationError('{0} {1} is not a string'.format(self.column_name, type(value)))\n        if self.max_length is not None:\n            if value and len(value) > self.max_length:\n                raise ValidationError('{0} is longer than {1} characters'.format(self.column_name, self.max_length))\n        if self.min_length:\n            if (self.min_length and not value) or len(value) < self.min_length:\n                raise ValidationError('{0} is shorter than {1} characters'.format(self.column_name, self.min_length))\n        return value\n\n\nclass Ascii(Text):\n    \"\"\"\n    Stores a US-ASCII character string\n    \"\"\"\n    db_type = 'ascii'\n\n    def validate(self, value):\n        \"\"\" Only allow ASCII and None values.\n\n        Check against US-ASCII, a.k.a. 7-bit ASCII, a.k.a. ISO646-US, a.k.a.\n        the Basic Latin block of the Unicode character set.\n\n        Source: https://github.com/apache/cassandra/blob\n        /3dcbe90e02440e6ee534f643c7603d50ca08482b/src/java/org/apache/cassandra\n        /serializers/AsciiSerializer.java#L29\n        \"\"\"\n        value = super(Ascii, self).validate(value)\n        if value:\n            charset = value if isinstance(\n                value, (bytearray, )) else map(ord, value)\n            if not set(range(128)).issuperset(charset):\n                raise ValidationError(\n                    '{!r} is not an ASCII string.'.format(value))\n        return value\n\n\nclass Integer(Column):\n    \"\"\"\n    Stores a 32-bit signed integer value\n    \"\"\"\n\n    db_type = 'int'\n\n    def validate(self, value):\n        val = super(Integer, self).validate(value)\n        if val is None:\n            return\n        try:\n            return int(val)\n        except (TypeError, ValueError):\n            raise ValidationError(\"{0} {1} can't be converted to integral value\".format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\n\nclass TinyInt(Integer):\n    \"\"\"\n    Stores an 8-bit signed integer value\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'tinyint'\n\n\nclass SmallInt(Integer):\n    \"\"\"\n    Stores a 16-bit signed integer value\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'smallint'\n\n\nclass BigInt(Integer):\n    \"\"\"\n    Stores a 64-bit signed integer value\n    \"\"\"\n    db_type = 'bigint'\n\n\nclass VarInt(Column):\n    \"\"\"\n    Stores an arbitrary-precision integer\n    \"\"\"\n    db_type = 'varint'\n\n    def validate(self, value):\n        val = super(VarInt, self).validate(value)\n        if val is None:\n            return\n        try:\n            return int(val)\n        except (TypeError, ValueError):\n            raise ValidationError(\n                \"{0} {1} can't be converted to integral value\".format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\n\nclass CounterValueManager(BaseValueManager):\n    def __init__(self, instance, column, value):\n        super(CounterValueManager, self).__init__(instance, column, value)\n        self.value = self.value or 0\n        self.previous_value = self.previous_value or 0\n\n\nclass Counter(Integer):\n    \"\"\"\n    Stores a counter that can be incremented and decremented\n    \"\"\"\n    db_type = 'counter'\n\n    value_manager = CounterValueManager\n\n    def __init__(self,\n                 index=False,\n                 db_field=None,\n                 required=False):\n        super(Counter, self).__init__(\n            primary_key=False,\n            partition_key=False,\n            index=index,\n            db_field=db_field,\n            default=0,\n            required=required,\n        )\n\n\nclass DateTime(Column):\n    \"\"\"\n    Stores a datetime value\n    \"\"\"\n    db_type = 'timestamp'\n\n    truncate_microseconds = False\n    \"\"\"\n    Set this ``True`` to have model instances truncate the date, quantizing it in the same way it will be in the database.\n    This allows equality comparison between assigned values and values read back from the database::\n\n        DateTime.truncate_microseconds = True\n        assert Model.create(id=0, d=datetime.utcnow()) == Model.objects(id=0).first()\n\n    Defaults to ``False`` to preserve legacy behavior. May change in the future.\n    \"\"\"\n\n    def to_python(self, value):\n        if value is None:\n            return\n        if isinstance(value, datetime):\n            if DateTime.truncate_microseconds:\n                us = value.microsecond\n                truncated_us = us // 1000 * 1000\n                return value - timedelta(microseconds=us - truncated_us)\n            else:\n                return value\n        elif isinstance(value, date):\n            return datetime(*(value.timetuple()[:6]))\n\n        return datetime.fromtimestamp(value, tz=timezone.utc).replace(tzinfo=None)\n\n    def to_database(self, value):\n        value = super(DateTime, self).to_database(value)\n        if value is None:\n            return\n        if not isinstance(value, datetime):\n            if isinstance(value, date):\n                value = datetime(value.year, value.month, value.day)\n            else:\n                raise ValidationError(\"{0} '{1}' is not a datetime object\".format(self.column_name, value))\n        epoch = datetime(1970, 1, 1, tzinfo=value.tzinfo)\n        offset = get_total_seconds(epoch.tzinfo.utcoffset(epoch)) if epoch.tzinfo else 0\n\n        return int((get_total_seconds(value - epoch) - offset) * 1000)\n\n\nclass Date(Column):\n    \"\"\"\n    Stores a simple date, with no time-of-day\n\n    .. versionchanged:: 2.6.0\n\n        removed overload of Date and DateTime. DateTime is a drop-in replacement for legacy models\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'date'\n\n    def to_database(self, value):\n        if value is None:\n            return\n\n        # need to translate to int version because some dates are not representable in\n        # string form (datetime limitation)\n        d = value if isinstance(value, util.Date) else util.Date(value)\n        return d.days_from_epoch + SimpleDateType.EPOCH_OFFSET_DAYS\n\n    def to_python(self, value):\n        if value is None:\n            return\n        if isinstance(value, util.Date):\n            return value\n        if isinstance(value, datetime):\n            value = value.date()\n        return util.Date(value)\n\nclass Time(Column):\n    \"\"\"\n    Stores a timezone-naive time-of-day, with nanosecond precision\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'time'\n\n    def to_database(self, value):\n        value = super(Time, self).to_database(value)\n        if value is None:\n            return\n        # str(util.Time) yields desired CQL encoding\n        return value if isinstance(value, util.Time) else util.Time(value)\n\n    def to_python(self, value):\n        value = super(Time, self).to_database(value)\n        if value is None:\n            return\n        if isinstance(value, util.Time):\n            return value\n        return util.Time(value)\n\nclass Duration(Column):\n    \"\"\"\n    Stores a duration (months, days, nanoseconds)\n\n    .. versionadded:: 3.10.0\n\n    requires C* 3.10+ and protocol v4+\n    \"\"\"\n    db_type = 'duration'\n\n    def validate(self, value):\n        val = super(Duration, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, _Duration):\n            raise TypeError('{0} {1} is not a valid Duration.'.format(self.column_name, value))\n        return val\n\n\nclass UUID(Column):\n    \"\"\"\n    Stores a type 1 or 4 UUID\n    \"\"\"\n    db_type = 'uuid'\n\n    def validate(self, value):\n        val = super(UUID, self).validate(value)\n        if val is None:\n            return\n        if isinstance(val, _UUID):\n            return val\n        if isinstance(val, str):\n            try:\n                return _UUID(val)\n            except ValueError:\n                # fall-through to error\n                pass\n        raise ValidationError(\"{0} {1} is not a valid uuid\".format(\n            self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\n\nclass TimeUUID(UUID):\n    \"\"\"\n    UUID containing timestamp\n    \"\"\"\n\n    db_type = 'timeuuid'\n\n\nclass Boolean(Column):\n    \"\"\"\n    Stores a boolean True or False value\n    \"\"\"\n    db_type = 'boolean'\n\n    def validate(self, value):\n        \"\"\" Always returns a Python boolean. \"\"\"\n        value = super(Boolean, self).validate(value)\n\n        if value is not None:\n            value = bool(value)\n\n        return value\n\n    def to_python(self, value):\n        return self.validate(value)\n\n\nclass BaseFloat(Column):\n    def validate(self, value):\n        value = super(BaseFloat, self).validate(value)\n        if value is None:\n            return\n        try:\n            return float(value)\n        except (TypeError, ValueError):\n            raise ValidationError(\"{0} {1} is not a valid float\".format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\n\nclass Float(BaseFloat):\n    \"\"\"\n    Stores a single-precision floating-point value\n    \"\"\"\n    db_type = 'float'\n\n\nclass Double(BaseFloat):\n    \"\"\"\n    Stores a double-precision floating-point value\n    \"\"\"\n    db_type = 'double'\n\n\nclass Decimal(Column):\n    \"\"\"\n    Stores a variable precision decimal value\n    \"\"\"\n    db_type = 'decimal'\n\n    def validate(self, value):\n        from decimal import Decimal as _Decimal\n        from decimal import InvalidOperation\n        val = super(Decimal, self).validate(value)\n        if val is None:\n            return\n        try:\n            return _Decimal(repr(val)) if isinstance(val, float) else _Decimal(val)\n        except InvalidOperation:\n            raise ValidationError(\"{0} '{1}' can't be coerced to decimal\".format(self.column_name, val))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\n\nclass BaseCollectionColumn(Column):\n    \"\"\"\n    Base Container type for collection-like columns.\n\n    http://cassandra.apache.org/doc/cql3/CQL-3.0.html#collections\n    \"\"\"\n    def __init__(self, types, **kwargs):\n        \"\"\"\n        :param types: a sequence of sub types in this collection\n        \"\"\"\n        instances = []\n        for t in types:\n            inheritance_comparator = issubclass if isinstance(t, type) else isinstance\n            if not inheritance_comparator(t, Column):\n                raise ValidationError(\"%s is not a column class\" % (t,))\n            if t.db_type is None:\n                raise ValidationError(\"%s is an abstract type\" % (t,))\n            inst = t() if isinstance(t, type) else t\n            if isinstance(t, BaseCollectionColumn):\n                inst._freeze_db_type()\n            instances.append(inst)\n\n        self.types = instances\n        super(BaseCollectionColumn, self).__init__(**kwargs)\n\n    def validate(self, value):\n        value = super(BaseCollectionColumn, self).validate(value)\n        # It is dangerous to let collections have more than 65535.\n        # See: https://issues.apache.org/jira/browse/CASSANDRA-5428\n        if value is not None and len(value) > 65535:\n            raise ValidationError(\"{0} Collection can't have more than 65535 elements.\".format(self.column_name))\n        return value\n\n    def _val_is_null(self, val):\n        return not val\n\n    def _freeze_db_type(self):\n        if not self.db_type.startswith('frozen'):\n            self.db_type = \"frozen<%s>\" % (self.db_type,)\n\n    @property\n    def sub_types(self):\n        return self.types\n\n    @property\n    def cql_type(self):\n        return _cqltypes[self.__class__.__name__.lower()].apply_parameters([c.cql_type for c in self.types])\n\n\nclass Tuple(BaseCollectionColumn):\n    \"\"\"\n    Stores a fixed-length set of positional values\n\n    http://docs.datastax.com/en/cql/3.1/cql/cql_reference/tupleType.html\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        :param args: column types representing tuple composition\n        \"\"\"\n        if not args:\n            raise ValueError(\"Tuple must specify at least one inner type\")\n        super(Tuple, self).__init__(args, **kwargs)\n        self.db_type = 'tuple<{0}>'.format(', '.join(typ.db_type for typ in self.types))\n\n    def validate(self, value):\n        val = super(Tuple, self).validate(value)\n        if val is None:\n            return\n        if len(val) > len(self.types):\n            raise ValidationError(\"Value %r has more fields than tuple definition (%s)\" %\n                                  (val, ', '.join(t for t in self.types)))\n        return tuple(t.validate(v) for t, v in zip(self.types, val))\n\n    def to_python(self, value):\n        if value is None:\n            return tuple()\n        return tuple(t.to_python(v) for t, v in zip(self.types, value))\n\n    def to_database(self, value):\n        if value is None:\n            return\n        return tuple(t.to_database(v) for t, v in zip(self.types, value))\n\n\nclass BaseContainerColumn(BaseCollectionColumn):\n    pass\n\n\nclass Set(BaseContainerColumn):\n    \"\"\"\n    Stores a set of unordered, unique values\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_set_t.html\n    \"\"\"\n\n    _python_type_hashable = False\n\n    def __init__(self, value_type, strict=True, default=set, **kwargs):\n        \"\"\"\n        :param value_type: a column class indicating the types of the value\n        :param strict: sets whether non set values will be coerced to set\n            type on validation, or raise a validation error, defaults to True\n        \"\"\"\n        self.strict = strict\n        super(Set, self).__init__((value_type,), default=default, **kwargs)\n        self.value_col = self.types[0]\n        if not self.value_col._python_type_hashable:\n            raise ValidationError(\"Cannot create a Set with unhashable value type (see PYTHON-494)\")\n        self.db_type = 'set<{0}>'.format(self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(Set, self).validate(value)\n        if val is None:\n            return\n        types = (set, util.SortedSet) if self.strict else (set, util.SortedSet, list, tuple)\n        if not isinstance(val, types):\n            if self.strict:\n                raise ValidationError('{0} {1} is not a set object'.format(self.column_name, val))\n            else:\n                raise ValidationError('{0} {1} cannot be coerced to a set object'.format(self.column_name, val))\n\n        if None in val:\n            raise ValidationError(\"{0} None not allowed in a set\".format(self.column_name))\n        # TODO: stop doing this conversion because it doesn't support non-hashable collections as keys (cassandra does)\n        # will need to start using the cassandra.util types in the next major rev (PYTHON-494)\n        return set(self.value_col.validate(v) for v in val)\n\n    def to_python(self, value):\n        if value is None:\n            return set()\n        return set(self.value_col.to_python(v) for v in value)\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return set(self.value_col.to_database(v) for v in value)\n\n\nclass List(BaseContainerColumn):\n    \"\"\"\n    Stores a list of ordered values\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_list_t.html\n    \"\"\"\n\n    _python_type_hashable = False\n\n    def __init__(self, value_type, default=list, **kwargs):\n        \"\"\"\n        :param value_type: a column class indicating the types of the value\n        \"\"\"\n        super(List, self).__init__((value_type,), default=default, **kwargs)\n        self.value_col = self.types[0]\n        self.db_type = 'list<{0}>'.format(self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(List, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, (set, list, tuple)):\n            raise ValidationError('{0} {1} is not a list object'.format(self.column_name, val))\n        if None in val:\n            raise ValidationError(\"{0} None is not allowed in a list\".format(self.column_name))\n        return [self.value_col.validate(v) for v in val]\n\n    def to_python(self, value):\n        if value is None:\n            return []\n        return [self.value_col.to_python(v) for v in value]\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return [self.value_col.to_database(v) for v in value]\n\n\nclass Map(BaseContainerColumn):\n    \"\"\"\n    Stores a key -> value map (dictionary)\n\n    https://docs.datastax.com/en/dse/6.7/cql/cql/cql_using/useMap.html\n    \"\"\"\n\n    _python_type_hashable = False\n\n    def __init__(self, key_type, value_type, default=dict, **kwargs):\n        \"\"\"\n        :param key_type: a column class indicating the types of the key\n        :param value_type: a column class indicating the types of the value\n        \"\"\"\n        super(Map, self).__init__((key_type, value_type), default=default, **kwargs)\n        self.key_col = self.types[0]\n        self.value_col = self.types[1]\n\n        if not self.key_col._python_type_hashable:\n            raise ValidationError(\"Cannot create a Map with unhashable key type (see PYTHON-494)\")\n\n        self.db_type = 'map<{0}, {1}>'.format(self.key_col.db_type, self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(Map, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, (dict, util.OrderedMap)):\n            raise ValidationError('{0} {1} is not a dict object'.format(self.column_name, val))\n        if None in val:\n            raise ValidationError(\"{0} None is not allowed in a map\".format(self.column_name))\n        # TODO: stop doing this conversion because it doesn't support non-hashable collections as keys (cassandra does)\n        # will need to start using the cassandra.util types in the next major rev (PYTHON-494)\n        return dict((self.key_col.validate(k), self.value_col.validate(v)) for k, v in val.items())\n\n    def to_python(self, value):\n        if value is None:\n            return {}\n        if value is not None:\n            return dict((self.key_col.to_python(k), self.value_col.to_python(v)) for k, v in value.items())\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return dict((self.key_col.to_database(k), self.value_col.to_database(v)) for k, v in value.items())\n\n\nclass UDTValueManager(BaseValueManager):\n    @property\n    def changed(self):\n        if self.explicit:\n            return self.value != self.previous_value\n\n        default_value = self.column.get_default()\n        if not self.column._val_is_null(default_value):\n            return self.value != default_value\n        elif self.previous_value is None:\n            return not self.column._val_is_null(self.value) and self.value.has_changed_fields()\n\n        return False\n\n    def reset_previous_value(self):\n        if self.value is not None:\n            self.value.reset_changed_fields()\n        self.previous_value = copy(self.value)\n\n\nclass UserDefinedType(Column):\n    \"\"\"\n    User Defined Type column\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html\n\n    These columns are represented by a specialization of :class:`cassandra.cqlengine.usertype.UserType`.\n\n    Please see :ref:`user_types` for examples and discussion.\n    \"\"\"\n\n    value_manager = UDTValueManager\n\n    def __init__(self, user_type, **kwargs):\n        \"\"\"\n        :param type user_type: specifies the :class:`~.cqlengine.usertype.UserType` model of the column\n        \"\"\"\n        self.user_type = user_type\n        self.db_type = \"frozen<%s>\" % user_type.type_name()\n        super(UserDefinedType, self).__init__(**kwargs)\n\n    @property\n    def sub_types(self):\n        return list(self.user_type._fields.values())\n\n    @property\n    def cql_type(self):\n        return UserType.make_udt_class(keyspace='', udt_name=self.user_type.type_name(),\n                                       field_names=[c.db_field_name for c in self.user_type._fields.values()],\n                                       field_types=[c.cql_type for c in self.user_type._fields.values()])\n\n    def validate(self, value):\n        val = super(UserDefinedType, self).validate(value)\n        if val is None:\n            return\n        val.validate()\n        return val\n\n    def to_python(self, value):\n        if value is None:\n            return\n\n        copied_value = deepcopy(value)\n        for name, field in self.user_type._fields.items():\n            if copied_value[name] is not None or isinstance(field, BaseContainerColumn):\n                copied_value[name] = field.to_python(copied_value[name])\n\n        return copied_value\n\n    def to_database(self, value):\n        if value is None:\n            return\n\n        copied_value = deepcopy(value)\n        for name, field in self.user_type._fields.items():\n            if copied_value[name] is not None or isinstance(field, BaseContainerColumn):\n                copied_value[name] = field.to_database(copied_value[name])\n\n        return copied_value\n\n\ndef resolve_udts(col_def, out_list):\n    for col in col_def.sub_types:\n        resolve_udts(col, out_list)\n    if isinstance(col_def, UserDefinedType):\n        out_list.append(col_def.user_type)\n\n\nclass _PartitionKeysToken(Column):\n    \"\"\"\n    virtual column representing token of partition columns.\n    Used by filter(pk__token=Token(...)) filters\n    \"\"\"\n\n    def __init__(self, model):\n        self.partition_columns = list(model._partition_keys.values())\n        super(_PartitionKeysToken, self).__init__(partition_key=True)\n\n    @property\n    def db_field_name(self):\n        return 'token({0})'.format(', '.join(['\"{0}\"'.format(c.db_field_name) for c in self.partition_columns]))\n",
    "cassandra/__init__.py": "# Copyright DataStax, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport logging\n\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\n\nlogging.getLogger('cassandra').addHandler(NullHandler())\n\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n\n    ANY = 0\n    \"\"\"\n    Only requires that one replica receives the write *or* the coordinator\n    stores a hint to replay later. Valid only for writes.\n    \"\"\"\n\n    ONE = 1\n    \"\"\"\n    Only one replica needs to respond to consider the operation a success\n    \"\"\"\n\n    TWO = 2\n    \"\"\"\n    Two replicas must respond to consider the operation a success\n    \"\"\"\n\n    THREE = 3\n    \"\"\"\n    Three replicas must respond to consider the operation a success\n    \"\"\"\n\n    QUORUM = 4\n    \"\"\"\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\n    \"\"\"\n\n    ALL = 5\n    \"\"\"\n    All replicas must respond to consider the operation a success\n    \"\"\"\n\n    LOCAL_QUORUM = 6\n    \"\"\"\n    Requires a quorum of replicas in the local datacenter\n    \"\"\"\n\n    EACH_QUORUM = 7\n    \"\"\"\n    Requires a quorum of replicas in each datacenter\n    \"\"\"\n\n    SERIAL = 8\n    \"\"\"\n    For conditional inserts/updates that utilize Cassandra's lightweight\n    transactions, this requires consensus among all replicas for the\n    modified data.\n    \"\"\"\n\n    LOCAL_SERIAL = 9\n    \"\"\"\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\n    among replicas in the local datacenter.\n    \"\"\"\n\n    LOCAL_ONE = 10\n    \"\"\"\n    Sends a request only to replicas in the local datacenter and waits for\n    one response.\n    \"\"\"\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\n\n\nConsistencyLevel.value_to_name = {\n    ConsistencyLevel.ANY: 'ANY',\n    ConsistencyLevel.ONE: 'ONE',\n    ConsistencyLevel.TWO: 'TWO',\n    ConsistencyLevel.THREE: 'THREE',\n    ConsistencyLevel.QUORUM: 'QUORUM',\n    ConsistencyLevel.ALL: 'ALL',\n    ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM',\n    ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM',\n    ConsistencyLevel.SERIAL: 'SERIAL',\n    ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL',\n    ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'\n}\n\nConsistencyLevel.name_to_value = {\n    'ANY': ConsistencyLevel.ANY,\n    'ONE': ConsistencyLevel.ONE,\n    'TWO': ConsistencyLevel.TWO,\n    'THREE': ConsistencyLevel.THREE,\n    'QUORUM': ConsistencyLevel.QUORUM,\n    'ALL': ConsistencyLevel.ALL,\n    'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM,\n    'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM,\n    'SERIAL': ConsistencyLevel.SERIAL,\n    'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL,\n    'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE\n}\n\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else \"Not Set\"\n\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    \"\"\"\n    v1, supported in Cassandra 1.2-->2.2\n    \"\"\"\n\n    V2 = 2\n    \"\"\"\n    v2, supported in Cassandra 2.0-->2.2;\n    added support for lightweight transactions, batch operations, and automatic query paging.\n    \"\"\"\n\n    V3 = 3\n    \"\"\"\n    v3, supported in Cassandra 2.1-->3.x+;\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\n    \"\"\"\n\n    V4 = 4\n    \"\"\"\n    v4, supported in Cassandra 2.2-->3.x+;\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\n    \"\"\"\n\n    V5 = 5\n    \"\"\"\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\n    \"\"\"\n\n    V6 = 6\n    \"\"\"\n    v6, in beta from 4.0-beta5\n    \"\"\"\n\n    DSE_V1 = 0x41\n    \"\"\"\n    DSE private protocol v1, supported in DSE 5.1+\n    \"\"\"\n\n    DSE_V2 = 0x42\n    \"\"\"\n    DSE private protocol v2, supported in DSE 6.0+\n    \"\"\"\n\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    \"\"\"\n    A tuple of all supported protocol versions\n    \"\"\"\n\n    BETA_VERSIONS = (V6,)\n    \"\"\"\n    A tuple of all beta protocol versions\n    \"\"\"\n\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    \"\"\"\n    Minimum protocol version supported by this driver.\n    \"\"\"\n\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    \"\"\"\n    Maximum protocol version supported by this driver.\n    \"\"\"\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next(v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if\n                           v not in ProtocolVersion.BETA_VERSIONS and v < previous_version)\n        except StopIteration:\n            version = 0\n\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n\n    SIMPLE = 0\n    \"\"\"\n    A write to a single partition key. Such writes are guaranteed to be atomic\n    and isolated.\n    \"\"\"\n\n    BATCH = 1\n    \"\"\"\n    A write to multiple partition keys that used the distributed batch log to\n    ensure atomicity.\n    \"\"\"\n\n    UNLOGGED_BATCH = 2\n    \"\"\"\n    A write to multiple partition keys that did not use the distributed batch\n    log. Atomicity for such writes is not guaranteed.\n    \"\"\"\n\n    COUNTER = 3\n    \"\"\"\n    A counter write (for one or multiple partition keys). Such writes should\n    not be replayed in order to avoid overcount.\n    \"\"\"\n\n    BATCH_LOG = 4\n    \"\"\"\n    The initial write to the distributed batch log that Cassandra performs\n    internally before a BATCH write.\n    \"\"\"\n\n    CAS = 5\n    \"\"\"\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\n    \"\"\"\n\n    VIEW = 6\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete MV operations.\n    \"\"\"\n\n    CDC = 7\n    \"\"\"\n    This WriteType is only seen in results for requests that were unable to\n    complete CDC operations.\n    \"\"\"\n\n\nWriteType.name_to_value = {\n    'SIMPLE': WriteType.SIMPLE,\n    'BATCH': WriteType.BATCH,\n    'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH,\n    'COUNTER': WriteType.COUNTER,\n    'BATCH_LOG': WriteType.BATCH_LOG,\n    'CAS': WriteType.CAS,\n    'VIEW': WriteType.VIEW,\n    'CDC': WriteType.CDC\n}\n\n\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return \"%s(%s)\" % (name, ','.join(t for t in argument_types))\n\n    def __repr__(self):\n        return \"%s(%s, %s)\" % (self.__class__.__name__, self.name, self.argument_types)\n\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the function\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n\n    name = None\n    \"\"\"\n    name of the aggregate\n    \"\"\"\n\n    argument_types = None\n    \"\"\"\n    Ordered list of CQL argument type names comprising the type signature\n    \"\"\"\n\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_replicas = None\n    \"\"\" The number of replicas that needed to be live to complete the operation \"\"\"\n\n    alive_replicas = None\n    \"\"\" The number of replicas that were actually alive \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' +\n                           repr({'consistency': consistency_value_to_name(consistency),\n                                 'required_replicas': required_replicas,\n                                 'alive_replicas': alive_replicas}))\n\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n\n        if \"write_type\" in kwargs:\n            kwargs[\"write_type\"] = WriteType.value_to_name[kwargs[\"write_type\"]]\n\n        info = {'consistency': consistency_value_to_name(consistency),\n                'required_responses': required_responses,\n                'received_responses': received_responses}\n        info.update(kwargs)\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs[\"write_type\"] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n\n    consistency = None\n    \"\"\" The requested :class:`ConsistencyLevel` \"\"\"\n\n    required_responses = None\n    \"\"\" The number of required replica responses \"\"\"\n\n    received_responses = None\n    \"\"\"\n    The number of replicas that responded before the coordinator timed out\n    the operation\n    \"\"\"\n\n    failures = None\n    \"\"\"\n    The number of replicas that sent a failure message\n    \"\"\"\n\n    error_code_map = None\n    \"\"\"\n    A map of inet addresses to error codes representing replicas that sent\n    a failure message.  Only set when `protocol_version` is 5 or higher.\n    \"\"\"\n\n    def __init__(self, summary_message, consistency=None, required_responses=None,\n                 received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n\n        info_dict = {\n            'consistency': consistency_value_to_name(consistency),\n            'required_responses': required_responses,\n            'received_responses': received_responses,\n            'failures': failures\n        }\n\n        if error_code_map is not None:\n            # make error codes look like \"0x002a\"\n            formatted_map = dict((addr, '0x%04x' % err_code)\n                                 for (addr, err_code) in error_code_map.items())\n            info_dict['error_code_map'] = formatted_map\n\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    data_retrieved = None\n    \"\"\"\n    A boolean indicating whether the requested data was retrieved\n    by the coordinator from any replicas before it timed out the\n    operation\n    \"\"\"\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n\n    write_type = None\n    \"\"\"\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\n    \"\"\"\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    Keyspace of the function\n    \"\"\"\n\n    function = None\n    \"\"\"\n    Name of the function\n    \"\"\"\n\n    arg_types = None\n    \"\"\"\n    List of argument type names of the function\n    \"\"\"\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n\n    keyspace = None\n    \"\"\"\n    The name of the keyspace that already exists, or, if an attempt was\n    made to create a new table, the keyspace that the table is in.\n    \"\"\"\n\n    table = None\n    \"\"\"\n    The name of the table that already exists, or, if an attempt was\n    make to create a keyspace, :const:`None`.\n    \"\"\"\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n\n    errors = None\n    \"\"\"\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\n    \"\"\"\n\n    last_host = None\n    \"\"\"\n    The last :class:`~.Host` this operation was attempted against.\n    \"\"\"\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = \"errors=%s, last_host=%s\" % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n\n    excs = []\n    \"\"\"\n    A sequence of child exceptions\n    \"\"\"\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += (\"\\nThe following exceptions were observed: \\n - \" + '\\n - '.join(str(e) for e in excs))\n        Exception.__init__(self, complete_msg)\n"
  },
  "GT_src_dict": {
    "cassandra/cqlengine/columns.py": {
      "Column.__init__": {
        "code": "    def __init__(self, primary_key=False, partition_key=False, index=False, db_field=None, default=None, required=False, clustering_order=None, discriminator_column=False, static=False, custom_index=False):\n        \"\"\"Initializes a Column instance for use in a Cassandra data model.\n\n Parameters:\n - primary_key (bool): Indicates if this column is a primary key. Defaults to False.\n - partition_key (bool): Indicates if this column serves as a partition key. Defaults to False.\n - index (bool): Indicates whether to create an index for this column. Defaults to False.\n - db_field (str): The name of the field in the database that this column maps to. Defaults to None.\n - default: Default value for the column, can be a static value or a callable. Defaults to None.\n - required (bool): Indicates if the column is required (cannot be None). Defaults to False.\n - clustering_order: Defines the order of clustering keys when applicable. Defaults to None.\n - discriminator_column (bool): If True, this column is used for distinguishing records in inherited models. Defaults to False.\n - static (bool): Indicates if this column is a static column, with a single value per partition. Defaults to False.\n - custom_index (bool): Indicates that an index is managed outside of cqlengine. Defaults to False.\n\n Side effects:\n The constructor increments a class-level counter (Column.instance_counter) to keep track of the order of column instantiations, which assigns a unique position value to each column instance.\n\n Attributes initialized:\n - self.partition_key: Set to the value of partition_key parameter.\n - self.primary_key: Set based on partition_key or primary_key parameter.\n - self.index, self.custom_index, self.db_field, self.default, self.required,\n   self.clustering_order, self.discriminator_column: Set based on corresponding parameters.\n - self.column_name, self._partition_key_index: Initialized to None.\n - self.static: Set to the value of the static parameter.\n - self.value: Initialized to None.\n - self.position: Incremental index representing the instantiation order of the column.\n\n Dependencies:\n Relies on class-level variable `Column.instance_counter` to assign a unique position to each instance for distinguishing within the model definition.\"\"\"\n        self.partition_key = partition_key\n        self.primary_key = partition_key or primary_key\n        self.index = index\n        self.custom_index = custom_index\n        self.db_field = db_field\n        self.default = default\n        self.required = required\n        self.clustering_order = clustering_order\n        self.discriminator_column = discriminator_column\n        self.column_name = None\n        self._partition_key_index = None\n        self.static = static\n        self.value = None\n        self.position = Column.instance_counter\n        Column.instance_counter += 1",
        "docstring": "Initializes a Column instance for use in a Cassandra data model.\n\nParameters:\n- primary_key (bool): Indicates if this column is a primary key. Defaults to False.\n- partition_key (bool): Indicates if this column serves as a partition key. Defaults to False.\n- index (bool): Indicates whether to create an index for this column. Defaults to False.\n- db_field (str): The name of the field in the database that this column maps to. Defaults to None.\n- default: Default value for the column, can be a static value or a callable. Defaults to None.\n- required (bool): Indicates if the column is required (cannot be None). Defaults to False.\n- clustering_order: Defines the order of clustering keys when applicable. Defaults to None.\n- discriminator_column (bool): If True, this column is used for distinguishing records in inherited models. Defaults to False.\n- static (bool): Indicates if this column is a static column, with a single value per partition. Defaults to False.\n- custom_index (bool): Indicates that an index is managed outside of cqlengine. Defaults to False.\n\nSide effects:\nThe constructor increments a class-level counter (Column.instance_counter) to keep track of the order of column instantiations, which assigns a unique position value to each column instance.\n\nAttributes initialized:\n- self.partition_key: Set to the value of partition_key parameter.\n- self.primary_key: Set based on partition_key or primary_key parameter.\n- self.index, self.custom_index, self.db_field, self.default, self.required,\n  self.clustering_order, self.discriminator_column: Set based on corresponding parameters.\n- self.column_name, self._partition_key_index: Initialized to None.\n- self.static: Set to the value of the static parameter.\n- self.value: Initialized to None.\n- self.position: Incremental index representing the instantiation order of the column.\n\nDependencies:\nRelies on class-level variable `Column.instance_counter` to assign a unique position to each instance for distinguishing within the model definition.",
        "signature": "def __init__(self, primary_key=False, partition_key=False, index=False, db_field=None, default=None, required=False, clustering_order=None, discriminator_column=False, static=False, custom_index=False):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__ne__": {
        "code": "    def __ne__(self, other):\n        \"\"\"Indicates whether this Column instance is not equal to another Column instance based on their instantiation order.\n\nParameters:\n- other (Column): Another instance of Column to compare against.\n\nReturns:\n- boolean: True if the current Column's position is not equal to the other Column's position, otherwise False. If `other` is not an instance of Column, NotImplemented is returned.\n\nThis method relies on the `position` attribute, which tracks the order in which Column instances are created within the class. Each Column instance has a unique `position`, which increments upon each instantiation, ensuring that no two Column instances, regardless of their type or properties, have the same position unless they were created in the same order.\"\"\"\n        if isinstance(other, Column):\n            return self.position != other.position\n        return NotImplemented",
        "docstring": "Indicates whether this Column instance is not equal to another Column instance based on their instantiation order.\n\nParameters:\n- other (Column): Another instance of Column to compare against.\n\nReturns:\n- boolean: True if the current Column's position is not equal to the other Column's position, otherwise False. If `other` is not an instance of Column, NotImplemented is returned.\n\nThis method relies on the `position` attribute, which tracks the order in which Column instances are created within the class. Each Column instance has a unique `position`, which increments upon each instantiation, ensuring that no two Column instances, regardless of their type or properties, have the same position unless they were created in the same order.",
        "signature": "def __ne__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two Column instances based on their instantiation order.\n\nParameters:\n    other (Column): Another Column instance to compare with.\n\nReturns:\n    bool: True if the other instance is a Column and their positions are equal, False otherwise.\n\nNotes:\n    The position attribute is defined in the Column class and represents the order in which instances of Column are created. This allows for a sequential comparison between instances. If `other` is not an instance of Column, the method returns NotImplemented, signaling that the operation is not supported for the given type.\"\"\"\n        if isinstance(other, Column):\n            return self.position == other.position\n        return NotImplemented",
        "docstring": "Checks for equality between two Column instances based on their instantiation order.\n\nParameters:\n    other (Column): Another Column instance to compare with.\n\nReturns:\n    bool: True if the other instance is a Column and their positions are equal, False otherwise.\n\nNotes:\n    The position attribute is defined in the Column class and represents the order in which instances of Column are created. This allows for a sequential comparison between instances. If `other` is not an instance of Column, the method returns NotImplemented, signaling that the operation is not supported for the given type.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__lt__": {
        "code": "    def __lt__(self, other):\n        \"\"\"Compares the current Column instance with another Column instance to determine their order based on their position in the instantiation sequence.\n\nParameters:\n- other (Column): The Column instance to compare against.\n\nReturns:\n- bool: True if the current Column's position is less than the other's position, otherwise False. If the other object is not a Column instance, returns NotImplemented, which allows Python to attempt the reverse operation.\n\nThe 'position' attribute is an integer that tracks the order of instantiation for Column instances, ensuring a consistent ordering mechanism within collections of column definitions.\"\"\"\n        if isinstance(other, Column):\n            return self.position < other.position\n        return NotImplemented",
        "docstring": "Compares the current Column instance with another Column instance to determine their order based on their position in the instantiation sequence.\n\nParameters:\n- other (Column): The Column instance to compare against.\n\nReturns:\n- bool: True if the current Column's position is less than the other's position, otherwise False. If the other object is not a Column instance, returns NotImplemented, which allows Python to attempt the reverse operation.\n\nThe 'position' attribute is an integer that tracks the order of instantiation for Column instances, ensuring a consistent ordering mechanism within collections of column definitions.",
        "signature": "def __lt__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__le__": {
        "code": "    def __le__(self, other):\n        \"\"\"Compares the position of this Column instance with another Column instance.\n\nParameters:\n- other (Column): The other Column instance to compare against.\n\nReturns:\n- bool: True if this Column's position is less than or equal to the other Column's position, otherwise False.\n\nThe position attribute is assigned during the initialization of the Column instance, starting from zero and incrementing for each additional instance. This method is useful for ordering or organizing Column instances based on their defined order in a model.\"\"\"\n        if isinstance(other, Column):\n            return self.position <= other.position\n        return NotImplemented",
        "docstring": "Compares the position of this Column instance with another Column instance.\n\nParameters:\n- other (Column): The other Column instance to compare against.\n\nReturns:\n- bool: True if this Column's position is less than or equal to the other Column's position, otherwise False.\n\nThe position attribute is assigned during the initialization of the Column instance, starting from zero and incrementing for each additional instance. This method is useful for ordering or organizing Column instances based on their defined order in a model.",
        "signature": "def __le__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__gt__": {
        "code": "    def __gt__(self, other):\n        \"\"\"Compares the position of this Column instance with another Column instance.\n\n    :param other: The Column instance to compare against.\n    :type other: Column\n    :return: True if this Column instance's position is greater than the other instance's position; otherwise, False.\n    :rtype: bool\n\n    This method utilizes the `position` attribute, which is an integer representing the order in which the Column instances are instantiated.\n    It is significant for maintaining a consistent ordering of column definitions, especially within a model that may have multiple columns.\"\"\"\n        if isinstance(other, Column):\n            return self.position > other.position\n        return NotImplemented",
        "docstring": "Compares the position of this Column instance with another Column instance.\n\n:param other: The Column instance to compare against.\n:type other: Column\n:return: True if this Column instance's position is greater than the other instance's position; otherwise, False.\n:rtype: bool\n\nThis method utilizes the `position` attribute, which is an integer representing the order in which the Column instances are instantiated.\nIt is significant for maintaining a consistent ordering of column definitions, especially within a model that may have multiple columns.",
        "signature": "def __gt__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__ge__": {
        "code": "    def __ge__(self, other):\n        \"\"\"Compares the position of two `Column` instances for greater-than-or-equal-to ordering.\n\nParameters:\n- `other`: Another instance of `Column` to compare against.\n\nReturns:\n- `bool`: Returns `True` if the `position` of the current column is greater than or equal to that of `other`, otherwise `False`.\n\nThis method utilizes the `position` attribute of the `Column` class, which is automatically assigned during initialization to maintain the instantiation order of columns. This allows for a natural ordering of columns based on their declaration in the model.\"\"\"\n        if isinstance(other, Column):\n            return self.position >= other.position\n        return NotImplemented",
        "docstring": "Compares the position of two `Column` instances for greater-than-or-equal-to ordering.\n\nParameters:\n- `other`: Another instance of `Column` to compare against.\n\nReturns:\n- `bool`: Returns `True` if the `position` of the current column is greater than or equal to that of `other`, otherwise `False`.\n\nThis method utilizes the `position` attribute of the `Column` class, which is automatically assigned during initialization to maintain the instantiation order of columns. This allows for a natural ordering of columns based on their declaration in the model.",
        "signature": "def __ge__(self, other):",
        "type": "Method",
        "class_signature": "class Column(object):"
      },
      "Column.__hash__": {
        "code": "    def __hash__(self):\n        \"\"\"Returns the hash value of the Column instance using its unique object identifier.\n\nThis method overrides the default behavior of `__hash__` in Python, allowing instances of the Column class to be used as keys in hash tables or sets. The hash value is generated using the built-in `id()` function, which provides a unique identifier for the object in memory.\n\nReturns:\n    int: The hash value of the Column instance.\n\nThis method does not take any parameters and has no side effects. It leverages the built-in Python `id()` function, ensuring consistency of hash values for Column objects throughout their lifespan.\"\"\"\n        return id(self)",
        "docstring": "Returns the hash value of the Column instance using its unique object identifier.\n\nThis method overrides the default behavior of `__hash__` in Python, allowing instances of the Column class to be used as keys in hash tables or sets. The hash value is generated using the built-in `id()` function, which provides a unique identifier for the object in memory.\n\nReturns:\n    int: The hash value of the Column instance.\n\nThis method does not take any parameters and has no side effects. It leverages the built-in Python `id()` function, ensuring consistency of hash values for Column objects throughout their lifespan.",
        "signature": "def __hash__(self):",
        "type": "Method",
        "class_signature": "class Column(object):"
      }
    },
    "cassandra/__init__.py": {}
  },
  "dependency_dict": {
    "cassandra/cqlengine/columns.py:Column:__ne__": {},
    "cassandra/cqlengine/columns.py:Column:Column": {},
    "cassandra/cqlengine/columns.py:Column:__eq__": {},
    "cassandra/cqlengine/columns.py:Column:__lt__": {},
    "cassandra/cqlengine/columns.py:Column:__le__": {},
    "cassandra/cqlengine/columns.py:Column:__gt__": {},
    "cassandra/cqlengine/columns.py:Column:__ge__": {}
  },
  "PRD": "# PROJECT NAME: cassandra_driver-test_columns\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 cassandra/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 InvalidRequest.InvalidRequest\n    \u2502   \u2514\u2500\u2500 OperationTimedOut.OperationTimedOut\n    \u2514\u2500\u2500 cqlengine/\n        \u2514\u2500\u2500 columns.py\n            \u251c\u2500\u2500 Column.Column\n            \u251c\u2500\u2500 Column.__eq__\n            \u251c\u2500\u2500 Column.__ge__\n            \u251c\u2500\u2500 Column.__gt__\n            \u251c\u2500\u2500 Column.__hash__\n            \u251c\u2500\u2500 Column.__init__\n            \u251c\u2500\u2500 Column.__le__\n            \u251c\u2500\u2500 Column.__lt__\n            \u251c\u2500\u2500 Column.__ne__\n            \u2514\u2500\u2500 UUID.UUID\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and ensure the correctness of the behavior of the `Column` class within the Cassandra CQL Engine. It provides functionality to test critical aspects of `Column` instances, such as comparison operations (e.g., equality, ordering, and inequality) and the integrity of their hash implementation. By offering automated testing capabilities, the module helps developers confirm that the `Column` class adheres to defined behaviors and supports consistent, reliable functionality within the Cassandra object mapping framework. This ensures stability and predictability in how `Column` objects are utilized, solving potential issues with incorrect behavior during comparisons or object hashing.\n\n## FILE 1: cassandra/cqlengine/columns.py\n\n- CLASS METHOD: Column.__le__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __le__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares the position of this Column instance with another Column instance.\n\nParameters:\n- other (Column): The other Column instance to compare against.\n\nReturns:\n- bool: True if this Column's position is less than or equal to the other Column's position, otherwise False.\n\nThe position attribute is assigned during the initialization of the Column instance, starting from zero and incrementing for each additional instance. This method is useful for ordering or organizing Column instances based on their defined order in a model.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__lt__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __lt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares the current Column instance with another Column instance to determine their order based on their position in the instantiation sequence.\n\nParameters:\n- other (Column): The Column instance to compare against.\n\nReturns:\n- bool: True if the current Column's position is less than the other's position, otherwise False. If the other object is not a Column instance, returns NotImplemented, which allows Python to attempt the reverse operation.\n\nThe 'position' attribute is an integer that tracks the order of instantiation for Column instances, ensuring a consistent ordering mechanism within collections of column definitions.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__ne__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __ne__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nIndicates whether this Column instance is not equal to another Column instance based on their instantiation order.\n\nParameters:\n- other (Column): Another instance of Column to compare against.\n\nReturns:\n- boolean: True if the current Column's position is not equal to the other Column's position, otherwise False. If `other` is not an instance of Column, NotImplemented is returned.\n\nThis method relies on the `position` attribute, which tracks the order in which Column instances are created within the class. Each Column instance has a unique `position`, which increments upon each instantiation, ensuring that no two Column instances, regardless of their type or properties, have the same position unless they were created in the same order.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__gt__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __gt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares the position of this Column instance with another Column instance.\n\n:param other: The Column instance to compare against.\n:type other: Column\n:return: True if this Column instance's position is greater than the other instance's position; otherwise, False.\n:rtype: bool\n\nThis method utilizes the `position` attribute, which is an integer representing the order in which the Column instances are instantiated.\nIt is significant for maintaining a consistent ordering of column definitions, especially within a model that may have multiple columns.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__init__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __init__(self, primary_key=False, partition_key=False, index=False, db_field=None, default=None, required=False, clustering_order=None, discriminator_column=False, static=False, custom_index=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Column instance for use in a Cassandra data model.\n\nParameters:\n- primary_key (bool): Indicates if this column is a primary key. Defaults to False.\n- partition_key (bool): Indicates if this column serves as a partition key. Defaults to False.\n- index (bool): Indicates whether to create an index for this column. Defaults to False.\n- db_field (str): The name of the field in the database that this column maps to. Defaults to None.\n- default: Default value for the column, can be a static value or a callable. Defaults to None.\n- required (bool): Indicates if the column is required (cannot be None). Defaults to False.\n- clustering_order: Defines the order of clustering keys when applicable. Defaults to None.\n- discriminator_column (bool): If True, this column is used for distinguishing records in inherited models. Defaults to False.\n- static (bool): Indicates if this column is a static column, with a single value per partition. Defaults to False.\n- custom_index (bool): Indicates that an index is managed outside of cqlengine. Defaults to False.\n\nSide effects:\nThe constructor increments a class-level counter (Column.instance_counter) to keep track of the order of column instantiations, which assigns a unique position value to each column instance.\n\nAttributes initialized:\n- self.partition_key: Set to the value of partition_key parameter.\n- self.primary_key: Set based on partition_key or primary_key parameter.\n- self.index, self.custom_index, self.db_field, self.default, self.required,\n  self.clustering_order, self.discriminator_column: Set based on corresponding parameters.\n- self.column_name, self._partition_key_index: Initialized to None.\n- self.static: Set to the value of the static parameter.\n- self.value: Initialized to None.\n- self.position: Incremental index representing the instantiation order of the column.\n\nDependencies:\nRelies on class-level variable `Column.instance_counter` to assign a unique position to each instance for distinguishing within the model definition.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__ge__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __ge__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares the position of two `Column` instances for greater-than-or-equal-to ordering.\n\nParameters:\n- `other`: Another instance of `Column` to compare against.\n\nReturns:\n- `bool`: Returns `True` if the `position` of the current column is greater than or equal to that of `other`, otherwise `False`.\n\nThis method utilizes the `position` attribute of the `Column` class, which is automatically assigned during initialization to maintain the instantiation order of columns. This allows for a natural ordering of columns based on their declaration in the model.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__hash__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __hash__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the hash value of the Column instance using its unique object identifier.\n\nThis method overrides the default behavior of `__hash__` in Python, allowing instances of the Column class to be used as keys in hash tables or sets. The hash value is generated using the built-in `id()` function, which provides a unique identifier for the object in memory.\n\nReturns:\n    int: The hash value of the Column instance.\n\nThis method does not take any parameters and has no side effects. It leverages the built-in Python `id()` function, ensuring consistency of hash values for Column objects throughout their lifespan.\n\"\"\"\n```\n\n- CLASS METHOD: Column.__eq__\n  - CLASS SIGNATURE: class Column(object):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two Column instances based on their instantiation order.\n\nParameters:\n    other (Column): Another Column instance to compare with.\n\nReturns:\n    bool: True if the other instance is a Column and their positions are equal, False otherwise.\n\nNotes:\n    The position attribute is defined in the Column class and represents the order in which instances of Column are created. This allows for a sequential comparison between instances. If `other` is not an instance of Column, the method returns NotImplemented, signaling that the operation is not supported for the given type.\n\"\"\"\n```\n\n## FILE 2: cassandra/__init__.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "cassandra/cqlengine/columns.py": "from copy import deepcopy, copy\nfrom datetime import date, datetime, timedelta, timezone\nimport logging\nfrom uuid import UUID as _UUID\nfrom cassandra import util\nfrom cassandra.cqltypes import SimpleDateType, _cqltypes, UserType\nfrom cassandra.cqlengine import ValidationError\nfrom cassandra.cqlengine.functions import get_total_seconds\nfrom cassandra.util import Duration as _Duration\nlog = logging.getLogger(__name__)\n\nclass BaseValueManager(object):\n\n    def __init__(self, instance, column, value):\n        self.instance = instance\n        self.column = column\n        self.value = value\n        self.previous_value = None\n        self.explicit = False\n\n    @property\n    def deleted(self):\n        return self.column._val_is_null(self.value) and (self.explicit or not self.column._val_is_null(self.previous_value))\n\n    @property\n    def changed(self):\n        \"\"\"\n        Indicates whether or not this value has changed.\n\n        :rtype: boolean\n\n        \"\"\"\n        if self.explicit:\n            return self.value != self.previous_value\n        if isinstance(self.column, BaseContainerColumn):\n            default_value = self.column.get_default()\n            if self.column._val_is_null(default_value):\n                return not self.column._val_is_null(self.value) and self.value != self.previous_value\n            elif self.previous_value is None:\n                return self.value != default_value\n            return self.value != self.previous_value\n        return False\n\n    def reset_previous_value(self):\n        self.previous_value = deepcopy(self.value)\n\n    def getval(self):\n        return self.value\n\n    def setval(self, val):\n        self.value = val\n        self.explicit = True\n\n    def delval(self):\n        self.value = None\n\n    def get_property(self):\n        _get = lambda slf: self.getval()\n        _set = lambda slf, val: self.setval(val)\n        _del = lambda slf: self.delval()\n        if self.column.can_delete:\n            return property(_get, _set, _del)\n        else:\n            return property(_get, _set)\n\nclass Column(object):\n    db_type = None\n    value_manager = BaseValueManager\n    instance_counter = 0\n    _python_type_hashable = True\n    primary_key = False\n    '\\n    bool flag, indicates this column is a primary key. The first primary key defined\\n    on a model is the partition key (unless partition keys are set), all others are cluster keys\\n    '\n    partition_key = False\n    '\\n    indicates that this column should be the partition key, defining\\n    more than one partition key column creates a compound partition key\\n    '\n    index = False\n    '\\n    bool flag, indicates an index should be created for this column\\n    '\n    custom_index = False\n    '\\n    bool flag, indicates an index is managed outside of cqlengine. This is\\n    useful if you want to do filter queries on fields that have custom\\n    indexes.\\n    '\n    db_field = None\n    '\\n    the fieldname this field will map to in the database\\n    '\n    default = None\n    '\\n    the default value, can be a value or a callable (no args)\\n    '\n    required = False\n    '\\n    boolean, is the field required? Model validation will raise and\\n    exception if required is set to True and there is a None value assigned\\n    '\n    clustering_order = None\n    '\\n    only applicable on clustering keys (primary keys that are not partition keys)\\n    determines the order that the clustering keys are sorted on disk\\n    '\n    discriminator_column = False\n    '\\n    boolean, if set to True, this column will be used for discriminating records\\n    of inherited models.\\n\\n    Should only be set on a column of an abstract model being used for inheritance.\\n\\n    There may only be one discriminator column per model. See :attr:`~.__discriminator_value__`\\n    for how to specify the value of this column on specialized models.\\n    '\n    static = False\n    '\\n    boolean, if set to True, this is a static column, with a single value per partition\\n    '\n\n    def validate(self, value):\n        \"\"\"\n        Returns a cleaned and validated value. Raises a ValidationError\n        if there's a problem\n        \"\"\"\n        if value is None:\n            if self.required:\n                raise ValidationError('{0} - None values are not allowed'.format(self.column_name or self.db_field))\n        return value\n\n    def to_python(self, value):\n        \"\"\"\n        Converts data from the database into python values\n        raises a ValidationError if the value can't be converted\n        \"\"\"\n        return value\n\n    def to_database(self, value):\n        \"\"\"\n        Converts python value into database value\n        \"\"\"\n        return value\n\n    @property\n    def has_default(self):\n        return self.default is not None\n\n    @property\n    def is_primary_key(self):\n        return self.primary_key\n\n    @property\n    def can_delete(self):\n        return not self.primary_key\n\n    def get_default(self):\n        if self.has_default:\n            if callable(self.default):\n                return self.default()\n            else:\n                return self.default\n\n    def get_column_def(self):\n        \"\"\"\n        Returns a column definition for CQL table definition\n        \"\"\"\n        static = 'static' if self.static else ''\n        return '{0} {1} {2}'.format(self.cql, self.db_type, static)\n\n    def cql_parameterized_type(self):\n        return self.db_type\n\n    def set_column_name(self, name):\n        \"\"\"\n        Sets the column name during document class construction\n        This value will be ignored if db_field is set in __init__\n        \"\"\"\n        self.column_name = name\n\n    @property\n    def db_field_name(self):\n        \"\"\" Returns the name of the cql name of this column \"\"\"\n        return self.db_field if self.db_field is not None else self.column_name\n\n    @property\n    def db_index_name(self):\n        \"\"\" Returns the name of the cql index \"\"\"\n        return 'index_{0}'.format(self.db_field_name)\n\n    @property\n    def has_index(self):\n        return self.index or self.custom_index\n\n    @property\n    def cql(self):\n        return self.get_cql()\n\n    def get_cql(self):\n        return '\"{0}\"'.format(self.db_field_name)\n\n    def _val_is_null(self, val):\n        \"\"\" determines if the given value equates to a null value for the given column type \"\"\"\n        return val is None\n\n    @property\n    def sub_types(self):\n        return []\n\n    @property\n    def cql_type(self):\n        return _cqltypes[self.db_type]\n\nclass Blob(Column):\n    \"\"\"\n    Stores a raw binary value\n    \"\"\"\n    db_type = 'blob'\n\n    def to_database(self, value):\n        if not isinstance(value, (bytes, bytearray)):\n            raise Exception('expecting a binary, got a %s' % type(value))\n        val = super(Bytes, self).to_database(value)\n        return bytearray(val)\nBytes = Blob\n\nclass Inet(Column):\n    \"\"\"\n    Stores an IP address in IPv4 or IPv6 format\n    \"\"\"\n    db_type = 'inet'\n\nclass Text(Column):\n    \"\"\"\n    Stores a UTF-8 encoded string\n    \"\"\"\n    db_type = 'text'\n\n    def __init__(self, min_length=None, max_length=None, **kwargs):\n        \"\"\"\n        :param int min_length: Sets the minimum length of this string, for validation purposes.\n            Defaults to 1 if this is a ``required`` column. Otherwise, None.\n        :param int max_length: Sets the maximum length of this string, for validation purposes.\n        \"\"\"\n        self.min_length = 1 if min_length is None and kwargs.get('required', False) else min_length\n        self.max_length = max_length\n        if self.min_length is not None:\n            if self.min_length < 0:\n                raise ValueError('Minimum length is not allowed to be negative.')\n        if self.max_length is not None:\n            if self.max_length < 0:\n                raise ValueError('Maximum length is not allowed to be negative.')\n        if self.min_length is not None and self.max_length is not None:\n            if self.max_length < self.min_length:\n                raise ValueError('Maximum length must be greater or equal to minimum length.')\n        super(Text, self).__init__(**kwargs)\n\n    def validate(self, value):\n        value = super(Text, self).validate(value)\n        if not isinstance(value, (str, bytearray)) and value is not None:\n            raise ValidationError('{0} {1} is not a string'.format(self.column_name, type(value)))\n        if self.max_length is not None:\n            if value and len(value) > self.max_length:\n                raise ValidationError('{0} is longer than {1} characters'.format(self.column_name, self.max_length))\n        if self.min_length:\n            if self.min_length and (not value) or len(value) < self.min_length:\n                raise ValidationError('{0} is shorter than {1} characters'.format(self.column_name, self.min_length))\n        return value\n\nclass Ascii(Text):\n    \"\"\"\n    Stores a US-ASCII character string\n    \"\"\"\n    db_type = 'ascii'\n\n    def validate(self, value):\n        \"\"\" Only allow ASCII and None values.\n\n        Check against US-ASCII, a.k.a. 7-bit ASCII, a.k.a. ISO646-US, a.k.a.\n        the Basic Latin block of the Unicode character set.\n\n        Source: https://github.com/apache/cassandra/blob\n        /3dcbe90e02440e6ee534f643c7603d50ca08482b/src/java/org/apache/cassandra\n        /serializers/AsciiSerializer.java#L29\n        \"\"\"\n        value = super(Ascii, self).validate(value)\n        if value:\n            charset = value if isinstance(value, (bytearray,)) else map(ord, value)\n            if not set(range(128)).issuperset(charset):\n                raise ValidationError('{!r} is not an ASCII string.'.format(value))\n        return value\n\nclass Integer(Column):\n    \"\"\"\n    Stores a 32-bit signed integer value\n    \"\"\"\n    db_type = 'int'\n\n    def validate(self, value):\n        val = super(Integer, self).validate(value)\n        if val is None:\n            return\n        try:\n            return int(val)\n        except (TypeError, ValueError):\n            raise ValidationError(\"{0} {1} can't be converted to integral value\".format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\nclass TinyInt(Integer):\n    \"\"\"\n    Stores an 8-bit signed integer value\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'tinyint'\n\nclass SmallInt(Integer):\n    \"\"\"\n    Stores a 16-bit signed integer value\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'smallint'\n\nclass BigInt(Integer):\n    \"\"\"\n    Stores a 64-bit signed integer value\n    \"\"\"\n    db_type = 'bigint'\n\nclass VarInt(Column):\n    \"\"\"\n    Stores an arbitrary-precision integer\n    \"\"\"\n    db_type = 'varint'\n\n    def validate(self, value):\n        val = super(VarInt, self).validate(value)\n        if val is None:\n            return\n        try:\n            return int(val)\n        except (TypeError, ValueError):\n            raise ValidationError(\"{0} {1} can't be converted to integral value\".format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\nclass CounterValueManager(BaseValueManager):\n\n    def __init__(self, instance, column, value):\n        super(CounterValueManager, self).__init__(instance, column, value)\n        self.value = self.value or 0\n        self.previous_value = self.previous_value or 0\n\nclass Counter(Integer):\n    \"\"\"\n    Stores a counter that can be incremented and decremented\n    \"\"\"\n    db_type = 'counter'\n    value_manager = CounterValueManager\n\n    def __init__(self, index=False, db_field=None, required=False):\n        super(Counter, self).__init__(primary_key=False, partition_key=False, index=index, db_field=db_field, default=0, required=required)\n\nclass DateTime(Column):\n    \"\"\"\n    Stores a datetime value\n    \"\"\"\n    db_type = 'timestamp'\n    truncate_microseconds = False\n    '\\n    Set this ``True`` to have model instances truncate the date, quantizing it in the same way it will be in the database.\\n    This allows equality comparison between assigned values and values read back from the database::\\n\\n        DateTime.truncate_microseconds = True\\n        assert Model.create(id=0, d=datetime.utcnow()) == Model.objects(id=0).first()\\n\\n    Defaults to ``False`` to preserve legacy behavior. May change in the future.\\n    '\n\n    def to_python(self, value):\n        if value is None:\n            return\n        if isinstance(value, datetime):\n            if DateTime.truncate_microseconds:\n                us = value.microsecond\n                truncated_us = us // 1000 * 1000\n                return value - timedelta(microseconds=us - truncated_us)\n            else:\n                return value\n        elif isinstance(value, date):\n            return datetime(*value.timetuple()[:6])\n        return datetime.fromtimestamp(value, tz=timezone.utc).replace(tzinfo=None)\n\n    def to_database(self, value):\n        value = super(DateTime, self).to_database(value)\n        if value is None:\n            return\n        if not isinstance(value, datetime):\n            if isinstance(value, date):\n                value = datetime(value.year, value.month, value.day)\n            else:\n                raise ValidationError(\"{0} '{1}' is not a datetime object\".format(self.column_name, value))\n        epoch = datetime(1970, 1, 1, tzinfo=value.tzinfo)\n        offset = get_total_seconds(epoch.tzinfo.utcoffset(epoch)) if epoch.tzinfo else 0\n        return int((get_total_seconds(value - epoch) - offset) * 1000)\n\nclass Date(Column):\n    \"\"\"\n    Stores a simple date, with no time-of-day\n\n    .. versionchanged:: 2.6.0\n\n        removed overload of Date and DateTime. DateTime is a drop-in replacement for legacy models\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'date'\n\n    def to_database(self, value):\n        if value is None:\n            return\n        d = value if isinstance(value, util.Date) else util.Date(value)\n        return d.days_from_epoch + SimpleDateType.EPOCH_OFFSET_DAYS\n\n    def to_python(self, value):\n        if value is None:\n            return\n        if isinstance(value, util.Date):\n            return value\n        if isinstance(value, datetime):\n            value = value.date()\n        return util.Date(value)\n\nclass Time(Column):\n    \"\"\"\n    Stores a timezone-naive time-of-day, with nanosecond precision\n\n    .. versionadded:: 2.6.0\n\n    requires C* 2.2+ and protocol v4+\n    \"\"\"\n    db_type = 'time'\n\n    def to_database(self, value):\n        value = super(Time, self).to_database(value)\n        if value is None:\n            return\n        return value if isinstance(value, util.Time) else util.Time(value)\n\n    def to_python(self, value):\n        value = super(Time, self).to_database(value)\n        if value is None:\n            return\n        if isinstance(value, util.Time):\n            return value\n        return util.Time(value)\n\nclass Duration(Column):\n    \"\"\"\n    Stores a duration (months, days, nanoseconds)\n\n    .. versionadded:: 3.10.0\n\n    requires C* 3.10+ and protocol v4+\n    \"\"\"\n    db_type = 'duration'\n\n    def validate(self, value):\n        val = super(Duration, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, _Duration):\n            raise TypeError('{0} {1} is not a valid Duration.'.format(self.column_name, value))\n        return val\n\nclass UUID(Column):\n    \"\"\"\n    Stores a type 1 or 4 UUID\n    \"\"\"\n    db_type = 'uuid'\n\n    def validate(self, value):\n        val = super(UUID, self).validate(value)\n        if val is None:\n            return\n        if isinstance(val, _UUID):\n            return val\n        if isinstance(val, str):\n            try:\n                return _UUID(val)\n            except ValueError:\n                pass\n        raise ValidationError('{0} {1} is not a valid uuid'.format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\nclass TimeUUID(UUID):\n    \"\"\"\n    UUID containing timestamp\n    \"\"\"\n    db_type = 'timeuuid'\n\nclass Boolean(Column):\n    \"\"\"\n    Stores a boolean True or False value\n    \"\"\"\n    db_type = 'boolean'\n\n    def validate(self, value):\n        \"\"\" Always returns a Python boolean. \"\"\"\n        value = super(Boolean, self).validate(value)\n        if value is not None:\n            value = bool(value)\n        return value\n\n    def to_python(self, value):\n        return self.validate(value)\n\nclass BaseFloat(Column):\n\n    def validate(self, value):\n        value = super(BaseFloat, self).validate(value)\n        if value is None:\n            return\n        try:\n            return float(value)\n        except (TypeError, ValueError):\n            raise ValidationError('{0} {1} is not a valid float'.format(self.column_name, value))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\nclass Float(BaseFloat):\n    \"\"\"\n    Stores a single-precision floating-point value\n    \"\"\"\n    db_type = 'float'\n\nclass Double(BaseFloat):\n    \"\"\"\n    Stores a double-precision floating-point value\n    \"\"\"\n    db_type = 'double'\n\nclass Decimal(Column):\n    \"\"\"\n    Stores a variable precision decimal value\n    \"\"\"\n    db_type = 'decimal'\n\n    def validate(self, value):\n        from decimal import Decimal as _Decimal\n        from decimal import InvalidOperation\n        val = super(Decimal, self).validate(value)\n        if val is None:\n            return\n        try:\n            return _Decimal(repr(val)) if isinstance(val, float) else _Decimal(val)\n        except InvalidOperation:\n            raise ValidationError(\"{0} '{1}' can't be coerced to decimal\".format(self.column_name, val))\n\n    def to_python(self, value):\n        return self.validate(value)\n\n    def to_database(self, value):\n        return self.validate(value)\n\nclass BaseCollectionColumn(Column):\n    \"\"\"\n    Base Container type for collection-like columns.\n\n    http://cassandra.apache.org/doc/cql3/CQL-3.0.html#collections\n    \"\"\"\n\n    def __init__(self, types, **kwargs):\n        \"\"\"\n        :param types: a sequence of sub types in this collection\n        \"\"\"\n        instances = []\n        for t in types:\n            inheritance_comparator = issubclass if isinstance(t, type) else isinstance\n            if not inheritance_comparator(t, Column):\n                raise ValidationError('%s is not a column class' % (t,))\n            if t.db_type is None:\n                raise ValidationError('%s is an abstract type' % (t,))\n            inst = t() if isinstance(t, type) else t\n            if isinstance(t, BaseCollectionColumn):\n                inst._freeze_db_type()\n            instances.append(inst)\n        self.types = instances\n        super(BaseCollectionColumn, self).__init__(**kwargs)\n\n    def validate(self, value):\n        value = super(BaseCollectionColumn, self).validate(value)\n        if value is not None and len(value) > 65535:\n            raise ValidationError(\"{0} Collection can't have more than 65535 elements.\".format(self.column_name))\n        return value\n\n    def _val_is_null(self, val):\n        return not val\n\n    def _freeze_db_type(self):\n        if not self.db_type.startswith('frozen'):\n            self.db_type = 'frozen<%s>' % (self.db_type,)\n\n    @property\n    def sub_types(self):\n        return self.types\n\n    @property\n    def cql_type(self):\n        return _cqltypes[self.__class__.__name__.lower()].apply_parameters([c.cql_type for c in self.types])\n\nclass Tuple(BaseCollectionColumn):\n    \"\"\"\n    Stores a fixed-length set of positional values\n\n    http://docs.datastax.com/en/cql/3.1/cql/cql_reference/tupleType.html\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        :param args: column types representing tuple composition\n        \"\"\"\n        if not args:\n            raise ValueError('Tuple must specify at least one inner type')\n        super(Tuple, self).__init__(args, **kwargs)\n        self.db_type = 'tuple<{0}>'.format(', '.join((typ.db_type for typ in self.types)))\n\n    def validate(self, value):\n        val = super(Tuple, self).validate(value)\n        if val is None:\n            return\n        if len(val) > len(self.types):\n            raise ValidationError('Value %r has more fields than tuple definition (%s)' % (val, ', '.join((t for t in self.types))))\n        return tuple((t.validate(v) for t, v in zip(self.types, val)))\n\n    def to_python(self, value):\n        if value is None:\n            return tuple()\n        return tuple((t.to_python(v) for t, v in zip(self.types, value)))\n\n    def to_database(self, value):\n        if value is None:\n            return\n        return tuple((t.to_database(v) for t, v in zip(self.types, value)))\n\nclass BaseContainerColumn(BaseCollectionColumn):\n    pass\n\nclass Set(BaseContainerColumn):\n    \"\"\"\n    Stores a set of unordered, unique values\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_set_t.html\n    \"\"\"\n    _python_type_hashable = False\n\n    def __init__(self, value_type, strict=True, default=set, **kwargs):\n        \"\"\"\n        :param value_type: a column class indicating the types of the value\n        :param strict: sets whether non set values will be coerced to set\n            type on validation, or raise a validation error, defaults to True\n        \"\"\"\n        self.strict = strict\n        super(Set, self).__init__((value_type,), default=default, **kwargs)\n        self.value_col = self.types[0]\n        if not self.value_col._python_type_hashable:\n            raise ValidationError('Cannot create a Set with unhashable value type (see PYTHON-494)')\n        self.db_type = 'set<{0}>'.format(self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(Set, self).validate(value)\n        if val is None:\n            return\n        types = (set, util.SortedSet) if self.strict else (set, util.SortedSet, list, tuple)\n        if not isinstance(val, types):\n            if self.strict:\n                raise ValidationError('{0} {1} is not a set object'.format(self.column_name, val))\n            else:\n                raise ValidationError('{0} {1} cannot be coerced to a set object'.format(self.column_name, val))\n        if None in val:\n            raise ValidationError('{0} None not allowed in a set'.format(self.column_name))\n        return set((self.value_col.validate(v) for v in val))\n\n    def to_python(self, value):\n        if value is None:\n            return set()\n        return set((self.value_col.to_python(v) for v in value))\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return set((self.value_col.to_database(v) for v in value))\n\nclass List(BaseContainerColumn):\n    \"\"\"\n    Stores a list of ordered values\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_list_t.html\n    \"\"\"\n    _python_type_hashable = False\n\n    def __init__(self, value_type, default=list, **kwargs):\n        \"\"\"\n        :param value_type: a column class indicating the types of the value\n        \"\"\"\n        super(List, self).__init__((value_type,), default=default, **kwargs)\n        self.value_col = self.types[0]\n        self.db_type = 'list<{0}>'.format(self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(List, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, (set, list, tuple)):\n            raise ValidationError('{0} {1} is not a list object'.format(self.column_name, val))\n        if None in val:\n            raise ValidationError('{0} None is not allowed in a list'.format(self.column_name))\n        return [self.value_col.validate(v) for v in val]\n\n    def to_python(self, value):\n        if value is None:\n            return []\n        return [self.value_col.to_python(v) for v in value]\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return [self.value_col.to_database(v) for v in value]\n\nclass Map(BaseContainerColumn):\n    \"\"\"\n    Stores a key -> value map (dictionary)\n\n    https://docs.datastax.com/en/dse/6.7/cql/cql/cql_using/useMap.html\n    \"\"\"\n    _python_type_hashable = False\n\n    def __init__(self, key_type, value_type, default=dict, **kwargs):\n        \"\"\"\n        :param key_type: a column class indicating the types of the key\n        :param value_type: a column class indicating the types of the value\n        \"\"\"\n        super(Map, self).__init__((key_type, value_type), default=default, **kwargs)\n        self.key_col = self.types[0]\n        self.value_col = self.types[1]\n        if not self.key_col._python_type_hashable:\n            raise ValidationError('Cannot create a Map with unhashable key type (see PYTHON-494)')\n        self.db_type = 'map<{0}, {1}>'.format(self.key_col.db_type, self.value_col.db_type)\n\n    def validate(self, value):\n        val = super(Map, self).validate(value)\n        if val is None:\n            return\n        if not isinstance(val, (dict, util.OrderedMap)):\n            raise ValidationError('{0} {1} is not a dict object'.format(self.column_name, val))\n        if None in val:\n            raise ValidationError('{0} None is not allowed in a map'.format(self.column_name))\n        return dict(((self.key_col.validate(k), self.value_col.validate(v)) for k, v in val.items()))\n\n    def to_python(self, value):\n        if value is None:\n            return {}\n        if value is not None:\n            return dict(((self.key_col.to_python(k), self.value_col.to_python(v)) for k, v in value.items()))\n\n    def to_database(self, value):\n        if value is None:\n            return None\n        return dict(((self.key_col.to_database(k), self.value_col.to_database(v)) for k, v in value.items()))\n\nclass UDTValueManager(BaseValueManager):\n\n    @property\n    def changed(self):\n        if self.explicit:\n            return self.value != self.previous_value\n        default_value = self.column.get_default()\n        if not self.column._val_is_null(default_value):\n            return self.value != default_value\n        elif self.previous_value is None:\n            return not self.column._val_is_null(self.value) and self.value.has_changed_fields()\n        return False\n\n    def reset_previous_value(self):\n        if self.value is not None:\n            self.value.reset_changed_fields()\n        self.previous_value = copy(self.value)\n\nclass UserDefinedType(Column):\n    \"\"\"\n    User Defined Type column\n\n    http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html\n\n    These columns are represented by a specialization of :class:`cassandra.cqlengine.usertype.UserType`.\n\n    Please see :ref:`user_types` for examples and discussion.\n    \"\"\"\n    value_manager = UDTValueManager\n\n    def __init__(self, user_type, **kwargs):\n        \"\"\"\n        :param type user_type: specifies the :class:`~.cqlengine.usertype.UserType` model of the column\n        \"\"\"\n        self.user_type = user_type\n        self.db_type = 'frozen<%s>' % user_type.type_name()\n        super(UserDefinedType, self).__init__(**kwargs)\n\n    @property\n    def sub_types(self):\n        return list(self.user_type._fields.values())\n\n    @property\n    def cql_type(self):\n        return UserType.make_udt_class(keyspace='', udt_name=self.user_type.type_name(), field_names=[c.db_field_name for c in self.user_type._fields.values()], field_types=[c.cql_type for c in self.user_type._fields.values()])\n\n    def validate(self, value):\n        val = super(UserDefinedType, self).validate(value)\n        if val is None:\n            return\n        val.validate()\n        return val\n\n    def to_python(self, value):\n        if value is None:\n            return\n        copied_value = deepcopy(value)\n        for name, field in self.user_type._fields.items():\n            if copied_value[name] is not None or isinstance(field, BaseContainerColumn):\n                copied_value[name] = field.to_python(copied_value[name])\n        return copied_value\n\n    def to_database(self, value):\n        if value is None:\n            return\n        copied_value = deepcopy(value)\n        for name, field in self.user_type._fields.items():\n            if copied_value[name] is not None or isinstance(field, BaseContainerColumn):\n                copied_value[name] = field.to_database(copied_value[name])\n        return copied_value\n\ndef resolve_udts(col_def, out_list):\n    for col in col_def.sub_types:\n        resolve_udts(col, out_list)\n    if isinstance(col_def, UserDefinedType):\n        out_list.append(col_def.user_type)\n\nclass _PartitionKeysToken(Column):\n    \"\"\"\n    virtual column representing token of partition columns.\n    Used by filter(pk__token=Token(...)) filters\n    \"\"\"\n\n    def __init__(self, model):\n        self.partition_columns = list(model._partition_keys.values())\n        super(_PartitionKeysToken, self).__init__(partition_key=True)\n\n    @property\n    def db_field_name(self):\n        return 'token({0})'.format(', '.join(['\"{0}\"'.format(c.db_field_name) for c in self.partition_columns]))",
    "cassandra/__init__.py": "import logging\n\nclass NullHandler(logging.Handler):\n\n    def emit(self, record):\n        pass\nlogging.getLogger('cassandra').addHandler(NullHandler())\n__version_info__ = (3, 29, 2)\n__version__ = '.'.join(map(str, __version_info__))\n\nclass ConsistencyLevel(object):\n    \"\"\"\n    Spcifies how many replicas must respond for an operation to be considered\n    a success.  By default, ``ONE`` is used for all operations.\n    \"\"\"\n    ANY = 0\n    '\\n    Only requires that one replica receives the write *or* the coordinator\\n    stores a hint to replay later. Valid only for writes.\\n    '\n    ONE = 1\n    '\\n    Only one replica needs to respond to consider the operation a success\\n    '\n    TWO = 2\n    '\\n    Two replicas must respond to consider the operation a success\\n    '\n    THREE = 3\n    '\\n    Three replicas must respond to consider the operation a success\\n    '\n    QUORUM = 4\n    '\\n    ``ceil(RF/2) + 1`` replicas must respond to consider the operation a success\\n    '\n    ALL = 5\n    '\\n    All replicas must respond to consider the operation a success\\n    '\n    LOCAL_QUORUM = 6\n    '\\n    Requires a quorum of replicas in the local datacenter\\n    '\n    EACH_QUORUM = 7\n    '\\n    Requires a quorum of replicas in each datacenter\\n    '\n    SERIAL = 8\n    \"\\n    For conditional inserts/updates that utilize Cassandra's lightweight\\n    transactions, this requires consensus among all replicas for the\\n    modified data.\\n    \"\n    LOCAL_SERIAL = 9\n    '\\n    Like :attr:`~ConsistencyLevel.SERIAL`, but only requires consensus\\n    among replicas in the local datacenter.\\n    '\n    LOCAL_ONE = 10\n    '\\n    Sends a request only to replicas in the local datacenter and waits for\\n    one response.\\n    '\n\n    @staticmethod\n    def is_serial(cl):\n        return cl == ConsistencyLevel.SERIAL or cl == ConsistencyLevel.LOCAL_SERIAL\nConsistencyLevel.value_to_name = {ConsistencyLevel.ANY: 'ANY', ConsistencyLevel.ONE: 'ONE', ConsistencyLevel.TWO: 'TWO', ConsistencyLevel.THREE: 'THREE', ConsistencyLevel.QUORUM: 'QUORUM', ConsistencyLevel.ALL: 'ALL', ConsistencyLevel.LOCAL_QUORUM: 'LOCAL_QUORUM', ConsistencyLevel.EACH_QUORUM: 'EACH_QUORUM', ConsistencyLevel.SERIAL: 'SERIAL', ConsistencyLevel.LOCAL_SERIAL: 'LOCAL_SERIAL', ConsistencyLevel.LOCAL_ONE: 'LOCAL_ONE'}\nConsistencyLevel.name_to_value = {'ANY': ConsistencyLevel.ANY, 'ONE': ConsistencyLevel.ONE, 'TWO': ConsistencyLevel.TWO, 'THREE': ConsistencyLevel.THREE, 'QUORUM': ConsistencyLevel.QUORUM, 'ALL': ConsistencyLevel.ALL, 'LOCAL_QUORUM': ConsistencyLevel.LOCAL_QUORUM, 'EACH_QUORUM': ConsistencyLevel.EACH_QUORUM, 'SERIAL': ConsistencyLevel.SERIAL, 'LOCAL_SERIAL': ConsistencyLevel.LOCAL_SERIAL, 'LOCAL_ONE': ConsistencyLevel.LOCAL_ONE}\n\ndef consistency_value_to_name(value):\n    return ConsistencyLevel.value_to_name[value] if value is not None else 'Not Set'\n\nclass ProtocolVersion(object):\n    \"\"\"\n    Defines native protocol versions supported by this driver.\n    \"\"\"\n    V1 = 1\n    '\\n    v1, supported in Cassandra 1.2-->2.2\\n    '\n    V2 = 2\n    '\\n    v2, supported in Cassandra 2.0-->2.2;\\n    added support for lightweight transactions, batch operations, and automatic query paging.\\n    '\n    V3 = 3\n    '\\n    v3, supported in Cassandra 2.1-->3.x+;\\n    added support for protocol-level client-side timestamps (see :attr:`.Session.use_client_timestamp`),\\n    serial consistency levels for :class:`~.BatchStatement`, and an improved connection pool.\\n    '\n    V4 = 4\n    '\\n    v4, supported in Cassandra 2.2-->3.x+;\\n    added a number of new types, server warnings, new failure messages, and custom payloads. Details in the\\n    `project docs <https://github.com/apache/cassandra/blob/trunk/doc/native_protocol_v4.spec>`_\\n    '\n    V5 = 5\n    '\\n    v5, in beta from 3.x+. Finalised in 4.0-beta5\\n    '\n    V6 = 6\n    '\\n    v6, in beta from 4.0-beta5\\n    '\n    DSE_V1 = 65\n    '\\n    DSE private protocol v1, supported in DSE 5.1+\\n    '\n    DSE_V2 = 66\n    '\\n    DSE private protocol v2, supported in DSE 6.0+\\n    '\n    SUPPORTED_VERSIONS = (DSE_V2, DSE_V1, V6, V5, V4, V3, V2, V1)\n    '\\n    A tuple of all supported protocol versions\\n    '\n    BETA_VERSIONS = (V6,)\n    '\\n    A tuple of all beta protocol versions\\n    '\n    MIN_SUPPORTED = min(SUPPORTED_VERSIONS)\n    '\\n    Minimum protocol version supported by this driver.\\n    '\n    MAX_SUPPORTED = max(SUPPORTED_VERSIONS)\n    '\\n    Maximum protocol version supported by this driver.\\n    '\n\n    @classmethod\n    def get_lower_supported(cls, previous_version):\n        \"\"\"\n        Return the lower supported protocol version. Beta versions are omitted.\n        \"\"\"\n        try:\n            version = next((v for v in sorted(ProtocolVersion.SUPPORTED_VERSIONS, reverse=True) if v not in ProtocolVersion.BETA_VERSIONS and v < previous_version))\n        except StopIteration:\n            version = 0\n        return version\n\n    @classmethod\n    def uses_int_query_flags(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_prepare_flags(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_prepared_metadata(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def uses_error_code_map(cls, version):\n        return version >= cls.V5\n\n    @classmethod\n    def uses_keyspace_flag(cls, version):\n        return version >= cls.V5 and version != cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_support(cls, version):\n        return version >= cls.DSE_V1\n\n    @classmethod\n    def has_continuous_paging_next_pages(cls, version):\n        return version >= cls.DSE_V2\n\n    @classmethod\n    def has_checksumming_support(cls, version):\n        return cls.V5 <= version < cls.DSE_V1\n\nclass WriteType(object):\n    \"\"\"\n    For usage with :class:`.RetryPolicy`, this describe a type\n    of write operation.\n    \"\"\"\n    SIMPLE = 0\n    '\\n    A write to a single partition key. Such writes are guaranteed to be atomic\\n    and isolated.\\n    '\n    BATCH = 1\n    '\\n    A write to multiple partition keys that used the distributed batch log to\\n    ensure atomicity.\\n    '\n    UNLOGGED_BATCH = 2\n    '\\n    A write to multiple partition keys that did not use the distributed batch\\n    log. Atomicity for such writes is not guaranteed.\\n    '\n    COUNTER = 3\n    '\\n    A counter write (for one or multiple partition keys). Such writes should\\n    not be replayed in order to avoid overcount.\\n    '\n    BATCH_LOG = 4\n    '\\n    The initial write to the distributed batch log that Cassandra performs\\n    internally before a BATCH write.\\n    '\n    CAS = 5\n    '\\n    A lighweight-transaction write, such as \"DELETE ... IF EXISTS\".\\n    '\n    VIEW = 6\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete MV operations.\\n    '\n    CDC = 7\n    '\\n    This WriteType is only seen in results for requests that were unable to\\n    complete CDC operations.\\n    '\nWriteType.name_to_value = {'SIMPLE': WriteType.SIMPLE, 'BATCH': WriteType.BATCH, 'UNLOGGED_BATCH': WriteType.UNLOGGED_BATCH, 'COUNTER': WriteType.COUNTER, 'BATCH_LOG': WriteType.BATCH_LOG, 'CAS': WriteType.CAS, 'VIEW': WriteType.VIEW, 'CDC': WriteType.CDC}\nWriteType.value_to_name = {v: k for k, v in WriteType.name_to_value.items()}\n\nclass SchemaChangeType(object):\n    DROPPED = 'DROPPED'\n    CREATED = 'CREATED'\n    UPDATED = 'UPDATED'\n\nclass SchemaTargetType(object):\n    KEYSPACE = 'KEYSPACE'\n    TABLE = 'TABLE'\n    TYPE = 'TYPE'\n    FUNCTION = 'FUNCTION'\n    AGGREGATE = 'AGGREGATE'\n\nclass SignatureDescriptor(object):\n\n    def __init__(self, name, argument_types):\n        self.name = name\n        self.argument_types = argument_types\n\n    @property\n    def signature(self):\n        \"\"\"\n        function signature string in the form 'name([type0[,type1[...]]])'\n\n        can be used to uniquely identify overloaded function names within a keyspace\n        \"\"\"\n        return self.format_signature(self.name, self.argument_types)\n\n    @staticmethod\n    def format_signature(name, argument_types):\n        return '%s(%s)' % (name, ','.join((t for t in argument_types)))\n\n    def __repr__(self):\n        return '%s(%s, %s)' % (self.__class__.__name__, self.name, self.argument_types)\n\nclass UserFunctionDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the function\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass UserAggregateDescriptor(SignatureDescriptor):\n    \"\"\"\n    Describes a User aggregate function by name and argument signature\n    \"\"\"\n    name = None\n    '\\n    name of the aggregate\\n    '\n    argument_types = None\n    '\\n    Ordered list of CQL argument type names comprising the type signature\\n    '\n\nclass DriverException(Exception):\n    \"\"\"\n    Base for all exceptions explicitly raised by the driver.\n    \"\"\"\n    pass\n\nclass RequestExecutionException(DriverException):\n    \"\"\"\n    Base for request execution exceptions returned from the server.\n    \"\"\"\n    pass\n\nclass Unavailable(RequestExecutionException):\n    \"\"\"\n    There were not enough live replicas to satisfy the requested consistency\n    level, so the coordinator node immediately failed the request without\n    forwarding it to any replicas.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_replicas = None\n    ' The number of replicas that needed to be live to complete the operation '\n    alive_replicas = None\n    ' The number of replicas that were actually alive '\n\n    def __init__(self, summary_message, consistency=None, required_replicas=None, alive_replicas=None):\n        self.consistency = consistency\n        self.required_replicas = required_replicas\n        self.alive_replicas = alive_replicas\n        Exception.__init__(self, summary_message + ' info=' + repr({'consistency': consistency_value_to_name(consistency), 'required_replicas': required_replicas, 'alive_replicas': alive_replicas}))\n\nclass Timeout(RequestExecutionException):\n    \"\"\"\n    Replicas failed to respond to the coordinator node before timing out.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, **kwargs):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        if 'write_type' in kwargs:\n            kwargs['write_type'] = WriteType.value_to_name[kwargs['write_type']]\n        info = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses}\n        info.update(kwargs)\n        Exception.__init__(self, summary_message + ' info=' + repr(info))\n\nclass ReadTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for read operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``read_request_timeout_in_ms``\n    and ``range_request_timeout_in_ms`` options.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        Timeout.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteTimeout(Timeout):\n    \"\"\"\n    A subclass of :exc:`Timeout` for write operations.\n\n    This indicates that the replicas failed to respond to the coordinator\n    node before the configured timeout. This timeout is configured in\n    ``cassandra.yaml`` with the ``write_request_timeout_in_ms``\n    option.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        kwargs['write_type'] = write_type\n        Timeout.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass CDCWriteFailure(RequestExecutionException):\n    \"\"\"\n    Hit limit on data in CDC folder, writes are rejected\n    \"\"\"\n\n    def __init__(self, message):\n        Exception.__init__(self, message)\n\nclass CoordinationFailure(RequestExecutionException):\n    \"\"\"\n    Replicas sent a failure to the coordinator.\n    \"\"\"\n    consistency = None\n    ' The requested :class:`ConsistencyLevel` '\n    required_responses = None\n    ' The number of required replica responses '\n    received_responses = None\n    '\\n    The number of replicas that responded before the coordinator timed out\\n    the operation\\n    '\n    failures = None\n    '\\n    The number of replicas that sent a failure message\\n    '\n    error_code_map = None\n    '\\n    A map of inet addresses to error codes representing replicas that sent\\n    a failure message.  Only set when `protocol_version` is 5 or higher.\\n    '\n\n    def __init__(self, summary_message, consistency=None, required_responses=None, received_responses=None, failures=None, error_code_map=None):\n        self.consistency = consistency\n        self.required_responses = required_responses\n        self.received_responses = received_responses\n        self.failures = failures\n        self.error_code_map = error_code_map\n        info_dict = {'consistency': consistency_value_to_name(consistency), 'required_responses': required_responses, 'received_responses': received_responses, 'failures': failures}\n        if error_code_map is not None:\n            formatted_map = dict(((addr, '0x%04x' % err_code) for addr, err_code in error_code_map.items()))\n            info_dict['error_code_map'] = formatted_map\n        Exception.__init__(self, summary_message + ' info=' + repr(info_dict))\n\nclass ReadFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for read operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    data_retrieved = None\n    '\\n    A boolean indicating whether the requested data was retrieved\\n    by the coordinator from any replicas before it timed out the\\n    operation\\n    '\n\n    def __init__(self, message, data_retrieved=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.data_retrieved = data_retrieved\n\nclass WriteFailure(CoordinationFailure):\n    \"\"\"\n    A subclass of :exc:`CoordinationFailure` for write operations.\n\n    This indicates that the replicas sent a failure message to the coordinator.\n    \"\"\"\n    write_type = None\n    '\\n    The type of write operation, enum on :class:`~cassandra.policies.WriteType`\\n    '\n\n    def __init__(self, message, write_type=None, **kwargs):\n        CoordinationFailure.__init__(self, message, **kwargs)\n        self.write_type = write_type\n\nclass FunctionFailure(RequestExecutionException):\n    \"\"\"\n    User Defined Function failed during execution\n    \"\"\"\n    keyspace = None\n    '\\n    Keyspace of the function\\n    '\n    function = None\n    '\\n    Name of the function\\n    '\n    arg_types = None\n    '\\n    List of argument type names of the function\\n    '\n\n    def __init__(self, summary_message, keyspace, function, arg_types):\n        self.keyspace = keyspace\n        self.function = function\n        self.arg_types = arg_types\n        Exception.__init__(self, summary_message)\n\nclass RequestValidationException(DriverException):\n    \"\"\"\n    Server request validation failed\n    \"\"\"\n    pass\n\nclass ConfigurationException(RequestValidationException):\n    \"\"\"\n    Server indicated request errro due to current configuration\n    \"\"\"\n    pass\n\nclass AlreadyExists(ConfigurationException):\n    \"\"\"\n    An attempt was made to create a keyspace or table that already exists.\n    \"\"\"\n    keyspace = None\n    '\\n    The name of the keyspace that already exists, or, if an attempt was\\n    made to create a new table, the keyspace that the table is in.\\n    '\n    table = None\n    '\\n    The name of the table that already exists, or, if an attempt was\\n    make to create a keyspace, :const:`None`.\\n    '\n\n    def __init__(self, keyspace=None, table=None):\n        if table:\n            message = \"Table '%s.%s' already exists\" % (keyspace, table)\n        else:\n            message = \"Keyspace '%s' already exists\" % (keyspace,)\n        Exception.__init__(self, message)\n        self.keyspace = keyspace\n        self.table = table\n\nclass InvalidRequest(RequestValidationException):\n    \"\"\"\n    A query was made that was invalid for some reason, such as trying to set\n    the keyspace for a connection to a nonexistent keyspace.\n    \"\"\"\n    pass\n\nclass Unauthorized(RequestValidationException):\n    \"\"\"\n    The current user is not authorized to perform the requested operation.\n    \"\"\"\n    pass\n\nclass AuthenticationFailed(DriverException):\n    \"\"\"\n    Failed to authenticate.\n    \"\"\"\n    pass\n\nclass OperationTimedOut(DriverException):\n    \"\"\"\n    The operation took longer than the specified (client-side) timeout\n    to complete.  This is not an error generated by Cassandra, only\n    the driver.\n    \"\"\"\n    errors = None\n    '\\n    A dict of errors keyed by the :class:`~.Host` against which they occurred.\\n    '\n    last_host = None\n    '\\n    The last :class:`~.Host` this operation was attempted against.\\n    '\n\n    def __init__(self, errors=None, last_host=None):\n        self.errors = errors\n        self.last_host = last_host\n        message = 'errors=%s, last_host=%s' % (self.errors, self.last_host)\n        Exception.__init__(self, message)\n\nclass UnsupportedOperation(DriverException):\n    \"\"\"\n    An attempt was made to use a feature that is not supported by the\n    selected protocol version.  See :attr:`Cluster.protocol_version`\n    for more details.\n    \"\"\"\n    pass\n\nclass UnresolvableContactPoints(DriverException):\n    \"\"\"\n    The driver was unable to resolve any provided hostnames.\n\n    Note that this is *not* raised when a :class:`.Cluster` is created with no\n    contact points, only when lookup fails for all hosts\n    \"\"\"\n    pass\n\nclass DependencyException(Exception):\n    \"\"\"\n    Specific exception class for handling issues with driver dependencies\n    \"\"\"\n    excs = []\n    '\\n    A sequence of child exceptions\\n    '\n\n    def __init__(self, msg, excs=[]):\n        complete_msg = msg\n        if excs:\n            complete_msg += '\\nThe following exceptions were observed: \\n - ' + '\\n - '.join((str(e) for e in excs))\n        Exception.__init__(self, complete_msg)"
  },
  "call_tree": {
    "tests/unit/cqlengine/test_columns.py:ColumnTest:test_comparisons": {
      "cassandra/cqlengine/columns.py:Column:__init__": {},
      "cassandra/cqlengine/columns.py:Column:__ne__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      },
      "cassandra/cqlengine/columns.py:Column:__eq__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      },
      "cassandra/cqlengine/columns.py:Column:__lt__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      },
      "cassandra/cqlengine/columns.py:Column:__le__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      },
      "cassandra/cqlengine/columns.py:Column:__gt__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      },
      "cassandra/cqlengine/columns.py:Column:__ge__": {
        "cassandra/cqlengine/columns.py:Column:Column": {}
      }
    },
    "tests/unit/cqlengine/test_columns.py:ColumnTest:test_hash": {
      "cassandra/cqlengine/columns.py:Column:__init__": {},
      "cassandra/cqlengine/columns.py:Column:__hash__": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/cassandra_driver-image/cassandra_driver/tests/integration/cqlengine/columns/test_validation.py:TestTimeUUIDFromDatetime:test_conversion_specific_date": {
      "cassandra/cqlengine/columns.py:UUID:UUID": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/cassandra_driver-image/cassandra_driver/tests/integration/advanced/graph/test_graph.py:GraphTimeoutTests:test_server_timeout_less_then_request": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/cassandra_driver-image/cassandra_driver/tests/integration/advanced/graph/test_graph.py:GraphProfileTests:test_graph_profile": {
      "cassandra/__init__.py:InvalidRequest:InvalidRequest": {},
      "cassandra/__init__.py:OperationTimedOut:OperationTimedOut": {}
    }
  }
}