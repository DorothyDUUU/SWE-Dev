{
  "dir_path": "/app/dogpile_cache",
  "package_name": "dogpile_cache",
  "sample_name": "dogpile_cache-test_nameregistry",
  "src_dir": "dogpile/",
  "test_dir": "tests/",
  "test_file": "tests/util/test_nameregistry.py",
  "test_code": "import logging\nimport random\nimport threading\nimport time\n\nfrom dogpile.util import NameRegistry\n\nlog = logging.getLogger(__name__)\n\n\nclass NameRegistryTest:\n    def test_name_registry(self):\n        success = [True]\n        num_operations = [0]\n\n        def create(identifier):\n            log.debug(\"Creator running for id: \" + identifier)\n            return threading.Lock()\n\n        registry = NameRegistry(create)\n\n        baton = {\"beans\": False, \"means\": False, \"please\": False}\n\n        def do_something(name):\n            for iteration in range(20):\n                name = list(baton)[random.randint(0, 2)]\n                lock = registry.get(name)\n                lock.acquire()\n                try:\n                    if baton[name]:\n                        success[0] = False\n                        log.debug(\"Baton is already populated\")\n                        break\n                    baton[name] = True\n                    try:\n                        time.sleep(random.random() * 0.01)\n                    finally:\n                        num_operations[0] += 1\n                        baton[name] = False\n                finally:\n                    lock.release()\n            log.debug(\"thread completed operations\")\n\n        threads = []\n        for id_ in range(1, 20):\n            t = threading.Thread(target=do_something, args=(\"somename\",))\n            t.start()\n            threads.append(t)\n\n        for t in threads:\n            t.join()\n\n        assert success[0]\n",
  "GT_file_code": {
    "dogpile/util/nameregistry.py": "import threading\nfrom typing import Any\nfrom typing import Callable\nfrom typing import MutableMapping\nimport weakref\n\n\nclass NameRegistry(object):\n    \"\"\"Generates and return an object, keeping it as a\n    singleton for a certain identifier for as long as its\n    strongly referenced.\n\n    e.g.::\n\n        class MyFoo(object):\n            \"some important object.\"\n            def __init__(self, identifier):\n                self.identifier = identifier\n\n        registry = NameRegistry(MyFoo)\n\n        # thread 1:\n        my_foo = registry.get(\"foo1\")\n\n        # thread 2\n        my_foo = registry.get(\"foo1\")\n\n    Above, ``my_foo`` in both thread #1 and #2 will\n    be *the same object*.   The constructor for\n    ``MyFoo`` will be called once, passing the\n    identifier ``foo1`` as the argument.\n\n    When thread 1 and thread 2 both complete or\n    otherwise delete references to ``my_foo``, the\n    object is *removed* from the :class:`.NameRegistry` as\n    a result of Python garbage collection.\n\n    :param creator: A function that will create a new\n     value, given the identifier passed to the :meth:`.NameRegistry.get`\n     method.\n\n    \"\"\"\n\n    _mutex = threading.RLock()\n\n    def __init__(self, creator: Callable[..., Any]):\n        \"\"\"Create a new :class:`.NameRegistry`.\"\"\"\n        self._values: MutableMapping[str, Any] = weakref.WeakValueDictionary()\n        self._mutex = threading.RLock()\n        self.creator = creator\n\n    def get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n        r\"\"\"Get and possibly create the value.\n\n        :param identifier: Hash key for the value.\n         If the creation function is called, this identifier\n         will also be passed to the creation function.\n        :param \\*args, \\**kw: Additional arguments which will\n         also be passed to the creation function if it is\n         called.\n\n        \"\"\"\n        try:\n            if identifier in self._values:\n                return self._values[identifier]\n            else:\n                return self._sync_get(identifier, *args, **kw)\n        except KeyError:\n            return self._sync_get(identifier, *args, **kw)\n\n    def _sync_get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n        self._mutex.acquire()\n        try:\n            try:\n                if identifier in self._values:\n                    return self._values[identifier]\n                else:\n                    self._values[identifier] = value = self.creator(\n                        identifier, *args, **kw\n                    )\n                    return value\n            except KeyError:\n                self._values[identifier] = value = self.creator(\n                    identifier, *args, **kw\n                )\n                return value\n        finally:\n            self._mutex.release()\n"
  },
  "GT_src_dict": {
    "dogpile/util/nameregistry.py": {
      "NameRegistry.__init__": {
        "code": "    def __init__(self, creator: Callable[..., Any]):\n        \"\"\"Initialize a new instance of the NameRegistry class.\n\nThis constructor sets up the necessary components for managing singleton instances associated with unique identifiers. It takes a callable `creator` function that generates new instances when needed.\n\nParameters:\n- creator (Callable[..., Any]): A function that receives an identifier and additional arguments to create a new object. This function will be called if the requested instance does not already exist in the registry.\n\nAttributes:\n- _values (MutableMapping[str, Any]): A weak reference dictionary that holds the instances created by the `creator`. This allows for automatic cleanup of instances when there are no strong references remaining.\n- _mutex (threading.RLock): A reentrant lock that ensures thread-safety when accessing or creating instances in the registry.\n- creator: The callable function provided at initialization, used for instantiating new objects.\n\nThis class enables the management of shared resources across threads while maintaining a singular instance per identifier.\"\"\"\n        'Create a new :class:`.NameRegistry`.'\n        self._values: MutableMapping[str, Any] = weakref.WeakValueDictionary()\n        self._mutex = threading.RLock()\n        self.creator = creator",
        "docstring": "Initialize a new instance of the NameRegistry class.\n\nThis constructor sets up the necessary components for managing singleton instances associated with unique identifiers. It takes a callable `creator` function that generates new instances when needed.\n\nParameters:\n- creator (Callable[..., Any]): A function that receives an identifier and additional arguments to create a new object. This function will be called if the requested instance does not already exist in the registry.\n\nAttributes:\n- _values (MutableMapping[str, Any]): A weak reference dictionary that holds the instances created by the `creator`. This allows for automatic cleanup of instances when there are no strong references remaining.\n- _mutex (threading.RLock): A reentrant lock that ensures thread-safety when accessing or creating instances in the registry.\n- creator: The callable function provided at initialization, used for instantiating new objects.\n\nThis class enables the management of shared resources across threads while maintaining a singular instance per identifier.",
        "signature": "def __init__(self, creator: Callable[..., Any]):",
        "type": "Method",
        "class_signature": "class NameRegistry(object):"
      },
      "NameRegistry.get": {
        "code": "    def get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n        \"\"\"Retrieve a singleton object associated with a given identifier, creating it if it does not already exist. This method checks if the object is already present in the weak reference dictionary `_values`. If found, it returns the existing object; if not, it calls the `_sync_get` method, which handles creating and storing the new object under the specified identifier, ensuring thread safety with a reentrant lock (`_mutex`). \n\nParameters:\n- identifier (str): A unique key used to reference the value in the registry.\n- *args (Any): Additional positional arguments to pass to the creator function if a new object is created.\n- **kw (Any): Additional keyword arguments to pass to the creator function if a new object is created.\n\nReturns:\n- Any: The existing or newly created object corresponding to the identifier.\n\nDependencies:\n- `_values` (MutableMapping[str, Any]): A weak reference dictionary that holds the singleton instances.\n- `_mutex` (threading.RLock): A reentrant lock used to ensure thread-safe access to the registry.\"\"\"\n        'Get and possibly create the value.\\n\\n        :param identifier: Hash key for the value.\\n         If the creation function is called, this identifier\\n         will also be passed to the creation function.\\n        :param \\\\*args, \\\\**kw: Additional arguments which will\\n         also be passed to the creation function if it is\\n         called.\\n\\n        '\n        try:\n            if identifier in self._values:\n                return self._values[identifier]\n            else:\n                return self._sync_get(identifier, *args, **kw)\n        except KeyError:\n            return self._sync_get(identifier, *args, **kw)",
        "docstring": "Retrieve a singleton object associated with a given identifier, creating it if it does not already exist. This method checks if the object is already present in the weak reference dictionary `_values`. If found, it returns the existing object; if not, it calls the `_sync_get` method, which handles creating and storing the new object under the specified identifier, ensuring thread safety with a reentrant lock (`_mutex`). \n\nParameters:\n- identifier (str): A unique key used to reference the value in the registry.\n- *args (Any): Additional positional arguments to pass to the creator function if a new object is created.\n- **kw (Any): Additional keyword arguments to pass to the creator function if a new object is created.\n\nReturns:\n- Any: The existing or newly created object corresponding to the identifier.\n\nDependencies:\n- `_values` (MutableMapping[str, Any]): A weak reference dictionary that holds the singleton instances.\n- `_mutex` (threading.RLock): A reentrant lock used to ensure thread-safe access to the registry.",
        "signature": "def get(self, identifier: str, *args: Any, **kw: Any) -> Any:",
        "type": "Method",
        "class_signature": "class NameRegistry(object):"
      }
    }
  },
  "dependency_dict": {
    "dogpile/util/nameregistry.py:NameRegistry:get": {
      "dogpile/util/nameregistry.py": {
        "NameRegistry._sync_get": {
          "code": "    def _sync_get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n        self._mutex.acquire()\n        try:\n            try:\n                if identifier in self._values:\n                    return self._values[identifier]\n                else:\n                    self._values[identifier] = value = self.creator(identifier, *args, **kw)\n                    return value\n            except KeyError:\n                self._values[identifier] = value = self.creator(identifier, *args, **kw)\n                return value\n        finally:\n            self._mutex.release()",
          "docstring": "",
          "signature": "def _sync_get(self, identifier: str, *args: Any, **kw: Any) -> Any:",
          "type": "Method",
          "class_signature": "class NameRegistry(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: dogpile_cache-test_nameregistry\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 dogpile/\n    \u2514\u2500\u2500 util/\n        \u2514\u2500\u2500 nameregistry.py\n            \u251c\u2500\u2500 NameRegistry.__init__\n            \u2514\u2500\u2500 NameRegistry.get\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a concurrency management tool that facilitates thread-safe operations by utilizing a name-based registry to manage resources. It enables developers to associate unique identifiers with shared locks, ensuring controlled access to shared data in multi-threaded environments. By dynamically creating and retrieving locks corresponding to specific resource names, it prevents contention and potential data corruption when concurrent operations are performed. This functionality simplifies the complexity of synchronization in multi-threaded applications, enhancing reliability and ensuring data integrity for developers managing shared resources.\n\n## FILE 1: dogpile/util/nameregistry.py\n\n- CLASS METHOD: NameRegistry.get\n  - CLASS SIGNATURE: class NameRegistry(object):\n  - SIGNATURE: def get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a singleton object associated with a given identifier, creating it if it does not already exist. This method checks if the object is already present in the weak reference dictionary `_values`. If found, it returns the existing object; if not, it calls the `_sync_get` method, which handles creating and storing the new object under the specified identifier, ensuring thread safety with a reentrant lock (`_mutex`). \n\nParameters:\n- identifier (str): A unique key used to reference the value in the registry.\n- *args (Any): Additional positional arguments to pass to the creator function if a new object is created.\n- **kw (Any): Additional keyword arguments to pass to the creator function if a new object is created.\n\nReturns:\n- Any: The existing or newly created object corresponding to the identifier.\n\nDependencies:\n- `_values` (MutableMapping[str, Any]): A weak reference dictionary that holds the singleton instances.\n- `_mutex` (threading.RLock): A reentrant lock used to ensure thread-safe access to the registry.\n\"\"\"\n```\n\n- CLASS METHOD: NameRegistry.__init__\n  - CLASS SIGNATURE: class NameRegistry(object):\n  - SIGNATURE: def __init__(self, creator: Callable[..., Any]):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new instance of the NameRegistry class.\n\nThis constructor sets up the necessary components for managing singleton instances associated with unique identifiers. It takes a callable `creator` function that generates new instances when needed.\n\nParameters:\n- creator (Callable[..., Any]): A function that receives an identifier and additional arguments to create a new object. This function will be called if the requested instance does not already exist in the registry.\n\nAttributes:\n- _values (MutableMapping[str, Any]): A weak reference dictionary that holds the instances created by the `creator`. This allows for automatic cleanup of instances when there are no strong references remaining.\n- _mutex (threading.RLock): A reentrant lock that ensures thread-safety when accessing or creating instances in the registry.\n- creator: The callable function provided at initialization, used for instantiating new objects.\n\nThis class enables the management of shared resources across threads while maintaining a singular instance per identifier.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "dogpile/util/nameregistry.py": "import threading\nfrom typing import Any\nfrom typing import Callable\nfrom typing import MutableMapping\nimport weakref\n\nclass NameRegistry(object):\n    \"\"\"Generates and return an object, keeping it as a\n    singleton for a certain identifier for as long as its\n    strongly referenced.\n\n    e.g.::\n\n        class MyFoo(object):\n            \"some important object.\"\n            def __init__(self, identifier):\n                self.identifier = identifier\n\n        registry = NameRegistry(MyFoo)\n\n        # thread 1:\n        my_foo = registry.get(\"foo1\")\n\n        # thread 2\n        my_foo = registry.get(\"foo1\")\n\n    Above, ``my_foo`` in both thread #1 and #2 will\n    be *the same object*.   The constructor for\n    ``MyFoo`` will be called once, passing the\n    identifier ``foo1`` as the argument.\n\n    When thread 1 and thread 2 both complete or\n    otherwise delete references to ``my_foo``, the\n    object is *removed* from the :class:`.NameRegistry` as\n    a result of Python garbage collection.\n\n    :param creator: A function that will create a new\n     value, given the identifier passed to the :meth:`.NameRegistry.get`\n     method.\n\n    \"\"\"\n    _mutex = threading.RLock()\n\n    def _sync_get(self, identifier: str, *args: Any, **kw: Any) -> Any:\n        self._mutex.acquire()\n        try:\n            try:\n                if identifier in self._values:\n                    return self._values[identifier]\n                else:\n                    self._values[identifier] = value = self.creator(identifier, *args, **kw)\n                    return value\n            except KeyError:\n                self._values[identifier] = value = self.creator(identifier, *args, **kw)\n                return value\n        finally:\n            self._mutex.release()"
  },
  "call_tree": {
    "tests/util/test_nameregistry.py:NameRegistryTest:test_name_registry": {
      "dogpile/util/nameregistry.py:NameRegistry:__init__": {}
    },
    "tests/util/test_nameregistry.py:NameRegistryTest:do_something": {
      "dogpile/util/nameregistry.py:NameRegistry:get": {
        "dogpile/util/nameregistry.py:NameRegistry:_sync_get": {
          "tests/util/test_nameregistry.py:NameRegistryTest:create": {}
        }
      }
    }
  }
}