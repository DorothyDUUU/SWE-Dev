{
  "dir_path": "/app/stestr",
  "package_name": "stestr",
  "sample_name": "stestr-test_selection",
  "src_dir": "stestr/",
  "test_dir": "stestr/tests/",
  "test_file": "modified_testcases/test_selection.py",
  "test_code": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport io\nimport re\nfrom unittest import mock\n\nfrom stestr import selection\nfrom stestr.tests import base\n\n\nclass TestSelection(base.TestCase):\n    def test_filter_tests_no_filter(self):\n        test_list = [\"a\", \"b\", \"c\"]\n        result = selection.filter_tests(None, test_list)\n        self.assertEqual(test_list, result)\n\n    def test_filter_tests(self):\n        test_list = [\"a\", \"b\", \"c\"]\n        result = selection.filter_tests([\"a\"], test_list)\n        self.assertEqual([\"a\"], result)\n\n    def test_filter_invalid_regex(self):\n        test_list = [\"a\", \"b\", \"c\"]\n        with mock.patch(\"sys.exit\", side_effect=ImportError) as mock_exit:\n            self.assertRaises(\n                ImportError,\n                selection.filter_tests,\n                [\"fake_regex_with_bad_part[The-BAD-part]\"],\n                test_list,\n            )\n            mock_exit.assert_called_once_with(5)\n\n\nclass TestExclusionReader(base.TestCase):\n    def test_exclusion_reader(self):\n        exclude_list = io.StringIO()\n        for i in range(4):\n            exclude_list.write(\"fake_regex_%s\\n\" % i)\n            exclude_list.write(\"fake_regex_with_note_%s # note\\n\" % i)\n        exclude_list.seek(0)\n        with mock.patch(\"builtins.open\", return_value=exclude_list):\n            result = selection.exclusion_reader(\"fake_path\")\n        self.assertEqual(2 * 4, len(result))\n        note_cnt = 0\n        # not assuming ordering, mainly just testing the type\n        for r in result:\n            self.assertEqual(r[2], [])\n            if r[1] == \"note\":\n                note_cnt += 1\n            self.assertIn(\"search\", dir(r[0]))  # like a compiled regexp\n        self.assertEqual(note_cnt, 4)\n\n    def test_invalid_regex(self):\n        exclude_list = io.StringIO()\n        exclude_list.write(\"fake_regex_with_bad_part[The-BAD-part]\")\n        exclude_list.seek(0)\n        with mock.patch(\"builtins.open\", return_value=exclude_list):\n            with mock.patch(\"sys.exit\") as mock_exit:\n                selection.exclusion_reader(\"fake_path\")\n                mock_exit.assert_called_once_with(5)\n\n\nclass TestConstructList(base.TestCase):\n    def test_simple_re(self):\n        test_lists = [\"fake_test(scen)[tag,bar])\", \"fake_test(scen)[egg,foo])\"]\n        result = selection.construct_list(test_lists, regexes=[\"foo\"])\n        self.assertEqual(list(result), [\"fake_test(scen)[egg,foo])\"])\n\n    def test_simple_exclusion_re(self):\n        test_lists = [\"fake_test(scen)[tag,bar])\", \"fake_test(scen)[egg,foo])\"]\n        result = selection.construct_list(test_lists, exclude_regex=\"foo\")\n        self.assertEqual(list(result), [\"fake_test(scen)[tag,bar])\"])\n\n    def test_invalid_exclusion_re(self):\n        test_lists = [\"fake_test(scen)[tag,bar])\", \"fake_test(scen)[egg,foo])\"]\n        invalid_regex = \"fake_regex_with_bad_part[The-BAD-part]\"\n        with mock.patch(\"sys.exit\", side_effect=ImportError) as exit_mock:\n            self.assertRaises(\n                ImportError,\n                selection.construct_list,\n                test_lists,\n                exclude_regex=invalid_regex,\n            )\n            exit_mock.assert_called_once_with(5)\n\n    def test_exclusion_list(self):\n        exclude_list = [(re.compile(\"foo\"), \"foo not liked\", [])]\n        test_lists = [\"fake_test(scen)[tag,bar])\", \"fake_test(scen)[egg,foo])\"]\n        with mock.patch(\"stestr.selection.exclusion_reader\", return_value=exclude_list):\n            result = selection.construct_list(\n                test_lists, exclude_list=\"file\", regexes=[\"fake_test\"]\n            )\n        self.assertEqual(list(result), [\"fake_test(scen)[tag,bar])\"])\n\n    def test_inclusion_list(self):\n        include_list = [re.compile(\"fake_test1\"), re.compile(\"fake_test2\")]\n        test_lists = [\"fake_test1[tg]\", \"fake_test2[tg]\", \"fake_test3[tg]\"]\n        include_getter = \"stestr.selection._get_regex_from_include_list\"\n        with mock.patch(include_getter, return_value=include_list):\n            result = selection.construct_list(test_lists, include_list=\"file\")\n        self.assertEqual(set(result), {\"fake_test1[tg]\", \"fake_test2[tg]\"})\n\n    def test_inclusion_list_invalid_regex(self):\n        include_list = io.StringIO()\n        include_list.write(\"fake_regex_with_bad_part[The-BAD-part]\")\n        include_list.seek(0)\n        with mock.patch(\"builtins.open\", return_value=include_list):\n            with mock.patch(\"sys.exit\") as mock_exit:\n                selection._get_regex_from_include_list(\"fake_path\")\n                mock_exit.assert_called_once_with(5)\n\n    def test_inclusion_exclusion_list_re(self):\n        include_list = [re.compile(\"fake_test1\"), re.compile(\"fake_test2\")]\n        test_lists = [\n            \"fake_test1[tg]\",\n            \"fake_test2[spam]\",\n            \"fake_test3[tg,foo]\",\n            \"fake_test4[spam]\",\n        ]\n        exclude_list = [(re.compile(\"spam\"), \"spam not liked\", [])]\n        include_getter = \"stestr.selection._get_regex_from_include_list\"\n        with mock.patch(include_getter, return_value=include_list):\n            with mock.patch(\n                \"stestr.selection.exclusion_reader\", return_value=exclude_list\n            ):\n                result = selection.construct_list(\n                    test_lists,\n                    exclude_list=\"exclude_file\",\n                    include_list=\"include_file\",\n                    regexes=[\"foo\"],\n                )\n        self.assertEqual(set(result), {\"fake_test1[tg]\", \"fake_test3[tg,foo]\"})\n\n    def test_overlapping_exclude_regex(self):\n\n        exclude_list = [\n            (re.compile(\"compute.test_keypairs.KeypairsTestV210\"), \"\", []),\n            (re.compile(\"compute.test_keypairs.KeypairsTestV21\"), \"\", []),\n        ]\n        test_lists = [\n            \"compute.test_keypairs.KeypairsTestV210.test_create_keypair\",\n            \"compute.test_keypairs.KeypairsTestV21.test_create_keypair\",\n            \"compute.test_fake.FakeTest.test_fake_test\",\n        ]\n        with mock.patch(\"stestr.selection.exclusion_reader\", return_value=exclude_list):\n            result = selection.construct_list(\n                test_lists, exclude_list=\"file\", regexes=[\"fake_test\"]\n            )\n        self.assertEqual(list(result), [\"compute.test_fake.FakeTest.test_fake_test\"])\n",
  "GT_file_code": {
    "stestr/selection.py": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport contextlib\nimport re\nimport sys\n\n\ndef filter_tests(filters, test_ids):\n    \"\"\"Filter test_ids by the test_filters.\n\n    :param list filters: A list of regex filters to apply to the test_ids. The\n        output will contain any test_ids which have a re.search() match for any\n        of the regexes in this list. If this is None all test_ids will be\n        returned\n    :param list test_ids: A list of test_ids that will be filtered\n    :return: A list of test ids.\n    \"\"\"\n    if filters is None:\n        return test_ids\n\n    _filters = []\n    for f in filters:\n        if isinstance(f, str):\n            try:\n                _filters.append(re.compile(f))\n            except re.error:\n                print(\"Invalid regex: %s provided in filters\" % f, file=sys.stderr)\n                sys.exit(5)\n        else:\n            _filters.append(f)\n\n    def include(test_id):\n        for pred in _filters:\n            if pred.search(test_id):\n                return True\n\n    return list(filter(include, test_ids))\n\n\ndef exclusion_reader(exclude_list):\n    with contextlib.closing(open(exclude_list)) as exclude_file:\n        regex_comment_lst = []  # tuple of (regex_compiled, msg, skipped_lst)\n        for line in exclude_file:\n            raw_line = line.strip()\n            split_line = raw_line.split(\"#\")\n            # Before the # is the regex\n            line_regex = split_line[0].strip()\n            if len(split_line) > 1:\n                # After the # is a comment\n                comment = \"\".join(split_line[1:]).strip()\n            else:\n                comment = \"Skipped because of regex %s:\" % line_regex\n            if not line_regex:\n                continue\n            try:\n                regex_comment_lst.append((re.compile(line_regex), comment, []))\n            except re.error:\n                print(\n                    \"Invalid regex: %s in provided exclusion list file\" % line_regex,\n                    file=sys.stderr,\n                )\n                sys.exit(5)\n    return regex_comment_lst\n\n\ndef _get_regex_from_include_list(file_path):\n    lines = []\n    for line in open(file_path).read().splitlines():\n        split_line = line.strip().split(\"#\")\n        # Before the # is the regex\n        line_regex = split_line[0].strip()\n        if line_regex:\n            try:\n                lines.append(re.compile(line_regex))\n            except re.error:\n                print(\n                    \"Invalid regex: %s in provided inclusion_list file\" % line_regex,\n                    file=sys.stderr,\n                )\n                sys.exit(5)\n    return lines\n\n\ndef construct_list(\n    test_ids, regexes=None, exclude_list=None, include_list=None, exclude_regex=None\n):\n    \"\"\"Filters the discovered test cases\n\n    :param list test_ids: The set of test_ids to be filtered\n    :param list regexes: A list of regex filters to apply to the test_ids. The\n        output will contain any test_ids which have a re.search() match for any\n        of the regexes in this list. If this is None all test_ids will be\n        returned\n    :param str exclude_list: The path to an exclusion_list file\n    :param str include_list: The path to an inclusion_list file\n    :param str exclude_regex: regex pattern to exclude tests\n\n    :return: iterable of strings. The strings are full\n        test_ids\n    :rtype: set\n    \"\"\"\n\n    if not regexes:\n        regexes = None  # handle the other false things\n\n    safe_re = None\n    if include_list:\n        safe_re = _get_regex_from_include_list(include_list)\n\n    if not regexes and safe_re:\n        regexes = safe_re\n    elif regexes and safe_re:\n        regexes += safe_re\n\n    if exclude_list:\n        exclude_data = exclusion_reader(exclude_list)\n    else:\n        exclude_data = None\n\n    if exclude_regex:\n        msg = \"Skipped because of regexp provided as a command line argument:\"\n        try:\n            record = (re.compile(exclude_regex), msg, [])\n        except re.error:\n            print(\n                \"Invalid regex: %s used for exclude_regex\" % exclude_regex,\n                file=sys.stderr,\n            )\n            sys.exit(5)\n        if exclude_data:\n            exclude_data.append(record)\n        else:\n            exclude_data = [record]\n\n    list_of_test_cases = filter_tests(regexes, test_ids)\n    set_of_test_cases = set(list_of_test_cases)\n\n    if not exclude_data:\n        return set_of_test_cases\n\n    # NOTE(afazekas): We might use a faster logic when the\n    # print option is not requested\n    for (rex, msg, s_list) in exclude_data:\n        for test_case in list_of_test_cases:\n            if rex.search(test_case):\n                # NOTE(mtreinish): In the case of overlapping regex the test\n                # case might have already been removed from the set of tests\n                if test_case in set_of_test_cases:\n                    set_of_test_cases.remove(test_case)\n                    s_list.append(test_case)\n\n    return set_of_test_cases\n"
  },
  "GT_src_dict": {
    "stestr/selection.py": {
      "filter_tests": {
        "code": "def filter_tests(filters, test_ids):\n    \"\"\"Filter the provided test IDs to include only those that match specified regex patterns.\n\n:param list filters: A list of regex patterns that will be applied to the test_ids. Each pattern is compiled using `re.compile()`. If this is None, all test_ids will be returned without filtering.\n:param list test_ids: A list of test IDs that are to be filtered based on the provided regex patterns.\n:return: A list of filtered test IDs that match any of the provided regex patterns.\n\nThis function communicates directly with the `re` module for regex operations, and any invalid regex in the filters will raise an error, terminating the program. The function also handles filtering through an internal `include` function, which checks each test ID against the compiled regex filters.\"\"\"\n    'Filter test_ids by the test_filters.\\n\\n    :param list filters: A list of regex filters to apply to the test_ids. The\\n        output will contain any test_ids which have a re.search() match for any\\n        of the regexes in this list. If this is None all test_ids will be\\n        returned\\n    :param list test_ids: A list of test_ids that will be filtered\\n    :return: A list of test ids.\\n    '\n    if filters is None:\n        return test_ids\n    _filters = []\n    for f in filters:\n        if isinstance(f, str):\n            try:\n                _filters.append(re.compile(f))\n            except re.error:\n                print('Invalid regex: %s provided in filters' % f, file=sys.stderr)\n                sys.exit(5)\n        else:\n            _filters.append(f)\n\n    def include(test_id):\n        \"\"\"Check if a given test_id matches any of the provided regex filters.\n\n:param str test_id: The test identifier to evaluate against the filters.\n:return: True if the test_id matches any filter in _filters; otherwise, False.\n:rtype: bool\n\nThe function relies on the _filters list, which contains compiled regular expressions created outside this function by the `filter_tests` function. These filters are used to determine if the test_id should be included based on regex matches.\"\"\"\n        for pred in _filters:\n            if pred.search(test_id):\n                return True\n    return list(filter(include, test_ids))",
        "docstring": "Filter the provided test IDs to include only those that match specified regex patterns.\n\n:param list filters: A list of regex patterns that will be applied to the test_ids. Each pattern is compiled using `re.compile()`. If this is None, all test_ids will be returned without filtering.\n:param list test_ids: A list of test IDs that are to be filtered based on the provided regex patterns.\n:return: A list of filtered test IDs that match any of the provided regex patterns.\n\nThis function communicates directly with the `re` module for regex operations, and any invalid regex in the filters will raise an error, terminating the program. The function also handles filtering through an internal `include` function, which checks each test ID against the compiled regex filters.",
        "signature": "def filter_tests(filters, test_ids):",
        "type": "Function",
        "class_signature": null
      },
      "exclusion_reader": {
        "code": "def exclusion_reader(exclude_list):\n    \"\"\"Reads an exclusion list file to generate a list of compiled regular expressions along with associated comments.\n\n:param str exclude_list: The path to the file containing exclusion regex patterns. Each line should specify a regex, with an optional comment prefixed by a '#'.\n:return: A list of tuples, where each tuple contains a compiled regex pattern, a comment string, and an empty list for tracking skipped test cases.\n:rtype: list of tuples\n:raises SystemExit: Exits with code 5 if an invalid regex is encountered in the exclusion list.\n    \nThe function utilizes the `contextlib.closing` to ensure proper closure of the file after reading. Each line in the exclusion file is processed to extract the regex and any associated comment, with support for comments at the end of the line. The compiled regex patterns are then stored in a list for later use in filtering tests in the `construct_list` function.\"\"\"\n    with contextlib.closing(open(exclude_list)) as exclude_file:\n        regex_comment_lst = []\n        for line in exclude_file:\n            raw_line = line.strip()\n            split_line = raw_line.split('#')\n            line_regex = split_line[0].strip()\n            if len(split_line) > 1:\n                comment = ''.join(split_line[1:]).strip()\n            else:\n                comment = 'Skipped because of regex %s:' % line_regex\n            if not line_regex:\n                continue\n            try:\n                regex_comment_lst.append((re.compile(line_regex), comment, []))\n            except re.error:\n                print('Invalid regex: %s in provided exclusion list file' % line_regex, file=sys.stderr)\n                sys.exit(5)\n    return regex_comment_lst",
        "docstring": "Reads an exclusion list file to generate a list of compiled regular expressions along with associated comments.\n\n:param str exclude_list: The path to the file containing exclusion regex patterns. Each line should specify a regex, with an optional comment prefixed by a '#'.\n:return: A list of tuples, where each tuple contains a compiled regex pattern, a comment string, and an empty list for tracking skipped test cases.\n:rtype: list of tuples\n:raises SystemExit: Exits with code 5 if an invalid regex is encountered in the exclusion list.\n    \nThe function utilizes the `contextlib.closing` to ensure proper closure of the file after reading. Each line in the exclusion file is processed to extract the regex and any associated comment, with support for comments at the end of the line. The compiled regex patterns are then stored in a list for later use in filtering tests in the `construct_list` function.",
        "signature": "def exclusion_reader(exclude_list):",
        "type": "Function",
        "class_signature": null
      },
      "_get_regex_from_include_list": {
        "code": "def _get_regex_from_include_list(file_path):\n    \"\"\"Retrieve and compile regex patterns from an inclusion list file.\n\n:param str file_path: The path to the inclusion list file, which should contain regex patterns, each potentially followed by a comment (denoted by '#'). \n:raises SystemExit: Exits the program if any regex pattern in the file is invalid. \n:return: A list of compiled regex patterns.\n:rtype: list\n\nThis function reads lines from the specified file, compiles any valid regex patterns, and returns them as a list. Each line can include a comment that is ignored during processing. Invalid regex patterns will trigger an error message and terminate the program, ensuring only valid expressions are returned for filtering test cases.\"\"\"\n    lines = []\n    for line in open(file_path).read().splitlines():\n        split_line = line.strip().split('#')\n        line_regex = split_line[0].strip()\n        if line_regex:\n            try:\n                lines.append(re.compile(line_regex))\n            except re.error:\n                print('Invalid regex: %s in provided inclusion_list file' % line_regex, file=sys.stderr)\n                sys.exit(5)\n    return lines",
        "docstring": "Retrieve and compile regex patterns from an inclusion list file.\n\n:param str file_path: The path to the inclusion list file, which should contain regex patterns, each potentially followed by a comment (denoted by '#'). \n:raises SystemExit: Exits the program if any regex pattern in the file is invalid. \n:return: A list of compiled regex patterns.\n:rtype: list\n\nThis function reads lines from the specified file, compiles any valid regex patterns, and returns them as a list. Each line can include a comment that is ignored during processing. Invalid regex patterns will trigger an error message and terminate the program, ensuring only valid expressions are returned for filtering test cases.",
        "signature": "def _get_regex_from_include_list(file_path):",
        "type": "Function",
        "class_signature": null
      },
      "construct_list": {
        "code": "def construct_list(test_ids, regexes=None, exclude_list=None, include_list=None, exclude_regex=None):\n    \"\"\"Filters a list of test identifiers based on provided regular expression patterns and exclusion criteria.\n\n:param list test_ids: A list of test identifiers to be filtered.\n:param list regexes: Optional; a list of regex patterns to include in the filtering. If None, all test_ids are accepted.\n:param str exclude_list: Optional; the file path to an exclusion list containing regexes for tests to be excluded.\n:param str include_list: Optional; the file path to an inclusion list containing regexes to include.\n:param str exclude_regex: Optional; a regex pattern given as a command-line argument to exclude certain tests.\n\n:return: A set of filtered test_ids after applying the specified include/exclude criteria.\n:rtype: set\n\nThis function interacts with the `filter_tests`, `exclusion_reader`, and `_get_regex_from_include_list` functions for filtering logic, validating regex patterns, and reading from files. Invalid regex patterns result in a termination of the program. The function constructs a comprehensive filter based on optional include/exclude regex specifications, enhancing flexibility in test selection.\"\"\"\n    'Filters the discovered test cases\\n\\n    :param list test_ids: The set of test_ids to be filtered\\n    :param list regexes: A list of regex filters to apply to the test_ids. The\\n        output will contain any test_ids which have a re.search() match for any\\n        of the regexes in this list. If this is None all test_ids will be\\n        returned\\n    :param str exclude_list: The path to an exclusion_list file\\n    :param str include_list: The path to an inclusion_list file\\n    :param str exclude_regex: regex pattern to exclude tests\\n\\n    :return: iterable of strings. The strings are full\\n        test_ids\\n    :rtype: set\\n    '\n    if not regexes:\n        regexes = None\n    safe_re = None\n    if include_list:\n        safe_re = _get_regex_from_include_list(include_list)\n    if not regexes and safe_re:\n        regexes = safe_re\n    elif regexes and safe_re:\n        regexes += safe_re\n    if exclude_list:\n        exclude_data = exclusion_reader(exclude_list)\n    else:\n        exclude_data = None\n    if exclude_regex:\n        msg = 'Skipped because of regexp provided as a command line argument:'\n        try:\n            record = (re.compile(exclude_regex), msg, [])\n        except re.error:\n            print('Invalid regex: %s used for exclude_regex' % exclude_regex, file=sys.stderr)\n            sys.exit(5)\n        if exclude_data:\n            exclude_data.append(record)\n        else:\n            exclude_data = [record]\n    list_of_test_cases = filter_tests(regexes, test_ids)\n    set_of_test_cases = set(list_of_test_cases)\n    if not exclude_data:\n        return set_of_test_cases\n    for rex, msg, s_list in exclude_data:\n        for test_case in list_of_test_cases:\n            if rex.search(test_case):\n                if test_case in set_of_test_cases:\n                    set_of_test_cases.remove(test_case)\n                    s_list.append(test_case)\n    return set_of_test_cases",
        "docstring": "Filters a list of test identifiers based on provided regular expression patterns and exclusion criteria.\n\n:param list test_ids: A list of test identifiers to be filtered.\n:param list regexes: Optional; a list of regex patterns to include in the filtering. If None, all test_ids are accepted.\n:param str exclude_list: Optional; the file path to an exclusion list containing regexes for tests to be excluded.\n:param str include_list: Optional; the file path to an inclusion list containing regexes to include.\n:param str exclude_regex: Optional; a regex pattern given as a command-line argument to exclude certain tests.\n\n:return: A set of filtered test_ids after applying the specified include/exclude criteria.\n:rtype: set\n\nThis function interacts with the `filter_tests`, `exclusion_reader`, and `_get_regex_from_include_list` functions for filtering logic, validating regex patterns, and reading from files. Invalid regex patterns result in a termination of the program. The function constructs a comprehensive filter based on optional include/exclude regex specifications, enhancing flexibility in test selection.",
        "signature": "def construct_list(test_ids, regexes=None, exclude_list=None, include_list=None, exclude_regex=None):",
        "type": "Function",
        "class_signature": null
      },
      "include": {
        "code": "    def include(test_id):\n        \"\"\"Check if a given test_id matches any of the provided regex filters.\n\n:param str test_id: The test identifier to evaluate against the filters.\n:return: True if the test_id matches any filter in _filters; otherwise, False.\n:rtype: bool\n\nThe function relies on the _filters list, which contains compiled regular expressions created outside this function by the `filter_tests` function. These filters are used to determine if the test_id should be included based on regex matches.\"\"\"\n        for pred in _filters:\n            if pred.search(test_id):\n                return True",
        "docstring": "Check if a given test_id matches any of the provided regex filters.\n\n:param str test_id: The test identifier to evaluate against the filters.\n:return: True if the test_id matches any filter in _filters; otherwise, False.\n:rtype: bool\n\nThe function relies on the _filters list, which contains compiled regular expressions created outside this function by the `filter_tests` function. These filters are used to determine if the test_id should be included based on regex matches.",
        "signature": "def include(test_id):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: stestr-test_selection\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 stestr/\n    \u2514\u2500\u2500 selection.py\n        \u251c\u2500\u2500 _get_regex_from_include_list\n        \u251c\u2500\u2500 construct_list\n        \u251c\u2500\u2500 exclusion_reader\n        \u251c\u2500\u2500 filter_tests\n        \u2514\u2500\u2500 include\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module provides comprehensive tools for managing and filtering test case execution within automated testing workflows. It enables users to include or exclude specific test cases based on regex-based selection criteria, process inclusion and exclusion lists, and handle scenarios involving invalid or conflicting patterns. By offering functionalities such as test filtering, exclusion list parsing, and dynamic construction of test execution lists, the module solves the problem of efficiently narrowing down large test suites to the most relevant or targeted subsets. This streamlines test execution, reduces complexity, and ensures greater flexibility and control for developers managing extensive test frameworks.\n\n## FILE 1: stestr/selection.py\n\n- FUNCTION NAME: include\n  - SIGNATURE: def include(test_id):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a given test_id matches any of the provided regex filters.\n\n:param str test_id: The test identifier to evaluate against the filters.\n:return: True if the test_id matches any filter in _filters; otherwise, False.\n:rtype: bool\n\nThe function relies on the _filters list, which contains compiled regular expressions created outside this function by the `filter_tests` function. These filters are used to determine if the test_id should be included based on regex matches.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - stestr/selection.py:filter_tests\n\n- FUNCTION NAME: _get_regex_from_include_list\n  - SIGNATURE: def _get_regex_from_include_list(file_path):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve and compile regex patterns from an inclusion list file.\n\n:param str file_path: The path to the inclusion list file, which should contain regex patterns, each potentially followed by a comment (denoted by '#'). \n:raises SystemExit: Exits the program if any regex pattern in the file is invalid. \n:return: A list of compiled regex patterns.\n:rtype: list\n\nThis function reads lines from the specified file, compiles any valid regex patterns, and returns them as a list. Each line can include a comment that is ignored during processing. Invalid regex patterns will trigger an error message and terminate the program, ensuring only valid expressions are returned for filtering test cases.\n\"\"\"\n```\n\n- FUNCTION NAME: filter_tests\n  - SIGNATURE: def filter_tests(filters, test_ids):\n  - DOCSTRING: \n```python\n\"\"\"\nFilter the provided test IDs to include only those that match specified regex patterns.\n\n:param list filters: A list of regex patterns that will be applied to the test_ids. Each pattern is compiled using `re.compile()`. If this is None, all test_ids will be returned without filtering.\n:param list test_ids: A list of test IDs that are to be filtered based on the provided regex patterns.\n:return: A list of filtered test IDs that match any of the provided regex patterns.\n\nThis function communicates directly with the `re` module for regex operations, and any invalid regex in the filters will raise an error, terminating the program. The function also handles filtering through an internal `include` function, which checks each test ID against the compiled regex filters.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - stestr/selection.py:include\n    - stestr/selection.py:construct_list\n\n- FUNCTION NAME: exclusion_reader\n  - SIGNATURE: def exclusion_reader(exclude_list):\n  - DOCSTRING: \n```python\n\"\"\"\nReads an exclusion list file to generate a list of compiled regular expressions along with associated comments.\n\n:param str exclude_list: The path to the file containing exclusion regex patterns. Each line should specify a regex, with an optional comment prefixed by a '#'.\n:return: A list of tuples, where each tuple contains a compiled regex pattern, a comment string, and an empty list for tracking skipped test cases.\n:rtype: list of tuples\n:raises SystemExit: Exits with code 5 if an invalid regex is encountered in the exclusion list.\n    \nThe function utilizes the `contextlib.closing` to ensure proper closure of the file after reading. Each line in the exclusion file is processed to extract the regex and any associated comment, with support for comments at the end of the line. The compiled regex patterns are then stored in a list for later use in filtering tests in the `construct_list` function.\n\"\"\"\n```\n\n- FUNCTION NAME: construct_list\n  - SIGNATURE: def construct_list(test_ids, regexes=None, exclude_list=None, include_list=None, exclude_regex=None):\n  - DOCSTRING: \n```python\n\"\"\"\nFilters a list of test identifiers based on provided regular expression patterns and exclusion criteria.\n\n:param list test_ids: A list of test identifiers to be filtered.\n:param list regexes: Optional; a list of regex patterns to include in the filtering. If None, all test_ids are accepted.\n:param str exclude_list: Optional; the file path to an exclusion list containing regexes for tests to be excluded.\n:param str include_list: Optional; the file path to an inclusion list containing regexes to include.\n:param str exclude_regex: Optional; a regex pattern given as a command-line argument to exclude certain tests.\n\n:return: A set of filtered test_ids after applying the specified include/exclude criteria.\n:rtype: set\n\nThis function interacts with the `filter_tests`, `exclusion_reader`, and `_get_regex_from_include_list` functions for filtering logic, validating regex patterns, and reading from files. Invalid regex patterns result in a termination of the program. The function constructs a comprehensive filter based on optional include/exclude regex specifications, enhancing flexibility in test selection.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - stestr/selection.py:filter_tests\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "stestr/selection.py": "import contextlib\nimport re\nimport sys"
  },
  "call_tree": {
    "modified_testcases/test_selection.py:TestSelection:test_filter_invalid_regex": {
      "stestr/selection.py:filter_tests": {}
    },
    "modified_testcases/test_selection.py:TestSelection:test_filter_tests": {
      "stestr/selection.py:filter_tests": {
        "stestr/selection.py:include": {}
      }
    },
    "modified_testcases/test_selection.py:TestSelection:test_filter_tests_no_filter": {
      "stestr/selection.py:filter_tests": {}
    },
    "modified_testcases/test_selection.py:TestExclusionReader:test_exclusion_reader": {
      "stestr/selection.py:exclusion_reader": {}
    },
    "modified_testcases/test_selection.py:TestExclusionReader:test_invalid_regex": {
      "stestr/selection.py:exclusion_reader": {}
    },
    "modified_testcases/test_selection.py:TestConstructList:test_exclusion_list": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {
          "stestr/selection.py:include": {}
        }
      }
    },
    "modified_testcases/test_selection.py:TestConstructList:test_inclusion_exclusion_list_re": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {
          "stestr/selection.py:include": {}
        }
      }
    },
    "modified_testcases/test_selection.py:TestConstructList:test_inclusion_list": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {
          "stestr/selection.py:include": {}
        }
      }
    },
    "modified_testcases/test_selection.py:TestConstructList:test_inclusion_list_invalid_regex": {
      "stestr/selection.py:_get_regex_from_include_list": {}
    },
    "modified_testcases/test_selection.py:TestConstructList:test_invalid_exclusion_re": {
      "stestr/selection.py:construct_list": {}
    },
    "modified_testcases/test_selection.py:TestConstructList:test_overlapping_exclude_regex": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {
          "stestr/selection.py:include": {}
        }
      }
    },
    "modified_testcases/test_selection.py:TestConstructList:test_simple_exclusion_re": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {}
      }
    },
    "modified_testcases/test_selection.py:TestConstructList:test_simple_re": {
      "stestr/selection.py:construct_list": {
        "stestr/selection.py:filter_tests": {
          "stestr/selection.py:include": {}
        }
      }
    }
  }
}