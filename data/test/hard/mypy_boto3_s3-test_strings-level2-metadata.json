{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_strings",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/utils/test_strings.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\nfrom mypy_boto3_builder.utils.strings import (\n    capitalize,\n    get_anchor_link,\n    get_botocore_class_name,\n    get_class_prefix,\n    get_copyright,\n    get_pypi_link,\n    get_short_docstring,\n    get_type_def_name,\n    is_reserved,\n    textwrap,\n    xform_name,\n)\n\n\nclass TestStrings:\n    def test_get_class_prefix(self) -> None:\n        assert get_class_prefix(\"my_func\") == \"MyFunc\"\n        assert not get_class_prefix(\"\")\n        assert get_class_prefix(\"myFunc\") == \"MyFunc\"\n\n    def test_get_anchor_link(self) -> None:\n        assert get_anchor_link(\"test\") == \"test\"\n        assert get_anchor_link(\"n.ew_t est\") == \"new_t-est\"\n\n    def test_is_reserved(self) -> None:\n        assert is_reserved(\"lambda\")\n        assert is_reserved(\"List\")\n        assert is_reserved(\"dict\")\n        assert not is_reserved(\"myname\")\n\n    def test_get_short_docstring(self) -> None:\n        assert not get_short_docstring(\"\")\n        assert not get_short_docstring(\"\\n\")\n        assert get_short_docstring(\"`asd\\n:type\") == \"`asd`.\"\n        assert get_short_docstring(\"`as\u2019d\\n:type\") == \"`as'd`.\"\n        assert (\n            get_short_docstring(\"`asd <https://link>`\\n **Request syntax**::\\ntest\")\n            == \"[asd](https://link).\"\n        )\n        assert (\n            get_short_docstring(\n                \"\"\"\n                This action aborts a multipart\n                upload. After a multipart upload is aborted,\n                no additional parts can be uploaded using that upload ID. The storage\n                consumed by any previously uploaded parts will be freed. However, if\n                any part uploads are currently in progress, those part uploads might or might\n                not succeed.\n                As a result, it might be necessary to abort a given multipart upload multiple times\n                in order to completely free all storage consumed by all parts.\n\n\n                To verify that all parts have been removed, so you don't get charged\n                for the part storage, you should call the `ListParts\n                <https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListParts.html>`\n                __ action and ensure that the parts list is empty.\n                \"\"\",\n            )\n            == \"This action aborts a multipart upload.\"\n        )\n\n    def test_get_type_def_name(self) -> None:\n        assert get_type_def_name(\"MyClass\", \"my_method\") == \"MyClassMyMethodTypeDef\"\n        assert get_type_def_name(\"my_func\") == \"MyFuncTypeDef\"\n\n        with pytest.raises(TypeAnnotationError):\n            get_type_def_name()\n\n    def test_textwrap(self) -> None:\n        assert textwrap(\"test\", 12) == \"test\"\n        assert textwrap(\"test\", 2) == \"test\"\n        assert textwrap(\"te  st words\", 12) == \"te  st words\"\n        assert textwrap(\"te  st words\", 6) == \"te\\nst\\nwords\"\n        assert textwrap(\"te  stwords\", 12) == \"te  stwords\"\n        assert textwrap(\"te  stwords new\", 6) == \"te\\nstwords\\nnew\"\n        assert textwrap(\n            \"Get all items from the collection, optionally\"\n            \" with a custom page size and item count limit.\",\n        ) == (\n            \"Get all items from the collection, optionally with a custom page size and item\"\n            \"\\ncount limit.\"\n        )\n\n    def test_get_botocore_class_name(self) -> None:\n        assert get_botocore_class_name({\"serviceAbbreviation\": \"drs\"}) == \"Drs\"\n        assert (\n            get_botocore_class_name({\"serviceAbbreviation\": \"drs\", \"serviceFullName\": \"name\"})\n            == \"Drs\"\n        )\n        assert get_botocore_class_name({\"serviceFullName\": \"name\"}) == \"Name\"\n        assert get_botocore_class_name({\"serviceFullName\": \"naMe\"}) == \"NaMe\"\n        assert get_botocore_class_name({\"serviceAbbreviation\": \"RDS\"}) == \"RDS\"\n\n    def test_capitalize(self) -> None:\n        assert capitalize(\"test caps\") == \"Test caps\"\n        assert capitalize(\"test Caps\") == \"Test Caps\"\n        assert capitalize(\"TEST\") == \"TEST\"\n\n    def test_xform_name(self) -> None:\n        assert xform_name(\"test\") == \"test\"\n        assert xform_name(\"MyClass\") == \"my_class\"\n        assert xform_name(\"MyClass\", \"-\") == \"my-class\"\n        with pytest.raises(BuildInternalError):\n            xform_name(\"MyClass\", \"\")\n\n    def test_get_pypi_link(self) -> None:\n        assert get_pypi_link(\"mypy-boto3-builder\") == \"https://pypi.org/project/mypy-boto3-builder/\"\n        with pytest.raises(BuildInternalError):\n            get_pypi_link(\"\")\n\n    def test_get_copyright(self) -> None:\n        assert \"Copyright\" in get_copyright()\n",
  "GT_file_code": {
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\n\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\n\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\n\nRESERVED_NAMES: Final = {\n    *dir(typing),\n    *dir(builtins),\n    *keyword.kwlist,\n}\nAWS_LINK_RE: Final = re.compile(r\"`([^`]+\\S)\\s*<https://(\\S+)>`\\_*\")\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({\"\u2019\": \"'\", \"\u2013\": \"-\"})\n\n\ndef get_class_prefix(func_name: str) -> str:\n    \"\"\"\n    Get a valid Python class prefix from `func_name`.\n\n    Arguments:\n        func_name -- Any string.\n\n    Returns:\n        String with a class prefix.\n    \"\"\"\n    parts = [capitalize(i) for i in func_name.split(\"_\") if i]\n    return \"\".join(parts)\n\n\ndef get_anchor_link(text: str) -> str:\n    \"\"\"\n    Convert header to markdown anchor link.\n    \"\"\"\n    return text.strip().replace(\" \", \"-\").replace(\".\", \"\").lower()\n\n\ndef is_reserved(word: str) -> bool:\n    \"\"\"\n    Check whether variable name conflicts with Python reserved names.\n    \"\"\"\n    return word in RESERVED_NAMES\n\n\ndef get_short_docstring(doc: str) -> str:\n    \"\"\"\n    Create a short docstring from boto3 documentation.\n\n    Trims docstring to 300 chars.\n    Removes double and triple backticks.\n    Stops on `**Request syntax**` and `::`.\n    Ensures that backticks are closed.\n    Replaces `Text <link>` with [Text](link).\n    Wraps docstring to 80 chars.\n    \"\"\"\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f\"{doc[:DOCSTRING_MAX_LENGTH - 3]}...\"\n    result: list[str] = []\n    if not doc:\n        return \"\"\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix(\"::\")\n        if not line:\n            continue\n        if line.startswith(\":\") or line.lower().startswith(\"**request syntax**\"):\n            break\n        if \". \" in line:\n            result.append(line.split(\". \")[0])\n            break\n        result.append(line)\n        if line.endswith(\".\"):\n            break\n\n    result_str = \" \".join(result).replace(\"```\", \"`\").replace(\"``\", \"`\").replace(\"\\n\", \" \").strip()\n    return clean_artifacts(result_str)\n\n\ndef clean_artifacts(line: str) -> str:\n    \"\"\"\n    Remove common artifacts in botocre docs.\n    \"\"\"\n    if line.count(\"`\") % 2:\n        line = f\"{line}`\"\n    if line and not line.endswith(\".\"):\n        line = f\"{line}.\"\n\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n\n    if \"<https:\" in line:\n        line = AWS_LINK_RE.sub(r\"[\\g<1>](https://\\g<2>)\", line)\n        # FIXME: temporary fix for pca-connector-ad service\n        line = line.replace(\"https\\\\:\", \"https:\")\n        # FIXME: temporary fix for neptunedata service\n        line = line.replace(\"neptune-db\\\\:\", \"neptune-db:\")\n\n    return line\n\n\ndef textwrap(text: str, width: int = DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"\n    Wrap text to `width` chars.\n    \"\"\"\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(\" \", 0, width)\n            if space_index < 0:\n                space_index = line.find(\" \", width)\n\n            if space_index < 0:\n                result.append(line)\n                break\n\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n\n    return \"\\n\".join(result)\n\n\ndef get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"\n    Get Botocore class name from Service metadata.\n    \"\"\"\n    service_model = MagicMock()\n    service_model.service_name = metadata.get(\"serviceId\", \"\")\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)\n\n\ndef get_type_def_name(*parts: str) -> str:\n    \"\"\"\n    Get a valid Python TypeDef class name from `parts`.\n\n    Examples:\n        ```python\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\n        ```\n    \"\"\"\n    if not parts:\n        raise TypeAnnotationError(\"At least one part is required\")\n\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = \"\".join(parts_camelcased)\n    return f\"{name}TypeDef\"\n\n\ndef capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f\"{s[:1].upper()}{s[1:]}\"\n\n\ndef xform_name(name: str, sep: str = \"_\") -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError(\"Separator is required\")\n    return botocore_xform_name(name, sep)\n\n\ndef get_pypi_link(package_name: str) -> str:\n    \"\"\"\n    Get link to PyPI.\n    \"\"\"\n    if not package_name:\n        raise BuildInternalError(\"package_name is required\")\n    return f\"https://pypi.org/project/{package_name}/\"\n\n\ndef get_copyright() -> str:\n    \"\"\"\n    Get copyright notice.\n    \"\"\"\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f\"Copyright {now.year} Vlad Emelianov\"\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/utils/strings.py": {
      "get_class_prefix": {
        "code": "def get_class_prefix(func_name: str) -> str:\n    \"\"\"Generate a valid Python class prefix from a given function name by converting the name from snake_case to CamelCase. \n\nParameters:\n    func_name (str): A string representing the function name in snake_case format.\n\nReturns:\n    str: A string representing the class prefix in CamelCase format.\n\nThe function utilizes the `capitalize` helper function to convert each segment of the input string (split by underscores) into capitalized form and concatenates these segments. The function does not have any side effects and operates solely on the provided input.\"\"\"\n    '\\n    Get a valid Python class prefix from `func_name`.\\n\\n    Arguments:\\n        func_name -- Any string.\\n\\n    Returns:\\n        String with a class prefix.\\n    '\n    parts = [capitalize(i) for i in func_name.split('_') if i]\n    return ''.join(parts)",
        "docstring": "Generate a valid Python class prefix from a given function name by converting the name from snake_case to CamelCase. \n\nParameters:\n    func_name (str): A string representing the function name in snake_case format.\n\nReturns:\n    str: A string representing the class prefix in CamelCase format.\n\nThe function utilizes the `capitalize` helper function to convert each segment of the input string (split by underscores) into capitalized form and concatenates these segments. The function does not have any side effects and operates solely on the provided input.",
        "signature": "def get_class_prefix(func_name: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_anchor_link": {
        "code": "def get_anchor_link(text: str) -> str:\n    \"\"\"Convert a string header into a markdown-compatible anchor link. The function trims any leading or trailing whitespace from the input `text`, replaces spaces with hyphens, removes periods, and converts the entire string to lowercase to ensure it complies with markdown link formatting. \n\nParameters:\n- text (str): The input string that represents a header, which will be transformed into an anchor link.\n\nReturns:\n- str: A markdown anchor link derived from the input text.\n\nThis function does not utilize any constants from the module but interacts with the principles of markdown formatting, which are evident in other utility functions like `get_short_docstring` and `clean_artifacts`.\"\"\"\n    '\\n    Convert header to markdown anchor link.\\n    '\n    return text.strip().replace(' ', '-').replace('.', '').lower()",
        "docstring": "Convert a string header into a markdown-compatible anchor link. The function trims any leading or trailing whitespace from the input `text`, replaces spaces with hyphens, removes periods, and converts the entire string to lowercase to ensure it complies with markdown link formatting. \n\nParameters:\n- text (str): The input string that represents a header, which will be transformed into an anchor link.\n\nReturns:\n- str: A markdown anchor link derived from the input text.\n\nThis function does not utilize any constants from the module but interacts with the principles of markdown formatting, which are evident in other utility functions like `get_short_docstring` and `clean_artifacts`.",
        "signature": "def get_anchor_link(text: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "is_reserved": {
        "code": "def is_reserved(word: str) -> bool:\n    \"\"\"Check if a given word is a reserved name in Python.\n\nParameters:\n    word (str): The variable name to check for conflicts with reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nThis function checks the provided `word` against the constant `RESERVED_NAMES`, which is a set of reserved keywords, built-in names, and names from the `typing` module. This constant is defined as a `Final` variable to prevent modification and includes entries gathered from Python's builtins, reserved keywords, and typing constructs, ensuring it covers all potential conflicts with variable names in Python code.\"\"\"\n    '\\n    Check whether variable name conflicts with Python reserved names.\\n    '\n    return word in RESERVED_NAMES",
        "docstring": "Check if a given word is a reserved name in Python.\n\nParameters:\n    word (str): The variable name to check for conflicts with reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nThis function checks the provided `word` against the constant `RESERVED_NAMES`, which is a set of reserved keywords, built-in names, and names from the `typing` module. This constant is defined as a `Final` variable to prevent modification and includes entries gathered from Python's builtins, reserved keywords, and typing constructs, ensuring it covers all potential conflicts with variable names in Python code.",
        "signature": "def is_reserved(word: str) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "get_short_docstring": {
        "code": "def get_short_docstring(doc: str) -> str:\n    \"\"\"Generate a concise summary from a given Boto3 documentation string.\n\nParameters:\n    doc (str): The full documentation string to be processed.\n\nReturns:\n    str: A trimmed and formatted version of the input docstring. The output will be up to 300 characters long, with certain formatting adjustments including the removal of backticks, stopping at specific markers, and ensuring proper wrapping to a maximum of 80 characters.\n\nDependencies:\n    - Uses the constant DOCSTRING_MAX_LENGTH to determine the maximum length for the output string.\n    - Interacts with the clean_artifacts function to clean up and replace certain patterns in the processed output.\"\"\"\n    '\\n    Create a short docstring from boto3 documentation.\\n\\n    Trims docstring to 300 chars.\\n    Removes double and triple backticks.\\n    Stops on `**Request syntax**` and `::`.\\n    Ensures that backticks are closed.\\n    Replaces `Text <link>` with [Text](link).\\n    Wraps docstring to 80 chars.\\n    '\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f'{doc[:DOCSTRING_MAX_LENGTH - 3]}...'\n    result: list[str] = []\n    if not doc:\n        return ''\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix('::')\n        if not line:\n            continue\n        if line.startswith(':') or line.lower().startswith('**request syntax**'):\n            break\n        if '. ' in line:\n            result.append(line.split('. ')[0])\n            break\n        result.append(line)\n        if line.endswith('.'):\n            break\n    result_str = ' '.join(result).replace('```', '`').replace('``', '`').replace('\\n', ' ').strip()\n    return clean_artifacts(result_str)",
        "docstring": "Generate a concise summary from a given Boto3 documentation string.\n\nParameters:\n    doc (str): The full documentation string to be processed.\n\nReturns:\n    str: A trimmed and formatted version of the input docstring. The output will be up to 300 characters long, with certain formatting adjustments including the removal of backticks, stopping at specific markers, and ensuring proper wrapping to a maximum of 80 characters.\n\nDependencies:\n    - Uses the constant DOCSTRING_MAX_LENGTH to determine the maximum length for the output string.\n    - Interacts with the clean_artifacts function to clean up and replace certain patterns in the processed output.",
        "signature": "def get_short_docstring(doc: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "clean_artifacts": {
        "code": "def clean_artifacts(line: str) -> str:\n    \"\"\"Remove common artifacts in Botocore documentation strings.\n\nParameters:\n- line (str): The input string containing documentation text that may contain artifacts.\n\nReturns:\n- str: A cleaned version of the input string with the following modifications:\n  - Ensures that an odd number of backticks (`) is even by adding a closing backtick if necessary.\n  - Appends a period (.) at the end if the line does not already end with one.\n  - Replaces specific characters defined in `REPLACE_DOCSTRING_CHARS` with their corresponding replacements.\n  - Converts AWS links from `Text <https://link>` format to markdown `[Text](https://link)` format.\n\nDependencies:\n- `REPLACE_DOCSTRING_CHARS`: A constant defined as a `MappingProxyType` that maps certain characters to their replacements. This is defined outside the function as part of the module.\n- `AWS_LINK_RE`: A compiled regular expression used to identify and transform AWS link patterns within the string.\"\"\"\n    '\\n    Remove common artifacts in botocre docs.\\n    '\n    if line.count('`') % 2:\n        line = f'{line}`'\n    if line and (not line.endswith('.')):\n        line = f'{line}.'\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n    if '<https:' in line:\n        line = AWS_LINK_RE.sub('[\\\\g<1>](https://\\\\g<2>)', line)\n        line = line.replace('https\\\\:', 'https:')\n        line = line.replace('neptune-db\\\\:', 'neptune-db:')\n    return line",
        "docstring": "Remove common artifacts in Botocore documentation strings.\n\nParameters:\n- line (str): The input string containing documentation text that may contain artifacts.\n\nReturns:\n- str: A cleaned version of the input string with the following modifications:\n  - Ensures that an odd number of backticks (`) is even by adding a closing backtick if necessary.\n  - Appends a period (.) at the end if the line does not already end with one.\n  - Replaces specific characters defined in `REPLACE_DOCSTRING_CHARS` with their corresponding replacements.\n  - Converts AWS links from `Text <https://link>` format to markdown `[Text](https://link)` format.\n\nDependencies:\n- `REPLACE_DOCSTRING_CHARS`: A constant defined as a `MappingProxyType` that maps certain characters to their replacements. This is defined outside the function as part of the module.\n- `AWS_LINK_RE`: A compiled regular expression used to identify and transform AWS link patterns within the string.",
        "signature": "def clean_artifacts(line: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "textwrap": {
        "code": "def textwrap(text: str, width: int=DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"Wraps the input text to a specified width in characters, ensuring that lines do not exceed the given length. The function splits the text at spaces when possible, preserving word integrity while avoiding line breaks in the middle of words.\n\nParameters:\n- text (str): The input text to wrap.\n- width (int, optional): The maximum number of characters per line (default is DOCSTRING_LINE_LENGTH from mypy_boto3_builder.constants).\n\nReturns:\n- str: The wrapped text with line breaks added after exceeding the specified width.\n\nThe function utilizes the DOCSTRING_LINE_LENGTH constant, which defines the default wrap width and is imported from `mypy_boto3_builder.constants`. This ensures consistent line lengths across the documentation generated by the utils.\"\"\"\n    '\\n    Wrap text to `width` chars.\\n    '\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(' ', 0, width)\n            if space_index < 0:\n                space_index = line.find(' ', width)\n            if space_index < 0:\n                result.append(line)\n                break\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n    return '\\n'.join(result)",
        "docstring": "Wraps the input text to a specified width in characters, ensuring that lines do not exceed the given length. The function splits the text at spaces when possible, preserving word integrity while avoiding line breaks in the middle of words.\n\nParameters:\n- text (str): The input text to wrap.\n- width (int, optional): The maximum number of characters per line (default is DOCSTRING_LINE_LENGTH from mypy_boto3_builder.constants).\n\nReturns:\n- str: The wrapped text with line breaks added after exceeding the specified width.\n\nThe function utilizes the DOCSTRING_LINE_LENGTH constant, which defines the default wrap width and is imported from `mypy_boto3_builder.constants`. This ensures consistent line lengths across the documentation generated by the utils.",
        "signature": "def textwrap(text: str, width: int=DOCSTRING_LINE_LENGTH) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_botocore_class_name": {
        "code": "def get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"Get Botocore class name from service metadata.\n\nThis function constructs a Botocore class name based on the provided service metadata. It utilizes the `get_service_module_name` function from the Botocore library to derive the class name. The `capitalize` function is used to ensure the first letter of the class name is uppercase.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, expected to include a key \"serviceId\" for the service's name.\n\nReturns:\n    str: The capitalized Botocore class name derived from the service name.\n\nDependencies:\n    - `MagicMock`: Used to create a mock object for the service model.\n    - `get_service_module_name`: A function from Botocore that retrieves the module name for a service.\n    - `capitalize`: A helper function in this module that capitalizes the first letter of a string.\"\"\"\n    '\\n    Get Botocore class name from Service metadata.\\n    '\n    service_model = MagicMock()\n    service_model.service_name = metadata.get('serviceId', '')\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)",
        "docstring": "Get Botocore class name from service metadata.\n\nThis function constructs a Botocore class name based on the provided service metadata. It utilizes the `get_service_module_name` function from the Botocore library to derive the class name. The `capitalize` function is used to ensure the first letter of the class name is uppercase.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, expected to include a key \"serviceId\" for the service's name.\n\nReturns:\n    str: The capitalized Botocore class name derived from the service name.\n\nDependencies:\n    - `MagicMock`: Used to create a mock object for the service model.\n    - `get_service_module_name`: A function from Botocore that retrieves the module name for a service.\n    - `capitalize`: A helper function in this module that capitalizes the first letter of a string.",
        "signature": "def get_botocore_class_name(metadata: dict[str, str]) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_type_def_name": {
        "code": "def get_type_def_name(*parts: str) -> str:\n    \"\"\"Generate a valid Python TypeDef class name by combining and capitalizing provided parts.\n\nParameters:\n    *parts (str): One or more strings representing the components of the class name.\n\nReturns:\n    str: A combined class name in CamelCase followed by 'TypeDef'.\n\nRaises:\n    TypeAnnotationError: If no parts are provided.\n\nThis function utilizes the `get_class_prefix` function to capitalize each part of the input. The resulting name is constructed by concatenating the capitalized parts and appending 'TypeDef', creating a standard naming convention for type definitions in the codebase.\"\"\"\n    '\\n    Get a valid Python TypeDef class name from `parts`.\\n\\n    Examples:\\n        ```python\\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\\n        ```\\n    '\n    if not parts:\n        raise TypeAnnotationError('At least one part is required')\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = ''.join(parts_camelcased)\n    return f'{name}TypeDef'",
        "docstring": "Generate a valid Python TypeDef class name by combining and capitalizing provided parts.\n\nParameters:\n    *parts (str): One or more strings representing the components of the class name.\n\nReturns:\n    str: A combined class name in CamelCase followed by 'TypeDef'.\n\nRaises:\n    TypeAnnotationError: If no parts are provided.\n\nThis function utilizes the `get_class_prefix` function to capitalize each part of the input. The resulting name is constructed by concatenating the capitalized parts and appending 'TypeDef', creating a standard naming convention for type definitions in the codebase.",
        "signature": "def get_type_def_name(*parts: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "capitalize": {
        "code": "def capitalize(s: str) -> str:\n    \"\"\"Capitalize the first letter of a given string.\n\nArguments:\n    s (str): The input string to be capitalized.\n\nReturns:\n    str: The input string with the first letter converted to uppercase, while the rest of the string remains unchanged.\n\nThis function does not depend on any constants or variables defined outside its scope. It is a straightforward utility function used to format strings properly and is often utilized in the context of generating class names or identifiers, where consistent capitalization is required.\"\"\"\n    '\\n    Capitalize first letter of a string.\\n    '\n    return f'{s[:1].upper()}{s[1:]}'",
        "docstring": "Capitalize the first letter of a given string.\n\nArguments:\n    s (str): The input string to be capitalized.\n\nReturns:\n    str: The input string with the first letter converted to uppercase, while the rest of the string remains unchanged.\n\nThis function does not depend on any constants or variables defined outside its scope. It is a straightforward utility function used to format strings properly and is often utilized in the context of generating class names or identifiers, where consistent capitalization is required.",
        "signature": "def capitalize(s: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "xform_name": {
        "code": "def xform_name(name: str, sep: str='_') -> str:\n    \"\"\"Convert a given string to snake_case using a specified separator.\n\nArguments:\n    name -- Any string to be converted.\n    sep -- The separator to use; defaults to an underscore (\"_\"). It cannot be empty.\n\nReturns:\n    A string formatted in snake_case.\n\nRaises:\n    BuildInternalError: If the provided separator is empty.\n\nThis function relies on the `botocore` library's `xform_name` function to perform the actual conversion. The `botocore_xform_name` is imported from `botocore` and handles the intricacies of transforming the string format.\"\"\"\n    '\\n    Convert name to snake_case.\\n\\n    Arguments:\\n        name -- Any string.\\n        sep -- Separator.\\n    '\n    if not sep:\n        raise BuildInternalError('Separator is required')\n    return botocore_xform_name(name, sep)",
        "docstring": "Convert a given string to snake_case using a specified separator.\n\nArguments:\n    name -- Any string to be converted.\n    sep -- The separator to use; defaults to an underscore (\"_\"). It cannot be empty.\n\nReturns:\n    A string formatted in snake_case.\n\nRaises:\n    BuildInternalError: If the provided separator is empty.\n\nThis function relies on the `botocore` library's `xform_name` function to perform the actual conversion. The `botocore_xform_name` is imported from `botocore` and handles the intricacies of transforming the string format.",
        "signature": "def xform_name(name: str, sep: str='_') -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_pypi_link": {
        "code": "def get_pypi_link(package_name: str) -> str:\n    \"\"\"Get a link to the Python Package Index (PyPI) for a specified package.\n\nParameters:\n    package_name (str): The name of the package to retrieve the PyPI link for. This parameter is required.\n\nReturns:\n    str: A formatted URL string pointing to the package's page on PyPI.\n\nRaises:\n    BuildInternalError: If the provided `package_name` is an empty string or None, indicating that a valid package name is necessary to construct the link.\n\nThis function directly constructs the URL using the provided package name and serves to facilitate easy access to package documentation and installation instructions hosted on PyPI.\"\"\"\n    '\\n    Get link to PyPI.\\n    '\n    if not package_name:\n        raise BuildInternalError('package_name is required')\n    return f'https://pypi.org/project/{package_name}/'",
        "docstring": "Get a link to the Python Package Index (PyPI) for a specified package.\n\nParameters:\n    package_name (str): The name of the package to retrieve the PyPI link for. This parameter is required.\n\nReturns:\n    str: A formatted URL string pointing to the package's page on PyPI.\n\nRaises:\n    BuildInternalError: If the provided `package_name` is an empty string or None, indicating that a valid package name is necessary to construct the link.\n\nThis function directly constructs the URL using the provided package name and serves to facilitate easy access to package documentation and installation instructions hosted on PyPI.",
        "signature": "def get_pypi_link(package_name: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_copyright": {
        "code": "def get_copyright() -> str:\n    \"\"\"Get the current copyright notice for the author.\n\nThis function retrieves the current year using UTC timezone to generate a copyright statement for the author, Vlad Emelianov. It does not take any parameters and returns a string containing the copyright notice.\n\nThe function relies on the `datetime` module to obtain the current year, ensuring accurate and up-to-date copyright information.\"\"\"\n    '\\n    Get copyright notice.\\n    '\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f'Copyright {now.year} Vlad Emelianov'",
        "docstring": "Get the current copyright notice for the author.\n\nThis function retrieves the current year using UTC timezone to generate a copyright statement for the author, Vlad Emelianov. It does not take any parameters and returns a string containing the copyright notice.\n\nThe function relies on the `datetime` module to obtain the current year, ensuring accurate and up-to-date copyright information.",
        "signature": "def get_copyright() -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_strings\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 strings.py\n            \u251c\u2500\u2500 capitalize\n            \u251c\u2500\u2500 clean_artifacts\n            \u251c\u2500\u2500 get_anchor_link\n            \u251c\u2500\u2500 get_botocore_class_name\n            \u251c\u2500\u2500 get_class_prefix\n            \u251c\u2500\u2500 get_copyright\n            \u251c\u2500\u2500 get_pypi_link\n            \u251c\u2500\u2500 get_short_docstring\n            \u251c\u2500\u2500 get_type_def_name\n            \u251c\u2500\u2500 is_reserved\n            \u251c\u2500\u2500 textwrap\n            \u2514\u2500\u2500 xform_name\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module serves as a testing suite for utility functions that support string manipulation and metadata extraction within the context of AWS service integration and type generation. It validates the behavior and accuracy of core utilities, such as transforming function and class names, generating standardized identifiers, formatting and shortening documentation strings, and ensuring proper naming conventions. Additionally, it ensures the module correctly resolves reserved keywords, generates PyPI links, and formats content in alignment with internal conventions. By doing so, the module guarantees robust, consistent functionality for developers building tools or libraries that interact with AWS services, enabling streamlined development and reduced risk of errors caused by misnamed entities or malformed documentation.\n\n## FILE 1: mypy_boto3_builder/utils/strings.py\n\n- FUNCTION NAME: capitalize\n  - SIGNATURE: def capitalize(s: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nCapitalize the first letter of a given string.\n\nArguments:\n    s (str): The input string to be capitalized.\n\nReturns:\n    str: The input string with the first letter converted to uppercase, while the rest of the string remains unchanged.\n\nThis function does not depend on any constants or variables defined outside its scope. It is a straightforward utility function used to format strings properly and is often utilized in the context of generating class names or identifiers, where consistent capitalization is required.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_class_prefix\n    - mypy_boto3_builder/utils/strings.py:get_botocore_class_name\n\n- FUNCTION NAME: textwrap\n  - SIGNATURE: def textwrap(text: str, width: int=DOCSTRING_LINE_LENGTH) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nWraps the input text to a specified width in characters, ensuring that lines do not exceed the given length. The function splits the text at spaces when possible, preserving word integrity while avoiding line breaks in the middle of words.\n\nParameters:\n- text (str): The input text to wrap.\n- width (int, optional): The maximum number of characters per line (default is DOCSTRING_LINE_LENGTH from mypy_boto3_builder.constants).\n\nReturns:\n- str: The wrapped text with line breaks added after exceeding the specified width.\n\nThe function utilizes the DOCSTRING_LINE_LENGTH constant, which defines the default wrap width and is imported from `mypy_boto3_builder.constants`. This ensures consistent line lengths across the documentation generated by the utils.\n\"\"\"\n```\n\n- FUNCTION NAME: get_anchor_link\n  - SIGNATURE: def get_anchor_link(text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a string header into a markdown-compatible anchor link. The function trims any leading or trailing whitespace from the input `text`, replaces spaces with hyphens, removes periods, and converts the entire string to lowercase to ensure it complies with markdown link formatting. \n\nParameters:\n- text (str): The input string that represents a header, which will be transformed into an anchor link.\n\nReturns:\n- str: A markdown anchor link derived from the input text.\n\nThis function does not utilize any constants from the module but interacts with the principles of markdown formatting, which are evident in other utility functions like `get_short_docstring` and `clean_artifacts`.\n\"\"\"\n```\n\n- FUNCTION NAME: clean_artifacts\n  - SIGNATURE: def clean_artifacts(line: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRemove common artifacts in Botocore documentation strings.\n\nParameters:\n- line (str): The input string containing documentation text that may contain artifacts.\n\nReturns:\n- str: A cleaned version of the input string with the following modifications:\n  - Ensures that an odd number of backticks (`) is even by adding a closing backtick if necessary.\n  - Appends a period (.) at the end if the line does not already end with one.\n  - Replaces specific characters defined in `REPLACE_DOCSTRING_CHARS` with their corresponding replacements.\n  - Converts AWS links from `Text <https://link>` format to markdown `[Text](https://link)` format.\n\nDependencies:\n- `REPLACE_DOCSTRING_CHARS`: A constant defined as a `MappingProxyType` that maps certain characters to their replacements. This is defined outside the function as part of the module.\n- `AWS_LINK_RE`: A compiled regular expression used to identify and transform AWS link patterns within the string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_short_docstring\n\n- FUNCTION NAME: get_pypi_link\n  - SIGNATURE: def get_pypi_link(package_name: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a link to the Python Package Index (PyPI) for a specified package.\n\nParameters:\n    package_name (str): The name of the package to retrieve the PyPI link for. This parameter is required.\n\nReturns:\n    str: A formatted URL string pointing to the package's page on PyPI.\n\nRaises:\n    BuildInternalError: If the provided `package_name` is an empty string or None, indicating that a valid package name is necessary to construct the link.\n\nThis function directly constructs the URL using the provided package name and serves to facilitate easy access to package documentation and installation instructions hosted on PyPI.\n\"\"\"\n```\n\n- FUNCTION NAME: get_botocore_class_name\n  - SIGNATURE: def get_botocore_class_name(metadata: dict[str, str]) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet Botocore class name from service metadata.\n\nThis function constructs a Botocore class name based on the provided service metadata. It utilizes the `get_service_module_name` function from the Botocore library to derive the class name. The `capitalize` function is used to ensure the first letter of the class name is uppercase.\n\nParameters:\n    metadata (dict[str, str]): A dictionary containing service metadata, expected to include a key \"serviceId\" for the service's name.\n\nReturns:\n    str: The capitalized Botocore class name derived from the service name.\n\nDependencies:\n    - `MagicMock`: Used to create a mock object for the service model.\n    - `get_service_module_name`: A function from Botocore that retrieves the module name for a service.\n    - `capitalize`: A helper function in this module that capitalizes the first letter of a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:capitalize\n\n- FUNCTION NAME: get_copyright\n  - SIGNATURE: def get_copyright() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the current copyright notice for the author.\n\nThis function retrieves the current year using UTC timezone to generate a copyright statement for the author, Vlad Emelianov. It does not take any parameters and returns a string containing the copyright notice.\n\nThe function relies on the `datetime` module to obtain the current year, ensuring accurate and up-to-date copyright information.\n\"\"\"\n```\n\n- FUNCTION NAME: get_class_prefix\n  - SIGNATURE: def get_class_prefix(func_name: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a valid Python class prefix from a given function name by converting the name from snake_case to CamelCase. \n\nParameters:\n    func_name (str): A string representing the function name in snake_case format.\n\nReturns:\n    str: A string representing the class prefix in CamelCase format.\n\nThe function utilizes the `capitalize` helper function to convert each segment of the input string (split by underscores) into capitalized form and concatenates these segments. The function does not have any side effects and operates solely on the provided input.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_type_def_name\n    - mypy_boto3_builder/utils/strings.py:capitalize\n\n- FUNCTION NAME: is_reserved\n  - SIGNATURE: def is_reserved(word: str) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a given word is a reserved name in Python.\n\nParameters:\n    word (str): The variable name to check for conflicts with reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nThis function checks the provided `word` against the constant `RESERVED_NAMES`, which is a set of reserved keywords, built-in names, and names from the `typing` module. This constant is defined as a `Final` variable to prevent modification and includes entries gathered from Python's builtins, reserved keywords, and typing constructs, ensuring it covers all potential conflicts with variable names in Python code.\n\"\"\"\n```\n\n- FUNCTION NAME: get_type_def_name\n  - SIGNATURE: def get_type_def_name(*parts: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a valid Python TypeDef class name by combining and capitalizing provided parts.\n\nParameters:\n    *parts (str): One or more strings representing the components of the class name.\n\nReturns:\n    str: A combined class name in CamelCase followed by 'TypeDef'.\n\nRaises:\n    TypeAnnotationError: If no parts are provided.\n\nThis function utilizes the `get_class_prefix` function to capitalize each part of the input. The resulting name is constructed by concatenating the capitalized parts and appending 'TypeDef', creating a standard naming convention for type definitions in the codebase.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_class_prefix\n\n- FUNCTION NAME: xform_name\n  - SIGNATURE: def xform_name(name: str, sep: str='_') -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a given string to snake_case using a specified separator.\n\nArguments:\n    name -- Any string to be converted.\n    sep -- The separator to use; defaults to an underscore (\"_\"). It cannot be empty.\n\nReturns:\n    A string formatted in snake_case.\n\nRaises:\n    BuildInternalError: If the provided separator is empty.\n\nThis function relies on the `botocore` library's `xform_name` function to perform the actual conversion. The `botocore_xform_name` is imported from `botocore` and handles the intricacies of transforming the string format.\n\"\"\"\n```\n\n- FUNCTION NAME: get_short_docstring\n  - SIGNATURE: def get_short_docstring(doc: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a concise summary from a given Boto3 documentation string.\n\nParameters:\n    doc (str): The full documentation string to be processed.\n\nReturns:\n    str: A trimmed and formatted version of the input docstring. The output will be up to 300 characters long, with certain formatting adjustments including the removal of backticks, stopping at specific markers, and ensuring proper wrapping to a maximum of 80 characters.\n\nDependencies:\n    - Uses the constant DOCSTRING_MAX_LENGTH to determine the maximum length for the output string.\n    - Interacts with the clean_artifacts function to clean up and replace certain patterns in the processed output.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:clean_artifacts\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\nRESERVED_NAMES: Final = {*dir(typing), *dir(builtins), *keyword.kwlist}\nAWS_LINK_RE: Final = re.compile('`([^`]+\\\\S)\\\\s*<https://(\\\\S+)>`\\\\_*')\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({'\u2019': \"'\", '\u2013': '-'})"
  },
  "call_tree": {
    "tests/utils/test_strings.py:TestStrings:test_get_class_prefix": {
      "mypy_boto3_builder/utils/strings.py:get_class_prefix": {
        "mypy_boto3_builder/utils/strings.py:capitalize": {}
      }
    },
    "tests/utils/test_strings.py:TestStrings:test_get_anchor_link": {
      "mypy_boto3_builder/utils/strings.py:get_anchor_link": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_is_reserved": {
      "mypy_boto3_builder/utils/strings.py:is_reserved": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_get_short_docstring": {
      "mypy_boto3_builder/utils/strings.py:get_short_docstring": {
        "mypy_boto3_builder/utils/strings.py:clean_artifacts": {}
      }
    },
    "tests/utils/test_strings.py:TestStrings:test_get_type_def_name": {
      "mypy_boto3_builder/utils/strings.py:get_type_def_name": {
        "mypy_boto3_builder/utils/strings.py:get_class_prefix": {
          "mypy_boto3_builder/utils/strings.py:capitalize": {}
        }
      }
    },
    "tests/utils/test_strings.py:TestStrings:test_textwrap": {
      "mypy_boto3_builder/utils/strings.py:textwrap": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_get_botocore_class_name": {
      "mypy_boto3_builder/utils/strings.py:get_botocore_class_name": {
        "mypy_boto3_builder/utils/strings.py:capitalize": {}
      }
    },
    "tests/utils/test_strings.py:TestStrings:test_capitalize": {
      "mypy_boto3_builder/utils/strings.py:capitalize": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_xform_name": {
      "mypy_boto3_builder/utils/strings.py:xform_name": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_get_pypi_link": {
      "mypy_boto3_builder/utils/strings.py:get_pypi_link": {}
    },
    "tests/utils/test_strings.py:TestStrings:test_get_copyright": {
      "mypy_boto3_builder/utils/strings.py:get_copyright": {}
    }
  }
}