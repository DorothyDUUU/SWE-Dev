{
  "dir_path": "/app/elasticsearch_curator",
  "package_name": "elasticsearch_curator",
  "sample_name": "elasticsearch_curator-test_helpers_testers",
  "src_dir": "curator/",
  "test_dir": "tests/",
  "test_file": "tests/unit/test_helpers_testers.py",
  "test_code": "\"\"\"Unit tests for utils\"\"\"\nfrom unittest import TestCase\nimport pytest\nfrom unittest.mock import Mock\nfrom elastic_transport import ApiResponseMeta\nfrom elasticsearch8 import Elasticsearch\nfrom elasticsearch8.exceptions import AuthenticationException, NotFoundError\nfrom curator.exceptions import (\n     ConfigurationError, FailedExecution, MissingArgument, RepositoryException,\n     SearchableSnapshotException)\nfrom curator.helpers.testers import (\n    has_lifecycle_name, is_idx_partial, repository_exists, rollable_alias, snapshot_running,\n    validate_filters, verify_client_object, verify_repository)\n\nFAKE_FAIL = Exception('Simulated Failure')\n\nclass TestRepositoryExists(TestCase):\n    \"\"\"TestRepositoryExists\n\n    Test helpers.testers.repository_exists functionality.\n    \"\"\"\n    def test_missing_arg(self):\n        \"\"\"test_missing_arg\n\n        Should raise an exception if the repository isn't passed as an arg\n        \"\"\"\n        client = Mock()\n        with pytest.raises(MissingArgument, match=r'No value for \"repository\" provided'):\n            repository_exists(client)\n    def test_repository_in_results(self):\n        \"\"\"test_repository_in_results\n\n        Should return ``True`` if the passed repository exists\n        \"\"\"\n        client = Mock()\n        client.snapshot.get_repository.return_value = {'repo':{'foo':'bar'}}\n        assert repository_exists(client, repository=\"repo\")\n    def test_repo_not_in_results(self):\n        \"\"\"test_repo_not_in_results\n\n        Should return ``False`` if the passed repository does not exist\n        \"\"\"\n        client = Mock()\n        client.snapshot.get_repository.return_value = {'not_your_repo':{'foo':'bar'}}\n        assert not repository_exists(client, repository=\"repo\")\n\nclass TestRollableAlias(TestCase):\n    \"\"\"TestRollableAlias\n\n    Test helpers.testers.rollable_alias functionality.\n    \"\"\"\n    def test_return_false_if_no_alias(self):\n        \"\"\"test_return_false_if_no_alias\n\n        Should return ``False`` with a simulated Exception being raised\n        \"\"\"\n        err = 'simulated error'\n        client = Mock()\n        client.info.return_value = {'version': {'number': '8.3.3'} }\n        client.indices.get_alias.return_value = {}\n        client.indices.get_alias.side_effect = NotFoundError(404, err, err)\n        assert not rollable_alias(client, 'foo')\n    def test_return_false_too_many_indices(self):\n        \"\"\"test_return_false_too_many_indices\n\n        Should return ``False`` if alias associated with too many indices\n        \"\"\"\n        retval = {'index-a': {'aliases': {'foo': {}}}, 'index-b': {'aliases': {'foo': {}}}}\n        client = Mock()\n        client.info.return_value = {'version': {'number': '8.3.3'} }\n        client.indices.get_alias.return_value = retval\n        assert not rollable_alias(client, 'foo')\n    def test_return_false_non_numeric(self):\n        \"\"\"test_return_false_non_numeric\n\n        Should return ``False`` if index name doesn't end in rollable digits\n        \"\"\"\n        retval = {'index-a': {'aliases': {'foo': {}}}}\n        client = Mock()\n        client.info.return_value = {'version': {'number': '8.3.3'} }\n        client.indices.get_alias.return_value = retval\n        assert not rollable_alias(client, 'foo')\n    def test_return_true_two_digits(self):\n        \"\"\"test_return_true_two_digits\n\n        Should return ``True`` if the index ends in rollable digits\n        \"\"\"\n        retval = {'index-00001': {'aliases': {'foo': {}}}}\n        client = Mock()\n        client.info.return_value = {'version': {'number': '8.3.3'} }\n        client.indices.get_alias.return_value = retval\n        assert rollable_alias(client, 'foo')\n    def test_return_true_hyphenated(self):\n        \"\"\"test_return_true_hyphenated\n\n        Should return ``True`` if the index has a rollable, hyphenated name\n        \"\"\"\n        retval = {'index-2017.03.07-1': {'aliases': {'foo': {}}}}\n        client = Mock()\n        client.info.return_value = {'version': {'number': '8.3.3'} }\n        client.indices.get_alias.return_value = retval\n        assert rollable_alias(client, 'foo')\n\nclass TestSnapshotRunning(TestCase):\n    \"\"\"TestSnapshotRunning\n\n    Test helpers.testers.snapshot_running functionality\n    \"\"\"\n    # :pylint disable=line-too-long\n    def test_true(self):\n        \"\"\"test_true\n\n        Should return ``True`` when a snapshot is in progress/running.\n        \"\"\"\n        client = Mock()\n        client.snapshot.status.return_value = {'snapshots': ['running']}\n        # self.assertTrue(snapshot_running(client))\n        assert snapshot_running(client)\n    def test_false(self):\n        \"\"\"test_False\n\n        Should return ``False`` when a snapshot is not in progress/running.\n        \"\"\"\n        client = Mock()\n        client.snapshot.status.return_value = {'snapshots': []}\n        # self.assertFalse(snapshot_running(client))\n        assert not snapshot_running(client)\n    def test_raises_exception(self):\n        \"\"\"test_raises_exception\n\n        Should raise a ``FailedExecution`` exception when an exception happens upstream\n        \"\"\"\n        client = Mock()\n        client.snapshot.status.return_value = {'snapshots': []}\n        client.snapshot.status.side_effect = FAKE_FAIL\n        # self.assertRaises(FailedExecution, snapshot_running, client)\n        with pytest.raises(FailedExecution, match=r'Rerun with loglevel DEBUG'):\n            snapshot_running(client)\n\nclass TestValidateFilters(TestCase):\n    \"\"\"TestValidateFilters\n\n    Test helpers.testers.validate_filters functionality.\n    \"\"\"\n    def test_snapshot_with_index_filter(self):\n        \"\"\"test_snapshot_with_index_filter\n\n        Should raise ConfigurationError with improper filter for filtertype\n        In this case, an index filtertype (``kibana``) for the ``delete_snapshots`` filter\n        \"\"\"\n        with pytest.raises(ConfigurationError, match=r'filtertype is not compatible with action'):\n            validate_filters('delete_snapshots', [{'filtertype': 'kibana'}])\n    def test_index_with_snapshot_filter(self):\n        \"\"\"test_index_with_snapshot_filter\n\n        Should raise ConfigurationError with improper filter for filtertype\n        In this case, a snapshot filtertype (``state``) for the ``delete_indices`` filter\n        \"\"\"\n        with pytest.raises(ConfigurationError, match=r'filtertype is not compatible with action'):\n            validate_filters('delete_indices', [{'filtertype': 'state', 'state': 'SUCCESS'}])\n\nclass TestVerifyClientObject(TestCase):\n    \"\"\"TestVerifyClientObject\n\n    Test helpers.testers.verify_client_object functionality.\n    \"\"\"\n    def test_is_client_object(self):\n        \"\"\"test_is_client_object\n\n        Should return a ``None`` value for a valid client object.\n        \"\"\"\n        test = Elasticsearch(hosts=[\"http://127.0.0.1:9200\"])\n        assert None is verify_client_object(test)\n\n    def test_is_not_client_object(self):\n        \"\"\"test_is_not_client_object\n\n        Should raise a ``TypeError`` exception with an invalid client object.\n        \"\"\"\n        test = 'not a client object'\n        with pytest.raises(TypeError, match=r'Not a valid client object'):\n            verify_client_object(test)\n\nclass TestVerifyRepository(TestCase):\n    \"\"\"TestVerifyRepository\n\n    Test helpers.testers.verify_repository functionality\n    \"\"\"\n    VERIFIED_NODES = {'nodes': {'nodeid1': {'name': 'node1'}, 'nodeid2': {'name': 'node2'}}}\n    REPO_NAME = 'repo_name'\n    def test_passing(self):\n        \"\"\"test_passing\n\n        Should return ``None`` and raise no Exception on success\n        \"\"\"\n        client = Mock()\n        client.snapshot.verify_repository.return_value = self.VERIFIED_NODES\n        assert None is verify_repository(client, repository=self.REPO_NAME)\n    def test_raises_404(self):\n        \"\"\"test_raises_404\n\n        Should raise ``RepositoryException`` when a 404 ``TransportError`` raises first\n        \"\"\"\n        client = Mock()\n        client.snapshot.verify_repository.return_value = self.VERIFIED_NODES\n        # 5 positional args for meta: status, http_version, headers, duration, node\n        meta = ApiResponseMeta(404, '1.1', {}, 0.01, None)\n        body = f'[{self.REPO_NAME}] missing'\n        msg = 'repository_missing_exception'\n        # 3 positional args for NotFoundError: message, meta, body\n        effect = NotFoundError(msg, meta, body)\n        client.snapshot.verify_repository.side_effect = effect\n        with pytest.raises(RepositoryException, match=r'Repository \"repo_name\" not found'):\n            verify_repository(client, repository=self.REPO_NAME)\n    def test_raises_401(self):\n        \"\"\"test_raises_401\n\n        Should raise ``RepositoryException`` when a 401 AuthenticationException raises first\n        \"\"\"\n        client = Mock()\n        client.snapshot.verify_repository.return_value = self.VERIFIED_NODES\n        # 5 positional args for meta: status, http_version, headers, duration, node\n        meta = ApiResponseMeta(401, '1.1', {}, 0.01, None)\n        body = 'No authentication'\n        msg = 'authentication error'\n        # 3 positional args for NotFoundError: message, meta, body\n        effect = AuthenticationException(msg, meta, body)\n        client.snapshot.verify_repository.side_effect = effect\n        with pytest.raises(RepositoryException, match=r'Got a 401 response from Elasticsearch'):\n            verify_repository(client, repository=self.REPO_NAME)\n    def test_raises_other(self):\n        \"\"\"test_raises_other\n\n        Should raise ``RepositoryException`` when any other Exception raises first\n        \"\"\"\n        client = Mock()\n        client.snapshot.verify_repository.return_value = self.VERIFIED_NODES\n        client.snapshot.verify_repository.side_effect = FAKE_FAIL\n        with pytest.raises(RepositoryException, match=r'Failed to verify'):\n            verify_repository(client, repository=self.REPO_NAME)\n\nclass TestHasLifecycleName(TestCase):\n    \"\"\"TestHasLifecycleName\n\n    Test helpers.testers.has_lifecycle_name functionality\n    \"\"\"\n    def test_has_lifecycle_name(self):\n        \"\"\"test_has_lifecycle_name\"\"\"\n        testval = {'lifecycle': {'name': 'ilm_policy'}}\n        assert has_lifecycle_name(testval)\n    def test_has_no_lifecycle_name(self):\n        \"\"\"test_has_no_lifecycle_name\"\"\"\n        testval = {'lifecycle': {'nothere': 'nope'}}\n        assert not has_lifecycle_name(testval)\n\nclass TestIsIdxPartial(TestCase):\n    \"\"\"TestIsIdxPartial\n\n    Test helpers.testers.is_idx_partial functionality\n    \"\"\"\n    def test_is_idx_partial(self):\n        \"\"\"test_is_idx_partial\"\"\"\n        testval = {'store': {'snapshot': {'partial': True}}}\n        assert is_idx_partial(testval)\n    def test_is_idx_partial_false1(self):\n        \"\"\"test_is_idx_partial_false1\"\"\"\n        testval = {'store': {'snapshot': {'partial': False}}}\n        assert not is_idx_partial(testval)\n    def test_is_idx_partial_false2(self):\n        \"\"\"test_is_idx_partial_false2\"\"\"\n        testval = {'store': {'snapshot': {'nothere': 'nope'}}}\n        assert not is_idx_partial(testval)\n    def test_is_idx_partial_raises1(self):\n        \"\"\"test_is_idx_partial_raises1\"\"\"\n        testval = {'store': {'nothere': 'nope'}}\n        with pytest.raises(SearchableSnapshotException, match='not a mounted searchable snapshot'):\n            is_idx_partial(testval)\n    def test_is_idx_partial_raises2(self):\n        \"\"\"test_is_idx_partial_raises2\"\"\"\n        testval = {'nothere': 'nope'}\n        with pytest.raises(SearchableSnapshotException, match='not a mounted searchable snapshot'):\n            is_idx_partial(testval)\n",
  "GT_file_code": {
    "curator/helpers/testers.py": "\"\"\"Utility functions that get things\"\"\"\n\nimport logging\nfrom voluptuous import Schema\nfrom elasticsearch8 import Elasticsearch\nfrom elasticsearch8.exceptions import NotFoundError\nfrom es_client.helpers.schemacheck import SchemaCheck\nfrom es_client.helpers.utils import prune_nones\nfrom curator.helpers.getters import get_repository, get_write_index\nfrom curator.exceptions import (\n    ConfigurationError,\n    MissingArgument,\n    RepositoryException,\n    SearchableSnapshotException,\n)\nfrom curator.defaults.settings import (\n    index_filtertypes,\n    snapshot_actions,\n    snapshot_filtertypes,\n)\nfrom curator.validators import actions, options\nfrom curator.validators.filter_functions import validfilters\nfrom curator.helpers.utils import report_failure\n\n\ndef has_lifecycle_name(idx_settings):\n    \"\"\"\n    :param idx_settings: The settings for an index being tested\n    :type idx_settings: dict\n\n    :returns: ``True`` if a lifecycle name exists in settings, else ``False``\n    :rtype: bool\n    \"\"\"\n    if 'lifecycle' in idx_settings:\n        if 'name' in idx_settings['lifecycle']:\n            return True\n    return False\n\n\ndef is_idx_partial(idx_settings):\n    \"\"\"\n    :param idx_settings: The settings for an index being tested\n    :type idx_settings: dict\n\n    :returns: ``True`` if store.snapshot.partial exists in settings, else ``False``\n    :rtype: bool\n    \"\"\"\n    if 'store' in idx_settings:\n        if 'snapshot' in idx_settings['store']:\n            if 'partial' in idx_settings['store']['snapshot']:\n                if idx_settings['store']['snapshot']['partial']:\n                    return True\n                # store.snapshot.partial exists but is False -- Not a frozen tier mount\n                return False\n            # store.snapshot exists, but partial isn't there --\n            # Possibly a cold tier mount\n            return False\n        raise SearchableSnapshotException('Index not a mounted searchable snapshot')\n    raise SearchableSnapshotException('Index not a mounted searchable snapshot')\n\n\ndef ilm_policy_check(client, alias):\n    \"\"\"Test if alias is associated with an ILM policy\n\n    Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_settings`\n\n    :param client: A client connection object\n    :param alias: The alias name\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type alias: str\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    # alias = action_obj.options['name']\n    write_index = get_write_index(client, alias)\n    try:\n        idx_settings = client.indices.get_settings(index=write_index)\n        if 'name' in idx_settings[write_index]['settings']['index']['lifecycle']:\n            # logger.info('Alias %s is associated with ILM policy.', alias)\n            # logger.info('Skipping action %s because allow_ilm_indices is false.', idx)\n            return True\n    except KeyError:\n        logger.debug('No ILM policies associated with %s', alias)\n    return False\n\n\ndef repository_exists(client, repository=None):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n    :param client: A client connection object\n    :param repository: The Elasticsearch snapshot repository to use\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type repository: str\n\n    :returns: ``True`` if ``repository`` exists, else ``False``\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    if not repository:\n        raise MissingArgument('No value for \"repository\" provided')\n    try:\n        test_result = get_repository(client, repository)\n        if repository in test_result:\n            logger.debug(\"Repository %s exists.\", repository)\n            response = True\n        else:\n            logger.debug(\"Repository %s not found...\", repository)\n            response = False\n    # pylint: disable=broad-except\n    except Exception as err:\n        logger.debug('Unable to find repository \"%s\": Error: %s', repository, err)\n        response = False\n    return response\n\n\ndef rollable_alias(client, alias):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_alias`\n\n    :param client: A client connection object\n    :param alias: An Elasticsearch alias\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type alias: str\n\n\n    :returns: ``True`` or ``False`` depending on whether ``alias`` is an alias that\n        points to an index that can be used by the ``_rollover`` API.\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    try:\n        response = client.indices.get_alias(name=alias)\n    except NotFoundError:\n        logger.error('Alias \"%s\" not found.', alias)\n        return False\n    # Response should be like:\n    # {'there_should_be_only_one': {'aliases': {'value of \"alias\" here': {}}}}\n    # where 'there_should_be_only_one' is a single index name that ends in a number,\n    # and 'value of \"alias\" here' reflects the value of the passed parameter, except\n    # where the ``is_write_index`` setting makes it possible to have more than one\n    # index associated with a rollover index\n    for idx in response:\n        if 'is_write_index' in response[idx]['aliases'][alias]:\n            if response[idx]['aliases'][alias]['is_write_index']:\n                return True\n    # implied ``else``: If not ``is_write_index``, it has to fit the following criteria:\n    if len(response) > 1:\n        logger.error(\n            '\"alias\" must only reference one index, but points to %s', response\n        )\n        return False\n    index = list(response.keys())[0]\n    rollable = False\n    # In order for `rollable` to be True, the last 2 digits of the index\n    # must be digits, or a hyphen followed by a digit.\n    # NOTE: This is not a guarantee that the rest of the index name is\n    # necessarily correctly formatted.\n    if index[-2:][1].isdigit():\n        if index[-2:][0].isdigit():\n            rollable = True\n        elif index[-2:][0] == '-':\n            rollable = True\n    return rollable\n\n\ndef snapshot_running(client):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n    Return ``True`` if a snapshot is in progress, and ``False`` if not\n\n    :param client: A client connection object\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n    :rtype: bool\n    \"\"\"\n    try:\n        status = client.snapshot.status()['snapshots']\n    # pylint: disable=broad-except\n    except Exception as exc:\n        report_failure(exc)\n    # We will only accept a positively identified False.  Anything else is\n    # suspect. That's why this statement, rather than just ``return status``\n    # pylint: disable=simplifiable-if-expression\n    return False if not status else True\n\n\ndef validate_actions(data):\n    \"\"\"\n    Validate the ``actions`` configuration dictionary, as imported from actions.yml,\n    for example.\n\n    :param data: The configuration dictionary\n\n    :type data: dict\n\n    :returns: The validated and sanitized configuration dictionary.\n    :rtype: dict\n    \"\"\"\n    # data is the ENTIRE schema...\n    clean_config = {}\n    # Let's break it down into smaller chunks...\n    # First, let's make sure it has \"actions\" as a key, with a subdictionary\n    root = SchemaCheck(data, actions.root(), 'Actions File', 'root').result()\n    # We've passed the first step.  Now let's iterate over the actions...\n    for action_id in root['actions']:\n        # Now, let's ensure that the basic action structure is correct, with\n        # the proper possibilities for 'action'\n        action_dict = root['actions'][action_id]\n        loc = f'Action ID \"{action_id}\"'\n        valid_structure = SchemaCheck(\n            action_dict, actions.structure(action_dict, loc), 'structure', loc\n        ).result()\n        # With the basic structure validated, now we extract the action name\n        current_action = valid_structure['action']\n        # And let's update the location with the action.\n        loc = f'Action ID \"{action_id}\", action \"{current_action}\"'\n        clean_options = SchemaCheck(\n            prune_nones(valid_structure['options']),\n            options.get_schema(current_action),\n            'options',\n            loc,\n        ).result()\n        clean_config[action_id] = {\n            'action': current_action,\n            'description': valid_structure['description'],\n            'options': clean_options,\n        }\n        if current_action == 'alias':\n            add_remove = {}\n            for k in ['add', 'remove']:\n                if k in valid_structure:\n                    current_filters = SchemaCheck(\n                        valid_structure[k]['filters'],\n                        Schema(validfilters(current_action, location=loc)),\n                        f'\"{k}\" filters',\n                        f'{loc}, \"filters\"',\n                    ).result()\n                    add_remove.update(\n                        {\n                            k: {\n                                'filters': SchemaCheck(\n                                    current_filters,\n                                    Schema(validfilters(current_action, location=loc)),\n                                    'filters',\n                                    f'{loc}, \"{k}\", \"filters\"',\n                                ).result()\n                            }\n                        }\n                    )\n            # Add/Remove here\n            clean_config[action_id].update(add_remove)\n        elif current_action in ['cluster_routing', 'create_index', 'rollover']:\n            # neither cluster_routing nor create_index should have filters\n            pass\n        else:  # Filters key only appears in non-alias actions\n            valid_filters = SchemaCheck(\n                valid_structure['filters'],\n                Schema(validfilters(current_action, location=loc)),\n                'filters',\n                f'{loc}, \"filters\"',\n            ).result()\n            clean_filters = validate_filters(current_action, valid_filters)\n            clean_config[action_id].update({'filters': clean_filters})\n        # This is a special case for remote reindex\n        if current_action == 'reindex':\n            # Check only if populated with something.\n            if 'remote_filters' in valid_structure['options']:\n                valid_filters = SchemaCheck(\n                    valid_structure['options']['remote_filters'],\n                    Schema(validfilters(current_action, location=loc)),\n                    'filters',\n                    f'{loc}, \"filters\"',\n                ).result()\n                clean_remote_filters = validate_filters(current_action, valid_filters)\n                clean_config[action_id]['options'].update(\n                    {'remote_filters': clean_remote_filters}\n                )\n\n    # if we've gotten this far without any Exceptions raised, it's valid!\n    return {'actions': clean_config}\n\n\ndef validate_filters(action, myfilters):\n    \"\"\"\n    Validate that myfilters are appropriate for the action type, e.g. no\n    index filters applied to a snapshot list.\n\n    :param action: An action name\n    :param myfilters: A list of filters to test.\n\n    :type action: str\n    :type myfilters: list\n\n    :returns: Validated list of filters\n    :rtype: list\n    \"\"\"\n    # Define which set of filtertypes to use for testing\n    if action in snapshot_actions():\n        filtertypes = snapshot_filtertypes()\n    else:\n        filtertypes = index_filtertypes()\n    for fil in myfilters:\n        if fil['filtertype'] not in filtertypes:\n            raise ConfigurationError(\n                f\"\\\"{fil['filtertype']}\\\" filtertype is not compatible with \"\n                f\"action \\\"{action}\\\"\"\n            )\n    # If we get to this point, we're still valid.  Return the original list\n    return myfilters\n\n\ndef verify_client_object(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.elasticsearch.Elasticsearch`\n\n    :returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\n        client object and raise a :py:exc:`TypeError` exception if it is not.\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    # Ignore mock type for testing\n    if str(type(test)) == \"<class 'unittest.mock.Mock'>\":\n        pass\n    elif not isinstance(test, Elasticsearch):\n        msg = f'Not a valid client object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)\n\n\ndef verify_index_list(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.curator.IndexList`\n\n    :returns: ``None`` if ``test`` is a proper :py:class:`~.curator.indexlist.IndexList`\n        object, else raise a :py:class:`TypeError` exception.\n    :rtype: None\n    \"\"\"\n    # It breaks if this import isn't local to this function:\n    # ImportError: cannot import name 'IndexList' from partially initialized module\n    # 'curator.indexlist' (most likely due to a circular import)\n    # pylint: disable=import-outside-toplevel\n    from curator.indexlist import IndexList\n\n    logger = logging.getLogger(__name__)\n    if not isinstance(test, IndexList):\n        msg = f'Not a valid IndexList object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)\n\n\ndef verify_repository(client, repository=None):\n    \"\"\"\n    Do :py:meth:`~.elasticsearch.snapshot.verify_repository` call. If it fails, raise a\n    :py:exc:`~.curator.exceptions.RepositoryException`.\n\n    :param client: A client connection object\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :param repository: A repository name\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type repository: str\n\n    :rtype: None\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    try:\n        nodes = client.snapshot.verify_repository(name=repository)['nodes']\n        logger.debug('All nodes can write to the repository')\n        logger.debug('Nodes with verified repository access: %s', nodes)\n    except Exception as err:\n        try:\n            if err.status_code == 404:\n                msg = (\n                    f'--- Repository \"{repository}\" not found. Error: '\n                    f'{err.meta.status}, {err.error}'\n                )\n            else:\n                msg = (\n                    f'--- Got a {err.meta.status} response from Elasticsearch.  '\n                    f'Error message: {err.error}'\n                )\n        except AttributeError:\n            msg = f'--- Error message: {err}'.format()\n        report = f'Failed to verify all nodes have repository access: {msg}'\n        raise RepositoryException(report) from err\n\n\ndef verify_snapshot_list(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.curator.SnapshotList`\n\n    :returns: ``None`` if ``test`` is a proper\n        :py:class:`~.curator.snapshotlist.SnapshotList` object, else raise a\n        :py:class:`TypeError` exception.\n    :rtype: None\n    \"\"\"\n    # It breaks if this import isn't local to this function:\n    # ImportError: cannot import name 'SnapshotList' from partially initialized module\n    # 'curator.snapshotlist' (most likely due to a circular import)\n    # pylint: disable=import-outside-toplevel\n    from curator.snapshotlist import SnapshotList\n\n    logger = logging.getLogger(__name__)\n    if not isinstance(test, SnapshotList):\n        msg = f'Not a valid SnapshotList object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)\n",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\"\n"
  },
  "GT_src_dict": {
    "curator/helpers/testers.py": {
      "has_lifecycle_name": {
        "code": "def has_lifecycle_name(idx_settings):\n    \"\"\"Check if the provided index settings include a lifecycle name.\n\n:param idx_settings: A dictionary containing the settings for an Elasticsearch index.\n:type idx_settings: dict\n\n:returns: ``True`` if the index settings contain a lifecycle configuration with a name, otherwise ``False``.\n:rtype: bool\n\nThe function interacts with the lifecycle settings of the index, specifically looking for the presence of a key `lifecycle` that contains a `name`. This is part of managing index lifecycle policies, which govern the automated actions that can be taken on indices over time.\"\"\"\n    '\\n    :param idx_settings: The settings for an index being tested\\n    :type idx_settings: dict\\n\\n    :returns: ``True`` if a lifecycle name exists in settings, else ``False``\\n    :rtype: bool\\n    '\n    if 'lifecycle' in idx_settings:\n        if 'name' in idx_settings['lifecycle']:\n            return True\n    return False",
        "docstring": "Check if the provided index settings include a lifecycle name.\n\n:param idx_settings: A dictionary containing the settings for an Elasticsearch index.\n:type idx_settings: dict\n\n:returns: ``True`` if the index settings contain a lifecycle configuration with a name, otherwise ``False``.\n:rtype: bool\n\nThe function interacts with the lifecycle settings of the index, specifically looking for the presence of a key `lifecycle` that contains a `name`. This is part of managing index lifecycle policies, which govern the automated actions that can be taken on indices over time.",
        "signature": "def has_lifecycle_name(idx_settings):",
        "type": "Function",
        "class_signature": null
      },
      "is_idx_partial": {
        "code": "def is_idx_partial(idx_settings):\n    \"\"\"Checks whether the given index settings indicate that the index is a mounted searchable snapshot with a partial snapshot.\n\n:param idx_settings: A dictionary containing the index settings to verify.\n:type idx_settings: dict\n\n:returns: ``True`` if the 'store.snapshot.partial' setting exists and is set to ``True``, indicating that the index can receive writes in a partial snapshot; otherwise, returns ``False`` if the setting exists but is ``False``, or if the 'partial' setting is not present. Raises a `SearchableSnapshotException` if the index is not a mounted searchable snapshot.\n\n:raises SearchableSnapshotException: Indicates that the provided index settings do not correspond to a mounted searchable snapshot.\n\nThis function interacts with the 'store.snapshot.partial' key within the index settings to determine the snapshot state. It is used within other functions that require knowledge of the index's snapshot status.\"\"\"\n    '\\n    :param idx_settings: The settings for an index being tested\\n    :type idx_settings: dict\\n\\n    :returns: ``True`` if store.snapshot.partial exists in settings, else ``False``\\n    :rtype: bool\\n    '\n    if 'store' in idx_settings:\n        if 'snapshot' in idx_settings['store']:\n            if 'partial' in idx_settings['store']['snapshot']:\n                if idx_settings['store']['snapshot']['partial']:\n                    return True\n                return False\n            return False\n        raise SearchableSnapshotException('Index not a mounted searchable snapshot')\n    raise SearchableSnapshotException('Index not a mounted searchable snapshot')",
        "docstring": "Checks whether the given index settings indicate that the index is a mounted searchable snapshot with a partial snapshot.\n\n:param idx_settings: A dictionary containing the index settings to verify.\n:type idx_settings: dict\n\n:returns: ``True`` if the 'store.snapshot.partial' setting exists and is set to ``True``, indicating that the index can receive writes in a partial snapshot; otherwise, returns ``False`` if the setting exists but is ``False``, or if the 'partial' setting is not present. Raises a `SearchableSnapshotException` if the index is not a mounted searchable snapshot.\n\n:raises SearchableSnapshotException: Indicates that the provided index settings do not correspond to a mounted searchable snapshot.\n\nThis function interacts with the 'store.snapshot.partial' key within the index settings to determine the snapshot state. It is used within other functions that require knowledge of the index's snapshot status.",
        "signature": "def is_idx_partial(idx_settings):",
        "type": "Function",
        "class_signature": null
      },
      "repository_exists": {
        "code": "def repository_exists(client, repository=None):\n    \"\"\"Check if a specified Elasticsearch snapshot repository exists.\n\nThis function attempts to verify the existence of a snapshot repository using the provided Elasticsearch client. It raises a `MissingArgument` exception if no repository name is provided. If an exception occurs during the check, it logs the error and returns `False`.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch cluster.\n- repository (str): The name of the snapshot repository to check.\n\nReturns:\n- bool: `True` if the specified repository exists, otherwise `False`.\n\nDependencies:\n- Utilizes the `get_repository` function from the `curator.helpers.getters` module to fetch repository information.\n- Logs messages using the standard Python `logging` library to provide feedback on the repository check process.\n- Raises `MissingArgument` if `repository` is not provided.\"\"\"\n    '\\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\\n\\n    :param client: A client connection object\\n    :param repository: The Elasticsearch snapshot repository to use\\n\\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n    :type repository: str\\n\\n    :returns: ``True`` if ``repository`` exists, else ``False``\\n    :rtype: bool\\n    '\n    logger = logging.getLogger(__name__)\n    if not repository:\n        raise MissingArgument('No value for \"repository\" provided')\n    try:\n        test_result = get_repository(client, repository)\n        if repository in test_result:\n            logger.debug('Repository %s exists.', repository)\n            response = True\n        else:\n            logger.debug('Repository %s not found...', repository)\n            response = False\n    except Exception as err:\n        logger.debug('Unable to find repository \"%s\": Error: %s', repository, err)\n        response = False\n    return response",
        "docstring": "Check if a specified Elasticsearch snapshot repository exists.\n\nThis function attempts to verify the existence of a snapshot repository using the provided Elasticsearch client. It raises a `MissingArgument` exception if no repository name is provided. If an exception occurs during the check, it logs the error and returns `False`.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch cluster.\n- repository (str): The name of the snapshot repository to check.\n\nReturns:\n- bool: `True` if the specified repository exists, otherwise `False`.\n\nDependencies:\n- Utilizes the `get_repository` function from the `curator.helpers.getters` module to fetch repository information.\n- Logs messages using the standard Python `logging` library to provide feedback on the repository check process.\n- Raises `MissingArgument` if `repository` is not provided.",
        "signature": "def repository_exists(client, repository=None):",
        "type": "Function",
        "class_signature": null
      },
      "rollable_alias": {
        "code": "def rollable_alias(client, alias):\n    \"\"\"Determines if a given Elasticsearch alias points to an index that can be used\nby the `_rollover` API.\n\nThis function interacts with the Elasticsearch client to retrieve alias information\nand checks whether the specified alias is associated with a single index that meets\nthe criteria for rollover. Specifically, it evaluates the alias's write index status \nand the naming conventions of the associated index.\n\nParameters:\n- client (Elasticsearch): A client connection object used to communicate with the \n  Elasticsearch server.\n- alias (str): The name of the alias to check for rollability.\n\nReturns:\n- bool: True if the alias is valid for rollover, otherwise False.\n\nRaises:\n- NotFoundError: If the specified alias does not exist in Elasticsearch. \n\nThe function logs errors when the alias is not found or when it references multiple \nindices, ensuring that the operation is clear and debuggable.\"\"\"\n    '\\n    Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_alias`\\n\\n    :param client: A client connection object\\n    :param alias: An Elasticsearch alias\\n\\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n    :type alias: str\\n\\n\\n    :returns: ``True`` or ``False`` depending on whether ``alias`` is an alias that\\n        points to an index that can be used by the ``_rollover`` API.\\n    :rtype: bool\\n    '\n    logger = logging.getLogger(__name__)\n    try:\n        response = client.indices.get_alias(name=alias)\n    except NotFoundError:\n        logger.error('Alias \"%s\" not found.', alias)\n        return False\n    for idx in response:\n        if 'is_write_index' in response[idx]['aliases'][alias]:\n            if response[idx]['aliases'][alias]['is_write_index']:\n                return True\n    if len(response) > 1:\n        logger.error('\"alias\" must only reference one index, but points to %s', response)\n        return False\n    index = list(response.keys())[0]\n    rollable = False\n    if index[-2:][1].isdigit():\n        if index[-2:][0].isdigit():\n            rollable = True\n        elif index[-2:][0] == '-':\n            rollable = True\n    return rollable",
        "docstring": "Determines if a given Elasticsearch alias points to an index that can be used\nby the `_rollover` API.\n\nThis function interacts with the Elasticsearch client to retrieve alias information\nand checks whether the specified alias is associated with a single index that meets\nthe criteria for rollover. Specifically, it evaluates the alias's write index status \nand the naming conventions of the associated index.\n\nParameters:\n- client (Elasticsearch): A client connection object used to communicate with the \n  Elasticsearch server.\n- alias (str): The name of the alias to check for rollability.\n\nReturns:\n- bool: True if the alias is valid for rollover, otherwise False.\n\nRaises:\n- NotFoundError: If the specified alias does not exist in Elasticsearch. \n\nThe function logs errors when the alias is not found or when it references multiple \nindices, ensuring that the operation is clear and debuggable.",
        "signature": "def rollable_alias(client, alias):",
        "type": "Function",
        "class_signature": null
      },
      "snapshot_running": {
        "code": "def snapshot_running(client):\n    \"\"\"Check if a snapshot is currently in progress in Elasticsearch.\n\nThis function uses the `client` to retrieve the current status of snapshots. If any snapshots are found to be in progress, the function returns `True`; otherwise, it returns `False`. It handles exceptions by calling `report_failure` to log any errors encountered during the status check.\n\n:param client: A client connection object to interact with Elasticsearch.\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n:returns: ``True`` if a snapshot is running, and ``False`` if none are active.\n:rtype: bool\"\"\"\n    '\\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\\n\\n    Return ``True`` if a snapshot is in progress, and ``False`` if not\\n\\n    :param client: A client connection object\\n\\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n\\n    :rtype: bool\\n    '\n    try:\n        status = client.snapshot.status()['snapshots']\n    except Exception as exc:\n        report_failure(exc)\n    return False if not status else True",
        "docstring": "Check if a snapshot is currently in progress in Elasticsearch.\n\nThis function uses the `client` to retrieve the current status of snapshots. If any snapshots are found to be in progress, the function returns `True`; otherwise, it returns `False`. It handles exceptions by calling `report_failure` to log any errors encountered during the status check.\n\n:param client: A client connection object to interact with Elasticsearch.\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n:returns: ``True`` if a snapshot is running, and ``False`` if none are active.\n:rtype: bool",
        "signature": "def snapshot_running(client):",
        "type": "Function",
        "class_signature": null
      },
      "validate_filters": {
        "code": "def validate_filters(action, myfilters):\n    \"\"\"Validate that the provided list of filters is appropriate for the specified action type.\n\nThis function checks that each filter's type in `myfilters` is compatible with the given action. It utilizes the constants `snapshot_actions()` and `index_filtertypes()` to determine the valid filter types based on the action.\n\n:param action: The name of the action for which filters are being validated.\n:type action: str\n:param myfilters: A list of filters to validate, where each filter is expected to be a dictionary with a key 'filtertype'.\n:type myfilters: list\n\n:raises ConfigurationError: If any filter type in `myfilters` is not compatible with the specified action.\n\n:returns: The original list of filters if all filters are valid.\n:rtype: list\"\"\"\n    '\\n    Validate that myfilters are appropriate for the action type, e.g. no\\n    index filters applied to a snapshot list.\\n\\n    :param action: An action name\\n    :param myfilters: A list of filters to test.\\n\\n    :type action: str\\n    :type myfilters: list\\n\\n    :returns: Validated list of filters\\n    :rtype: list\\n    '\n    if action in snapshot_actions():\n        filtertypes = snapshot_filtertypes()\n    else:\n        filtertypes = index_filtertypes()\n    for fil in myfilters:\n        if fil['filtertype'] not in filtertypes:\n            raise ConfigurationError(f'\"{fil['filtertype']}\" filtertype is not compatible with action \"{action}\"')\n    return myfilters",
        "docstring": "Validate that the provided list of filters is appropriate for the specified action type.\n\nThis function checks that each filter's type in `myfilters` is compatible with the given action. It utilizes the constants `snapshot_actions()` and `index_filtertypes()` to determine the valid filter types based on the action.\n\n:param action: The name of the action for which filters are being validated.\n:type action: str\n:param myfilters: A list of filters to validate, where each filter is expected to be a dictionary with a key 'filtertype'.\n:type myfilters: list\n\n:raises ConfigurationError: If any filter type in `myfilters` is not compatible with the specified action.\n\n:returns: The original list of filters if all filters are valid.\n:rtype: list",
        "signature": "def validate_filters(action, myfilters):",
        "type": "Function",
        "class_signature": null
      },
      "verify_client_object": {
        "code": "def verify_client_object(test):\n    \"\"\"Verify that the provided object is a valid Elasticsearch client instance.\n\n:param test: The object to validate as an Elasticsearch client.\n:type test: :py:class:`~.elasticsearch.Elasticsearch` or mock object\n\n:returns: ``True`` if the object is a valid Elasticsearch client, otherwise raises \n:py:exc:`TypeError`.\n:rtype: bool\n\nThis function utilizes the `logging` module to log errors if the validation fails. \nIt checks if the `test` parameter is an instance of `Elasticsearch` from the \n`elasticsearch8` library. If the `test` is a mock object (i.e., for unit testing), \nit will not throw an error. A `TypeError` is raised if the type does not match \nexpectations, providing a message that includes the actual type passed to the function.\"\"\"\n    '\\n    :param test: The variable or object to test\\n\\n    :type test: :py:class:`~.elasticsearch.Elasticsearch`\\n\\n    :returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\\n        client object and raise a :py:exc:`TypeError` exception if it is not.\\n    :rtype: bool\\n    '\n    logger = logging.getLogger(__name__)\n    if str(type(test)) == \"<class 'unittest.mock.Mock'>\":\n        pass\n    elif not isinstance(test, Elasticsearch):\n        msg = f'Not a valid client object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)",
        "docstring": "Verify that the provided object is a valid Elasticsearch client instance.\n\n:param test: The object to validate as an Elasticsearch client.\n:type test: :py:class:`~.elasticsearch.Elasticsearch` or mock object\n\n:returns: ``True`` if the object is a valid Elasticsearch client, otherwise raises \n:py:exc:`TypeError`.\n:rtype: bool\n\nThis function utilizes the `logging` module to log errors if the validation fails. \nIt checks if the `test` parameter is an instance of `Elasticsearch` from the \n`elasticsearch8` library. If the `test` is a mock object (i.e., for unit testing), \nit will not throw an error. A `TypeError` is raised if the type does not match \nexpectations, providing a message that includes the actual type passed to the function.",
        "signature": "def verify_client_object(test):",
        "type": "Function",
        "class_signature": null
      },
      "verify_repository": {
        "code": "def verify_repository(client, repository=None):\n    \"\"\"Verifies the accessibility of an Elasticsearch snapshot repository by calling the \n`verify_repository` method on the client. If verification fails, a \n`RepositoryException` will be raised, detailing the nature of the failure.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch service.\n- repository (str, optional): The name of the repository to verify. If not provided, \n  the function will raise a MissingArgument exception.\n\nReturns:\n- None: This function does not return any value. \n\nRaises:\n- RepositoryException: If the repository cannot be verified for any reason, \n  including if it does not exist or if there is an issue with the response \n  from Elasticsearch.\n  \nDependencies:\n- The function uses the logger for debugging, logging success or failure messages. \n- It relies on `curator.exceptions.RepositoryException` to handle errors related \n  to repository verification failures.\"\"\"\n    '\\n    Do :py:meth:`~.elasticsearch.snapshot.verify_repository` call. If it fails, raise a\\n    :py:exc:`~.curator.exceptions.RepositoryException`.\\n\\n    :param client: A client connection object\\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n    :param repository: A repository name\\n\\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n    :type repository: str\\n\\n    :rtype: None\\n    '\n    logger = logging.getLogger(__name__)\n    try:\n        nodes = client.snapshot.verify_repository(name=repository)['nodes']\n        logger.debug('All nodes can write to the repository')\n        logger.debug('Nodes with verified repository access: %s', nodes)\n    except Exception as err:\n        try:\n            if err.status_code == 404:\n                msg = f'--- Repository \"{repository}\" not found. Error: {err.meta.status}, {err.error}'\n            else:\n                msg = f'--- Got a {err.meta.status} response from Elasticsearch.  Error message: {err.error}'\n        except AttributeError:\n            msg = f'--- Error message: {err}'.format()\n        report = f'Failed to verify all nodes have repository access: {msg}'\n        raise RepositoryException(report) from err",
        "docstring": "Verifies the accessibility of an Elasticsearch snapshot repository by calling the \n`verify_repository` method on the client. If verification fails, a \n`RepositoryException` will be raised, detailing the nature of the failure.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch service.\n- repository (str, optional): The name of the repository to verify. If not provided, \n  the function will raise a MissingArgument exception.\n\nReturns:\n- None: This function does not return any value. \n\nRaises:\n- RepositoryException: If the repository cannot be verified for any reason, \n  including if it does not exist or if there is an issue with the response \n  from Elasticsearch.\n  \nDependencies:\n- The function uses the logger for debugging, logging success or failure messages. \n- It relies on `curator.exceptions.RepositoryException` to handle errors related \n  to repository verification failures.",
        "signature": "def verify_repository(client, repository=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "curator/exceptions.py": {}
  },
  "dependency_dict": {
    "curator/helpers/testers.py:repository_exists": {
      "curator/helpers/getters.py": {
        "get_repository": {
          "code": "def get_repository(client, repository=''):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n    :param client: A client connection object\n    :param repository: The Elasticsearch snapshot repository to use\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type repository: str\n\n    :returns: Configuration information for ``repository``.\n    :rtype: dict\n    \"\"\"\n    try:\n        return client.snapshot.get_repository(name=repository)\n    except (es8exc.TransportError, es8exc.NotFoundError) as err:\n        msg = (\n            f'Unable to get repository {repository}.  Error: {err} Check Elasticsearch '\n            f'logs for more information.'\n        )\n        raise CuratorException(msg) from err",
          "docstring": "Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n:param client: A client connection object\n:param repository: The Elasticsearch snapshot repository to use\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n:type repository: str\n\n:returns: Configuration information for ``repository``.\n:rtype: dict",
          "signature": "def get_repository(client, repository=''):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "curator/helpers/testers.py:snapshot_running": {
      "curator/helpers/utils.py": {
        "report_failure": {
          "code": "def report_failure(exception):\n    \"\"\"\n    Raise a :py:exc:`~.curator.exceptions.FailedExecution` exception and include the original error\n    message.\n\n    :param exception: The upstream exception.\n\n    :type exception: :py:exc:Exception\n\n    :rtype: None\n    \"\"\"\n    raise FailedExecution(\n        f'Exception encountered.  Rerun with loglevel DEBUG and/or check Elasticsearch logs for'\n        f'more information. Exception: {exception}'\n    )",
          "docstring": "Raise a :py:exc:`~.curator.exceptions.FailedExecution` exception and include the original error\nmessage.\n\n:param exception: The upstream exception.\n\n:type exception: :py:exc:Exception\n\n:rtype: None",
          "signature": "def report_failure(exception):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "curator/helpers/testers.py:validate_filters": {
      "curator/defaults/settings.py": {
        "snapshot_actions": {
          "code": "def snapshot_actions():\n    \"\"\"\n    :returns: The list of supported snapshot actions: ['delete_snapshots', 'restore']\n    \"\"\"\n    return ['delete_snapshots', 'restore']",
          "docstring": ":returns: The list of supported snapshot actions: ['delete_snapshots', 'restore']",
          "signature": "def snapshot_actions():",
          "type": "Function",
          "class_signature": null
        },
        "index_filtertypes": {
          "code": "def index_filtertypes():\n    \"\"\"\n    :returns: The list of supported index filter types:\n        ['alias', 'allocated', 'age', 'closed', 'count', 'empty', 'forcemerged',\n        'ilm', 'kibana', 'none', 'opened', 'pattern', 'period', 'space',\n        'shards', 'size']\n    \"\"\"\n\n    return [\n        'alias',\n        'allocated',\n        'age',\n        'closed',\n        'count',\n        'empty',\n        'forcemerged',\n        'ilm',\n        'kibana',\n        'none',\n        'opened',\n        'pattern',\n        'period',\n        'space',\n        'shards',\n        'size',\n    ]",
          "docstring": ":returns: The list of supported index filter types:\n    ['alias', 'allocated', 'age', 'closed', 'count', 'empty', 'forcemerged',\n    'ilm', 'kibana', 'none', 'opened', 'pattern', 'period', 'space',\n    'shards', 'size']",
          "signature": "def index_filtertypes():",
          "type": "Function",
          "class_signature": null
        },
        "snapshot_filtertypes": {
          "code": "def snapshot_filtertypes():\n    \"\"\"\n    :returns: The list of supported snapshot filter types: ['age', 'count', 'none',\n        'pattern', 'period', 'state']\n    \"\"\"\n    return ['age', 'count', 'none', 'pattern', 'period', 'state']",
          "docstring": ":returns: The list of supported snapshot filter types: ['age', 'count', 'none',\n    'pattern', 'period', 'state']",
          "signature": "def snapshot_filtertypes():",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "tests/unit/test_helpers_testers.py:TestRepositoryExists:test_missing_arg": {
      "curator/helpers/testers.py:repository_exists": {}
    },
    "tests/unit/test_helpers_testers.py:TestRepositoryExists:test_repo_not_in_results": {
      "curator/helpers/testers.py:repository_exists": {
        "curator/helpers/getters.py:get_repository": {}
      }
    },
    "tests/unit/test_helpers_testers.py:TestRepositoryExists:test_repository_in_results": {
      "curator/helpers/testers.py:repository_exists": {
        "curator/helpers/getters.py:get_repository": {}
      }
    },
    "tests/unit/test_helpers_testers.py:TestRollableAlias:test_return_false_if_no_alias": {
      "curator/helpers/testers.py:rollable_alias": {}
    },
    "tests/unit/test_helpers_testers.py:TestRollableAlias:test_return_false_non_numeric": {
      "curator/helpers/testers.py:rollable_alias": {}
    },
    "tests/unit/test_helpers_testers.py:TestRollableAlias:test_return_false_too_many_indices": {
      "curator/helpers/testers.py:rollable_alias": {}
    },
    "tests/unit/test_helpers_testers.py:TestRollableAlias:test_return_true_hyphenated": {
      "curator/helpers/testers.py:rollable_alias": {}
    },
    "tests/unit/test_helpers_testers.py:TestRollableAlias:test_return_true_two_digits": {
      "curator/helpers/testers.py:rollable_alias": {}
    },
    "tests/unit/test_helpers_testers.py:TestSnapshotRunning:test_false": {
      "curator/helpers/testers.py:snapshot_running": {}
    },
    "tests/unit/test_helpers_testers.py:TestSnapshotRunning:test_raises_exception": {
      "curator/helpers/testers.py:snapshot_running": {
        "curator/helpers/utils.py:report_failure": {}
      }
    },
    "tests/unit/test_helpers_testers.py:TestSnapshotRunning:test_true": {
      "curator/helpers/testers.py:snapshot_running": {}
    },
    "tests/unit/test_helpers_testers.py:TestValidateFilters:test_index_with_snapshot_filter": {
      "curator/helpers/testers.py:validate_filters": {
        "curator/defaults/settings.py:snapshot_actions": {},
        "curator/defaults/settings.py:index_filtertypes": {}
      }
    },
    "tests/unit/test_helpers_testers.py:TestValidateFilters:test_snapshot_with_index_filter": {
      "curator/helpers/testers.py:validate_filters": {
        "curator/defaults/settings.py:snapshot_actions": {},
        "curator/defaults/settings.py:snapshot_filtertypes": {}
      }
    },
    "tests/unit/test_helpers_testers.py:TestVerifyClientObject:test_is_client_object": {
      "curator/helpers/testers.py:verify_client_object": {}
    },
    "tests/unit/test_helpers_testers.py:TestVerifyClientObject:test_is_not_client_object": {
      "curator/helpers/testers.py:verify_client_object": {}
    },
    "tests/unit/test_helpers_testers.py:TestVerifyRepository:test_passing": {
      "curator/helpers/testers.py:verify_repository": {}
    },
    "tests/unit/test_helpers_testers.py:TestVerifyRepository:test_raises_401": {
      "curator/helpers/testers.py:verify_repository": {}
    },
    "tests/unit/test_helpers_testers.py:TestVerifyRepository:test_raises_404": {
      "curator/helpers/testers.py:verify_repository": {}
    },
    "tests/unit/test_helpers_testers.py:TestVerifyRepository:test_raises_other": {
      "curator/helpers/testers.py:verify_repository": {}
    },
    "tests/unit/test_helpers_testers.py:TestHasLifecycleName:test_has_lifecycle_name": {
      "curator/helpers/testers.py:has_lifecycle_name": {}
    },
    "tests/unit/test_helpers_testers.py:TestHasLifecycleName:test_has_no_lifecycle_name": {
      "curator/helpers/testers.py:has_lifecycle_name": {}
    },
    "tests/unit/test_helpers_testers.py:TestIsIdxPartial:test_is_idx_partial": {
      "curator/helpers/testers.py:is_idx_partial": {}
    },
    "tests/unit/test_helpers_testers.py:TestIsIdxPartial:test_is_idx_partial_false1": {
      "curator/helpers/testers.py:is_idx_partial": {}
    },
    "tests/unit/test_helpers_testers.py:TestIsIdxPartial:test_is_idx_partial_false2": {
      "curator/helpers/testers.py:is_idx_partial": {}
    },
    "tests/unit/test_helpers_testers.py:TestIsIdxPartial:test_is_idx_partial_raises1": {
      "curator/helpers/testers.py:is_idx_partial": {}
    },
    "tests/unit/test_helpers_testers.py:TestIsIdxPartial:test_is_idx_partial_raises2": {
      "curator/helpers/testers.py:is_idx_partial": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_helpers_testers/elasticsearch_curator-test_helpers_testers/tests/integration/test_cli.py:TestCLIMethods:test_action_is_none": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_helpers_testers/elasticsearch_curator-test_helpers_testers/tests/integration/test_cli.py:TestCLIMethods:test_no_action": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_helpers_testers/elasticsearch_curator-test_helpers_testers/tests/integration/test_integrations.py:TestFilters:test_filter_by_alias_bad_aliases": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    }
  },
  "PRD": "# PROJECT NAME: elasticsearch_curator-test_helpers_testers\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 curator/\n    \u251c\u2500\u2500 exceptions.py\n    \u2502   \u2514\u2500\u2500 ConfigurationError.ConfigurationError\n    \u2514\u2500\u2500 helpers/\n        \u2514\u2500\u2500 testers.py\n            \u251c\u2500\u2500 has_lifecycle_name\n            \u251c\u2500\u2500 is_idx_partial\n            \u251c\u2500\u2500 repository_exists\n            \u251c\u2500\u2500 rollable_alias\n            \u251c\u2500\u2500 snapshot_running\n            \u251c\u2500\u2500 validate_filters\n            \u251c\u2500\u2500 verify_client_object\n            \u2514\u2500\u2500 verify_repository\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to provide robust validation and testing utilities for Elasticsearch interactions, ensuring the reliability and correctness of operations performed on critical elements such as repositories, aliases, snapshots, filters, lifecycle policies, and client objects. It enables verification of repository existence, lifecycle name configurations, and alias rollability while facilitating the detection of partial or incomplete index snapshots and validating client interactions with Elasticsearch. By offering detailed exception handling and validation mechanisms, it helps developers preemptively identify misconfigurations, incompatibilities, and runtime errors. This module addresses challenges in managing and verifying Elasticsearch resources, improving the stability and reliability of operations within the system.\n\n## FILE 1: curator/helpers/testers.py\n\n- FUNCTION NAME: validate_filters\n  - SIGNATURE: def validate_filters(action, myfilters):\n  - DOCSTRING: \n```python\n\"\"\"\nValidate that the provided list of filters is appropriate for the specified action type.\n\nThis function checks that each filter's type in `myfilters` is compatible with the given action. It utilizes the constants `snapshot_actions()` and `index_filtertypes()` to determine the valid filter types based on the action.\n\n:param action: The name of the action for which filters are being validated.\n:type action: str\n:param myfilters: A list of filters to validate, where each filter is expected to be a dictionary with a key 'filtertype'.\n:type myfilters: list\n\n:raises ConfigurationError: If any filter type in `myfilters` is not compatible with the specified action.\n\n:returns: The original list of filters if all filters are valid.\n:rtype: list\n\"\"\"\n```\n  - DEPENDENCIES:\n    - curator/defaults/settings.py:index_filtertypes\n    - curator/defaults/settings.py:snapshot_filtertypes\n    - curator/defaults/settings.py:snapshot_actions\n\n- FUNCTION NAME: repository_exists\n  - SIGNATURE: def repository_exists(client, repository=None):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a specified Elasticsearch snapshot repository exists.\n\nThis function attempts to verify the existence of a snapshot repository using the provided Elasticsearch client. It raises a `MissingArgument` exception if no repository name is provided. If an exception occurs during the check, it logs the error and returns `False`.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch cluster.\n- repository (str): The name of the snapshot repository to check.\n\nReturns:\n- bool: `True` if the specified repository exists, otherwise `False`.\n\nDependencies:\n- Utilizes the `get_repository` function from the `curator.helpers.getters` module to fetch repository information.\n- Logs messages using the standard Python `logging` library to provide feedback on the repository check process.\n- Raises `MissingArgument` if `repository` is not provided.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - curator/helpers/getters.py:get_repository\n\n- FUNCTION NAME: snapshot_running\n  - SIGNATURE: def snapshot_running(client):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a snapshot is currently in progress in Elasticsearch.\n\nThis function uses the `client` to retrieve the current status of snapshots. If any snapshots are found to be in progress, the function returns `True`; otherwise, it returns `False`. It handles exceptions by calling `report_failure` to log any errors encountered during the status check.\n\n:param client: A client connection object to interact with Elasticsearch.\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n:returns: ``True`` if a snapshot is running, and ``False`` if none are active.\n:rtype: bool\n\"\"\"\n```\n  - DEPENDENCIES:\n    - curator/helpers/utils.py:report_failure\n\n- FUNCTION NAME: verify_repository\n  - SIGNATURE: def verify_repository(client, repository=None):\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies the accessibility of an Elasticsearch snapshot repository by calling the \n`verify_repository` method on the client. If verification fails, a \n`RepositoryException` will be raised, detailing the nature of the failure.\n\nParameters:\n- client (Elasticsearch): A client connection object to interact with the Elasticsearch service.\n- repository (str, optional): The name of the repository to verify. If not provided, \n  the function will raise a MissingArgument exception.\n\nReturns:\n- None: This function does not return any value. \n\nRaises:\n- RepositoryException: If the repository cannot be verified for any reason, \n  including if it does not exist or if there is an issue with the response \n  from Elasticsearch.\n  \nDependencies:\n- The function uses the logger for debugging, logging success or failure messages. \n- It relies on `curator.exceptions.RepositoryException` to handle errors related \n  to repository verification failures.\n\"\"\"\n```\n\n- FUNCTION NAME: is_idx_partial\n  - SIGNATURE: def is_idx_partial(idx_settings):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks whether the given index settings indicate that the index is a mounted searchable snapshot with a partial snapshot.\n\n:param idx_settings: A dictionary containing the index settings to verify.\n:type idx_settings: dict\n\n:returns: ``True`` if the 'store.snapshot.partial' setting exists and is set to ``True``, indicating that the index can receive writes in a partial snapshot; otherwise, returns ``False`` if the setting exists but is ``False``, or if the 'partial' setting is not present. Raises a `SearchableSnapshotException` if the index is not a mounted searchable snapshot.\n\n:raises SearchableSnapshotException: Indicates that the provided index settings do not correspond to a mounted searchable snapshot.\n\nThis function interacts with the 'store.snapshot.partial' key within the index settings to determine the snapshot state. It is used within other functions that require knowledge of the index's snapshot status.\n\"\"\"\n```\n\n- FUNCTION NAME: verify_client_object\n  - SIGNATURE: def verify_client_object(test):\n  - DOCSTRING: \n```python\n\"\"\"\nVerify that the provided object is a valid Elasticsearch client instance.\n\n:param test: The object to validate as an Elasticsearch client.\n:type test: :py:class:`~.elasticsearch.Elasticsearch` or mock object\n\n:returns: ``True`` if the object is a valid Elasticsearch client, otherwise raises \n:py:exc:`TypeError`.\n:rtype: bool\n\nThis function utilizes the `logging` module to log errors if the validation fails. \nIt checks if the `test` parameter is an instance of `Elasticsearch` from the \n`elasticsearch8` library. If the `test` is a mock object (i.e., for unit testing), \nit will not throw an error. A `TypeError` is raised if the type does not match \nexpectations, providing a message that includes the actual type passed to the function.\n\"\"\"\n```\n\n- FUNCTION NAME: rollable_alias\n  - SIGNATURE: def rollable_alias(client, alias):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if a given Elasticsearch alias points to an index that can be used\nby the `_rollover` API.\n\nThis function interacts with the Elasticsearch client to retrieve alias information\nand checks whether the specified alias is associated with a single index that meets\nthe criteria for rollover. Specifically, it evaluates the alias's write index status \nand the naming conventions of the associated index.\n\nParameters:\n- client (Elasticsearch): A client connection object used to communicate with the \n  Elasticsearch server.\n- alias (str): The name of the alias to check for rollability.\n\nReturns:\n- bool: True if the alias is valid for rollover, otherwise False.\n\nRaises:\n- NotFoundError: If the specified alias does not exist in Elasticsearch. \n\nThe function logs errors when the alias is not found or when it references multiple \nindices, ensuring that the operation is clear and debuggable.\n\"\"\"\n```\n\n- FUNCTION NAME: has_lifecycle_name\n  - SIGNATURE: def has_lifecycle_name(idx_settings):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the provided index settings include a lifecycle name.\n\n:param idx_settings: A dictionary containing the settings for an Elasticsearch index.\n:type idx_settings: dict\n\n:returns: ``True`` if the index settings contain a lifecycle configuration with a name, otherwise ``False``.\n:rtype: bool\n\nThe function interacts with the lifecycle settings of the index, specifically looking for the presence of a key `lifecycle` that contains a `name`. This is part of managing index lifecycle policies, which govern the automated actions that can be taken on indices over time.\n\"\"\"\n```\n\n## FILE 2: curator/exceptions.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "curator/helpers/testers.py": "\"\"\"Utility functions that get things\"\"\"\nimport logging\nfrom voluptuous import Schema\nfrom elasticsearch8 import Elasticsearch\nfrom elasticsearch8.exceptions import NotFoundError\nfrom es_client.helpers.schemacheck import SchemaCheck\nfrom es_client.helpers.utils import prune_nones\nfrom curator.helpers.getters import get_repository, get_write_index\nfrom curator.exceptions import ConfigurationError, MissingArgument, RepositoryException, SearchableSnapshotException\nfrom curator.defaults.settings import index_filtertypes, snapshot_actions, snapshot_filtertypes\nfrom curator.validators import actions, options\nfrom curator.validators.filter_functions import validfilters\nfrom curator.helpers.utils import report_failure\n\ndef ilm_policy_check(client, alias):\n    \"\"\"Test if alias is associated with an ILM policy\n\n    Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_settings`\n\n    :param client: A client connection object\n    :param alias: The alias name\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type alias: str\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    write_index = get_write_index(client, alias)\n    try:\n        idx_settings = client.indices.get_settings(index=write_index)\n        if 'name' in idx_settings[write_index]['settings']['index']['lifecycle']:\n            return True\n    except KeyError:\n        logger.debug('No ILM policies associated with %s', alias)\n    return False\n\ndef validate_actions(data):\n    \"\"\"\n    Validate the ``actions`` configuration dictionary, as imported from actions.yml,\n    for example.\n\n    :param data: The configuration dictionary\n\n    :type data: dict\n\n    :returns: The validated and sanitized configuration dictionary.\n    :rtype: dict\n    \"\"\"\n    clean_config = {}\n    root = SchemaCheck(data, actions.root(), 'Actions File', 'root').result()\n    for action_id in root['actions']:\n        action_dict = root['actions'][action_id]\n        loc = f'Action ID \"{action_id}\"'\n        valid_structure = SchemaCheck(action_dict, actions.structure(action_dict, loc), 'structure', loc).result()\n        current_action = valid_structure['action']\n        loc = f'Action ID \"{action_id}\", action \"{current_action}\"'\n        clean_options = SchemaCheck(prune_nones(valid_structure['options']), options.get_schema(current_action), 'options', loc).result()\n        clean_config[action_id] = {'action': current_action, 'description': valid_structure['description'], 'options': clean_options}\n        if current_action == 'alias':\n            add_remove = {}\n            for k in ['add', 'remove']:\n                if k in valid_structure:\n                    current_filters = SchemaCheck(valid_structure[k]['filters'], Schema(validfilters(current_action, location=loc)), f'\"{k}\" filters', f'{loc}, \"filters\"').result()\n                    add_remove.update({k: {'filters': SchemaCheck(current_filters, Schema(validfilters(current_action, location=loc)), 'filters', f'{loc}, \"{k}\", \"filters\"').result()}})\n            clean_config[action_id].update(add_remove)\n        elif current_action in ['cluster_routing', 'create_index', 'rollover']:\n            pass\n        else:\n            valid_filters = SchemaCheck(valid_structure['filters'], Schema(validfilters(current_action, location=loc)), 'filters', f'{loc}, \"filters\"').result()\n            clean_filters = validate_filters(current_action, valid_filters)\n            clean_config[action_id].update({'filters': clean_filters})\n        if current_action == 'reindex':\n            if 'remote_filters' in valid_structure['options']:\n                valid_filters = SchemaCheck(valid_structure['options']['remote_filters'], Schema(validfilters(current_action, location=loc)), 'filters', f'{loc}, \"filters\"').result()\n                clean_remote_filters = validate_filters(current_action, valid_filters)\n                clean_config[action_id]['options'].update({'remote_filters': clean_remote_filters})\n    return {'actions': clean_config}\n\ndef verify_index_list(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.curator.IndexList`\n\n    :returns: ``None`` if ``test`` is a proper :py:class:`~.curator.indexlist.IndexList`\n        object, else raise a :py:class:`TypeError` exception.\n    :rtype: None\n    \"\"\"\n    from curator.indexlist import IndexList\n    logger = logging.getLogger(__name__)\n    if not isinstance(test, IndexList):\n        msg = f'Not a valid IndexList object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)\n\ndef verify_snapshot_list(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.curator.SnapshotList`\n\n    :returns: ``None`` if ``test`` is a proper\n        :py:class:`~.curator.snapshotlist.SnapshotList` object, else raise a\n        :py:class:`TypeError` exception.\n    :rtype: None\n    \"\"\"\n    from curator.snapshotlist import SnapshotList\n    logger = logging.getLogger(__name__)\n    if not isinstance(test, SnapshotList):\n        msg = f'Not a valid SnapshotList object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\n\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\""
  }
}