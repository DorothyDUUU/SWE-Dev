{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_service_name",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/test_service_name.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\n\n\nclass TestServiceName:\n    def test_init(self) -> None:\n        service_name = ServiceName(\"my-service\", \"MyService\")\n        assert service_name.name == \"my-service\"\n        assert service_name.import_name == \"my_service\"\n        assert service_name.class_name == \"MyService\"\n        assert service_name.boto3_version == \"latest\"\n        assert service_name.boto3_name == \"my-service\"\n        assert service_name.extras_name == \"my-service\"\n        assert (\n            service_name.boto3_doc_link\n            == \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/my-service.html#myservice\"\n        )\n        assert (\n            service_name.boto3_doc_link_parent\n            == \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/my-service\"\n        )\n\n    def test_special_name(self) -> None:\n        assert ServiceName(\"lambda\", \"MyService\").import_name == \"lambda_\"\n\n    def test_is_essential(self) -> None:\n        assert not ServiceName(\"my-service\", \"MyService\").is_essential()\n        assert ServiceName(\"lambda\", \"MyService\").is_essential()\n\n\nclass TestServiceNameCatalog:\n    def test_add(self) -> None:\n        assert ServiceNameCatalog.add(\"test\", \"Test\").name == \"test\"\n        assert ServiceNameCatalog.add(\"test\", \"Test\").name == \"test\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n",
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\n\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\n\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\n\nRESERVED_NAMES: Final = {\n    *dir(typing),\n    *dir(builtins),\n    *keyword.kwlist,\n}\nAWS_LINK_RE: Final = re.compile(r\"`([^`]+\\S)\\s*<https://(\\S+)>`\\_*\")\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({\"\u2019\": \"'\", \"\u2013\": \"-\"})\n\n\ndef get_class_prefix(func_name: str) -> str:\n    \"\"\"\n    Get a valid Python class prefix from `func_name`.\n\n    Arguments:\n        func_name -- Any string.\n\n    Returns:\n        String with a class prefix.\n    \"\"\"\n    parts = [capitalize(i) for i in func_name.split(\"_\") if i]\n    return \"\".join(parts)\n\n\ndef get_anchor_link(text: str) -> str:\n    \"\"\"\n    Convert header to markdown anchor link.\n    \"\"\"\n    return text.strip().replace(\" \", \"-\").replace(\".\", \"\").lower()\n\n\ndef is_reserved(word: str) -> bool:\n    \"\"\"\n    Check whether variable name conflicts with Python reserved names.\n    \"\"\"\n    return word in RESERVED_NAMES\n\n\ndef get_short_docstring(doc: str) -> str:\n    \"\"\"\n    Create a short docstring from boto3 documentation.\n\n    Trims docstring to 300 chars.\n    Removes double and triple backticks.\n    Stops on `**Request syntax**` and `::`.\n    Ensures that backticks are closed.\n    Replaces `Text <link>` with [Text](link).\n    Wraps docstring to 80 chars.\n    \"\"\"\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f\"{doc[:DOCSTRING_MAX_LENGTH - 3]}...\"\n    result: list[str] = []\n    if not doc:\n        return \"\"\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix(\"::\")\n        if not line:\n            continue\n        if line.startswith(\":\") or line.lower().startswith(\"**request syntax**\"):\n            break\n        if \". \" in line:\n            result.append(line.split(\". \")[0])\n            break\n        result.append(line)\n        if line.endswith(\".\"):\n            break\n\n    result_str = \" \".join(result).replace(\"```\", \"`\").replace(\"``\", \"`\").replace(\"\\n\", \" \").strip()\n    return clean_artifacts(result_str)\n\n\ndef clean_artifacts(line: str) -> str:\n    \"\"\"\n    Remove common artifacts in botocre docs.\n    \"\"\"\n    if line.count(\"`\") % 2:\n        line = f\"{line}`\"\n    if line and not line.endswith(\".\"):\n        line = f\"{line}.\"\n\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n\n    if \"<https:\" in line:\n        line = AWS_LINK_RE.sub(r\"[\\g<1>](https://\\g<2>)\", line)\n        # FIXME: temporary fix for pca-connector-ad service\n        line = line.replace(\"https\\\\:\", \"https:\")\n        # FIXME: temporary fix for neptunedata service\n        line = line.replace(\"neptune-db\\\\:\", \"neptune-db:\")\n\n    return line\n\n\ndef textwrap(text: str, width: int = DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"\n    Wrap text to `width` chars.\n    \"\"\"\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(\" \", 0, width)\n            if space_index < 0:\n                space_index = line.find(\" \", width)\n\n            if space_index < 0:\n                result.append(line)\n                break\n\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n\n    return \"\\n\".join(result)\n\n\ndef get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"\n    Get Botocore class name from Service metadata.\n    \"\"\"\n    service_model = MagicMock()\n    service_model.service_name = metadata.get(\"serviceId\", \"\")\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)\n\n\ndef get_type_def_name(*parts: str) -> str:\n    \"\"\"\n    Get a valid Python TypeDef class name from `parts`.\n\n    Examples:\n        ```python\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\n        ```\n    \"\"\"\n    if not parts:\n        raise TypeAnnotationError(\"At least one part is required\")\n\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = \"\".join(parts_camelcased)\n    return f\"{name}TypeDef\"\n\n\ndef capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f\"{s[:1].upper()}{s[1:]}\"\n\n\ndef xform_name(name: str, sep: str = \"_\") -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError(\"Separator is required\")\n    return botocore_xform_name(name, sep)\n\n\ndef get_pypi_link(package_name: str) -> str:\n    \"\"\"\n    Get link to PyPI.\n    \"\"\"\n    if not package_name:\n        raise BuildInternalError(\"package_name is required\")\n    return f\"https://pypi.org/project/{package_name}/\"\n\n\ndef get_copyright() -> str:\n    \"\"\"\n    Get copyright notice.\n    \"\"\"\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f\"Copyright {now.year} Vlad Emelianov\"\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.__init__": {
        "code": "    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        \"\"\"Initialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the service, used for identifying the service in various contexts.\n- class_name (str): The corresponding class name of the service, typically used in documentation and code readability.\n- override_boto3_name (str, optional): An optional parameter to provide an alternative name for the service when referenced in the boto3 library.\n\nAttributes Initialized:\n- self.name: Stores the provided service name.\n- self.class_name: Stores the provided class name.\n- self.boto3_version: Initializes to the latest version defined in the class constant LATEST.\n- self.override_boto3_name: Stores the provided override name, or an empty string if not specified.\n\nConstants Used:\n- LATEST (Final): A constant representing the latest version of the service, defined within the class to ensure uniformity across instances.\"\"\"\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name",
        "docstring": "Initialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the service, used for identifying the service in various contexts.\n- class_name (str): The corresponding class name of the service, typically used in documentation and code readability.\n- override_boto3_name (str, optional): An optional parameter to provide an alternative name for the service when referenced in the boto3 library.\n\nAttributes Initialized:\n- self.name: Stores the provided service name.\n- self.class_name: Stores the provided class name.\n- self.boto3_version: Initializes to the latest version defined in the class constant LATEST.\n- self.override_boto3_name: Stores the provided override name, or an empty string if not specified.\n\nConstants Used:\n- LATEST (Final): A constant representing the latest version of the service, defined within the class to ensure uniformity across instances.",
        "signature": "def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.boto3_name": {
        "code": "    def boto3_name(self) -> str:\n        \"\"\"Returns the Boto3 package name for the service. If an `override_boto3_name` is provided during the initialization of the ServiceName instance, it will be returned; otherwise, the original `name` attribute is used. This method ensures that the correct package name is used, which is essential for interaction with the Boto3 library. \n\nReturns:\n    str: The Boto3 package name, either the overridden name or the service name.\"\"\"\n        '\\n        Boto3 package name.\\n        '\n        return self.override_boto3_name or self.name",
        "docstring": "Returns the Boto3 package name for the service. If an `override_boto3_name` is provided during the initialization of the ServiceName instance, it will be returned; otherwise, the original `name` attribute is used. This method ensures that the correct package name is used, which is essential for interaction with the Boto3 library. \n\nReturns:\n    str: The Boto3 package name, either the overridden name or the service name.",
        "signature": "def boto3_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.import_name": {
        "code": "    def import_name(self) -> str:\n        \"\"\"Returns a safe Python module import name derived from the service name. The method replaces hyphens in the service name with underscores to comply with Python naming conventions. If the resulting name is reserved (checked using the `is_reserved` utility), it appends an underscore to prevent conflicts. \n\nThis method helps ensure that service names can be utilized safely as Python identifiers within modules. The `is_reserved` function is imported from `mypy_boto3_builder.utils.strings` and is used to verify if the name is a reserved Python keyword.\"\"\"\n        '\\n        Safe mudule import name.\\n        '\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name",
        "docstring": "Returns a safe Python module import name derived from the service name. The method replaces hyphens in the service name with underscores to comply with Python naming conventions. If the resulting name is reserved (checked using the `is_reserved` utility), it appends an underscore to prevent conflicts. \n\nThis method helps ensure that service names can be utilized safely as Python identifiers within modules. The `is_reserved` function is imported from `mypy_boto3_builder.utils.strings` and is used to verify if the name is a reserved Python keyword.",
        "signature": "def import_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.extras_name": {
        "code": "    def extras_name(self) -> str:\n        \"\"\"Return the service name used for subpackage installation in extras requirements. The `extras_name` method retrieves the service name directly from the instance attribute `self.name`, which is defined during the initialization of the `ServiceName` instance. This attribute corresponds to the specific AWS service represented by the instance, and it is instrumental for dynamically generating extras requirements for installations in package management tools.\"\"\"\n        '\\n        Extras name for subpackage installation.\\n        '\n        return self.name",
        "docstring": "Return the service name used for subpackage installation in extras requirements. The `extras_name` method retrieves the service name directly from the instance attribute `self.name`, which is defined during the initialization of the `ServiceName` instance. This attribute corresponds to the specific AWS service represented by the instance, and it is instrumental for dynamically generating extras requirements for installations in package management tools.",
        "signature": "def extras_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.is_essential": {
        "code": "    def is_essential(self) -> bool:\n        \"\"\"Checks if the service represented by this instance of `ServiceName` is considered essential for inclusion in the `boto3-stubs[essential]` package. \n\nReturns:\n    bool: True if the service name is listed in `ESSENTIAL_NAMES`, which is a predefined set of core services (such as EC2, RDS, S3, etc.) crucial for many AWS operations, and False otherwise.\n\nThis method relies on the `ESSENTIAL_NAMES` constant defined within the `ServiceName` class, which contains service identifiers that are treated as essential.\"\"\"\n        '\\n        Whether service is included to `boto3-stubs[essential]`.\\n        '\n        return self.name in self.ESSENTIAL_NAMES",
        "docstring": "Checks if the service represented by this instance of `ServiceName` is considered essential for inclusion in the `boto3-stubs[essential]` package. \n\nReturns:\n    bool: True if the service name is listed in `ESSENTIAL_NAMES`, which is a predefined set of core services (such as EC2, RDS, S3, etc.) crucial for many AWS operations, and False otherwise.\n\nThis method relies on the `ESSENTIAL_NAMES` constant defined within the `ServiceName` class, which contains service identifiers that are treated as essential.",
        "signature": "def is_essential(self) -> bool:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Generate the URL for the documentation of the current boto3 service.\n\nThis method constructs and returns a hyperlink that directs to the official boto3 documentation for the service represented by the instance of the ServiceName class. The link includes the service's boto3 package name, which is derived from the `boto3_name` property, and an anchor corresponding to the service's class name, converted to lowercase.\n\nReturns:\n    str: The complete URL string to the boto3 documentation for the service.\n\nDependencies:\n    - `self.boto3_name`: The name of the service used to generate the documentation link, defined based on the service's name or its overridden name (if provided).\n    - `self.class_name`: Used to generate the anchor for the documentation link, representing the class name associated with the service.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'",
        "docstring": "Generate the URL for the documentation of the current boto3 service.\n\nThis method constructs and returns a hyperlink that directs to the official boto3 documentation for the service represented by the instance of the ServiceName class. The link includes the service's boto3 package name, which is derived from the `boto3_name` property, and an anchor corresponding to the service's class name, converted to lowercase.\n\nReturns:\n    str: The complete URL string to the boto3 documentation for the service.\n\nDependencies:\n    - `self.boto3_name`: The name of the service used to generate the documentation link, defined based on the service's name or its overridden name (if provided).\n    - `self.class_name`: Used to generate the anchor for the documentation link, representing the class name associated with the service.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceName.boto3_doc_link_parent": {
        "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"Generates a link to the parent directory of the Boto3 documentation for the specific AWS service.\n\nThis method constructs a URL that points to the Boto3 documentation for the service represented by the instance's `boto3_name` attribute. The `boto3_name` property retrieves the service's name, which may be overridden or defined in the `ServiceName` constructor.\n\nReturns:\n    str: The URL linking to the Boto3 documentation parent directory for the service.\n\nDependencies:\n    - The `boto3_name` attribute, derived from the `override_boto3_name` or `name`, to format the URL correctly.\n    - This method relies on the base URL \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/\" to build the complete link.\"\"\"\n        '\\n        Link to boto3 docs parent directory.\\n        '\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'",
        "docstring": "Generates a link to the parent directory of the Boto3 documentation for the specific AWS service.\n\nThis method constructs a URL that points to the Boto3 documentation for the service represented by the instance's `boto3_name` attribute. The `boto3_name` property retrieves the service's name, which may be overridden or defined in the `ServiceName` constructor.\n\nReturns:\n    str: The URL linking to the Boto3 documentation parent directory for the service.\n\nDependencies:\n    - The `boto3_name` attribute, derived from the `override_boto3_name` or `name`, to format the URL correctly.\n    - This method relies on the base URL \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/\" to build the complete link.",
        "signature": "def boto3_doc_link_parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      },
      "ServiceNameCatalog.add": {
        "code": "    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"Add a new ServiceName to the catalog or modify an existing one identified by its name.\n\n    Parameters:\n        name (str): The name of the service to be added or updated.\n        class_name (str): The class name associated with the service.\n\n    Returns:\n        ServiceName: The newly added ServiceName object or the modified one if it already exists.\n\n    The method interacts with the `ITEMS` dictionary, which is a class-level dictionary that stores \n    instances of `ServiceName` indexed by their `boto3_name`. If the provided `name` already exists in \n    `ITEMS`, the method updates the `class_name` of the existing `ServiceName` instance. Otherwise, \n    it creates a new instance of `ServiceName` and adds it to the `ITEMS` dictionary.\"\"\"\n        '\\n        Add new ServiceName to catalog or modify existing one.\\n\\n        Returns:\\n            New ServiceName or modified if it exists.\\n        '\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name",
        "docstring": "Add a new ServiceName to the catalog or modify an existing one identified by its name.\n\nParameters:\n    name (str): The name of the service to be added or updated.\n    class_name (str): The class name associated with the service.\n\nReturns:\n    ServiceName: The newly added ServiceName object or the modified one if it already exists.\n\nThe method interacts with the `ITEMS` dictionary, which is a class-level dictionary that stores \ninstances of `ServiceName` indexed by their `boto3_name`. If the provided `name` already exists in \n`ITEMS`, the method updates the `class_name` of the existing `ServiceName` instance. Otherwise, \nit creates a new instance of `ServiceName` and adds it to the `ITEMS` dictionary.",
        "signature": "def add(cls, name: str, class_name: str) -> ServiceName:",
        "type": "Method",
        "class_signature": "class ServiceNameCatalog:"
      }
    },
    "mypy_boto3_builder/utils/strings.py": {
      "is_reserved": {
        "code": "def is_reserved(word: str) -> bool:\n    \"\"\"Check whether a given variable name is a reserved word in Python.\n\nArgs:\n    word (str): The variable name to check against reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nDependencies:\n    Utilizes the RESERVED_NAMES constant, which is a collection of Python's built-in names, keywords, and names defined in the `typing` module. RESERVED_NAMES is defined as a Final set at the module level, ensuring the names are immutable and cannot be altered, providing a reliable reference for checking reserved words.\"\"\"\n    '\\n    Check whether variable name conflicts with Python reserved names.\\n    '\n    return word in RESERVED_NAMES",
        "docstring": "Check whether a given variable name is a reserved word in Python.\n\nArgs:\n    word (str): The variable name to check against reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nDependencies:\n    Utilizes the RESERVED_NAMES constant, which is a collection of Python's built-in names, keywords, and names defined in the `typing` module. RESERVED_NAMES is defined as a Final set at the module level, ensuring the names are immutable and cannot be altered, providing a reliable reference for checking reserved words.",
        "signature": "def is_reserved(word: str) -> bool:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/service_name.py:ServiceName:import_name": {},
    "mypy_boto3_builder/utils/strings.py:is_reserved": {},
    "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link": {},
    "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
    "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {},
    "mypy_boto3_builder/service_name.py:ServiceNameCatalog:add": {},
    "mypy_boto3_builder/service_name.py:ServiceName:__init__": {}
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_service_name\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u251c\u2500\u2500 ServiceName.__init__\n    \u2502   \u251c\u2500\u2500 ServiceName.boto3_doc_link\n    \u2502   \u251c\u2500\u2500 ServiceName.boto3_doc_link_parent\n    \u2502   \u251c\u2500\u2500 ServiceName.boto3_name\n    \u2502   \u251c\u2500\u2500 ServiceName.extras_name\n    \u2502   \u251c\u2500\u2500 ServiceName.import_name\n    \u2502   \u251c\u2500\u2500 ServiceName.is_essential\n    \u2502   \u2514\u2500\u2500 ServiceNameCatalog.add\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 strings.py\n            \u2514\u2500\u2500 is_reserved\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for defining, managing, and cataloging service metadata related to AWS services in the context of Boto3 interactions. It enables the creation and manipulation of `ServiceName` objects, which encapsulate key details about an AWS service, such as its name, class name, import conventions, documentation links, and other related properties. Additionally, the module includes a `ServiceNameCatalog` that acts as a registry for managing service entries. This module simplifies how developers manage service configurations and metadata, ensuring consistency and reducing the need for manual handling of service-related details when extending or working with the Boto3 library.\n\n## FILE 1: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.extras_name\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def extras_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the service name used for subpackage installation in extras requirements. The `extras_name` method retrieves the service name directly from the instance attribute `self.name`, which is defined during the initialization of the `ServiceName` instance. This attribute corresponds to the specific AWS service represented by the instance, and it is instrumental for dynamically generating extras requirements for installations in package management tools.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.is_essential\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def is_essential(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the service represented by this instance of `ServiceName` is considered essential for inclusion in the `boto3-stubs[essential]` package. \n\nReturns:\n    bool: True if the service name is listed in `ESSENTIAL_NAMES`, which is a predefined set of core services (such as EC2, RDS, S3, etc.) crucial for many AWS operations, and False otherwise.\n\nThis method relies on the `ESSENTIAL_NAMES` constant defined within the `ServiceName` class, which contains service identifiers that are treated as essential.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.__init__\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ServiceName instance representing a specific AWS service.\n\nParameters:\n- name (str): The name of the service, used for identifying the service in various contexts.\n- class_name (str): The corresponding class name of the service, typically used in documentation and code readability.\n- override_boto3_name (str, optional): An optional parameter to provide an alternative name for the service when referenced in the boto3 library.\n\nAttributes Initialized:\n- self.name: Stores the provided service name.\n- self.class_name: Stores the provided class name.\n- self.boto3_version: Initializes to the latest version defined in the class constant LATEST.\n- self.override_boto3_name: Stores the provided override name, or an empty string if not specified.\n\nConstants Used:\n- LATEST (Final): A constant representing the latest version of the service, defined within the class to ensure uniformity across instances.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.boto3_doc_link_parent\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def boto3_doc_link_parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a link to the parent directory of the Boto3 documentation for the specific AWS service.\n\nThis method constructs a URL that points to the Boto3 documentation for the service represented by the instance's `boto3_name` attribute. The `boto3_name` property retrieves the service's name, which may be overridden or defined in the `ServiceName` constructor.\n\nReturns:\n    str: The URL linking to the Boto3 documentation parent directory for the service.\n\nDependencies:\n    - The `boto3_name` attribute, derived from the `override_boto3_name` or `name`, to format the URL correctly.\n    - This method relies on the base URL \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/\" to build the complete link.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.boto3_name\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def boto3_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the Boto3 package name for the service. If an `override_boto3_name` is provided during the initialization of the ServiceName instance, it will be returned; otherwise, the original `name` attribute is used. This method ensures that the correct package name is used, which is essential for interaction with the Boto3 library. \n\nReturns:\n    str: The Boto3 package name, either the overridden name or the service name.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.boto3_doc_link\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate the URL for the documentation of the current boto3 service.\n\nThis method constructs and returns a hyperlink that directs to the official boto3 documentation for the service represented by the instance of the ServiceName class. The link includes the service's boto3 package name, which is derived from the `boto3_name` property, and an anchor corresponding to the service's class name, converted to lowercase.\n\nReturns:\n    str: The complete URL string to the boto3 documentation for the service.\n\nDependencies:\n    - `self.boto3_name`: The name of the service used to generate the documentation link, defined based on the service's name or its overridden name (if provided).\n    - `self.class_name`: Used to generate the anchor for the documentation link, representing the class name associated with the service.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceNameCatalog.add\n  - CLASS SIGNATURE: class ServiceNameCatalog:\n  - SIGNATURE: def add(cls, name: str, class_name: str) -> ServiceName:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a new ServiceName to the catalog or modify an existing one identified by its name.\n\nParameters:\n    name (str): The name of the service to be added or updated.\n    class_name (str): The class name associated with the service.\n\nReturns:\n    ServiceName: The newly added ServiceName object or the modified one if it already exists.\n\nThe method interacts with the `ITEMS` dictionary, which is a class-level dictionary that stores \ninstances of `ServiceName` indexed by their `boto3_name`. If the provided `name` already exists in \n`ITEMS`, the method updates the `class_name` of the existing `ServiceName` instance. Otherwise, \nit creates a new instance of `ServiceName` and adds it to the `ITEMS` dictionary.\n\"\"\"\n```\n\n- CLASS METHOD: ServiceName.import_name\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def import_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a safe Python module import name derived from the service name. The method replaces hyphens in the service name with underscores to comply with Python naming conventions. If the resulting name is reserved (checked using the `is_reserved` utility), it appends an underscore to prevent conflicts. \n\nThis method helps ensure that service names can be utilized safely as Python identifiers within modules. The `is_reserved` function is imported from `mypy_boto3_builder.utils.strings` and is used to verify if the name is a reserved Python keyword.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/utils/strings.py\n\n- FUNCTION NAME: is_reserved\n  - SIGNATURE: def is_reserved(word: str) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck whether a given variable name is a reserved word in Python.\n\nArgs:\n    word (str): The variable name to check against reserved names.\n\nReturns:\n    bool: True if the word is a reserved name, False otherwise.\n\nDependencies:\n    Utilizes the RESERVED_NAMES constant, which is a collection of Python's built-in names, keywords, and names defined in the `typing` module. RESERVED_NAMES is defined as a Final set at the module level, ensuring the names are immutable and cannot be altered, providing a reliable reference for checking reserved words.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/service_name.py:ServiceName:import_name\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name",
    "mypy_boto3_builder/utils/strings.py": "\"\"\"\nMultiple string utils collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport builtins\nimport datetime\nimport keyword\nimport re\nimport typing\nfrom types import MappingProxyType\nfrom typing import Final\nfrom unittest.mock import MagicMock\nfrom botocore import xform_name as botocore_xform_name\nfrom botocore.utils import get_service_module_name\nfrom mypy_boto3_builder.constants import DOCSTRING_LINE_LENGTH, DOCSTRING_MAX_LENGTH\nfrom mypy_boto3_builder.exceptions import BuildInternalError, TypeAnnotationError\nRESERVED_NAMES: Final = {*dir(typing), *dir(builtins), *keyword.kwlist}\nAWS_LINK_RE: Final = re.compile('`([^`]+\\\\S)\\\\s*<https://(\\\\S+)>`\\\\_*')\nREPLACE_DOCSTRING_CHARS: Final = MappingProxyType({'\u2019': \"'\", '\u2013': '-'})\n\ndef get_class_prefix(func_name: str) -> str:\n    \"\"\"\n    Get a valid Python class prefix from `func_name`.\n\n    Arguments:\n        func_name -- Any string.\n\n    Returns:\n        String with a class prefix.\n    \"\"\"\n    parts = [capitalize(i) for i in func_name.split('_') if i]\n    return ''.join(parts)\n\ndef get_anchor_link(text: str) -> str:\n    \"\"\"\n    Convert header to markdown anchor link.\n    \"\"\"\n    return text.strip().replace(' ', '-').replace('.', '').lower()\n\ndef get_short_docstring(doc: str) -> str:\n    \"\"\"\n    Create a short docstring from boto3 documentation.\n\n    Trims docstring to 300 chars.\n    Removes double and triple backticks.\n    Stops on `**Request syntax**` and `::`.\n    Ensures that backticks are closed.\n    Replaces `Text <link>` with [Text](link).\n    Wraps docstring to 80 chars.\n    \"\"\"\n    doc = str(doc)\n    if len(doc) > DOCSTRING_MAX_LENGTH:\n        doc = f'{doc[:DOCSTRING_MAX_LENGTH - 3]}...'\n    result: list[str] = []\n    if not doc:\n        return ''\n    for raw_line in doc.splitlines():\n        line = raw_line.strip().removesuffix('::')\n        if not line:\n            continue\n        if line.startswith(':') or line.lower().startswith('**request syntax**'):\n            break\n        if '. ' in line:\n            result.append(line.split('. ')[0])\n            break\n        result.append(line)\n        if line.endswith('.'):\n            break\n    result_str = ' '.join(result).replace('```', '`').replace('``', '`').replace('\\n', ' ').strip()\n    return clean_artifacts(result_str)\n\ndef clean_artifacts(line: str) -> str:\n    \"\"\"\n    Remove common artifacts in botocre docs.\n    \"\"\"\n    if line.count('`') % 2:\n        line = f'{line}`'\n    if line and (not line.endswith('.')):\n        line = f'{line}.'\n    for ch, replacement in REPLACE_DOCSTRING_CHARS.items():\n        if ch in line:\n            line = line.replace(ch, replacement)\n    if '<https:' in line:\n        line = AWS_LINK_RE.sub('[\\\\g<1>](https://\\\\g<2>)', line)\n        line = line.replace('https\\\\:', 'https:')\n        line = line.replace('neptune-db\\\\:', 'neptune-db:')\n    return line\n\ndef textwrap(text: str, width: int=DOCSTRING_LINE_LENGTH) -> str:\n    \"\"\"\n    Wrap text to `width` chars.\n    \"\"\"\n    result: list[str] = []\n    for raw_line in text.splitlines():\n        if len(raw_line) <= width:\n            result.append(raw_line)\n            continue\n        line = raw_line\n        while line:\n            if len(line) < width:\n                result.append(line)\n                break\n            space_index = line.rfind(' ', 0, width)\n            if space_index < 0:\n                space_index = line.find(' ', width)\n            if space_index < 0:\n                result.append(line)\n                break\n            sub_line = line[:space_index].rstrip()\n            next_index = space_index + 1\n            line = line[next_index:].lstrip()\n            result.append(sub_line)\n    return '\\n'.join(result)\n\ndef get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"\n    Get Botocore class name from Service metadata.\n    \"\"\"\n    service_model = MagicMock()\n    service_model.service_name = metadata.get('serviceId', '')\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)\n\ndef get_type_def_name(*parts: str) -> str:\n    \"\"\"\n    Get a valid Python TypeDef class name from `parts`.\n\n    Examples:\n        ```python\n        get_type_def_name(\"MyClass\", \"my_method\")  # MyClassMyMethodTypeDef\n        ```\n    \"\"\"\n    if not parts:\n        raise TypeAnnotationError('At least one part is required')\n    parts_camelcased = [get_class_prefix(i) for i in parts]\n    name = ''.join(parts_camelcased)\n    return f'{name}TypeDef'\n\ndef capitalize(s: str) -> str:\n    \"\"\"\n    Capitalize first letter of a string.\n    \"\"\"\n    return f'{s[:1].upper()}{s[1:]}'\n\ndef xform_name(name: str, sep: str='_') -> str:\n    \"\"\"\n    Convert name to snake_case.\n\n    Arguments:\n        name -- Any string.\n        sep -- Separator.\n    \"\"\"\n    if not sep:\n        raise BuildInternalError('Separator is required')\n    return botocore_xform_name(name, sep)\n\ndef get_pypi_link(package_name: str) -> str:\n    \"\"\"\n    Get link to PyPI.\n    \"\"\"\n    if not package_name:\n        raise BuildInternalError('package_name is required')\n    return f'https://pypi.org/project/{package_name}/'\n\ndef get_copyright() -> str:\n    \"\"\"\n    Get copyright notice.\n    \"\"\"\n    now = datetime.datetime.now(datetime.timezone.utc)\n    return f'Copyright {now.year} Vlad Emelianov'"
  },
  "call_tree": {
    "tests/test_service_name.py:TestServiceName:test_init": {
      "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
      "mypy_boto3_builder/service_name.py:ServiceName:import_name": {
        "mypy_boto3_builder/utils/strings.py:is_reserved": {}
      },
      "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {},
      "mypy_boto3_builder/service_name.py:ServiceName:extras_name": {},
      "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link": {
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
      },
      "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
      }
    },
    "tests/test_service_name.py:TestServiceName:test_special_name": {
      "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
      "mypy_boto3_builder/service_name.py:ServiceName:import_name": {
        "mypy_boto3_builder/utils/strings.py:is_reserved": {}
      }
    },
    "tests/test_service_name.py:TestServiceName:test_is_essential": {
      "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
      "mypy_boto3_builder/service_name.py:ServiceName:is_essential": {}
    },
    "tests/test_service_name.py:TestServiceNameCatalog:test_add": {
      "mypy_boto3_builder/service_name.py:ServiceNameCatalog:add": {
        "mypy_boto3_builder/service_name.py:ServiceName:__init__": {}
      }
    }
  }
}