{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_gen_table",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_base_table/test_gen_table.py",
  "test_code": "\"\"\"Test method in BaseTable class.\"\"\"\n\nimport pytest\n\nfrom terminaltables3.base_table import BaseTable\nfrom terminaltables3.build import flatten\nfrom terminaltables3.width_and_alignment import max_dimensions\n\n\n@pytest.mark.parametrize(\"inner_heading_row_border\", [True, False])\n@pytest.mark.parametrize(\"inner_footing_row_border\", [True, False])\n@pytest.mark.parametrize(\"inner_row_border\", [True, False])\ndef test_inner_row_borders(\n    inner_heading_row_border, inner_footing_row_border, inner_row_border\n):\n    \"\"\"Test heading/footing/row borders.\n\n    :param bool inner_heading_row_border: Passed to table.\n    :param bool inner_footing_row_border: Passed to table.\n    :param bool inner_row_border: Passed to table.\n    \"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n    ]\n    table = BaseTable(table_data)\n    table.inner_heading_row_border = inner_heading_row_border\n    table.inner_footing_row_border = inner_footing_row_border\n    table.inner_row_border = inner_row_border\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if inner_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_heading_row_border and inner_footing_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_heading_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_footing_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    else:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"outer_border\", [True, False])\ndef test_outer_borders(outer_border):\n    \"\"\"Test left/right/top/bottom table borders.\n\n    :param bool outer_border: Passed to table.\n    \"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n    ]\n    table = BaseTable(table_data, \"Example Table\")\n    table.outer_border = outer_border\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if outer_border:\n        expected = (\n            \"+Example Table----+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    else:\n        expected = (\n            \" Name    | Color | Type      \\n\"\n            \"---------+-------+-----------\\n\"\n            \" Avocado | green | nut       \\n\"\n            \" Tomato  | red   | fruit     \\n\"\n            \" Lettuce | green | vegetable \"\n        )\n\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"mode\", [\"row\", \"one\", \"blank\", \"empty\", \"none\"])\n@pytest.mark.parametrize(\"bare\", [False, True])\ndef test_one_no_rows(mode, bare):\n    \"\"\"Test with one or no rows.\n\n    :param str mode: Type of table contents to test.\n    :param bool bare: Disable padding/borders.\n    \"\"\"\n    if mode == \"row\":\n        table_data = [\n            [\"Avocado\", \"green\", \"nut\"],\n        ]\n    elif mode == \"one\":\n        table_data = [\n            [\"Avocado\"],\n        ]\n    elif mode == \"blank\":\n        table_data = [\n            [\"\"],\n        ]\n    elif mode == \"empty\":\n        table_data = [\n            [],\n        ]\n    else:\n        table_data = []\n    table = BaseTable(table_data)\n    if bare:\n        table.inner_column_border = False\n        table.inner_footing_row_border = False\n        table.inner_heading_row_border = False\n        table.inner_row_border = False\n        table.outer_border = False\n        table.padding_left = 0\n        table.padding_right = 0\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if mode == \"row\":\n        if bare:\n            expected = \"Avocadogreennut\"\n        else:\n            expected = (\n                \"+---------+-------+-----+\\n\"\n                \"| Avocado | green | nut |\\n\"\n                \"+---------+-------+-----+\"\n            )\n    elif mode == \"one\":\n        if bare:\n            expected = \"Avocado\"\n        else:\n            expected = \"+---------+\\n\" \"| Avocado |\\n\" \"+---------+\"\n    elif mode == \"blank\":  # Remember there's still padding.\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"+--+\\n\" \"|  |\\n\" \"+--+\"\n    elif mode == \"empty\":\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"++\\n\" \"||\\n\" \"++\"\n    else:\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"++\\n\" \"++\"\n\n    assert actual == expected\n",
  "GT_file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\n\nfrom typing import Generator, Iterator, Optional, Sequence, Union\n\nfrom terminaltables3.width_and_alignment import visible_width\n\n\ndef combine(\n    line: Union[\n        Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]\n    ],\n    left: str,\n    intersect: Optional[str],\n    right: str,\n) -> Generator[int, None, None]:\n    \"\"\"Zip borders between items in `line`.\n\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\n\n    :param iter line: List to iterate.\n    :param left: Left border.\n    :param intersect: Column separator.\n    :param right: Right border.\n\n    :return: Yields combined objects.\n    \"\"\"\n    # Yield left border.\n    if left:\n        yield left\n\n    # Yield items with intersect characters.\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:  # Generator.\n            try:\n                item = next(line)\n            except StopIteration:  # Was empty all along.\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n\n        # Yield right border.\n    if right:\n        yield right\n\n\ndef build_border(\n    outer_widths: Sequence[int],\n    horizontal: str,\n    left: str,\n    intersect: str,\n    right: str,\n    title: Optional[str] = None,\n):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n\n    # Hide title if it doesn't fit.\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n\n    # Handle no title.\n    if title is None or not outer_widths or not horizontal:\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n\n    # Handle title fitting in the first column.\n    if length == outer_widths[0]:\n        return combine(\n            [title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right\n        )\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [\n            horizontal * c for c in outer_widths[1:]\n        ]\n        return combine(columns, left, intersect, right)\n\n    # Handle wide titles/narrow columns.\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        # If title is taken care of.\n        if length < 1:\n            columns_and_intersects.append(\n                intersect if width is True else horizontal * width\n            )\n        # If title's last character overrides an intersect character.\n        elif width is True and length == 1:\n            length = 0\n        # If this is an intersect character that is overridden by the title.\n        elif width is True:\n            length -= 1\n        # If title's last character is within a column.\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (\n                width - length\n            )  # Append horizontal chars to title.\n            length = 0\n        # If remainder of title won't fit in a column.\n        else:\n            length -= width\n\n    return combine(columns_and_intersects, left, None, right)\n\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)\n",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\n\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\n\nfrom terminaltables3.terminal_io import terminal_size\n\nRE_COLOR_ANSI = re.compile(r\"(\\033\\[[\\d;]+m)\")\n\n\ndef visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string.\n\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\n\n    From: https://github.com/Robpol86/terminaltables3/pull/9\n\n    :param str string: String to measure.\n\n    :return: String's width.\n    :rtype: int\n    \"\"\"\n    if \"\\033\" in string:\n        string = RE_COLOR_ANSI.sub(\"\", string)\n\n    # Convert to unicode.\n    try:\n        string = string.decode(\"u8\")\n    except (AttributeError, UnicodeEncodeError):\n        pass\n\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in (\"F\", \"W\"):\n            width += 2\n        else:\n            width += 1\n\n    return width\n\n\ndef align_and_pad_cell(\n    string: str,\n    align: Tuple,\n    inner_dimensions: Tuple,\n    padding: Sequence[int],\n    space: str = \" \",\n) -> List[str]:\n    \"\"\"Align a string horizontally and vertically. Also add additional padding in both dimensions.\n\n    :param str string: Input string to operate on.\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\n\n    :return: Padded cell split into lines.\n    :rtype: list\n    \"\"\"\n    if not hasattr(string, \"splitlines\"):\n        string = str(string)\n\n    # Handle trailing newlines or empty strings, str.splitlines() does not satisfy.\n    lines = string.splitlines() or [\"\"]\n    if string.endswith(\"\\n\"):\n        lines.append(\"\")\n\n    # Vertically align and pad.\n    if \"bottom\" in align:\n        lines = (\n            ([\"\"] * (inner_dimensions[1] - len(lines) + padding[2]))\n            + lines\n            + ([\"\"] * padding[3])\n        )\n    elif \"middle\" in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = (\n            ([\"\"] * (delta // 2 + delta % 2 + padding[2]))\n            + lines\n            + ([\"\"] * (delta // 2 + padding[3]))\n        )\n    else:\n        lines = (\n            ([\"\"] * padding[2])\n            + lines\n            + ([\"\"] * (inner_dimensions[1] - len(lines) + padding[3]))\n        )\n\n    # Horizontally align and pad.\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if \"right\" in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + (space * padding[1])\n        elif \"center\" in align:\n            lines[i] = (\n                (space * padding[0])\n                + line.center(new_width, space)\n                + (space * padding[1])\n            )\n        else:\n            lines[i] = (space * padding[0]) + line.ljust(new_width + padding[1], space)\n\n    return lines\n\n\ndef max_dimensions(\n    table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0\n):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max(len(r) for r in table_data) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n\n    # Find max width and heights.\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, \"count\") or not hasattr(cell, \"splitlines\"):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count(\"\\n\") + 1)\n            inner_widths[i] = max(\n                inner_widths[i],\n                *[visible_width(the_line) for the_line in cell.splitlines()],\n            )\n\n    # Calculate with padding.\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n\n    return inner_widths, inner_heights, outer_widths, outer_heights\n\n\ndef column_max_width(\n    inner_widths: Sequence[int],\n    column_number: int,\n    outer_border: int,\n    inner_border: int,\n    padding: int,\n) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n\n    # Count how much space padding, outer, and inner borders take up.\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n\n    # Exclude selected column's width.\n    data_space = sum(inner_widths) - inner_widths[column_number]\n\n    return terminal_width - data_space - non_data_space\n\n\ndef table_width(\n    outer_widths: Sequence[int], outer_border: int, inner_border: int\n) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n\n    # Count how much space outer and inner borders take up.\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n\n    # Space of all columns and their padding.\n    data_space = sum(outer_widths)\n    return data_space + non_data_space\n",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\n\nfrom typing import Generator, Optional, Sequence, Tuple\n\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"-\"\n    CHAR_F_INNER_INTERSECT = \"+\"\n    CHAR_F_INNER_VERTICAL = \"|\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_H_INNER_HORIZONTAL = \"-\"\n    CHAR_H_INNER_INTERSECT = \"+\"\n    CHAR_H_INNER_VERTICAL = \"|\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_INNER_HORIZONTAL = \"-\"\n    CHAR_INNER_INTERSECT = \"+\"\n    CHAR_INNER_VERTICAL = \"|\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"-\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"+\"\n    CHAR_OUTER_BOTTOM_LEFT = \"+\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"+\"\n    CHAR_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"-\"\n    CHAR_OUTER_TOP_INTERSECT = \"+\"\n    CHAR_OUTER_TOP_LEFT = \"+\"\n    CHAR_OUTER_TOP_RIGHT = \"+\"\n\n    def __init__(\n        self, table_data: Sequence[Sequence[str]], title: Optional[str] = None\n    ):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n\n        self.justify_columns = {}  # {0: 'right', 1: 'left', 2: 'center'}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(\n        self, style: str, outer_widths: Sequence[int]\n    ) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == \"top\":\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = (\n                self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == \"bottom\":\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = (\n                self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == \"heading\":\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        elif style == \"footing\":\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(\n        self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int\n    ) -> Generator[Tuple[str, ...], None, None]:\n        r\"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n\n        # Resize row if it doesn't have enough cells.\n        if len(row) != len(inner_widths):\n            row = row + [\"\"] * (len(inner_widths) - len(row))\n\n        # Pad and align each cell. Split each cell into lines to support multi-line cells.\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(\n                align_and_pad_cell(cell, align, inner_dimensions, padding)\n            )\n\n        # Determine border characters.\n        if style == \"heading\":\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        elif style == \"footing\":\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n\n        # Yield each line.\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(\n        self,\n        inner_widths: Sequence[int],\n        inner_heights: Sequence[int],\n        outer_widths: Sequence[int],\n    ) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        # Yield top border.\n        if self.outer_border:\n            yield self.horizontal_border(\"top\", outer_widths)\n\n        # Yield table body.\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = row_count - 1, row_count - 2\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            if self.inner_heading_row_border and i == 0:\n                style = \"heading\"\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = \"footing\"\n            else:\n                style = \"row\"\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            # If this is the last row then break. No separator needed.\n            if i == last_row_index:\n                break\n            # Yield heading separator.\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border(\"heading\", outer_widths)\n            # Yield footing separator.\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border(\"footing\", outer_widths)\n            # Yield row separator.\n            elif self.inner_row_border:\n                yield self.horizontal_border(\"row\", outer_widths)\n\n        # Yield bottom border.\n        if self.outer_border:\n            yield self.horizontal_border(\"bottom\", outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(\n            self.table_data, self.padding_left, self.padding_right\n        )[:3]\n        return flatten(self.gen_table(*dimensions))\n"
  },
  "GT_src_dict": {
    "terminaltables3/build.py": {
      "combine": {
        "code": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n    \"\"\"Combine elements of an iterable with specified border characters to form structured rows for table display.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items (integers or strings) that are to be combined into a single structured output.\n- left (str): The character(s) to use as the left border of the combined output.\n- intersect (Optional[str]): The character(s) used to separate the elements in the combined output. If None, no separators will be included.\n- right (str): The character(s) to use as the right border of the combined output.\n\nReturns:\n- Generator[int, None, None]: A generator yielding the combined elements, structured with the specified borders and separators. The function handles both iterable sequences and generators, ensuring compatibility while yielding each item surrounded by the defined borders and separators.\n\nThis function interacts with the `build_row` and `build_border` functions to create structured table rows and borders, enhancing table formatting in display-related functionalities.\"\"\"\n    \"Zip borders between items in `line`.\\n\\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\\n\\n    :param iter line: List to iterate.\\n    :param left: Left border.\\n    :param intersect: Column separator.\\n    :param right: Right border.\\n\\n    :return: Yields combined objects.\\n    \"\n    if left:\n        yield left\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:\n            try:\n                item = next(line)\n            except StopIteration:\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n    if right:\n        yield right",
        "docstring": "Combine elements of an iterable with specified border characters to form structured rows for table display.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items (integers or strings) that are to be combined into a single structured output.\n- left (str): The character(s) to use as the left border of the combined output.\n- intersect (Optional[str]): The character(s) used to separate the elements in the combined output. If None, no separators will be included.\n- right (str): The character(s) to use as the right border of the combined output.\n\nReturns:\n- Generator[int, None, None]: A generator yielding the combined elements, structured with the specified borders and separators. The function handles both iterable sequences and generators, ensuring compatibility while yielding each item surrounded by the defined borders and separators.\n\nThis function interacts with the `build_row` and `build_border` functions to create structured table rows and borders, enhancing table formatting in display-related functionalities.",
        "signature": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:",
        "type": "Function",
        "class_signature": null
      },
      "build_border": {
        "code": "def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n    \"\"\"Builds a border for a table, potentially embedding a title within it. The function computes the appearance of the border based on the widths of the columns, characters used for the left, right, and intersect borders, and the provided title. If the title cannot fit within the border, it is omitted.\n\nParameters:\n- outer_widths (Sequence[int]): List of widths for each column, including padding.\n- horizontal (str): Character used to fill the width of each column.\n- left (str): Character for the left border of the table.\n- intersect (str): Character used as the column separator.\n- right (str): Character for the right border of the table.\n- title (Optional[str]): An optional title to display within the border.\n\nReturns:\n- Generator of strings representing the constructed border.\n\nDependencies:\n- The function uses `visible_width` from `terminaltables3.width_and_alignment` to determine the width of the title for fitting calculations, ensuring the title does not exceed the available space in relation to the left and right borders.\"\"\"\n    \"Build the top/bottom/middle row. Optionally embed the table title within the border.\\n\\n    Title is hidden if it doesn't fit between the left/right characters/edges.\\n\\n    Example return value:\\n    ('<', '-----', '+', '------', '+', '-------', '>')\\n    ('<', 'My Table', '----', '+', '------->')\\n\\n    :param iter outer_widths: List of widths (with padding) for each column.\\n    :param str horizontal: Character to stretch across each column.\\n    :param str left: Left border.\\n    :param str intersect: Column separator.\\n    :param str right: Right border.\\n    :param title: Overlay the title on the border between the left and right characters.\\n\\n    :return: Returns a generator of strings representing a border.\\n    :rtype: iter\\n    \"\n    length = 0\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n    if title is None or not outer_widths or (not horizontal):\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n    if length == outer_widths[0]:\n        return combine([title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right)\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [horizontal * c for c in outer_widths[1:]]\n        return combine(columns, left, intersect, right)\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        if length < 1:\n            columns_and_intersects.append(intersect if width is True else horizontal * width)\n        elif width is True and length == 1:\n            length = 0\n        elif width is True:\n            length -= 1\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (width - length)\n            length = 0\n        else:\n            length -= width\n    return combine(columns_and_intersects, left, None, right)",
        "docstring": "Builds a border for a table, potentially embedding a title within it. The function computes the appearance of the border based on the widths of the columns, characters used for the left, right, and intersect borders, and the provided title. If the title cannot fit within the border, it is omitted.\n\nParameters:\n- outer_widths (Sequence[int]): List of widths for each column, including padding.\n- horizontal (str): Character used to fill the width of each column.\n- left (str): Character for the left border of the table.\n- intersect (str): Character used as the column separator.\n- right (str): Character for the right border of the table.\n- title (Optional[str]): An optional title to display within the border.\n\nReturns:\n- Generator of strings representing the constructed border.\n\nDependencies:\n- The function uses `visible_width` from `terminaltables3.width_and_alignment` to determine the width of the title for fitting calculations, ensuring the title does not exceed the available space in relation to the left and right borders.",
        "signature": "def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):",
        "type": "Function",
        "class_signature": null
      },
      "build_row": {
        "code": "def build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a formatted row with borders.\n\nThis function takes a row represented as a list of lists (where each inner list \ncontains cell data) and combines the cells into a single row by adding specified \nborders and a column separator.\n\n:param iter row: List of lists corresponding to the cells of one row, where each \n                 inner list contains strings representing the content of the cells.\n:param str left: Character(s) to use as the left border of the row.\n:param str center: Character(s) to use as the column separator between cells.\n:param str right: Character(s) to use as the right border of the row.\n\n:yield: Yields generators that produce strings for each combined row with borders.\n:rtype: iter\n\nIf the row is empty or the first inner list is empty, it yields an empty row with borders.\nOtherwise, it iterates through the number of lines in the first cell (assuming all \ncells are padded to the same height) and combines the corresponding entries from each \ncell using the `combine` function, which is defined elsewhere in the code.\"\"\"\n    \"Combine single or multi-lined cells into a single row of list of lists including borders.\\n\\n    Row must already be padded and extended so each cell has the same number of lines.\\n\\n    Example return value:\\n    [\\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\\n    ]\\n\\n    :param iter row: List of cells for one row.\\n    :param str left: Left border.\\n    :param str center: Column separator.\\n    :param str right: Right border.\\n\\n    :return: Yields other generators that yield strings.\\n    :rtype: iter\\n    \"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)",
        "docstring": "Combine single or multi-lined cells into a formatted row with borders.\n\nThis function takes a row represented as a list of lists (where each inner list \ncontains cell data) and combines the cells into a single row by adding specified \nborders and a column separator.\n\n:param iter row: List of lists corresponding to the cells of one row, where each \n                 inner list contains strings representing the content of the cells.\n:param str left: Character(s) to use as the left border of the row.\n:param str center: Character(s) to use as the column separator between cells.\n:param str right: Character(s) to use as the right border of the row.\n\n:yield: Yields generators that produce strings for each combined row with borders.\n:rtype: iter\n\nIf the row is empty or the first inner list is empty, it yields an empty row with borders.\nOtherwise, it iterates through the number of lines in the first cell (assuming all \ncells are padded to the same height) and combines the corresponding entries from each \ncell using the `combine` function, which is defined elsewhere in the code.",
        "signature": "def build_row(row, left, center, right):",
        "type": "Function",
        "class_signature": null
      },
      "flatten": {
        "code": "def flatten(table):\n    \"\"\"Flatten a table into a single string, where each row is joined by newlines.\n\n:param iter table: An iterable containing padded and bordered table data, structured as a list of rows, where each row is a sequence of strings representing cells.\n\n:return: A single string that concatenates all the rows and cells in the table, separated by newline characters.\n:rtype: str\n\nThis function is designed to work with the output of functions that generate table structures elsewhere in the code, such as `build_row` and `combine`, which facilitate row and cell construction. The final output provides a clear textual representation of the entire table layout.\"\"\"\n    'Flatten table data into a single string with newlines.\\n\\n    :param iter table: Padded and bordered table data.\\n\\n    :return: Joined rows/cells.\\n    :rtype: str\\n    '\n    return '\\n'.join((''.join(r) for r in table))",
        "docstring": "Flatten a table into a single string, where each row is joined by newlines.\n\n:param iter table: An iterable containing padded and bordered table data, structured as a list of rows, where each row is a sequence of strings representing cells.\n\n:return: A single string that concatenates all the rows and cells in the table, separated by newline characters.\n:rtype: str\n\nThis function is designed to work with the output of functions that generate table structures elsewhere in the code, such as `build_row` and `combine`, which facilitate row and cell construction. The final output provides a clear textual representation of the entire table layout.",
        "signature": "def flatten(table):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/width_and_alignment.py": {
      "visible_width": {
        "code": "def visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string, accounting for multi-byte characters like CJK (Chinese, Japanese, Korean) symbols.\n\nParameters:\n- string (str): The input string for which the visible width is to be computed.\n\nReturns:\n- int: The visible width of the string as an integer.\n\nNotes:\n- The function removes ANSI color codes using the compiled regular expression RE_COLOR_ANSI, which is defined globally in the code.\n- It recognizes the width of each character using the `unicodedata.east_asian_width` method, where characters classified as 'F' (fullwidth) or 'W' (wide) contribute a width of 2, while all other characters contribute a width of 1.\n- It handles potential decoding of the input string, ensuring compatibility with both byte and unicode formats.\"\"\"\n    \"Get the visible width of a unicode string.\\n\\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\\n\\n    From: https://github.com/Robpol86/terminaltables3/pull/9\\n\\n    :param str string: String to measure.\\n\\n    :return: String's width.\\n    :rtype: int\\n    \"\n    if '\\x1b' in string:\n        string = RE_COLOR_ANSI.sub('', string)\n    try:\n        string = string.decode('u8')\n    except (AttributeError, UnicodeEncodeError):\n        pass\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in ('F', 'W'):\n            width += 2\n        else:\n            width += 1\n    return width",
        "docstring": "Get the visible width of a unicode string, accounting for multi-byte characters like CJK (Chinese, Japanese, Korean) symbols.\n\nParameters:\n- string (str): The input string for which the visible width is to be computed.\n\nReturns:\n- int: The visible width of the string as an integer.\n\nNotes:\n- The function removes ANSI color codes using the compiled regular expression RE_COLOR_ANSI, which is defined globally in the code.\n- It recognizes the width of each character using the `unicodedata.east_asian_width` method, where characters classified as 'F' (fullwidth) or 'W' (wide) contribute a width of 2, while all other characters contribute a width of 1.\n- It handles potential decoding of the input string, ensuring compatibility with both byte and unicode formats.",
        "signature": "def visible_width(string: str) -> int:",
        "type": "Function",
        "class_signature": null
      },
      "align_and_pad_cell": {
        "code": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n    \"\"\"Aligns a given string within specified dimensions through horizontal and vertical alignment while applying padding. The function takes into account the visibility of Unicode characters and adjusts for multiline text.\n\n:param str string: The string to be aligned and padded.\n:param tuple align: A tuple specifying horizontal alignment ('left', 'center', 'right') and vertical alignment ('top', 'middle', 'bottom').\n:param tuple inner_dimensions: A tuple containing width and height integers to define the space the string should fit into, excluding padding.\n:param iter padding: A list of four integers determining the number of padding spaces: left, right, top, and bottom.\n:param str space: A character used for padding; it defaults to a single space.\n\n:return: A list of strings representing the formatted and padded lines of the input string.\n:rtype: list\n\nThis function interacts with the `visible_width` function to accurately calculate the rendered width of the string, factoring in multibyte characters that can affect alignment in terminal displays. It also manages empty or newline-only strings by ensuring they are treated as valid input.\"\"\"\n    'Align a string horizontally and vertically. Also add additional padding in both dimensions.\\n\\n    :param str string: Input string to operate on.\\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\\n\\n    :return: Padded cell split into lines.\\n    :rtype: list\\n    '\n    if not hasattr(string, 'splitlines'):\n        string = str(string)\n    lines = string.splitlines() or ['']\n    if string.endswith('\\n'):\n        lines.append('')\n    if 'bottom' in align:\n        lines = [''] * (inner_dimensions[1] - len(lines) + padding[2]) + lines + [''] * padding[3]\n    elif 'middle' in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = [''] * (delta // 2 + delta % 2 + padding[2]) + lines + [''] * (delta // 2 + padding[3])\n    else:\n        lines = [''] * padding[2] + lines + [''] * (inner_dimensions[1] - len(lines) + padding[3])\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if 'right' in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + space * padding[1]\n        elif 'center' in align:\n            lines[i] = space * padding[0] + line.center(new_width, space) + space * padding[1]\n        else:\n            lines[i] = space * padding[0] + line.ljust(new_width + padding[1], space)\n    return lines",
        "docstring": "Aligns a given string within specified dimensions through horizontal and vertical alignment while applying padding. The function takes into account the visibility of Unicode characters and adjusts for multiline text.\n\n:param str string: The string to be aligned and padded.\n:param tuple align: A tuple specifying horizontal alignment ('left', 'center', 'right') and vertical alignment ('top', 'middle', 'bottom').\n:param tuple inner_dimensions: A tuple containing width and height integers to define the space the string should fit into, excluding padding.\n:param iter padding: A list of four integers determining the number of padding spaces: left, right, top, and bottom.\n:param str space: A character used for padding; it defaults to a single space.\n\n:return: A list of strings representing the formatted and padded lines of the input string.\n:rtype: list\n\nThis function interacts with the `visible_width` function to accurately calculate the rendered width of the string, factoring in multibyte characters that can affect alignment in terminal displays. It also manages empty or newline-only strings by ensuring they are treated as valid input.",
        "signature": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:",
        "type": "Function",
        "class_signature": null
      },
      "max_dimensions": {
        "code": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n    \"\"\"Get the maximum widths of each column and maximum heights of each row in a given table data structure. The function calculates these dimensions while considering any specified padding for each cell.\n\n:param iter table_data: A list of lists containing the unmodified table data, where each inner list represents a row and each string within represents a cell.\n:param int padding_left: The number of space characters to be added on the left side of each cell (default is 0).\n:param int padding_right: The number of space characters to be added on the right side of each cell (default is 0).\n:param int padding_top: The number of empty lines to be added on the top side of each cell (default is 0).\n:param int padding_bottom: The number of empty lines to be added on the bottom side of each cell (default is 0).\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column excluding padding.\n    - inner_heights: A list of maximum heights for each row.\n    - outer_widths: A list of widths for each column including specified padding.\n    - outer_heights: A list of heights for each row including specified padding.\n\nThis function interacts with the `visible_width` function to measure the widths of cell contents accurately, accounting for varying character widths in Unicode. This is important for ensuring proper alignment and appearance of the table when rendered on the terminal.\"\"\"\n    'Get maximum widths of each column and maximum height of each row.\\n\\n    :param iter table_data: List of list of strings (unmodified table data).\\n    :param int padding_left: Number of space chars on left side of cell.\\n    :param int padding_right: Number of space chars on right side of cell.\\n    :param int padding_top: Number of empty lines on top side of cell.\\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\\n\\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\\n    :rtype: tuple\\n    '\n    inner_widths = [0] * (max((len(r) for r in table_data)) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, 'count') or not hasattr(cell, 'splitlines'):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count('\\n') + 1)\n            inner_widths[i] = max(inner_widths[i], *[visible_width(the_line) for the_line in cell.splitlines()])\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n    return (inner_widths, inner_heights, outer_widths, outer_heights)",
        "docstring": "Get the maximum widths of each column and maximum heights of each row in a given table data structure. The function calculates these dimensions while considering any specified padding for each cell.\n\n:param iter table_data: A list of lists containing the unmodified table data, where each inner list represents a row and each string within represents a cell.\n:param int padding_left: The number of space characters to be added on the left side of each cell (default is 0).\n:param int padding_right: The number of space characters to be added on the right side of each cell (default is 0).\n:param int padding_top: The number of empty lines to be added on the top side of each cell (default is 0).\n:param int padding_bottom: The number of empty lines to be added on the bottom side of each cell (default is 0).\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column excluding padding.\n    - inner_heights: A list of maximum heights for each row.\n    - outer_widths: A list of widths for each column including specified padding.\n    - outer_heights: A list of heights for each row including specified padding.\n\nThis function interacts with the `visible_width` function to measure the widths of cell contents accurately, accounting for varying character widths in Unicode. This is important for ensuring proper alignment and appearance of the table when rendered on the terminal.",
        "signature": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/base_table.py": {
      "BaseTable.__init__": {
        "code": "    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Initializes a BaseTable instance with the provided table data and optional title.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list representing the table, which can be empty or consist of lists of strings, where each list corresponds to a row.\n- title (Optional[str]): An optional title that is displayed within the top border of the table.\n\nAttributes initialized:\n- inner_column_border (bool): Indicates if columns should be separated by inner borders; defaults to True.\n- inner_footing_row_border (bool): Indicates if a border should be shown before the last row; defaults to False.\n- inner_heading_row_border (bool): Indicates if a border should be shown after the first row; defaults to True.\n- inner_row_border (bool): Indicates if a border should be shown between every row; defaults to False.\n- outer_border (bool): Indicates if the table should have a border around its outer edges; defaults to True.\n- justify_columns (dict): A dictionary to set horizontal justification for columns where keys are column indexes and values are justification types (right, left, center).\n- padding_left (int): Number of spaces to pad on the left side of each cell; defaults to 1.\n- padding_right (int): Number of spaces to pad on the right side of each cell; defaults to 1.\n\nThis class serves as a base for creating formatted tables in a terminal setting, enabling customization of appearance and layout through its attributes.\"\"\"\n        'Constructor.\\n\\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\\n        :param title: Optional title to show within the top border of the table.\\n        '\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1",
        "docstring": "Initializes a BaseTable instance with the provided table data and optional title.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list representing the table, which can be empty or consist of lists of strings, where each list corresponds to a row.\n- title (Optional[str]): An optional title that is displayed within the top border of the table.\n\nAttributes initialized:\n- inner_column_border (bool): Indicates if columns should be separated by inner borders; defaults to True.\n- inner_footing_row_border (bool): Indicates if a border should be shown before the last row; defaults to False.\n- inner_heading_row_border (bool): Indicates if a border should be shown after the first row; defaults to True.\n- inner_row_border (bool): Indicates if a border should be shown between every row; defaults to False.\n- outer_border (bool): Indicates if the table should have a border around its outer edges; defaults to True.\n- justify_columns (dict): A dictionary to set horizontal justification for columns where keys are column indexes and values are justification types (right, left, center).\n- padding_left (int): Number of spaces to pad on the left side of each cell; defaults to 1.\n- padding_right (int): Number of spaces to pad on the right side of each cell; defaults to 1.\n\nThis class serves as a base for creating formatted tables in a terminal setting, enabling customization of appearance and layout through its attributes.",
        "signature": "def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.horizontal_border": {
        "code": "    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Builds a horizontal border for the table based on the specified style and column widths.\n\nThis method creates the visual border lines for the top, bottom, heading, and footing of the table. The border is constructed using character constants defined in the BaseTable class to maintain consistent styling. The method checks if inner column borders are enabled to determine the presence of intersecting characters.\n\nParameters:\n- style (str): The type of border requested ('top', 'bottom', 'heading', 'footing', or 'row').\n- outer_widths (Sequence[int]): A list of widths for each column, including any padding.\n\nReturns:\n- Tuple[str, ...]: A tuple of strings representing the prepared border line.\n\nConstants Used:\n- CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_TOP_LEFT, CHAR_OUTER_TOP_INTERSECT, CHAR_OUTER_TOP_RIGHT, CHAR_OUTER_BOTTOM_HORIZONTAL, CHAR_OUTER_BOTTOM_LEFT, CHAR_OUTER_BOTTOM_INTERSECT, CHAR_OUTER_BOTTOM_RIGHT, CHAR_H_INNER_HORIZONTAL, CHAR_H_OUTER_LEFT_INTERSECT, CHAR_H_INNER_INTERSECT, CHAR_H_OUTER_RIGHT_INTERSECT, CHAR_F_INNER_HORIZONTAL, CHAR_F_OUTER_LEFT_INTERSECT, CHAR_F_INNER_INTERSECT, CHAR_F_OUTER_RIGHT_INTERSECT: Define the visual characters used for borders and intersections based on the selected style. They are defined as class constants within BaseTable for easy customization and maintenance.\"\"\"\n        'Build any kind of horizontal border for the table.\\n\\n        :param str style: Type of border to return.\\n        :param iter outer_widths: List of widths (with padding) for each column.\\n\\n        :return: Prepared border as a tuple of strings.\\n        :rtype: tuple\\n        '\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)",
        "docstring": "Builds a horizontal border for the table based on the specified style and column widths.\n\nThis method creates the visual border lines for the top, bottom, heading, and footing of the table. The border is constructed using character constants defined in the BaseTable class to maintain consistent styling. The method checks if inner column borders are enabled to determine the presence of intersecting characters.\n\nParameters:\n- style (str): The type of border requested ('top', 'bottom', 'heading', 'footing', or 'row').\n- outer_widths (Sequence[int]): A list of widths for each column, including any padding.\n\nReturns:\n- Tuple[str, ...]: A tuple of strings representing the prepared border line.\n\nConstants Used:\n- CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_TOP_LEFT, CHAR_OUTER_TOP_INTERSECT, CHAR_OUTER_TOP_RIGHT, CHAR_OUTER_BOTTOM_HORIZONTAL, CHAR_OUTER_BOTTOM_LEFT, CHAR_OUTER_BOTTOM_INTERSECT, CHAR_OUTER_BOTTOM_RIGHT, CHAR_H_INNER_HORIZONTAL, CHAR_H_OUTER_LEFT_INTERSECT, CHAR_H_INNER_INTERSECT, CHAR_H_OUTER_RIGHT_INTERSECT, CHAR_F_INNER_HORIZONTAL, CHAR_F_OUTER_LEFT_INTERSECT, CHAR_F_INNER_INTERSECT, CHAR_F_OUTER_RIGHT_INTERSECT: Define the visual characters used for borders and intersections based on the selected style. They are defined as class constants within BaseTable for easy customization and maintenance.",
        "signature": "def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_row_lines": {
        "code": "    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine cells in a table row and group them into lines with vertical borders. This method prepares each cell by aligning and padding its content, and it supports multi-line cells by adjusting height accordingly. Depending on the provided style, it uses predefined constants for border characters (e.g., `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`) to determine how to display the vertical borders.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row in the table, which may include multi-line cells.\n- style (str): Specifies the style of border characters to apply (e.g., \"heading\", \"footing\", or \"row\").\n- inner_widths (Sequence[int]): A sequence indicating the widths of each column without padding.\n- height (int): The number of lines to which the row should be expanded, allowing for multi-line cell support.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples of strings that represent the formatted lines of the row, ready to be joined into printable format.\n\nImportant Constants:\n- `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, `CHAR_H_OUTER_RIGHT_VERTICAL`: These constants, defined in the BaseTable class, denote the characters used for vertical borders based on the specified style (heading, footing, row) and whether outer borders are enabled.\"\"\"\n        \"Combine cells in row and group them into lines with vertical borders.\\n\\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\\n        newline character to the end of joined line.\\n\\n        In:\\n        ['Row One Column One', 'Two', 'Three']\\n        Out:\\n        [\\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\\n        ]\\n\\n        In:\\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\\n        Out:\\n        [\\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\\n        ]\\n\\n        :param iter row: One row in the table. List of cells.\\n        :param str style: Type of border characters to use.\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\\n\\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\\n        \"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)",
        "docstring": "Combine cells in a table row and group them into lines with vertical borders. This method prepares each cell by aligning and padding its content, and it supports multi-line cells by adjusting height accordingly. Depending on the provided style, it uses predefined constants for border characters (e.g., `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`) to determine how to display the vertical borders.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row in the table, which may include multi-line cells.\n- style (str): Specifies the style of border characters to apply (e.g., \"heading\", \"footing\", or \"row\").\n- inner_widths (Sequence[int]): A sequence indicating the widths of each column without padding.\n- height (int): The number of lines to which the row should be expanded, allowing for multi-line cell support.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples of strings that represent the formatted lines of the row, ready to be joined into printable format.\n\nImportant Constants:\n- `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, `CHAR_H_OUTER_RIGHT_VERTICAL`: These constants, defined in the BaseTable class, denote the characters used for vertical borders based on the specified style (heading, footing, row) and whether outer borders are enabled.",
        "signature": "def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_table": {
        "code": "    def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything to yield each line of the entire formatted table with borders.\n\nThis method generates the complete string representation of the table, including the top and bottom borders, row contents, and possible separators for heading and footing rows. It leverages the `horizontal_border` method to create the appropriate borders based on the specified style.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be assembled and printed.\n\nDependencies:\n- Depends on the attributes `outer_border`, `inner_heading_row_border`, `inner_footing_row_border`, and `inner_row_border` to determine how to format the borders and separators.\n- Utilizes the `gen_row_lines` method to format individual rows and the `horizontal_border` method for creating border lines.\"\"\"\n        'Combine everything and yield every line of the entire table with borders.\\n\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param iter inner_heights: List of heights (no padding) for each row.\\n        :param iter outer_widths: List of widths (with padding) for each column.\\n        :return:\\n        '\n        if self.outer_border:\n            yield self.horizontal_border('top', outer_widths)\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = (row_count - 1, row_count - 2)\n        for i, row in enumerate(self.table_data):\n            if self.inner_heading_row_border and i == 0:\n                style = 'heading'\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = 'footing'\n            else:\n                style = 'row'\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            if i == last_row_index:\n                break\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border('heading', outer_widths)\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border('footing', outer_widths)\n            elif self.inner_row_border:\n                yield self.horizontal_border('row', outer_widths)\n        if self.outer_border:\n            yield self.horizontal_border('bottom', outer_widths)",
        "docstring": "Combine everything to yield each line of the entire formatted table with borders.\n\nThis method generates the complete string representation of the table, including the top and bottom borders, row contents, and possible separators for heading and footing rows. It leverages the `horizontal_border` method to create the appropriate borders based on the specified style.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be assembled and printed.\n\nDependencies:\n- Depends on the attributes `outer_border`, `inner_heading_row_border`, `inner_footing_row_border`, and `inner_row_border` to determine how to format the borders and separators.\n- Utilizes the `gen_row_lines` method to format individual rows and the `horizontal_border` method for creating border lines.",
        "signature": "def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: terminaltables-test_gen_table\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u251c\u2500\u2500 base_table.py\n    \u2502   \u251c\u2500\u2500 BaseTable.__init__\n    \u2502   \u251c\u2500\u2500 BaseTable.gen_row_lines\n    \u2502   \u251c\u2500\u2500 BaseTable.gen_table\n    \u2502   \u2514\u2500\u2500 BaseTable.horizontal_border\n    \u251c\u2500\u2500 build.py\n    \u2502   \u251c\u2500\u2500 build_border\n    \u2502   \u251c\u2500\u2500 build_row\n    \u2502   \u251c\u2500\u2500 combine\n    \u2502   \u2514\u2500\u2500 flatten\n    \u2514\u2500\u2500 width_and_alignment.py\n        \u251c\u2500\u2500 align_and_pad_cell\n        \u251c\u2500\u2500 max_dimensions\n        \u2514\u2500\u2500 visible_width\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides comprehensive functionality for generating and customizing tabular representations of data with support for fine-grained control over table borders, padding, and alignment. It enables users to define both inner and outer table borders, customize heading, footing, and row borders, and format tables with flexible layouts, including scenarios with minimal data or empty tables. The module ensures accurate rendering of table structures by calculating dimensions and layouts dynamically based on the input data and user-defined parameters. By offering configurable and visually structured tables, it simplifies the process of creating organized tabular outputs, addressing the common challenges developers face when formatting data for terminals or text-based interfaces.\n\n## FILE 1: terminaltables3/build.py\n\n- FUNCTION NAME: build_border\n  - SIGNATURE: def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds a border for a table, potentially embedding a title within it. The function computes the appearance of the border based on the widths of the columns, characters used for the left, right, and intersect borders, and the provided title. If the title cannot fit within the border, it is omitted.\n\nParameters:\n- outer_widths (Sequence[int]): List of widths for each column, including padding.\n- horizontal (str): Character used to fill the width of each column.\n- left (str): Character for the left border of the table.\n- intersect (str): Character used as the column separator.\n- right (str): Character for the right border of the table.\n- title (Optional[str]): An optional title to display within the border.\n\nReturns:\n- Generator of strings representing the constructed border.\n\nDependencies:\n- The function uses `visible_width` from `terminaltables3.width_and_alignment` to determine the width of the title for fitting calculations, ensuring the title does not exceed the available space in relation to the left and right borders.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n    - terminaltables3/build.py:combine\n\n- FUNCTION NAME: combine\n  - SIGNATURE: def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine elements of an iterable with specified border characters to form structured rows for table display.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items (integers or strings) that are to be combined into a single structured output.\n- left (str): The character(s) to use as the left border of the combined output.\n- intersect (Optional[str]): The character(s) used to separate the elements in the combined output. If None, no separators will be included.\n- right (str): The character(s) to use as the right border of the combined output.\n\nReturns:\n- Generator[int, None, None]: A generator yielding the combined elements, structured with the specified borders and separators. The function handles both iterable sequences and generators, ensuring compatibility while yielding each item surrounded by the defined borders and separators.\n\nThis function interacts with the `build_row` and `build_border` functions to create structured table rows and borders, enhancing table formatting in display-related functionalities.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/build.py:flatten\n\n- FUNCTION NAME: build_row\n  - SIGNATURE: def build_row(row, left, center, right):\n  - DOCSTRING: \n```python\n\"\"\"\nCombine single or multi-lined cells into a formatted row with borders.\n\nThis function takes a row represented as a list of lists (where each inner list \ncontains cell data) and combines the cells into a single row by adding specified \nborders and a column separator.\n\n:param iter row: List of lists corresponding to the cells of one row, where each \n                 inner list contains strings representing the content of the cells.\n:param str left: Character(s) to use as the left border of the row.\n:param str center: Character(s) to use as the column separator between cells.\n:param str right: Character(s) to use as the right border of the row.\n\n:yield: Yields generators that produce strings for each combined row with borders.\n:rtype: iter\n\nIf the row is empty or the first inner list is empty, it yields an empty row with borders.\nOtherwise, it iterates through the number of lines in the first cell (assuming all \ncells are padded to the same height) and combines the corresponding entries from each \ncell using the `combine` function, which is defined elsewhere in the code.\n\"\"\"\n```\n\n- FUNCTION NAME: flatten\n  - SIGNATURE: def flatten(table):\n  - DOCSTRING: \n```python\n\"\"\"\nFlatten a table into a single string, where each row is joined by newlines.\n\n:param iter table: An iterable containing padded and bordered table data, structured as a list of rows, where each row is a sequence of strings representing cells.\n\n:return: A single string that concatenates all the rows and cells in the table, separated by newline characters.\n:rtype: str\n\nThis function is designed to work with the output of functions that generate table structures elsewhere in the code, such as `build_row` and `combine`, which facilitate row and cell construction. The final output provides a clear textual representation of the entire table layout.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/base_table.py:BaseTable:gen_table\n    - terminaltables3/build.py:combine\n\n## FILE 2: terminaltables3/width_and_alignment.py\n\n- FUNCTION NAME: align_and_pad_cell\n  - SIGNATURE: def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nAligns a given string within specified dimensions through horizontal and vertical alignment while applying padding. The function takes into account the visibility of Unicode characters and adjusts for multiline text.\n\n:param str string: The string to be aligned and padded.\n:param tuple align: A tuple specifying horizontal alignment ('left', 'center', 'right') and vertical alignment ('top', 'middle', 'bottom').\n:param tuple inner_dimensions: A tuple containing width and height integers to define the space the string should fit into, excluding padding.\n:param iter padding: A list of four integers determining the number of padding spaces: left, right, top, and bottom.\n:param str space: A character used for padding; it defaults to a single space.\n\n:return: A list of strings representing the formatted and padded lines of the input string.\n:rtype: list\n\nThis function interacts with the `visible_width` function to accurately calculate the rendered width of the string, factoring in multibyte characters that can affect alignment in terminal displays. It also manages empty or newline-only strings by ensuring they are treated as valid input.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: max_dimensions\n  - SIGNATURE: def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the maximum widths of each column and maximum heights of each row in a given table data structure. The function calculates these dimensions while considering any specified padding for each cell.\n\n:param iter table_data: A list of lists containing the unmodified table data, where each inner list represents a row and each string within represents a cell.\n:param int padding_left: The number of space characters to be added on the left side of each cell (default is 0).\n:param int padding_right: The number of space characters to be added on the right side of each cell (default is 0).\n:param int padding_top: The number of empty lines to be added on the top side of each cell (default is 0).\n:param int padding_bottom: The number of empty lines to be added on the bottom side of each cell (default is 0).\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column excluding padding.\n    - inner_heights: A list of maximum heights for each row.\n    - outer_widths: A list of widths for each column including specified padding.\n    - outer_heights: A list of heights for each row including specified padding.\n\nThis function interacts with the `visible_width` function to measure the widths of cell contents accurately, accounting for varying character widths in Unicode. This is important for ensuring proper alignment and appearance of the table when rendered on the terminal.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: visible_width\n  - SIGNATURE: def visible_width(string: str) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the visible width of a unicode string, accounting for multi-byte characters like CJK (Chinese, Japanese, Korean) symbols.\n\nParameters:\n- string (str): The input string for which the visible width is to be computed.\n\nReturns:\n- int: The visible width of the string as an integer.\n\nNotes:\n- The function removes ANSI color codes using the compiled regular expression RE_COLOR_ANSI, which is defined globally in the code.\n- It recognizes the width of each character using the `unicodedata.east_asian_width` method, where characters classified as 'F' (fullwidth) or 'W' (wide) contribute a width of 2, while all other characters contribute a width of 1.\n- It handles potential decoding of the input string, ensuring compatibility with both byte and unicode formats.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:max_dimensions\n\n## FILE 3: terminaltables3/base_table.py\n\n- CLASS METHOD: BaseTable.gen_row_lines\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine cells in a table row and group them into lines with vertical borders. This method prepares each cell by aligning and padding its content, and it supports multi-line cells by adjusting height accordingly. Depending on the provided style, it uses predefined constants for border characters (e.g., `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`) to determine how to display the vertical borders.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row in the table, which may include multi-line cells.\n- style (str): Specifies the style of border characters to apply (e.g., \"heading\", \"footing\", or \"row\").\n- inner_widths (Sequence[int]): A sequence indicating the widths of each column without padding.\n- height (int): The number of lines to which the row should be expanded, allowing for multi-line cell support.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields tuples of strings that represent the formatted lines of the row, ready to be joined into printable format.\n\nImportant Constants:\n- `CHAR_H_OUTER_LEFT_VERTICAL`, `CHAR_H_INNER_VERTICAL`, `CHAR_H_OUTER_RIGHT_VERTICAL`: These constants, defined in the BaseTable class, denote the characters used for vertical borders based on the specified style (heading, footing, row) and whether outer borders are enabled.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.__init__\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a BaseTable instance with the provided table data and optional title.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list representing the table, which can be empty or consist of lists of strings, where each list corresponds to a row.\n- title (Optional[str]): An optional title that is displayed within the top border of the table.\n\nAttributes initialized:\n- inner_column_border (bool): Indicates if columns should be separated by inner borders; defaults to True.\n- inner_footing_row_border (bool): Indicates if a border should be shown before the last row; defaults to False.\n- inner_heading_row_border (bool): Indicates if a border should be shown after the first row; defaults to True.\n- inner_row_border (bool): Indicates if a border should be shown between every row; defaults to False.\n- outer_border (bool): Indicates if the table should have a border around its outer edges; defaults to True.\n- justify_columns (dict): A dictionary to set horizontal justification for columns where keys are column indexes and values are justification types (right, left, center).\n- padding_left (int): Number of spaces to pad on the left side of each cell; defaults to 1.\n- padding_right (int): Number of spaces to pad on the right side of each cell; defaults to 1.\n\nThis class serves as a base for creating formatted tables in a terminal setting, enabling customization of appearance and layout through its attributes.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.horizontal_border\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds a horizontal border for the table based on the specified style and column widths.\n\nThis method creates the visual border lines for the top, bottom, heading, and footing of the table. The border is constructed using character constants defined in the BaseTable class to maintain consistent styling. The method checks if inner column borders are enabled to determine the presence of intersecting characters.\n\nParameters:\n- style (str): The type of border requested ('top', 'bottom', 'heading', 'footing', or 'row').\n- outer_widths (Sequence[int]): A list of widths for each column, including any padding.\n\nReturns:\n- Tuple[str, ...]: A tuple of strings representing the prepared border line.\n\nConstants Used:\n- CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_TOP_LEFT, CHAR_OUTER_TOP_INTERSECT, CHAR_OUTER_TOP_RIGHT, CHAR_OUTER_BOTTOM_HORIZONTAL, CHAR_OUTER_BOTTOM_LEFT, CHAR_OUTER_BOTTOM_INTERSECT, CHAR_OUTER_BOTTOM_RIGHT, CHAR_H_INNER_HORIZONTAL, CHAR_H_OUTER_LEFT_INTERSECT, CHAR_H_INNER_INTERSECT, CHAR_H_OUTER_RIGHT_INTERSECT, CHAR_F_INNER_HORIZONTAL, CHAR_F_OUTER_LEFT_INTERSECT, CHAR_F_INNER_INTERSECT, CHAR_F_OUTER_RIGHT_INTERSECT: Define the visual characters used for borders and intersections based on the selected style. They are defined as class constants within BaseTable for easy customization and maintenance.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.gen_table\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine everything to yield each line of the entire formatted table with borders.\n\nThis method generates the complete string representation of the table, including the top and bottom borders, row contents, and possible separators for heading and footing rows. It leverages the `horizontal_border` method to create the appropriate borders based on the specified style.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be assembled and printed.\n\nDependencies:\n- Depends on the attributes `outer_border`, `inner_heading_row_border`, `inner_footing_row_border`, and `inner_row_border` to determine how to format the borders and separators.\n- Utilizes the `gen_row_lines` method to format individual rows and the `horizontal_border` method for creating border lines.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\nfrom typing import Generator, Iterator, Optional, Sequence, Union\nfrom terminaltables3.width_and_alignment import visible_width",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\nfrom terminaltables3.terminal_io import terminal_size\nRE_COLOR_ANSI = re.compile('(\\\\033\\\\[[\\\\d;]+m)')\n\ndef column_max_width(inner_widths: Sequence[int], column_number: int, outer_border: int, inner_border: int, padding: int) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n    data_space = sum(inner_widths) - inner_widths[column_number]\n    return terminal_width - data_space - non_data_space\n\ndef table_width(outer_widths: Sequence[int], outer_border: int, inner_border: int) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n    data_space = sum(outer_widths)\n    return data_space + non_data_space",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\nfrom typing import Generator, Optional, Sequence, Tuple\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '-'\n    CHAR_F_INNER_INTERSECT = '+'\n    CHAR_F_INNER_VERTICAL = '|'\n    CHAR_F_OUTER_LEFT_INTERSECT = '+'\n    CHAR_F_OUTER_LEFT_VERTICAL = '|'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_H_INNER_HORIZONTAL = '-'\n    CHAR_H_INNER_INTERSECT = '+'\n    CHAR_H_INNER_VERTICAL = '|'\n    CHAR_H_OUTER_LEFT_INTERSECT = '+'\n    CHAR_H_OUTER_LEFT_VERTICAL = '|'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_INNER_HORIZONTAL = '-'\n    CHAR_INNER_INTERSECT = '+'\n    CHAR_INNER_VERTICAL = '|'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '-'\n    CHAR_OUTER_BOTTOM_INTERSECT = '+'\n    CHAR_OUTER_BOTTOM_LEFT = '+'\n    CHAR_OUTER_BOTTOM_RIGHT = '+'\n    CHAR_OUTER_LEFT_INTERSECT = '+'\n    CHAR_OUTER_LEFT_VERTICAL = '|'\n    CHAR_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_OUTER_TOP_HORIZONTAL = '-'\n    CHAR_OUTER_TOP_INTERSECT = '+'\n    CHAR_OUTER_TOP_LEFT = '+'\n    CHAR_OUTER_TOP_RIGHT = '+'\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(self.table_data, self.padding_left, self.padding_right)[:3]\n        return flatten(self.gen_table(*dimensions))"
  },
  "call_tree": {
    "tests/test_base_table/test_gen_table.py:test_inner_row_borders": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {}
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    },
    "tests/test_base_table/test_gen_table.py:test_outer_borders": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {
              "terminaltables3/width_and_alignment.py:visible_width": {},
              "terminaltables3/build.py:combine": {}
            }
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    },
    "tests/test_base_table/test_gen_table.py:test_one_no_rows": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {}
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    }
  }
}