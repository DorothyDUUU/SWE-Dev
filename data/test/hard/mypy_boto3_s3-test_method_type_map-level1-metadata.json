{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_method_type_map",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_maps/test_method_type_map.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.type_maps.method_type_map import (\n    get_default_value_stub,\n    get_method_type_stub,\n)\n\n\nclass TestMethodTypeMap:\n    def test_get_method_type_stub(self) -> None:\n        assert get_method_type_stub(ServiceNameCatalog.s3, \"Client\", \"copy_object\", \"CopySource\")\n        assert (\n            get_method_type_stub(ServiceNameCatalog.s3, \"Client\", \"copy_object\", \"Unknown\") is None\n        )\n        assert (\n            get_method_type_stub(ServiceNameCatalog.logs, \"Client\", \"copy_object\", \"Unknown\")\n            is None\n        )\n        assert get_method_type_stub(\n            ServiceNameCatalog.sqs,\n            \"SomeResource\",\n            \"receive_messages\",\n            \"AttributeNames\",\n        )\n        assert (\n            get_method_type_stub(\n                ServiceNameCatalog.sqs,\n                \"SomeResource\",\n                \"receive_messages\",\n                \"Attribute\",\n            )\n            is None\n        )\n\n    def test_get_default_value_stub(self) -> None:\n        assert get_default_value_stub(ServiceNameCatalog.glacier, \"Client\", \"*\", \"accountId\")\n        assert get_default_value_stub(ServiceNameCatalog.glacier, \"Client\", \"test\", \"accountId\")\n        assert get_default_value_stub(ServiceNameCatalog.glacier, \"Client\", \"*\", \"any\") is None\n        assert get_default_value_stub(ServiceNameCatalog.ec2, \"Client\", \"*\", \"accountId\") is None\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_maps/method_type_map.py": "\"\"\"\nString to type annotation map that find type annotation by method and argument name.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Mapping\nfrom typing import Final, TypeVar\n\nfrom boto3.dynamodb.table import BatchWriter\n\nfrom mypy_boto3_builder.constants import ALL, CLIENT\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_maps.literals import QueueAttributeFilterType\nfrom mypy_boto3_builder.type_maps.named_unions import (\n    ConditionBaseImportTypeDef,\n    CopySourceOrStrTypeDef,\n)\nfrom mypy_boto3_builder.type_maps.typed_dicts import CopySourceTypeDef\nfrom mypy_boto3_builder.utils.lookup_dict import LookupDict\n\n__all__ = (\"get_method_type_stub\",)\n\n_T = TypeVar(\"_T\", bound=FakeAnnotation)\nServiceTypeMap = Mapping[ServiceName, Mapping[str, Mapping[str, Mapping[str, _T]]]]\n\n\n# Mapping representing default values for botocore methods.\n# ServiceName -> TypedDict name -> Argument name -> default value\n# Missing value is set to Ellipsis.\nDEFAULT_VALUE_MAP: Final[ServiceTypeMap[TypeConstant]] = {\n    ServiceNameCatalog.glacier: {\n        CLIENT: {\n            ALL: {\n                \"accountId\": TypeConstant(\"-\"),\n            },\n        },\n    },\n}\n\n_DEFAULT_VALUE_MAP_LOOKUP: LookupDict[TypeConstant] = LookupDict(\n    {ServiceNameCatalog.to_str(k): v for k, v in DEFAULT_VALUE_MAP.items()},\n)\n\n# Mapping overriding type annotations for botocore method arguments.\n# ServiceName -> TypedDict name -> Argument name -> type annotation\n# Missing value is parsed from botocore shapes.\nTYPE_MAP: Final[ServiceTypeMap[FakeAnnotation]] = {\n    ServiceNameCatalog.s3: {\n        # FIXME: boto3 overrides CopySource parameters for some S3 methods.\n        # Types are set according to docs, might be incorrect\n        CLIENT: {\n            \"copy_object\": {\"CopySource\": CopySourceOrStrTypeDef},\n            \"upload_part_copy\": {\"CopySource\": CopySourceOrStrTypeDef},\n            \"copy\": {\"CopySource\": CopySourceTypeDef},\n        },\n        \"MultipartUploadPart\": {\n            \"copy_from\": {\"CopySource\": CopySourceOrStrTypeDef},\n        },\n        \"Bucket\": {\"copy\": {\"CopySource\": CopySourceTypeDef}},\n        \"Object\": {\n            \"copy\": {\"CopySource\": CopySourceTypeDef},\n            \"copy_from\": {\"CopySource\": CopySourceOrStrTypeDef},\n        },\n        \"ObjectSummary\": {\"copy_from\": {\"CopySource\": CopySourceOrStrTypeDef}},\n        # FIXME: https://github.com/boto/boto3/issues/3501\n        \"MultipartUpload\": {\"Part\": {\"part_number\": Type.int}},\n    },\n    ServiceNameCatalog.dynamodb: {\n        \"Table\": {\n            \"batch_writer\": {\"return\": ExternalImport.from_class(BatchWriter)},\n            \"query\": {\n                \"KeyConditionExpression\": ConditionBaseImportTypeDef,\n                \"FilterExpression\": ConditionBaseImportTypeDef,\n                \"ConditionExpression\": ConditionBaseImportTypeDef,\n            },\n            \"delete_item\": {\n                \"ConditionExpression\": ConditionBaseImportTypeDef,\n            },\n            \"put_item\": {\n                \"ConditionExpression\": ConditionBaseImportTypeDef,\n            },\n            \"update_item\": {\n                \"ConditionExpression\": ConditionBaseImportTypeDef,\n            },\n            \"scan\": {\n                \"FilterExpression\": ConditionBaseImportTypeDef,\n            },\n        },\n    },\n    ServiceNameCatalog.sqs: {\n        ALL: {\n            # FIXME: https://github.com/boto/botocore/issues/2726\n            \"receive_messages\": {\n                \"AttributeNames\": TypeSubscript(Type.Sequence, [QueueAttributeFilterType]),\n            },\n            \"receive_message\": {\n                \"AttributeNames\": TypeSubscript(Type.Sequence, [QueueAttributeFilterType]),\n            },\n            \"get_queue_attributes\": {\n                \"AttributeNames\": TypeSubscript(Type.Sequence, [QueueAttributeFilterType]),\n            },\n        },\n    },\n}\n\n_TYPE_MAP_LOOKUP: LookupDict[FakeAnnotation] = LookupDict(\n    {ServiceNameCatalog.to_str(k): v for k, v in TYPE_MAP.items()},\n)\n\n\ndef get_method_type_stub(\n    service_name: ServiceName,\n    class_name: str,\n    method_name: str,\n    argument_name: str,\n) -> FakeAnnotation | None:\n    \"\"\"\n    Get stub type for method argument.\n\n    Arguments:\n        service_name -- Service name.\n        class_name -- Parent class name.\n        method_name -- Method name.\n        argument_name -- Argument name.\n\n    Returns:\n        Type annotation or None.\n    \"\"\"\n    return _TYPE_MAP_LOOKUP.get(service_name.name, class_name, method_name, argument_name)\n\n\ndef get_default_value_stub(\n    service_name: ServiceName,\n    class_name: str,\n    method_name: str,\n    argument_name: str,\n) -> TypeConstant | None:\n    \"\"\"\n    Get default value stub for method argument.\n\n    Arguments:\n        service_name -- Service name.\n        class_name -- Parent class name.\n        method_name -- Method name.\n        argument_name -- Argument name.\n\n    Returns:\n        TypeConstant or None.\n    \"\"\"\n    return _DEFAULT_VALUE_MAP_LOOKUP.get(service_name.name, class_name, method_name, argument_name)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_maps/method_type_map.py": {
      "get_method_type_stub": {
        "code": "def get_method_type_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> FakeAnnotation | None:\n    \"\"\"Retrieve the type annotation for a specified method argument in a given service's class within the boto3 library.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class containing the method (e.g., 'Bucket', 'Table').\n    method_name (str): The name of the method to look up (e.g., 'copy', 'put_item').\n    argument_name (str): The name of the argument for which to retrieve the type annotation.\n\nReturns:\n    FakeAnnotation | None: The type annotation corresponding to the specified method and argument, or None if no matching annotation is found.\n\nThis function interacts with the _TYPE_MAP_LOOKUP constant, which is a LookupDict mapping service names, class names, method names, and argument names to their respective type annotations, based on the TYPE_MAP defined elsewhere in the code.\"\"\"\n    '\\n    Get stub type for method argument.\\n\\n    Arguments:\\n        service_name -- Service name.\\n        class_name -- Parent class name.\\n        method_name -- Method name.\\n        argument_name -- Argument name.\\n\\n    Returns:\\n        Type annotation or None.\\n    '\n    return _TYPE_MAP_LOOKUP.get(service_name.name, class_name, method_name, argument_name)",
        "docstring": "Retrieve the type annotation for a specified method argument in a given service's class within the boto3 library.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class containing the method (e.g., 'Bucket', 'Table').\n    method_name (str): The name of the method to look up (e.g., 'copy', 'put_item').\n    argument_name (str): The name of the argument for which to retrieve the type annotation.\n\nReturns:\n    FakeAnnotation | None: The type annotation corresponding to the specified method and argument, or None if no matching annotation is found.\n\nThis function interacts with the _TYPE_MAP_LOOKUP constant, which is a LookupDict mapping service names, class names, method names, and argument names to their respective type annotations, based on the TYPE_MAP defined elsewhere in the code.",
        "signature": "def get_method_type_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> FakeAnnotation | None:",
        "type": "Function",
        "class_signature": null
      },
      "get_default_value_stub": {
        "code": "def get_default_value_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> TypeConstant | None:\n    \"\"\"Retrieve the default value for a specified argument of a given method within a specified AWS service.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class that contains the method.\n    method_name (str): The name of the method for which the argument default value is requested.\n    argument_name (str): The name of the argument whose default value is being retrieved.\n\nReturns:\n    TypeConstant | None: The default value for the argument or None if no default value is found.\n\nThis function interacts with the _DEFAULT_VALUE_MAP_LOOKUP, which is a LookupDict created from DEFAULT_VALUE_MAP, mapping combinations of service names, class names, method names, and argument names to their respective default values for method arguments as defined in the botocore library, allowing for consistent access to these values across the application.\"\"\"\n    '\\n    Get default value stub for method argument.\\n\\n    Arguments:\\n        service_name -- Service name.\\n        class_name -- Parent class name.\\n        method_name -- Method name.\\n        argument_name -- Argument name.\\n\\n    Returns:\\n        TypeConstant or None.\\n    '\n    return _DEFAULT_VALUE_MAP_LOOKUP.get(service_name.name, class_name, method_name, argument_name)",
        "docstring": "Retrieve the default value for a specified argument of a given method within a specified AWS service.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class that contains the method.\n    method_name (str): The name of the method for which the argument default value is requested.\n    argument_name (str): The name of the argument whose default value is being retrieved.\n\nReturns:\n    TypeConstant | None: The default value for the argument or None if no default value is found.\n\nThis function interacts with the _DEFAULT_VALUE_MAP_LOOKUP, which is a LookupDict created from DEFAULT_VALUE_MAP, mapping combinations of service names, class names, method names, and argument names to their respective default values for method arguments as defined in the botocore library, allowing for consistent access to these values across the application.",
        "signature": "def get_default_value_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> TypeConstant | None:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
      "mypy_boto3_builder/utils/lookup_dict.py": {
        "LookupDict.get": {
          "code": "    def get(self, *keys: str) -> _V | None:\n        \"\"\"\n        Get value by multiple keys.\n        \"\"\"\n        lookup = self._lookup\n        for lookup_keys in self._iterate_lookup_keys(keys):\n            result = lookup.get(lookup_keys)\n            if result is not None:\n                return result\n        return None",
          "docstring": "Get value by multiple keys.",
          "signature": "def get(self, *keys: str) -> _V | None:",
          "type": "Method",
          "class_signature": "class LookupDict(Generic[_V]):"
        }
      }
    },
    "mypy_boto3_builder/type_maps/method_type_map.py:get_default_value_stub": {
      "mypy_boto3_builder/utils/lookup_dict.py": {
        "LookupDict.get": {
          "code": "    def get(self, *keys: str) -> _V | None:\n        \"\"\"\n        Get value by multiple keys.\n        \"\"\"\n        lookup = self._lookup\n        for lookup_keys in self._iterate_lookup_keys(keys):\n            result = lookup.get(lookup_keys)\n            if result is not None:\n                return result\n        return None",
          "docstring": "Get value by multiple keys.",
          "signature": "def get(self, *keys: str) -> _V | None:",
          "type": "Method",
          "class_signature": "class LookupDict(Generic[_V]):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_method_type_map\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 type_maps/\n        \u2514\u2500\u2500 method_type_map.py\n            \u251c\u2500\u2500 get_default_value_stub\n            \u2514\u2500\u2500 get_method_type_stub\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the mapping and validation of method types and default values for AWS service client methods within the context of type-safe API interactions. It provides functionality to retrieve method type stubs and default value stubs based on the service, client type, method name, and parameter name, ensuring consistent and context-appropriate handling of these elements. By enabling structured lookup and verification of method and parameter compatibility, the module aids developers in building and maintaining strongly-typed interfaces for AWS SDKs. This reduces errors and enhances developer productivity by ensuring accurate typing and configuration during the development of AWS-integrated applications.\n\n## FILE 1: mypy_boto3_builder/type_maps/method_type_map.py\n\n- FUNCTION NAME: get_method_type_stub\n  - SIGNATURE: def get_method_type_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> FakeAnnotation | None:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the type annotation for a specified method argument in a given service's class within the boto3 library.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class containing the method (e.g., 'Bucket', 'Table').\n    method_name (str): The name of the method to look up (e.g., 'copy', 'put_item').\n    argument_name (str): The name of the argument for which to retrieve the type annotation.\n\nReturns:\n    FakeAnnotation | None: The type annotation corresponding to the specified method and argument, or None if no matching annotation is found.\n\nThis function interacts with the _TYPE_MAP_LOOKUP constant, which is a LookupDict mapping service names, class names, method names, and argument names to their respective type annotations, based on the TYPE_MAP defined elsewhere in the code.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get\n\n- FUNCTION NAME: get_default_value_stub\n  - SIGNATURE: def get_default_value_stub(service_name: ServiceName, class_name: str, method_name: str, argument_name: str) -> TypeConstant | None:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the default value for a specified argument of a given method within a specified AWS service.\n\nParameters:\n    service_name (ServiceName): The name of the AWS service (e.g., S3, DynamoDB).\n    class_name (str): The name of the class that contains the method.\n    method_name (str): The name of the method for which the argument default value is requested.\n    argument_name (str): The name of the argument whose default value is being retrieved.\n\nReturns:\n    TypeConstant | None: The default value for the argument or None if no default value is found.\n\nThis function interacts with the _DEFAULT_VALUE_MAP_LOOKUP, which is a LookupDict created from DEFAULT_VALUE_MAP, mapping combinations of service names, class names, method names, and argument names to their respective default values for method arguments as defined in the botocore library, allowing for consistent access to these values across the application.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_maps/method_type_map.py": "\"\"\"\nString to type annotation map that find type annotation by method and argument name.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Mapping\nfrom typing import Final, TypeVar\nfrom boto3.dynamodb.table import BatchWriter\nfrom mypy_boto3_builder.constants import ALL, CLIENT\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_maps.literals import QueueAttributeFilterType\nfrom mypy_boto3_builder.type_maps.named_unions import ConditionBaseImportTypeDef, CopySourceOrStrTypeDef\nfrom mypy_boto3_builder.type_maps.typed_dicts import CopySourceTypeDef\nfrom mypy_boto3_builder.utils.lookup_dict import LookupDict\n__all__ = ('get_method_type_stub',)\n_T = TypeVar('_T', bound=FakeAnnotation)\nServiceTypeMap = Mapping[ServiceName, Mapping[str, Mapping[str, Mapping[str, _T]]]]\nDEFAULT_VALUE_MAP: Final[ServiceTypeMap[TypeConstant]] = {ServiceNameCatalog.glacier: {CLIENT: {ALL: {'accountId': TypeConstant('-')}}}}\n_DEFAULT_VALUE_MAP_LOOKUP: LookupDict[TypeConstant] = LookupDict({ServiceNameCatalog.to_str(k): v for k, v in DEFAULT_VALUE_MAP.items()})\nTYPE_MAP: Final[ServiceTypeMap[FakeAnnotation]] = {ServiceNameCatalog.s3: {CLIENT: {'copy_object': {'CopySource': CopySourceOrStrTypeDef}, 'upload_part_copy': {'CopySource': CopySourceOrStrTypeDef}, 'copy': {'CopySource': CopySourceTypeDef}}, 'MultipartUploadPart': {'copy_from': {'CopySource': CopySourceOrStrTypeDef}}, 'Bucket': {'copy': {'CopySource': CopySourceTypeDef}}, 'Object': {'copy': {'CopySource': CopySourceTypeDef}, 'copy_from': {'CopySource': CopySourceOrStrTypeDef}}, 'ObjectSummary': {'copy_from': {'CopySource': CopySourceOrStrTypeDef}}, 'MultipartUpload': {'Part': {'part_number': Type.int}}}, ServiceNameCatalog.dynamodb: {'Table': {'batch_writer': {'return': ExternalImport.from_class(BatchWriter)}, 'query': {'KeyConditionExpression': ConditionBaseImportTypeDef, 'FilterExpression': ConditionBaseImportTypeDef, 'ConditionExpression': ConditionBaseImportTypeDef}, 'delete_item': {'ConditionExpression': ConditionBaseImportTypeDef}, 'put_item': {'ConditionExpression': ConditionBaseImportTypeDef}, 'update_item': {'ConditionExpression': ConditionBaseImportTypeDef}, 'scan': {'FilterExpression': ConditionBaseImportTypeDef}}}, ServiceNameCatalog.sqs: {ALL: {'receive_messages': {'AttributeNames': TypeSubscript(Type.Sequence, [QueueAttributeFilterType])}, 'receive_message': {'AttributeNames': TypeSubscript(Type.Sequence, [QueueAttributeFilterType])}, 'get_queue_attributes': {'AttributeNames': TypeSubscript(Type.Sequence, [QueueAttributeFilterType])}}}}\n_TYPE_MAP_LOOKUP: LookupDict[FakeAnnotation] = LookupDict({ServiceNameCatalog.to_str(k): v for k, v in TYPE_MAP.items()})"
  },
  "call_tree": {
    "tests/type_maps/test_method_type_map.py:TestMethodTypeMap:test_get_method_type_stub": {
      "mypy_boto3_builder/type_maps/method_type_map.py:get_method_type_stub": {
        "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
          "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
            }
          },
          "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
        }
      }
    },
    "tests/type_maps/test_method_type_map.py:TestMethodTypeMap:test_get_default_value_stub": {
      "mypy_boto3_builder/type_maps/method_type_map.py:get_default_value_stub": {
        "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:get": {
          "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_lookup": {
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_lookup": {},
            "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_generate_products": {
              "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_join_product": {}
            }
          },
          "mypy_boto3_builder/utils/lookup_dict.py:LookupDict:_iterate_lookup_keys": {}
        }
      }
    }
  }
}