{
  "dir_path": "/app/intervaltree",
  "package_name": "intervaltree",
  "sample_name": "intervaltree-issue41_test",
  "src_dir": "intervaltree/",
  "test_dir": "test/",
  "test_file": "test/issues/issue41_test.py",
  "test_code": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nTest module: IntervalTree, removal of intervals\nSubmitted as issue #41 (Interval removal breaks this tree) by escalonn\n\nCopyright 2013-2018 Chaim Leib Halbert\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom __future__ import absolute_import\nfrom intervaltree import IntervalTree\nfrom test import data\nimport pytest\n\n\ndef test_sequence():\n    t = IntervalTree()\n    t.addi(860, 917, 1)\n    t.verify()\n    t.addi(860, 917, 2)\n    t.verify()\n    t.addi(860, 917, 3)\n    t.verify()\n    t.addi(860, 917, 4)\n    t.verify()\n    t.addi(871, 917, 1)\n    t.verify()\n    t.addi(871, 917, 2)\n    t.verify()\n    t.addi(871, 917, 3)     # Value inserted here\n    t.verify()\n    t.addi(961, 986, 1)\n    t.verify()\n    t.addi(1047, 1064, 1)\n    t.verify()\n    t.addi(1047, 1064, 2)\n    t.verify()\n    t.removei(961, 986, 1)\n    t.verify()\n    t.removei(871, 917, 3)  # Deleted here\n    t.verify()\n\n\ndef test_structure():\n    \"\"\"\n    Reconstruct the original tree just before the removals, then\n    perform the removals.\n    \"\"\"\n    t = data.issue41_orig.tree()\n    t.verify()\n\n    t.removei(961, 986, 1)\n    t.verify()\n\n    t.removei(871, 917, 3)\n    t.verify()\n\n\nif __name__ == \"__main__\":\n    # pytest.main([__file__, '-v'])\n    test_structure()\n",
  "GT_file_code": {
    "intervaltree/node.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic: internal tree nodes.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom operator import attrgetter\nfrom math import floor, log\n\n\ndef l2(num):\n    \"\"\"\n    log base 2\n    :rtype real\n    \"\"\"\n    return log(num, 2)\n\n\nclass Node(object):\n    __slots__ = (\n        'x_center',\n        's_center',\n        'left_node',\n        'right_node',\n        'depth',\n        'balance'\n    )\n    def __init__(self,\n                 x_center=None,\n                 s_center=set(),\n                 left_node=None,\n                 right_node=None):\n        self.x_center = x_center\n        self.s_center = set(s_center)\n        self.left_node = left_node\n        self.right_node = right_node\n        self.depth = 0    # will be set when rotated\n        self.balance = 0  # ditto\n        self.rotate()\n\n    @classmethod\n    def from_interval(cls, interval):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        center = interval.begin\n        return Node(center, [interval])\n\n    @classmethod\n    def from_intervals(cls, intervals):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        if not intervals:\n            return None\n        return Node.from_sorted_intervals(sorted(intervals))\n\n    @classmethod\n    def from_sorted_intervals(cls, intervals):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        if not intervals:\n            return None\n        node = Node()\n        node = node.init_from_sorted(intervals)\n        return node\n\n    def init_from_sorted(self, intervals):\n        # assumes that intervals is a non-empty collection.\n        # Else, next line raises IndexError\n        center_iv = intervals[len(intervals) // 2]\n        self.x_center = center_iv.begin\n        self.s_center = set()\n        s_left = []\n        s_right = []\n        for k in intervals:\n            if k.end <= self.x_center:\n                s_left.append(k)\n            elif k.begin > self.x_center:\n                s_right.append(k)\n            else:\n                self.s_center.add(k)\n        self.left_node = Node.from_sorted_intervals(s_left)\n        self.right_node = Node.from_sorted_intervals(s_right)\n        return self.rotate()\n\n    def center_hit(self, interval):\n        \"\"\"Returns whether interval overlaps self.x_center.\"\"\"\n        return interval.contains_point(self.x_center)\n\n    def hit_branch(self, interval):\n        \"\"\"\n        Assuming not center_hit(interval), return which branch\n        (left=0, right=1) interval is in.\n        \"\"\"\n        return interval.begin > self.x_center\n\n    def refresh_balance(self):\n        \"\"\"\n        Recalculate self.balance and self.depth based on child node values.\n        \"\"\"\n        left_depth = self.left_node.depth if self.left_node else 0\n        right_depth = self.right_node.depth if self.right_node else 0\n        self.depth = 1 + max(left_depth, right_depth)\n        self.balance = right_depth - left_depth\n\n    def compute_depth(self):\n        \"\"\"\n        Recursively computes true depth of the subtree. Should only\n        be needed for debugging. Unless something is wrong, the\n        depth field should reflect the correct depth of the subtree.\n        \"\"\"\n        left_depth = self.left_node.compute_depth() if self.left_node else 0\n        right_depth = self.right_node.compute_depth() if self.right_node else 0\n        return 1 + max(left_depth, right_depth)\n\n    def rotate(self):\n        \"\"\"\n        Does rotating, if necessary, to balance this node, and\n        returns the new top node.\n        \"\"\"\n        self.refresh_balance()\n        if abs(self.balance) < 2:\n            return self\n        # balance > 0  is the heavy side\n        my_heavy = self.balance > 0\n        child_heavy = self[my_heavy].balance > 0\n        if my_heavy == child_heavy or self[my_heavy].balance == 0:\n            ## Heavy sides same\n            #    self     save\n            #  save   -> 1   self\n            # 1\n            #\n            ## Heavy side balanced\n            #    self     save         save\n            #  save   -> 1   self  -> 1  self.rot()\n            #  1  2         2\n            return self.srotate()\n        else:\n            return self.drotate()\n\n    def srotate(self):\n        \"\"\"Single rotation. Assumes that balance is +-2.\"\"\"\n        #     self        save         save\n        #   save 3  ->   1   self  -> 1   self.rot()\n        #  1   2            2   3\n        #\n        #  self            save                save\n        # 3   save  ->  self  1    -> self.rot()   1\n        #    2   1     3   2\n\n        #assert(self.balance != 0)\n        heavy = self.balance > 0\n        light = not heavy\n        save = self[heavy]\n        #print(\"srotate: bal={},{}\".format(self.balance, save.balance))\n        #self.print_structure()\n        self[heavy] = save[light]   # 2\n        #assert(save[light])\n        save[light] = self.rotate()  # Needed to ensure the 2 and 3 are balanced under new subnode\n\n        # Some intervals may overlap both self.x_center and save.x_center\n        # Promote those to the new tip of the tree\n        promotees = [iv for iv in save[light].s_center if save.center_hit(iv)]\n        if promotees:\n            for iv in promotees:\n                save[light] = save[light].remove(iv)  # may trigger pruning\n            # TODO: Use Node.add() here, to simplify future balancing improvements.\n            # For now, this is the same as augmenting save.s_center, but that may\n            # change.\n            save.s_center.update(promotees)\n        save.refresh_balance()\n        return save\n\n    def drotate(self):\n        # First rotation\n        my_heavy = self.balance > 0\n        self[my_heavy] = self[my_heavy].srotate()\n        self.refresh_balance()\n\n        # Second rotation\n        result = self.srotate()\n\n        return result\n\n    def add(self, interval):\n        \"\"\"\n        Returns self after adding the interval and balancing.\n        \"\"\"\n        if self.center_hit(interval):\n            self.s_center.add(interval)\n            return self\n        else:\n            direction = self.hit_branch(interval)\n            if not self[direction]:\n                self[direction] = Node.from_interval(interval)\n                self.refresh_balance()\n                return self\n            else:\n                self[direction] = self[direction].add(interval)\n                return self.rotate()\n\n    def remove(self, interval):\n        \"\"\"\n        Returns self after removing the interval and balancing.\n\n        If interval is not present, raise ValueError.\n        \"\"\"\n        # since this is a list, called methods can set this to [1],\n        # making it true\n        done = []\n        return self.remove_interval_helper(interval, done, should_raise_error=True)\n\n    def discard(self, interval):\n        \"\"\"\n        Returns self after removing interval and balancing.\n\n        If interval is not present, do nothing.\n        \"\"\"\n        done = []\n        return self.remove_interval_helper(interval, done, should_raise_error=False)\n\n    def remove_interval_helper(self, interval, done, should_raise_error):\n        \"\"\"\n        Returns self after removing interval and balancing.\n        If interval doesn't exist, raise ValueError.\n\n        This method may set done to [1] to tell all callers that\n        rebalancing has completed.\n\n        See Eternally Confuzzled's jsw_remove_r function (lines 1-32)\n        in his AVL tree article for reference.\n        \"\"\"\n        #trace = interval.begin == 347 and interval.end == 353\n        #if trace: print('\\nRemoving from {} interval {}'.format(\n        #   self.x_center, interval))\n        if self.center_hit(interval):\n            #if trace: print('Hit at {}'.format(self.x_center))\n            if not should_raise_error and interval not in self.s_center:\n                done.append(1)\n                #if trace: print('Doing nothing.')\n                return self\n            try:\n                # raises error if interval not present - this is\n                # desired.\n                self.s_center.remove(interval)\n            except:\n                self.print_structure()\n                raise KeyError(interval)\n            if self.s_center:     # keep this node\n                done.append(1)    # no rebalancing necessary\n                #if trace: print('Removed, no rebalancing.')\n                return self\n\n            # If we reach here, no intervals are left in self.s_center.\n            # So, prune self.\n            return self.prune()\n        else:  # interval not in s_center\n            direction = self.hit_branch(interval)\n\n            if not self[direction]:\n                if should_raise_error:\n                    raise ValueError\n                done.append(1)\n                return self\n\n            #if trace:\n            #   print('Descending to {} branch'.format(\n            #       ['left', 'right'][direction]\n            #       ))\n            self[direction] = self[direction].remove_interval_helper(interval, done, should_raise_error)\n\n            # Clean up\n            if not done:\n                #if trace:\n                #    print('Rotating {}'.format(self.x_center))\n                #    self.print_structure()\n                return self.rotate()\n            return self\n\n    def search_overlap(self, point_list):\n        \"\"\"\n        Returns all intervals that overlap the point_list.\n        \"\"\"\n        result = set()\n        for j in point_list:\n            self.search_point(j, result)\n        return result\n\n    def search_point(self, point, result):\n        \"\"\"\n        Returns all intervals that contain point.\n        \"\"\"\n        for k in self.s_center:\n            if k.begin <= point < k.end:\n                result.add(k)\n        if point < self.x_center and self[0]:\n            return self[0].search_point(point, result)\n        elif point > self.x_center and self[1]:\n            return self[1].search_point(point, result)\n        return result\n\n    def prune(self):\n        \"\"\"\n        On a subtree where the root node's s_center is empty,\n        return a new subtree with no empty s_centers.\n        \"\"\"\n        if not self[0] or not self[1]:    # if I have an empty branch\n            direction = not self[0]       # graft the other branch here\n            #if trace:\n            #    print('Grafting {} branch'.format(\n            #       'right' if direction else 'left'))\n\n            result = self[direction]\n            #if result: result.verify()\n            return result\n        else:\n            # Replace the root node with the greatest predecessor.\n            heir, self[0] = self[0].pop_greatest_child()\n            #if trace:\n            #    print('Replacing {} with {}.'.format(\n            #        self.x_center, heir.x_center\n            #        ))\n            #    print('Removed greatest predecessor:')\n            #    self.print_structure()\n\n            #if self[0]: self[0].verify()\n            #if self[1]: self[1].verify()\n\n            # Set up the heir as the new root node\n            (heir[0], heir[1]) = (self[0], self[1])\n            #if trace: print('Setting up the heir:')\n            #if trace: heir.print_structure()\n\n            # popping the predecessor may have unbalanced this node;\n            # fix it\n            heir.refresh_balance()\n            heir = heir.rotate()\n            #heir.verify()\n            #if trace: print('Rotated the heir:')\n            #if trace: heir.print_structure()\n            return heir\n\n    def pop_greatest_child(self):\n        \"\"\"\n        Used when pruning a node with both a left and a right branch.\n        Returns (greatest_child, node), where:\n          * greatest_child is a new node to replace the removed node.\n          * node is the subtree after:\n              - removing the greatest child\n              - balancing\n              - moving overlapping nodes into greatest_child\n\n        Assumes that self.s_center is not empty.\n\n        See Eternally Confuzzled's jsw_remove_r function (lines 34-54)\n        in his AVL tree article for reference.\n        \"\"\"\n        #print('Popping from {}'.format(self.x_center))\n        if not self.right_node:         # This node is the greatest child.\n            # To reduce the chances of an overlap with a parent, return\n            # a child node containing the smallest possible number of\n            # intervals, as close as possible to the maximum bound.\n            ivs = sorted(self.s_center, key=attrgetter('end', 'begin'))\n            max_iv = ivs.pop()\n            new_x_center = self.x_center\n            while ivs:\n                next_max_iv = ivs.pop()\n                if next_max_iv.end == max_iv.end: continue\n                new_x_center = max(new_x_center, next_max_iv.end)\n            def get_new_s_center():\n                for iv in self.s_center:\n                    if iv.contains_point(new_x_center): yield iv\n\n            # Create a new node with the largest x_center possible.\n            child = Node(new_x_center, get_new_s_center())\n            self.s_center -= child.s_center\n\n            #print('Pop hit! Returning child   = {}'.format(\n            #    child.print_structure(tostring=True)\n            #    ))\n            #assert not child[0]\n            #assert not child[1]\n\n            if self.s_center:\n                #print('     and returning newnode = {}'.format( self ))\n                #self.verify()\n                return child, self\n            else:\n                #print('     and returning newnode = {}'.format( self[0] ))\n                #if self[0]: self[0].verify()\n                return child, self[0]  # Rotate left child up\n\n        else:\n            #print('Pop descent to {}'.format(self[1].x_center))\n            (greatest_child, self[1]) = self[1].pop_greatest_child()\n\n            # Move any overlaps into greatest_child\n            for iv in set(self.s_center):\n                if iv.contains_point(greatest_child.x_center):\n                    self.s_center.remove(iv)\n                    greatest_child.add(iv)\n\n            #print('Pop Returning child   = {}'.format(\n            #    greatest_child.print_structure(tostring=True)\n            #    ))\n            if self.s_center:\n                #print('and returning newnode = {}'.format(\n                #    new_self.print_structure(tostring=True)\n                #    ))\n                #new_self.verify()\n                self.refresh_balance()\n                new_self = self.rotate()\n                return greatest_child, new_self\n            else:\n                new_self = self.prune()\n                #print('and returning prune = {}'.format(\n                #    new_self.print_structure(tostring=True)\n                #    ))\n                #if new_self: new_self.verify()\n                return greatest_child, new_self\n\n    def contains_point(self, p):\n        \"\"\"\n        Returns whether this node or a child overlaps p.\n        \"\"\"\n        for iv in self.s_center:\n            if iv.contains_point(p):\n                return True\n        branch = self[p > self.x_center]\n        return branch and branch.contains_point(p)\n\n    def all_children(self):\n        return self.all_children_helper(set())\n\n    def all_children_helper(self, result):\n        result.update(self.s_center)\n        if self[0]:\n            self[0].all_children_helper(result)\n        if self[1]:\n            self[1].all_children_helper(result)\n        return result\n\n    def verify(self, parents=set()):\n        \"\"\"\n        ## DEBUG ONLY ##\n        Recursively ensures that the invariants of an interval subtree\n        hold.\n        \"\"\"\n        assert(isinstance(self.s_center, set))\n\n        bal = self.balance\n        assert abs(bal) < 2, \\\n            \"Error: Rotation should have happened, but didn't! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n        self.refresh_balance()\n        assert bal == self.balance, \\\n            \"Error: self.balance not set correctly! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n\n        assert self.s_center, \\\n            \"Error: s_center is empty! \\n{}\".format(\n                self.print_structure(tostring=True)\n            )\n        for iv in self.s_center:\n            assert hasattr(iv, 'begin')\n            assert hasattr(iv, 'end')\n            assert iv.begin < iv.end\n            assert iv.overlaps(self.x_center)\n            for parent in sorted(parents):\n                assert not iv.contains_point(parent), \\\n                    \"Error: Overlaps ancestor ({})! \\n{}\\n\\n{}\".format(\n                        parent, iv, self.print_structure(tostring=True)\n                    )\n        if self[0]:\n            assert self[0].x_center < self.x_center, \\\n                \"Error: Out-of-order left child! {}\".format(self.x_center)\n            self[0].verify(parents.union([self.x_center]))\n        if self[1]:\n            assert self[1].x_center > self.x_center, \\\n                \"Error: Out-of-order right child! {}\".format(self.x_center)\n            self[1].verify(parents.union([self.x_center]))\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns the left child if input is equivalent to False, or\n        the right side otherwise.\n        \"\"\"\n        if index:\n            return self.right_node\n        else:\n            return self.left_node\n\n    def __setitem__(self, key, value):\n        \"\"\"Sets the left (0) or right (1) child.\"\"\"\n        if key:\n            self.right_node = value\n        else:\n            self.left_node = value\n\n    def __str__(self):\n        \"\"\"\n        Shows info about this node.\n\n        Since Nodes are internal data structures not revealed to the\n        user, I'm not bothering to make this copy-paste-executable as a\n        constructor.\n        \"\"\"\n        return \"Node<{0}, depth={1}, balance={2}>\".format(\n            self.x_center,\n            self.depth,\n            self.balance\n        )\n        #fieldcount = 'c_count,has_l,has_r = <{}, {}, {}>'.format(\n        #    len(self.s_center),\n        #    bool(self.left_node),\n        #    bool(self.right_node)\n        #)\n        #fields = [self.x_center, self.balance, fieldcount]\n        #return \"Node({}, b={}, {})\".format(*fields)\n\n    def count_nodes(self):\n        \"\"\"\n        Count the number of Nodes in this subtree.\n        :rtype: int\n        \"\"\"\n        count = 1\n        if self.left_node:\n            count += self.left_node.count_nodes()\n        if self.right_node:\n            count += self.right_node.count_nodes()\n        return count\n\n    def depth_score(self, n, m):\n        \"\"\"\n        Calculates flaws in balancing the tree.\n        :param n: size of tree\n        :param m: number of Nodes in tree\n        :rtype: real\n        \"\"\"\n        if n == 0:\n            return 0.0\n\n        # dopt is the optimal maximum depth of the tree\n        dopt = 1 + int(floor(l2(m)))\n        f = 1 / float(1 + n - dopt)\n        return f * self.depth_score_helper(1, dopt)\n\n    def depth_score_helper(self, d, dopt):\n        \"\"\"\n        Gets a weighted count of the number of Intervals deeper than dopt.\n        :param d: current depth, starting from 0\n        :param dopt: optimal maximum depth of a leaf Node\n        :rtype: real\n        \"\"\"\n        # di is how may levels deeper than optimal d is\n        di = d - dopt\n        if di > 0:\n            count = di * len(self.s_center)\n        else:\n            count = 0\n        if self.right_node:\n            count += self.right_node.depth_score_helper(d + 1, dopt)\n        if self.left_node:\n            count += self.left_node.depth_score_helper(d + 1, dopt)\n        return count\n\n    def print_structure(self, indent=0, tostring=False):\n        \"\"\"\n        For debugging.\n        \"\"\"\n        nl = '\\n'\n        sp = indent * '    '\n\n        rlist = [str(self) + nl]\n        if self.s_center:\n            for iv in sorted(self.s_center):\n                rlist.append(sp + ' ' + repr(iv) + nl)\n        if self.left_node:\n            rlist.append(sp + '<:  ')  # no CR\n            rlist.append(self.left_node.print_structure(indent + 1, True))\n        if self.right_node:\n            rlist.append(sp + '>:  ')  # no CR\n            rlist.append(self.right_node.print_structure(indent + 1, True))\n        result = ''.join(rlist)\n        if tostring:\n            return result\n        else:\n            print(result)\n",
    "intervaltree/intervaltree.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom .interval import Interval\nfrom .node import Node\nfrom numbers import Number\nfrom sortedcontainers import SortedDict\nfrom copy import copy\nfrom warnings import warn\n\ntry:\n    from collections.abc import MutableSet  # Python 3?\nexcept ImportError:\n    from collections import MutableSet\n\ntry:\n    xrange  # Python 2?\nexcept NameError:  # pragma: no cover\n    xrange = range\n\n\n# noinspection PyBroadException\nclass IntervalTree(MutableSet):\n    \"\"\"\n    A binary lookup tree of intervals.\n    The intervals contained in the tree are represented using ``Interval(a, b, data)`` objects.\n    Each such object represents a half-open interval ``[a, b)`` with optional data.\n\n    Examples:\n    ---------\n\n    Initialize a blank tree::\n\n        >>> tree = IntervalTree()\n        >>> tree\n        IntervalTree()\n\n    Initialize a tree from an iterable set of Intervals in O(n * log n)::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-20.0, -10.0)])\n        >>> tree\n        IntervalTree([Interval(-20.0, -10.0), Interval(-10, 10)])\n        >>> len(tree)\n        2\n\n    Note that this is a set, i.e. repeated intervals are ignored. However,\n    Intervals with different data fields are regarded as different::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-10, 10), Interval(-10, 10, \"x\")])\n        >>> tree\n        IntervalTree([Interval(-10, 10), Interval(-10, 10, 'x')])\n        >>> len(tree)\n        2\n\n    Insertions::\n        >>> tree = IntervalTree()\n        >>> tree[0:1] = \"data\"\n        >>> tree.add(Interval(10, 20))\n        >>> tree.addi(19.9, 20)\n        >>> tree\n        IntervalTree([Interval(0, 1, 'data'), Interval(10, 20), Interval(19.9, 20)])\n        >>> tree.update([Interval(19.9, 20.1), Interval(20.1, 30)])\n        >>> len(tree)\n        5\n\n        Inserting the same Interval twice does nothing::\n            >>> tree = IntervalTree()\n            >>> tree[-10:20] = \"arbitrary data\"\n            >>> tree[-10:20] = None  # Note that this is also an insertion\n            >>> tree\n            IntervalTree([Interval(-10, 20), Interval(-10, 20, 'arbitrary data')])\n            >>> tree[-10:20] = None  # This won't change anything\n            >>> tree[-10:20] = \"arbitrary data\" # Neither will this\n            >>> len(tree)\n            2\n\n    Deletions::\n        >>> tree = IntervalTree(Interval(b, e) for b, e in [(-10, 10), (-20, -10), (10, 20)])\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(-10, 10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        Traceback (most recent call last):\n        ...\n        ValueError\n        >>> tree.discard(Interval(-10, 10))  # Same as remove, but no exception on failure\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n\n    Delete intervals, overlapping a given point::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.1)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1)])\n\n    Delete intervals, overlapping an interval::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(0, 0.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.7, 1.8)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.6)  # Null interval does nothing\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.5)  # Ditto\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n\n    Delete intervals, enveloped in the range::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.0, 1.5)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.1, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.7)\n        >>> tree\n        IntervalTree()\n\n    Point queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[-1.1]   == set([Interval(-1.1, 1.1)])\n        >>> assert tree.at(1.1) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])   # Same as tree[1.1]\n        >>> assert tree.at(1.5) == set([Interval(0.5, 1.7)])                        # Same as tree[1.5]\n\n    Interval overlap queries\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.overlap(1.7, 1.8) == set()\n        >>> assert tree.overlap(1.5, 1.8) == set([Interval(0.5, 1.7)])\n        >>> assert tree[1.5:1.8] == set([Interval(0.5, 1.7)])                       # same as previous\n        >>> assert tree.overlap(1.1, 1.8) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[1.1:1.8] == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])  # same as previous\n\n    Interval envelop queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.envelop(-0.5, 0.5) == set()\n        >>> assert tree.envelop(-0.5, 1.5) == set([Interval(-0.5, 1.5)])\n\n    Membership queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> Interval(-0.5, 0.5) in tree\n        False\n        >>> Interval(-1.1, 1.1) in tree\n        True\n        >>> Interval(-1.1, 1.1, \"x\") in tree\n        False\n        >>> tree.overlaps(-1.1)\n        True\n        >>> tree.overlaps(1.7)\n        False\n        >>> tree.overlaps(1.7, 1.8)\n        False\n        >>> tree.overlaps(-1.2, -1.1)\n        False\n        >>> tree.overlaps(-1.2, -1.0)\n        True\n\n    Sizing::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> len(tree)\n        3\n        >>> tree.is_empty()\n        False\n        >>> IntervalTree().is_empty()\n        True\n        >>> not tree\n        False\n        >>> not IntervalTree()\n        True\n        >>> print(tree.begin())    # using print() because of floats in Python 2.6\n        -1.1\n        >>> print(tree.end())      # ditto\n        1.7\n\n    Iteration::\n\n        >>> tree = IntervalTree([Interval(-11, 11), Interval(-5, 15), Interval(5, 17)])\n        >>> [iv.begin for iv in sorted(tree)]\n        [-11, -5, 5]\n        >>> assert tree.items() == set([Interval(-5, 15), Interval(-11, 11), Interval(5, 17)])\n\n    Copy- and typecasting, pickling::\n\n        >>> tree0 = IntervalTree([Interval(0, 1, \"x\"), Interval(1, 2, [\"x\"])])\n        >>> tree1 = IntervalTree(tree0)  # Shares Interval objects\n        >>> tree2 = tree0.copy()         # Shallow copy (same as above, as Intervals are singletons)\n        >>> import pickle\n        >>> tree3 = pickle.loads(pickle.dumps(tree0))  # Deep copy\n        >>> list(tree0[1])[0].data[0] = \"y\"  # affects shallow copies, but not deep copies\n        >>> tree0\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree1\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree2\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree3\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['x'])])\n\n    Equality testing::\n\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1)])\n        True\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1, \"x\")])\n        False\n    \"\"\"\n    @classmethod\n    def from_tuples(cls, tups):\n        \"\"\"\n        Create a new IntervalTree from an iterable of 2- or 3-tuples,\n         where the tuple lists begin, end, and optionally data.\n        \"\"\"\n        ivs = [Interval(*t) for t in tups]\n        return IntervalTree(ivs)\n\n    def __init__(self, intervals=None):\n        \"\"\"\n        Set up a tree. If intervals is provided, add all the intervals\n        to the tree.\n\n        Completes in O(n*log n) time.\n        \"\"\"\n        intervals = set(intervals) if intervals is not None else set()\n        for iv in intervals:\n            if iv.is_null():\n                raise ValueError(\n                    \"IntervalTree: Null Interval objects not allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n        self.all_intervals = intervals\n        self.top_node = Node.from_intervals(self.all_intervals)\n        self.boundary_table = SortedDict()\n        for iv in self.all_intervals:\n            self._add_boundaries(iv)\n\n    def copy(self):\n        \"\"\"\n        Construct a new IntervalTree using shallow copies of the\n        intervals in the source tree.\n\n        Completes in O(n*log n) time.\n        :rtype: IntervalTree\n        \"\"\"\n        return IntervalTree(iv.copy() for iv in self)\n\n    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1\n\n    def _remove_boundaries(self, interval):\n        \"\"\"\n        Removes the boundaries of the interval from the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if self.boundary_table[begin] == 1:\n            del self.boundary_table[begin]\n        else:\n            self.boundary_table[begin] -= 1\n\n        if self.boundary_table[end] == 1:\n            del self.boundary_table[end]\n        else:\n            self.boundary_table[end] -= 1\n\n    def add(self, interval):\n        \"\"\"\n        Adds an interval to the tree, if not already present.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval in self:\n            return\n\n        if interval.is_null():\n            raise ValueError(\n                \"IntervalTree: Null Interval objects not allowed in IntervalTree:\"\n                \" {0}\".format(interval)\n            )\n\n        if not self.top_node:\n            self.top_node = Node.from_interval(interval)\n        else:\n            self.top_node = self.top_node.add(interval)\n        self.all_intervals.add(interval)\n        self._add_boundaries(interval)\n    append = add\n\n    def addi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for add(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.add(Interval(begin, end, data))\n    appendi = addi\n\n    def update(self, intervals):\n        \"\"\"\n        Given an iterable of intervals, add them to the tree.\n\n        Completes in O(m*log(n+m), where m = number of intervals to\n        add.\n        \"\"\"\n        for iv in intervals:\n            self.add(iv)\n\n    def remove(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, raises\n        ValueError.\n\n        Completes in O(log n) time.\n        \"\"\"\n        #self.verify()\n        if interval not in self:\n            #print(self.all_intervals)\n            raise ValueError\n        self.top_node = self.top_node.remove(interval)\n        self.all_intervals.remove(interval)\n        self._remove_boundaries(interval)\n        #self.verify()\n\n    def removei(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for remove(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.remove(Interval(begin, end, data))\n\n    def discard(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, does\n        nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval not in self:\n            return\n        self.all_intervals.discard(interval)\n        self.top_node = self.top_node.discard(interval)\n        self._remove_boundaries(interval)\n\n    def discardi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for discard(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.discard(Interval(begin, end, data))\n\n    def difference(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals in self but not\n        in other.\n        \"\"\"\n        ivs = set()\n        for iv in self:\n            if iv not in other:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def difference_update(self, other):\n        \"\"\"\n        Removes all intervals in other from self.\n        \"\"\"\n        for iv in other:\n            self.discard(iv)\n\n    def union(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals from self\n        and other.\n        \"\"\"\n        return IntervalTree(set(self).union(other))\n\n    def intersection(self, other):\n        \"\"\"\n        Returns a new tree of all intervals common to both self and\n        other.\n        \"\"\"\n        ivs = set()\n        shorter, longer = sorted([self, other], key=len)\n        for iv in shorter:\n            if iv in longer:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def intersection_update(self, other):\n        \"\"\"\n        Removes intervals from self unless they also exist in other.\n        \"\"\"\n        ivs = list(self)\n        for iv in ivs:\n            if iv not in other:\n                self.remove(iv)\n\n    def symmetric_difference(self, other):\n        \"\"\"\n        Return a tree with elements only in self or other but not\n        both.\n        \"\"\"\n        if not isinstance(other, set): other = set(other)\n        me = set(self)\n        ivs = me.difference(other).union(other.difference(me))\n        return IntervalTree(ivs)\n\n    def symmetric_difference_update(self, other):\n        \"\"\"\n        Throws out all intervals except those only in self or other,\n        not both.\n        \"\"\"\n        other = set(other)\n        ivs = list(self)\n        for iv in ivs:\n            if iv in other:\n                self.remove(iv)\n                other.remove(iv)\n        self.update(other)\n\n    def remove_overlap(self, begin, end=None):\n        \"\"\"\n        Removes all intervals overlapping the given point or range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range (this is 1 for a point)\n        \"\"\"\n        hitlist = self.at(begin) if end is None else self.overlap(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def remove_envelop(self, begin, end):\n        \"\"\"\n        Removes all intervals completely enveloped in the given range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range\n        \"\"\"\n        hitlist = self.envelop(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def chop(self, begin, end, datafunc=None):\n        \"\"\"\n        Like remove_envelop(), but trims back Intervals hanging into\n        the chopped area so that nothing overlaps.\n        \"\"\"\n        insertions = set()\n        begin_hits = [iv for iv in self.at(begin) if iv.begin < begin]\n        end_hits = [iv for iv in self.at(end) if iv.end > end]\n\n        if datafunc:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, datafunc(iv, True)))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, datafunc(iv, False)))\n        else:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, iv.data))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, iv.data))\n\n        self.remove_envelop(begin, end)\n        self.difference_update(begin_hits)\n        self.difference_update(end_hits)\n        self.update(insertions)\n\n    def slice(self, point, datafunc=None):\n        \"\"\"\n        Split Intervals that overlap point into two new Intervals. if\n        specified, uses datafunc(interval, islower=True/False) to\n        set the data field of the new Intervals.\n        :param point: where to slice\n        :param datafunc(interval, isupper): callable returning a new\n        value for the interval's data field\n        \"\"\"\n        hitlist = set(iv for iv in self.at(point) if iv.begin < point)\n        insertions = set()\n        if datafunc:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, datafunc(iv, True)))\n                insertions.add(Interval(point, iv.end, datafunc(iv, False)))\n        else:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, iv.data))\n                insertions.add(Interval(point, iv.end, iv.data))\n        self.difference_update(hitlist)\n        self.update(insertions)\n\n    def clear(self):\n        \"\"\"\n        Empties the tree.\n\n        Completes in O(1) tine.\n        \"\"\"\n        self.__init__()\n\n    def find_nested(self):\n        \"\"\"\n        Returns a dictionary mapping parent intervals to sets of\n        intervals overlapped by and contained in the parent.\n\n        Completes in O(n^2) time.\n        :rtype: dict of [Interval, set of Interval]\n        \"\"\"\n        result = {}\n\n        def add_if_nested():\n            if parent.contains_interval(child):\n                if parent not in result:\n                    result[parent] = set()\n                result[parent].add(child)\n\n        long_ivs = sorted(self.all_intervals, key=Interval.length, reverse=True)\n        for i, parent in enumerate(long_ivs):\n            for child in long_ivs[i + 1:]:\n                add_if_nested()\n        return result\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        point or range.\n\n        Completes in O(r*log n) time, where r is the size of the\n        search range.\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return self.overlaps_range(begin, end)\n        elif isinstance(begin, Number):\n            return self.overlaps_point(begin)\n        else:\n            return self.overlaps_range(begin.begin, begin.end)\n\n    def overlaps_point(self, p):\n        \"\"\"\n        Returns whether some interval in the tree overlaps p.\n\n        Completes in O(log n) time.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        return bool(self.top_node.contains_point(p))\n\n    def overlaps_range(self, begin, end):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        range. Returns False if given a null interval over which to\n        test.\n\n        Completes in O(r*log n) time, where r is the range length and n\n        is the table size.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        elif begin >= end:\n            return False\n        elif self.overlaps_point(begin):\n            return True\n        return any(\n            self.overlaps_point(bound)\n            for bound in self.boundary_table\n            if begin < bound < end\n        )\n\n    def split_overlaps(self):\n        \"\"\"\n        Finds all intervals with overlapping ranges and splits them\n        along the range boundaries.\n\n        Completes in worst-case O(n^2*log n) time (many interval\n        boundaries are inside many intervals), best-case O(n*log n)\n        time (small number of overlaps << n per interval).\n        \"\"\"\n        if not self:\n            return\n        if len(self.boundary_table) == 2:\n            return\n\n        bounds = sorted(self.boundary_table)  # get bound locations\n\n        new_ivs = set()\n        for lbound, ubound in zip(bounds[:-1], bounds[1:]):\n            for iv in self[lbound]:\n                new_ivs.add(Interval(lbound, ubound, iv.data))\n\n        self.__init__(new_ivs)\n\n    def merge_overlaps(self, data_reducer=None, data_initializer=None, strict=True):\n        \"\"\"\n        Finds all intervals with overlapping ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initializer created with copy.copy(data_initializer).\n\n        If strict is True (default), intervals are only merged if\n        their ranges actually overlap; adjacent, touching intervals\n        will not be merged. If strict is False, intervals are merged\n        even if they are only end-to-end adjacent.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                if (higher.begin < lower.end or\n                    not strict and higher.begin == lower.end):  # should merge\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:  # annihilate the data, since we don't know how to merge it\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def merge_equals(self, data_reducer=None, data_initializer=None):\n        \"\"\"\n        Finds all intervals with equal ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                if higher.range_matches(lower):  # should merge\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:  # annihilate the data, since we don't know how to merge it\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def merge_neighbors(\n        self,\n        data_reducer=None,\n        data_initializer=None,\n        distance=1,\n        strict=True,\n    ):\n        \"\"\"\n        Finds all adjacent intervals with range terminals less than or equal to\n        the given distance and merges them into a single interval. If provided,\n        uses data_reducer and data_initializer with similar semantics to\n        Python's built-in reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        If strict is True (default), only discrete intervals are merged if\n        their ranges are within the given distance; overlapping intervals\n        will not be merged. If strict is False, both neighbors and overlapping\n        intervals are merged.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n\n        sorted_intervals = sorted(self.all_intervals)  # get sorted intervals\n        merged = []\n        # use mutable object to allow new_series() to modify it\n        current_reduced = [None]\n        higher = None  # iterating variable, which new_series() needs access to\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:  # data_initializer is not None\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n\n        for higher in sorted_intervals:\n            if merged:  # series already begun\n                lower = merged[-1]\n                margin = higher.begin - lower.end\n                if margin <= distance:  # should merge\n                    if strict and margin < 0:\n                        new_series()\n                        continue\n                    else:\n                        upper_bound = max(lower.end, higher.end)\n                        if data_reducer is not None:\n                            current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                        else:  # annihilate the data, since we don't know how to merge it\n                            current_reduced[0] = None\n                        merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:  # not merged; is first of Intervals to merge\n                new_series()\n\n        self.__init__(merged)\n\n    def items(self):\n        \"\"\"\n        Constructs and returns a set of all intervals in the tree.\n\n        Completes in O(n) time.\n        :rtype: set of Interval\n        \"\"\"\n        return set(self.all_intervals)\n\n    def is_empty(self):\n        \"\"\"\n        Returns whether the tree is empty.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return 0 == len(self)\n\n    def at(self, p):\n        \"\"\"\n        Returns the set of all intervals that contain p.\n\n        Completes in O(m + log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        return root.search_point(p, set())\n\n    def envelop(self, begin, end=None):\n        \"\"\"\n        Returns the set of all intervals fully contained in the range\n        [begin, end).\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.envelop(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set()) # bound_begin might be greater\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)  # up to, but not including end\n        result.update(root.search_overlap(\n            # slice notation is slightly slower\n            boundary_table.keys()[index] for index in xrange(bound_begin, bound_end)\n        ))\n\n        # TODO: improve envelop() to use node info instead of less-efficient filtering\n        result = set(\n            iv for iv in result\n            if iv.begin >= begin and iv.end <= end\n        )\n        return result\n\n    def overlap(self, begin, end=None):\n        \"\"\"\n        Returns a set of all intervals overlapping the given range.\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.overlap(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())  # bound_begin might be greater\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)  # up to, but not including end\n        result.update(root.search_overlap(\n            # slice notation is slightly slower\n            boundary_table.keys()[index] for index in xrange(bound_begin, bound_end)\n        ))\n        return result\n\n    def begin(self):\n        \"\"\"\n        Returns the lower bound of the first interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[0]\n\n    def end(self):\n        \"\"\"\n        Returns the upper bound of the last interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[-1]\n\n    def range(self):\n        \"\"\"\n        Returns a minimum-spanning Interval that encloses all the\n        members of this IntervalTree. If the tree is empty, returns\n        null Interval.\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin(), self.end())\n\n    def span(self):\n        \"\"\"\n        Returns the length of the minimum-spanning Interval that\n        encloses all the members of this IntervalTree. If the tree\n        is empty, return 0.\n        \"\"\"\n        if not self:\n            return 0\n        return self.end() - self.begin()\n\n    def print_structure(self, tostring=False):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Pretty-prints the structure of the tree.\n        If tostring is true, prints nothing and returns a string.\n        :rtype: None or str\n        \"\"\"\n        if self.top_node:\n            return self.top_node.print_structure(tostring=tostring)\n        else:\n            result = \"<empty IntervalTree>\"\n            if not tostring:\n                print(result)\n            else:\n                return result\n\n    def verify(self):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Checks the table to ensure that the invariants are held.\n        \"\"\"\n        if self.all_intervals:\n            ## top_node.all_children() == self.all_intervals\n            try:\n                assert self.top_node.all_children() == self.all_intervals\n            except AssertionError as e:\n                print(\n                    'Error: the tree and the membership set are out of sync!'\n                )\n                tivs = set(self.top_node.all_children())\n                print('top_node.all_children() - all_intervals:')\n                try:\n                    pprint\n                except NameError:\n                    from pprint import pprint\n                pprint(tivs - self.all_intervals)\n                print('all_intervals - top_node.all_children():')\n                pprint(self.all_intervals - tivs)\n                raise e\n\n            ## All members are Intervals\n            for iv in self:\n                assert isinstance(iv, Interval), (\n                    \"Error: Only Interval objects allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n\n            ## No null intervals\n            for iv in self:\n                assert not iv.is_null(), (\n                    \"Error: Null Interval objects not allowed in IntervalTree:\"\n                    \" {0}\".format(iv)\n                )\n\n            ## Reconstruct boundary_table\n            bound_check = {}\n            for iv in self:\n                if iv.begin in bound_check:\n                    bound_check[iv.begin] += 1\n                else:\n                    bound_check[iv.begin] = 1\n                if iv.end in bound_check:\n                    bound_check[iv.end] += 1\n                else:\n                    bound_check[iv.end] = 1\n\n            ## Reconstructed boundary table (bound_check) ==? boundary_table\n            assert set(self.boundary_table.keys()) == set(bound_check.keys()),\\\n                'Error: boundary_table is out of sync with ' \\\n                'the intervals in the tree!'\n\n            # For efficiency reasons this should be iteritems in Py2, but we\n            # don't care much for efficiency in debug methods anyway.\n            for key, val in self.boundary_table.items():\n                assert bound_check[key] == val, \\\n                    'Error: boundary_table[{0}] should be {1},' \\\n                    ' but is {2}!'.format(\n                        key, bound_check[key], val)\n\n            ## Internal tree structure\n            self.top_node.verify(set())\n        else:\n            ## Verify empty tree\n            assert not self.boundary_table, \\\n                \"Error: boundary table should be empty!\"\n            assert self.top_node is None, \\\n                \"Error: top_node isn't None!\"\n\n    def score(self, full_report=False):\n        \"\"\"\n        Returns a number between 0 and 1, indicating how suboptimal the tree\n        is. The lower, the better. Roughly, this number represents the\n        fraction of flawed Intervals in the tree.\n        :rtype: float\n        \"\"\"\n        if len(self) <= 2:\n            return 0.0\n\n        n = len(self)\n        m = self.top_node.count_nodes()\n\n        def s_center_score():\n            \"\"\"\n            Returns a normalized score, indicating roughly how many times\n            intervals share s_center with other intervals. Output is full-scale\n            from 0 to 1.\n            :rtype: float\n            \"\"\"\n            raw = n - m\n            maximum = n - 1\n            return raw / float(maximum)\n\n        report = {\n            \"depth\": self.top_node.depth_score(n, m),\n            \"s_center\": s_center_score(),\n        }\n        cumulative = max(report.values())\n        report[\"_cumulative\"] = cumulative\n        if full_report:\n            return report\n        return cumulative\n\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns a set of all intervals overlapping the given index or\n        slice.\n\n        Completes in O(k * log(n) + m) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range (this is 1 for a point)\n        :rtype: set of Interval\n        \"\"\"\n        try:\n            start, stop = index.start, index.stop\n            if start is None:\n                start = self.begin()\n                if stop is None:\n                    return set(self)\n            if stop is None:\n                stop = self.end()\n            return self.overlap(start, stop)\n        except AttributeError:\n            return self.at(index)\n\n    def __setitem__(self, index, value):\n        \"\"\"\n        Adds a new interval to the tree. A shortcut for\n        add(Interval(index.start, index.stop, value)).\n\n        If an identical Interval object with equal range and data\n        already exists, does nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        self.addi(index.start, index.stop, value)\n\n    def __delitem__(self, point):\n        \"\"\"\n        Delete all items overlapping point.\n        \"\"\"\n        self.remove_overlap(point)\n\n    def __contains__(self, item):\n        \"\"\"\n        Returns whether item exists as an Interval in the tree.\n        This method only returns True for exact matches; for\n        overlaps, see the overlaps() method.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        # Removed point-checking code; it might trick the user into\n        # thinking that this is O(1), which point-checking isn't.\n        #if isinstance(item, Interval):\n        return item in self.all_intervals\n        #else:\n        #    return self.contains_point(item)\n\n    def containsi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for (Interval(begin, end, data) in tree).\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return Interval(begin, end, data) in self\n\n    def __iter__(self):\n        \"\"\"\n        Returns an iterator over all the intervals in the tree.\n\n        Completes in O(1) time.\n        :rtype: collections.Iterable[Interval]\n        \"\"\"\n        return self.all_intervals.__iter__()\n    iter = __iter__\n\n    def __len__(self):\n        \"\"\"\n        Returns how many intervals are in the tree.\n\n        Completes in O(1) time.\n        :rtype: int\n        \"\"\"\n        return len(self.all_intervals)\n\n    def __eq__(self, other):\n        \"\"\"\n        Whether two IntervalTrees are equal.\n\n        Completes in O(n) time if sizes are equal; O(1) time otherwise.\n        :rtype: bool\n        \"\"\"\n        return (\n            isinstance(other, IntervalTree) and\n            self.all_intervals == other.all_intervals\n        )\n\n    def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        ivs = sorted(self)\n        if not ivs:\n            return \"IntervalTree()\"\n        else:\n            return \"IntervalTree({0})\".format(ivs)\n\n    __str__ = __repr__\n\n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :rtype: tuple\n        \"\"\"\n        return IntervalTree, (sorted(self.all_intervals),)\n\n",
    "intervaltree/interval.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nInterval class\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom numbers import Number\nfrom collections import namedtuple\n\n\n# noinspection PyBroadException\nclass Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n    __slots__ = ()  # Saves memory, avoiding the need to create __dict__ for each interval\n\n    def __new__(cls, begin, end, data=None):\n        return super(Interval, cls).__new__(cls, begin, end, data)\n    \n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Whether the interval overlaps the given point, range or Interval.\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            # An overlap means that some C exists that is inside both ranges:\n            #   begin <= C < end\n            # and \n            #   self.begin <= C < self.end\n            # See https://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap/3269471#3269471\n            return begin < self.end and end > self.begin\n        try:\n            return self.overlaps(begin.begin, begin.end)\n        except:\n            return self.contains_point(begin)\n\n    def overlap_size(self, begin, end=None):\n        \"\"\"\n        Return the overlap size between two intervals or a point\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: Return the overlap size, None if not overlap is found\n        :rtype: depends on the given input (e.g., int will be returned for int interval and timedelta for\n        datetime intervals)\n        \"\"\"\n        overlaps = self.overlaps(begin, end)\n        if not overlaps:\n            return 0\n\n        if end is not None:\n            # case end is given\n            i0 = max(self.begin, begin)\n            i1 = min(self.end, end)\n            return i1 - i0\n        # assume the type is interval, in other cases, an exception will be thrown\n        i0 = max(self.begin, begin.begin)\n        i1 = min(self.end, begin.end)\n        return i1 - i0\n\n    def contains_point(self, p):\n        \"\"\"\n        Whether the Interval contains p.\n        :param p: a point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= p < self.end\n    \n    def range_matches(self, other):\n        \"\"\"\n        Whether the begins equal and the ends equal. Compare __eq__().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin == other.begin and \n            self.end == other.end\n        )\n    \n    def contains_interval(self, other):\n        \"\"\"\n        Whether other is contained in this Interval.\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin <= other.begin and\n            self.end >= other.end\n        )\n    \n    def distance_to(self, other):\n        \"\"\"\n        Returns the size of the gap between intervals, or 0 \n        if they touch or overlap.\n        :param other: Interval or point\n        :return: distance\n        :rtype: Number\n        \"\"\"\n        if self.overlaps(other):\n            return 0\n        try:\n            if self.begin < other.begin:\n                return other.begin - self.end\n            else:\n                return self.begin - other.end\n        except:\n            if self.end <= other:\n                return other - self.end\n            else:\n                return self.begin - other\n\n    def is_null(self):\n        \"\"\"\n        Whether this equals the null interval.\n        :return: True if end <= begin else False\n        :rtype: bool\n        \"\"\"\n        return self.begin >= self.end\n\n    def length(self):\n        \"\"\"\n        The distance covered by this Interval.\n        :return: length\n        :type: Number\n        \"\"\"\n        if self.is_null():\n            return 0\n        return self.end - self.begin\n\n    def __hash__(self):\n        \"\"\"\n        Depends on begin and end only.\n        :return: hash\n        :rtype: Number\n        \"\"\"\n        return hash((self.begin, self.end))\n\n    def __eq__(self, other):\n        \"\"\"\n        Whether the begins equal, the ends equal, and the data fields\n        equal. Compare range_matches().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return (\n            self.begin == other.begin and\n            self.end == other.end and\n            self.data == other.data\n        )\n\n    def __cmp__(self, other):\n        \"\"\"\n        Tells whether other sorts before, after or equal to this\n        Interval.\n\n        Sorting is by begins, then by ends, then by data fields.\n\n        If data fields are not both sortable types, data fields are\n        compared alphabetically by type name.\n        :param other: Interval\n        :return: -1, 0, 1\n        :rtype: int\n        \"\"\"\n        s = self[0:2]\n        try:\n            o = other[0:2]\n        except:\n            o = (other,)\n        if s != o:\n            return -1 if s < o else 1\n        try:\n            if self.data == other.data:\n                return 0\n            return -1 if self.data < other.data else 1\n        except TypeError:\n            s = type(self.data).__name__\n            o = type(other.data).__name__\n            if s == o:\n                return 0\n            return -1 if s < o else 1\n\n    def __lt__(self, other):\n        \"\"\"\n        Less than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) < 0\n\n    def __gt__(self, other):\n        \"\"\"\n        Greater than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) > 0\n\n    def _raise_if_null(self, other):\n        \"\"\"\n        :raises ValueError: if either self or other is a null Interval\n        \"\"\"\n        if self.is_null():\n            raise ValueError(\"Cannot compare null Intervals!\")\n        if hasattr(other, 'is_null') and other.is_null():\n            raise ValueError(\"Cannot compare null Intervals!\")\n\n    def lt(self, other):\n        \"\"\"\n        Strictly less than. Returns True if no part of this Interval\n        extends higher than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'begin', other)\n\n    def le(self, other):\n        \"\"\"\n        Less than or overlaps. Returns True if no part of this Interval\n        extends higher than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'end', other)\n\n    def gt(self, other):\n        \"\"\"\n        Strictly greater than. Returns True if no part of this Interval\n        extends lower than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        if hasattr(other, 'end'):\n            return self.begin >= other.end\n        else:\n            return self.begin > other\n\n    def ge(self, other):\n        \"\"\"\n        Greater than or overlaps. Returns True if no part of this Interval\n        extends lower than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.begin >= getattr(other, 'begin', other)\n\n    def _get_fields(self):\n        \"\"\"\n        Used by str, unicode, repr and __reduce__.\n\n        Returns only the fields necessary to reconstruct the Interval.\n        :return: reconstruction info\n        :rtype: tuple\n        \"\"\"\n        if self.data is not None:\n            return self.begin, self.end, self.data\n        else:\n            return self.begin, self.end\n    \n    def __repr__(self):\n        \"\"\"\n        Executable string representation of this Interval.\n        :return: string representation\n        :rtype: str\n        \"\"\"\n        if isinstance(self.begin, Number):\n            s_begin = str(self.begin)\n            s_end = str(self.end)\n        else:\n            s_begin = repr(self.begin)\n            s_end = repr(self.end)\n        if self.data is None:\n            return \"Interval({0}, {1})\".format(s_begin, s_end)\n        else:\n            return \"Interval({0}, {1}, {2})\".format(s_begin, s_end, repr(self.data))\n\n    __str__ = __repr__\n\n    def copy(self):\n        \"\"\"\n        Shallow copy.\n        :return: copy of self\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin, self.end, self.data)\n    \n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :return: pickle data\n        :rtype: tuple\n        \"\"\"\n        return Interval, self._get_fields()\n"
  },
  "GT_src_dict": {
    "intervaltree/node.py": {
      "Node.__init__": {
        "code": "    def __init__(self, x_center=None, s_center=set(), left_node=None, right_node=None):\n        \"\"\"Initializes a Node in an interval tree, representing an interval's center and the intervals that overlap it.\n\nParameters:\n- x_center (optional): The central point of the intervals, which serves as the splitting point for subtree organization. It should be a numeric value representing the center of the interval.\n- s_center (optional): A set of intervals overlapping the x_center. It defaults to an empty set but can be initialized with a collection of intervals.\n- left_node (optional): A reference to the left child Node, representing intervals that are completely to the left of x_center.\n- right_node (optional): A reference to the right child Node, representing intervals that are completely to the right of x_center.\n\nThe Node construction also initializes `depth` and `balance` to 0, which will be updated later during balancing operations. Upon initialization, it immediately balances the Node using the `rotate()` method. The method expects the `s_center` to contain intervals that have `begin` and `end` attributes, which are essential for determining overlaps and for the functioning of the tree.\"\"\"\n        self.x_center = x_center\n        self.s_center = set(s_center)\n        self.left_node = left_node\n        self.right_node = right_node\n        self.depth = 0\n        self.balance = 0\n        self.rotate()",
        "docstring": "Initializes a Node in an interval tree, representing an interval's center and the intervals that overlap it.\n\nParameters:\n- x_center (optional): The central point of the intervals, which serves as the splitting point for subtree organization. It should be a numeric value representing the center of the interval.\n- s_center (optional): A set of intervals overlapping the x_center. It defaults to an empty set but can be initialized with a collection of intervals.\n- left_node (optional): A reference to the left child Node, representing intervals that are completely to the left of x_center.\n- right_node (optional): A reference to the right child Node, representing intervals that are completely to the right of x_center.\n\nThe Node construction also initializes `depth` and `balance` to 0, which will be updated later during balancing operations. Upon initialization, it immediately balances the Node using the `rotate()` method. The method expects the `s_center` to contain intervals that have `begin` and `end` attributes, which are essential for determining overlaps and for the functioning of the tree.",
        "signature": "def __init__(self, x_center=None, s_center=set(), left_node=None, right_node=None):",
        "type": "Method",
        "class_signature": "class Node(object):"
      },
      "Node.from_intervals": {
        "code": "    def from_intervals(cls, intervals):\n        \"\"\"Creates a Node instance from a list of intervals.\n\n:param intervals: A list of interval objects that need to be stored in the new Node. Each interval is expected to have 'begin' and 'end' attributes.\n:rtype: Node or None: Returns a Node containing the provided intervals if the list is non-empty. If the list is empty, it returns None, indicating that no Node can be created.\n:raises: The method relies on the Node.from_sorted_intervals class method to initialize the Node with sorted intervals, ensuring that it correctly constructs an AVL tree structure suited for interval management.\"\"\"\n        '\\n        :rtype : Node\\n        '\n        if not intervals:\n            return None\n        return Node.from_sorted_intervals(sorted(intervals))",
        "docstring": "Creates a Node instance from a list of intervals.\n\n:param intervals: A list of interval objects that need to be stored in the new Node. Each interval is expected to have 'begin' and 'end' attributes.\n:rtype: Node or None: Returns a Node containing the provided intervals if the list is non-empty. If the list is empty, it returns None, indicating that no Node can be created.\n:raises: The method relies on the Node.from_sorted_intervals class method to initialize the Node with sorted intervals, ensuring that it correctly constructs an AVL tree structure suited for interval management.",
        "signature": "def from_intervals(cls, intervals):",
        "type": "Method",
        "class_signature": "class Node(object):"
      },
      "Node.all_children": {
        "code": "    def all_children(self):\n        \"\"\"Returns a set of all intervals contained within this node and its descendants.\n\nThis method invokes the helper function `all_children_helper`, which is initiated with an empty set to accumulate the intervals. It traverses the entire subtree of the Node, collecting intervals from both the left and right children, if they exist, and returns the complete collection of intervals. This can be useful for operations that require knowledge of all intervals present in the entire interval tree.\n\nNo input parameters or constants are required for this method.\"\"\"\n        return self.all_children_helper(set())",
        "docstring": "Returns a set of all intervals contained within this node and its descendants.\n\nThis method invokes the helper function `all_children_helper`, which is initiated with an empty set to accumulate the intervals. It traverses the entire subtree of the Node, collecting intervals from both the left and right children, if they exist, and returns the complete collection of intervals. This can be useful for operations that require knowledge of all intervals present in the entire interval tree.\n\nNo input parameters or constants are required for this method.",
        "signature": "def all_children(self):",
        "type": "Method",
        "class_signature": "class Node(object):"
      },
      "Node.verify": {
        "code": "    def verify(self, parents=set()):\n        \"\"\"## DEBUG ONLY ##\nRecursively verifies the invariants of an interval subtree represented by the Node instance. It checks that the subtree adheres to AVL tree properties, ensuring correct balancing and structure.\n\nParameters:\n- parents (set): A set of ancestor x_center values for the current node, used to verify that no intervals overlap with their ancestor nodes.\n\nReturns:\n- None: If the assertions hold true, the method completes without returning a value. If any assertion fails, it raises an AssertionError with a descriptive message.\n\nKey Checks:\n- Verifies that the balance factor (self.balance) is within the range of -1 to 1, ensuring the node is correctly balanced.\n- Ensures that s_center, the set of intervals at this node, is not empty.\n- Confirms that each interval in s_center has valid properties (begin and end attributes), and that they overlap with the node's x_center.\n- Ensures the ordering of child nodes based on their x_center, maintaining the binary search tree property.\n\nDependencies:\n- Calls self.refresh_balance() to recalculate the balance factor after checking assertions.\n- Utilizes self[0] and self[1] for left and right child nodes, validating their structure and order.\n\nThis method is essential for maintaining the integrity and efficiency of operations on the interval tree.\"\"\"\n        '\\n        ## DEBUG ONLY ##\\n        Recursively ensures that the invariants of an interval subtree\\n        hold.\\n        '\n        assert isinstance(self.s_center, set)\n        bal = self.balance\n        assert abs(bal) < 2, \"Error: Rotation should have happened, but didn't! \\n{}\".format(self.print_structure(tostring=True))\n        self.refresh_balance()\n        assert bal == self.balance, 'Error: self.balance not set correctly! \\n{}'.format(self.print_structure(tostring=True))\n        assert self.s_center, 'Error: s_center is empty! \\n{}'.format(self.print_structure(tostring=True))\n        for iv in self.s_center:\n            assert hasattr(iv, 'begin')\n            assert hasattr(iv, 'end')\n            assert iv.begin < iv.end\n            assert iv.overlaps(self.x_center)\n            for parent in sorted(parents):\n                assert not iv.contains_point(parent), 'Error: Overlaps ancestor ({})! \\n{}\\n\\n{}'.format(parent, iv, self.print_structure(tostring=True))\n        if self[0]:\n            assert self[0].x_center < self.x_center, 'Error: Out-of-order left child! {}'.format(self.x_center)\n            self[0].verify(parents.union([self.x_center]))\n        if self[1]:\n            assert self[1].x_center > self.x_center, 'Error: Out-of-order right child! {}'.format(self.x_center)\n            self[1].verify(parents.union([self.x_center]))",
        "docstring": "## DEBUG ONLY ##\nRecursively verifies the invariants of an interval subtree represented by the Node instance. It checks that the subtree adheres to AVL tree properties, ensuring correct balancing and structure.\n\nParameters:\n- parents (set): A set of ancestor x_center values for the current node, used to verify that no intervals overlap with their ancestor nodes.\n\nReturns:\n- None: If the assertions hold true, the method completes without returning a value. If any assertion fails, it raises an AssertionError with a descriptive message.\n\nKey Checks:\n- Verifies that the balance factor (self.balance) is within the range of -1 to 1, ensuring the node is correctly balanced.\n- Ensures that s_center, the set of intervals at this node, is not empty.\n- Confirms that each interval in s_center has valid properties (begin and end attributes), and that they overlap with the node's x_center.\n- Ensures the ordering of child nodes based on their x_center, maintaining the binary search tree property.\n\nDependencies:\n- Calls self.refresh_balance() to recalculate the balance factor after checking assertions.\n- Utilizes self[0] and self[1] for left and right child nodes, validating their structure and order.\n\nThis method is essential for maintaining the integrity and efficiency of operations on the interval tree.",
        "signature": "def verify(self, parents=set()):",
        "type": "Method",
        "class_signature": "class Node(object):"
      },
      "Node.print_structure": {
        "code": "    def print_structure(self, indent=0, tostring=False):\n        \"\"\"Prints or returns a structured representation of the Node and its subtrees for debugging purposes.\n\n    Parameters:\n        indent (int): The level of indentation used for the printed structure, enabling visualization of the tree hierarchy.\n        tostring (bool): If True, the function returns the structure as a string instead of printing it directly.\n\n    Returns:\n        str: A string representation of the Node and its intervals if tostring is True. Otherwise, it prints the structure directly.\n\n    This method accesses the Node's attributes, including `s_center` (a set of intervals associated with the Node), \n    `left_node`, and `right_node` (links to child Nodes). It constructs a visual layout of the tree structure, indicating \n    the relationships between Nodes and displaying the intervals contained in each Node.\"\"\"\n        '\\n        For debugging.\\n        '\n        nl = '\\n'\n        sp = indent * '    '\n        rlist = [str(self) + nl]\n        if self.s_center:\n            for iv in sorted(self.s_center):\n                rlist.append(sp + ' ' + repr(iv) + nl)\n        if self.left_node:\n            rlist.append(sp + '<:  ')\n            rlist.append(self.left_node.print_structure(indent + 1, True))\n        if self.right_node:\n            rlist.append(sp + '>:  ')\n            rlist.append(self.right_node.print_structure(indent + 1, True))\n        result = ''.join(rlist)\n        if tostring:\n            return result\n        else:\n            print(result)",
        "docstring": "Prints or returns a structured representation of the Node and its subtrees for debugging purposes.\n\nParameters:\n    indent (int): The level of indentation used for the printed structure, enabling visualization of the tree hierarchy.\n    tostring (bool): If True, the function returns the structure as a string instead of printing it directly.\n\nReturns:\n    str: A string representation of the Node and its intervals if tostring is True. Otherwise, it prints the structure directly.\n\nThis method accesses the Node's attributes, including `s_center` (a set of intervals associated with the Node), \n`left_node`, and `right_node` (links to child Nodes). It constructs a visual layout of the tree structure, indicating \nthe relationships between Nodes and displaying the intervals contained in each Node.",
        "signature": "def print_structure(self, indent=0, tostring=False):",
        "type": "Method",
        "class_signature": "class Node(object):"
      }
    },
    "intervaltree/intervaltree.py": {
      "IntervalTree.from_tuples": {
        "code": "    def from_tuples(cls, tups):\n        \"\"\"Create a new `IntervalTree` from an iterable of 2- or 3-tuples, where each tuple defines an interval's start, end, and optionally, associated data. The method constructs `Interval` objects from the provided tuples and initializes the `IntervalTree` with these intervals.\n\nParameters:\n- `tups`: An iterable of 2- or 3-element tuples. Each tuple should contain float or integer values that define the beginning and ending points of the intervals, and optionally, a data value.\n\nReturns:\n- An instance of `IntervalTree` populated with the intervals created from the input tuples.\n\nThis method relies on the `Interval` class, which must be defined in the same module, and it preserves the order of intervals during tree creation. The resulting tree can be used for efficient interval operations such as querying overlaps, containment, and other interval-related functionalities.\"\"\"\n        '\\n        Create a new IntervalTree from an iterable of 2- or 3-tuples,\\n         where the tuple lists begin, end, and optionally data.\\n        '\n        ivs = [Interval(*t) for t in tups]\n        return IntervalTree(ivs)",
        "docstring": "Create a new `IntervalTree` from an iterable of 2- or 3-tuples, where each tuple defines an interval's start, end, and optionally, associated data. The method constructs `Interval` objects from the provided tuples and initializes the `IntervalTree` with these intervals.\n\nParameters:\n- `tups`: An iterable of 2- or 3-element tuples. Each tuple should contain float or integer values that define the beginning and ending points of the intervals, and optionally, a data value.\n\nReturns:\n- An instance of `IntervalTree` populated with the intervals created from the input tuples.\n\nThis method relies on the `Interval` class, which must be defined in the same module, and it preserves the order of intervals during tree creation. The resulting tree can be used for efficient interval operations such as querying overlaps, containment, and other interval-related functionalities.",
        "signature": "def from_tuples(cls, tups):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__init__": {
        "code": "    def __init__(self, intervals=None):\n        \"\"\"Initialize an IntervalTree, a data structure for managing a set of intervals efficiently. \n\nParameters:\n-----------\nintervals: iterable, optional\n    An optional iterable of Interval objects to initialize the tree. If provided, these intervals are added to the tree while ensuring that no null intervals are included.\n\nRaises:\n-------\nValueError: \n    If any of the provided intervals is a null interval (i.e., an interval that is not properly defined).\n\nAttributes:\n-----------\n- all_intervals: A set storing the unique intervals in the tree.\n- top_node: The root node of the tree, initialized from the provided intervals using Node.from_intervals.\n- boundary_table: A SortedDict to track the boundaries of intervals for quick access and management.\n\nComplexity:\n-----------\nThe initialization process completes in O(n*log n) time, where n is the number of intervals provided, as it requires sorting and building the tree structure.\"\"\"\n        '\\n        Set up a tree. If intervals is provided, add all the intervals\\n        to the tree.\\n\\n        Completes in O(n*log n) time.\\n        '\n        intervals = set(intervals) if intervals is not None else set()\n        for iv in intervals:\n            if iv.is_null():\n                raise ValueError('IntervalTree: Null Interval objects not allowed in IntervalTree: {0}'.format(iv))\n        self.all_intervals = intervals\n        self.top_node = Node.from_intervals(self.all_intervals)\n        self.boundary_table = SortedDict()\n        for iv in self.all_intervals:\n            self._add_boundaries(iv)",
        "docstring": "Initialize an IntervalTree, a data structure for managing a set of intervals efficiently. \n\nParameters:\n-----------\nintervals: iterable, optional\n    An optional iterable of Interval objects to initialize the tree. If provided, these intervals are added to the tree while ensuring that no null intervals are included.\n\nRaises:\n-------\nValueError: \n    If any of the provided intervals is a null interval (i.e., an interval that is not properly defined).\n\nAttributes:\n-----------\n- all_intervals: A set storing the unique intervals in the tree.\n- top_node: The root node of the tree, initialized from the provided intervals using Node.from_intervals.\n- boundary_table: A SortedDict to track the boundaries of intervals for quick access and management.\n\nComplexity:\n-----------\nThe initialization process completes in O(n*log n) time, where n is the number of intervals provided, as it requires sorting and building the tree structure.",
        "signature": "def __init__(self, intervals=None):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.add": {
        "code": "    def add(self, interval):\n        \"\"\"Adds an `Interval` object to the `IntervalTree` if it is not already present. The operation ensures that duplicates are not added, and raises a `ValueError` if the interval is null (i.e., it has no valid start and end points). If the tree is empty, it initializes the `top_node` with the new interval; otherwise, it delegates the addition to the `add` method of the current `top_node`. The method updates the `all_intervals` set and records the boundaries of the newly added interval in the `boundary_table`.\n\nParameters:\n- `interval` (Interval): An `Interval` object representing a half-open interval, which should contain valid start and end values.\n\nReturns:\n- None: This method does not return a value.\n\nRaises:\n- ValueError: If the provided interval is null.\n\nSide Effects:\n- Updates the `top_node` of the tree if it is empty or modifies the existing tree structure.\n- Modifies the `all_intervals` set and the `boundary_table` for maintaining the tree's structure.\"\"\"\n        '\\n        Adds an interval to the tree, if not already present.\\n\\n        Completes in O(log n) time.\\n        '\n        if interval in self:\n            return\n        if interval.is_null():\n            raise ValueError('IntervalTree: Null Interval objects not allowed in IntervalTree: {0}'.format(interval))\n        if not self.top_node:\n            self.top_node = Node.from_interval(interval)\n        else:\n            self.top_node = self.top_node.add(interval)\n        self.all_intervals.add(interval)\n        self._add_boundaries(interval)",
        "docstring": "Adds an `Interval` object to the `IntervalTree` if it is not already present. The operation ensures that duplicates are not added, and raises a `ValueError` if the interval is null (i.e., it has no valid start and end points). If the tree is empty, it initializes the `top_node` with the new interval; otherwise, it delegates the addition to the `add` method of the current `top_node`. The method updates the `all_intervals` set and records the boundaries of the newly added interval in the `boundary_table`.\n\nParameters:\n- `interval` (Interval): An `Interval` object representing a half-open interval, which should contain valid start and end values.\n\nReturns:\n- None: This method does not return a value.\n\nRaises:\n- ValueError: If the provided interval is null.\n\nSide Effects:\n- Updates the `top_node` of the tree if it is empty or modifies the existing tree structure.\n- Modifies the `all_intervals` set and the `boundary_table` for maintaining the tree's structure.",
        "signature": "def add(self, interval):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.addi": {
        "code": "    def addi(self, begin, end, data=None):\n        \"\"\"Adds an interval to the tree using the specified start and end points, along with optional data. This method constructs an `Interval` object using the provided `begin`, `end`, and `data` parameters, and then invokes the `add` method to insert it into the `IntervalTree`.\n\nParameters:\n- `begin` (numeric): The starting boundary of the interval.\n- `end` (numeric): The ending boundary of the interval.\n- `data` (optional): Optional data associated with the interval.\n\nReturns:\n- None: The method updates the internal structure of the `IntervalTree` by adding the new interval if it doesn't already exist.\n\nComplexity:\n- Completes in O(log n) time, where n is the number of intervals currently in the tree.\n\nThis method interacts with the `add` method, which checks for duplicates and inserts intervals into the tree structure. It utilizes the `Interval` class defined elsewhere in the module.\"\"\"\n        '\\n        Shortcut for add(Interval(begin, end, data)).\\n\\n        Completes in O(log n) time.\\n        '\n        return self.add(Interval(begin, end, data))",
        "docstring": "Adds an interval to the tree using the specified start and end points, along with optional data. This method constructs an `Interval` object using the provided `begin`, `end`, and `data` parameters, and then invokes the `add` method to insert it into the `IntervalTree`.\n\nParameters:\n- `begin` (numeric): The starting boundary of the interval.\n- `end` (numeric): The ending boundary of the interval.\n- `data` (optional): Optional data associated with the interval.\n\nReturns:\n- None: The method updates the internal structure of the `IntervalTree` by adding the new interval if it doesn't already exist.\n\nComplexity:\n- Completes in O(log n) time, where n is the number of intervals currently in the tree.\n\nThis method interacts with the `add` method, which checks for duplicates and inserts intervals into the tree structure. It utilizes the `Interval` class defined elsewhere in the module.",
        "signature": "def addi(self, begin, end, data=None):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.remove": {
        "code": "    def remove(self, interval):\n        \"\"\"Removes an interval from the IntervalTree if it exists. \n\nArgs:\n    interval (Interval): The Interval object to be removed from the tree. \n\nRaises:\n    ValueError: If the specified interval is not present in the tree.\n\nThis method updates the tree structure by calling the `remove` method on the `top_node`, which handles the internal tree structure modifications. It also updates `all_intervals`, a set that maintains all the intervals currently in the tree, and calls `_remove_boundaries(interval)` to update the boundary table accordingly, ensuring the internal state remains consistent after the removal.\"\"\"\n        '\\n        Removes an interval from the tree, if present. If not, raises\\n        ValueError.\\n\\n        Completes in O(log n) time.\\n        '\n        if interval not in self:\n            raise ValueError\n        self.top_node = self.top_node.remove(interval)\n        self.all_intervals.remove(interval)\n        self._remove_boundaries(interval)",
        "docstring": "Removes an interval from the IntervalTree if it exists. \n\nArgs:\n    interval (Interval): The Interval object to be removed from the tree. \n\nRaises:\n    ValueError: If the specified interval is not present in the tree.\n\nThis method updates the tree structure by calling the `remove` method on the `top_node`, which handles the internal tree structure modifications. It also updates `all_intervals`, a set that maintains all the intervals currently in the tree, and calls `_remove_boundaries(interval)` to update the boundary table accordingly, ensuring the internal state remains consistent after the removal.",
        "signature": "def remove(self, interval):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.removei": {
        "code": "    def removei(self, begin, end, data=None):\n        \"\"\"Removes an interval from the IntervalTree using a specified start and end point.\n\nParameters:\n- begin (float or int): The starting point of the interval to be removed.\n- end (float or int): The ending point of the interval to be removed.\n- data (optional): Not used; included for compatibility with the `remove` method.\n\nReturns:\n- None. If the interval specified by (begin, end, data) is present in the tree, it will be removed. If not present, a ValueError will be raised.\n\nThis method directly calls the `remove` method of the IntervalTree class, which manages the actual removal process. It executes in O(log n) time, where n is the number of intervals in the tree. Intervals in the tree are instances of the `Interval` class defined in the imported `interval` module.\"\"\"\n        '\\n        Shortcut for remove(Interval(begin, end, data)).\\n\\n        Completes in O(log n) time.\\n        '\n        return self.remove(Interval(begin, end, data))",
        "docstring": "Removes an interval from the IntervalTree using a specified start and end point.\n\nParameters:\n- begin (float or int): The starting point of the interval to be removed.\n- end (float or int): The ending point of the interval to be removed.\n- data (optional): Not used; included for compatibility with the `remove` method.\n\nReturns:\n- None. If the interval specified by (begin, end, data) is present in the tree, it will be removed. If not present, a ValueError will be raised.\n\nThis method directly calls the `remove` method of the IntervalTree class, which manages the actual removal process. It executes in O(log n) time, where n is the number of intervals in the tree. Intervals in the tree are instances of the `Interval` class defined in the imported `interval` module.",
        "signature": "def removei(self, begin, end, data=None):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.verify": {
        "code": "    def verify(self):\n        \"\"\"Verifies the integrity of the IntervalTree data structure by checking that it maintains its invariants. This method performs several assertions to ensure consistency among the tree's members, boundary table, and internal structures.\n\nChecks include:\n- Ensures that all intervals in the tree correspond to the expected set of intervals (`self.all_intervals`).\n- Validates that all members are instances of the `Interval` class.\n- Confirms that no null intervals are present in the tree.\n- Reconstructs the boundary table from the current intervals and verifies its consistency with the existing boundary table.\n- Calls the `verify` method of the `top_node`, which checks the internal structure of the tree.\n\nIf the tree is empty, the method confirms that both the boundary table and top node are not present.\n\nNo input parameters are required. The method does not return any value but raises `AssertionError` if any of the invariants are violated, providing a message with details regarding the inconsistency.\n\nAttributes used:\n- `self.all_intervals`: A set of all intervals in the tree.\n- `self.top_node`: The root node of the interval tree, which contains a method to verify the node structure.\n- `self.boundary_table`: A sorted dictionary that maintains boundaries of intervals for efficient queries.\n\nThis method is meant primarily for debugging purposes.\"\"\"\n        '\\n        ## FOR DEBUGGING ONLY ##\\n        Checks the table to ensure that the invariants are held.\\n        '\n        if self.all_intervals:\n            try:\n                assert self.top_node.all_children() == self.all_intervals\n            except AssertionError as e:\n                print('Error: the tree and the membership set are out of sync!')\n                tivs = set(self.top_node.all_children())\n                print('top_node.all_children() - all_intervals:')\n                try:\n                    pprint\n                except NameError:\n                    from pprint import pprint\n                pprint(tivs - self.all_intervals)\n                print('all_intervals - top_node.all_children():')\n                pprint(self.all_intervals - tivs)\n                raise e\n            for iv in self:\n                assert isinstance(iv, Interval), 'Error: Only Interval objects allowed in IntervalTree: {0}'.format(iv)\n            for iv in self:\n                assert not iv.is_null(), 'Error: Null Interval objects not allowed in IntervalTree: {0}'.format(iv)\n            bound_check = {}\n            for iv in self:\n                if iv.begin in bound_check:\n                    bound_check[iv.begin] += 1\n                else:\n                    bound_check[iv.begin] = 1\n                if iv.end in bound_check:\n                    bound_check[iv.end] += 1\n                else:\n                    bound_check[iv.end] = 1\n            assert set(self.boundary_table.keys()) == set(bound_check.keys()), 'Error: boundary_table is out of sync with the intervals in the tree!'\n            for key, val in self.boundary_table.items():\n                assert bound_check[key] == val, 'Error: boundary_table[{0}] should be {1}, but is {2}!'.format(key, bound_check[key], val)\n            self.top_node.verify(set())\n        else:\n            assert not self.boundary_table, 'Error: boundary table should be empty!'\n            assert self.top_node is None, \"Error: top_node isn't None!\"",
        "docstring": "Verifies the integrity of the IntervalTree data structure by checking that it maintains its invariants. This method performs several assertions to ensure consistency among the tree's members, boundary table, and internal structures.\n\nChecks include:\n- Ensures that all intervals in the tree correspond to the expected set of intervals (`self.all_intervals`).\n- Validates that all members are instances of the `Interval` class.\n- Confirms that no null intervals are present in the tree.\n- Reconstructs the boundary table from the current intervals and verifies its consistency with the existing boundary table.\n- Calls the `verify` method of the `top_node`, which checks the internal structure of the tree.\n\nIf the tree is empty, the method confirms that both the boundary table and top node are not present.\n\nNo input parameters are required. The method does not return any value but raises `AssertionError` if any of the invariants are violated, providing a message with details regarding the inconsistency.\n\nAttributes used:\n- `self.all_intervals`: A set of all intervals in the tree.\n- `self.top_node`: The root node of the interval tree, which contains a method to verify the node structure.\n- `self.boundary_table`: A sorted dictionary that maintains boundaries of intervals for efficient queries.\n\nThis method is meant primarily for debugging purposes.",
        "signature": "def verify(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      },
      "IntervalTree.__iter__": {
        "code": "    def __iter__(self):\n        \"\"\"Returns an iterator that yields all intervals contained within the interval tree.\n\nThis method provides a standard way to iterate over the intervals stored in the `IntervalTree` instance. It leverages the `all_intervals` attribute, which is a set that maintains all the interval objects in the tree. Since `all_intervals` is a set, the order of the intervals may not be guaranteed, but the iteration will cover all unique intervals present in the tree.\n\nCompletes in O(1) time as it directly accesses the underlying data structure.\n\n:rtype: collections.Iterator[Interval]\"\"\"\n        '\\n        Returns an iterator over all the intervals in the tree.\\n\\n        Completes in O(1) time.\\n        :rtype: collections.Iterable[Interval]\\n        '\n        return self.all_intervals.__iter__()",
        "docstring": "Returns an iterator that yields all intervals contained within the interval tree.\n\nThis method provides a standard way to iterate over the intervals stored in the `IntervalTree` instance. It leverages the `all_intervals` attribute, which is a set that maintains all the interval objects in the tree. Since `all_intervals` is a set, the order of the intervals may not be guaranteed, but the iteration will cover all unique intervals present in the tree.\n\nCompletes in O(1) time as it directly accesses the underlying data structure.\n\n:rtype: collections.Iterator[Interval]",
        "signature": "def __iter__(self):",
        "type": "Method",
        "class_signature": "class IntervalTree(MutableSet):"
      }
    },
    "intervaltree/interval.py": {
      "Interval.__new__": {
        "code": "    def __new__(cls, begin, end, data=None):\n        \"\"\"Create a new instance of the Interval class.\n\nThis method constructs an Interval object, which represents a mutable range defined by a beginning and an end point, optionally including associated data. It ensures that the Interval can be initialized with the specified attributes while adhering to the constraints of the parent class, `namedtuple`.\n\nParameters:\n- begin (numeric): The starting point of the interval.\n- end (numeric): The ending point of the interval.\n- data (optional): An optional attribute to store additional information associated with the interval.\n\nReturns:\n- Interval: An instance of the Interval class initialized with the specified begin, end, and data attributes.\n\nThis method relies on the `namedtuple` feature from the `collections` module to manage the interval\u2019s fields efficiently.\"\"\"\n        return super(Interval, cls).__new__(cls, begin, end, data)",
        "docstring": "Create a new instance of the Interval class.\n\nThis method constructs an Interval object, which represents a mutable range defined by a beginning and an end point, optionally including associated data. It ensures that the Interval can be initialized with the specified attributes while adhering to the constraints of the parent class, `namedtuple`.\n\nParameters:\n- begin (numeric): The starting point of the interval.\n- end (numeric): The ending point of the interval.\n- data (optional): An optional attribute to store additional information associated with the interval.\n\nReturns:\n- Interval: An instance of the Interval class initialized with the specified begin, end, and data attributes.\n\nThis method relies on the `namedtuple` feature from the `collections` module to manage the interval\u2019s fields efficiently.",
        "signature": "def __new__(cls, begin, end, data=None):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.is_null": {
        "code": "    def is_null(self):\n        \"\"\"Determines if the current Interval instance represents a null interval, where a null interval is defined as an interval with its end point less than or equal to its beginning point.\n\n:return: True if the interval is null (i.e., end <= begin), otherwise False.\n:rtype: bool\n\nThis method interacts with the Interval's attributes `begin` and `end`, which are set during initialization of the Interval instance. It is used to validate or compare intervals throughout other methods in this class.\"\"\"\n        '\\n        Whether this equals the null interval.\\n        :return: True if end <= begin else False\\n        :rtype: bool\\n        '\n        return self.begin >= self.end",
        "docstring": "Determines if the current Interval instance represents a null interval, where a null interval is defined as an interval with its end point less than or equal to its beginning point.\n\n:return: True if the interval is null (i.e., end <= begin), otherwise False.\n:rtype: bool\n\nThis method interacts with the Interval's attributes `begin` and `end`, which are set during initialization of the Interval instance. It is used to validate or compare intervals throughout other methods in this class.",
        "signature": "def is_null(self):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__hash__": {
        "code": "    def __hash__(self):\n        \"\"\"Calculates the hash value for the Interval instance based on its `begin` and `end` attributes. This method allows Interval instances to be used as keys in hash tables and sets. The hash is computed using the built-in `hash` function on a tuple containing `self.begin` and `self.end`, ensuring that intervals with the same start and end points produce identical hash values.\n\n:return: A hash value derived from the `begin` and `end` attributes.\n:rtype: Number\"\"\"\n        '\\n        Depends on begin and end only.\\n        :return: hash\\n        :rtype: Number\\n        '\n        return hash((self.begin, self.end))",
        "docstring": "Calculates the hash value for the Interval instance based on its `begin` and `end` attributes. This method allows Interval instances to be used as keys in hash tables and sets. The hash is computed using the built-in `hash` function on a tuple containing `self.begin` and `self.end`, ensuring that intervals with the same start and end points produce identical hash values.\n\n:return: A hash value derived from the `begin` and `end` attributes.\n:rtype: Number",
        "signature": "def __hash__(self):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      },
      "Interval.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Determines equality between two Interval instances. This method compares if both the `begin` and `end` values, as well as the `data` field, are equal between the two Interval objects.\n\n:param other: An instance of Interval to compare against.\n:return: True if both intervals have the same beginning, end points, and data; otherwise, False.\n:rtype: bool\n\nThis method leverages the attributes `begin`, `end`, and `data` which are defined in the Interval class using the `namedtuple` structure. It ensures that all relevant properties are considered when checking for equality.\"\"\"\n        '\\n        Whether the begins equal, the ends equal, and the data fields\\n        equal. Compare range_matches().\\n        :param other: Interval\\n        :return: True or False\\n        :rtype: bool\\n        '\n        return self.begin == other.begin and self.end == other.end and (self.data == other.data)",
        "docstring": "Determines equality between two Interval instances. This method compares if both the `begin` and `end` values, as well as the `data` field, are equal between the two Interval objects.\n\n:param other: An instance of Interval to compare against.\n:return: True if both intervals have the same beginning, end points, and data; otherwise, False.\n:rtype: bool\n\nThis method leverages the attributes `begin`, `end`, and `data` which are defined in the Interval class using the `namedtuple` structure. It ensures that all relevant properties are considered when checking for equality.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
      }
    }
  },
  "dependency_dict": {
    "intervaltree/intervaltree.py:IntervalTree:__init__": {},
    "intervaltree/node.py:Node:from_intervals": {},
    "intervaltree/intervaltree.py:IntervalTree:addi": {},
    "intervaltree/interval.py:Interval:__new__": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:add": {
      "intervaltree/intervaltree.py": {
        "IntervalTree._add_boundaries": {
          "code": "    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1",
          "docstring": "Records the boundaries of the interval in the boundary table.",
          "signature": "def _add_boundaries(self, interval):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        },
        "IntervalTree.__contains__": {
          "code": "    def __contains__(self, item):\n        \"\"\"\n        Returns whether item exists as an Interval in the tree.\n        This method only returns True for exact matches; for\n        overlaps, see the overlaps() method.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return item in self.all_intervals",
          "docstring": "Returns whether item exists as an Interval in the tree.\nThis method only returns True for exact matches; for\noverlaps, see the overlaps() method.\n\nCompletes in O(1) time.\n:rtype: bool",
          "signature": "def __contains__(self, item):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        }
      },
      "intervaltree/node.py": {
        "Node.from_interval": {
          "code": "    def from_interval(cls, interval):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        center = interval.begin\n        return Node(center, [interval])",
          "docstring": ":rtype : Node",
          "signature": "def from_interval(cls, interval):",
          "type": "Method",
          "class_signature": "class Node(object):"
        },
        "Node.add": {
          "code": "    def add(self, interval):\n        \"\"\"\n        Returns self after adding the interval and balancing.\n        \"\"\"\n        if self.center_hit(interval):\n            self.s_center.add(interval)\n            return self\n        else:\n            direction = self.hit_branch(interval)\n            if not self[direction]:\n                self[direction] = Node.from_interval(interval)\n                self.refresh_balance()\n                return self\n            else:\n                self[direction] = self[direction].add(interval)\n                return self.rotate()",
          "docstring": "Returns self after adding the interval and balancing.",
          "signature": "def add(self, interval):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:verify": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "intervaltree/interval.py:Interval:Interval": {},
    "intervaltree/node.py:Node:all_children": {
      "intervaltree/node.py": {
        "Node.all_children_helper": {
          "code": "    def all_children_helper(self, result):\n        result.update(self.s_center)\n        if self[0]:\n            self[0].all_children_helper(result)\n        if self[1]:\n            self[1].all_children_helper(result)\n        return result",
          "docstring": "",
          "signature": "def all_children_helper(self, result):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
    "intervaltree/interval.py:Interval:is_null": {},
    "intervaltree/node.py:Node:verify": {
      "intervaltree/interval.py": {
        "Interval.overlaps": {
          "code": "    def overlaps(self, begin, end=None):\n        \"\"\"\n        Whether the interval overlaps the given point, range or Interval.\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return begin < self.end and end > self.begin\n        try:\n            return self.overlaps(begin.begin, begin.end)\n        except:\n            return self.contains_point(begin)",
          "docstring": "Whether the interval overlaps the given point, range or Interval.\n:param begin: beginning point of the range, or the point, or an Interval\n:param end: end point of the range. Optional if not testing ranges.\n:return: True or False\n:rtype: bool",
          "signature": "def overlaps(self, begin, end=None):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      },
      "intervaltree/node.py": {
        "Node.refresh_balance": {
          "code": "    def refresh_balance(self):\n        \"\"\"\n        Recalculate self.balance and self.depth based on child node values.\n        \"\"\"\n        left_depth = self.left_node.depth if self.left_node else 0\n        right_depth = self.right_node.depth if self.right_node else 0\n        self.depth = 1 + max(left_depth, right_depth)\n        self.balance = right_depth - left_depth",
          "docstring": "Recalculate self.balance and self.depth based on child node values.",
          "signature": "def refresh_balance(self):",
          "type": "Method",
          "class_signature": "class Node(object):"
        },
        "Node.__getitem__": {
          "code": "    def __getitem__(self, index):\n        \"\"\"\n        Returns the left child if input is equivalent to False, or\n        the right side otherwise.\n        \"\"\"\n        if index:\n            return self.right_node\n        else:\n            return self.left_node",
          "docstring": "Returns the left child if input is equivalent to False, or\nthe right side otherwise.",
          "signature": "def __getitem__(self, index):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/interval.py:Interval:__eq__": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:removei": {},
    "intervaltree/intervaltree.py:IntervalTree:remove": {
      "intervaltree/intervaltree.py": {
        "IntervalTree._remove_boundaries": {
          "code": "    def _remove_boundaries(self, interval):\n        \"\"\"\n        Removes the boundaries of the interval from the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if self.boundary_table[begin] == 1:\n            del self.boundary_table[begin]\n        else:\n            self.boundary_table[begin] -= 1\n        if self.boundary_table[end] == 1:\n            del self.boundary_table[end]\n        else:\n            self.boundary_table[end] -= 1",
          "docstring": "Removes the boundaries of the interval from the boundary table.",
          "signature": "def _remove_boundaries(self, interval):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        },
        "IntervalTree.__contains__": {
          "code": "    def __contains__(self, item):\n        \"\"\"\n        Returns whether item exists as an Interval in the tree.\n        This method only returns True for exact matches; for\n        overlaps, see the overlaps() method.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return item in self.all_intervals",
          "docstring": "Returns whether item exists as an Interval in the tree.\nThis method only returns True for exact matches; for\noverlaps, see the overlaps() method.\n\nCompletes in O(1) time.\n:rtype: bool",
          "signature": "def __contains__(self, item):",
          "type": "Method",
          "class_signature": "class IntervalTree(MutableSet):"
        }
      },
      "intervaltree/node.py": {
        "Node.remove": {
          "code": "    def remove(self, interval):\n        \"\"\"\n        Returns self after removing the interval and balancing.\n\n        If interval is not present, raise ValueError.\n        \"\"\"\n        done = []\n        return self.remove_interval_helper(interval, done, should_raise_error=True)",
          "docstring": "Returns self after removing the interval and balancing.\n\nIf interval is not present, raise ValueError.",
          "signature": "def remove(self, interval):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/intervaltree.py:IntervalTree:from_tuples": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "intervaltree/node.py:Node:__init__": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      },
      "intervaltree/node.py": {
        "Node.rotate": {
          "code": "    def rotate(self):\n        \"\"\"\n        Does rotating, if necessary, to balance this node, and\n        returns the new top node.\n        \"\"\"\n        self.refresh_balance()\n        if abs(self.balance) < 2:\n            return self\n        my_heavy = self.balance > 0\n        child_heavy = self[my_heavy].balance > 0\n        if my_heavy == child_heavy or self[my_heavy].balance == 0:\n            return self.srotate()\n        else:\n            return self.drotate()",
          "docstring": "Does rotating, if necessary, to balance this node, and\nreturns the new top node.",
          "signature": "def rotate(self):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      }
    },
    "intervaltree/interval.py:Interval:__hash__": {
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "intervaltree/node.py:Node:print_structure": {
      "intervaltree/node.py": {
        "Node.__str__": {
          "code": "    def __str__(self):\n        \"\"\"\n        Shows info about this node.\n\n        Since Nodes are internal data structures not revealed to the\n        user, I'm not bothering to make this copy-paste-executable as a\n        constructor.\n        \"\"\"\n        return 'Node<{0}, depth={1}, balance={2}>'.format(self.x_center, self.depth, self.balance)",
          "docstring": "Shows info about this node.\n\nSince Nodes are internal data structures not revealed to the\nuser, I'm not bothering to make this copy-paste-executable as a\nconstructor.",
          "signature": "def __str__(self):",
          "type": "Method",
          "class_signature": "class Node(object):"
        }
      },
      "test/data/issue41_orig.py": {
        "tree": {
          "code": "def tree():\n    t = IntervalTree.from_tuples(data)\n    # Node<961, depth=2, balance=0>\n    #  Interval(961, 986, 1)\n    root = Node()\n    root.x_center = 961\n    root.s_center = set([Interval(*data[7])])\n    root.depth = 2\n    root.balance = 0\n\n    # <:  Node<871, depth=1, balance=0>\n    #      Interval(860, 917, 1)\n    #      Interval(860, 917, 2)\n    #      Interval(860, 917, 3)\n    #      Interval(860, 917, 4)\n    #      Interval(871, 917, 1)\n    #      Interval(871, 917, 2)\n    #      Interval(871, 917, 3)\n    n = root.left_node = Node()\n    n.x_center = 871\n    n.s_center = set(Interval(*tup) for tup in data[:7])\n    n.depth = 1\n    n.balance = 0\n\n    # >:  Node<1047, depth=1, balance=0>\n    #      Interval(1047, 1064, 1)\n    #      Interval(1047, 1064, 2)\n    n = root.right_node = Node()\n    n.x_center = 1047\n    n.s_center = set(Interval(*tup) for tup in data[8:])\n    n.depth = 1\n    n.balance = 0\n\n    structure = root.print_structure(tostring=True)\n    # root.print_structure()\n    assert structure == \"\"\"\\\nNode<961, depth=2, balance=0>\n Interval(961, 986, 1)\n<:  Node<871, depth=1, balance=0>\n     Interval(860, 917, 1)\n     Interval(860, 917, 2)\n     Interval(860, 917, 3)\n     Interval(860, 917, 4)\n     Interval(871, 917, 1)\n     Interval(871, 917, 2)\n     Interval(871, 917, 3)\n>:  Node<1047, depth=1, balance=0>\n     Interval(1047, 1064, 1)\n     Interval(1047, 1064, 2)\n\"\"\"\n    t.top_node = root\n    t.verify()\n    return t",
          "docstring": "",
          "signature": "def tree():",
          "type": "Function",
          "class_signature": null
        }
      },
      "intervaltree/interval.py": {
        "Interval.__repr__": {
          "code": "    def __repr__(self):\n        \"\"\"\n        Executable string representation of this Interval.\n        :return: string representation\n        :rtype: str\n        \"\"\"\n        if isinstance(self.begin, Number):\n            s_begin = str(self.begin)\n            s_end = str(self.end)\n        else:\n            s_begin = repr(self.begin)\n            s_end = repr(self.end)\n        if self.data is None:\n            return 'Interval({0}, {1})'.format(s_begin, s_end)\n        else:\n            return 'Interval({0}, {1}, {2})'.format(s_begin, s_end, repr(self.data))",
          "docstring": "Executable string representation of this Interval.\n:return: string representation\n:rtype: str",
          "signature": "def __repr__(self):",
          "type": "Method",
          "class_signature": "class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):"
        }
      }
    }
  },
  "call_tree": {
    "test/issues/issue41_test.py:test_sequence": {
      "intervaltree/intervaltree.py:IntervalTree:__init__": {
        "intervaltree/node.py:Node:from_intervals": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:addi": {
        "intervaltree/interval.py:Interval:__new__": {},
        "intervaltree/intervaltree.py:IntervalTree:add": {
          "intervaltree/intervaltree.py:IntervalTree:__contains__": {
            "intervaltree/interval.py:Interval:__hash__": {},
            "intervaltree/interval.py:Interval:__eq__": {}
          },
          "intervaltree/interval.py:Interval:is_null": {},
          "intervaltree/node.py:Node:from_interval": {
            "intervaltree/node.py:Node:__init__": {
              "intervaltree/interval.py:Interval:__hash__": {},
              "intervaltree/node.py:Node:rotate": {
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            }
          },
          "intervaltree/interval.py:Interval:__hash__": {},
          "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {},
          "intervaltree/node.py:Node:add": {
            "intervaltree/node.py:Node:center_hit": {
              "intervaltree/interval.py:Interval:contains_point": {}
            },
            "intervaltree/interval.py:Interval:__hash__": {},
            "intervaltree/interval.py:Interval:__eq__": {},
            "intervaltree/node.py:Node:hit_branch": {},
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:from_interval": {
              "intervaltree/node.py:Node:__init__": {
                "intervaltree/interval.py:Interval:__hash__": {},
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              }
            },
            "intervaltree/node.py:Node:__setitem__": {},
            "intervaltree/node.py:Node:refresh_balance": {},
            "intervaltree/node.py:Node:add": {
              "[ignored_or_cut_off]": "..."
            },
            "intervaltree/node.py:Node:rotate": {
              "intervaltree/node.py:Node:refresh_balance": {},
              "intervaltree/node.py:Node:__getitem__": {},
              "intervaltree/node.py:Node:srotate": {
                "intervaltree/node.py:Node:__getitem__": {},
                "intervaltree/node.py:Node:__setitem__": {},
                "intervaltree/node.py:Node:rotate": {
                  "[ignored_or_cut_off]": "..."
                },
                "intervaltree/node.py:Node:center_hit": {
                  "intervaltree/interval.py:Interval:contains_point": {}
                },
                "intervaltree/node.py:Node:remove": {
                  "intervaltree/node.py:Node:remove_interval_helper": {
                    "intervaltree/node.py:Node:center_hit": {
                      "intervaltree/interval.py:Interval:contains_point": {}
                    },
                    "intervaltree/interval.py:Interval:__hash__": {},
                    "intervaltree/interval.py:Interval:__eq__": {},
                    "intervaltree/node.py:Node:prune": {
                      "intervaltree/node.py:Node:__getitem__": {}
                    }
                  }
                },
                "intervaltree/interval.py:Interval:__hash__": {},
                "intervaltree/interval.py:Interval:__eq__": {},
                "intervaltree/node.py:Node:refresh_balance": {}
              }
            }
          },
          "intervaltree/interval.py:Interval:__eq__": {}
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:verify": {
        "intervaltree/interval.py:Interval:Interval": {},
        "intervaltree/node.py:Node:all_children": {
          "intervaltree/node.py:Node:all_children_helper": {
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:all_children_helper": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:verify": {
          "intervaltree/node.py:Node:refresh_balance": {},
          "intervaltree/interval.py:Interval:overlaps": {
            "intervaltree/interval.py:Interval:contains_point": {}
          },
          "intervaltree/node.py:Node:__getitem__": {},
          "intervaltree/node.py:Node:verify": {
            "[ignored_or_cut_off]": "..."
          }
        },
        "intervaltree/interval.py:Interval:__eq__": {}
      },
      "intervaltree/intervaltree.py:IntervalTree:removei": {
        "intervaltree/interval.py:Interval:__new__": {},
        "intervaltree/intervaltree.py:IntervalTree:remove": {
          "intervaltree/intervaltree.py:IntervalTree:__contains__": {
            "intervaltree/interval.py:Interval:__hash__": {},
            "intervaltree/interval.py:Interval:__eq__": {}
          },
          "intervaltree/node.py:Node:remove": {
            "intervaltree/node.py:Node:remove_interval_helper": {
              "intervaltree/node.py:Node:center_hit": {
                "intervaltree/interval.py:Interval:contains_point": {}
              },
              "intervaltree/interval.py:Interval:__hash__": {},
              "intervaltree/interval.py:Interval:__eq__": {},
              "intervaltree/node.py:Node:prune": {
                "intervaltree/node.py:Node:__getitem__": {},
                "intervaltree/node.py:Node:pop_greatest_child": {
                  "intervaltree/node.py:Node:__init__": {
                    "intervaltree/node.py:Node:get_new_s_center": {
                      "intervaltree/interval.py:Interval:contains_point": {}
                    },
                    "intervaltree/interval.py:Interval:__hash__": {},
                    "intervaltree/interval.py:Interval:__eq__": {},
                    "intervaltree/node.py:Node:rotate": {
                      "intervaltree/node.py:Node:refresh_balance": {}
                    }
                  },
                  "intervaltree/interval.py:Interval:__eq__": {},
                  "intervaltree/node.py:Node:__getitem__": {}
                },
                "intervaltree/node.py:Node:__setitem__": {},
                "intervaltree/node.py:Node:refresh_balance": {},
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              }
            }
          },
          "intervaltree/interval.py:Interval:__hash__": {},
          "intervaltree/interval.py:Interval:__eq__": {},
          "intervaltree/intervaltree.py:IntervalTree:_remove_boundaries": {}
        }
      }
    },
    "test/issues/issue41_test.py:test_structure": {
      "test/data/issue41_orig.py:tree": {
        "intervaltree/intervaltree.py:IntervalTree:from_tuples": {
          "intervaltree/interval.py:Interval:__new__": {},
          "intervaltree/intervaltree.py:IntervalTree:__init__": {
            "intervaltree/interval.py:Interval:__hash__": {},
            "intervaltree/interval.py:Interval:__eq__": {},
            "intervaltree/interval.py:Interval:is_null": {},
            "intervaltree/node.py:Node:from_intervals": {
              "intervaltree/interval.py:Interval:__lt__": {
                "intervaltree/interval.py:Interval:__cmp__": {}
              },
              "intervaltree/node.py:Node:from_sorted_intervals": {
                "intervaltree/node.py:Node:__init__": {
                  "intervaltree/node.py:Node:rotate": {
                    "intervaltree/node.py:Node:refresh_balance": {}
                  }
                },
                "intervaltree/node.py:Node:init_from_sorted": {
                  "intervaltree/interval.py:Interval:__hash__": {},
                  "intervaltree/interval.py:Interval:__eq__": {},
                  "intervaltree/node.py:Node:from_sorted_intervals": {
                    "[ignored_or_cut_off]": "..."
                  },
                  "intervaltree/node.py:Node:rotate": {
                    "intervaltree/node.py:Node:refresh_balance": {},
                    "intervaltree/node.py:Node:__getitem__": {},
                    "intervaltree/node.py:Node:drotate": {
                      "intervaltree/node.py:Node:__getitem__": {},
                      "intervaltree/node.py:Node:srotate": {},
                      "intervaltree/node.py:Node:__setitem__": {},
                      "intervaltree/node.py:Node:refresh_balance": {}
                    }
                  }
                }
              }
            },
            "intervaltree/intervaltree.py:IntervalTree:_add_boundaries": {}
          }
        },
        "intervaltree/node.py:Node:__init__": {
          "intervaltree/node.py:Node:rotate": {
            "intervaltree/node.py:Node:refresh_balance": {}
          }
        },
        "intervaltree/interval.py:Interval:__new__": {},
        "intervaltree/interval.py:Interval:__hash__": {},
        "intervaltree/interval.py:Interval:__eq__": {},
        "intervaltree/node.py:Node:print_structure": {
          "intervaltree/node.py:Node:__str__": {},
          "intervaltree/interval.py:Interval:__repr__": {},
          "intervaltree/node.py:Node:print_structure": {
            "[ignored_or_cut_off]": "..."
          }
        },
        "intervaltree/intervaltree.py:IntervalTree:verify": {
          "intervaltree/node.py:Node:all_children": {
            "intervaltree/node.py:Node:all_children_helper": {
              "intervaltree/node.py:Node:__getitem__": {},
              "intervaltree/node.py:Node:all_children_helper": {
                "[ignored_or_cut_off]": "..."
              }
            }
          },
          "intervaltree/interval.py:Interval:__eq__": {},
          "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
          "intervaltree/interval.py:Interval:is_null": {},
          "intervaltree/node.py:Node:verify": {
            "intervaltree/node.py:Node:refresh_balance": {},
            "intervaltree/interval.py:Interval:overlaps": {
              "intervaltree/interval.py:Interval:contains_point": {}
            },
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:verify": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:verify": {
        "intervaltree/node.py:Node:all_children": {
          "intervaltree/node.py:Node:all_children_helper": {
            "intervaltree/node.py:Node:__getitem__": {},
            "intervaltree/node.py:Node:all_children_helper": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "intervaltree/interval.py:Interval:__eq__": {},
        "intervaltree/intervaltree.py:IntervalTree:__iter__": {},
        "intervaltree/interval.py:Interval:is_null": {},
        "intervaltree/node.py:Node:verify": {
          "intervaltree/node.py:Node:refresh_balance": {},
          "intervaltree/interval.py:Interval:overlaps": {
            "intervaltree/interval.py:Interval:contains_point": {}
          },
          "intervaltree/node.py:Node:__getitem__": {},
          "intervaltree/node.py:Node:verify": {
            "[ignored_or_cut_off]": "..."
          }
        }
      },
      "intervaltree/intervaltree.py:IntervalTree:removei": {
        "intervaltree/interval.py:Interval:__new__": {},
        "intervaltree/intervaltree.py:IntervalTree:remove": {
          "intervaltree/intervaltree.py:IntervalTree:__contains__": {
            "intervaltree/interval.py:Interval:__hash__": {},
            "intervaltree/interval.py:Interval:__eq__": {}
          },
          "intervaltree/node.py:Node:remove": {
            "intervaltree/node.py:Node:remove_interval_helper": {
              "intervaltree/node.py:Node:center_hit": {
                "intervaltree/interval.py:Interval:contains_point": {}
              },
              "intervaltree/interval.py:Interval:__hash__": {},
              "intervaltree/interval.py:Interval:__eq__": {},
              "intervaltree/node.py:Node:prune": {
                "intervaltree/node.py:Node:__getitem__": {},
                "intervaltree/node.py:Node:pop_greatest_child": {
                  "intervaltree/node.py:Node:__init__": {
                    "intervaltree/node.py:Node:get_new_s_center": {
                      "intervaltree/interval.py:Interval:contains_point": {}
                    },
                    "intervaltree/interval.py:Interval:__hash__": {},
                    "intervaltree/interval.py:Interval:__eq__": {},
                    "intervaltree/node.py:Node:rotate": {
                      "intervaltree/node.py:Node:refresh_balance": {}
                    }
                  },
                  "intervaltree/interval.py:Interval:__eq__": {},
                  "intervaltree/node.py:Node:__getitem__": {}
                },
                "intervaltree/node.py:Node:__setitem__": {},
                "intervaltree/node.py:Node:refresh_balance": {},
                "intervaltree/node.py:Node:rotate": {
                  "intervaltree/node.py:Node:refresh_balance": {}
                }
              }
            }
          },
          "intervaltree/interval.py:Interval:__hash__": {},
          "intervaltree/interval.py:Interval:__eq__": {},
          "intervaltree/intervaltree.py:IntervalTree:_remove_boundaries": {}
        }
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-issue41_test/intervaltree-issue41_test/test/intervaltree_methods/setlike_test.py:test_update": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-issue41_test/intervaltree-issue41_test/test/intervaltree_methods/setlike_test.py:test_difference": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-issue41_test/intervaltree-issue41_test/test/intervaltree_methods/setlike_test.py:test_difference_operator": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-issue41_test/intervaltree-issue41_test/test/optimality/optimality_test_matrix.py:OptimalityTestMatrix:test_prebuilt": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/intervaltree-image-issue41_test/intervaltree-issue41_test/modified_testcases/optimality/optimality_test_matrix.py:OptimalityTestMatrix:test_prebuilt": {
      "intervaltree/intervaltree.py:IntervalTree:IntervalTree": {}
    }
  },
  "PRD": "# PROJECT NAME: intervaltree-issue41_test\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 intervaltree/\n    \u251c\u2500\u2500 interval.py\n    \u2502   \u251c\u2500\u2500 Interval.Interval\n    \u2502   \u251c\u2500\u2500 Interval.__eq__\n    \u2502   \u251c\u2500\u2500 Interval.__hash__\n    \u2502   \u251c\u2500\u2500 Interval.__new__\n    \u2502   \u2514\u2500\u2500 Interval.is_null\n    \u251c\u2500\u2500 intervaltree.py\n    \u2502   \u251c\u2500\u2500 IntervalTree.IntervalTree\n    \u2502   \u251c\u2500\u2500 IntervalTree.__init__\n    \u2502   \u251c\u2500\u2500 IntervalTree.__iter__\n    \u2502   \u251c\u2500\u2500 IntervalTree.add\n    \u2502   \u251c\u2500\u2500 IntervalTree.addi\n    \u2502   \u251c\u2500\u2500 IntervalTree.from_tuples\n    \u2502   \u251c\u2500\u2500 IntervalTree.remove\n    \u2502   \u251c\u2500\u2500 IntervalTree.removei\n    \u2502   \u2514\u2500\u2500 IntervalTree.verify\n    \u2514\u2500\u2500 node.py\n        \u251c\u2500\u2500 Node.__init__\n        \u251c\u2500\u2500 Node.all_children\n        \u251c\u2500\u2500 Node.from_intervals\n        \u251c\u2500\u2500 Node.print_structure\n        \u2514\u2500\u2500 Node.verify\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module provides functionality for managing and manipulating interval trees in Python, enabling efficient storage, querying, and modification of intervals. It supports operations such as adding, removing, and verifying intervals, with capabilities to query intervals by point, range overlap, or range envelopment. Designed to be mutable and self-balancing, it ensures data consistency even after modifications, enhancing performance and reliability. This module addresses the need for developers to handle interval-based operations in a structured and computationally efficient manner, solving problems related to overlapping or hierarchical data.\n\n## FILE 1: intervaltree/node.py\n\n- CLASS METHOD: Node.__init__\n  - CLASS SIGNATURE: class Node(object):\n  - SIGNATURE: def __init__(self, x_center=None, s_center=set(), left_node=None, right_node=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Node in an interval tree, representing an interval's center and the intervals that overlap it.\n\nParameters:\n- x_center (optional): The central point of the intervals, which serves as the splitting point for subtree organization. It should be a numeric value representing the center of the interval.\n- s_center (optional): A set of intervals overlapping the x_center. It defaults to an empty set but can be initialized with a collection of intervals.\n- left_node (optional): A reference to the left child Node, representing intervals that are completely to the left of x_center.\n- right_node (optional): A reference to the right child Node, representing intervals that are completely to the right of x_center.\n\nThe Node construction also initializes `depth` and `balance` to 0, which will be updated later during balancing operations. Upon initialization, it immediately balances the Node using the `rotate()` method. The method expects the `s_center` to contain intervals that have `begin` and `end` attributes, which are essential for determining overlaps and for the functioning of the tree.\n\"\"\"\n```\n\n- CLASS METHOD: Node.all_children\n  - CLASS SIGNATURE: class Node(object):\n  - SIGNATURE: def all_children(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a set of all intervals contained within this node and its descendants.\n\nThis method invokes the helper function `all_children_helper`, which is initiated with an empty set to accumulate the intervals. It traverses the entire subtree of the Node, collecting intervals from both the left and right children, if they exist, and returns the complete collection of intervals. This can be useful for operations that require knowledge of all intervals present in the entire interval tree.\n\nNo input parameters or constants are required for this method.\n\"\"\"\n```\n\n- CLASS METHOD: Node.print_structure\n  - CLASS SIGNATURE: class Node(object):\n  - SIGNATURE: def print_structure(self, indent=0, tostring=False):\n  - DOCSTRING: \n```python\n\"\"\"\nPrints or returns a structured representation of the Node and its subtrees for debugging purposes.\n\nParameters:\n    indent (int): The level of indentation used for the printed structure, enabling visualization of the tree hierarchy.\n    tostring (bool): If True, the function returns the structure as a string instead of printing it directly.\n\nReturns:\n    str: A string representation of the Node and its intervals if tostring is True. Otherwise, it prints the structure directly.\n\nThis method accesses the Node's attributes, including `s_center` (a set of intervals associated with the Node), \n`left_node`, and `right_node` (links to child Nodes). It constructs a visual layout of the tree structure, indicating \nthe relationships between Nodes and displaying the intervals contained in each Node.\n\"\"\"\n```\n\n- CLASS METHOD: Node.verify\n  - CLASS SIGNATURE: class Node(object):\n  - SIGNATURE: def verify(self, parents=set()):\n  - DOCSTRING: \n```python\n\"\"\"\n## DEBUG ONLY ##\nRecursively verifies the invariants of an interval subtree represented by the Node instance. It checks that the subtree adheres to AVL tree properties, ensuring correct balancing and structure.\n\nParameters:\n- parents (set): A set of ancestor x_center values for the current node, used to verify that no intervals overlap with their ancestor nodes.\n\nReturns:\n- None: If the assertions hold true, the method completes without returning a value. If any assertion fails, it raises an AssertionError with a descriptive message.\n\nKey Checks:\n- Verifies that the balance factor (self.balance) is within the range of -1 to 1, ensuring the node is correctly balanced.\n- Ensures that s_center, the set of intervals at this node, is not empty.\n- Confirms that each interval in s_center has valid properties (begin and end attributes), and that they overlap with the node's x_center.\n- Ensures the ordering of child nodes based on their x_center, maintaining the binary search tree property.\n\nDependencies:\n- Calls self.refresh_balance() to recalculate the balance factor after checking assertions.\n- Utilizes self[0] and self[1] for left and right child nodes, validating their structure and order.\n\nThis method is essential for maintaining the integrity and efficiency of operations on the interval tree.\n\"\"\"\n```\n\n- CLASS METHOD: Node.from_intervals\n  - CLASS SIGNATURE: class Node(object):\n  - SIGNATURE: def from_intervals(cls, intervals):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates a Node instance from a list of intervals.\n\n:param intervals: A list of interval objects that need to be stored in the new Node. Each interval is expected to have 'begin' and 'end' attributes.\n:rtype: Node or None: Returns a Node containing the provided intervals if the list is non-empty. If the list is empty, it returns None, indicating that no Node can be created.\n:raises: The method relies on the Node.from_sorted_intervals class method to initialize the Node with sorted intervals, ensuring that it correctly constructs an AVL tree structure suited for interval management.\n\"\"\"\n```\n\n## FILE 2: intervaltree/intervaltree.py\n\n- CLASS METHOD: IntervalTree.add\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def add(self, interval):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds an `Interval` object to the `IntervalTree` if it is not already present. The operation ensures that duplicates are not added, and raises a `ValueError` if the interval is null (i.e., it has no valid start and end points). If the tree is empty, it initializes the `top_node` with the new interval; otherwise, it delegates the addition to the `add` method of the current `top_node`. The method updates the `all_intervals` set and records the boundaries of the newly added interval in the `boundary_table`.\n\nParameters:\n- `interval` (Interval): An `Interval` object representing a half-open interval, which should contain valid start and end values.\n\nReturns:\n- None: This method does not return a value.\n\nRaises:\n- ValueError: If the provided interval is null.\n\nSide Effects:\n- Updates the `top_node` of the tree if it is empty or modifies the existing tree structure.\n- Modifies the `all_intervals` set and the `boundary_table` for maintaining the tree's structure.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__init__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __init__(self, intervals=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an IntervalTree, a data structure for managing a set of intervals efficiently. \n\nParameters:\n-----------\nintervals: iterable, optional\n    An optional iterable of Interval objects to initialize the tree. If provided, these intervals are added to the tree while ensuring that no null intervals are included.\n\nRaises:\n-------\nValueError: \n    If any of the provided intervals is a null interval (i.e., an interval that is not properly defined).\n\nAttributes:\n-----------\n- all_intervals: A set storing the unique intervals in the tree.\n- top_node: The root node of the tree, initialized from the provided intervals using Node.from_intervals.\n- boundary_table: A SortedDict to track the boundaries of intervals for quick access and management.\n\nComplexity:\n-----------\nThe initialization process completes in O(n*log n) time, where n is the number of intervals provided, as it requires sorting and building the tree structure.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.removei\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def removei(self, begin, end, data=None):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves an interval from the IntervalTree using a specified start and end point.\n\nParameters:\n- begin (float or int): The starting point of the interval to be removed.\n- end (float or int): The ending point of the interval to be removed.\n- data (optional): Not used; included for compatibility with the `remove` method.\n\nReturns:\n- None. If the interval specified by (begin, end, data) is present in the tree, it will be removed. If not present, a ValueError will be raised.\n\nThis method directly calls the `remove` method of the IntervalTree class, which manages the actual removal process. It executes in O(log n) time, where n is the number of intervals in the tree. Intervals in the tree are instances of the `Interval` class defined in the imported `interval` module.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.from_tuples\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def from_tuples(cls, tups):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new `IntervalTree` from an iterable of 2- or 3-tuples, where each tuple defines an interval's start, end, and optionally, associated data. The method constructs `Interval` objects from the provided tuples and initializes the `IntervalTree` with these intervals.\n\nParameters:\n- `tups`: An iterable of 2- or 3-element tuples. Each tuple should contain float or integer values that define the beginning and ending points of the intervals, and optionally, a data value.\n\nReturns:\n- An instance of `IntervalTree` populated with the intervals created from the input tuples.\n\nThis method relies on the `Interval` class, which must be defined in the same module, and it preserves the order of intervals during tree creation. The resulting tree can be used for efficient interval operations such as querying overlaps, containment, and other interval-related functionalities.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.verify\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def verify(self):\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies the integrity of the IntervalTree data structure by checking that it maintains its invariants. This method performs several assertions to ensure consistency among the tree's members, boundary table, and internal structures.\n\nChecks include:\n- Ensures that all intervals in the tree correspond to the expected set of intervals (`self.all_intervals`).\n- Validates that all members are instances of the `Interval` class.\n- Confirms that no null intervals are present in the tree.\n- Reconstructs the boundary table from the current intervals and verifies its consistency with the existing boundary table.\n- Calls the `verify` method of the `top_node`, which checks the internal structure of the tree.\n\nIf the tree is empty, the method confirms that both the boundary table and top node are not present.\n\nNo input parameters are required. The method does not return any value but raises `AssertionError` if any of the invariants are violated, providing a message with details regarding the inconsistency.\n\nAttributes used:\n- `self.all_intervals`: A set of all intervals in the tree.\n- `self.top_node`: The root node of the interval tree, which contains a method to verify the node structure.\n- `self.boundary_table`: A sorted dictionary that maintains boundaries of intervals for efficient queries.\n\nThis method is meant primarily for debugging purposes.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.remove\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def remove(self, interval):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves an interval from the IntervalTree if it exists. \n\nArgs:\n    interval (Interval): The Interval object to be removed from the tree. \n\nRaises:\n    ValueError: If the specified interval is not present in the tree.\n\nThis method updates the tree structure by calling the `remove` method on the `top_node`, which handles the internal tree structure modifications. It also updates `all_intervals`, a set that maintains all the intervals currently in the tree, and calls `_remove_boundaries(interval)` to update the boundary table accordingly, ensuring the internal state remains consistent after the removal.\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.__iter__\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def __iter__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns an iterator that yields all intervals contained within the interval tree.\n\nThis method provides a standard way to iterate over the intervals stored in the `IntervalTree` instance. It leverages the `all_intervals` attribute, which is a set that maintains all the interval objects in the tree. Since `all_intervals` is a set, the order of the intervals may not be guaranteed, but the iteration will cover all unique intervals present in the tree.\n\nCompletes in O(1) time as it directly accesses the underlying data structure.\n\n:rtype: collections.Iterator[Interval]\n\"\"\"\n```\n\n- CLASS METHOD: IntervalTree.addi\n  - CLASS SIGNATURE: class IntervalTree(MutableSet):\n  - SIGNATURE: def addi(self, begin, end, data=None):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds an interval to the tree using the specified start and end points, along with optional data. This method constructs an `Interval` object using the provided `begin`, `end`, and `data` parameters, and then invokes the `add` method to insert it into the `IntervalTree`.\n\nParameters:\n- `begin` (numeric): The starting boundary of the interval.\n- `end` (numeric): The ending boundary of the interval.\n- `data` (optional): Optional data associated with the interval.\n\nReturns:\n- None: The method updates the internal structure of the `IntervalTree` by adding the new interval if it doesn't already exist.\n\nComplexity:\n- Completes in O(log n) time, where n is the number of intervals currently in the tree.\n\nThis method interacts with the `add` method, which checks for duplicates and inserts intervals into the tree structure. It utilizes the `Interval` class defined elsewhere in the module.\n\"\"\"\n```\n\n## FILE 3: intervaltree/interval.py\n\n- CLASS METHOD: Interval.__hash__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __hash__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculates the hash value for the Interval instance based on its `begin` and `end` attributes. This method allows Interval instances to be used as keys in hash tables and sets. The hash is computed using the built-in `hash` function on a tuple containing `self.begin` and `self.end`, ensuring that intervals with the same start and end points produce identical hash values.\n\n:return: A hash value derived from the `begin` and `end` attributes.\n:rtype: Number\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__eq__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines equality between two Interval instances. This method compares if both the `begin` and `end` values, as well as the `data` field, are equal between the two Interval objects.\n\n:param other: An instance of Interval to compare against.\n:return: True if both intervals have the same beginning, end points, and data; otherwise, False.\n:rtype: bool\n\nThis method leverages the attributes `begin`, `end`, and `data` which are defined in the Interval class using the `namedtuple` structure. It ensures that all relevant properties are considered when checking for equality.\n\"\"\"\n```\n\n- CLASS METHOD: Interval.is_null\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def is_null(self):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the current Interval instance represents a null interval, where a null interval is defined as an interval with its end point less than or equal to its beginning point.\n\n:return: True if the interval is null (i.e., end <= begin), otherwise False.\n:rtype: bool\n\nThis method interacts with the Interval's attributes `begin` and `end`, which are set during initialization of the Interval instance. It is used to validate or compare intervals throughout other methods in this class.\n\"\"\"\n```\n\n- CLASS METHOD: Interval.__new__\n  - CLASS SIGNATURE: class Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n  - SIGNATURE: def __new__(cls, begin, end, data=None):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new instance of the Interval class.\n\nThis method constructs an Interval object, which represents a mutable range defined by a beginning and an end point, optionally including associated data. It ensures that the Interval can be initialized with the specified attributes while adhering to the constraints of the parent class, `namedtuple`.\n\nParameters:\n- begin (numeric): The starting point of the interval.\n- end (numeric): The ending point of the interval.\n- data (optional): An optional attribute to store additional information associated with the interval.\n\nReturns:\n- Interval: An instance of the Interval class initialized with the specified begin, end, and data attributes.\n\nThis method relies on the `namedtuple` feature from the `collections` module to manage the interval\u2019s fields efficiently.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "intervaltree/node.py": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic: internal tree nodes.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom operator import attrgetter\nfrom math import floor, log\n\ndef l2(num):\n    \"\"\"\n    log base 2\n    :rtype real\n    \"\"\"\n    return log(num, 2)\n\nclass Node(object):\n    __slots__ = ('x_center', 's_center', 'left_node', 'right_node', 'depth', 'balance')\n\n    @classmethod\n    def from_interval(cls, interval):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        center = interval.begin\n        return Node(center, [interval])\n\n    @classmethod\n    def from_sorted_intervals(cls, intervals):\n        \"\"\"\n        :rtype : Node\n        \"\"\"\n        if not intervals:\n            return None\n        node = Node()\n        node = node.init_from_sorted(intervals)\n        return node\n\n    def init_from_sorted(self, intervals):\n        center_iv = intervals[len(intervals) // 2]\n        self.x_center = center_iv.begin\n        self.s_center = set()\n        s_left = []\n        s_right = []\n        for k in intervals:\n            if k.end <= self.x_center:\n                s_left.append(k)\n            elif k.begin > self.x_center:\n                s_right.append(k)\n            else:\n                self.s_center.add(k)\n        self.left_node = Node.from_sorted_intervals(s_left)\n        self.right_node = Node.from_sorted_intervals(s_right)\n        return self.rotate()\n\n    def center_hit(self, interval):\n        \"\"\"Returns whether interval overlaps self.x_center.\"\"\"\n        return interval.contains_point(self.x_center)\n\n    def hit_branch(self, interval):\n        \"\"\"\n        Assuming not center_hit(interval), return which branch\n        (left=0, right=1) interval is in.\n        \"\"\"\n        return interval.begin > self.x_center\n\n    def refresh_balance(self):\n        \"\"\"\n        Recalculate self.balance and self.depth based on child node values.\n        \"\"\"\n        left_depth = self.left_node.depth if self.left_node else 0\n        right_depth = self.right_node.depth if self.right_node else 0\n        self.depth = 1 + max(left_depth, right_depth)\n        self.balance = right_depth - left_depth\n\n    def compute_depth(self):\n        \"\"\"\n        Recursively computes true depth of the subtree. Should only\n        be needed for debugging. Unless something is wrong, the\n        depth field should reflect the correct depth of the subtree.\n        \"\"\"\n        left_depth = self.left_node.compute_depth() if self.left_node else 0\n        right_depth = self.right_node.compute_depth() if self.right_node else 0\n        return 1 + max(left_depth, right_depth)\n\n    def rotate(self):\n        \"\"\"\n        Does rotating, if necessary, to balance this node, and\n        returns the new top node.\n        \"\"\"\n        self.refresh_balance()\n        if abs(self.balance) < 2:\n            return self\n        my_heavy = self.balance > 0\n        child_heavy = self[my_heavy].balance > 0\n        if my_heavy == child_heavy or self[my_heavy].balance == 0:\n            return self.srotate()\n        else:\n            return self.drotate()\n\n    def srotate(self):\n        \"\"\"Single rotation. Assumes that balance is +-2.\"\"\"\n        heavy = self.balance > 0\n        light = not heavy\n        save = self[heavy]\n        self[heavy] = save[light]\n        save[light] = self.rotate()\n        promotees = [iv for iv in save[light].s_center if save.center_hit(iv)]\n        if promotees:\n            for iv in promotees:\n                save[light] = save[light].remove(iv)\n            save.s_center.update(promotees)\n        save.refresh_balance()\n        return save\n\n    def drotate(self):\n        my_heavy = self.balance > 0\n        self[my_heavy] = self[my_heavy].srotate()\n        self.refresh_balance()\n        result = self.srotate()\n        return result\n\n    def add(self, interval):\n        \"\"\"\n        Returns self after adding the interval and balancing.\n        \"\"\"\n        if self.center_hit(interval):\n            self.s_center.add(interval)\n            return self\n        else:\n            direction = self.hit_branch(interval)\n            if not self[direction]:\n                self[direction] = Node.from_interval(interval)\n                self.refresh_balance()\n                return self\n            else:\n                self[direction] = self[direction].add(interval)\n                return self.rotate()\n\n    def remove(self, interval):\n        \"\"\"\n        Returns self after removing the interval and balancing.\n\n        If interval is not present, raise ValueError.\n        \"\"\"\n        done = []\n        return self.remove_interval_helper(interval, done, should_raise_error=True)\n\n    def discard(self, interval):\n        \"\"\"\n        Returns self after removing interval and balancing.\n\n        If interval is not present, do nothing.\n        \"\"\"\n        done = []\n        return self.remove_interval_helper(interval, done, should_raise_error=False)\n\n    def remove_interval_helper(self, interval, done, should_raise_error):\n        \"\"\"\n        Returns self after removing interval and balancing.\n        If interval doesn't exist, raise ValueError.\n\n        This method may set done to [1] to tell all callers that\n        rebalancing has completed.\n\n        See Eternally Confuzzled's jsw_remove_r function (lines 1-32)\n        in his AVL tree article for reference.\n        \"\"\"\n        if self.center_hit(interval):\n            if not should_raise_error and interval not in self.s_center:\n                done.append(1)\n                return self\n            try:\n                self.s_center.remove(interval)\n            except:\n                self.print_structure()\n                raise KeyError(interval)\n            if self.s_center:\n                done.append(1)\n                return self\n            return self.prune()\n        else:\n            direction = self.hit_branch(interval)\n            if not self[direction]:\n                if should_raise_error:\n                    raise ValueError\n                done.append(1)\n                return self\n            self[direction] = self[direction].remove_interval_helper(interval, done, should_raise_error)\n            if not done:\n                return self.rotate()\n            return self\n\n    def search_overlap(self, point_list):\n        \"\"\"\n        Returns all intervals that overlap the point_list.\n        \"\"\"\n        result = set()\n        for j in point_list:\n            self.search_point(j, result)\n        return result\n\n    def search_point(self, point, result):\n        \"\"\"\n        Returns all intervals that contain point.\n        \"\"\"\n        for k in self.s_center:\n            if k.begin <= point < k.end:\n                result.add(k)\n        if point < self.x_center and self[0]:\n            return self[0].search_point(point, result)\n        elif point > self.x_center and self[1]:\n            return self[1].search_point(point, result)\n        return result\n\n    def prune(self):\n        \"\"\"\n        On a subtree where the root node's s_center is empty,\n        return a new subtree with no empty s_centers.\n        \"\"\"\n        if not self[0] or not self[1]:\n            direction = not self[0]\n            result = self[direction]\n            return result\n        else:\n            heir, self[0] = self[0].pop_greatest_child()\n            heir[0], heir[1] = (self[0], self[1])\n            heir.refresh_balance()\n            heir = heir.rotate()\n            return heir\n\n    def pop_greatest_child(self):\n        \"\"\"\n        Used when pruning a node with both a left and a right branch.\n        Returns (greatest_child, node), where:\n          * greatest_child is a new node to replace the removed node.\n          * node is the subtree after:\n              - removing the greatest child\n              - balancing\n              - moving overlapping nodes into greatest_child\n\n        Assumes that self.s_center is not empty.\n\n        See Eternally Confuzzled's jsw_remove_r function (lines 34-54)\n        in his AVL tree article for reference.\n        \"\"\"\n        if not self.right_node:\n            ivs = sorted(self.s_center, key=attrgetter('end', 'begin'))\n            max_iv = ivs.pop()\n            new_x_center = self.x_center\n            while ivs:\n                next_max_iv = ivs.pop()\n                if next_max_iv.end == max_iv.end:\n                    continue\n                new_x_center = max(new_x_center, next_max_iv.end)\n\n            def get_new_s_center():\n                for iv in self.s_center:\n                    if iv.contains_point(new_x_center):\n                        yield iv\n            child = Node(new_x_center, get_new_s_center())\n            self.s_center -= child.s_center\n            if self.s_center:\n                return (child, self)\n            else:\n                return (child, self[0])\n        else:\n            greatest_child, self[1] = self[1].pop_greatest_child()\n            for iv in set(self.s_center):\n                if iv.contains_point(greatest_child.x_center):\n                    self.s_center.remove(iv)\n                    greatest_child.add(iv)\n            if self.s_center:\n                self.refresh_balance()\n                new_self = self.rotate()\n                return (greatest_child, new_self)\n            else:\n                new_self = self.prune()\n                return (greatest_child, new_self)\n\n    def contains_point(self, p):\n        \"\"\"\n        Returns whether this node or a child overlaps p.\n        \"\"\"\n        for iv in self.s_center:\n            if iv.contains_point(p):\n                return True\n        branch = self[p > self.x_center]\n        return branch and branch.contains_point(p)\n\n    def all_children_helper(self, result):\n        result.update(self.s_center)\n        if self[0]:\n            self[0].all_children_helper(result)\n        if self[1]:\n            self[1].all_children_helper(result)\n        return result\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns the left child if input is equivalent to False, or\n        the right side otherwise.\n        \"\"\"\n        if index:\n            return self.right_node\n        else:\n            return self.left_node\n\n    def __setitem__(self, key, value):\n        \"\"\"Sets the left (0) or right (1) child.\"\"\"\n        if key:\n            self.right_node = value\n        else:\n            self.left_node = value\n\n    def __str__(self):\n        \"\"\"\n        Shows info about this node.\n\n        Since Nodes are internal data structures not revealed to the\n        user, I'm not bothering to make this copy-paste-executable as a\n        constructor.\n        \"\"\"\n        return 'Node<{0}, depth={1}, balance={2}>'.format(self.x_center, self.depth, self.balance)\n\n    def count_nodes(self):\n        \"\"\"\n        Count the number of Nodes in this subtree.\n        :rtype: int\n        \"\"\"\n        count = 1\n        if self.left_node:\n            count += self.left_node.count_nodes()\n        if self.right_node:\n            count += self.right_node.count_nodes()\n        return count\n\n    def depth_score(self, n, m):\n        \"\"\"\n        Calculates flaws in balancing the tree.\n        :param n: size of tree\n        :param m: number of Nodes in tree\n        :rtype: real\n        \"\"\"\n        if n == 0:\n            return 0.0\n        dopt = 1 + int(floor(l2(m)))\n        f = 1 / float(1 + n - dopt)\n        return f * self.depth_score_helper(1, dopt)\n\n    def depth_score_helper(self, d, dopt):\n        \"\"\"\n        Gets a weighted count of the number of Intervals deeper than dopt.\n        :param d: current depth, starting from 0\n        :param dopt: optimal maximum depth of a leaf Node\n        :rtype: real\n        \"\"\"\n        di = d - dopt\n        if di > 0:\n            count = di * len(self.s_center)\n        else:\n            count = 0\n        if self.right_node:\n            count += self.right_node.depth_score_helper(d + 1, dopt)\n        if self.left_node:\n            count += self.left_node.depth_score_helper(d + 1, dopt)\n        return count",
    "intervaltree/intervaltree.py": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nCore logic.\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications Copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom .interval import Interval\nfrom .node import Node\nfrom numbers import Number\nfrom sortedcontainers import SortedDict\nfrom copy import copy\nfrom warnings import warn\ntry:\n    from collections.abc import MutableSet\nexcept ImportError:\n    from collections import MutableSet\ntry:\n    xrange\nexcept NameError:\n    xrange = range\n\nclass IntervalTree(MutableSet):\n    \"\"\"\n    A binary lookup tree of intervals.\n    The intervals contained in the tree are represented using ``Interval(a, b, data)`` objects.\n    Each such object represents a half-open interval ``[a, b)`` with optional data.\n\n    Examples:\n    ---------\n\n    Initialize a blank tree::\n\n        >>> tree = IntervalTree()\n        >>> tree\n        IntervalTree()\n\n    Initialize a tree from an iterable set of Intervals in O(n * log n)::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-20.0, -10.0)])\n        >>> tree\n        IntervalTree([Interval(-20.0, -10.0), Interval(-10, 10)])\n        >>> len(tree)\n        2\n\n    Note that this is a set, i.e. repeated intervals are ignored. However,\n    Intervals with different data fields are regarded as different::\n\n        >>> tree = IntervalTree([Interval(-10, 10), Interval(-10, 10), Interval(-10, 10, \"x\")])\n        >>> tree\n        IntervalTree([Interval(-10, 10), Interval(-10, 10, 'x')])\n        >>> len(tree)\n        2\n\n    Insertions::\n        >>> tree = IntervalTree()\n        >>> tree[0:1] = \"data\"\n        >>> tree.add(Interval(10, 20))\n        >>> tree.addi(19.9, 20)\n        >>> tree\n        IntervalTree([Interval(0, 1, 'data'), Interval(10, 20), Interval(19.9, 20)])\n        >>> tree.update([Interval(19.9, 20.1), Interval(20.1, 30)])\n        >>> len(tree)\n        5\n\n        Inserting the same Interval twice does nothing::\n            >>> tree = IntervalTree()\n            >>> tree[-10:20] = \"arbitrary data\"\n            >>> tree[-10:20] = None  # Note that this is also an insertion\n            >>> tree\n            IntervalTree([Interval(-10, 20), Interval(-10, 20, 'arbitrary data')])\n            >>> tree[-10:20] = None  # This won't change anything\n            >>> tree[-10:20] = \"arbitrary data\" # Neither will this\n            >>> len(tree)\n            2\n\n    Deletions::\n        >>> tree = IntervalTree(Interval(b, e) for b, e in [(-10, 10), (-20, -10), (10, 20)])\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(-10, 10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n        >>> tree.remove(Interval(-10, 10))\n        Traceback (most recent call last):\n        ...\n        ValueError\n        >>> tree.discard(Interval(-10, 10))  # Same as remove, but no exception on failure\n        >>> tree\n        IntervalTree([Interval(-20, -10), Interval(10, 20)])\n\n    Delete intervals, overlapping a given point::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.1)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1)])\n\n    Delete intervals, overlapping an interval::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(0, 0.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.7, 1.8)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.6)  # Null interval does nothing\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_overlap(1.6, 1.5)  # Ditto\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n\n    Delete intervals, enveloped in the range::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.0, 1.5)\n        >>> tree\n        IntervalTree([Interval(-1.1, 1.1), Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(-1.1, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.5)\n        >>> tree\n        IntervalTree([Interval(0.5, 1.7)])\n        >>> tree.remove_envelop(0.5, 1.7)\n        >>> tree\n        IntervalTree()\n\n    Point queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[-1.1]   == set([Interval(-1.1, 1.1)])\n        >>> assert tree.at(1.1) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])   # Same as tree[1.1]\n        >>> assert tree.at(1.5) == set([Interval(0.5, 1.7)])                        # Same as tree[1.5]\n\n    Interval overlap queries\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.overlap(1.7, 1.8) == set()\n        >>> assert tree.overlap(1.5, 1.8) == set([Interval(0.5, 1.7)])\n        >>> assert tree[1.5:1.8] == set([Interval(0.5, 1.7)])                       # same as previous\n        >>> assert tree.overlap(1.1, 1.8) == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree[1.1:1.8] == set([Interval(-0.5, 1.5), Interval(0.5, 1.7)])  # same as previous\n\n    Interval envelop queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> assert tree.envelop(-0.5, 0.5) == set()\n        >>> assert tree.envelop(-0.5, 1.5) == set([Interval(-0.5, 1.5)])\n\n    Membership queries::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> Interval(-0.5, 0.5) in tree\n        False\n        >>> Interval(-1.1, 1.1) in tree\n        True\n        >>> Interval(-1.1, 1.1, \"x\") in tree\n        False\n        >>> tree.overlaps(-1.1)\n        True\n        >>> tree.overlaps(1.7)\n        False\n        >>> tree.overlaps(1.7, 1.8)\n        False\n        >>> tree.overlaps(-1.2, -1.1)\n        False\n        >>> tree.overlaps(-1.2, -1.0)\n        True\n\n    Sizing::\n\n        >>> tree = IntervalTree([Interval(-1.1, 1.1), Interval(-0.5, 1.5), Interval(0.5, 1.7)])\n        >>> len(tree)\n        3\n        >>> tree.is_empty()\n        False\n        >>> IntervalTree().is_empty()\n        True\n        >>> not tree\n        False\n        >>> not IntervalTree()\n        True\n        >>> print(tree.begin())    # using print() because of floats in Python 2.6\n        -1.1\n        >>> print(tree.end())      # ditto\n        1.7\n\n    Iteration::\n\n        >>> tree = IntervalTree([Interval(-11, 11), Interval(-5, 15), Interval(5, 17)])\n        >>> [iv.begin for iv in sorted(tree)]\n        [-11, -5, 5]\n        >>> assert tree.items() == set([Interval(-5, 15), Interval(-11, 11), Interval(5, 17)])\n\n    Copy- and typecasting, pickling::\n\n        >>> tree0 = IntervalTree([Interval(0, 1, \"x\"), Interval(1, 2, [\"x\"])])\n        >>> tree1 = IntervalTree(tree0)  # Shares Interval objects\n        >>> tree2 = tree0.copy()         # Shallow copy (same as above, as Intervals are singletons)\n        >>> import pickle\n        >>> tree3 = pickle.loads(pickle.dumps(tree0))  # Deep copy\n        >>> list(tree0[1])[0].data[0] = \"y\"  # affects shallow copies, but not deep copies\n        >>> tree0\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree1\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree2\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['y'])])\n        >>> tree3\n        IntervalTree([Interval(0, 1, 'x'), Interval(1, 2, ['x'])])\n\n    Equality testing::\n\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1)])\n        True\n        >>> IntervalTree([Interval(0, 1)]) == IntervalTree([Interval(0, 1, \"x\")])\n        False\n    \"\"\"\n\n    def copy(self):\n        \"\"\"\n        Construct a new IntervalTree using shallow copies of the\n        intervals in the source tree.\n\n        Completes in O(n*log n) time.\n        :rtype: IntervalTree\n        \"\"\"\n        return IntervalTree((iv.copy() for iv in self))\n\n    def _add_boundaries(self, interval):\n        \"\"\"\n        Records the boundaries of the interval in the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if begin in self.boundary_table:\n            self.boundary_table[begin] += 1\n        else:\n            self.boundary_table[begin] = 1\n        if end in self.boundary_table:\n            self.boundary_table[end] += 1\n        else:\n            self.boundary_table[end] = 1\n\n    def _remove_boundaries(self, interval):\n        \"\"\"\n        Removes the boundaries of the interval from the boundary table.\n        \"\"\"\n        begin = interval.begin\n        end = interval.end\n        if self.boundary_table[begin] == 1:\n            del self.boundary_table[begin]\n        else:\n            self.boundary_table[begin] -= 1\n        if self.boundary_table[end] == 1:\n            del self.boundary_table[end]\n        else:\n            self.boundary_table[end] -= 1\n    append = add\n    appendi = addi\n\n    def update(self, intervals):\n        \"\"\"\n        Given an iterable of intervals, add them to the tree.\n\n        Completes in O(m*log(n+m), where m = number of intervals to\n        add.\n        \"\"\"\n        for iv in intervals:\n            self.add(iv)\n\n    def discard(self, interval):\n        \"\"\"\n        Removes an interval from the tree, if present. If not, does\n        nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        if interval not in self:\n            return\n        self.all_intervals.discard(interval)\n        self.top_node = self.top_node.discard(interval)\n        self._remove_boundaries(interval)\n\n    def discardi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for discard(Interval(begin, end, data)).\n\n        Completes in O(log n) time.\n        \"\"\"\n        return self.discard(Interval(begin, end, data))\n\n    def difference(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals in self but not\n        in other.\n        \"\"\"\n        ivs = set()\n        for iv in self:\n            if iv not in other:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def difference_update(self, other):\n        \"\"\"\n        Removes all intervals in other from self.\n        \"\"\"\n        for iv in other:\n            self.discard(iv)\n\n    def union(self, other):\n        \"\"\"\n        Returns a new tree, comprising all intervals from self\n        and other.\n        \"\"\"\n        return IntervalTree(set(self).union(other))\n\n    def intersection(self, other):\n        \"\"\"\n        Returns a new tree of all intervals common to both self and\n        other.\n        \"\"\"\n        ivs = set()\n        shorter, longer = sorted([self, other], key=len)\n        for iv in shorter:\n            if iv in longer:\n                ivs.add(iv)\n        return IntervalTree(ivs)\n\n    def intersection_update(self, other):\n        \"\"\"\n        Removes intervals from self unless they also exist in other.\n        \"\"\"\n        ivs = list(self)\n        for iv in ivs:\n            if iv not in other:\n                self.remove(iv)\n\n    def symmetric_difference(self, other):\n        \"\"\"\n        Return a tree with elements only in self or other but not\n        both.\n        \"\"\"\n        if not isinstance(other, set):\n            other = set(other)\n        me = set(self)\n        ivs = me.difference(other).union(other.difference(me))\n        return IntervalTree(ivs)\n\n    def symmetric_difference_update(self, other):\n        \"\"\"\n        Throws out all intervals except those only in self or other,\n        not both.\n        \"\"\"\n        other = set(other)\n        ivs = list(self)\n        for iv in ivs:\n            if iv in other:\n                self.remove(iv)\n                other.remove(iv)\n        self.update(other)\n\n    def remove_overlap(self, begin, end=None):\n        \"\"\"\n        Removes all intervals overlapping the given point or range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range (this is 1 for a point)\n        \"\"\"\n        hitlist = self.at(begin) if end is None else self.overlap(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def remove_envelop(self, begin, end):\n        \"\"\"\n        Removes all intervals completely enveloped in the given range.\n\n        Completes in O((r+m)*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * r = size of the search range\n        \"\"\"\n        hitlist = self.envelop(begin, end)\n        for iv in hitlist:\n            self.remove(iv)\n\n    def chop(self, begin, end, datafunc=None):\n        \"\"\"\n        Like remove_envelop(), but trims back Intervals hanging into\n        the chopped area so that nothing overlaps.\n        \"\"\"\n        insertions = set()\n        begin_hits = [iv for iv in self.at(begin) if iv.begin < begin]\n        end_hits = [iv for iv in self.at(end) if iv.end > end]\n        if datafunc:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, datafunc(iv, True)))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, datafunc(iv, False)))\n        else:\n            for iv in begin_hits:\n                insertions.add(Interval(iv.begin, begin, iv.data))\n            for iv in end_hits:\n                insertions.add(Interval(end, iv.end, iv.data))\n        self.remove_envelop(begin, end)\n        self.difference_update(begin_hits)\n        self.difference_update(end_hits)\n        self.update(insertions)\n\n    def slice(self, point, datafunc=None):\n        \"\"\"\n        Split Intervals that overlap point into two new Intervals. if\n        specified, uses datafunc(interval, islower=True/False) to\n        set the data field of the new Intervals.\n        :param point: where to slice\n        :param datafunc(interval, isupper): callable returning a new\n        value for the interval's data field\n        \"\"\"\n        hitlist = set((iv for iv in self.at(point) if iv.begin < point))\n        insertions = set()\n        if datafunc:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, datafunc(iv, True)))\n                insertions.add(Interval(point, iv.end, datafunc(iv, False)))\n        else:\n            for iv in hitlist:\n                insertions.add(Interval(iv.begin, point, iv.data))\n                insertions.add(Interval(point, iv.end, iv.data))\n        self.difference_update(hitlist)\n        self.update(insertions)\n\n    def clear(self):\n        \"\"\"\n        Empties the tree.\n\n        Completes in O(1) tine.\n        \"\"\"\n        self.__init__()\n\n    def find_nested(self):\n        \"\"\"\n        Returns a dictionary mapping parent intervals to sets of\n        intervals overlapped by and contained in the parent.\n\n        Completes in O(n^2) time.\n        :rtype: dict of [Interval, set of Interval]\n        \"\"\"\n        result = {}\n\n        def add_if_nested():\n            if parent.contains_interval(child):\n                if parent not in result:\n                    result[parent] = set()\n                result[parent].add(child)\n        long_ivs = sorted(self.all_intervals, key=Interval.length, reverse=True)\n        for i, parent in enumerate(long_ivs):\n            for child in long_ivs[i + 1:]:\n                add_if_nested()\n        return result\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        point or range.\n\n        Completes in O(r*log n) time, where r is the size of the\n        search range.\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return self.overlaps_range(begin, end)\n        elif isinstance(begin, Number):\n            return self.overlaps_point(begin)\n        else:\n            return self.overlaps_range(begin.begin, begin.end)\n\n    def overlaps_point(self, p):\n        \"\"\"\n        Returns whether some interval in the tree overlaps p.\n\n        Completes in O(log n) time.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        return bool(self.top_node.contains_point(p))\n\n    def overlaps_range(self, begin, end):\n        \"\"\"\n        Returns whether some interval in the tree overlaps the given\n        range. Returns False if given a null interval over which to\n        test.\n\n        Completes in O(r*log n) time, where r is the range length and n\n        is the table size.\n        :rtype: bool\n        \"\"\"\n        if self.is_empty():\n            return False\n        elif begin >= end:\n            return False\n        elif self.overlaps_point(begin):\n            return True\n        return any((self.overlaps_point(bound) for bound in self.boundary_table if begin < bound < end))\n\n    def split_overlaps(self):\n        \"\"\"\n        Finds all intervals with overlapping ranges and splits them\n        along the range boundaries.\n\n        Completes in worst-case O(n^2*log n) time (many interval\n        boundaries are inside many intervals), best-case O(n*log n)\n        time (small number of overlaps << n per interval).\n        \"\"\"\n        if not self:\n            return\n        if len(self.boundary_table) == 2:\n            return\n        bounds = sorted(self.boundary_table)\n        new_ivs = set()\n        for lbound, ubound in zip(bounds[:-1], bounds[1:]):\n            for iv in self[lbound]:\n                new_ivs.add(Interval(lbound, ubound, iv.data))\n        self.__init__(new_ivs)\n\n    def merge_overlaps(self, data_reducer=None, data_initializer=None, strict=True):\n        \"\"\"\n        Finds all intervals with overlapping ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initializer created with copy.copy(data_initializer).\n\n        If strict is True (default), intervals are only merged if\n        their ranges actually overlap; adjacent, touching intervals\n        will not be merged. If strict is False, intervals are merged\n        even if they are only end-to-end adjacent.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                if higher.begin < lower.end or (not strict and higher.begin == lower.end):\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def merge_equals(self, data_reducer=None, data_initializer=None):\n        \"\"\"\n        Finds all intervals with equal ranges and merges them\n        into a single interval. If provided, uses data_reducer and\n        data_initializer with similar semantics to Python's built-in\n        reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                if higher.range_matches(lower):\n                    upper_bound = max(lower.end, higher.end)\n                    if data_reducer is not None:\n                        current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                    else:\n                        current_reduced[0] = None\n                    merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def merge_neighbors(self, data_reducer=None, data_initializer=None, distance=1, strict=True):\n        \"\"\"\n        Finds all adjacent intervals with range terminals less than or equal to\n        the given distance and merges them into a single interval. If provided,\n        uses data_reducer and data_initializer with similar semantics to\n        Python's built-in reduce(reducer_func[, initializer]), as follows:\n\n        If data_reducer is set to a function, combines the data\n        fields of the Intervals with\n            current_reduced_data = data_reducer(current_reduced_data, new_data)\n        If data_reducer is None, the merged Interval's data\n        field will be set to None, ignoring all the data fields\n        of the merged Intervals.\n\n        On encountering the first Interval to merge, if\n        data_initializer is None (default), uses the first\n        Interval's data field as the first value for\n        current_reduced_data. If data_initializer is not None,\n        current_reduced_data is set to a shallow copy of\n        data_initiazer created with\n            copy.copy(data_initializer).\n\n        If strict is True (default), only discrete intervals are merged if\n        their ranges are within the given distance; overlapping intervals\n        will not be merged. If strict is False, both neighbors and overlapping\n        intervals are merged.\n\n        Completes in O(n*logn) time.\n        \"\"\"\n        if not self:\n            return\n        sorted_intervals = sorted(self.all_intervals)\n        merged = []\n        current_reduced = [None]\n        higher = None\n\n        def new_series():\n            if data_initializer is None:\n                current_reduced[0] = higher.data\n                merged.append(higher)\n                return\n            else:\n                current_reduced[0] = copy(data_initializer)\n                current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                merged.append(Interval(higher.begin, higher.end, current_reduced[0]))\n        for higher in sorted_intervals:\n            if merged:\n                lower = merged[-1]\n                margin = higher.begin - lower.end\n                if margin <= distance:\n                    if strict and margin < 0:\n                        new_series()\n                        continue\n                    else:\n                        upper_bound = max(lower.end, higher.end)\n                        if data_reducer is not None:\n                            current_reduced[0] = data_reducer(current_reduced[0], higher.data)\n                        else:\n                            current_reduced[0] = None\n                        merged[-1] = Interval(lower.begin, upper_bound, current_reduced[0])\n                else:\n                    new_series()\n            else:\n                new_series()\n        self.__init__(merged)\n\n    def items(self):\n        \"\"\"\n        Constructs and returns a set of all intervals in the tree.\n\n        Completes in O(n) time.\n        :rtype: set of Interval\n        \"\"\"\n        return set(self.all_intervals)\n\n    def is_empty(self):\n        \"\"\"\n        Returns whether the tree is empty.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return 0 == len(self)\n\n    def at(self, p):\n        \"\"\"\n        Returns the set of all intervals that contain p.\n\n        Completes in O(m + log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        return root.search_point(p, set())\n\n    def envelop(self, begin, end=None):\n        \"\"\"\n        Returns the set of all intervals fully contained in the range\n        [begin, end).\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.envelop(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)\n        result.update(root.search_overlap((boundary_table.keys()[index] for index in xrange(bound_begin, bound_end))))\n        result = set((iv for iv in result if iv.begin >= begin and iv.end <= end))\n        return result\n\n    def overlap(self, begin, end=None):\n        \"\"\"\n        Returns a set of all intervals overlapping the given range.\n\n        Completes in O(m + k*log n) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range\n        :rtype: set of Interval\n        \"\"\"\n        root = self.top_node\n        if not root:\n            return set()\n        if end is None:\n            iv = begin\n            return self.overlap(iv.begin, iv.end)\n        elif begin >= end:\n            return set()\n        result = root.search_point(begin, set())\n        boundary_table = self.boundary_table\n        bound_begin = boundary_table.bisect_left(begin)\n        bound_end = boundary_table.bisect_left(end)\n        result.update(root.search_overlap((boundary_table.keys()[index] for index in xrange(bound_begin, bound_end))))\n        return result\n\n    def begin(self):\n        \"\"\"\n        Returns the lower bound of the first interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[0]\n\n    def end(self):\n        \"\"\"\n        Returns the upper bound of the last interval in the tree.\n\n        Completes in O(1) time.\n        \"\"\"\n        if not self.boundary_table:\n            return 0\n        return self.boundary_table.keys()[-1]\n\n    def range(self):\n        \"\"\"\n        Returns a minimum-spanning Interval that encloses all the\n        members of this IntervalTree. If the tree is empty, returns\n        null Interval.\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin(), self.end())\n\n    def span(self):\n        \"\"\"\n        Returns the length of the minimum-spanning Interval that\n        encloses all the members of this IntervalTree. If the tree\n        is empty, return 0.\n        \"\"\"\n        if not self:\n            return 0\n        return self.end() - self.begin()\n\n    def print_structure(self, tostring=False):\n        \"\"\"\n        ## FOR DEBUGGING ONLY ##\n        Pretty-prints the structure of the tree.\n        If tostring is true, prints nothing and returns a string.\n        :rtype: None or str\n        \"\"\"\n        if self.top_node:\n            return self.top_node.print_structure(tostring=tostring)\n        else:\n            result = '<empty IntervalTree>'\n            if not tostring:\n                print(result)\n            else:\n                return result\n\n    def score(self, full_report=False):\n        \"\"\"\n        Returns a number between 0 and 1, indicating how suboptimal the tree\n        is. The lower, the better. Roughly, this number represents the\n        fraction of flawed Intervals in the tree.\n        :rtype: float\n        \"\"\"\n        if len(self) <= 2:\n            return 0.0\n        n = len(self)\n        m = self.top_node.count_nodes()\n\n        def s_center_score():\n            \"\"\"\n            Returns a normalized score, indicating roughly how many times\n            intervals share s_center with other intervals. Output is full-scale\n            from 0 to 1.\n            :rtype: float\n            \"\"\"\n            raw = n - m\n            maximum = n - 1\n            return raw / float(maximum)\n        report = {'depth': self.top_node.depth_score(n, m), 's_center': s_center_score()}\n        cumulative = max(report.values())\n        report['_cumulative'] = cumulative\n        if full_report:\n            return report\n        return cumulative\n\n    def __getitem__(self, index):\n        \"\"\"\n        Returns a set of all intervals overlapping the given index or\n        slice.\n\n        Completes in O(k * log(n) + m) time, where:\n          * n = size of the tree\n          * m = number of matches\n          * k = size of the search range (this is 1 for a point)\n        :rtype: set of Interval\n        \"\"\"\n        try:\n            start, stop = (index.start, index.stop)\n            if start is None:\n                start = self.begin()\n                if stop is None:\n                    return set(self)\n            if stop is None:\n                stop = self.end()\n            return self.overlap(start, stop)\n        except AttributeError:\n            return self.at(index)\n\n    def __setitem__(self, index, value):\n        \"\"\"\n        Adds a new interval to the tree. A shortcut for\n        add(Interval(index.start, index.stop, value)).\n\n        If an identical Interval object with equal range and data\n        already exists, does nothing.\n\n        Completes in O(log n) time.\n        \"\"\"\n        self.addi(index.start, index.stop, value)\n\n    def __delitem__(self, point):\n        \"\"\"\n        Delete all items overlapping point.\n        \"\"\"\n        self.remove_overlap(point)\n\n    def __contains__(self, item):\n        \"\"\"\n        Returns whether item exists as an Interval in the tree.\n        This method only returns True for exact matches; for\n        overlaps, see the overlaps() method.\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return item in self.all_intervals\n\n    def containsi(self, begin, end, data=None):\n        \"\"\"\n        Shortcut for (Interval(begin, end, data) in tree).\n\n        Completes in O(1) time.\n        :rtype: bool\n        \"\"\"\n        return Interval(begin, end, data) in self\n    iter = __iter__\n\n    def __len__(self):\n        \"\"\"\n        Returns how many intervals are in the tree.\n\n        Completes in O(1) time.\n        :rtype: int\n        \"\"\"\n        return len(self.all_intervals)\n\n    def __eq__(self, other):\n        \"\"\"\n        Whether two IntervalTrees are equal.\n\n        Completes in O(n) time if sizes are equal; O(1) time otherwise.\n        :rtype: bool\n        \"\"\"\n        return isinstance(other, IntervalTree) and self.all_intervals == other.all_intervals\n\n    def __repr__(self):\n        \"\"\"\n        :rtype: str\n        \"\"\"\n        ivs = sorted(self)\n        if not ivs:\n            return 'IntervalTree()'\n        else:\n            return 'IntervalTree({0})'.format(ivs)\n    __str__ = __repr__\n\n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :rtype: tuple\n        \"\"\"\n        return (IntervalTree, (sorted(self.all_intervals),))",
    "intervaltree/interval.py": "\"\"\"\nintervaltree: A mutable, self-balancing interval tree for Python 2 and 3.\nQueries may be by point, by range overlap, or by range envelopment.\n\nInterval class\n\nCopyright 2013-2018 Chaim Leib Halbert\nModifications copyright 2014 Konstantin Tretyakov\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\"\"\"\nfrom numbers import Number\nfrom collections import namedtuple\n\nclass Interval(namedtuple('IntervalBase', ['begin', 'end', 'data'])):\n    __slots__ = ()\n\n    def overlaps(self, begin, end=None):\n        \"\"\"\n        Whether the interval overlaps the given point, range or Interval.\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        if end is not None:\n            return begin < self.end and end > self.begin\n        try:\n            return self.overlaps(begin.begin, begin.end)\n        except:\n            return self.contains_point(begin)\n\n    def overlap_size(self, begin, end=None):\n        \"\"\"\n        Return the overlap size between two intervals or a point\n        :param begin: beginning point of the range, or the point, or an Interval\n        :param end: end point of the range. Optional if not testing ranges.\n        :return: Return the overlap size, None if not overlap is found\n        :rtype: depends on the given input (e.g., int will be returned for int interval and timedelta for\n        datetime intervals)\n        \"\"\"\n        overlaps = self.overlaps(begin, end)\n        if not overlaps:\n            return 0\n        if end is not None:\n            i0 = max(self.begin, begin)\n            i1 = min(self.end, end)\n            return i1 - i0\n        i0 = max(self.begin, begin.begin)\n        i1 = min(self.end, begin.end)\n        return i1 - i0\n\n    def contains_point(self, p):\n        \"\"\"\n        Whether the Interval contains p.\n        :param p: a point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= p < self.end\n\n    def range_matches(self, other):\n        \"\"\"\n        Whether the begins equal and the ends equal. Compare __eq__().\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin == other.begin and self.end == other.end\n\n    def contains_interval(self, other):\n        \"\"\"\n        Whether other is contained in this Interval.\n        :param other: Interval\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.begin <= other.begin and self.end >= other.end\n\n    def distance_to(self, other):\n        \"\"\"\n        Returns the size of the gap between intervals, or 0 \n        if they touch or overlap.\n        :param other: Interval or point\n        :return: distance\n        :rtype: Number\n        \"\"\"\n        if self.overlaps(other):\n            return 0\n        try:\n            if self.begin < other.begin:\n                return other.begin - self.end\n            else:\n                return self.begin - other.end\n        except:\n            if self.end <= other:\n                return other - self.end\n            else:\n                return self.begin - other\n\n    def length(self):\n        \"\"\"\n        The distance covered by this Interval.\n        :return: length\n        :type: Number\n        \"\"\"\n        if self.is_null():\n            return 0\n        return self.end - self.begin\n\n    def __cmp__(self, other):\n        \"\"\"\n        Tells whether other sorts before, after or equal to this\n        Interval.\n\n        Sorting is by begins, then by ends, then by data fields.\n\n        If data fields are not both sortable types, data fields are\n        compared alphabetically by type name.\n        :param other: Interval\n        :return: -1, 0, 1\n        :rtype: int\n        \"\"\"\n        s = self[0:2]\n        try:\n            o = other[0:2]\n        except:\n            o = (other,)\n        if s != o:\n            return -1 if s < o else 1\n        try:\n            if self.data == other.data:\n                return 0\n            return -1 if self.data < other.data else 1\n        except TypeError:\n            s = type(self.data).__name__\n            o = type(other.data).__name__\n            if s == o:\n                return 0\n            return -1 if s < o else 1\n\n    def __lt__(self, other):\n        \"\"\"\n        Less than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) < 0\n\n    def __gt__(self, other):\n        \"\"\"\n        Greater than operator. Parrots __cmp__()\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        return self.__cmp__(other) > 0\n\n    def _raise_if_null(self, other):\n        \"\"\"\n        :raises ValueError: if either self or other is a null Interval\n        \"\"\"\n        if self.is_null():\n            raise ValueError('Cannot compare null Intervals!')\n        if hasattr(other, 'is_null') and other.is_null():\n            raise ValueError('Cannot compare null Intervals!')\n\n    def lt(self, other):\n        \"\"\"\n        Strictly less than. Returns True if no part of this Interval\n        extends higher than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'begin', other)\n\n    def le(self, other):\n        \"\"\"\n        Less than or overlaps. Returns True if no part of this Interval\n        extends higher than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.end <= getattr(other, 'end', other)\n\n    def gt(self, other):\n        \"\"\"\n        Strictly greater than. Returns True if no part of this Interval\n        extends lower than or into other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        if hasattr(other, 'end'):\n            return self.begin >= other.end\n        else:\n            return self.begin > other\n\n    def ge(self, other):\n        \"\"\"\n        Greater than or overlaps. Returns True if no part of this Interval\n        extends lower than other.\n        :raises ValueError: if either self or other is a null Interval\n        :param other: Interval or point\n        :return: True or False\n        :rtype: bool\n        \"\"\"\n        self._raise_if_null(other)\n        return self.begin >= getattr(other, 'begin', other)\n\n    def _get_fields(self):\n        \"\"\"\n        Used by str, unicode, repr and __reduce__.\n\n        Returns only the fields necessary to reconstruct the Interval.\n        :return: reconstruction info\n        :rtype: tuple\n        \"\"\"\n        if self.data is not None:\n            return (self.begin, self.end, self.data)\n        else:\n            return (self.begin, self.end)\n\n    def __repr__(self):\n        \"\"\"\n        Executable string representation of this Interval.\n        :return: string representation\n        :rtype: str\n        \"\"\"\n        if isinstance(self.begin, Number):\n            s_begin = str(self.begin)\n            s_end = str(self.end)\n        else:\n            s_begin = repr(self.begin)\n            s_end = repr(self.end)\n        if self.data is None:\n            return 'Interval({0}, {1})'.format(s_begin, s_end)\n        else:\n            return 'Interval({0}, {1}, {2})'.format(s_begin, s_end, repr(self.data))\n    __str__ = __repr__\n\n    def copy(self):\n        \"\"\"\n        Shallow copy.\n        :return: copy of self\n        :rtype: Interval\n        \"\"\"\n        return Interval(self.begin, self.end, self.data)\n\n    def __reduce__(self):\n        \"\"\"\n        For pickle-ing.\n        :return: pickle data\n        :rtype: tuple\n        \"\"\"\n        return (Interval, self._get_fields())"
  }
}