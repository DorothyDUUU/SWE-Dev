{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_hpcomware",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_hpcomware.py",
  "test_code": "import unittest\nfrom ncclient.devices.hpcomware import *\nfrom ncclient.xml_ import *\n\n\nclass TestHpcomwareDevice(unittest.TestCase):\n\n    def setUp(self):\n        self.obj = HpcomwareDeviceHandler({'name': 'hpcomware'})\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.obj.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = {'nsmap': {'data': 'http://www.hp.com/netconf/data:1.0',\n                              'config': 'http://www.hp.com/netconf/config:1.0',\n                              None: 'urn:ietf:params:xml:ns:netconf:base:1.0'}}\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n\n    def test_add_additional_operations(self):\n        expected = dict()\n        expected['cli_display'] = DisplayCommand\n        expected['cli_config'] = ConfigCommand\n        expected['action'] = Action\n        expected['save'] = Save\n        expected['rollback'] = Rollback\n        self.assertDictEqual(expected, self.obj.add_additional_operations())\n",
  "GT_file_code": {
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/devices/hpcomware.py": "from ncclient.xml_ import BASE_NS_1_0\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.hpcomware.rpc import DisplayCommand, ConfigCommand, Action, Rollback, Save\n\nclass HpcomwareDeviceHandler(DefaultDeviceHandler):\n\n    def __init__(self, device_params):\n        super(HpcomwareDeviceHandler, self).__init__(device_params)\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        Base namespace needs a None key.\n\n        See 'nsmap' argument for lxml's Element().\n\n        \"\"\"\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return keyword arguments per request, which are applied to Element().\n\n        Mostly, this is a dictionary containing the \"nsmap\" key.\n\n        See 'nsmap' argument for lxml's Element().\n\n        \"\"\"\n        d = {\n                \"data\": \"http://www.hp.com/netconf/data:1.0\",\n                \"config\": \"http://www.hp.com/netconf/config:1.0\",\n            }\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def add_additional_operations(self):\n        addtl = {}\n        addtl['cli_display'] = DisplayCommand\n        addtl['cli_config'] = ConfigCommand\n        addtl['action'] = Action\n        addtl['rollback'] = Rollback\n        addtl['save'] = Save\n        return addtl\n",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n"
  },
  "GT_src_dict": {
    "ncclient/transport/errors.py": {},
    "ncclient/devices/hpcomware.py": {
      "HpcomwareDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initialize the HpcomwareDeviceHandler class, which is a specialized device handler for HP Comware devices. This constructor initializes the device handler with parameters specific to the device by invoking the constructor of the parent class, DefaultDeviceHandler.\n\nParameters:\n- device_params (dict): A dictionary of parameters required to configure the device connection, such as hostname, username, and password.\n\nThis method does not return any value, but it establishes the necessary setup for handling HP Comware devices by leveraging the existing functionality of the DefaultDeviceHandler. The interaction with the parent class is facilitated by calling its constructor with the provided device parameters.\"\"\"\n        super(HpcomwareDeviceHandler, self).__init__(device_params)",
        "docstring": "Initialize the HpcomwareDeviceHandler class, which is a specialized device handler for HP Comware devices. This constructor initializes the device handler with parameters specific to the device by invoking the constructor of the parent class, DefaultDeviceHandler.\n\nParameters:\n- device_params (dict): A dictionary of parameters required to configure the device connection, such as hostname, username, and password.\n\nThis method does not return any value, but it establishes the necessary setup for handling HP Comware devices by leveraging the existing functionality of the DefaultDeviceHandler. The interaction with the parent class is facilitated by calling its constructor with the provided device parameters.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class HpcomwareDeviceHandler(DefaultDeviceHandler):"
      },
      "HpcomwareDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary representing the base XML namespace for Netconf operations.\n\nThis method is part of the `HpcomwareDeviceHandler` class, which extends `DefaultDeviceHandler`. It provides the necessary base XML namespace with a `None` key, required for constructing XML elements using the `lxml` library. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and represents the base namespace URI for version 1.0 of the Netconf XML schema.\n\nReturns:\n    dict: A dictionary with a single entry where the key is `None` and the value is the base namespace URI (`BASE_NS_1_0`).\"\"\"\n        \"\\n        Base namespace needs a None key.\\n\\n        See 'nsmap' argument for lxml's Element().\\n\\n        \"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary representing the base XML namespace for Netconf operations.\n\nThis method is part of the `HpcomwareDeviceHandler` class, which extends `DefaultDeviceHandler`. It provides the necessary base XML namespace with a `None` key, required for constructing XML elements using the `lxml` library. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and represents the base namespace URI for version 1.0 of the Netconf XML schema.\n\nReturns:\n    dict: A dictionary with a single entry where the key is `None` and the value is the base namespace URI (`BASE_NS_1_0`).",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class HpcomwareDeviceHandler(DefaultDeviceHandler):"
      },
      "HpcomwareDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary of keyword arguments for constructing XML elements, specifically containing the namespace mappings required for HP Comware devices. This method builds upon a base namespace and includes additional prefixes for data and configuration namespaces. It utilizes the method `get_xml_base_namespace_dict` to include the base namespace with a None key, necessary for the `nsmap` argument used by the lxml's Element() function.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" that holds the namespace mappings for XML requests.\n\nDependencies:\n    - BASE_NS_1_0: A constant from `ncclient.xml_` defining the base XML namespace used in the context.\n    - get_xml_base_namespace_dict: An inherited method from the DefaultDeviceHandler class that provides the base namespace.\"\"\"\n        '\\n        Return keyword arguments per request, which are applied to Element().\\n\\n        Mostly, this is a dictionary containing the \"nsmap\" key.\\n\\n        See \\'nsmap\\' argument for lxml\\'s Element().\\n\\n        '\n        d = {'data': 'http://www.hp.com/netconf/data:1.0', 'config': 'http://www.hp.com/netconf/config:1.0'}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary of keyword arguments for constructing XML elements, specifically containing the namespace mappings required for HP Comware devices. This method builds upon a base namespace and includes additional prefixes for data and configuration namespaces. It utilizes the method `get_xml_base_namespace_dict` to include the base namespace with a None key, necessary for the `nsmap` argument used by the lxml's Element() function.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" that holds the namespace mappings for XML requests.\n\nDependencies:\n    - BASE_NS_1_0: A constant from `ncclient.xml_` defining the base XML namespace used in the context.\n    - get_xml_base_namespace_dict: An inherited method from the DefaultDeviceHandler class that provides the base namespace.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class HpcomwareDeviceHandler(DefaultDeviceHandler):"
      },
      "HpcomwareDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Add additional device operations specific to HP Comware devices.\n\nThis method defines and returns a dictionary of additional operations that can be performed on the HP Comware device. Each key in the dictionary represents the operation name and its associated value is the corresponding class or command from the `ncclient.operations.third_party.hpcomware.rpc` module, which allows for executing specific tasks like displaying configurations, making configuration changes, performing actions, rolling back configurations, and saving current settings.\n\nReturns:\n    dict: A dictionary containing additional operation names as keys and their corresponding command classes as values.\n\nDependencies:\n- The method utilizes the following classes from the `ncclient.operations.third_party.hpcomware.rpc` module: \n    - `DisplayCommand`\n    - `ConfigCommand`\n    - `Action`\n    - `Rollback`\n    - `Save`\nThese classes encapsulate the operations that can be performed on the HP Comware devices, each handling a specific type of command or operation within the device's management protocols.\"\"\"\n        addtl = {}\n        addtl['cli_display'] = DisplayCommand\n        addtl['cli_config'] = ConfigCommand\n        addtl['action'] = Action\n        addtl['rollback'] = Rollback\n        addtl['save'] = Save\n        return addtl",
        "docstring": "Add additional device operations specific to HP Comware devices.\n\nThis method defines and returns a dictionary of additional operations that can be performed on the HP Comware device. Each key in the dictionary represents the operation name and its associated value is the corresponding class or command from the `ncclient.operations.third_party.hpcomware.rpc` module, which allows for executing specific tasks like displaying configurations, making configuration changes, performing actions, rolling back configurations, and saving current settings.\n\nReturns:\n    dict: A dictionary containing additional operation names as keys and their corresponding command classes as values.\n\nDependencies:\n- The method utilizes the following classes from the `ncclient.operations.third_party.hpcomware.rpc` module: \n    - `DisplayCommand`\n    - `ConfigCommand`\n    - `Action`\n    - `Rollback`\n    - `Save`\nThese classes encapsulate the operations that can be performed on the HP Comware devices, each handling a specific type of command or operation within the device's management protocols.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class HpcomwareDeviceHandler(DefaultDeviceHandler):"
      }
    },
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initialize the DefaultDeviceHandler with device-specific parameters and configure error handling.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device that may influence the handler's behavior.\n\nThis constructor initializes essential attributes of the DefaultDeviceHandler, including:\n- `self.device_params`: Stores the device parameters passed during initialization.\n- `self.capabilities`: Initializes an empty list to hold device capabilities.\n- Error handling lists (`_exempt_errors_exact_match`, `_exempt_errors_startwith_wildcard_match`, `_exempt_errors_endwith_wildcard_match`, `_exempt_errors_full_wildcard_match`) for categorizing exempt error messages defined in the class constant `_EXEMPT_ERRORS`. These lists are populated with lowercase variations of each exempt error for case-insensitive matching.\n\nThe `_EXEMPT_ERRORS` constant allows subclasses to define specific error messages that should be exempt from raising exceptions upon RPC errors.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initialize the DefaultDeviceHandler with device-specific parameters and configure error handling.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device that may influence the handler's behavior.\n\nThis constructor initializes essential attributes of the DefaultDeviceHandler, including:\n- `self.device_params`: Stores the device parameters passed during initialization.\n- `self.capabilities`: Initializes an empty list to hold device capabilities.\n- Error handling lists (`_exempt_errors_exact_match`, `_exempt_errors_startwith_wildcard_match`, `_exempt_errors_endwith_wildcard_match`, `_exempt_errors_full_wildcard_match`) for categorizing exempt error messages defined in the class constant `_EXEMPT_ERRORS`. These lists are populated with lowercase variations of each exempt error for case-insensitive matching.\n\nThe `_EXEMPT_ERRORS` constant allows subclasses to define specific error messages that should be exempt from raising exceptions upon RPC errors.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: ncclient-test_hpcomware\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 default.py\n    \u2502   \u2502   \u2514\u2500\u2500 DefaultDeviceHandler.__init__\n    \u2502   \u2514\u2500\u2500 hpcomware.py\n    \u2502       \u251c\u2500\u2500 HpcomwareDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 HpcomwareDeviceHandler.add_additional_operations\n    \u2502       \u251c\u2500\u2500 HpcomwareDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u2514\u2500\u2500 HpcomwareDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2514\u2500\u2500 transport/\n        \u2514\u2500\u2500 errors.py\n            \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate the functionality of the Hpcomware Device Handler component within a network management system that leverages the NETCONF protocol. It ensures the proper implementation of key device-specific capabilities, such as generating XML namespace mappings, applying extended XML prefix configurations, and supporting additional custom operations (e.g., CLI commands, configuration actions, and rollback mechanisms). By verifying the accurate behavior of these features, the module ensures seamless interaction between the system and HP Comware devices, addressing compatibility and integration challenges for developers working with complex, device-specific configurations in automated network environments. It ultimately facilitates robust and reliable network automation by confirming that the Hpcomware device handler adheres to expected behaviors.\n\n## FILE 1: ncclient/transport/errors.py\n\n## FILE 2: ncclient/devices/hpcomware.py\n\n- CLASS METHOD: HpcomwareDeviceHandler.__init__\n  - CLASS SIGNATURE: class HpcomwareDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the HpcomwareDeviceHandler class, which is a specialized device handler for HP Comware devices. This constructor initializes the device handler with parameters specific to the device by invoking the constructor of the parent class, DefaultDeviceHandler.\n\nParameters:\n- device_params (dict): A dictionary of parameters required to configure the device connection, such as hostname, username, and password.\n\nThis method does not return any value, but it establishes the necessary setup for handling HP Comware devices by leveraging the existing functionality of the DefaultDeviceHandler. The interaction with the parent class is facilitated by calling its constructor with the provided device parameters.\n\"\"\"\n```\n\n- CLASS METHOD: HpcomwareDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class HpcomwareDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary representing the base XML namespace for Netconf operations.\n\nThis method is part of the `HpcomwareDeviceHandler` class, which extends `DefaultDeviceHandler`. It provides the necessary base XML namespace with a `None` key, required for constructing XML elements using the `lxml` library. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and represents the base namespace URI for version 1.0 of the Netconf XML schema.\n\nReturns:\n    dict: A dictionary with a single entry where the key is `None` and the value is the base namespace URI (`BASE_NS_1_0`).\n\"\"\"\n```\n\n- CLASS METHOD: HpcomwareDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class HpcomwareDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary of keyword arguments for constructing XML elements, specifically containing the namespace mappings required for HP Comware devices. This method builds upon a base namespace and includes additional prefixes for data and configuration namespaces. It utilizes the method `get_xml_base_namespace_dict` to include the base namespace with a None key, necessary for the `nsmap` argument used by the lxml's Element() function.\n\nReturns:\n    dict: A dictionary with the key \"nsmap\" that holds the namespace mappings for XML requests.\n\nDependencies:\n    - BASE_NS_1_0: A constant from `ncclient.xml_` defining the base XML namespace used in the context.\n    - get_xml_base_namespace_dict: An inherited method from the DefaultDeviceHandler class that provides the base namespace.\n\"\"\"\n```\n\n- CLASS METHOD: HpcomwareDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class HpcomwareDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nAdd additional device operations specific to HP Comware devices.\n\nThis method defines and returns a dictionary of additional operations that can be performed on the HP Comware device. Each key in the dictionary represents the operation name and its associated value is the corresponding class or command from the `ncclient.operations.third_party.hpcomware.rpc` module, which allows for executing specific tasks like displaying configurations, making configuration changes, performing actions, rolling back configurations, and saving current settings.\n\nReturns:\n    dict: A dictionary containing additional operation names as keys and their corresponding command classes as values.\n\nDependencies:\n- The method utilizes the following classes from the `ncclient.operations.third_party.hpcomware.rpc` module: \n    - `DisplayCommand`\n    - `ConfigCommand`\n    - `Action`\n    - `Rollback`\n    - `Save`\nThese classes encapsulate the operations that can be performed on the HP Comware devices, each handling a specific type of command or operation within the device's management protocols.\n\"\"\"\n```\n\n## FILE 3: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the DefaultDeviceHandler with device-specific parameters and configure error handling.\n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device that may influence the handler's behavior.\n\nThis constructor initializes essential attributes of the DefaultDeviceHandler, including:\n- `self.device_params`: Stores the device parameters passed during initialization.\n- `self.capabilities`: Initializes an empty list to hold device capabilities.\n- Error handling lists (`_exempt_errors_exact_match`, `_exempt_errors_startwith_wildcard_match`, `_exempt_errors_endwith_wildcard_match`, `_exempt_errors_full_wildcard_match`) for categorizing exempt error messages defined in the class constant `_EXEMPT_ERRORS`. These lists are populated with lowercase variations of each exempt error for case-insensitive matching.\n\nThe `_EXEMPT_ERRORS` constant allows subclasses to define specific error messages that should be exempt from raising exceptions upon RPC errors.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/devices/hpcomware.py": "from ncclient.xml_ import BASE_NS_1_0\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.hpcomware.rpc import DisplayCommand, ConfigCommand, Action, Rollback, Save\n\nclass HpcomwareDeviceHandler(DefaultDeviceHandler):",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)"
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_hpcomware.py:TestHpcomwareDevice:setUp": {
      "ncclient/devices/hpcomware.py:HpcomwareDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_hpcomware.py:TestHpcomwareDevice:test_add_additional_operations": {
      "ncclient/devices/hpcomware.py:HpcomwareDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_hpcomware.py:TestHpcomwareDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/hpcomware.py:HpcomwareDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_hpcomware.py:TestHpcomwareDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/hpcomware.py:HpcomwareDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/hpcomware.py:HpcomwareDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}