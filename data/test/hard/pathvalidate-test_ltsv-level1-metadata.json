{
  "dir_path": "/app/pathvalidate",
  "package_name": "pathvalidate",
  "sample_name": "pathvalidate-test_ltsv",
  "src_dir": "pathvalidate/",
  "test_dir": "test/",
  "test_file": "test/test_ltsv.py",
  "test_code": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport itertools\n\nimport pytest\n\nfrom pathvalidate import sanitize_ltsv_label, validate_ltsv_label\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom ._common import INVALID_WIN_FILENAME_CHARS, alphanum_chars\n\n\nVALID_LABEL_CHARS = alphanum_chars + (\"_\", \".\", \"-\")\nINVALID_LABEL_CHARS = INVALID_WIN_FILENAME_CHARS + (\n    \"!\",\n    \"#\",\n    \"$\",\n    \"&\",\n    \"'\",\n    \"=\",\n    \"~\",\n    \"^\",\n    \"@\",\n    \"`\",\n    \"[\",\n    \"]\",\n    \"+\",\n    \";\",\n    \"{\",\n    \"}\",\n    \",\",\n    \"(\",\n    \")\",\n    \"%\",\n    \" \",\n    \"\\t\",\n    \"\\n\",\n    \"\\r\",\n    \"\\f\",\n    \"\\v\",\n)\n\n\nclass Test_validate_ltsv_label:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = INVALID_LABEL_CHARS\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_ltsv_label(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [[\"abc\" + invalid_char + \"hoge123\"] for invalid_char in INVALID_CHARS]\n        + [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30e9\u30d9\u30eb\"]],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_ltsv_label(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n\nclass Test_sanitize_ltsv_label:\n    TARGET_CHARS = INVALID_LABEL_CHARS\n    NOT_TARGET_CHARS = alphanum_chars\n    REPLACE_TEXT_LIST = [\"\", \"_\"]\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"expected\"],\n        [\n            [\"A\" + c + \"B\", rep, \"A\" + rep + \"B\"]\n            for c, rep in itertools.product(TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [\"A\" + c + \"B\", rep, \"A\" + c + \"B\"]\n            for c, rep in itertools.product(NOT_TARGET_CHARS, REPLACE_TEXT_LIST)\n        ],\n    )\n    def test_normal(self, value, replace_text, expected):\n        assert sanitize_ltsv_label(value, replace_text) == expected\n\n    @pytest.mark.parametrize([\"value\", \"expected\"], [[\"a\u3042\u3044b\u3046\u3048c\u304a\", \"abc\"]])\n    def test_normal_multibyte(self, value, expected):\n        sanitize_ltsv_label(value)\n\n    @pytest.mark.parametrize(\n        [\"value\", \"expected\"],\n        [\n            [\"\", ValidationError],\n            [None, ValidationError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_abnormal(self, value, expected):\n        with pytest.raises(expected):\n            sanitize_ltsv_label(value)\n",
  "GT_file_code": {
    "pathvalidate/_ltsv.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport re\n\nfrom ._common import to_str, validate_pathtype\nfrom .error import InvalidCharError\n\n\n__RE_INVALID_LTSV_LABEL = re.compile(\"[^0-9A-Za-z_.-]\", re.UNICODE)\n\n\ndef validate_ltsv_label(label: str) -> None:\n    \"\"\"\n    Verifying whether ``label`` is a valid\n    `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ label or not.\n\n    :param label: Label to validate.\n    :raises pathvalidate.ValidationError:\n        If invalid character(s) found in the ``label`` for a LTSV format label.\n    \"\"\"\n\n    validate_pathtype(label, allow_whitespaces=False)\n\n    match_list = __RE_INVALID_LTSV_LABEL.findall(to_str(label))\n    if match_list:\n        raise InvalidCharError(f\"invalid character found for a LTSV format label: {match_list}\")\n\n\ndef sanitize_ltsv_label(label: str, replacement_text: str = \"\") -> str:\n    \"\"\"\n    Replace all of the symbols in text.\n\n    :param label: Input text.\n    :param replacement_text: Replacement text.\n    :return: A replacement string.\n    :rtype: str\n    \"\"\"\n\n    validate_pathtype(label, allow_whitespaces=False)\n\n    return __RE_INVALID_LTSV_LABEL.sub(replacement_text, to_str(label))\n",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport enum\nfrom typing import Dict, Optional\n\nfrom ._const import Platform\n\n\ndef _to_error_code(code: int) -> str:\n    return f\"PV{code:04d}\"\n\n\nclass ErrorAttrKey:\n    BYTE_COUNT = \"byte_count\"\n    DESCRIPTION = \"description\"\n    FS_ENCODING = \"fs_encoding\"\n    PLATFORM = \"platform\"\n    REASON = \"reason\"\n    RESERVED_NAME = \"reserved_name\"\n    REUSABLE_NAME = \"reusable_name\"\n\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n\n    NULL_NAME = (_to_error_code(1001), \"NULL_NAME\", \"the value must not be an empty string\")\n    RESERVED_NAME = (\n        _to_error_code(1002),\n        \"RESERVED_NAME\",\n        \"found a reserved name by a platform\",\n    )\n    INVALID_CHARACTER = (\n        _to_error_code(1100),\n        \"INVALID_CHARACTER\",\n        \"invalid characters found\",\n    )\n    INVALID_LENGTH = (\n        _to_error_code(1101),\n        \"INVALID_LENGTH\",\n        \"found an invalid string length\",\n    )\n    FOUND_ABS_PATH = (\n        _to_error_code(1200),\n        \"FOUND_ABS_PATH\",\n        \"found an absolute path where must be a relative path\",\n    )\n    MALFORMED_ABS_PATH = (\n        _to_error_code(1201),\n        \"MALFORMED_ABS_PATH\",\n        \"found a malformed absolute path\",\n    )\n    INVALID_AFTER_SANITIZE = (\n        _to_error_code(2000),\n        \"INVALID_AFTER_SANITIZE\",\n        \"found invalid value after sanitizing\",\n    )\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f\"[{self.__code}] {self.__description}\"\n\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f\"{ErrorAttrKey.REASON} must be specified\")\n\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, \"\")\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n\n        slog: Dict[str, str] = {\n            \"code\": self.reason.code,\n            ErrorAttrKey.DESCRIPTION: self.reason.description,\n        }\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n\n        if self.platform:\n            item_list.append(f\"{ErrorAttrKey.PLATFORM}={self.platform.value}\")\n        if self.description:\n            item_list.append(f\"{ErrorAttrKey.DESCRIPTION}={self.description}\")\n        if self.__reusable_name is not None:\n            item_list.append(f\"{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}\")\n        if self.__fs_encoding:\n            item_list.append(f\"{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}\")\n        if self.__byte_count is not None:\n            item_list.append(f\"{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}\")\n\n        if item_list:\n            header += \": \"\n\n        return header + \", \".join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n\n        super().__init__(args, **kwargs)\n\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n\n        super().__init__(args, **kwargs)\n"
  },
  "GT_src_dict": {
    "pathvalidate/_ltsv.py": {
      "validate_ltsv_label": {
        "code": "def validate_ltsv_label(label: str) -> None:\n    \"\"\"Verifies whether the provided `label` is a valid Labeled Tab-separated Values (LTSV) label. The function checks for invalid characters using a precompiled regular expression, `__RE_INVALID_LTSV_LABEL`, which matches any character that is not a letter, digit, underscore, hyphen, or dot. \n\n:param label: The label string to validate.\n:raises pathvalidate.ValidationError: If the label contains invalid character(s) as defined by LTSV specifications.\n:raises InvalidCharError: If invalid characters are found, indicating which characters are not allowed.\n\nThis function also calls `validate_pathtype` to ensure the label meets path type validation criteria without allowing whitespaces.\"\"\"\n    '\\n    Verifying whether ``label`` is a valid\\n    `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ label or not.\\n\\n    :param label: Label to validate.\\n    :raises pathvalidate.ValidationError:\\n        If invalid character(s) found in the ``label`` for a LTSV format label.\\n    '\n    validate_pathtype(label, allow_whitespaces=False)\n    match_list = __RE_INVALID_LTSV_LABEL.findall(to_str(label))\n    if match_list:\n        raise InvalidCharError(f'invalid character found for a LTSV format label: {match_list}')",
        "docstring": "Verifies whether the provided `label` is a valid Labeled Tab-separated Values (LTSV) label. The function checks for invalid characters using a precompiled regular expression, `__RE_INVALID_LTSV_LABEL`, which matches any character that is not a letter, digit, underscore, hyphen, or dot. \n\n:param label: The label string to validate.\n:raises pathvalidate.ValidationError: If the label contains invalid character(s) as defined by LTSV specifications.\n:raises InvalidCharError: If invalid characters are found, indicating which characters are not allowed.\n\nThis function also calls `validate_pathtype` to ensure the label meets path type validation criteria without allowing whitespaces.",
        "signature": "def validate_ltsv_label(label: str) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "sanitize_ltsv_label": {
        "code": "def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:\n    \"\"\"Sanitizes a given Labeled Tab-separated Values (LTSV) label by replacing all invalid characters with a specified replacement string.\n\n:param label: The input label string to sanitize. It must not contain whitespace characters.\n:param replacement_text: The string to replace invalid characters with. Defaults to an empty string.\n:return: A sanitized label with invalid characters replaced.\n:rtype: str\n\nThis function validates the label using `validate_pathtype`, ensuring the label does not include any whitespace. The constant `__RE_INVALID_LTSV_LABEL`, defined as a regular expression, identifies characters that are not valid in an LTSV label (including anything that is not a letter, digit, underscore, period, or hyphen). The invalid characters are substituted with `replacement_text` in the returned sanitized label.\"\"\"\n    '\\n    Replace all of the symbols in text.\\n\\n    :param label: Input text.\\n    :param replacement_text: Replacement text.\\n    :return: A replacement string.\\n    :rtype: str\\n    '\n    validate_pathtype(label, allow_whitespaces=False)\n    return __RE_INVALID_LTSV_LABEL.sub(replacement_text, to_str(label))",
        "docstring": "Sanitizes a given Labeled Tab-separated Values (LTSV) label by replacing all invalid characters with a specified replacement string.\n\n:param label: The input label string to sanitize. It must not contain whitespace characters.\n:param replacement_text: The string to replace invalid characters with. Defaults to an empty string.\n:return: A sanitized label with invalid characters replaced.\n:rtype: str\n\nThis function validates the label using `validate_pathtype`, ensuring the label does not include any whitespace. The constant `__RE_INVALID_LTSV_LABEL`, defined as a regular expression, identifies characters that are not valid in an LTSV label (including anything that is not a letter, digit, underscore, period, or hyphen). The invalid characters are substituted with `replacement_text` in the returned sanitized label.",
        "signature": "def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/error.py": {
      "ValidationError.reason": {
        "code": "    def reason(self) -> ErrorReason:\n        \"\"\"@property\ndef reason(self) -> ErrorReason:\"\"\"\n        '\\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\\n        '\n        return self.__reason",
        "docstring": "@property\ndef reason(self) -> ErrorReason:",
        "signature": "def reason(self) -> ErrorReason:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      }
    }
  },
  "dependency_dict": {
    "pathvalidate/_ltsv.py:validate_ltsv_label": {
      "pathvalidate/_common.py": {
        "validate_pathtype": {
          "code": "def validate_pathtype(\n    text: PathType, allow_whitespaces: bool = False, error_msg: Optional[str] = None\n) -> None:\n    from .error import ErrorReason, ValidationError\n\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n\n    raise TypeError(f\"text must be a string: actual={type(text)}\")",
          "docstring": "",
          "signature": "def validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:",
          "type": "Function",
          "class_signature": null
        },
        "to_str": {
          "code": "def to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n\n    return name",
          "docstring": "",
          "signature": "def to_str(name: PathType) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "pathvalidate/error.py": {
        "InvalidCharError.__init__": {
          "code": "    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)",
          "docstring": "",
          "signature": "def __init__(self, *args, **kwargs) -> None:",
          "type": "Method",
          "class_signature": "class InvalidCharError(ValidationError):"
        }
      }
    },
    "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
      "pathvalidate/_common.py": {
        "validate_pathtype": {
          "code": "def validate_pathtype(\n    text: PathType, allow_whitespaces: bool = False, error_msg: Optional[str] = None\n) -> None:\n    from .error import ErrorReason, ValidationError\n\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n\n    raise TypeError(f\"text must be a string: actual={type(text)}\")",
          "docstring": "",
          "signature": "def validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:",
          "type": "Function",
          "class_signature": null
        },
        "to_str": {
          "code": "def to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n\n    return name",
          "docstring": "",
          "signature": "def to_str(name: PathType) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pathvalidate-test_ltsv\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pathvalidate/\n    \u251c\u2500\u2500 _ltsv.py\n    \u2502   \u251c\u2500\u2500 sanitize_ltsv_label\n    \u2502   \u2514\u2500\u2500 validate_ltsv_label\n    \u2514\u2500\u2500 error.py\n        \u2514\u2500\u2500 ValidationError.reason\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and sanitize labels used in Labeled Tab-Separated Values (LTSV) files, ensuring compliance with accepted character standards. It provides functionality to check labels for invalid characters and raises specific errors when violations are detected, as well as methods to automatically sanitize labels by replacing or removing disallowed characters. By enforcing strict validation and sanitation of labels, the module prevents formatting issues and ensures compatibility with systems handling LTSV data. This simplifies the process for developers by automating compliance checks and corrections, reducing potential errors and enhancing data integrity.\n\n## FILE 1: pathvalidate/_ltsv.py\n\n- FUNCTION NAME: sanitize_ltsv_label\n  - SIGNATURE: def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nSanitizes a given Labeled Tab-separated Values (LTSV) label by replacing all invalid characters with a specified replacement string.\n\n:param label: The input label string to sanitize. It must not contain whitespace characters.\n:param replacement_text: The string to replace invalid characters with. Defaults to an empty string.\n:return: A sanitized label with invalid characters replaced.\n:rtype: str\n\nThis function validates the label using `validate_pathtype`, ensuring the label does not include any whitespace. The constant `__RE_INVALID_LTSV_LABEL`, defined as a regular expression, identifies characters that are not valid in an LTSV label (including anything that is not a letter, digit, underscore, period, or hyphen). The invalid characters are substituted with `replacement_text` in the returned sanitized label.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/_common.py:validate_pathtype\n\n- FUNCTION NAME: validate_ltsv_label\n  - SIGNATURE: def validate_ltsv_label(label: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies whether the provided `label` is a valid Labeled Tab-separated Values (LTSV) label. The function checks for invalid characters using a precompiled regular expression, `__RE_INVALID_LTSV_LABEL`, which matches any character that is not a letter, digit, underscore, hyphen, or dot. \n\n:param label: The label string to validate.\n:raises pathvalidate.ValidationError: If the label contains invalid character(s) as defined by LTSV specifications.\n:raises InvalidCharError: If invalid characters are found, indicating which characters are not allowed.\n\nThis function also calls `validate_pathtype` to ensure the label meets path type validation criteria without allowing whitespaces.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n    - pathvalidate/_common.py:validate_pathtype\n\n## FILE 2: pathvalidate/error.py\n\n- CLASS METHOD: ValidationError.reason\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reason(self) -> ErrorReason:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reason(self) -> ErrorReason:\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pathvalidate/_ltsv.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport re\nfrom ._common import to_str, validate_pathtype\nfrom .error import InvalidCharError\n__RE_INVALID_LTSV_LABEL = re.compile('[^0-9A-Za-z_.-]', re.UNICODE)",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport enum\nfrom typing import Dict, Optional\nfrom ._const import Platform\n\ndef _to_error_code(code: int) -> str:\n    return f'PV{code:04d}'\n\nclass ErrorAttrKey:\n    BYTE_COUNT = 'byte_count'\n    DESCRIPTION = 'description'\n    FS_ENCODING = 'fs_encoding'\n    PLATFORM = 'platform'\n    REASON = 'reason'\n    RESERVED_NAME = 'reserved_name'\n    REUSABLE_NAME = 'reusable_name'\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n    NULL_NAME = (_to_error_code(1001), 'NULL_NAME', 'the value must not be an empty string')\n    RESERVED_NAME = (_to_error_code(1002), 'RESERVED_NAME', 'found a reserved name by a platform')\n    INVALID_CHARACTER = (_to_error_code(1100), 'INVALID_CHARACTER', 'invalid characters found')\n    INVALID_LENGTH = (_to_error_code(1101), 'INVALID_LENGTH', 'found an invalid string length')\n    FOUND_ABS_PATH = (_to_error_code(1200), 'FOUND_ABS_PATH', 'found an absolute path where must be a relative path')\n    MALFORMED_ABS_PATH = (_to_error_code(1201), 'MALFORMED_ABS_PATH', 'found a malformed absolute path')\n    INVALID_AFTER_SANITIZE = (_to_error_code(2000), 'INVALID_AFTER_SANITIZE', 'found invalid value after sanitizing')\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f'[{self.__code}] {self.__description}'\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f'{ErrorAttrKey.REASON} must be specified')\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, '')\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n        slog: Dict[str, str] = {'code': self.reason.code, ErrorAttrKey.DESCRIPTION: self.reason.description}\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n        if self.platform:\n            item_list.append(f'{ErrorAttrKey.PLATFORM}={self.platform.value}')\n        if self.description:\n            item_list.append(f'{ErrorAttrKey.DESCRIPTION}={self.description}')\n        if self.__reusable_name is not None:\n            item_list.append(f'{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}')\n        if self.__fs_encoding:\n            item_list.append(f'{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}')\n        if self.__byte_count is not None:\n            item_list.append(f'{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}')\n        if item_list:\n            header += ': '\n        return header + ', '.join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n        super().__init__(args, **kwargs)\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n        super().__init__(args, **kwargs)\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n        super().__init__(args, **kwargs)\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n        super().__init__(args, **kwargs)"
  },
  "call_tree": {
    "test/test_ltsv.py:Test_validate_ltsv_label:test_normal": {
      "pathvalidate/_ltsv.py:validate_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_validate_ltsv_label:test_exception_invalid_char": {
      "pathvalidate/_ltsv.py:validate_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_normal": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_normal_multibyte": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_abnormal": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {},
          "pathvalidate/_common.py:is_null_string": {},
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      }
    }
  }
}