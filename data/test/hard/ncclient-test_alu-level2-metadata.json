{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_alu",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_alu.py",
  "test_code": "import unittest\nfrom ncclient.devices.alu import *\nfrom ncclient.xml_ import *\nimport re\n\n\nxml = \"\"\"<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">\n<routing-engin>\n<name>reX</name>\n<commit-success/>\n<!-- This is a comment -->\n</routing-engin>\n<ok/>\n</rpc-reply>\"\"\"\n\n\nclass TestAluDevice(unittest.TestCase):\n    \n    def setUp(self):\n        self.obj = AluDeviceHandler({'name': 'alu'})\n\n    def test_remove_namespaces(self):\n        xmlObj = to_ele(xml)\n        expected = re.sub(r'<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">',\n                          r'<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc-reply>', xml)\n        self.assertEqual(expected, to_xml(remove_namespaces(xmlObj)))\n\n    def test_get_capabilities(self):\n        expected = [\"urn:ietf:params:netconf:base:1.0\", ]\n        self.assertListEqual(expected, self.obj.get_capabilities())\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.obj.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected[\"nsmap\"] = self.obj.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n\n    def test_add_additional_operations(self):\n        expected=dict()\n        expected[\"get_configuration\"] = GetConfiguration\n        expected[\"show_cli\"] = ShowCLI\n        expected[\"load_configuration\"] = LoadConfiguration\n        self.assertDictEqual(expected, self.obj.add_additional_operations())\n    \n    def test_transform_reply(self):\n        expected = re.sub(r'<rpc-reply xmlns:junos=\"http://xml.alu.net/alu/12.1x46/alu\">',\n                          r'<?xml version=\"1.0\" encoding=\"UTF-8\"?><rpc-reply>', xml)\n        actual = self.obj.transform_reply()\n        xmlObj = to_ele(xml)\n        self.assertEqual(expected, to_xml(actual(xmlObj)))\n",
  "GT_file_code": {
    "ncclient/devices/alu.py": "from lxml import etree\n\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.alu.rpc import GetConfiguration, LoadConfiguration, ShowCLI\nfrom ncclient.xml_ import BASE_NS_1_0\n\n\ndef remove_namespaces(xml):\n\n    for elem in xml.getiterator():\n        if elem.tag is etree.Comment:\n            continue\n        i = elem.tag.find('}')\n        if i > 0:\n            elem.tag = elem.tag[i + 1:]\n\n    etree.cleanup_namespaces(xml)\n    return xml\n\n\nclass AluDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Alcatel-Lucent 7x50 handler for device specific information.\n    \"\"\"\n\n    def __init__(self, device_params):\n        super(AluDeviceHandler, self).__init__(device_params)\n\n    def get_capabilities(self):\n        return [\n            \"urn:ietf:params:netconf:base:1.0\",\n        ]\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n\n    def add_additional_operations(self):\n        dict = {}\n        dict[\"get_configuration\"] = GetConfiguration\n        dict[\"show_cli\"] = ShowCLI\n        dict[\"load_configuration\"] = LoadConfiguration\n        return dict\n\n    def transform_reply(self):\n        return remove_namespaces\n",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\nfrom ncclient.transport.parser import DefaultXMLParser\n\nimport sys\nif sys.version >= '3':\n    xrange = range\n\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    # Define the exempt error messages (those that shouldn't cause an exception).\n    # Wild cards are possible: Start and/or end with a '*' to indicate that the text\n    # can appear at the start, the end or the middle of the error message to still\n    # match. All comparisons are case insensitive.\n    _EXEMPT_ERRORS = []\n\n    _BASE_CAPABILITIES = [\n            \"urn:ietf:params:netconf:base:1.0\",\n            \"urn:ietf:params:netconf:base:1.1\",\n            \"urn:ietf:params:netconf:capability:writable-running:1.0\",\n            \"urn:ietf:params:netconf:capability:candidate:1.0\",\n            \"urn:ietf:params:netconf:capability:confirmed-commit:1.0\",\n            \"urn:ietf:params:netconf:capability:rollback-on-error:1.0\",\n            \"urn:ietf:params:netconf:capability:startup:1.0\",\n            \"urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp\",\n            \"urn:ietf:params:netconf:capability:validate:1.0\",\n            \"urn:ietf:params:netconf:capability:xpath:1.0\",\n            \"urn:ietf:params:netconf:capability:notification:1.0\",\n            \"urn:ietf:params:netconf:capability:interleave:1.0\",\n            \"urn:ietf:params:netconf:capability:with-defaults:1.0\"\n    ]\n\n    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)\n\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop(\"capabilities\", [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return [ \"netconf\" ]\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n\n        # Compare the error text against all the exempt errors.\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n\n        return False\n\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        # No transformation by default\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)\n",
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/xml_.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2011 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\n\n\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\n\n# In case issues come up with XML generation/parsing\n# make sure you have the ElementTree v1.2.7+ lib as\n# well as lxml v3.0+\n\nfrom ncclient import NCClientError\n\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\n\ndef _get_parser(huge_tree=False):\n    return huge_parser if huge_tree else parser\n\n\nclass XMLError(NCClientError):\n    pass\n\n### Namespace-related\n\n#: Base NETCONF namespace\nBASE_NS_1_0 = \"urn:ietf:params:xml:ns:netconf:base:1.0\"\n#: YANG (RFC 6020/RFC 7950) namespace\nYANG_NS_1_0 = \"urn:ietf:params:xml:ns:yang:1\"\n#: NXOS_1_0\nNXOS_1_0 = \"http://www.cisco.com/nxos:1.0\"\n#: NXOS_IF\nNXOS_IF = \"http://www.cisco.com/nxos:1.0:if_manager\"\n#: Namespace for Tail-f core data model\nTAILF_AAA_1_1 = \"http://tail-f.com/ns/aaa/1.1\"\n#: Namespace for Tail-f execd data model\nTAILF_EXECD_1_1 = \"http://tail-f.com/ns/execd/1.1\"\n#: Namespace for Cisco data model\nCISCO_CPI_1_0 = \"http://www.cisco.com/cpi_10/schema\"\n#: Namespace for Flowmon data model\nFLOWMON_1_0 = \"http://www.liberouter.org/ns/netopeer/flowmon/1.0\"\n#: Namespace for Juniper 9.6R4. Tested with Junos 9.6R4+\nJUNIPER_1_1 = \"http://xml.juniper.net/xnm/1.1/xnm\"\n#: Namespace for Huawei data model\nHUAWEI_NS = \"http://www.huawei.com/netconf/vrp\"\n#: Namespace for Huawei private\nHW_PRIVATE_NS = \"http://www.huawei.com/netconf/capability/base/1.0\"\n#: Namespace for H3C data model\nH3C_DATA_1_0 = \"http://www.h3c.com/netconf/data:1.0\"\n#: Namespace for H3C config model\nH3C_CONFIG_1_0 = \"http://www.h3c.com/netconf/config:1.0\"\n#: Namespace for H3C action model\nH3C_ACTION_1_0 = \"http://www.h3c.com/netconf/action:1.0\"\n#: Namespace for netconf monitoring\nNETCONF_MONITORING_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring\"\n#: Namespace for netconf notifications\nNETCONF_NOTIFICATION_NS = \"urn:ietf:params:xml:ns:netconf:notification:1.0\"\n#: Namespace for netconf with-defaults (RFC 6243)\nNETCONF_WITH_DEFAULTS_NS = \"urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults\"\n#: Namespace for Alcatel-Lucent SR OS Base r13 YANG models\nALU_CONFIG = \"urn:alcatel-lucent.com:sros:ns:yang:conf-r13\"\n#: Namespace for Nokia SR OS global operations\nSROS_GLOBAL_OPS_NS = \"urn:nokia.com:sros:ns:yang:sr:oper-global\"\n\n\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        # cElementTree uses ElementTree's _namespace_map, so that's ok\n        ElementTree._namespace_map[uri] = prefix\n\nfor (ns, pre) in six.iteritems({\n    BASE_NS_1_0: 'nc',\n    NETCONF_MONITORING_NS: 'ncm',\n    NXOS_1_0: 'nxos',\n    NXOS_IF: 'if',\n    TAILF_AAA_1_1: 'aaa',\n    TAILF_EXECD_1_1: 'execd',\n    CISCO_CPI_1_0: 'cpi',\n    FLOWMON_1_0: 'fm',\n    JUNIPER_1_1: 'junos',\n}):\n    register_namespace(pre, ns)\n\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else \"{%s}%s\" % (ns, tag)\n\"\"\"Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.\"\"\"\n\n\ndef to_xml(ele, encoding=\"UTF-8\", pretty_print=False):\n    \"Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.\"\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') \\\n            else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))\n\n\ndef to_ele(x, huge_tree=False):\n    \"\"\"Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\n\n    *huge_tree*: parse XML with very deep trees and very long text content\n    \"\"\"\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))\n\n\ndef parse_root(raw):\n    \"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError(\"Element [%s] does not meet requirement\" % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)): req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError(\"Element [%s] does not have required attributes\" % ele.tag)\n    return ele\n\nXPATH_NAMESPACES = {\n    're':'http://exslt.org/regular-expressions'\n}\n\n\nclass NCElement(object):\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt=self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)),\n                                                                        parser=self.__parser))),\n                                       parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        # Comments don't have a namespace\n        if elem.tag is not etree.Comment:\n            # handle tag\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n\n            # handle attributes\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\n\n\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\n\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\n\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag,ns), attrs, **extra)\n\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\n\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)\n"
  },
  "GT_src_dict": {
    "ncclient/devices/alu.py": {
      "remove_namespaces": {
        "code": "def remove_namespaces(xml):\n    \"\"\"Removes XML namespaces from the given ElementTree XML structure.\n\nParameters:\n    xml (etree.ElementTree): The XML document from which to remove namespaces.\n\nReturns:\n    etree.ElementTree: The modified XML document with namespaces removed.\n\nThis function iterates over the elements of the provided XML, stripping any namespace prefixes from the tags, and ensuring that comments within the XML structure are not altered. It makes use of `etree.cleanup_namespaces` to clean up any remaining namespace declarations after modification. This function indirectly interacts with the `lxml.etree` module, which must be imported for proper functionality.\"\"\"\n    for elem in xml.getiterator():\n        if elem.tag is etree.Comment:\n            continue\n        i = elem.tag.find('}')\n        if i > 0:\n            elem.tag = elem.tag[i + 1:]\n    etree.cleanup_namespaces(xml)\n    return xml",
        "docstring": "Removes XML namespaces from the given ElementTree XML structure.\n\nParameters:\n    xml (etree.ElementTree): The XML document from which to remove namespaces.\n\nReturns:\n    etree.ElementTree: The modified XML document with namespaces removed.\n\nThis function iterates over the elements of the provided XML, stripping any namespace prefixes from the tags, and ensuring that comments within the XML structure are not altered. It makes use of `etree.cleanup_namespaces` to clean up any remaining namespace declarations after modification. This function indirectly interacts with the `lxml.etree` module, which must be imported for proper functionality.",
        "signature": "def remove_namespaces(xml):",
        "type": "Function",
        "class_signature": null
      },
      "AluDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initializes an instance of the AluDeviceHandler class, which is a specialized handler for Alcatel-Lucent 7x50 devices, inheriting from DefaultDeviceHandler. \n\nParameters:\n- device_params: A dictionary containing parameters necessary for configuring the device connection and communication. This parameter is passed to the parent class for proper initialization.\n\nThis method does not return any value but sets up the necessary context for the device handler to operate effectively. It utilizes the constructor of the superclass (DefaultDeviceHandler) to ensure that any related initialization processes defined there are executed.\"\"\"\n        super(AluDeviceHandler, self).__init__(device_params)",
        "docstring": "Initializes an instance of the AluDeviceHandler class, which is a specialized handler for Alcatel-Lucent 7x50 devices, inheriting from DefaultDeviceHandler. \n\nParameters:\n- device_params: A dictionary containing parameters necessary for configuring the device connection and communication. This parameter is passed to the parent class for proper initialization.\n\nThis method does not return any value but sets up the necessary context for the device handler to operate effectively. It utilizes the constructor of the superclass (DefaultDeviceHandler) to ensure that any related initialization processes defined there are executed.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_capabilities": {
        "code": "    def get_capabilities(self):\n        \"\"\"Return the capabilities supported by the Alcatel-Lucent 7x50 device.\n\nThis method provides a list of URIs that indicate the capabilities of the device handler. The returned capability, specifically \"urn:ietf:params:netconf:base:1.0\", denotes compliance with the base NETCONF protocol. This capability is relevant for interactions with other network management systems that rely on NETCONF for configuration and management tasks.\"\"\"\n        return ['urn:ietf:params:netconf:base:1.0']",
        "docstring": "Return the capabilities supported by the Alcatel-Lucent 7x50 device.\n\nThis method provides a list of URIs that indicate the capabilities of the device handler. The returned capability, specifically \"urn:ietf:params:netconf:base:1.0\", denotes compliance with the base NETCONF protocol. This capability is relevant for interactions with other network management systems that rely on NETCONF for configuration and management tasks.",
        "signature": "def get_capabilities(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Returns a dictionary mapping XML namespace prefixes to their corresponding URIs, specifically for the base NETCONF 1.0 namespace.\n\nThis method does not take any parameters. It returns a dictionary with a single entry where the key is `None`, and the value is `BASE_NS_1_0`, which represents the base namespace URI for NETCONF operations. The constant `BASE_NS_1_0` is imported from `ncclient.xml_` and provides a standard reference for XML namespace compatibility in NETCONF communications, ensuring correct interpretation of payloads compliant with NETCONF 1.0 specifications.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Returns a dictionary mapping XML namespace prefixes to their corresponding URIs, specifically for the base NETCONF 1.0 namespace.\n\nThis method does not take any parameters. It returns a dictionary with a single entry where the key is `None`, and the value is `BASE_NS_1_0`, which represents the base namespace URI for NETCONF operations. The constant `BASE_NS_1_0` is imported from `ncclient.xml_` and provides a standard reference for XML namespace compatibility in NETCONF communications, ensuring correct interpretation of payloads compliant with NETCONF 1.0 specifications.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing XML namespace mapping for the Alcatel-Lucent device handler. This method combines the base namespace dictionary obtained from `get_xml_base_namespace_dict`, which returns a mapping with a `None` key associated with a base namespace constant `BASE_NS_1_0` defined in the `ncclient.xml_` module. The resulting dictionary is formatted as `{\"nsmap\": d}`, where `d` contains the namespace mapping. This is utilized for constructing XML documents with the appropriate namespace in the context of NETCONF operations.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing XML namespace mapping for the Alcatel-Lucent device handler. This method combines the base namespace dictionary obtained from `get_xml_base_namespace_dict`, which returns a mapping with a `None` key associated with a base namespace constant `BASE_NS_1_0` defined in the `ncclient.xml_` module. The resulting dictionary is formatted as `{\"nsmap\": d}`, where `d` contains the namespace mapping. This is utilized for constructing XML documents with the appropriate namespace in the context of NETCONF operations.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.add_additional_operations": {
        "code": "    def add_additional_operations(self):\n        \"\"\"Adds additional NETCONF operations specific to the Alcatel-Lucent device.\n\nThis method creates and returns a dictionary mapping operation names to their respective classes:\n- \"get_configuration\" mapped to `GetConfiguration`,\n- \"show_cli\" mapped to `ShowCLI`,\n- \"load_configuration\" mapped to `LoadConfiguration`.\n\nNo input parameters are required. The return value is a dictionary (dict) containing the mapping of operation names to their classes, which can be utilized for performing device-specific NETCONF operations as defined in the `ncclient.operations.third_party.alu.rpc` module.\"\"\"\n        dict = {}\n        dict['get_configuration'] = GetConfiguration\n        dict['show_cli'] = ShowCLI\n        dict['load_configuration'] = LoadConfiguration\n        return dict",
        "docstring": "Adds additional NETCONF operations specific to the Alcatel-Lucent device.\n\nThis method creates and returns a dictionary mapping operation names to their respective classes:\n- \"get_configuration\" mapped to `GetConfiguration`,\n- \"show_cli\" mapped to `ShowCLI`,\n- \"load_configuration\" mapped to `LoadConfiguration`.\n\nNo input parameters are required. The return value is a dictionary (dict) containing the mapping of operation names to their classes, which can be utilized for performing device-specific NETCONF operations as defined in the `ncclient.operations.third_party.alu.rpc` module.",
        "signature": "def add_additional_operations(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      },
      "AluDeviceHandler.transform_reply": {
        "code": "    def transform_reply(self):\n        \"\"\"Transform the reply from a device-specific operation by removing XML namespaces.\n\nThis method returns the 'remove_namespaces' function, which processes the XML response by stripping unnecessary namespace information from XML elements. This ensures that the XML is simplified for further manipulation or analysis.\n\nReturns:\n    callable: The 'remove_namespaces' function used for transforming XML responses.\n\nDependencies:\n    This method relies on the 'remove_namespaces' function defined outside this class, which takes an XML object as input and returns it without namespaces.\"\"\"\n        return remove_namespaces",
        "docstring": "Transform the reply from a device-specific operation by removing XML namespaces.\n\nThis method returns the 'remove_namespaces' function, which processes the XML response by stripping unnecessary namespace information from XML elements. This ensures that the XML is simplified for further manipulation or analysis.\n\nReturns:\n    callable: The 'remove_namespaces' function used for transforming XML responses.\n\nDependencies:\n    This method relies on the 'remove_namespaces' function defined outside this class, which takes an XML object as input and returns it without namespaces.",
        "signature": "def transform_reply(self):",
        "type": "Method",
        "class_signature": "class AluDeviceHandler(DefaultDeviceHandler):"
      }
    },
    "ncclient/devices/default.py": {
      "DefaultDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params=None):\n        \"\"\"Initializes a DefaultDeviceHandler instance, which serves as a base for handling device-specific interactions for Netconf servers. \n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device being handled. This is stored for further use during the connection and communication processes.\n\nThe constructor processes the class-level constant _EXEMPT_ERRORS, which is a list of error messages that should not trigger exceptions during RPC operation. It converts these messages into a lower case format for case-insensitive comparisons and categorizes them into four types: exact match, wildcard at the start, wildcard at the end, and full wildcard. These categorized lists are stored as instance attributes for efficient error checking.\n\nAttributes initialized include:\n- self.device_params: Stores the input device parameters.\n- self.capabilities: An empty list intended to hold the capabilities of the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists to store categorized exempt error messages based on the provided _EXEMPT_ERRORS constant.\"\"\"\n        self.device_params = device_params\n        self.capabilities = []\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith('*'):\n                if e.endswith('*'):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith('*'):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
        "docstring": "Initializes a DefaultDeviceHandler instance, which serves as a base for handling device-specific interactions for Netconf servers. \n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device being handled. This is stored for further use during the connection and communication processes.\n\nThe constructor processes the class-level constant _EXEMPT_ERRORS, which is a list of error messages that should not trigger exceptions during RPC operation. It converts these messages into a lower case format for case-insensitive comparisons and categorizes them into four types: exact match, wildcard at the start, wildcard at the end, and full wildcard. These categorized lists are stored as instance attributes for efficient error checking.\n\nAttributes initialized include:\n- self.device_params: Stores the input device parameters.\n- self.capabilities: An empty list intended to hold the capabilities of the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists to store categorized exempt error messages based on the provided _EXEMPT_ERRORS constant.",
        "signature": "def __init__(self, device_params=None):",
        "type": "Method",
        "class_signature": "class DefaultDeviceHandler(object):"
      }
    },
    "ncclient/transport/errors.py": {},
    "ncclient/xml_.py": {
      "_get_parser": {
        "code": "def _get_parser(huge_tree=False):\n    \"\"\"Retrieve an XML parser based on the specified tree size configuration.\n\nParameters:\n- huge_tree (bool): A flag indicating whether to use a parser configured to handle very deep XML trees (if True) or a standard parser (if False). The default is False.\n\nReturns:\n- An instance of lxml.etree.XMLParser: Returns the `huge_parser` if `huge_tree` is True; otherwise, it returns the standard `parser`.\n\nThis function utilizes two parser instances defined in the code: `parser`, which can handle typical XML documents, and `huge_parser`, which is specifically designed for very large XML trees. These instances are defined at the module level, allowing for efficient parsing based on the size of the XML document being processed.\"\"\"\n    return huge_parser if huge_tree else parser",
        "docstring": "Retrieve an XML parser based on the specified tree size configuration.\n\nParameters:\n- huge_tree (bool): A flag indicating whether to use a parser configured to handle very deep XML trees (if True) or a standard parser (if False). The default is False.\n\nReturns:\n- An instance of lxml.etree.XMLParser: Returns the `huge_parser` if `huge_tree` is True; otherwise, it returns the standard `parser`.\n\nThis function utilizes two parser instances defined in the code: `parser`, which can handle typical XML documents, and `huge_parser`, which is specifically designed for very large XML trees. These instances are defined at the module level, allowing for efficient parsing based on the size of the XML document being processed.",
        "signature": "def _get_parser(huge_tree=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_xml": {
        "code": "def to_xml(ele, encoding='UTF-8', pretty_print=False):\n    \"\"\"Convert an XML Element to a string representation and return it with the specified encoding.\n\nParameters:\n- ele (Element): The XML element to convert, which should be an instance of `xml.etree.ElementTree.Element`.\n- encoding (str): The encoding for the output XML string. Defaults to \"UTF-8\".\n- pretty_print (bool): A flag indicating whether to format the output string for readability. Defaults to False.\n\nReturns:\n- str: The XML representation of the provided element as a string. An XML declaration is included if the element does not already contain one.\n\nThis function uses `etree.tostring` to serialize the element to a string format and handles both Python 2 and 3 compatibility. The `sys.version` check ensures that the XML output is appropriately formatted based on the Python version. The encoding constant \"UTF-8\", defined directly in the function argument, is significant because it specifies the character set used for the output, which is crucial for XML documents. If pretty_print is set to True, the output will be formatted for easier readability.\"\"\"\n    'Convert and return the XML for an *ele* (:class:`~xml.etree.ElementTree.Element`) with specified *encoding*.'\n    xml = etree.tostring(ele, encoding=encoding, pretty_print=pretty_print)\n    if sys.version < '3':\n        return xml if xml.startswith('<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml)\n    else:\n        return xml.decode('UTF-8') if xml.startswith(b'<?xml') else '<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (encoding, xml.decode('UTF-8'))",
        "docstring": "Convert an XML Element to a string representation and return it with the specified encoding.\n\nParameters:\n- ele (Element): The XML element to convert, which should be an instance of `xml.etree.ElementTree.Element`.\n- encoding (str): The encoding for the output XML string. Defaults to \"UTF-8\".\n- pretty_print (bool): A flag indicating whether to format the output string for readability. Defaults to False.\n\nReturns:\n- str: The XML representation of the provided element as a string. An XML declaration is included if the element does not already contain one.\n\nThis function uses `etree.tostring` to serialize the element to a string format and handles both Python 2 and 3 compatibility. The `sys.version` check ensures that the XML output is appropriately formatted based on the Python version. The encoding constant \"UTF-8\", defined directly in the function argument, is significant because it specifies the character set used for the output, which is crucial for XML documents. If pretty_print is set to True, the output will be formatted for easier readability.",
        "signature": "def to_xml(ele, encoding='UTF-8', pretty_print=False):",
        "type": "Function",
        "class_signature": null
      },
      "to_ele": {
        "code": "def to_ele(x, huge_tree=False):\n    \"\"\"Convert a given XML document or an already existing XML Element into an `lxml.etree.Element`. If the input is a string, it ensures proper parsing, utilizing a specified parser for handling large XML trees if the `huge_tree` parameter is set to True.\n\nParameters:\n- x (str or lxml.etree.Element): The XML document as a string or an existing Element. \n- huge_tree (bool): Flag to indicate whether to parse XML documents that may contain very deep trees and long text content, defaulting to False.\n\nReturns:\n- lxml.etree.Element: The parsed XML as an Element object, or the input Element if it was already an instance of `lxml.etree.Element`.\n\nDependencies:\n- Relies on `lxml` for XML parsing and requires the use of the `_get_parser` function, which returns an appropriate XML parser based on the `huge_tree` flag. The function also utilizes the `sys` module to check for Python version compatibility when processing the input.\"\"\"\n    'Convert and return the :class:`~xml.etree.ElementTree.Element` for the XML document *x*. If *x* is already an :class:`~xml.etree.ElementTree.Element` simply returns that.\\n\\n    *huge_tree*: parse XML with very deep trees and very long text content\\n    '\n    if sys.version < '3':\n        return x if etree.iselement(x) else etree.fromstring(x, parser=_get_parser(huge_tree))\n    else:\n        return x if etree.iselement(x) else etree.fromstring(x.encode('UTF-8'), parser=_get_parser(huge_tree))",
        "docstring": "Convert a given XML document or an already existing XML Element into an `lxml.etree.Element`. If the input is a string, it ensures proper parsing, utilizing a specified parser for handling large XML trees if the `huge_tree` parameter is set to True.\n\nParameters:\n- x (str or lxml.etree.Element): The XML document as a string or an existing Element. \n- huge_tree (bool): Flag to indicate whether to parse XML documents that may contain very deep trees and long text content, defaulting to False.\n\nReturns:\n- lxml.etree.Element: The parsed XML as an Element object, or the input Element if it was already an instance of `lxml.etree.Element`.\n\nDependencies:\n- Relies on `lxml` for XML parsing and requires the use of the `_get_parser` function, which returns an appropriate XML parser based on the `huge_tree` flag. The function also utilizes the `sys` module to check for Python version compatibility when processing the input.",
        "signature": "def to_ele(x, huge_tree=False):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/alu.py:AluDeviceHandler:__init__": {},
    "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {},
    "ncclient/devices/alu.py:AluDeviceHandler:get_xml_extra_prefix_kwargs": {},
    "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {},
    "ncclient/xml_.py:to_ele": {},
    "ncclient/xml_.py:_get_parser": {}
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:setUp": {
      "ncclient/devices/alu.py:AluDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_add_additional_operations": {
      "ncclient/devices/alu.py:AluDeviceHandler:add_additional_operations": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_capabilities": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_capabilities": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/alu.py:AluDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/alu.py:AluDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_remove_namespaces": {
      "ncclient/xml_.py:to_ele": {
        "ncclient/xml_.py:_get_parser": {}
      },
      "ncclient/devices/alu.py:remove_namespaces": {},
      "ncclient/xml_.py:to_xml": {}
    },
    "modified_testcases/unit/devices/test_alu.py:TestAluDevice:test_transform_reply": {
      "ncclient/devices/alu.py:AluDeviceHandler:transform_reply": {},
      "ncclient/xml_.py:to_ele": {
        "ncclient/xml_.py:_get_parser": {}
      },
      "ncclient/devices/alu.py:remove_namespaces": {},
      "ncclient/xml_.py:to_xml": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/ncclient-image-test_alu/ncclient-test_alu/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_alu\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u251c\u2500\u2500 alu.py\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.add_additional_operations\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.get_capabilities\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.get_xml_base_namespace_dict\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2502   \u2502   \u251c\u2500\u2500 AluDeviceHandler.transform_reply\n    \u2502   \u2502   \u2514\u2500\u2500 remove_namespaces\n    \u2502   \u2514\u2500\u2500 default.py\n    \u2502       \u2514\u2500\u2500 DefaultDeviceHandler.__init__\n    \u251c\u2500\u2500 transport/\n    \u2502   \u2514\u2500\u2500 errors.py\n    \u2502       \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n    \u2514\u2500\u2500 xml_.py\n        \u251c\u2500\u2500 _get_parser\n        \u251c\u2500\u2500 to_ele\n        \u2514\u2500\u2500 to_xml\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the testing of functionality related to managing and interacting with Alu (Alcatel-Lucent) networking devices using the NETCONF protocol. It provides capabilities for namespace manipulation, capability detection, and extending device operations with additional commands such as retrieving configurations, running command-line interface (CLI) commands, and loading configuration files. The module also ensures XML responses from devices are transformed into a standardized format for consistent processing. By offering these features, it simplifies the integration and validation of Alu device interactions in networking environments, minimizing the complexity for developers working with XML-based NETCONF device communications.\n\n## FILE 1: ncclient/devices/alu.py\n\n- CLASS METHOD: AluDeviceHandler.__init__\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the AluDeviceHandler class, which is a specialized handler for Alcatel-Lucent 7x50 devices, inheriting from DefaultDeviceHandler. \n\nParameters:\n- device_params: A dictionary containing parameters necessary for configuring the device connection and communication. This parameter is passed to the parent class for proper initialization.\n\nThis method does not return any value but sets up the necessary context for the device handler to operate effectively. It utilizes the constructor of the superclass (DefaultDeviceHandler) to ensure that any related initialization processes defined there are executed.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_capabilities\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_capabilities(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the capabilities supported by the Alcatel-Lucent 7x50 device.\n\nThis method provides a list of URIs that indicate the capabilities of the device handler. The returned capability, specifically \"urn:ietf:params:netconf:base:1.0\", denotes compliance with the base NETCONF protocol. This capability is relevant for interactions with other network management systems that rely on NETCONF for configuration and management tasks.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.add_additional_operations\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_operations(self):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds additional NETCONF operations specific to the Alcatel-Lucent device.\n\nThis method creates and returns a dictionary mapping operation names to their respective classes:\n- \"get_configuration\" mapped to `GetConfiguration`,\n- \"show_cli\" mapped to `ShowCLI`,\n- \"load_configuration\" mapped to `LoadConfiguration`.\n\nNo input parameters are required. The return value is a dictionary (dict) containing the mapping of operation names to their classes, which can be utilized for performing device-specific NETCONF operations as defined in the `ncclient.operations.third_party.alu.rpc` module.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing XML namespace mapping for the Alcatel-Lucent device handler. This method combines the base namespace dictionary obtained from `get_xml_base_namespace_dict`, which returns a mapping with a `None` key associated with a base namespace constant `BASE_NS_1_0` defined in the `ncclient.xml_` module. The resulting dictionary is formatted as `{\"nsmap\": d}`, where `d` contains the namespace mapping. This is utilized for constructing XML documents with the appropriate namespace in the context of NETCONF operations.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary mapping XML namespace prefixes to their corresponding URIs, specifically for the base NETCONF 1.0 namespace.\n\nThis method does not take any parameters. It returns a dictionary with a single entry where the key is `None`, and the value is `BASE_NS_1_0`, which represents the base namespace URI for NETCONF operations. The constant `BASE_NS_1_0` is imported from `ncclient.xml_` and provides a standard reference for XML namespace compatibility in NETCONF communications, ensuring correct interpretation of payloads compliant with NETCONF 1.0 specifications.\n\"\"\"\n```\n\n- FUNCTION NAME: remove_namespaces\n  - SIGNATURE: def remove_namespaces(xml):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves XML namespaces from the given ElementTree XML structure.\n\nParameters:\n    xml (etree.ElementTree): The XML document from which to remove namespaces.\n\nReturns:\n    etree.ElementTree: The modified XML document with namespaces removed.\n\nThis function iterates over the elements of the provided XML, stripping any namespace prefixes from the tags, and ensuring that comments within the XML structure are not altered. It makes use of `etree.cleanup_namespaces` to clean up any remaining namespace declarations after modification. This function indirectly interacts with the `lxml.etree` module, which must be imported for proper functionality.\n\"\"\"\n```\n\n- CLASS METHOD: AluDeviceHandler.transform_reply\n  - CLASS SIGNATURE: class AluDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def transform_reply(self):\n  - DOCSTRING: \n```python\n\"\"\"\nTransform the reply from a device-specific operation by removing XML namespaces.\n\nThis method returns the 'remove_namespaces' function, which processes the XML response by stripping unnecessary namespace information from XML elements. This ensures that the XML is simplified for further manipulation or analysis.\n\nReturns:\n    callable: The 'remove_namespaces' function used for transforming XML responses.\n\nDependencies:\n    This method relies on the 'remove_namespaces' function defined outside this class, which takes an XML object as input and returns it without namespaces.\n\"\"\"\n```\n\n## FILE 2: ncclient/devices/default.py\n\n- CLASS METHOD: DefaultDeviceHandler.__init__\n  - CLASS SIGNATURE: class DefaultDeviceHandler(object):\n  - SIGNATURE: def __init__(self, device_params=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DefaultDeviceHandler instance, which serves as a base for handling device-specific interactions for Netconf servers. \n\nParameters:\n- device_params (optional): A dictionary containing parameters specific to the device being handled. This is stored for further use during the connection and communication processes.\n\nThe constructor processes the class-level constant _EXEMPT_ERRORS, which is a list of error messages that should not trigger exceptions during RPC operation. It converts these messages into a lower case format for case-insensitive comparisons and categorizes them into four types: exact match, wildcard at the start, wildcard at the end, and full wildcard. These categorized lists are stored as instance attributes for efficient error checking.\n\nAttributes initialized include:\n- self.device_params: Stores the input device parameters.\n- self.capabilities: An empty list intended to hold the capabilities of the device.\n- self._exempt_errors_exact_match, self._exempt_errors_startwith_wildcard_match, self._exempt_errors_endwith_wildcard_match, self._exempt_errors_full_wildcard_match: Lists to store categorized exempt error messages based on the provided _EXEMPT_ERRORS constant.\n\"\"\"\n```\n\n## FILE 3: ncclient/transport/errors.py\n\n## FILE 4: ncclient/xml_.py\n\n- FUNCTION NAME: to_xml\n  - SIGNATURE: def to_xml(ele, encoding='UTF-8', pretty_print=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an XML Element to a string representation and return it with the specified encoding.\n\nParameters:\n- ele (Element): The XML element to convert, which should be an instance of `xml.etree.ElementTree.Element`.\n- encoding (str): The encoding for the output XML string. Defaults to \"UTF-8\".\n- pretty_print (bool): A flag indicating whether to format the output string for readability. Defaults to False.\n\nReturns:\n- str: The XML representation of the provided element as a string. An XML declaration is included if the element does not already contain one.\n\nThis function uses `etree.tostring` to serialize the element to a string format and handles both Python 2 and 3 compatibility. The `sys.version` check ensures that the XML output is appropriately formatted based on the Python version. The encoding constant \"UTF-8\", defined directly in the function argument, is significant because it specifies the character set used for the output, which is crucial for XML documents. If pretty_print is set to True, the output will be formatted for easier readability.\n\"\"\"\n```\n\n- FUNCTION NAME: to_ele\n  - SIGNATURE: def to_ele(x, huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a given XML document or an already existing XML Element into an `lxml.etree.Element`. If the input is a string, it ensures proper parsing, utilizing a specified parser for handling large XML trees if the `huge_tree` parameter is set to True.\n\nParameters:\n- x (str or lxml.etree.Element): The XML document as a string or an existing Element. \n- huge_tree (bool): Flag to indicate whether to parse XML documents that may contain very deep trees and long text content, defaulting to False.\n\nReturns:\n- lxml.etree.Element: The parsed XML as an Element object, or the input Element if it was already an instance of `lxml.etree.Element`.\n\nDependencies:\n- Relies on `lxml` for XML parsing and requires the use of the `_get_parser` function, which returns an appropriate XML parser based on the `huge_tree` flag. The function also utilizes the `sys` module to check for Python version compatibility when processing the input.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:_get_parser\n\n- FUNCTION NAME: _get_parser\n  - SIGNATURE: def _get_parser(huge_tree=False):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve an XML parser based on the specified tree size configuration.\n\nParameters:\n- huge_tree (bool): A flag indicating whether to use a parser configured to handle very deep XML trees (if True) or a standard parser (if False). The default is False.\n\nReturns:\n- An instance of lxml.etree.XMLParser: Returns the `huge_parser` if `huge_tree` is True; otherwise, it returns the standard `parser`.\n\nThis function utilizes two parser instances defined in the code: `parser`, which can handle typical XML documents, and `huge_parser`, which is specifically designed for very large XML trees. These instances are defined at the module level, allowing for efficient parsing based on the size of the XML document being processed.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - ncclient/xml_.py:to_ele\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/devices/alu.py": "from lxml import etree\nfrom .default import DefaultDeviceHandler\nfrom ncclient.operations.third_party.alu.rpc import GetConfiguration, LoadConfiguration, ShowCLI\nfrom ncclient.xml_ import BASE_NS_1_0\n\nclass AluDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Alcatel-Lucent 7x50 handler for device specific information.\n    \"\"\"",
    "ncclient/devices/default.py": "\"\"\"\nHandler for default device information.\n\nSome devices require very specific information and action during client interaction.\n\nThe \"device handlers\" provide a number of callbacks that return the necessary\ninformation. This allows the ncclient code to merely call upon this device handler -\nonce configured - instead of cluttering its code with if-statements.\n\nInitially, not much is dealt with by the handler. However, in the future, as more\ndevices with specific handling are added, more handlers and more functions should be\nimplememted here, so that the ncclient code can use these callbacks to fill in the\ndevice specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom ncclient.transport.parser import DefaultXMLParser\nimport sys\nif sys.version >= '3':\n    xrange = range\n\nclass DefaultDeviceHandler(object):\n    \"\"\"\n    Default handler for device specific information.\n\n    \"\"\"\n    _EXEMPT_ERRORS = []\n    _BASE_CAPABILITIES = ['urn:ietf:params:netconf:base:1.0', 'urn:ietf:params:netconf:base:1.1', 'urn:ietf:params:netconf:capability:writable-running:1.0', 'urn:ietf:params:netconf:capability:candidate:1.0', 'urn:ietf:params:netconf:capability:confirmed-commit:1.0', 'urn:ietf:params:netconf:capability:rollback-on-error:1.0', 'urn:ietf:params:netconf:capability:startup:1.0', 'urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file,https,sftp', 'urn:ietf:params:netconf:capability:validate:1.0', 'urn:ietf:params:netconf:capability:xpath:1.0', 'urn:ietf:params:netconf:capability:notification:1.0', 'urn:ietf:params:netconf:capability:interleave:1.0', 'urn:ietf:params:netconf:capability:with-defaults:1.0']\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"\n        Add device specific parameters for the SSH connect.\n\n        Pass in the keyword-argument dictionary for the SSH connect call. The\n        dictionary will be modified (!) with the additional device-specific parameters.\n\n        \"\"\"\n        pass\n\n    def add_additional_netconf_params(self, kwargs):\n        \"\"\"Add additional NETCONF parameters\n\n        Accept a keyword-argument dictionary to add additional NETCONF\n        parameters that may be in addition to those specified by the\n        default and device specific handlers.\n\n        Currently, only additional client specified capabilities are\n        supported and will be appended to default and device specific\n        capabilities.\n\n        Args:\n            kwargs: A dictionary of specific NETCONF parameters to\n                apply in addition to those derived by default and\n                device specific handlers.\n        \"\"\"\n        self.capabilities = kwargs.pop('capabilities', [])\n\n    def get_capabilities(self):\n        \"\"\"\n        Return the capability list.\n\n        A list of URI's representing the client's capabilities. This is used during\n        the initial capability exchange. Modify (in a new device-handler subclass)\n        as needed.\n\n        \"\"\"\n        return self._BASE_CAPABILITIES + self.capabilities\n\n    def get_xml_base_namespace_dict(self):\n        \"\"\"\n        A dictionary containing the base namespace.\n\n        For lxml's nsmap, the base namespace should have a 'None' key.\n\n            {\n                None: \"... base namespace... \"\n            }\n\n        If no base namespace is needed, an empty dictionary should be\n        returned.\n\n        \"\"\"\n        return {}\n\n    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"\n        Return any extra prefix that should be sent with each RPC request.\n\n        Since these are used as kwargs, the function should return\n        either an empty dictionary if there are no additional arguments,\n        or a dictionary with keyword parameters suitable fo the Element()\n        function. Mostly, this is the \"nsmap\" argument.\n\n            {\n                \"nsmap\" : {\n                    ... namespace definitions ...\n                }\n            }\n\n        \"\"\"\n        return {}\n\n    def get_ssh_subsystem_names(self):\n        \"\"\"\n        Return a list of names to try for the SSH subsystems.\n\n        This always returns a list, even if only a single subsystem name is used.\n\n        If the returned list contains multiple names then the various subsystems are\n        tried in order, until one of them can successfully connect.\n\n        \"\"\"\n        return ['netconf']\n\n    def is_rpc_error_exempt(self, error_text):\n        \"\"\"\n        Check whether an RPC error message is excempt, thus NOT causing an exception.\n\n        On some devices the RPC operations may indicate an error response, even though\n        the operation actually succeeded. This may be in cases where a warning would be\n        more appropriate. In that case, the client may be better advised to simply\n        ignore that error and not raise an exception.\n\n        Note that there is also the \"raise_mode\", set on session and manager, which\n        controls the exception-raising behaviour in case of returned errors. This error\n        filter here is independent of that: No matter what the raise_mode says, if the\n        error message matches one of the exempt errors returned here, an exception\n        will not be raised.\n\n        The exempt error messages are defined in the _EXEMPT_ERRORS field of the device\n        handler object and can be overwritten by child classes.  Wild cards are\n        possible: Start and/or end with a '*' to indicate that the text can appear at\n        the start, the end or the middle of the error message to still match. All\n        comparisons are case insensitive.\n\n        Return True/False depending on found match.\n\n        \"\"\"\n        if error_text is not None:\n            error_text = error_text.lower().strip()\n        else:\n            error_text = 'no error given'\n        for ex in self._exempt_errors_exact_match:\n            if error_text == ex:\n                return True\n        for ex in self._exempt_errors_startwith_wildcard_match:\n            if error_text.endswith(ex):\n                return True\n        for ex in self._exempt_errors_endwith_wildcard_match:\n            if error_text.startswith(ex):\n                return True\n        for ex in self._exempt_errors_full_wildcard_match:\n            if ex in error_text:\n                return True\n        return False\n\n    def perform_qualify_check(self):\n        \"\"\"\n        During RPC operations, we perform some initial sanity checks on the responses.\n\n        This check will fail for some devices, in which case this function here should\n        return False in order to skip the test.\n\n        \"\"\"\n        return True\n\n    def add_additional_operations(self):\n        \"\"\"\n        Add device/vendor specific operations.\n\n        \"\"\"\n        return {}\n\n    def handle_raw_dispatch(self, raw):\n        return False\n\n    def handle_connection_exceptions(self, sshsession):\n        return False\n\n    def reply_parsing_error_transform(self, reply_cls):\n        \"\"\"\n        Hook for working around bugs in replies from devices (the root element can be \"fixed\")\n\n        :param reply_cls: the RPCReply class that is parsing the reply 'root' xml element\n\n        :return: transform function for the 'root' xml element of the RPC reply in case the normal parsing fails\n        \"\"\"\n        return None\n\n    def transform_reply(self):\n        return False\n\n    def transform_edit_config(self, node):\n        \"\"\"\n        Hook for working around bugs in devices that cannot deal with\n        standard config payloads for edits. This will be called\n        in EditConfig.request just before the request is submitted,\n        meaning it will get an XML tree rooted at edit-config.\n\n        :param node: the XML tree for edit-config\n\n        :return: either the original XML tree if no changes made or a modified XML tree\n        \"\"\"\n        return node\n\n    def get_xml_parser(self, session):\n        \"\"\"\n        vendor can chose which parser to use for RPC reply response.\n        Default being DOM\n\n        :param session: ssh session object\n        :return: default DOM parser\n        \"\"\"\n        return DefaultXMLParser(session)",
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/xml_.py": "\"\"\"Methods for creating, parsing, and dealing with XML and ElementTree objects.\"\"\"\nimport io\nimport sys\nimport six\nimport types\nfrom six import StringIO\nfrom io import BytesIO\nfrom lxml import etree\nfrom ncclient import NCClientError\nparser = etree.XMLParser(recover=False)\nhuge_parser = etree.XMLParser(recover=False, huge_tree=True)\n\nclass XMLError(NCClientError):\n    pass\nBASE_NS_1_0 = 'urn:ietf:params:xml:ns:netconf:base:1.0'\nYANG_NS_1_0 = 'urn:ietf:params:xml:ns:yang:1'\nNXOS_1_0 = 'http://www.cisco.com/nxos:1.0'\nNXOS_IF = 'http://www.cisco.com/nxos:1.0:if_manager'\nTAILF_AAA_1_1 = 'http://tail-f.com/ns/aaa/1.1'\nTAILF_EXECD_1_1 = 'http://tail-f.com/ns/execd/1.1'\nCISCO_CPI_1_0 = 'http://www.cisco.com/cpi_10/schema'\nFLOWMON_1_0 = 'http://www.liberouter.org/ns/netopeer/flowmon/1.0'\nJUNIPER_1_1 = 'http://xml.juniper.net/xnm/1.1/xnm'\nHUAWEI_NS = 'http://www.huawei.com/netconf/vrp'\nHW_PRIVATE_NS = 'http://www.huawei.com/netconf/capability/base/1.0'\nH3C_DATA_1_0 = 'http://www.h3c.com/netconf/data:1.0'\nH3C_CONFIG_1_0 = 'http://www.h3c.com/netconf/config:1.0'\nH3C_ACTION_1_0 = 'http://www.h3c.com/netconf/action:1.0'\nNETCONF_MONITORING_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring'\nNETCONF_NOTIFICATION_NS = 'urn:ietf:params:xml:ns:netconf:notification:1.0'\nNETCONF_WITH_DEFAULTS_NS = 'urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults'\nALU_CONFIG = 'urn:alcatel-lucent.com:sros:ns:yang:conf-r13'\nSROS_GLOBAL_OPS_NS = 'urn:nokia.com:sros:ns:yang:sr:oper-global'\ntry:\n    register_namespace = etree.register_namespace\nexcept AttributeError:\n\n    def register_namespace(prefix, uri):\n        from xml.etree import ElementTree\n        ElementTree._namespace_map[uri] = prefix\nfor ns, pre in six.iteritems({BASE_NS_1_0: 'nc', NETCONF_MONITORING_NS: 'ncm', NXOS_1_0: 'nxos', NXOS_IF: 'if', TAILF_AAA_1_1: 'aaa', TAILF_EXECD_1_1: 'execd', CISCO_CPI_1_0: 'cpi', FLOWMON_1_0: 'fm', JUNIPER_1_1: 'junos'}):\n    register_namespace(pre, ns)\nqualify = lambda tag, ns=BASE_NS_1_0: tag if ns is None else '{%s}%s' % (ns, tag)\n'Qualify a *tag* name with a *namespace*, in :mod:`~xml.etree.ElementTree` fashion i.e. *{namespace}tagname*.'\n\ndef parse_root(raw):\n    \"\"\"Efficiently parses the root element of a *raw* XML document, returning a tuple of its qualified name and attribute dictionary.\"\"\"\n    if sys.version < '3':\n        fp = StringIO(raw)\n    else:\n        fp = BytesIO(raw.encode('UTF-8'))\n    for event, element in etree.iterparse(fp, events=('start',)):\n        return (element.tag, element.attrib)\n\ndef validated_element(x, tags=None, attrs=None):\n    \"\"\"Checks if the root element of an XML document or Element meets the supplied criteria.\n\n    *tags* if specified is either a single allowable tag name or sequence of allowable alternatives\n\n    *attrs* if specified is a sequence of required attributes, each of which may be a sequence of several allowable alternatives\n\n    Raises :exc:`XMLError` if the requirements are not met.\n    \"\"\"\n    ele = to_ele(x)\n    if tags:\n        if isinstance(tags, (str, bytes)):\n            tags = [tags]\n        if ele.tag not in tags:\n            raise XMLError('Element [%s] does not meet requirement' % ele.tag)\n    if attrs:\n        for req in attrs:\n            if isinstance(req, (str, bytes)):\n                req = [req]\n            for alt in req:\n                if alt in ele.attrib:\n                    break\n            else:\n                raise XMLError('Element [%s] does not have required attributes' % ele.tag)\n    return ele\nXPATH_NAMESPACES = {'re': 'http://exslt.org/regular-expressions'}\n\nclass NCElement(object):\n\n    def __init__(self, result, transform_reply, huge_tree=False):\n        self.__result = result\n        self.__transform_reply = transform_reply\n        self.__huge_tree = huge_tree\n        if isinstance(transform_reply, types.FunctionType):\n            self.__doc = self.__transform_reply(result._root)\n        else:\n            self.__doc = self.remove_namespaces(self.__result)\n\n    def xpath(self, expression, namespaces={}):\n        \"\"\"Perform XPath navigation on an object\n\n        Args:\n            expression: A string representing a compliant XPath\n                expression.\n            namespaces: A dict of caller supplied prefix/xmlns to\n                append to the static dict of XPath namespaces.\n        Returns:\n            A list of 'lxml.etree._Element' should a match on the\n            expression be successful.  Otherwise, an empty list will\n            be returned to the caller.\n        \"\"\"\n        self.__expression = expression\n        self.__namespaces = XPATH_NAMESPACES\n        self.__namespaces.update(namespaces)\n        return self.__doc.xpath(self.__expression, namespaces=self.__namespaces)\n\n    def find(self, expression):\n        \"\"\"return result for a call to lxml ElementPath find()\"\"\"\n        self.__expression = expression\n        return self.__doc.find(self.__expression)\n\n    def findtext(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findtext()\"\"\"\n        self.__expression = expression\n        return self.__doc.findtext(self.__expression)\n\n    def findall(self, expression):\n        \"\"\"return result for a call to lxml ElementPath findall()\"\"\"\n        self.__expression = expression\n        return self.__doc.findall(self.__expression)\n\n    def __str__(self):\n        \"\"\"syntactic sugar for str() - alias to tostring\"\"\"\n        if sys.version < '3':\n            return self.tostring\n        else:\n            return self.tostring.decode('UTF-8')\n\n    @property\n    def tostring(self):\n        \"\"\"return a pretty-printed string output for rpc reply\"\"\"\n        parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        outputtree = etree.XML(etree.tostring(self.__doc), parser)\n        return etree.tostring(outputtree, pretty_print=True)\n\n    @property\n    def data_xml(self):\n        \"\"\"return an unmodified output for rpc reply\"\"\"\n        return to_xml(self.__doc)\n\n    def remove_namespaces(self, rpc_reply):\n        \"\"\"remove xmlns attributes from rpc reply\"\"\"\n        self.__xslt = self.__transform_reply\n        self.__parser = etree.XMLParser(remove_blank_text=True, huge_tree=self.__huge_tree)\n        self.__xslt_doc = etree.parse(io.BytesIO(self.__xslt), self.__parser)\n        self.__transform = etree.XSLT(self.__xslt_doc)\n        self.__root = etree.fromstring(str(self.__transform(etree.parse(StringIO(str(rpc_reply)), parser=self.__parser))), parser=self.__parser)\n        return self.__root\n\ndef parent_ns(node):\n    if node.prefix:\n        return node.nsmap[node.prefix]\n    return None\n\ndef yang_action(name, attrs):\n    \"\"\"Instantiate a YANG action element\n\n    Args:\n        name: A string representing the first descendant name of the\n            XML element for the YANG action.\n        attrs: A dict of attributes to apply to the XML element\n            (e.g. namespaces).\n    Returns:\n        A tuple of 'lxml.etree._Element' values.  The first value\n        represents the top-level YANG action element and the second\n        represents the caller supplied initial node.\n    \"\"\"\n    node = new_ele('action', attrs={'xmlns': YANG_NS_1_0})\n    return (node, sub_ele(node, name, attrs))\n\ndef replace_namespace(root, old_ns, new_ns):\n    \"\"\"\n    Substitute old_ns with new_ns for all the xml elements including and below root\n    :param root: top element (root for this change)\n    :param old_ns: old namespace\n    :param new_ns: new namespace\n    :return:\n    \"\"\"\n    for elem in root.getiterator():\n        if elem.tag is not etree.Comment:\n            qtag = etree.QName(elem)\n            if qtag.namespace == old_ns:\n                elem.tag = etree.QName(new_ns, qtag.localname)\n            attribs_dict = elem.attrib\n            for attr in attribs_dict.keys():\n                qattr = etree.QName(attr)\n                if qattr.namespace == old_ns:\n                    attribs_dict[etree.QName(new_ns, qattr.localname)] = attribs_dict.pop(attr)\nnew_ele_nsmap = lambda tag, nsmap, attrs={}, **extra: etree.Element(qualify(tag), attrs, nsmap, **extra)\nnew_ele = lambda tag, attrs={}, **extra: etree.Element(qualify(tag), attrs, **extra)\nnew_ele_ns = lambda tag, ns, attrs={}, **extra: etree.Element(qualify(tag, ns), attrs, **extra)\nsub_ele = lambda parent, tag, attrs={}, **extra: etree.SubElement(parent, qualify(tag, parent_ns(parent)), attrs, **extra)\nsub_ele_ns = lambda parent, tag, ns, attrs={}, **extra: etree.SubElement(parent, qualify(tag, ns), attrs, **extra)"
  }
}