{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_combine",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_build/test_combine.py",
  "test_code": "\"\"\"Test function in module.\"\"\"\n\nimport pytest\n\nfrom terminaltables3.build import combine\n\n\n@pytest.mark.parametrize(\"generator\", [False, True])\ndef test_borders(generator):\n    \"\"\"Test with borders.\n\n    :param bool generator: Test with generator instead of list.\n    \"\"\"\n    line = [\"One\", \"Two\", \"Three\"]\n    actual = list(combine(iter(line) if generator else line, \">\", \"|\", \"<\"))\n    assert actual == [\">\", \"One\", \"|\", \"Two\", \"|\", \"Three\", \"<\"]\n\n\n@pytest.mark.parametrize(\"generator\", [False, True])\ndef test_no_border(generator):\n    \"\"\"Test without borders.\n\n    :param bool generator: Test with generator instead of list.\n    \"\"\"\n    line = [\"One\", \"Two\", \"Three\"]\n    actual = list(combine(iter(line) if generator else line, \"\", \"\", \"\"))\n    assert actual == [\"One\", \"Two\", \"Three\"]\n\n\n@pytest.mark.parametrize(\"generator\", [False, True])\ndef test_no_items(generator):\n    \"\"\"Test with empty list.\n\n    :param bool generator: Test with generator instead of list.\n    \"\"\"\n    actual = list(combine(iter([]) if generator else [], \">\", \"|\", \"<\"))\n    assert actual == [\">\", \"<\"]\n",
  "GT_file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\n\nfrom typing import Generator, Iterator, Optional, Sequence, Union\n\nfrom terminaltables3.width_and_alignment import visible_width\n\n\ndef combine(\n    line: Union[\n        Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]\n    ],\n    left: str,\n    intersect: Optional[str],\n    right: str,\n) -> Generator[int, None, None]:\n    \"\"\"Zip borders between items in `line`.\n\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\n\n    :param iter line: List to iterate.\n    :param left: Left border.\n    :param intersect: Column separator.\n    :param right: Right border.\n\n    :return: Yields combined objects.\n    \"\"\"\n    # Yield left border.\n    if left:\n        yield left\n\n    # Yield items with intersect characters.\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:  # Generator.\n            try:\n                item = next(line)\n            except StopIteration:  # Was empty all along.\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n\n        # Yield right border.\n    if right:\n        yield right\n\n\ndef build_border(\n    outer_widths: Sequence[int],\n    horizontal: str,\n    left: str,\n    intersect: str,\n    right: str,\n    title: Optional[str] = None,\n):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n\n    # Hide title if it doesn't fit.\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n\n    # Handle no title.\n    if title is None or not outer_widths or not horizontal:\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n\n    # Handle title fitting in the first column.\n    if length == outer_widths[0]:\n        return combine(\n            [title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right\n        )\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [\n            horizontal * c for c in outer_widths[1:]\n        ]\n        return combine(columns, left, intersect, right)\n\n    # Handle wide titles/narrow columns.\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        # If title is taken care of.\n        if length < 1:\n            columns_and_intersects.append(\n                intersect if width is True else horizontal * width\n            )\n        # If title's last character overrides an intersect character.\n        elif width is True and length == 1:\n            length = 0\n        # If this is an intersect character that is overridden by the title.\n        elif width is True:\n            length -= 1\n        # If title's last character is within a column.\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (\n                width - length\n            )  # Append horizontal chars to title.\n            length = 0\n        # If remainder of title won't fit in a column.\n        else:\n            length -= width\n\n    return combine(columns_and_intersects, left, None, right)\n\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)\n"
  },
  "GT_src_dict": {
    "terminaltables3/build.py": {
      "combine": {
        "code": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n    \"\"\"Combine elements in a line with specified borders and separators.\n\nThis function takes a collection of items and combines them into a single output by enclosing them with defined left and right borders, and optionally inserting a column separator between the items. It handles both iterable sequences and generators, ensuring the correct output format regardless of the input type.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items to combine.\n- left (str): The left border character(s) to prepend to the output.\n- intersect (Optional[str]): The character(s) to insert between items; if None, no separator is added.\n- right (str): The right border character(s) to append to the output.\n\nReturns:\n- Generator[int, None, None]: Yields combined strings or characters in the specified format.\n\nThis function is used in conjunction with other functions like `build_row` and `build_border`, which rely on the formatted output to create structured representations of tabular data. It also interacts with input types defined in the typing module which aid in type hinting for better code clarity.\"\"\"\n    \"Zip borders between items in `line`.\\n\\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\\n\\n    :param iter line: List to iterate.\\n    :param left: Left border.\\n    :param intersect: Column separator.\\n    :param right: Right border.\\n\\n    :return: Yields combined objects.\\n    \"\n    if left:\n        yield left\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:\n            try:\n                item = next(line)\n            except StopIteration:\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n    if right:\n        yield right",
        "docstring": "Combine elements in a line with specified borders and separators.\n\nThis function takes a collection of items and combines them into a single output by enclosing them with defined left and right borders, and optionally inserting a column separator between the items. It handles both iterable sequences and generators, ensuring the correct output format regardless of the input type.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items to combine.\n- left (str): The left border character(s) to prepend to the output.\n- intersect (Optional[str]): The character(s) to insert between items; if None, no separator is added.\n- right (str): The right border character(s) to append to the output.\n\nReturns:\n- Generator[int, None, None]: Yields combined strings or characters in the specified format.\n\nThis function is used in conjunction with other functions like `build_row` and `build_border`, which rely on the formatted output to create structured representations of tabular data. It also interacts with input types defined in the typing module which aid in type hinting for better code clarity.",
        "signature": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: terminaltables-test_combine\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u2514\u2500\u2500 build.py\n        \u2514\u2500\u2500 combine\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the combination of iterable elements with configurable border and separator strings, providing robust support for formatting data into structured outputs. It supports dynamic input handling, including both standard lists and generators, and allows users to customize the presentation of data by defining leading, trailing, and inter-element separators. This functionality is particularly useful for developers requiring a flexible way to format and display tabular or sequential data consistently, streamlining the creation of formatted text-based outputs while ensuring that edge cases, like empty inputs, are properly handled. The module\u2019s design simplifies the process of transforming raw data into visually structured forms, improving readability and reducing boilerplate code for formatting tasks.\n\n## FILE 1: terminaltables3/build.py\n\n- FUNCTION NAME: combine\n  - SIGNATURE: def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine elements in a line with specified borders and separators.\n\nThis function takes a collection of items and combines them into a single output by enclosing them with defined left and right borders, and optionally inserting a column separator between the items. It handles both iterable sequences and generators, ensuring the correct output format regardless of the input type.\n\nParameters:\n- line (Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]): An iterable sequence of items to combine.\n- left (str): The left border character(s) to prepend to the output.\n- intersect (Optional[str]): The character(s) to insert between items; if None, no separator is added.\n- right (str): The right border character(s) to append to the output.\n\nReturns:\n- Generator[int, None, None]: Yields combined strings or characters in the specified format.\n\nThis function is used in conjunction with other functions like `build_row` and `build_border`, which rely on the formatted output to create structured representations of tabular data. It also interacts with input types defined in the typing module which aid in type hinting for better code clarity.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\nfrom typing import Generator, Iterator, Optional, Sequence, Union\nfrom terminaltables3.width_and_alignment import visible_width\n\ndef build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n    if title is None or not outer_widths or (not horizontal):\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n    if length == outer_widths[0]:\n        return combine([title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right)\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [horizontal * c for c in outer_widths[1:]]\n        return combine(columns, left, intersect, right)\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        if length < 1:\n            columns_and_intersects.append(intersect if width is True else horizontal * width)\n        elif width is True and length == 1:\n            length = 0\n        elif width is True:\n            length -= 1\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (width - length)\n            length = 0\n        else:\n            length -= width\n    return combine(columns_and_intersects, left, None, right)\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return '\\n'.join((''.join(r) for r in table))"
  },
  "call_tree": {
    "tests/test_build/test_combine.py:test_borders": {
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_build/test_combine.py:test_no_border": {
      "terminaltables3/build.py:combine": {}
    },
    "tests/test_build/test_combine.py:test_no_items": {
      "terminaltables3/build.py:combine": {}
    }
  }
}