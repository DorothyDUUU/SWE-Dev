{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_single_table",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_all_tables_e2e/test_single_table.py",
  "test_code": "\"\"\"SingleTable end to end testing on Linux/OSX.\"\"\"\n\nimport pytest\n\nfrom terminaltables3 import SingleTable\nfrom terminaltables3.terminal_io import IS_WINDOWS\n\npytestmark = pytest.mark.skipif(str(IS_WINDOWS))\n\n\ndef test_single_line():\n    \"\"\"Test single-lined cells.\"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n        [\"Watermelon\", \"green\"],\n        [],\n    ]\n    table = SingleTable(table_data, \"Example\")\n    table.inner_footing_row_border = True\n    table.justify_columns[0] = \"left\"\n    table.justify_columns[1] = \"center\"\n    table.justify_columns[2] = \"right\"\n    actual = table.table\n\n    expected = (\n        \"\\033(0\\x6c\\033(BExample\\033(0\\x71\\x71\\x71\\x71\\x71\\x77\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x77\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x6b\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Name       \\033(0\\x78\\033(B Color \\033(0\\x78\\033(B      Type \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Avocado    \\033(0\\x78\\033(B green \\033(0\\x78\\033(B       nut \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Tomato     \\033(0\\x78\\033(B  red  \\033(0\\x78\\033(B     fruit \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Lettuce    \\033(0\\x78\\033(B green \\033(0\\x78\\033(B vegetable \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Watermelon \\033(0\\x78\\033(B green \\033(0\\x78\\033(B           \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B            \\033(0\\x78\\033(B       \\033(0\\x78\\033(B           \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x6d\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x76\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x76\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6a\\033(B\"\n    )\n    assert actual == expected\n\n\ndef test_multi_line():\n    \"\"\"Test multi-lined cells.\"\"\"\n    table_data = [\n        [\"Show\", \"Characters\"],\n        [\n            \"Rugrats\",\n            \"Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille, Angelica Pickles,\\nDil Pickles\",\n        ],\n        [\"South Park\", \"Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick\"],\n    ]\n    table = SingleTable(table_data)\n\n    # Test defaults.\n    actual = table.table\n    expected = (\n        \"\\033(0\\x6c\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x77\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6b\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Show       \\033(0\\x78\\033(B Characters                                                       \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Rugrats    \\033(0\\x78\\033(B Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille,\"\n        \" Angelica Pickles, \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B            \\033(0\\x78\\033(B Dil Pickles                                                      \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B South Park \\033(0\\x78\\033(B Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick       \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x6d\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x76\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6a\\033(B\"\n    )\n    assert actual == expected\n\n    # Test inner row border.\n    table.inner_row_border = True\n    actual = table.table\n    expected = (\n        \"\\033(0\\x6c\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x77\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6b\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Show       \\033(0\\x78\\033(B Characters                                                       \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Rugrats    \\033(0\\x78\\033(B Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille,\"\n        \" Angelica Pickles, \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B            \\033(0\\x78\\033(B Dil Pickles                                                      \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B South Park \\033(0\\x78\\033(B Stan Marsh, Kyle Broflovski, Eric Cartman, Kenny McCormick       \"\n        \"                   \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x6d\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x76\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6a\\033(B\"\n    )\n    assert actual == expected\n\n    # Justify right.\n    table.justify_columns = {1: \"right\"}\n    actual = table.table\n    expected = (\n        \"\\033(0\\x6c\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x77\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6b\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Show       \\033(0\\x78\\033(B                                                                  \"\n        \"        Characters \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B Rugrats    \\033(0\\x78\\033(B Tommy Pickles, Chuckie Finster, Phillip DeVille, Lillian DeVille,\"\n        \" Angelica Pickles, \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x78\\033(B            \\033(0\\x78\\033(B                                                                  \"\n        \"       Dil Pickles \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x74\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6e\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x75\\033(B\\n\"\n        \"\\033(0\\x78\\033(B South Park \\033(0\\x78\\033(B                          Stan Marsh, Kyle Broflovski, \"\n        \"Eric Cartman, Kenny McCormick \\033(0\\x78\\033(B\\n\"\n        \"\\033(0\\x6d\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x76\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\"\n        \"\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x71\\x6a\\033(B\"\n    )\n    assert actual == expected\n",
  "GT_file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\n\nfrom typing import Generator, Iterator, Optional, Sequence, Union\n\nfrom terminaltables3.width_and_alignment import visible_width\n\n\ndef combine(\n    line: Union[\n        Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]\n    ],\n    left: str,\n    intersect: Optional[str],\n    right: str,\n) -> Generator[int, None, None]:\n    \"\"\"Zip borders between items in `line`.\n\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\n\n    :param iter line: List to iterate.\n    :param left: Left border.\n    :param intersect: Column separator.\n    :param right: Right border.\n\n    :return: Yields combined objects.\n    \"\"\"\n    # Yield left border.\n    if left:\n        yield left\n\n    # Yield items with intersect characters.\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:  # Generator.\n            try:\n                item = next(line)\n            except StopIteration:  # Was empty all along.\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n\n        # Yield right border.\n    if right:\n        yield right\n\n\ndef build_border(\n    outer_widths: Sequence[int],\n    horizontal: str,\n    left: str,\n    intersect: str,\n    right: str,\n    title: Optional[str] = None,\n):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n\n    # Hide title if it doesn't fit.\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n\n    # Handle no title.\n    if title is None or not outer_widths or not horizontal:\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n\n    # Handle title fitting in the first column.\n    if length == outer_widths[0]:\n        return combine(\n            [title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right\n        )\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [\n            horizontal * c for c in outer_widths[1:]\n        ]\n        return combine(columns, left, intersect, right)\n\n    # Handle wide titles/narrow columns.\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        # If title is taken care of.\n        if length < 1:\n            columns_and_intersects.append(\n                intersect if width is True else horizontal * width\n            )\n        # If title's last character overrides an intersect character.\n        elif width is True and length == 1:\n            length = 0\n        # If this is an intersect character that is overridden by the title.\n        elif width is True:\n            length -= 1\n        # If title's last character is within a column.\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (\n                width - length\n            )  # Append horizontal chars to title.\n            length = 0\n        # If remainder of title won't fit in a column.\n        else:\n            length -= width\n\n    return combine(columns_and_intersects, left, None, right)\n\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)\n",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\n\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\n\nfrom terminaltables3.terminal_io import terminal_size\n\nRE_COLOR_ANSI = re.compile(r\"(\\033\\[[\\d;]+m)\")\n\n\ndef visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string.\n\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\n\n    From: https://github.com/Robpol86/terminaltables3/pull/9\n\n    :param str string: String to measure.\n\n    :return: String's width.\n    :rtype: int\n    \"\"\"\n    if \"\\033\" in string:\n        string = RE_COLOR_ANSI.sub(\"\", string)\n\n    # Convert to unicode.\n    try:\n        string = string.decode(\"u8\")\n    except (AttributeError, UnicodeEncodeError):\n        pass\n\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in (\"F\", \"W\"):\n            width += 2\n        else:\n            width += 1\n\n    return width\n\n\ndef align_and_pad_cell(\n    string: str,\n    align: Tuple,\n    inner_dimensions: Tuple,\n    padding: Sequence[int],\n    space: str = \" \",\n) -> List[str]:\n    \"\"\"Align a string horizontally and vertically. Also add additional padding in both dimensions.\n\n    :param str string: Input string to operate on.\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\n\n    :return: Padded cell split into lines.\n    :rtype: list\n    \"\"\"\n    if not hasattr(string, \"splitlines\"):\n        string = str(string)\n\n    # Handle trailing newlines or empty strings, str.splitlines() does not satisfy.\n    lines = string.splitlines() or [\"\"]\n    if string.endswith(\"\\n\"):\n        lines.append(\"\")\n\n    # Vertically align and pad.\n    if \"bottom\" in align:\n        lines = (\n            ([\"\"] * (inner_dimensions[1] - len(lines) + padding[2]))\n            + lines\n            + ([\"\"] * padding[3])\n        )\n    elif \"middle\" in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = (\n            ([\"\"] * (delta // 2 + delta % 2 + padding[2]))\n            + lines\n            + ([\"\"] * (delta // 2 + padding[3]))\n        )\n    else:\n        lines = (\n            ([\"\"] * padding[2])\n            + lines\n            + ([\"\"] * (inner_dimensions[1] - len(lines) + padding[3]))\n        )\n\n    # Horizontally align and pad.\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if \"right\" in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + (space * padding[1])\n        elif \"center\" in align:\n            lines[i] = (\n                (space * padding[0])\n                + line.center(new_width, space)\n                + (space * padding[1])\n            )\n        else:\n            lines[i] = (space * padding[0]) + line.ljust(new_width + padding[1], space)\n\n    return lines\n\n\ndef max_dimensions(\n    table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0\n):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max(len(r) for r in table_data) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n\n    # Find max width and heights.\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, \"count\") or not hasattr(cell, \"splitlines\"):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count(\"\\n\") + 1)\n            inner_widths[i] = max(\n                inner_widths[i],\n                *[visible_width(the_line) for the_line in cell.splitlines()],\n            )\n\n    # Calculate with padding.\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n\n    return inner_widths, inner_heights, outer_widths, outer_heights\n\n\ndef column_max_width(\n    inner_widths: Sequence[int],\n    column_number: int,\n    outer_border: int,\n    inner_border: int,\n    padding: int,\n) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n\n    # Count how much space padding, outer, and inner borders take up.\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n\n    # Exclude selected column's width.\n    data_space = sum(inner_widths) - inner_widths[column_number]\n\n    return terminal_width - data_space - non_data_space\n\n\ndef table_width(\n    outer_widths: Sequence[int], outer_border: int, inner_border: int\n) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n\n    # Count how much space outer and inner borders take up.\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n\n    # Space of all columns and their padding.\n    data_space = sum(outer_widths)\n    return data_space + non_data_space\n",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\n\nfrom typing import Generator, Optional, Sequence, Tuple\n\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"-\"\n    CHAR_F_INNER_INTERSECT = \"+\"\n    CHAR_F_INNER_VERTICAL = \"|\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_H_INNER_HORIZONTAL = \"-\"\n    CHAR_H_INNER_INTERSECT = \"+\"\n    CHAR_H_INNER_VERTICAL = \"|\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_INNER_HORIZONTAL = \"-\"\n    CHAR_INNER_INTERSECT = \"+\"\n    CHAR_INNER_VERTICAL = \"|\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"-\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"+\"\n    CHAR_OUTER_BOTTOM_LEFT = \"+\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"+\"\n    CHAR_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"-\"\n    CHAR_OUTER_TOP_INTERSECT = \"+\"\n    CHAR_OUTER_TOP_LEFT = \"+\"\n    CHAR_OUTER_TOP_RIGHT = \"+\"\n\n    def __init__(\n        self, table_data: Sequence[Sequence[str]], title: Optional[str] = None\n    ):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n\n        self.justify_columns = {}  # {0: 'right', 1: 'left', 2: 'center'}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(\n        self, style: str, outer_widths: Sequence[int]\n    ) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == \"top\":\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = (\n                self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == \"bottom\":\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = (\n                self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == \"heading\":\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        elif style == \"footing\":\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(\n        self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int\n    ) -> Generator[Tuple[str, ...], None, None]:\n        r\"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n\n        # Resize row if it doesn't have enough cells.\n        if len(row) != len(inner_widths):\n            row = row + [\"\"] * (len(inner_widths) - len(row))\n\n        # Pad and align each cell. Split each cell into lines to support multi-line cells.\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(\n                align_and_pad_cell(cell, align, inner_dimensions, padding)\n            )\n\n        # Determine border characters.\n        if style == \"heading\":\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        elif style == \"footing\":\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n\n        # Yield each line.\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(\n        self,\n        inner_widths: Sequence[int],\n        inner_heights: Sequence[int],\n        outer_widths: Sequence[int],\n    ) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        # Yield top border.\n        if self.outer_border:\n            yield self.horizontal_border(\"top\", outer_widths)\n\n        # Yield table body.\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = row_count - 1, row_count - 2\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            if self.inner_heading_row_border and i == 0:\n                style = \"heading\"\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = \"footing\"\n            else:\n                style = \"row\"\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            # If this is the last row then break. No separator needed.\n            if i == last_row_index:\n                break\n            # Yield heading separator.\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border(\"heading\", outer_widths)\n            # Yield footing separator.\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border(\"footing\", outer_widths)\n            # Yield row separator.\n            elif self.inner_row_border:\n                yield self.horizontal_border(\"row\", outer_widths)\n\n        # Yield bottom border.\n        if self.outer_border:\n            yield self.horizontal_border(\"bottom\", outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(\n            self.table_data, self.padding_left, self.padding_right\n        )[:3]\n        return flatten(self.gen_table(*dimensions))\n",
    "terminaltables3/other_tables.py": "\"\"\"Additional simple tables defined here.\"\"\"\n\nfrom terminaltables3.ascii_table import AsciiTable\nfrom terminaltables3.terminal_io import IS_WINDOWS\n\n\nclass UnixTable(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Unix platforms. Table borders won't have any gaps between lines.\n\n    Similar to the tables shown on PC BIOS boot messages, but not double-lined.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"\\033(0\\x71\\033(B\"\n    CHAR_F_INNER_INTERSECT = \"\\033(0\\x6e\\033(B\"\n    CHAR_F_INNER_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"\\033(0\\x74\\033(B\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"\\033(0\\x75\\033(B\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_H_INNER_HORIZONTAL = \"\\033(0\\x71\\033(B\"\n    CHAR_H_INNER_INTERSECT = \"\\033(0\\x6e\\033(B\"\n    CHAR_H_INNER_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"\\033(0\\x74\\033(B\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"\\033(0\\x75\\033(B\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_INNER_HORIZONTAL = \"\\033(0\\x71\\033(B\"\n    CHAR_INNER_INTERSECT = \"\\033(0\\x6e\\033(B\"\n    CHAR_INNER_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"\\033(0\\x71\\033(B\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"\\033(0\\x76\\033(B\"\n    CHAR_OUTER_BOTTOM_LEFT = \"\\033(0\\x6d\\033(B\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"\\033(0\\x6a\\033(B\"\n    CHAR_OUTER_LEFT_INTERSECT = \"\\033(0\\x74\\033(B\"\n    CHAR_OUTER_LEFT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"\\033(0\\x75\\033(B\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"\\033(0\\x78\\033(B\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"\\033(0\\x71\\033(B\"\n    CHAR_OUTER_TOP_INTERSECT = \"\\033(0\\x77\\033(B\"\n    CHAR_OUTER_TOP_LEFT = \"\\033(0\\x6c\\033(B\"\n    CHAR_OUTER_TOP_RIGHT = \"\\033(0\\x6b\\033(B\"\n\n    @property\n    def table(self):\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        ascii_table = super().table\n        optimized = ascii_table.replace(\"\\033(B\\033(0\", \"\")\n        return optimized\n\n\nclass WindowsTable(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Windows platforms. This uses Code Page 437. Single-line borders.\n\n    From: http://en.wikipedia.org/wiki/Code_page_437#Characters\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = b\"\\xc4\".decode(\"ibm437\")\n    CHAR_F_INNER_INTERSECT = b\"\\xc5\".decode(\"ibm437\")\n    CHAR_F_INNER_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_F_OUTER_LEFT_INTERSECT = b\"\\xc3\".decode(\"ibm437\")\n    CHAR_F_OUTER_LEFT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_F_OUTER_RIGHT_INTERSECT = b\"\\xb4\".decode(\"ibm437\")\n    CHAR_F_OUTER_RIGHT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_H_INNER_HORIZONTAL = b\"\\xc4\".decode(\"ibm437\")\n    CHAR_H_INNER_INTERSECT = b\"\\xc5\".decode(\"ibm437\")\n    CHAR_H_INNER_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_H_OUTER_LEFT_INTERSECT = b\"\\xc3\".decode(\"ibm437\")\n    CHAR_H_OUTER_LEFT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_H_OUTER_RIGHT_INTERSECT = b\"\\xb4\".decode(\"ibm437\")\n    CHAR_H_OUTER_RIGHT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_INNER_HORIZONTAL = b\"\\xc4\".decode(\"ibm437\")\n    CHAR_INNER_INTERSECT = b\"\\xc5\".decode(\"ibm437\")\n    CHAR_INNER_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_HORIZONTAL = b\"\\xc4\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_INTERSECT = b\"\\xc1\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_LEFT = b\"\\xc0\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_RIGHT = b\"\\xd9\".decode(\"ibm437\")\n    CHAR_OUTER_LEFT_INTERSECT = b\"\\xc3\".decode(\"ibm437\")\n    CHAR_OUTER_LEFT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_OUTER_RIGHT_INTERSECT = b\"\\xb4\".decode(\"ibm437\")\n    CHAR_OUTER_RIGHT_VERTICAL = b\"\\xb3\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_HORIZONTAL = b\"\\xc4\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_INTERSECT = b\"\\xc2\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_LEFT = b\"\\xda\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_RIGHT = b\"\\xbf\".decode(\"ibm437\")\n\n\nclass WindowsTableDouble(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Windows platforms. This uses Code Page 437. Double-line borders.\"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = b\"\\xcd\".decode(\"ibm437\")\n    CHAR_F_INNER_INTERSECT = b\"\\xce\".decode(\"ibm437\")\n    CHAR_F_INNER_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_F_OUTER_LEFT_INTERSECT = b\"\\xcc\".decode(\"ibm437\")\n    CHAR_F_OUTER_LEFT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_F_OUTER_RIGHT_INTERSECT = b\"\\xb9\".decode(\"ibm437\")\n    CHAR_F_OUTER_RIGHT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_H_INNER_HORIZONTAL = b\"\\xcd\".decode(\"ibm437\")\n    CHAR_H_INNER_INTERSECT = b\"\\xce\".decode(\"ibm437\")\n    CHAR_H_INNER_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_H_OUTER_LEFT_INTERSECT = b\"\\xcc\".decode(\"ibm437\")\n    CHAR_H_OUTER_LEFT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_H_OUTER_RIGHT_INTERSECT = b\"\\xb9\".decode(\"ibm437\")\n    CHAR_H_OUTER_RIGHT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_INNER_HORIZONTAL = b\"\\xcd\".decode(\"ibm437\")\n    CHAR_INNER_INTERSECT = b\"\\xce\".decode(\"ibm437\")\n    CHAR_INNER_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_HORIZONTAL = b\"\\xcd\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_INTERSECT = b\"\\xca\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_LEFT = b\"\\xc8\".decode(\"ibm437\")\n    CHAR_OUTER_BOTTOM_RIGHT = b\"\\xbc\".decode(\"ibm437\")\n    CHAR_OUTER_LEFT_INTERSECT = b\"\\xcc\".decode(\"ibm437\")\n    CHAR_OUTER_LEFT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_OUTER_RIGHT_INTERSECT = b\"\\xb9\".decode(\"ibm437\")\n    CHAR_OUTER_RIGHT_VERTICAL = b\"\\xba\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_HORIZONTAL = b\"\\xcd\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_INTERSECT = b\"\\xcb\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_LEFT = b\"\\xc9\".decode(\"ibm437\")\n    CHAR_OUTER_TOP_RIGHT = b\"\\xbb\".decode(\"ibm437\")\n\n\nclass SingleTable(WindowsTable if IS_WINDOWS else UnixTable):\n    \"\"\"Cross-platform table with single-line box-drawing characters.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n\nclass DoubleTable(WindowsTableDouble):\n    \"\"\"Cross-platform table with box-drawing characters. On Windows it's double borders, on Linux/OSX it's unicode.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n\nclass PorcelainTable(AsciiTable):\n    \"\"\"An AsciiTable stripped to a minimum.\n\n    Meant to be machine passable and roughly follow format set by git --porcelain option (hence the name).\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    \"\"\"\n\n    def __init__(self, table_data):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        \"\"\"\n        # Porcelain table won't support title since it has no outer birders.\n        super().__init__(table_data)\n\n        # Removes outer border, and inner footing and header row borders.\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = False\n        self.outer_border = False\n"
  },
  "GT_src_dict": {
    "terminaltables3/build.py": {
      "combine": {
        "code": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n    \"\"\"Combine items in a sequence with specified borders and separators, yielding a generator of combined objects. This is useful for formatting rows in a table, where `left` and `right` define the outer borders, and `intersect` serves as a separator between items. \n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A generator or iterator containing items to be combined.\n:param str left: The left border string to prepend.\n:param Optional[str] intersect: The string to insert between each item in `line`.\n:param str right: The right border string to append.\n\n:return: A generator that yields the combined strings, formatted according to the provided borders and separator.\"\"\"\n    \"Zip borders between items in `line`.\\n\\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\\n\\n    :param iter line: List to iterate.\\n    :param left: Left border.\\n    :param intersect: Column separator.\\n    :param right: Right border.\\n\\n    :return: Yields combined objects.\\n    \"\n    if left:\n        yield left\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:\n            try:\n                item = next(line)\n            except StopIteration:\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n    if right:\n        yield right",
        "docstring": "Combine items in a sequence with specified borders and separators, yielding a generator of combined objects. This is useful for formatting rows in a table, where `left` and `right` define the outer borders, and `intersect` serves as a separator between items. \n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A generator or iterator containing items to be combined.\n:param str left: The left border string to prepend.\n:param Optional[str] intersect: The string to insert between each item in `line`.\n:param str right: The right border string to append.\n\n:return: A generator that yields the combined strings, formatted according to the provided borders and separator.",
        "signature": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:",
        "type": "Function",
        "class_signature": null
      },
      "build_border": {
        "code": "def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n    \"\"\"Builds a border for a table, optionally embedding a title if it fits within the left and right borders. The function constructs rows using specified characters for the left and right borders, column separators, and horizontal lines based on the outer column widths.\n\nParameters:\n- outer_widths (Sequence[int]): A list of integers representing the widths of each column.\n- horizontal (str): The character used to create horizontal lines across each column.\n- left (str): The character for the left border of the table.\n- intersect (str): The character used as a column separator between cells.\n- right (str): The character for the right border of the table.\n- title (Optional[str]): An optional string to overlay on the border. It will be hidden if it doesn't fit.\n\nReturns:\n- Generator of strings representing the constructed border. The output contains combined elements as per the specified formatting.\n\nDependencies:\n- The function relies on the `combine` function to yield formatted strings and the `visible_width` function to calculate the display width of the title, ensuring proper fitting between the borders.\"\"\"\n    \"Build the top/bottom/middle row. Optionally embed the table title within the border.\\n\\n    Title is hidden if it doesn't fit between the left/right characters/edges.\\n\\n    Example return value:\\n    ('<', '-----', '+', '------', '+', '-------', '>')\\n    ('<', 'My Table', '----', '+', '------->')\\n\\n    :param iter outer_widths: List of widths (with padding) for each column.\\n    :param str horizontal: Character to stretch across each column.\\n    :param str left: Left border.\\n    :param str intersect: Column separator.\\n    :param str right: Right border.\\n    :param title: Overlay the title on the border between the left and right characters.\\n\\n    :return: Returns a generator of strings representing a border.\\n    :rtype: iter\\n    \"\n    length = 0\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n    if title is None or not outer_widths or (not horizontal):\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n    if length == outer_widths[0]:\n        return combine([title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right)\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [horizontal * c for c in outer_widths[1:]]\n        return combine(columns, left, intersect, right)\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        if length < 1:\n            columns_and_intersects.append(intersect if width is True else horizontal * width)\n        elif width is True and length == 1:\n            length = 0\n        elif width is True:\n            length -= 1\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (width - length)\n            length = 0\n        else:\n            length -= width\n    return combine(columns_and_intersects, left, None, right)",
        "docstring": "Builds a border for a table, optionally embedding a title if it fits within the left and right borders. The function constructs rows using specified characters for the left and right borders, column separators, and horizontal lines based on the outer column widths.\n\nParameters:\n- outer_widths (Sequence[int]): A list of integers representing the widths of each column.\n- horizontal (str): The character used to create horizontal lines across each column.\n- left (str): The character for the left border of the table.\n- intersect (str): The character used as a column separator between cells.\n- right (str): The character for the right border of the table.\n- title (Optional[str]): An optional string to overlay on the border. It will be hidden if it doesn't fit.\n\nReturns:\n- Generator of strings representing the constructed border. The output contains combined elements as per the specified formatting.\n\nDependencies:\n- The function relies on the `combine` function to yield formatted strings and the `visible_width` function to calculate the display width of the title, ensuring proper fitting between the borders.",
        "signature": "def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):",
        "type": "Function",
        "class_signature": null
      },
      "build_row": {
        "code": "def build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single formatted row with borders.\n\nThe function takes a list of cells, where each cell can contain one or more lines of text, and combines them into a formatted row with specified left and right borders and a center column separator. This output is generated for each row based on the cells' content.\n\n:param iter row: A list of cells for one row, where each cell is expected to be a list of strings representing its lines.\n:param str left: A string that represents the left border of the row.\n:param str center: A string that serves as the column separator between cells.\n:param str right: A string that represents the right border of the row.\n\n:yield: Produces a generator that yields strings representing the combined row.\n:rtype: iter\n\nDependency on the `combine` function is essential as it is responsible for formatting the output string by applying the provided borders and separators between cell contents. The function expects that each cell has been properly padded and extended, ensuring uniform line count across cells for proper display.\"\"\"\n    \"Combine single or multi-lined cells into a single row of list of lists including borders.\\n\\n    Row must already be padded and extended so each cell has the same number of lines.\\n\\n    Example return value:\\n    [\\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\\n    ]\\n\\n    :param iter row: List of cells for one row.\\n    :param str left: Left border.\\n    :param str center: Column separator.\\n    :param str right: Right border.\\n\\n    :return: Yields other generators that yield strings.\\n    :rtype: iter\\n    \"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)",
        "docstring": "Combine single or multi-lined cells into a single formatted row with borders.\n\nThe function takes a list of cells, where each cell can contain one or more lines of text, and combines them into a formatted row with specified left and right borders and a center column separator. This output is generated for each row based on the cells' content.\n\n:param iter row: A list of cells for one row, where each cell is expected to be a list of strings representing its lines.\n:param str left: A string that represents the left border of the row.\n:param str center: A string that serves as the column separator between cells.\n:param str right: A string that represents the right border of the row.\n\n:yield: Produces a generator that yields strings representing the combined row.\n:rtype: iter\n\nDependency on the `combine` function is essential as it is responsible for formatting the output string by applying the provided borders and separators between cell contents. The function expects that each cell has been properly padded and extended, ensuring uniform line count across cells for proper display.",
        "signature": "def build_row(row, left, center, right):",
        "type": "Function",
        "class_signature": null
      },
      "flatten": {
        "code": "def flatten(table):\n    \"\"\"Flatten a padded and bordered table into a single string, where each row is separated by a newline.\n\n:param iter table: An iterable containing rows of table data, which are expected to be lists of strings. Each row should be properly padded and bordered for visual alignment.\n\n:return: A single string representation of the table, with each row joined together and separated by newline characters.\n:rtype: str\n\nThis function interacts with the structure of the table data created by the `build_row` function. The output is suitable for display in a console or text interface, where the visual layout of the table is important.\"\"\"\n    'Flatten table data into a single string with newlines.\\n\\n    :param iter table: Padded and bordered table data.\\n\\n    :return: Joined rows/cells.\\n    :rtype: str\\n    '\n    return '\\n'.join((''.join(r) for r in table))",
        "docstring": "Flatten a padded and bordered table into a single string, where each row is separated by a newline.\n\n:param iter table: An iterable containing rows of table data, which are expected to be lists of strings. Each row should be properly padded and bordered for visual alignment.\n\n:return: A single string representation of the table, with each row joined together and separated by newline characters.\n:rtype: str\n\nThis function interacts with the structure of the table data created by the `build_row` function. The output is suitable for display in a console or text interface, where the visual layout of the table is important.",
        "signature": "def flatten(table):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/width_and_alignment.py": {
      "visible_width": {
        "code": "def visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a Unicode string, considering the varying byte sizes of characters, particularly East Asian characters. \n\nThis function removes ANSI color codes using the `RE_COLOR_ANSI` regular expression defined at the top of the code, ensuring that formatting does not affect the width calculation. It counts the visible width by checking each character's East Asian width classification, where Fullwidth (F) and Wide (W) characters contribute two units to the width, while all others contribute one.\n\nParameters:\n- string (str): The Unicode string for which to measure the visible width.\n\nReturns:\n- int: The calculated visible width of the input string, measured in character units.\n\nDependencies:\n- `RE_COLOR_ANSI`: A compiled regular expression pattern used to detect and remove ANSI color codes from the input string.\n- `unicodedata`: A standard library module used to classify Unicode characters based on their width.\"\"\"\n    \"Get the visible width of a unicode string.\\n\\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\\n\\n    From: https://github.com/Robpol86/terminaltables3/pull/9\\n\\n    :param str string: String to measure.\\n\\n    :return: String's width.\\n    :rtype: int\\n    \"\n    if '\\x1b' in string:\n        string = RE_COLOR_ANSI.sub('', string)\n    try:\n        string = string.decode('u8')\n    except (AttributeError, UnicodeEncodeError):\n        pass\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in ('F', 'W'):\n            width += 2\n        else:\n            width += 1\n    return width",
        "docstring": "Get the visible width of a Unicode string, considering the varying byte sizes of characters, particularly East Asian characters. \n\nThis function removes ANSI color codes using the `RE_COLOR_ANSI` regular expression defined at the top of the code, ensuring that formatting does not affect the width calculation. It counts the visible width by checking each character's East Asian width classification, where Fullwidth (F) and Wide (W) characters contribute two units to the width, while all others contribute one.\n\nParameters:\n- string (str): The Unicode string for which to measure the visible width.\n\nReturns:\n- int: The calculated visible width of the input string, measured in character units.\n\nDependencies:\n- `RE_COLOR_ANSI`: A compiled regular expression pattern used to detect and remove ANSI color codes from the input string.\n- `unicodedata`: A standard library module used to classify Unicode characters based on their width.",
        "signature": "def visible_width(string: str) -> int:",
        "type": "Function",
        "class_signature": null
      },
      "align_and_pad_cell": {
        "code": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n    \"\"\"Aligns a given string both horizontally and vertically within specified dimensions, while adding padding. This function is useful for formatting table cells to ensure their contents are properly positioned, accommodating different alignment options (left, center, right for horizontal and top, middle, bottom for vertical).\n\nParameters:\n- string (str): The input string to format.\n- align (Tuple): A tuple defining the horizontal and vertical alignment, which can include \"left\", \"center\", \"right\" for horizontal and \"top\", \"middle\", \"bottom\" for vertical alignment.\n- inner_dimensions (Tuple): A tuple containing two integers representing the width and height to which the string should be expanded, exclusive of padding.\n- padding (Sequence[int]): A sequence of four integers specifying the number of space characters to use for padding on the left, right, top, and bottom sides.\n- space (str, optional): The character to use for padding; it defaults to a single space character.\n\nReturns:\n- List[str]: A list of strings representing the lines of the padded and aligned cell.\n\nDependencies:\n- This function leverages the `visible_width` function to calculate the visible width of lines to ensure proper alignment, especially for wide unicode characters. The handling of different line lengths and the adjustment of vertical space based on newlines is crucial for formatting multi-line strings effectively.\"\"\"\n    'Align a string horizontally and vertically. Also add additional padding in both dimensions.\\n\\n    :param str string: Input string to operate on.\\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\\n\\n    :return: Padded cell split into lines.\\n    :rtype: list\\n    '\n    if not hasattr(string, 'splitlines'):\n        string = str(string)\n    lines = string.splitlines() or ['']\n    if string.endswith('\\n'):\n        lines.append('')\n    if 'bottom' in align:\n        lines = [''] * (inner_dimensions[1] - len(lines) + padding[2]) + lines + [''] * padding[3]\n    elif 'middle' in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = [''] * (delta // 2 + delta % 2 + padding[2]) + lines + [''] * (delta // 2 + padding[3])\n    else:\n        lines = [''] * padding[2] + lines + [''] * (inner_dimensions[1] - len(lines) + padding[3])\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if 'right' in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + space * padding[1]\n        elif 'center' in align:\n            lines[i] = space * padding[0] + line.center(new_width, space) + space * padding[1]\n        else:\n            lines[i] = space * padding[0] + line.ljust(new_width + padding[1], space)\n    return lines",
        "docstring": "Aligns a given string both horizontally and vertically within specified dimensions, while adding padding. This function is useful for formatting table cells to ensure their contents are properly positioned, accommodating different alignment options (left, center, right for horizontal and top, middle, bottom for vertical).\n\nParameters:\n- string (str): The input string to format.\n- align (Tuple): A tuple defining the horizontal and vertical alignment, which can include \"left\", \"center\", \"right\" for horizontal and \"top\", \"middle\", \"bottom\" for vertical alignment.\n- inner_dimensions (Tuple): A tuple containing two integers representing the width and height to which the string should be expanded, exclusive of padding.\n- padding (Sequence[int]): A sequence of four integers specifying the number of space characters to use for padding on the left, right, top, and bottom sides.\n- space (str, optional): The character to use for padding; it defaults to a single space character.\n\nReturns:\n- List[str]: A list of strings representing the lines of the padded and aligned cell.\n\nDependencies:\n- This function leverages the `visible_width` function to calculate the visible width of lines to ensure proper alignment, especially for wide unicode characters. The handling of different line lengths and the adjustment of vertical space based on newlines is crucial for formatting multi-line strings effectively.",
        "signature": "def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:",
        "type": "Function",
        "class_signature": null
      },
      "max_dimensions": {
        "code": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n    \"\"\"Get the maximum widths of each column and maximum height of each row in a table given its data and padding specifications.\n\n:param iter table_data: A list of lists containing unmodified strings that represent the table data.\n:param int padding_left: The number of space characters to add as padding on the left side of each cell.\n:param int padding_right: The number of space characters to add as padding on the right side of each cell.\n:param int padding_top: The number of empty lines to add as padding on the top side of each cell.\n:param int padding_bottom: The number of empty lines to add as padding on the bottom side of each cell.\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column (excluding padding).\n    - inner_heights: A list of maximum heights for each row (excluding padding).\n    - outer_widths: A list of maximum widths for each column (including padding).\n    - outer_heights: A list of maximum heights for each row (including padding).\n:rtype: tuple\n\nThis function interacts with the `visible_width` function to compute the widths of cell contents accurately. It calculates the necessary dimensions based on the contents of each cell, accommodating for newlines and padding, and returns these values to assist in rendering a formatted table output.\"\"\"\n    'Get maximum widths of each column and maximum height of each row.\\n\\n    :param iter table_data: List of list of strings (unmodified table data).\\n    :param int padding_left: Number of space chars on left side of cell.\\n    :param int padding_right: Number of space chars on right side of cell.\\n    :param int padding_top: Number of empty lines on top side of cell.\\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\\n\\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\\n    :rtype: tuple\\n    '\n    inner_widths = [0] * (max((len(r) for r in table_data)) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, 'count') or not hasattr(cell, 'splitlines'):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count('\\n') + 1)\n            inner_widths[i] = max(inner_widths[i], *[visible_width(the_line) for the_line in cell.splitlines()])\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n    return (inner_widths, inner_heights, outer_widths, outer_heights)",
        "docstring": "Get the maximum widths of each column and maximum height of each row in a table given its data and padding specifications.\n\n:param iter table_data: A list of lists containing unmodified strings that represent the table data.\n:param int padding_left: The number of space characters to add as padding on the left side of each cell.\n:param int padding_right: The number of space characters to add as padding on the right side of each cell.\n:param int padding_top: The number of empty lines to add as padding on the top side of each cell.\n:param int padding_bottom: The number of empty lines to add as padding on the bottom side of each cell.\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column (excluding padding).\n    - inner_heights: A list of maximum heights for each row (excluding padding).\n    - outer_widths: A list of maximum widths for each column (including padding).\n    - outer_heights: A list of maximum heights for each row (including padding).\n:rtype: tuple\n\nThis function interacts with the `visible_width` function to compute the widths of cell contents accurately. It calculates the necessary dimensions based on the contents of each cell, accommodating for newlines and padding, and returns these values to assist in rendering a formatted table output.",
        "signature": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/base_table.py": {
      "BaseTable.__init__": {
        "code": "    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Initializes a BaseTable instance for creating a formatted table in the terminal.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list of lists of strings representing the table's rows and columns.\n- title (Optional[str]): An optional title to display at the top of the table.\n\nAttributes:\n- inner_column_border (bool): Indicates whether to show separators between columns (default: True).\n- inner_footing_row_border (bool): Indicates whether to show a border before the last row (default: False).\n- inner_heading_row_border (bool): Indicates whether to show a border after the first row (default: True).\n- inner_row_border (bool): Indicates whether to show a border between every row (default: False).\n- outer_border (bool): Indicates whether to show an outer border around the table (default: True).\n- justify_columns (dict): A dictionary for column justification (default: empty).\n- padding_left (int): Number of spaces to pad on the left side of each cell (default: 1).\n- padding_right (int): Number of spaces to pad on the right side of each cell (default: 1).\n\nThe constants defined at the class level are used for constructing table borders and separators, providing flexibility in styling the table's appearance throughout the methods.\"\"\"\n        'Constructor.\\n\\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\\n        :param title: Optional title to show within the top border of the table.\\n        '\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1",
        "docstring": "Initializes a BaseTable instance for creating a formatted table in the terminal.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list of lists of strings representing the table's rows and columns.\n- title (Optional[str]): An optional title to display at the top of the table.\n\nAttributes:\n- inner_column_border (bool): Indicates whether to show separators between columns (default: True).\n- inner_footing_row_border (bool): Indicates whether to show a border before the last row (default: False).\n- inner_heading_row_border (bool): Indicates whether to show a border after the first row (default: True).\n- inner_row_border (bool): Indicates whether to show a border between every row (default: False).\n- outer_border (bool): Indicates whether to show an outer border around the table (default: True).\n- justify_columns (dict): A dictionary for column justification (default: empty).\n- padding_left (int): Number of spaces to pad on the left side of each cell (default: 1).\n- padding_right (int): Number of spaces to pad on the right side of each cell (default: 1).\n\nThe constants defined at the class level are used for constructing table borders and separators, providing flexibility in styling the table's appearance throughout the methods.",
        "signature": "def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.horizontal_border": {
        "code": "    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Build a horizontal border for the table based on the specified style.\n\n    :param str style: The type of border to construct. It can be \"top\", \"bottom\", \"heading\", \"footing\", or \"row\".\n    :param iter outer_widths: A sequence of integers representing the widths (with padding) for each column.\n\n    :return: A tuple of strings representing the prepared border for the specified style.\n    :rtype: tuple\n\n    This method utilizes several class constants defined at the class level, such as CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_BOTTOM_HORIZONTAL, and others that define the visual representation of the borders depending on their styles. The constants are utilized to determine the characters used for the borders (e.g., vertical bars, horizontal lines, and intersection characters). The choice of characters and the inclusion of titles or intersections depends on the parameters passed and the table's configuration related to column borders and padding.\"\"\"\n        'Build any kind of horizontal border for the table.\\n\\n        :param str style: Type of border to return.\\n        :param iter outer_widths: List of widths (with padding) for each column.\\n\\n        :return: Prepared border as a tuple of strings.\\n        :rtype: tuple\\n        '\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)",
        "docstring": "Build a horizontal border for the table based on the specified style.\n\n:param str style: The type of border to construct. It can be \"top\", \"bottom\", \"heading\", \"footing\", or \"row\".\n:param iter outer_widths: A sequence of integers representing the widths (with padding) for each column.\n\n:return: A tuple of strings representing the prepared border for the specified style.\n:rtype: tuple\n\nThis method utilizes several class constants defined at the class level, such as CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_BOTTOM_HORIZONTAL, and others that define the visual representation of the borders depending on their styles. The constants are utilized to determine the characters used for the borders (e.g., vertical bars, horizontal lines, and intersection characters). The choice of characters and the inclusion of titles or intersections depends on the parameters passed and the table's configuration related to column borders and padding.",
        "signature": "def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_row_lines": {
        "code": "    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine cell content from a table row into printable lines with vertical borders. This method accounts for multi-line cells and aligns the content according to specified justification, returning the formatted lines ready for display.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row of the table containing cell values.\n- style (str): The type of border style to apply (e.g., \"heading\", \"footing\", or default row).\n- inner_widths (Sequence[int]): A sequence of integers denoting the widths of each column without padding.\n- height (int): The height of the row indicating how many lines each cell should expand to.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields a tuple of strings for each line of the row, which can be combined using ''.join().\n\nConstants used:\n- CHAR_H_OUTER_LEFT_VERTICAL, CHAR_H_INNER_VERTICAL, CHAR_H_OUTER_RIGHT_VERTICAL: Defined in the BaseTable class, these constants represent the characters used for vertical borders based on the current style (heading, footing, or row). They control the appearance of the table output.\"\"\"\n        \"Combine cells in row and group them into lines with vertical borders.\\n\\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\\n        newline character to the end of joined line.\\n\\n        In:\\n        ['Row One Column One', 'Two', 'Three']\\n        Out:\\n        [\\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\\n        ]\\n\\n        In:\\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\\n        Out:\\n        [\\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\\n        ]\\n\\n        :param iter row: One row in the table. List of cells.\\n        :param str style: Type of border characters to use.\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\\n\\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\\n        \"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)",
        "docstring": "Combine cell content from a table row into printable lines with vertical borders. This method accounts for multi-line cells and aligns the content according to specified justification, returning the formatted lines ready for display.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row of the table containing cell values.\n- style (str): The type of border style to apply (e.g., \"heading\", \"footing\", or default row).\n- inner_widths (Sequence[int]): A sequence of integers denoting the widths of each column without padding.\n- height (int): The height of the row indicating how many lines each cell should expand to.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields a tuple of strings for each line of the row, which can be combined using ''.join().\n\nConstants used:\n- CHAR_H_OUTER_LEFT_VERTICAL, CHAR_H_INNER_VERTICAL, CHAR_H_OUTER_RIGHT_VERTICAL: Defined in the BaseTable class, these constants represent the characters used for vertical borders based on the current style (heading, footing, or row). They control the appearance of the table output.",
        "signature": "def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_table": {
        "code": "    def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\nThis method generates the complete visual representation of the table, including borders and row separators. It leverages various attributes of the class, such as `outer_border`, `inner_heading_row_border`, and `inner_row_border`, to determine when and how to include borders.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be combined into a single string for output.\n\nThe method interacts with the `horizontal_border` method to create top, bottom, and internal row borders, and utilizes the `gen_row_lines` method to format each row. The constants defining border characters are accessed through attributes in the class, ensuring a cohesive output format.\"\"\"\n        'Combine everything and yield every line of the entire table with borders.\\n\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param iter inner_heights: List of heights (no padding) for each row.\\n        :param iter outer_widths: List of widths (with padding) for each column.\\n        :return:\\n        '\n        if self.outer_border:\n            yield self.horizontal_border('top', outer_widths)\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = (row_count - 1, row_count - 2)\n        for i, row in enumerate(self.table_data):\n            if self.inner_heading_row_border and i == 0:\n                style = 'heading'\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = 'footing'\n            else:\n                style = 'row'\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            if i == last_row_index:\n                break\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border('heading', outer_widths)\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border('footing', outer_widths)\n            elif self.inner_row_border:\n                yield self.horizontal_border('row', outer_widths)\n        if self.outer_border:\n            yield self.horizontal_border('bottom', outer_widths)",
        "docstring": "Combine everything and yield every line of the entire table with borders.\n\nThis method generates the complete visual representation of the table, including borders and row separators. It leverages various attributes of the class, such as `outer_border`, `inner_heading_row_border`, and `inner_row_border`, to determine when and how to include borders.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be combined into a single string for output.\n\nThe method interacts with the `horizontal_border` method to create top, bottom, and internal row borders, and utilizes the `gen_row_lines` method to format each row. The constants defining border characters are accessed through attributes in the class, ensuring a cohesive output format.",
        "signature": "def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.table": {
        "code": "    def table(self) -> str:\n        \"\"\"Return a formatted string representation of the entire table, suitable for terminal output.\n\nThis method computes the maximum dimensions for the table, taking into account any specified padding on the left and right sides, by calling the `max_dimensions` function. It then generates the table lines through the `gen_table` method and flattens the results into a single string using the `flatten` function.\n\nReturns:\n    str: A string that represents the complete table including borders and formatted rows, ready for display in a terminal.\n\nDependencies:\n- `max_dimensions`: Used to calculate the necessary dimensions of the table based on the content and padding.\n- `flatten`: Used to combine the generated table lines into a single formatted string.\n\nAttributes Utilized:\n- `self.table_data`: Contains the data to be displayed in the table.\n- `self.padding_left` and `self.padding_right`: Specify the padding for cell content, affecting the final string representation of the table.\"\"\"\n        'Return a large string of the entire table ready to be printed to the terminal.'\n        dimensions = max_dimensions(self.table_data, self.padding_left, self.padding_right)[:3]\n        return flatten(self.gen_table(*dimensions))",
        "docstring": "Return a formatted string representation of the entire table, suitable for terminal output.\n\nThis method computes the maximum dimensions for the table, taking into account any specified padding on the left and right sides, by calling the `max_dimensions` function. It then generates the table lines through the `gen_table` method and flattens the results into a single string using the `flatten` function.\n\nReturns:\n    str: A string that represents the complete table including borders and formatted rows, ready for display in a terminal.\n\nDependencies:\n- `max_dimensions`: Used to calculate the necessary dimensions of the table based on the content and padding.\n- `flatten`: Used to combine the generated table lines into a single formatted string.\n\nAttributes Utilized:\n- `self.table_data`: Contains the data to be displayed in the table.\n- `self.padding_left` and `self.padding_right`: Specify the padding for cell content, affecting the final string representation of the table.",
        "signature": "def table(self) -> str:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      }
    },
    "terminaltables3/other_tables.py": {
      "UnixTable.table": {
        "code": "    def table(self):\n        \"\"\"Return a formatted string representation of the entire table, optimized for display in Unix terminals.\n\nThis method overrides the `table` property from the superclass `AsciiTable`. It generates a large string that contains the entire table structure with box-drawing characters appropriate for Unix platforms. The method applies an optimization to remove unnecessary escape sequences (`\\\\033(B\\\\033(0`) from the standard output, ensuring that the table displays correctly without additional control characters.\n\nReturns:\n    str: A string representation of the table, ready to be printed to the terminal.\n\nDependencies:\n    - Inherits from `AsciiTable`, which contains the core functionality for building the table.\n    - Utilizes escape sequences defined as constants in the `UnixTable` class to draw borders and intersections of the table.\"\"\"\n        'Return a large string of the entire table ready to be printed to the terminal.'\n        ascii_table = super().table\n        optimized = ascii_table.replace('\\x1b(B\\x1b(0', '')\n        return optimized",
        "docstring": "Return a formatted string representation of the entire table, optimized for display in Unix terminals.\n\nThis method overrides the `table` property from the superclass `AsciiTable`. It generates a large string that contains the entire table structure with box-drawing characters appropriate for Unix platforms. The method applies an optimization to remove unnecessary escape sequences (`\\033(B\\033(0`) from the standard output, ensuring that the table displays correctly without additional control characters.\n\nReturns:\n    str: A string representation of the table, ready to be printed to the terminal.\n\nDependencies:\n    - Inherits from `AsciiTable`, which contains the core functionality for building the table.\n    - Utilizes escape sequences defined as constants in the `UnixTable` class to draw borders and intersections of the table.",
        "signature": "def table(self):",
        "type": "Method",
        "class_signature": "class UnixTable(AsciiTable):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: terminaltables-test_single_table\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u251c\u2500\u2500 base_table.py\n    \u2502   \u251c\u2500\u2500 BaseTable.__init__\n    \u2502   \u251c\u2500\u2500 BaseTable.gen_row_lines\n    \u2502   \u251c\u2500\u2500 BaseTable.gen_table\n    \u2502   \u251c\u2500\u2500 BaseTable.horizontal_border\n    \u2502   \u2514\u2500\u2500 BaseTable.table\n    \u251c\u2500\u2500 build.py\n    \u2502   \u251c\u2500\u2500 build_border\n    \u2502   \u251c\u2500\u2500 build_row\n    \u2502   \u251c\u2500\u2500 combine\n    \u2502   \u2514\u2500\u2500 flatten\n    \u251c\u2500\u2500 other_tables.py\n    \u2502   \u2514\u2500\u2500 UnixTable.table\n    \u2514\u2500\u2500 width_and_alignment.py\n        \u251c\u2500\u2500 align_and_pad_cell\n        \u251c\u2500\u2500 max_dimensions\n        \u2514\u2500\u2500 visible_width\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for rendering and formatting tabular data into visually appealing, console-compatible tables, specifically tailored for Linux and macOS environments. It supports creating tables with customizable column alignments, borders, and multi-line cells to enhance the readability of complex datasets in terminal applications. This enables developers and end-users to present structured data in an organized and legible manner directly within the terminal, avoiding the need for third-party tools or graphical interfaces. By simplifying table creation and styling, the module addresses the challenge of efficiently displaying tabular content in text-based environments.\n\n## FILE 1: terminaltables3/build.py\n\n- FUNCTION NAME: build_border\n  - SIGNATURE: def build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds a border for a table, optionally embedding a title if it fits within the left and right borders. The function constructs rows using specified characters for the left and right borders, column separators, and horizontal lines based on the outer column widths.\n\nParameters:\n- outer_widths (Sequence[int]): A list of integers representing the widths of each column.\n- horizontal (str): The character used to create horizontal lines across each column.\n- left (str): The character for the left border of the table.\n- intersect (str): The character used as a column separator between cells.\n- right (str): The character for the right border of the table.\n- title (Optional[str]): An optional string to overlay on the border. It will be hidden if it doesn't fit.\n\nReturns:\n- Generator of strings representing the constructed border. The output contains combined elements as per the specified formatting.\n\nDependencies:\n- The function relies on the `combine` function to yield formatted strings and the `visible_width` function to calculate the display width of the title, ensuring proper fitting between the borders.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: combine\n  - SIGNATURE: def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine items in a sequence with specified borders and separators, yielding a generator of combined objects. This is useful for formatting rows in a table, where `left` and `right` define the outer borders, and `intersect` serves as a separator between items. \n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A generator or iterator containing items to be combined.\n:param str left: The left border string to prepend.\n:param Optional[str] intersect: The string to insert between each item in `line`.\n:param str right: The right border string to append.\n\n:return: A generator that yields the combined strings, formatted according to the provided borders and separator.\n\"\"\"\n```\n\n- FUNCTION NAME: build_row\n  - SIGNATURE: def build_row(row, left, center, right):\n  - DOCSTRING: \n```python\n\"\"\"\nCombine single or multi-lined cells into a single formatted row with borders.\n\nThe function takes a list of cells, where each cell can contain one or more lines of text, and combines them into a formatted row with specified left and right borders and a center column separator. This output is generated for each row based on the cells' content.\n\n:param iter row: A list of cells for one row, where each cell is expected to be a list of strings representing its lines.\n:param str left: A string that represents the left border of the row.\n:param str center: A string that serves as the column separator between cells.\n:param str right: A string that represents the right border of the row.\n\n:yield: Produces a generator that yields strings representing the combined row.\n:rtype: iter\n\nDependency on the `combine` function is essential as it is responsible for formatting the output string by applying the provided borders and separators between cell contents. The function expects that each cell has been properly padded and extended, ensuring uniform line count across cells for proper display.\n\"\"\"\n```\n\n- FUNCTION NAME: flatten\n  - SIGNATURE: def flatten(table):\n  - DOCSTRING: \n```python\n\"\"\"\nFlatten a padded and bordered table into a single string, where each row is separated by a newline.\n\n:param iter table: An iterable containing rows of table data, which are expected to be lists of strings. Each row should be properly padded and bordered for visual alignment.\n\n:return: A single string representation of the table, with each row joined together and separated by newline characters.\n:rtype: str\n\nThis function interacts with the structure of the table data created by the `build_row` function. The output is suitable for display in a console or text interface, where the visual layout of the table is important.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/base_table.py:BaseTable:gen_table\n    - terminaltables3/build.py:combine\n\n## FILE 2: terminaltables3/width_and_alignment.py\n\n- FUNCTION NAME: align_and_pad_cell\n  - SIGNATURE: def align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nAligns a given string both horizontally and vertically within specified dimensions, while adding padding. This function is useful for formatting table cells to ensure their contents are properly positioned, accommodating different alignment options (left, center, right for horizontal and top, middle, bottom for vertical).\n\nParameters:\n- string (str): The input string to format.\n- align (Tuple): A tuple defining the horizontal and vertical alignment, which can include \"left\", \"center\", \"right\" for horizontal and \"top\", \"middle\", \"bottom\" for vertical alignment.\n- inner_dimensions (Tuple): A tuple containing two integers representing the width and height to which the string should be expanded, exclusive of padding.\n- padding (Sequence[int]): A sequence of four integers specifying the number of space characters to use for padding on the left, right, top, and bottom sides.\n- space (str, optional): The character to use for padding; it defaults to a single space character.\n\nReturns:\n- List[str]: A list of strings representing the lines of the padded and aligned cell.\n\nDependencies:\n- This function leverages the `visible_width` function to calculate the visible width of lines to ensure proper alignment, especially for wide unicode characters. The handling of different line lengths and the adjustment of vertical space based on newlines is crucial for formatting multi-line strings effectively.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: max_dimensions\n  - SIGNATURE: def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the maximum widths of each column and maximum height of each row in a table given its data and padding specifications.\n\n:param iter table_data: A list of lists containing unmodified strings that represent the table data.\n:param int padding_left: The number of space characters to add as padding on the left side of each cell.\n:param int padding_right: The number of space characters to add as padding on the right side of each cell.\n:param int padding_top: The number of empty lines to add as padding on the top side of each cell.\n:param int padding_bottom: The number of empty lines to add as padding on the bottom side of each cell.\n\n:return: A 4-item tuple containing:\n    - inner_widths: A list of maximum widths for each column (excluding padding).\n    - inner_heights: A list of maximum heights for each row (excluding padding).\n    - outer_widths: A list of maximum widths for each column (including padding).\n    - outer_heights: A list of maximum heights for each row (including padding).\n:rtype: tuple\n\nThis function interacts with the `visible_width` function to compute the widths of cell contents accurately. It calculates the necessary dimensions based on the contents of each cell, accommodating for newlines and padding, and returns these values to assist in rendering a formatted table output.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: visible_width\n  - SIGNATURE: def visible_width(string: str) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the visible width of a Unicode string, considering the varying byte sizes of characters, particularly East Asian characters. \n\nThis function removes ANSI color codes using the `RE_COLOR_ANSI` regular expression defined at the top of the code, ensuring that formatting does not affect the width calculation. It counts the visible width by checking each character's East Asian width classification, where Fullwidth (F) and Wide (W) characters contribute two units to the width, while all others contribute one.\n\nParameters:\n- string (str): The Unicode string for which to measure the visible width.\n\nReturns:\n- int: The calculated visible width of the input string, measured in character units.\n\nDependencies:\n- `RE_COLOR_ANSI`: A compiled regular expression pattern used to detect and remove ANSI color codes from the input string.\n- `unicodedata`: A standard library module used to classify Unicode characters based on their width.\n\"\"\"\n```\n\n## FILE 3: terminaltables3/base_table.py\n\n- CLASS METHOD: BaseTable.gen_row_lines\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine cell content from a table row into printable lines with vertical borders. This method accounts for multi-line cells and aligns the content according to specified justification, returning the formatted lines ready for display.\n\nParameters:\n- row (Sequence[str]): A sequence representing one row of the table containing cell values.\n- style (str): The type of border style to apply (e.g., \"heading\", \"footing\", or default row).\n- inner_widths (Sequence[int]): A sequence of integers denoting the widths of each column without padding.\n- height (int): The height of the row indicating how many lines each cell should expand to.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields a tuple of strings for each line of the row, which can be combined using ''.join().\n\nConstants used:\n- CHAR_H_OUTER_LEFT_VERTICAL, CHAR_H_INNER_VERTICAL, CHAR_H_OUTER_RIGHT_VERTICAL: Defined in the BaseTable class, these constants represent the characters used for vertical borders based on the current style (heading, footing, or row). They control the appearance of the table output.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.__init__\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a BaseTable instance for creating a formatted table in the terminal.\n\nParameters:\n- table_data (Sequence[Sequence[str]]): A list of lists of strings representing the table's rows and columns.\n- title (Optional[str]): An optional title to display at the top of the table.\n\nAttributes:\n- inner_column_border (bool): Indicates whether to show separators between columns (default: True).\n- inner_footing_row_border (bool): Indicates whether to show a border before the last row (default: False).\n- inner_heading_row_border (bool): Indicates whether to show a border after the first row (default: True).\n- inner_row_border (bool): Indicates whether to show a border between every row (default: False).\n- outer_border (bool): Indicates whether to show an outer border around the table (default: True).\n- justify_columns (dict): A dictionary for column justification (default: empty).\n- padding_left (int): Number of spaces to pad on the left side of each cell (default: 1).\n- padding_right (int): Number of spaces to pad on the right side of each cell (default: 1).\n\nThe constants defined at the class level are used for constructing table borders and separators, providing flexibility in styling the table's appearance throughout the methods.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.horizontal_border\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nBuild a horizontal border for the table based on the specified style.\n\n:param str style: The type of border to construct. It can be \"top\", \"bottom\", \"heading\", \"footing\", or \"row\".\n:param iter outer_widths: A sequence of integers representing the widths (with padding) for each column.\n\n:return: A tuple of strings representing the prepared border for the specified style.\n:rtype: tuple\n\nThis method utilizes several class constants defined at the class level, such as CHAR_OUTER_TOP_HORIZONTAL, CHAR_OUTER_BOTTOM_HORIZONTAL, and others that define the visual representation of the borders depending on their styles. The constants are utilized to determine the characters used for the borders (e.g., vertical bars, horizontal lines, and intersection characters). The choice of characters and the inclusion of titles or intersections depends on the parameters passed and the table's configuration related to column borders and padding.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.gen_table\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine everything and yield every line of the entire table with borders.\n\nThis method generates the complete visual representation of the table, including borders and row separators. It leverages various attributes of the class, such as `outer_border`, `inner_heading_row_border`, and `inner_row_border`, to determine when and how to include borders.\n\nParameters:\n- inner_widths (Sequence[int]): List of widths (without padding) for each column.\n- inner_heights (Sequence[int]): List of heights (without padding) for each row.\n- outer_widths (Sequence[int]): List of widths (with padding) for each column.\n\nReturns:\n- Generator[Tuple[str, ...], None, None]: Yields lines of the table as tuples of strings, which can be combined into a single string for output.\n\nThe method interacts with the `horizontal_border` method to create top, bottom, and internal row borders, and utilizes the `gen_row_lines` method to format each row. The constants defining border characters are accessed through attributes in the class, ensuring a cohesive output format.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.table\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def table(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a formatted string representation of the entire table, suitable for terminal output.\n\nThis method computes the maximum dimensions for the table, taking into account any specified padding on the left and right sides, by calling the `max_dimensions` function. It then generates the table lines through the `gen_table` method and flattens the results into a single string using the `flatten` function.\n\nReturns:\n    str: A string that represents the complete table including borders and formatted rows, ready for display in a terminal.\n\nDependencies:\n- `max_dimensions`: Used to calculate the necessary dimensions of the table based on the content and padding.\n- `flatten`: Used to combine the generated table lines into a single formatted string.\n\nAttributes Utilized:\n- `self.table_data`: Contains the data to be displayed in the table.\n- `self.padding_left` and `self.padding_right`: Specify the padding for cell content, affecting the final string representation of the table.\n\"\"\"\n```\n\n## FILE 4: terminaltables3/other_tables.py\n\n- CLASS METHOD: UnixTable.table\n  - CLASS SIGNATURE: class UnixTable(AsciiTable):\n  - SIGNATURE: def table(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a formatted string representation of the entire table, optimized for display in Unix terminals.\n\nThis method overrides the `table` property from the superclass `AsciiTable`. It generates a large string that contains the entire table structure with box-drawing characters appropriate for Unix platforms. The method applies an optimization to remove unnecessary escape sequences (`\\033(B\\033(0`) from the standard output, ensuring that the table displays correctly without additional control characters.\n\nReturns:\n    str: A string representation of the table, ready to be printed to the terminal.\n\nDependencies:\n    - Inherits from `AsciiTable`, which contains the core functionality for building the table.\n    - Utilizes escape sequences defined as constants in the `UnixTable` class to draw borders and intersections of the table.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\nfrom typing import Generator, Iterator, Optional, Sequence, Union\nfrom terminaltables3.width_and_alignment import visible_width",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\nfrom terminaltables3.terminal_io import terminal_size\nRE_COLOR_ANSI = re.compile('(\\\\033\\\\[[\\\\d;]+m)')\n\ndef column_max_width(inner_widths: Sequence[int], column_number: int, outer_border: int, inner_border: int, padding: int) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n    data_space = sum(inner_widths) - inner_widths[column_number]\n    return terminal_width - data_space - non_data_space\n\ndef table_width(outer_widths: Sequence[int], outer_border: int, inner_border: int) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n    data_space = sum(outer_widths)\n    return data_space + non_data_space",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\nfrom typing import Generator, Optional, Sequence, Tuple\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '-'\n    CHAR_F_INNER_INTERSECT = '+'\n    CHAR_F_INNER_VERTICAL = '|'\n    CHAR_F_OUTER_LEFT_INTERSECT = '+'\n    CHAR_F_OUTER_LEFT_VERTICAL = '|'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_H_INNER_HORIZONTAL = '-'\n    CHAR_H_INNER_INTERSECT = '+'\n    CHAR_H_INNER_VERTICAL = '|'\n    CHAR_H_OUTER_LEFT_INTERSECT = '+'\n    CHAR_H_OUTER_LEFT_VERTICAL = '|'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_INNER_HORIZONTAL = '-'\n    CHAR_INNER_INTERSECT = '+'\n    CHAR_INNER_VERTICAL = '|'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '-'\n    CHAR_OUTER_BOTTOM_INTERSECT = '+'\n    CHAR_OUTER_BOTTOM_LEFT = '+'\n    CHAR_OUTER_BOTTOM_RIGHT = '+'\n    CHAR_OUTER_LEFT_INTERSECT = '+'\n    CHAR_OUTER_LEFT_VERTICAL = '|'\n    CHAR_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_OUTER_TOP_HORIZONTAL = '-'\n    CHAR_OUTER_TOP_INTERSECT = '+'\n    CHAR_OUTER_TOP_LEFT = '+'\n    CHAR_OUTER_TOP_RIGHT = '+'",
    "terminaltables3/other_tables.py": "\"\"\"Additional simple tables defined here.\"\"\"\nfrom terminaltables3.ascii_table import AsciiTable\nfrom terminaltables3.terminal_io import IS_WINDOWS\n\nclass UnixTable(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Unix platforms. Table borders won't have any gaps between lines.\n\n    Similar to the tables shown on PC BIOS boot messages, but not double-lined.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '\\x1b(0q\\x1b(B'\n    CHAR_F_INNER_INTERSECT = '\\x1b(0n\\x1b(B'\n    CHAR_F_INNER_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_F_OUTER_LEFT_INTERSECT = '\\x1b(0t\\x1b(B'\n    CHAR_F_OUTER_LEFT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '\\x1b(0u\\x1b(B'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_H_INNER_HORIZONTAL = '\\x1b(0q\\x1b(B'\n    CHAR_H_INNER_INTERSECT = '\\x1b(0n\\x1b(B'\n    CHAR_H_INNER_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_H_OUTER_LEFT_INTERSECT = '\\x1b(0t\\x1b(B'\n    CHAR_H_OUTER_LEFT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '\\x1b(0u\\x1b(B'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_INNER_HORIZONTAL = '\\x1b(0q\\x1b(B'\n    CHAR_INNER_INTERSECT = '\\x1b(0n\\x1b(B'\n    CHAR_INNER_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '\\x1b(0q\\x1b(B'\n    CHAR_OUTER_BOTTOM_INTERSECT = '\\x1b(0v\\x1b(B'\n    CHAR_OUTER_BOTTOM_LEFT = '\\x1b(0m\\x1b(B'\n    CHAR_OUTER_BOTTOM_RIGHT = '\\x1b(0j\\x1b(B'\n    CHAR_OUTER_LEFT_INTERSECT = '\\x1b(0t\\x1b(B'\n    CHAR_OUTER_LEFT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_OUTER_RIGHT_INTERSECT = '\\x1b(0u\\x1b(B'\n    CHAR_OUTER_RIGHT_VERTICAL = '\\x1b(0x\\x1b(B'\n    CHAR_OUTER_TOP_HORIZONTAL = '\\x1b(0q\\x1b(B'\n    CHAR_OUTER_TOP_INTERSECT = '\\x1b(0w\\x1b(B'\n    CHAR_OUTER_TOP_LEFT = '\\x1b(0l\\x1b(B'\n    CHAR_OUTER_TOP_RIGHT = '\\x1b(0k\\x1b(B'\n\nclass WindowsTable(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Windows platforms. This uses Code Page 437. Single-line borders.\n\n    From: http://en.wikipedia.org/wiki/Code_page_437#Characters\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = b'\\xc4'.decode('ibm437')\n    CHAR_F_INNER_INTERSECT = b'\\xc5'.decode('ibm437')\n    CHAR_F_INNER_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_F_OUTER_LEFT_INTERSECT = b'\\xc3'.decode('ibm437')\n    CHAR_F_OUTER_LEFT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_F_OUTER_RIGHT_INTERSECT = b'\\xb4'.decode('ibm437')\n    CHAR_F_OUTER_RIGHT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_H_INNER_HORIZONTAL = b'\\xc4'.decode('ibm437')\n    CHAR_H_INNER_INTERSECT = b'\\xc5'.decode('ibm437')\n    CHAR_H_INNER_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_H_OUTER_LEFT_INTERSECT = b'\\xc3'.decode('ibm437')\n    CHAR_H_OUTER_LEFT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_H_OUTER_RIGHT_INTERSECT = b'\\xb4'.decode('ibm437')\n    CHAR_H_OUTER_RIGHT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_INNER_HORIZONTAL = b'\\xc4'.decode('ibm437')\n    CHAR_INNER_INTERSECT = b'\\xc5'.decode('ibm437')\n    CHAR_INNER_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_HORIZONTAL = b'\\xc4'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_INTERSECT = b'\\xc1'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_LEFT = b'\\xc0'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_RIGHT = b'\\xd9'.decode('ibm437')\n    CHAR_OUTER_LEFT_INTERSECT = b'\\xc3'.decode('ibm437')\n    CHAR_OUTER_LEFT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_OUTER_RIGHT_INTERSECT = b'\\xb4'.decode('ibm437')\n    CHAR_OUTER_RIGHT_VERTICAL = b'\\xb3'.decode('ibm437')\n    CHAR_OUTER_TOP_HORIZONTAL = b'\\xc4'.decode('ibm437')\n    CHAR_OUTER_TOP_INTERSECT = b'\\xc2'.decode('ibm437')\n    CHAR_OUTER_TOP_LEFT = b'\\xda'.decode('ibm437')\n    CHAR_OUTER_TOP_RIGHT = b'\\xbf'.decode('ibm437')\n\nclass WindowsTableDouble(AsciiTable):\n    \"\"\"Draw a table using box-drawing characters on Windows platforms. This uses Code Page 437. Double-line borders.\"\"\"\n    CHAR_F_INNER_HORIZONTAL = b'\\xcd'.decode('ibm437')\n    CHAR_F_INNER_INTERSECT = b'\\xce'.decode('ibm437')\n    CHAR_F_INNER_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_F_OUTER_LEFT_INTERSECT = b'\\xcc'.decode('ibm437')\n    CHAR_F_OUTER_LEFT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_F_OUTER_RIGHT_INTERSECT = b'\\xb9'.decode('ibm437')\n    CHAR_F_OUTER_RIGHT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_H_INNER_HORIZONTAL = b'\\xcd'.decode('ibm437')\n    CHAR_H_INNER_INTERSECT = b'\\xce'.decode('ibm437')\n    CHAR_H_INNER_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_H_OUTER_LEFT_INTERSECT = b'\\xcc'.decode('ibm437')\n    CHAR_H_OUTER_LEFT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_H_OUTER_RIGHT_INTERSECT = b'\\xb9'.decode('ibm437')\n    CHAR_H_OUTER_RIGHT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_INNER_HORIZONTAL = b'\\xcd'.decode('ibm437')\n    CHAR_INNER_INTERSECT = b'\\xce'.decode('ibm437')\n    CHAR_INNER_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_HORIZONTAL = b'\\xcd'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_INTERSECT = b'\\xca'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_LEFT = b'\\xc8'.decode('ibm437')\n    CHAR_OUTER_BOTTOM_RIGHT = b'\\xbc'.decode('ibm437')\n    CHAR_OUTER_LEFT_INTERSECT = b'\\xcc'.decode('ibm437')\n    CHAR_OUTER_LEFT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_OUTER_RIGHT_INTERSECT = b'\\xb9'.decode('ibm437')\n    CHAR_OUTER_RIGHT_VERTICAL = b'\\xba'.decode('ibm437')\n    CHAR_OUTER_TOP_HORIZONTAL = b'\\xcd'.decode('ibm437')\n    CHAR_OUTER_TOP_INTERSECT = b'\\xcb'.decode('ibm437')\n    CHAR_OUTER_TOP_LEFT = b'\\xc9'.decode('ibm437')\n    CHAR_OUTER_TOP_RIGHT = b'\\xbb'.decode('ibm437')\n\nclass SingleTable(WindowsTable if IS_WINDOWS else UnixTable):\n    \"\"\"Cross-platform table with single-line box-drawing characters.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\nclass DoubleTable(WindowsTableDouble):\n    \"\"\"Cross-platform table with box-drawing characters. On Windows it's double borders, on Linux/OSX it's unicode.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\nclass PorcelainTable(AsciiTable):\n    \"\"\"An AsciiTable stripped to a minimum.\n\n    Meant to be machine passable and roughly follow format set by git --porcelain option (hence the name).\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    \"\"\"\n\n    def __init__(self, table_data):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        \"\"\"\n        super().__init__(table_data)\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = False\n        self.outer_border = False"
  },
  "call_tree": {
    "tests/test_all_tables_e2e/test_single_table.py:test_single_line": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/other_tables.py:UnixTable:table": {
        "terminaltables3/base_table.py:BaseTable:table": {
          "terminaltables3/width_and_alignment.py:max_dimensions": {
            "terminaltables3/width_and_alignment.py:visible_width": {}
          },
          "terminaltables3/build.py:flatten": {
            "terminaltables3/base_table.py:BaseTable:gen_table": {
              "terminaltables3/base_table.py:BaseTable:horizontal_border": {
                "terminaltables3/build.py:build_border": {
                  "terminaltables3/width_and_alignment.py:visible_width": {}
                }
              },
              "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
                "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
                  "terminaltables3/width_and_alignment.py:visible_width": {}
                },
                "terminaltables3/build.py:build_row": {}
              }
            },
            "terminaltables3/build.py:combine": {}
          }
        }
      }
    },
    "tests/test_all_tables_e2e/test_single_table.py:test_multi_line": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/other_tables.py:UnixTable:table": {
        "terminaltables3/base_table.py:BaseTable:table": {
          "terminaltables3/width_and_alignment.py:max_dimensions": {
            "terminaltables3/width_and_alignment.py:visible_width": {}
          },
          "terminaltables3/build.py:flatten": {
            "terminaltables3/base_table.py:BaseTable:gen_table": {
              "terminaltables3/base_table.py:BaseTable:horizontal_border": {
                "terminaltables3/build.py:build_border": {}
              },
              "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
                "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
                  "terminaltables3/width_and_alignment.py:visible_width": {}
                },
                "terminaltables3/build.py:build_row": {}
              }
            },
            "terminaltables3/build.py:combine": {}
          }
        }
      }
    }
  }
}