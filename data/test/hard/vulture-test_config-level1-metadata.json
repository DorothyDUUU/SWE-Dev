{
  "dir_path": "/app/vulture",
  "package_name": "vulture",
  "sample_name": "vulture-test_config",
  "src_dir": "vulture/",
  "test_dir": "tests/",
  "test_file": "tests/test_config.py",
  "test_code": "\"\"\"\nUnit tests for config file and CLI argument parsing.\n\"\"\"\n\nfrom io import BytesIO\nimport pathlib\nfrom textwrap import dedent\n\nimport pytest\n\nfrom vulture.config import (\n    DEFAULTS,\n    _check_input_config,\n    _parse_args,\n    _parse_toml,\n    make_config,\n    InputError,\n)\n\n\ndef get_toml_bytes(toml_str: str) -> BytesIO:\n    \"\"\"\n    Wrap a string in BytesIO to play the role of the incoming config stream.\n    \"\"\"\n    return BytesIO(bytes(toml_str, \"utf-8\"))\n\n\ndef test_cli_args():\n    \"\"\"\n    Ensure that CLI arguments are converted to a config object.\n    \"\"\"\n    expected = dict(\n        paths=[\"path1\", \"path2\"],\n        exclude=[\"file*.py\", \"dir/\"],\n        ignore_decorators=[\"deco1\", \"deco2\"],\n        ignore_names=[\"name1\", \"name2\"],\n        config=\"pyproject.toml\",\n        make_whitelist=True,\n        min_confidence=10,\n        sort_by_size=True,\n        verbose=True,\n    )\n    result = _parse_args(\n        [\n            \"--exclude=file*.py,dir/\",\n            \"--ignore-decorators=deco1,deco2\",\n            \"--ignore-names=name1,name2\",\n            \"--make-whitelist\",\n            \"--min-confidence=10\",\n            \"--sort-by-size\",\n            \"--verbose\",\n            \"path1\",\n            \"path2\",\n        ]\n    )\n    assert isinstance(result, dict)\n    assert result == expected\n\n\ndef test_toml_config():\n    \"\"\"\n    Ensure parsing of TOML files results in a valid config object.\n    \"\"\"\n    expected = dict(\n        paths=[\"path1\", \"path2\"],\n        exclude=[\"file*.py\", \"dir/\"],\n        ignore_decorators=[\"deco1\", \"deco2\"],\n        ignore_names=[\"name1\", \"name2\"],\n        make_whitelist=True,\n        min_confidence=10,\n        sort_by_size=True,\n        verbose=True,\n    )\n    data = get_toml_bytes(\n        dedent(\n            \"\"\"\\\n        [tool.vulture]\n        exclude = [\"file*.py\", \"dir/\"]\n        ignore_decorators = [\"deco1\", \"deco2\"]\n        ignore_names = [\"name1\", \"name2\"]\n        make_whitelist = true\n        min_confidence = 10\n        sort_by_size = true\n        verbose = true\n        paths = [\"path1\", \"path2\"]\n        \"\"\"\n        )\n    )\n    result = _parse_toml(data)\n    assert isinstance(result, dict)\n    assert result == expected\n\n\ndef test_toml_config_with_heterogenous_array():\n    \"\"\"\n    Ensure parsing of TOML files results in a valid config object, even if some\n    other part of the file contains an array of mixed types.\n    \"\"\"\n    expected = dict(\n        paths=[\"path1\", \"path2\"],\n        exclude=[\"file*.py\", \"dir/\"],\n        ignore_decorators=[\"deco1\", \"deco2\"],\n        ignore_names=[\"name1\", \"name2\"],\n        make_whitelist=True,\n        min_confidence=10,\n        sort_by_size=True,\n        verbose=True,\n    )\n    data = get_toml_bytes(\n        dedent(\n            \"\"\"\\\n        [tool.foo]\n        # comment for good measure\n        problem_array = [{a = 1}, [2,3,4], \"foo\"]\n\n        [tool.vulture]\n        exclude = [\"file*.py\", \"dir/\"]\n        ignore_decorators = [\"deco1\", \"deco2\"]\n        ignore_names = [\"name1\", \"name2\"]\n        make_whitelist = true\n        min_confidence = 10\n        sort_by_size = true\n        verbose = true\n        paths = [\"path1\", \"path2\"]\n        \"\"\"\n        )\n    )\n    result = _parse_toml(data)\n    assert isinstance(result, dict)\n    assert result == expected\n\n\ndef test_config_merging():\n    \"\"\"\n    If we have both CLI args and a ``pyproject.toml`` file, the CLI args should\n    have precedence.\n    \"\"\"\n    toml = get_toml_bytes(\n        dedent(\n            \"\"\"\\\n        [tool.vulture]\n        exclude = [\"toml_exclude\"]\n        ignore_decorators = [\"toml_deco\"]\n        ignore_names = [\"toml_name\"]\n        make_whitelist = false\n        min_confidence = 10\n        sort_by_size = false\n        verbose = false\n        paths = [\"toml_path\"]\n        \"\"\"\n        )\n    )\n    cliargs = [\n        \"--exclude=cli_exclude\",\n        \"--ignore-decorators=cli_deco\",\n        \"--ignore-names=cli_name\",\n        \"--make-whitelist\",\n        \"--min-confidence=20\",\n        \"--sort-by-size\",\n        \"--verbose\",\n        \"cli_path\",\n    ]\n    result = make_config(cliargs, toml)\n    expected = dict(\n        paths=[\"cli_path\"],\n        exclude=[\"cli_exclude\"],\n        ignore_decorators=[\"cli_deco\"],\n        ignore_names=[\"cli_name\"],\n        config=\"pyproject.toml\",\n        make_whitelist=True,\n        min_confidence=20,\n        sort_by_size=True,\n        verbose=True,\n    )\n    assert result == expected\n\n\ndef test_toml_config_custom_path():\n    \"\"\"\n    Ensure that TOML pyproject.toml files can be read from a custom path,\n    other than the current working directory.\n\n    Test file is in tests/toml/mock_pyproject.toml\n    \"\"\"\n    here = pathlib.Path(__file__).parent\n    tomlfile_path = here.joinpath(\"toml\", \"mock_pyproject.toml\")\n    cliargs = [\n        f\"--config={tomlfile_path}\",\n        \"cli_path\",\n    ]\n    result = make_config(cliargs)\n    assert result[\"ignore_names\"] == [\"name_from_toml_file\"]\n\n\ndef test_config_merging_missing():\n    \"\"\"\n    If we have set a boolean value in the TOML file, but not on the CLI, we\n    want the TOML value to be taken.\n    \"\"\"\n    toml = get_toml_bytes(\n        dedent(\n            \"\"\"\\\n        [tool.vulture]\n        verbose = true\n        ignore_names = [\"name1\"]\n        \"\"\"\n        )\n    )\n    cliargs = [\n        \"cli_path\",\n    ]\n    result = make_config(cliargs, toml)\n    assert result[\"verbose\"] is True\n    assert result[\"ignore_names\"] == [\"name1\"]\n\n\ndef test_config_merging_toml_paths_only():\n    \"\"\"\n    If we have paths in the TOML but not on the CLI, the TOML paths should be\n    used.\n    \"\"\"\n    toml = get_toml_bytes(\n        dedent(\n            \"\"\"\\\n        [tool.vulture]\n        paths = [\"path1\", \"path2\"]\n        \"\"\"\n        )\n    )\n    cliargs = [\n        \"--exclude=test_*.py\",\n    ]\n    result = make_config(cliargs, toml)\n    assert result[\"paths\"] == [\"path1\", \"path2\"]\n    assert result[\"exclude\"] == [\"test_*.py\"]\n\n\ndef test_invalid_config_options_output():\n    \"\"\"\n    If the config file contains unknown options we want to abort.\n    \"\"\"\n\n    with pytest.raises(InputError):\n        _check_input_config({\"unknown_key_1\": 1})\n\n\n@pytest.mark.parametrize(\"key, value\", list(DEFAULTS.items()))\ndef test_incompatible_option_type(key, value):\n    \"\"\"\n    If a config value has a different type from the default value we abort.\n    \"\"\"\n    wrong_types = {int, str, list, bool} - {type(value)}\n    for wrong_type in wrong_types:\n        test_value = wrong_type()\n        with pytest.raises(InputError):\n            _check_input_config({key: test_value})\n\n\ndef test_missing_paths():\n    \"\"\"\n    If the script is run without any paths, we want to abort.\n    \"\"\"\n    with pytest.raises(InputError):\n        make_config([])\n",
  "GT_file_code": {
    "vulture/config.py": "\"\"\"\nThis module handles retrieval of configuration values from either the\ncommand-line arguments or the pyproject.toml file.\n\"\"\"\nimport argparse\nimport pathlib\n\ntry:\n    import tomllib\nexcept ModuleNotFoundError:\n    import tomli as tomllib\n\nfrom .version import __version__\n\n#: Possible configuration options and their respective defaults\nDEFAULTS = {\n    \"config\": \"pyproject.toml\",\n    \"min_confidence\": 0,\n    \"paths\": [],\n    \"exclude\": [],\n    \"ignore_decorators\": [],\n    \"ignore_names\": [],\n    \"make_whitelist\": False,\n    \"sort_by_size\": False,\n    \"verbose\": False,\n}\n\n\nclass InputError(Exception):\n    def __init__(self, message):\n        self.message = message\n\n\ndef _check_input_config(data):\n    \"\"\"\n    Checks the types of the values in *data* against the expected types of\n    config-values. If a value has the wrong type, raise an InputError.\n    \"\"\"\n    for key, value in data.items():\n        if key not in DEFAULTS:\n            raise InputError(f\"Unknown configuration key: {key}\")\n        # The linter suggests to use \"isinstance\" here but this fails to\n        # detect the difference between `int` and `bool`.\n        if type(value) is not type(DEFAULTS[key]):  # noqa: E721\n            expected_type = type(DEFAULTS[key]).__name__\n            raise InputError(f\"Data type for {key} must be {expected_type!r}\")\n\n\ndef _check_output_config(config):\n    \"\"\"\n    Run sanity checks on the generated config after all parsing and\n    preprocessing is done.\n\n    Raise InputError if an error is encountered.\n    \"\"\"\n    if not config[\"paths\"]:\n        raise InputError(\"Please pass at least one file or directory\")\n\n\ndef _parse_toml(infile):\n    \"\"\"\n    Parse a TOML file for config values.\n\n    It will search for a section named ``[tool.vulture]`` which contains the\n    same keys as the CLI arguments seen with ``--help``. All leading dashes are\n    removed and other dashes are replaced by underscores (so ``--sort-by-size``\n    becomes ``sort_by_size``).\n\n    Arguments containing multiple values are standard TOML lists.\n\n    Example::\n\n        [tool.vulture]\n        exclude = [\"file*.py\", \"dir/\"]\n        ignore_decorators = [\"deco1\", \"deco2\"]\n        ignore_names = [\"name1\", \"name2\"]\n        make_whitelist = true\n        min_confidence = 10\n        sort_by_size = true\n        verbose = true\n        paths = [\"path1\", \"path2\"]\n    \"\"\"\n    data = tomllib.load(infile)\n    settings = data.get(\"tool\", {}).get(\"vulture\", {})\n    _check_input_config(settings)\n    return settings\n\n\ndef _parse_args(args=None):\n    \"\"\"\n    Parse CLI arguments.\n\n    :param args: A list of strings representing the CLI arguments. If left to\n        the default, this will default to ``sys.argv``.\n    \"\"\"\n\n    # Sentinel value to distinguish between \"False\" and \"no default given\".\n    missing = object()\n\n    def csv(exclude):\n        return exclude.split(\",\")\n\n    usage = \"%(prog)s [options] [PATH ...]\"\n    version = f\"vulture {__version__}\"\n    glob_help = \"Patterns may contain glob wildcards (*, ?, [abc], [!abc]).\"\n    parser = argparse.ArgumentParser(prog=\"vulture\", usage=usage)\n    parser.add_argument(\n        \"paths\",\n        nargs=\"*\",\n        metavar=\"PATH\",\n        default=missing,\n        help=\"Paths may be Python files or directories. For each directory\"\n        \" Vulture analyzes all contained *.py files.\",\n    )\n    parser.add_argument(\n        \"--exclude\",\n        metavar=\"PATTERNS\",\n        type=csv,\n        default=missing,\n        help=f\"Comma-separated list of path patterns to ignore (e.g.,\"\n        f' \"*settings.py,docs,*/test_*.py,venv\"). {glob_help} A PATTERN'\n        f\" without glob wildcards is treated as *PATTERN*. Patterns are\"\n        f\" matched against absolute paths.\",\n    )\n    parser.add_argument(\n        \"--ignore-decorators\",\n        metavar=\"PATTERNS\",\n        type=csv,\n        default=missing,\n        help=f\"Comma-separated list of decorators. Functions and classes using\"\n        f' these decorators are ignored (e.g., \"@app.route,@require_*\").'\n        f\" {glob_help}\",\n    )\n    parser.add_argument(\n        \"--ignore-names\",\n        metavar=\"PATTERNS\",\n        type=csv,\n        default=missing,\n        help=f'Comma-separated list of names to ignore (e.g., \"visit_*,do_*\").'\n        f\" {glob_help}\",\n    )\n    parser.add_argument(\n        \"--make-whitelist\",\n        action=\"store_true\",\n        default=missing,\n        help=\"Report unused code in a format that can be added to a\"\n        \" whitelist module.\",\n    )\n    parser.add_argument(\n        \"--min-confidence\",\n        type=int,\n        default=missing,\n        help=\"Minimum confidence (between 0 and 100) for code to be\"\n        \" reported as unused.\",\n    )\n    parser.add_argument(\n        \"--sort-by-size\",\n        action=\"store_true\",\n        default=missing,\n        help=\"Sort unused functions and classes by their lines of code.\",\n    )\n    parser.add_argument(\n        \"--config\",\n        type=str,\n        default=\"pyproject.toml\",\n        help=\"Path to pyproject.toml config file.\",\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", default=missing\n    )\n    parser.add_argument(\"--version\", action=\"version\", version=version)\n    namespace = parser.parse_args(args)\n    cli_args = {\n        key: value\n        for key, value in vars(namespace).items()\n        if value is not missing\n    }\n    _check_input_config(cli_args)\n    return cli_args\n\n\ndef make_config(argv=None, tomlfile=None):\n    \"\"\"\n    Returns a config object for vulture, merging both ``pyproject.toml`` and\n    CLI arguments (CLI arguments have precedence).\n\n    :param argv: The CLI arguments to be parsed. This value is transparently\n        passed through to :py:meth:`argparse.ArgumentParser.parse_args`.\n    :param tomlfile: An IO instance containing TOML data. By default this will\n        auto-detect an existing ``pyproject.toml`` file and exists solely for\n        unit-testing.\n    \"\"\"\n\n    # Parse CLI first to skip sanity checks when --version or --help is given.\n    cli_config = _parse_args(argv)\n\n    # If we loaded data from a TOML file, we want to print this out on stdout\n    # in verbose mode so we need to keep the value around.\n    detected_toml_path = \"\"\n\n    if tomlfile:\n        config = _parse_toml(tomlfile)\n        detected_toml_path = str(tomlfile)\n    else:\n        toml_path = pathlib.Path(cli_config[\"config\"]).resolve()\n        if toml_path.is_file():\n            with open(toml_path, \"rb\") as fconfig:\n                config = _parse_toml(fconfig)\n            detected_toml_path = str(toml_path)\n        else:\n            config = {}\n\n    # Overwrite TOML options with CLI options, if given.\n    config.update(cli_config)\n\n    # Set defaults for missing options.\n    for key, value in DEFAULTS.items():\n        config.setdefault(key, value)\n\n    if detected_toml_path and config[\"verbose\"]:\n        print(f\"Reading configuration from {detected_toml_path}\")\n\n    _check_output_config(config)\n\n    return config\n"
  },
  "GT_src_dict": {
    "vulture/config.py": {
      "_check_input_config": {
        "code": "def _check_input_config(data):\n    \"\"\"Checks the types of values in the provided configuration *data* against expected types defined in the DEFAULTS dictionary. Raises an InputError if an unknown configuration key is encountered or if a value has the wrong type. \n\nParameters:\n- data (dict): A dictionary containing configuration key-value pairs to be validated, where keys should match those in DEFAULTS.\n\nRaises:\n- InputError: If any key in *data* is not recognized or if the type of a value does not match the expected type.\n\nDependencies:\n- The function relies on the DEFAULTS constant, which defines valid configuration keys along with their expected types. The InputError class is used for raising exceptions related to invalid inputs.\"\"\"\n    '\\n    Checks the types of the values in *data* against the expected types of\\n    config-values. If a value has the wrong type, raise an InputError.\\n    '\n    for key, value in data.items():\n        if key not in DEFAULTS:\n            raise InputError(f'Unknown configuration key: {key}')\n        if type(value) is not type(DEFAULTS[key]):\n            expected_type = type(DEFAULTS[key]).__name__\n            raise InputError(f'Data type for {key} must be {expected_type!r}')",
        "docstring": "Checks the types of values in the provided configuration *data* against expected types defined in the DEFAULTS dictionary. Raises an InputError if an unknown configuration key is encountered or if a value has the wrong type. \n\nParameters:\n- data (dict): A dictionary containing configuration key-value pairs to be validated, where keys should match those in DEFAULTS.\n\nRaises:\n- InputError: If any key in *data* is not recognized or if the type of a value does not match the expected type.\n\nDependencies:\n- The function relies on the DEFAULTS constant, which defines valid configuration keys along with their expected types. The InputError class is used for raising exceptions related to invalid inputs.",
        "signature": "def _check_input_config(data):",
        "type": "Function",
        "class_signature": null
      },
      "_parse_toml": {
        "code": "def _parse_toml(infile):\n    \"\"\"Parse a TOML file for configuration values specific to the Vulture tool.\n\nThis function reads a TOML file and retrieves configuration settings defined \nunder the `[tool.vulture]` section. It expects the keys to match the command-line \narguments available for configuring the Vulture tool. The configuration settings \nare validated against predefined defaults in the `DEFAULTS` dictionary using the \n`_check_input_config` function. The function raises an `InputError` if any keys \nare unknown or if their types do not match expected values.\n\nParameters:\n- infile: A file-like object containing the TOML data to be parsed.\n\nReturns:\nA dictionary containing the configuration settings retrieved from the TOML file.\n\nUses:\n- `tomllib`: For loading TOML data.\n- `DEFAULTS`: Defined at the module level to specify valid configuration keys \n  and their default values. These constants help in ensuring the integrity of \n  the configuration values.\"\"\"\n    '\\n    Parse a TOML file for config values.\\n\\n    It will search for a section named ``[tool.vulture]`` which contains the\\n    same keys as the CLI arguments seen with ``--help``. All leading dashes are\\n    removed and other dashes are replaced by underscores (so ``--sort-by-size``\\n    becomes ``sort_by_size``).\\n\\n    Arguments containing multiple values are standard TOML lists.\\n\\n    Example::\\n\\n        [tool.vulture]\\n        exclude = [\"file*.py\", \"dir/\"]\\n        ignore_decorators = [\"deco1\", \"deco2\"]\\n        ignore_names = [\"name1\", \"name2\"]\\n        make_whitelist = true\\n        min_confidence = 10\\n        sort_by_size = true\\n        verbose = true\\n        paths = [\"path1\", \"path2\"]\\n    '\n    data = tomllib.load(infile)\n    settings = data.get('tool', {}).get('vulture', {})\n    _check_input_config(settings)\n    return settings",
        "docstring": "Parse a TOML file for configuration values specific to the Vulture tool.\n\nThis function reads a TOML file and retrieves configuration settings defined \nunder the `[tool.vulture]` section. It expects the keys to match the command-line \narguments available for configuring the Vulture tool. The configuration settings \nare validated against predefined defaults in the `DEFAULTS` dictionary using the \n`_check_input_config` function. The function raises an `InputError` if any keys \nare unknown or if their types do not match expected values.\n\nParameters:\n- infile: A file-like object containing the TOML data to be parsed.\n\nReturns:\nA dictionary containing the configuration settings retrieved from the TOML file.\n\nUses:\n- `tomllib`: For loading TOML data.\n- `DEFAULTS`: Defined at the module level to specify valid configuration keys \n  and their default values. These constants help in ensuring the integrity of \n  the configuration values.",
        "signature": "def _parse_toml(infile):",
        "type": "Function",
        "class_signature": null
      },
      "_parse_args": {
        "code": "def _parse_args(args=None):\n    \"\"\"Parse command-line arguments for the Vulture application.\n\nThis function utilizes Python's `argparse` module to define and process command-line options and their associated values. The parsed arguments include file paths, exclusion patterns, decorators to ignore, and configuration options. It validates the input against predefined configuration defaults found in the `DEFAULTS` dictionary.\n\nParameters:\n- args (list of str, optional): A list of strings representing the command-line arguments. By default, the function operates on `sys.argv`.\n\nReturns:\n- dict: A dictionary of parsed command-line arguments with values that are not missing. The keys in this dictionary correspond to the options defined in the arguments.\n\nRaises:\n- InputError: If any of the parsed arguments do not conform to the expected types as defined in the `DEFAULTS` dictionary.\n\nConstants:\n- `missing`: A unique sentinel object used to differentiate between arguments explicitly set to `False` and those that were not provided.\n- `usage`: A string defining the usage message for the command-line interface.\n- `version`: A string containing the current version of the Vulture application, imported from the module-level `__version__`.\n- `glob_help`: A string indicating that the patterns may contain glob wildcards, which is included in the help messages for relevant arguments.\"\"\"\n    '\\n    Parse CLI arguments.\\n\\n    :param args: A list of strings representing the CLI arguments. If left to\\n        the default, this will default to ``sys.argv``.\\n    '\n    missing = object()\n\n    def csv(exclude):\n        return exclude.split(',')\n    usage = '%(prog)s [options] [PATH ...]'\n    version = f'vulture {__version__}'\n    glob_help = 'Patterns may contain glob wildcards (*, ?, [abc], [!abc]).'\n    parser = argparse.ArgumentParser(prog='vulture', usage=usage)\n    parser.add_argument('paths', nargs='*', metavar='PATH', default=missing, help='Paths may be Python files or directories. For each directory Vulture analyzes all contained *.py files.')\n    parser.add_argument('--exclude', metavar='PATTERNS', type=csv, default=missing, help=f'Comma-separated list of path patterns to ignore (e.g., \"*settings.py,docs,*/test_*.py,venv\"). {glob_help} A PATTERN without glob wildcards is treated as *PATTERN*. Patterns are matched against absolute paths.')\n    parser.add_argument('--ignore-decorators', metavar='PATTERNS', type=csv, default=missing, help=f'Comma-separated list of decorators. Functions and classes using these decorators are ignored (e.g., \"@app.route,@require_*\"). {glob_help}')\n    parser.add_argument('--ignore-names', metavar='PATTERNS', type=csv, default=missing, help=f'Comma-separated list of names to ignore (e.g., \"visit_*,do_*\"). {glob_help}')\n    parser.add_argument('--make-whitelist', action='store_true', default=missing, help='Report unused code in a format that can be added to a whitelist module.')\n    parser.add_argument('--min-confidence', type=int, default=missing, help='Minimum confidence (between 0 and 100) for code to be reported as unused.')\n    parser.add_argument('--sort-by-size', action='store_true', default=missing, help='Sort unused functions and classes by their lines of code.')\n    parser.add_argument('--config', type=str, default='pyproject.toml', help='Path to pyproject.toml config file.')\n    parser.add_argument('-v', '--verbose', action='store_true', default=missing)\n    parser.add_argument('--version', action='version', version=version)\n    namespace = parser.parse_args(args)\n    cli_args = {key: value for key, value in vars(namespace).items() if value is not missing}\n    _check_input_config(cli_args)\n    return cli_args",
        "docstring": "Parse command-line arguments for the Vulture application.\n\nThis function utilizes Python's `argparse` module to define and process command-line options and their associated values. The parsed arguments include file paths, exclusion patterns, decorators to ignore, and configuration options. It validates the input against predefined configuration defaults found in the `DEFAULTS` dictionary.\n\nParameters:\n- args (list of str, optional): A list of strings representing the command-line arguments. By default, the function operates on `sys.argv`.\n\nReturns:\n- dict: A dictionary of parsed command-line arguments with values that are not missing. The keys in this dictionary correspond to the options defined in the arguments.\n\nRaises:\n- InputError: If any of the parsed arguments do not conform to the expected types as defined in the `DEFAULTS` dictionary.\n\nConstants:\n- `missing`: A unique sentinel object used to differentiate between arguments explicitly set to `False` and those that were not provided.\n- `usage`: A string defining the usage message for the command-line interface.\n- `version`: A string containing the current version of the Vulture application, imported from the module-level `__version__`.\n- `glob_help`: A string indicating that the patterns may contain glob wildcards, which is included in the help messages for relevant arguments.",
        "signature": "def _parse_args(args=None):",
        "type": "Function",
        "class_signature": null
      },
      "make_config": {
        "code": "def make_config(argv=None, tomlfile=None):\n    \"\"\"Returns a configuration object for the Vulture static code analysis tool by merging settings from a TOML configuration file (typically `pyproject.toml`) and command-line arguments. The command-line arguments take precedence over the TOML file values.\n\n:param argv: A list of command-line arguments to be parsed. If not specified, defaults to `sys.argv`.\n:param tomlfile: An IO instance containing TOML data for testing purposes. If not provided, the function attempts to locate and read `pyproject.toml`.\n\n:returns: A dictionary containing configuration settings.\n\nThis function utilizes the constant `DEFAULTS`, which defines the default values for various configuration options and is used to fill any missing settings in the final configuration. It also leverages helper functions such as `_parse_args` for command-line parsing and `_parse_toml` for reading TOML files. After merging configurations, it verifies the output configuration with the `_check_output_config` function to ensure that essential settings are provided.\"\"\"\n    '\\n    Returns a config object for vulture, merging both ``pyproject.toml`` and\\n    CLI arguments (CLI arguments have precedence).\\n\\n    :param argv: The CLI arguments to be parsed. This value is transparently\\n        passed through to :py:meth:`argparse.ArgumentParser.parse_args`.\\n    :param tomlfile: An IO instance containing TOML data. By default this will\\n        auto-detect an existing ``pyproject.toml`` file and exists solely for\\n        unit-testing.\\n    '\n    cli_config = _parse_args(argv)\n    detected_toml_path = ''\n    if tomlfile:\n        config = _parse_toml(tomlfile)\n        detected_toml_path = str(tomlfile)\n    else:\n        toml_path = pathlib.Path(cli_config['config']).resolve()\n        if toml_path.is_file():\n            with open(toml_path, 'rb') as fconfig:\n                config = _parse_toml(fconfig)\n            detected_toml_path = str(toml_path)\n        else:\n            config = {}\n    config.update(cli_config)\n    for key, value in DEFAULTS.items():\n        config.setdefault(key, value)\n    if detected_toml_path and config['verbose']:\n        print(f'Reading configuration from {detected_toml_path}')\n    _check_output_config(config)\n    return config",
        "docstring": "Returns a configuration object for the Vulture static code analysis tool by merging settings from a TOML configuration file (typically `pyproject.toml`) and command-line arguments. The command-line arguments take precedence over the TOML file values.\n\n:param argv: A list of command-line arguments to be parsed. If not specified, defaults to `sys.argv`.\n:param tomlfile: An IO instance containing TOML data for testing purposes. If not provided, the function attempts to locate and read `pyproject.toml`.\n\n:returns: A dictionary containing configuration settings.\n\nThis function utilizes the constant `DEFAULTS`, which defines the default values for various configuration options and is used to fill any missing settings in the final configuration. It also leverages helper functions such as `_parse_args` for command-line parsing and `_parse_toml` for reading TOML files. After merging configurations, it verifies the output configuration with the `_check_output_config` function to ensure that essential settings are provided.",
        "signature": "def make_config(argv=None, tomlfile=None):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "vulture/config.py:_parse_args": {},
    "vulture/config.py:_parse_toml": {},
    "vulture/config.py:make_config": {
      "vulture/config.py": {
        "_check_output_config": {
          "code": "def _check_output_config(config):\n    \"\"\"\n    Run sanity checks on the generated config after all parsing and\n    preprocessing is done.\n\n    Raise InputError if an error is encountered.\n    \"\"\"\n    if not config['paths']:\n        raise InputError('Please pass at least one file or directory')",
          "docstring": "Run sanity checks on the generated config after all parsing and\npreprocessing is done.\n\nRaise InputError if an error is encountered.",
          "signature": "def _check_output_config(config):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "vulture/config.py:_check_input_config": {
      "vulture/config.py": {
        "InputError.__init__": {
          "code": "    def __init__(self, message):\n        self.message = message",
          "docstring": "",
          "signature": "def __init__(self, message):",
          "type": "Method",
          "class_signature": "class InputError(Exception):"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_config.py:test_cli_args": {
      "vulture/config.py:_parse_args": {
        "vulture/config.py:csv": {},
        "vulture/config.py:_check_input_config": {}
      }
    },
    "tests/test_config.py:test_toml_config": {
      "tests/test_config.py:get_toml_bytes": {},
      "vulture/config.py:_parse_toml": {
        "vulture/config.py:_check_input_config": {}
      }
    },
    "tests/test_config.py:test_toml_config_with_heterogenous_array": {
      "tests/test_config.py:get_toml_bytes": {},
      "vulture/config.py:_parse_toml": {
        "vulture/config.py:_check_input_config": {}
      }
    },
    "tests/test_config.py:test_config_merging": {
      "tests/test_config.py:get_toml_bytes": {},
      "vulture/config.py:make_config": {
        "vulture/config.py:_parse_args": {
          "vulture/config.py:csv": {},
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_parse_toml": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_check_output_config": {}
      }
    },
    "tests/test_config.py:test_toml_config_custom_path": {
      "vulture/config.py:make_config": {
        "vulture/config.py:_parse_args": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_parse_toml": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_check_output_config": {}
      }
    },
    "tests/test_config.py:test_config_merging_missing": {
      "tests/test_config.py:get_toml_bytes": {},
      "vulture/config.py:make_config": {
        "vulture/config.py:_parse_args": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_parse_toml": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_check_output_config": {}
      }
    },
    "tests/test_config.py:test_config_merging_toml_paths_only": {
      "tests/test_config.py:get_toml_bytes": {},
      "vulture/config.py:make_config": {
        "vulture/config.py:_parse_args": {
          "vulture/config.py:csv": {},
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_parse_toml": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_check_output_config": {}
      }
    },
    "tests/test_config.py:test_invalid_config_options_output": {
      "vulture/config.py:_check_input_config": {
        "vulture/config.py:InputError:__init__": {}
      }
    },
    "tests/test_config.py:test_incompatible_option_type": {
      "vulture/config.py:_check_input_config": {
        "vulture/config.py:InputError:__init__": {}
      }
    },
    "tests/test_config.py:test_missing_paths": {
      "vulture/config.py:make_config": {
        "vulture/config.py:_parse_args": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_parse_toml": {
          "vulture/config.py:_check_input_config": {}
        },
        "vulture/config.py:_check_output_config": {
          "vulture/config.py:InputError:__init__": {}
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: vulture-test_config\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 vulture/\n    \u2514\u2500\u2500 config.py\n        \u251c\u2500\u2500 _check_input_config\n        \u251c\u2500\u2500 _parse_args\n        \u251c\u2500\u2500 _parse_toml\n        \u2514\u2500\u2500 make_config\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is responsible for validating and processing configuration inputs for a software tool, supporting both command-line arguments and TOML configuration files. It ensures that user-defined settings, such as paths to analyze, elements to exclude, and other parameters like verbosity and confidence thresholds, are correctly parsed and merged, with command-line arguments taking precedence over file-based configurations. The module provides robust error handling to abort execution when invalid configurations, unknown keys, or type mismatches are detected. By standardizing and enforcing configuration consistency, it eliminates ambiguities, ensuring seamless integration for users and developers relying on flexible and predictable configuration management.\n\n## FILE 1: vulture/config.py\n\n- FUNCTION NAME: _parse_toml\n  - SIGNATURE: def _parse_toml(infile):\n  - DOCSTRING: \n```python\n\"\"\"\nParse a TOML file for configuration values specific to the Vulture tool.\n\nThis function reads a TOML file and retrieves configuration settings defined \nunder the `[tool.vulture]` section. It expects the keys to match the command-line \narguments available for configuring the Vulture tool. The configuration settings \nare validated against predefined defaults in the `DEFAULTS` dictionary using the \n`_check_input_config` function. The function raises an `InputError` if any keys \nare unknown or if their types do not match expected values.\n\nParameters:\n- infile: A file-like object containing the TOML data to be parsed.\n\nReturns:\nA dictionary containing the configuration settings retrieved from the TOML file.\n\nUses:\n- `tomllib`: For loading TOML data.\n- `DEFAULTS`: Defined at the module level to specify valid configuration keys \n  and their default values. These constants help in ensuring the integrity of \n  the configuration values.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/config.py:_check_input_config\n\n- FUNCTION NAME: _parse_args\n  - SIGNATURE: def _parse_args(args=None):\n  - DOCSTRING: \n```python\n\"\"\"\nParse command-line arguments for the Vulture application.\n\nThis function utilizes Python's `argparse` module to define and process command-line options and their associated values. The parsed arguments include file paths, exclusion patterns, decorators to ignore, and configuration options. It validates the input against predefined configuration defaults found in the `DEFAULTS` dictionary.\n\nParameters:\n- args (list of str, optional): A list of strings representing the command-line arguments. By default, the function operates on `sys.argv`.\n\nReturns:\n- dict: A dictionary of parsed command-line arguments with values that are not missing. The keys in this dictionary correspond to the options defined in the arguments.\n\nRaises:\n- InputError: If any of the parsed arguments do not conform to the expected types as defined in the `DEFAULTS` dictionary.\n\nConstants:\n- `missing`: A unique sentinel object used to differentiate between arguments explicitly set to `False` and those that were not provided.\n- `usage`: A string defining the usage message for the command-line interface.\n- `version`: A string containing the current version of the Vulture application, imported from the module-level `__version__`.\n- `glob_help`: A string indicating that the patterns may contain glob wildcards, which is included in the help messages for relevant arguments.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/config.py:csv\n    - vulture/config.py:_check_input_config\n\n- FUNCTION NAME: make_config\n  - SIGNATURE: def make_config(argv=None, tomlfile=None):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a configuration object for the Vulture static code analysis tool by merging settings from a TOML configuration file (typically `pyproject.toml`) and command-line arguments. The command-line arguments take precedence over the TOML file values.\n\n:param argv: A list of command-line arguments to be parsed. If not specified, defaults to `sys.argv`.\n:param tomlfile: An IO instance containing TOML data for testing purposes. If not provided, the function attempts to locate and read `pyproject.toml`.\n\n:returns: A dictionary containing configuration settings.\n\nThis function utilizes the constant `DEFAULTS`, which defines the default values for various configuration options and is used to fill any missing settings in the final configuration. It also leverages helper functions such as `_parse_args` for command-line parsing and `_parse_toml` for reading TOML files. After merging configurations, it verifies the output configuration with the `_check_output_config` function to ensure that essential settings are provided.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/config.py:_check_output_config\n    - vulture/config.py:_parse_args\n    - vulture/config.py:_parse_toml\n\n- FUNCTION NAME: _check_input_config\n  - SIGNATURE: def _check_input_config(data):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks the types of values in the provided configuration *data* against expected types defined in the DEFAULTS dictionary. Raises an InputError if an unknown configuration key is encountered or if a value has the wrong type. \n\nParameters:\n- data (dict): A dictionary containing configuration key-value pairs to be validated, where keys should match those in DEFAULTS.\n\nRaises:\n- InputError: If any key in *data* is not recognized or if the type of a value does not match the expected type.\n\nDependencies:\n- The function relies on the DEFAULTS constant, which defines valid configuration keys along with their expected types. The InputError class is used for raising exceptions related to invalid inputs.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/config.py:InputError:__init__\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "vulture/config.py": "\"\"\"\nThis module handles retrieval of configuration values from either the\ncommand-line arguments or the pyproject.toml file.\n\"\"\"\nimport argparse\nimport pathlib\ntry:\n    import tomllib\nexcept ModuleNotFoundError:\n    import tomli as tomllib\nfrom .version import __version__\nDEFAULTS = {'config': 'pyproject.toml', 'min_confidence': 0, 'paths': [], 'exclude': [], 'ignore_decorators': [], 'ignore_names': [], 'make_whitelist': False, 'sort_by_size': False, 'verbose': False}\n\nclass InputError(Exception):\n\n    def __init__(self, message):\n        self.message = message\n\ndef _check_output_config(config):\n    \"\"\"\n    Run sanity checks on the generated config after all parsing and\n    preprocessing is done.\n\n    Raise InputError if an error is encountered.\n    \"\"\"\n    if not config['paths']:\n        raise InputError('Please pass at least one file or directory')"
  }
}