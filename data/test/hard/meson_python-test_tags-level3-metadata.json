{
  "dir_path": "/app/meson_python",
  "package_name": "meson_python",
  "sample_name": "meson_python-test_tags",
  "src_dir": "mesonpy/",
  "test_dir": "tests/",
  "test_file": "tests/test_tags.py",
  "test_code": "# SPDX-FileCopyrightText: 2021 The meson-python developers\n#\n# SPDX-License-Identifier: MIT\n\nimport importlib.machinery\nimport os\nimport pathlib\nimport platform\nimport sys\nimport sysconfig\n\nfrom collections import defaultdict\n\nimport packaging.tags\nimport pytest\n\nimport mesonpy\nimport mesonpy._tags\n\nfrom .conftest import adjust_packaging_platform_tag\n\n\n# Test against the wheel tag generated by packaging module.\ntag = next(packaging.tags.sys_tags())\nABI = tag.abi\nINTERPRETER = tag.interpreter\nPLATFORM = adjust_packaging_platform_tag(tag.platform)\n\n\ndef get_abi3_suffix():\n    for suffix in importlib.machinery.EXTENSION_SUFFIXES:\n        if '.abi3' in suffix:  # Unix\n            return suffix\n        elif suffix == '.pyd':  # Windows\n            return suffix\n\n\nSUFFIX = sysconfig.get_config_var('EXT_SUFFIX')\nABI3SUFFIX = get_abi3_suffix()\n\n\ndef test_wheel_tag():\n    assert str(mesonpy._tags.Tag()) == f'{INTERPRETER}-{ABI}-{PLATFORM}'\n    assert str(mesonpy._tags.Tag(abi='abi3')) == f'{INTERPRETER}-abi3-{PLATFORM}'\n\n\n@pytest.mark.skipif(sys.platform != 'darwin', reason='macOS specific test')\ndef test_macos_platform_tag(monkeypatch):\n    for minor in range(9, 16):\n        monkeypatch.setenv('MACOSX_DEPLOYMENT_TARGET', f'10.{minor}')\n        version = (10, minor) if platform.mac_ver()[2] != 'arm64' else (11, 0)\n        assert next(packaging.tags.mac_platforms(version)) == mesonpy._tags.get_platform_tag()\n    for major in range(11, 20):\n        for minor in range(3):\n            monkeypatch.setenv('MACOSX_DEPLOYMENT_TARGET', f'{major}.{minor}')\n            assert next(packaging.tags.mac_platforms((major, minor))) == mesonpy._tags.get_platform_tag()\n\n\n@pytest.mark.skipif(sys.platform != 'darwin', reason='macOS specific test')\ndef test_macos_platform_tag_arm64(monkeypatch):\n    monkeypatch.setenv('_PYTHON_HOST_PLATFORM', 'macosx-12.0-arm64')\n    # Verify that the minimum platform ABI version on arm64 is 11.0.\n    monkeypatch.setenv('MACOSX_DEPLOYMENT_TARGET', '10.12')\n    assert mesonpy._tags.get_platform_tag() == 'macosx_11_0_arm64'\n    monkeypatch.setenv('MACOSX_DEPLOYMENT_TARGET', '12.34')\n    assert mesonpy._tags.get_platform_tag() == 'macosx_12_0_arm64'\n\n\n@pytest.mark.skipif(sys.platform != 'darwin', reason='macOS specific test')\ndef test_python_host_platform(monkeypatch):\n    monkeypatch.setenv('_PYTHON_HOST_PLATFORM', 'macosx-12.0-arm64')\n    assert mesonpy._tags.get_platform_tag().endswith('arm64')\n    monkeypatch.setenv('_PYTHON_HOST_PLATFORM', 'macosx-11.1-x86_64')\n    assert mesonpy._tags.get_platform_tag().endswith('x86_64')\n\n\ndef wheel_builder_test_factory(content, pure=True, limited_api=False):\n    manifest = defaultdict(list)\n    manifest.update({key: [(pathlib.Path(x), os.path.join('build', x)) for x in value] for key, value in content.items()})\n    return mesonpy._WheelBuilder(None, manifest, limited_api)\n\n\ndef test_tag_empty_wheel():\n    builder = wheel_builder_test_factory({})\n    assert str(builder.tag) == 'py3-none-any'\n\n\ndef test_tag_purelib_wheel():\n    builder = wheel_builder_test_factory({\n        'purelib': ['pure.py'],\n    })\n    assert str(builder.tag) == 'py3-none-any'\n\n\ndef test_tag_platlib_wheel():\n    builder = wheel_builder_test_factory({\n        'platlib': [f'extension{SUFFIX}'],\n    })\n    assert str(builder.tag) == f'{INTERPRETER}-{ABI}-{PLATFORM}'\n\n\ndef test_tag_stable_abi():\n    builder = wheel_builder_test_factory({\n        'platlib': [f'extension{ABI3SUFFIX}'],\n    }, limited_api=True)\n    # PyPy does not support the stable ABI.\n    abi = 'abi3' if '__pypy__' not in sys.builtin_module_names else ABI\n    assert str(builder.tag) == f'{INTERPRETER}-{abi}-{PLATFORM}'\n\n\n@pytest.mark.xfail(sys.version_info < (3, 8) and sys.platform == 'win32', reason='Extension modules suffix without ABI tags')\n@pytest.mark.xfail('__pypy__' in sys.builtin_module_names, reason='PyPy does not support the stable ABI')\ndef test_tag_mixed_abi():\n    builder = wheel_builder_test_factory({\n        'platlib': [f'extension{ABI3SUFFIX}', f'another{SUFFIX}'],\n    }, pure=False, limited_api=True)\n    with pytest.raises(mesonpy.BuildError, match='The package declares compatibility with Python limited API but '):\n        assert str(builder.tag) == f'{INTERPRETER}-abi3-{PLATFORM}'\n",
  "GT_file_code": {
    "mesonpy/_tags.py": "# SPDX-FileCopyrightText: 2022 The meson-python developers\n#\n# SPDX-License-Identifier: MIT\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport struct\nimport sys\nimport sysconfig\nimport typing\n\n\nif typing.TYPE_CHECKING:  # pragma: no cover\n    from typing import Optional, Union\n\n\n# https://peps.python.org/pep-0425/#python-tag\nINTERPRETERS = {\n    'python': 'py',\n    'cpython': 'cp',\n    'pypy': 'pp',\n    'ironpython': 'ip',\n    'jython': 'jy',\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize('P') == 4\n\n\ndef get_interpreter_tag() -> str:\n    name = sys.implementation.name\n    name = INTERPRETERS.get(name, name)\n    version = sys.version_info\n    return f'{name}{version[0]}{version[1]}'\n\n\ndef _get_config_var(name: str, default: Union[str, int, None] = None) -> Union[str, int, None]:\n    value: Union[str, int, None] = sysconfig.get_config_var(name)\n    if value is None:\n        return default\n    return value\n\n\ndef _get_cpython_abi() -> str:\n    version = sys.version_info\n    debug = pymalloc = ''\n    if _get_config_var('Py_DEBUG', hasattr(sys, 'gettotalrefcount')):\n        debug = 'd'\n    if version < (3, 8) and _get_config_var('WITH_PYMALLOC', True):\n        pymalloc = 'm'\n    return f'cp{version[0]}{version[1]}{debug}{pymalloc}'\n\n\ndef get_abi_tag() -> str:\n    # The best solution to obtain the Python ABI is to parse the\n    # $SOABI or $EXT_SUFFIX sysconfig variables as defined in PEP-314.\n\n    # PyPy reports a $SOABI that does not agree with $EXT_SUFFIX.\n    # Using $EXT_SUFFIX will not break when PyPy will fix this.\n    # See https://foss.heptapod.net/pypy/pypy/-/issues/3816 and\n    # https://github.com/pypa/packaging/pull/607.\n    try:\n        empty, abi, ext = str(sysconfig.get_config_var('EXT_SUFFIX')).split('.')\n    except ValueError as exc:\n        # CPython <= 3.8.7 on Windows does not implement PEP3149 and\n        # uses '.pyd' as $EXT_SUFFIX, which does not allow to extract\n        # the interpreter ABI.  Check that the fallback is not hit for\n        # any other Python implementation.\n        if sys.implementation.name != 'cpython':\n            raise NotImplementedError from exc\n        return _get_cpython_abi()\n\n    # The packaging module initially based his understanding of the\n    # $SOABI variable on the inconsistent value reported by PyPy, and\n    # did not strip architecture information from it.  Therefore the\n    # ABI tag for later Python implementations (all the ones not\n    # explicitly handled below) contains architecture information too.\n    # Unfortunately, fixing this now would break compatibility.\n\n    if abi.startswith('cpython'):\n        abi = 'cp' + abi.split('-')[1]\n    elif abi.startswith('cp'):\n        abi = abi.split('-')[0]\n    elif abi.startswith('pypy'):\n        abi = '_'.join(abi.split('-')[:2])\n    elif abi.startswith('graalpy'):\n        abi = '_'.join(abi.split('-')[:3])\n\n    return abi.replace('.', '_').replace('-', '_')\n\n\ndef _get_macosx_platform_tag() -> str:\n    ver, _, arch = platform.mac_ver()\n\n    # Override the architecture with the one provided in the\n    # _PYTHON_HOST_PLATFORM environment variable.  This environment\n    # variable affects the sysconfig.get_platform() return value and\n    # is used to cross-compile python extensions on macOS for a\n    # different architecture.  We base the platform tag computation on\n    # platform.mac_ver() but respect the content of the environment\n    # variable.\n    try:\n        arch = os.environ.get('_PYTHON_HOST_PLATFORM', '').split('-')[2]\n    except IndexError:\n        pass\n\n    # Override the macOS version if one is provided via the\n    # MACOSX_DEPLOYMENT_TARGET environment variable.\n    try:\n        version = tuple(map(int, os.environ.get('MACOSX_DEPLOYMENT_TARGET', '').split('.')))[:2]\n    except ValueError:\n        version = tuple(map(int, ver.split('.')))[:2]\n\n    # Python built with older macOS SDK on macOS 11, reports an\n    # unexising macOS 10.16 version instead of the real version.\n    #\n    # The packaging module introduced a workaround\n    # https://github.com/pypa/packaging/commit/67c4a2820c549070bbfc4bfbf5e2a250075048da\n    #\n    # This results in packaging versions up to 21.3 generating\n    # platform tags like \"macosx_10_16_x86_64\" and later versions\n    # generating \"macosx_11_0_x86_64\".  Using the latter would be more\n    # correct but prevents the resulting wheel from being installed on\n    # systems using packaging 21.3 or earlier (pip 22.3 or earlier).\n    #\n    # Fortunately packaging versions carrying the workaround still\n    # accepts \"macosx_10_16_x86_64\" as a compatible platform tag.  We\n    # can therefore ignore the issue and generate the slightly\n    # incorrect tag.\n\n    # The minimum macOS ABI version on arm64 is 11.0.  The macOS SDK\n    # on arm64 silently bumps any compatibility version specified via\n    # the MACOSX_DEPLOYMENT_TARGET environment variable to 11.0.\n    # Despite the platform ABI tag being intended to be a minimum\n    # compatibility version, pip refuses to install wheels with a\n    # platform tag specifying an ABI version lower than 11.0.  Use\n    # 11.0 as minimum ABI version on arm64.\n    if arch == 'arm64' and version < (11, 0):\n        version = (11, 0)\n\n    major, minor = version\n\n    if major >= 11:\n        # For macOS reelases up to 10.15, the major version number is\n        # actually part of the OS name and the minor version is the\n        # actual OS release.  Starting with macOS 11, the major\n        # version number is the OS release and the minor version is\n        # the patch level.  Reset the patch level to zero.\n        minor = 0\n\n    if _32_BIT_INTERPRETER:\n        # 32-bit Python running on a 64-bit kernel.\n        if arch == 'ppc64':\n            arch = 'ppc'\n        if arch == 'x86_64':\n            arch = 'i386'\n\n    return f'macosx_{major}_{minor}_{arch}'\n\n\ndef get_platform_tag() -> str:\n    platform = sysconfig.get_platform()\n    if platform.startswith('macosx'):\n        return _get_macosx_platform_tag()\n    if _32_BIT_INTERPRETER:\n        # 32-bit Python running on a 64-bit kernel.\n        if platform == 'linux-x86_64':\n            return 'linux_i686'\n        if platform == 'linux-aarch64':\n            return 'linux_armv7l'\n    return platform.replace('-', '_').replace('.', '_').lower()\n\n\nclass Tag:\n    def __init__(self, interpreter: Optional[str] = None, abi: Optional[str] = None, platform: Optional[str] = None):\n        self.interpreter = interpreter or get_interpreter_tag()\n        self.abi = abi or get_abi_tag()\n        self.platform = platform or get_platform_tag()\n\n    def __str__(self) -> str:\n        return f'{self.interpreter}-{self.abi}-{self.platform}'\n",
    "mesonpy/__init__.py": "# SPDX-FileCopyrightText: 2021 Filipe La\u00edns <lains@riseup.net>\n# SPDX-FileCopyrightText: 2021 Quansight, LLC\n# SPDX-FileCopyrightText: 2022 The meson-python developers\n#\n# SPDX-License-Identifier: MIT\n\n\"\"\"Meson Python build backend\n\nImplements PEP 517 hooks.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport collections\nimport contextlib\nimport difflib\nimport functools\nimport importlib.machinery\nimport io\nimport itertools\nimport json\nimport os\nimport pathlib\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport sysconfig\nimport tarfile\nimport tempfile\nimport textwrap\nimport typing\nimport warnings\n\n\nif sys.version_info < (3, 11):\n    import tomli as tomllib\nelse:\n    import tomllib\n\nimport packaging.utils\nimport packaging.version\nimport pyproject_metadata\n\nimport mesonpy._compat\nimport mesonpy._rpath\nimport mesonpy._tags\nimport mesonpy._util\nimport mesonpy._wheelfile\n\nfrom mesonpy._compat import cached_property, read_binary\n\n\nif typing.TYPE_CHECKING:  # pragma: no cover\n    from typing import Any, Callable, DefaultDict, Dict, List, Literal, Optional, Sequence, TextIO, Tuple, Type, TypeVar, Union\n\n    from mesonpy._compat import Collection, Iterator, Mapping, ParamSpec, Path, Self\n\n    P = ParamSpec('P')\n    T = TypeVar('T')\n\n    MesonArgsKeys = Literal['dist', 'setup', 'compile', 'install']\n    MesonArgs = Mapping[MesonArgsKeys, List[str]]\n\n\n_NINJA_REQUIRED_VERSION = '1.8.2'\n_MESON_REQUIRED_VERSION = '0.63.3' # keep in sync with the version requirement in pyproject.toml\n\n_MESON_ARGS_KEYS = ['dist', 'setup', 'compile', 'install']\n\n_SUFFIXES = importlib.machinery.all_suffixes()\n_EXTENSION_SUFFIX_REGEX = re.compile(r'^[^.]+\\.(?:(?P<abi>[^.]+)\\.)?(?:so|pyd|dll)$')\nassert all(re.match(_EXTENSION_SUFFIX_REGEX, f'foo{x}') for x in importlib.machinery.EXTENSION_SUFFIXES)\n\n# Map Meson installation path placeholders to wheel installation paths.\n# See https://docs.python.org/3/library/sysconfig.html#installation-paths\n_INSTALLATION_PATH_MAP = {\n    '{bindir}': 'scripts',\n    '{py_purelib}': 'purelib',\n    '{py_platlib}': 'platlib',\n    '{moduledir_shared}': 'platlib',\n    '{includedir}': 'headers',\n    '{datadir}': 'data',\n    # custom location\n    '{libdir}': 'mesonpy-libs',\n    '{libdir_shared}': 'mesonpy-libs',\n}\n\n\ndef _map_to_wheel(sources: Dict[str, Dict[str, Any]]) -> DefaultDict[str, List[Tuple[pathlib.Path, str]]]:\n    \"\"\"Map files to the wheel, organized by wheel installation directory.\"\"\"\n    wheel_files: DefaultDict[str, List[Tuple[pathlib.Path, str]]] = collections.defaultdict(list)\n    packages: Dict[str, str] = {}\n\n    for key, group in sources.items():\n        for src, target in group.items():\n            destination = pathlib.Path(target['destination'])\n            anchor = destination.parts[0]\n            dst = pathlib.Path(*destination.parts[1:])\n\n            path = _INSTALLATION_PATH_MAP.get(anchor)\n            if path is None:\n                raise BuildError(f'Could not map installation path to an equivalent wheel directory: {str(destination)!r}')\n\n            if path == 'purelib' or path == 'platlib':\n                package = destination.parts[1]\n                other = packages.setdefault(package, path)\n                if other != path:\n                    this = os.fspath(pathlib.Path(path, *destination.parts[1:]))\n                    that = os.fspath(other / next(d for d, s in wheel_files[other] if d.parts[0] == destination.parts[1]))\n                    raise BuildError(\n                        f'The {package} package is split between {path} and {other}: '\n                        f'{this!r} and {that!r}, a \"pure: false\" argument may be missing in meson.build. '\n                        f'It is recommended to set it in \"import(\\'python\\').find_installation()\"')\n\n            if key == 'install_subdirs' or key == 'targets' and os.path.isdir(src):\n                exclude_files = {os.path.normpath(x) for x in target.get('exclude_files', [])}\n                exclude_dirs = {os.path.normpath(x) for x in target.get('exclude_dirs', [])}\n                for root, dirnames, filenames in os.walk(src):\n                    for name in dirnames.copy():\n                        dirsrc = os.path.join(root, name)\n                        relpath = os.path.relpath(dirsrc, src)\n                        if relpath in exclude_dirs:\n                            dirnames.remove(name)\n                    # sort to process directories determninistically\n                    dirnames.sort()\n                    for name in sorted(filenames):\n                        filesrc = os.path.join(root, name)\n                        relpath = os.path.relpath(filesrc, src)\n                        if relpath in exclude_files:\n                            continue\n                        filedst = dst / relpath\n                        wheel_files[path].append((filedst, filesrc))\n            else:\n                wheel_files[path].append((dst, src))\n\n    return wheel_files\n\n\nclass style:\n    ERROR = '\\33[31m'  # red\n    WARNING = '\\33[93m'  # bright yellow\n    INFO = '\\33[36m\\33[1m'  # cyan, bold\n    RESET = '\\33[0m'\n\n    @staticmethod\n    def strip(string: str) -> str:\n        \"\"\"Strip ANSI escape sequences from string.\"\"\"\n        return re.sub(r'\\033\\[[;?0-9]*[a-zA-Z]', '', string)\n\n\n@functools.lru_cache()\ndef _use_ansi_escapes() -> bool:\n    \"\"\"Determine whether logging should use ANSI escapes.\"\"\"\n\n    # We print log messages and error messages that may contain file\n    # names containing characters that cannot be represented in the\n    # stdout encoding. Use replacement markers for those instead than\n    # raising UnicodeEncodeError.\n    sys.stdout.reconfigure(errors='replace')  # type: ignore[attr-defined]\n\n    if 'NO_COLOR' in os.environ:\n        return False\n\n    if 'FORCE_COLOR' in os.environ or sys.stdout.isatty() and os.environ.get('TERM') != 'dumb':\n        if sys.platform == 'win32' and not os.environ.get('ANSICON'):\n            return mesonpy._util.setup_windows_console()\n        return True\n\n    return False\n\n\ndef _log(string: str , **kwargs: Any) -> None:\n    if not _use_ansi_escapes():\n        string = style.strip(string)\n    print(string, **kwargs)\n\n\ndef _showwarning(\n    message: Union[Warning, str],\n    category: Type[Warning],\n    filename: str,\n    lineno: int,\n    file: Optional[TextIO] = None,\n    line: Optional[str] = None,\n) -> None:  # pragma: no cover\n    \"\"\"Callable to override the default warning handler, to have colored output.\"\"\"\n    _log(f'{style.WARNING}meson-python: warning:{style.RESET} {message}')\n\n\nclass _clicounter:\n    def __init__(self, total: int) -> None:\n        self._total = total\n        self._count = itertools.count(start=1)\n\n    def __enter__(self) -> Self:\n        return self\n\n    def update(self, description: str) -> None:\n        line = f'[{next(self._count)}/{self._total}] {description}'\n        if _use_ansi_escapes():\n            print('\\r', line, sep='', end='\\33[0K', flush=True)\n        else:\n            print(line)\n\n    def __exit__(self, exc_type: Any, exc_value: Any, exc_tb: Any) -> None:\n        if _use_ansi_escapes():\n            print()\n\n\nclass Error(RuntimeError):\n    def __str__(self) -> str:\n        return str(self.args[0])\n\n\nclass ConfigError(Error):\n    \"\"\"Error in the backend configuration.\"\"\"\n\n\nclass BuildError(Error):\n    \"\"\"Error when building the wheel.\"\"\"\n\n\nclass MesonBuilderError(Error):\n    \"\"\"Error when building the Meson package.\"\"\"\n\n\nclass Metadata(pyproject_metadata.StandardMetadata):\n    def __init__(self, name: str, *args: Any, **kwargs: Any):\n        # See https://packaging.python.org/en/latest/specifications/core-metadata/#name\n        if not re.match(r'^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$', name, re.IGNORECASE):\n            raise pyproject_metadata.ConfigurationError(\n                f'Invalid project name \"{name}\". A valid name consists only of ASCII letters and '\n                f'numbers, period, underscore and hyphen. It must start and end with a letter or number')\n        super().__init__(name, *args, **kwargs)\n\n    @classmethod\n    def from_pyproject(  # type: ignore[override]\n        cls,\n        data: Mapping[str, Any],\n        project_dir: Path = os.path.curdir,\n        metadata_version: Optional[str] = None\n    ) -> Self:\n        metadata = super().from_pyproject(data, project_dir, metadata_version)\n\n        # Check for unsupported dynamic fields.\n        unsupported_dynamic = set(metadata.dynamic) - {'version', }\n        if unsupported_dynamic:\n            fields = ', '.join(f'\"{x}\"' for x in unsupported_dynamic)\n            raise pyproject_metadata.ConfigurationError(f'Unsupported dynamic fields: {fields}')\n\n        return metadata\n\n    @property\n    def distribution_name(self) -> str:\n        \"\"\"Name to be used in wheel and sdist file names.\"\"\"\n        return self.canonical_name.replace('-', '_')\n\n\ndef _is_native(file: Path) -> bool:\n    \"\"\"Check if file is a native file.\"\"\"\n\n    with open(file, 'rb') as f:\n        if sys.platform == 'darwin':\n            return f.read(4) in (\n                b'\\xfe\\xed\\xfa\\xce',  # 32-bit\n                b'\\xfe\\xed\\xfa\\xcf',  # 64-bit\n                b'\\xcf\\xfa\\xed\\xfe',  # arm64\n                b'\\xca\\xfe\\xba\\xbe',  # universal / fat (same as java class so beware!)\n            )\n        elif sys.platform == 'win32' or sys.platform == 'cygwin':\n            return f.read(2) == b'MZ'\n        else:\n            # Assume that any other platform uses ELF binaries.\n            return f.read(4) == b'\\x7fELF'  # ELF\n\n\nclass _WheelBuilder():\n    \"\"\"Helper class to build wheels from projects.\"\"\"\n\n    def __init__(\n        self,\n        metadata: Metadata,\n        manifest: Dict[str, List[Tuple[pathlib.Path, str]]],\n        limited_api: bool,\n    ) -> None:\n        self._metadata = metadata\n        self._manifest = manifest\n        self._limited_api = limited_api\n\n    @property\n    def _has_internal_libs(self) -> bool:\n        return bool(self._manifest.get('mesonpy-libs'))\n\n    @property\n    def _has_extension_modules(self) -> bool:\n        # Assume that all code installed in {platlib} is Python ABI dependent.\n        return bool(self._manifest.get('platlib'))\n\n    @cached_property\n    def _pure(self) -> bool:\n        \"\"\"Whether the wheel is architecture independent\"\"\"\n        if self._manifest['platlib'] or self._manifest['mesonpy-libs']:\n            return False\n        for _, file in self._manifest['scripts']:\n            if _is_native(file):\n                return False\n        return True\n\n    @property\n    def tag(self) -> mesonpy._tags.Tag:\n        \"\"\"Wheel tags.\"\"\"\n        if self._pure:\n            return mesonpy._tags.Tag('py3', 'none', 'any')\n        if not self._has_extension_modules:\n            # The wheel has platform dependent code (is not pure) but\n            # does not contain any extension module (does not\n            # distribute any file in {platlib}) thus use generic\n            # implementation and ABI tags.\n            return mesonpy._tags.Tag('py3', 'none', None)\n        return mesonpy._tags.Tag(None, self._stable_abi, None)\n\n    @property\n    def name(self) -> str:\n        \"\"\"Wheel name, this includes the basename and tag.\"\"\"\n        return f'{self._metadata.distribution_name}-{self._metadata.version}-{self.tag}'\n\n    @property\n    def _distinfo_dir(self) -> str:\n        return f'{self._metadata.distribution_name}-{self._metadata.version}.dist-info'\n\n    @property\n    def _data_dir(self) -> str:\n        return f'{self._metadata.distribution_name}-{self._metadata.version}.data'\n\n    @property\n    def _libs_dir(self) -> str:\n        return f'.{self._metadata.distribution_name}.mesonpy.libs'\n\n    @property\n    def _license_file(self) -> Optional[pathlib.Path]:\n        license_ = self._metadata.license\n        if license_ and isinstance(license_, pyproject_metadata.License):\n            return license_.file\n        return None\n\n    @property\n    def wheel(self) -> bytes:\n        \"\"\"Return WHEEL file for dist-info.\"\"\"\n        return textwrap.dedent('''\n            Wheel-Version: 1.0\n            Generator: meson\n            Root-Is-Purelib: {is_purelib}\n            Tag: {tag}\n        ''').strip().format(\n            is_purelib='true' if self._pure else 'false',\n            tag=self.tag,\n        ).encode()\n\n    @property\n    def entrypoints_txt(self) -> bytes:\n        \"\"\"dist-info entry_points.txt.\"\"\"\n        data = self._metadata.entrypoints.copy()\n        data.update({\n            'console_scripts': self._metadata.scripts,\n            'gui_scripts': self._metadata.gui_scripts,\n        })\n\n        text = ''\n        for entrypoint in data:\n            if data[entrypoint]:\n                text += f'[{entrypoint}]\\n'\n                for name, target in data[entrypoint].items():\n                    text += f'{name} = {target}\\n'\n                text += '\\n'\n\n        return text.encode()\n\n    @cached_property\n    def _stable_abi(self) -> Optional[str]:\n        # PyPy supports the limited API but does not provide a stable\n        # ABI, therefore extension modules using the limited API do\n        # not use the stable ABI filename suffix and wheels should not\n        # be tagged with the abi3 tag.\n        if self._limited_api and '__pypy__' not in sys.builtin_module_names:\n            # Verify stable ABI compatibility: examine files installed\n            # in {platlib} that look like extension modules, and raise\n            # an exception if any of them has a Python version\n            # specific extension filename suffix ABI tag.\n            for path, _ in self._manifest['platlib']:\n                match = _EXTENSION_SUFFIX_REGEX.match(path.name)\n                if match:\n                    abi = match.group('abi')\n                    if abi is not None and abi != 'abi3':\n                        raise BuildError(\n                            f'The package declares compatibility with Python limited API but extension '\n                            f'module {os.fspath(path)!r} is tagged for a specific Python version.')\n            return 'abi3'\n        return None\n\n    def _install_path(self, wheel_file: mesonpy._wheelfile.WheelFile, origin: Path, destination: pathlib.Path) -> None:\n        \"\"\"Add a file to the wheel.\"\"\"\n\n        if self._has_internal_libs:\n            if _is_native(origin):\n                # When an executable, libray, or Python extension module is\n                # dynamically linked to a library built as part of the project,\n                # Meson adds a library load path to it pointing to the build\n                # directory, in the form of a relative RPATH entry. meson-python\n                # relocates the shared libraries to the $project.mesonpy.libs\n                # folder. Rewrite the RPATH to point to that folder instead.\n                libspath = os.path.relpath(self._libs_dir, destination.parent)\n                mesonpy._rpath.fix_rpath(origin, libspath)\n\n        try:\n            wheel_file.write(origin, destination.as_posix())\n        except FileNotFoundError:\n            # work around for Meson bug, see https://github.com/mesonbuild/meson/pull/11655\n            if not os.fspath(origin).endswith('.pdb'):\n                raise\n\n    def _wheel_write_metadata(self, whl: mesonpy._wheelfile.WheelFile) -> None:\n        # add metadata\n        whl.writestr(f'{self._distinfo_dir}/METADATA', bytes(self._metadata.as_rfc822()))\n        whl.writestr(f'{self._distinfo_dir}/WHEEL', self.wheel)\n        if self.entrypoints_txt:\n            whl.writestr(f'{self._distinfo_dir}/entry_points.txt', self.entrypoints_txt)\n\n        # add license (see https://github.com/mesonbuild/meson-python/issues/88)\n        if self._license_file:\n            whl.write(self._license_file, f'{self._distinfo_dir}/{os.path.basename(self._license_file)}')\n\n    def build(self, directory: Path) -> pathlib.Path:\n        wheel_file = pathlib.Path(directory, f'{self.name}.whl')\n        with mesonpy._wheelfile.WheelFile(wheel_file, 'w') as whl:\n            self._wheel_write_metadata(whl)\n\n            with _clicounter(sum(len(x) for x in self._manifest.values())) as counter:\n\n                root = 'purelib' if self._pure else 'platlib'\n\n                for path, entries in self._manifest.items():\n                    for dst, src in entries:\n                        counter.update(src)\n\n                        if path == root:\n                            pass\n                        elif path == 'mesonpy-libs':\n                            # custom installation path for bundled libraries\n                            dst = pathlib.Path(self._libs_dir, dst)\n                        else:\n                            dst = pathlib.Path(self._data_dir, path, dst)\n\n                        self._install_path(whl, src, dst)\n\n        return wheel_file\n\n\nclass _EditableWheelBuilder(_WheelBuilder):\n\n    @property\n    def _top_level_modules(self) -> Collection[str]:\n        modules = set()\n        for type_ in self._manifest:\n            for path, _ in self._manifest[type_]:\n                name, dot, ext = path.parts[0].partition('.')\n                if dot:\n                    # module\n                    suffix = dot + ext\n                    if suffix in _SUFFIXES:\n                        modules.add(name)\n                else:\n                    # package\n                    modules.add(name)\n        return modules\n\n    def build(self, directory: Path, source_dir: pathlib.Path, build_dir: pathlib.Path,  # type: ignore[override]\n              build_command: List[str], verbose: bool = False) -> pathlib.Path:\n\n        wheel_file = pathlib.Path(directory, f'{self.name}.whl')\n        with mesonpy._wheelfile.WheelFile(wheel_file, 'w') as whl:\n            self._wheel_write_metadata(whl)\n            whl.writestr(\n                f'{self._distinfo_dir}/direct_url.json',\n                source_dir.as_uri().encode('utf-8'))\n\n            # install loader module\n            loader_module_name = f'_{self._metadata.distribution_name}_editable_loader'\n            whl.writestr(\n                f'{loader_module_name}.py',\n                read_binary('mesonpy', '_editable.py') + textwrap.dedent(f'''\n                   install(\n                       {self._metadata.name!r},\n                       {self._top_level_modules!r},\n                       {os.fspath(build_dir)!r},\n                       {build_command!r},\n                       {verbose!r},\n                   )''').encode('utf-8'))\n\n            # install .pth file\n            whl.writestr(\n                f'{self._metadata.canonical_name}-editable.pth',\n                f'import {loader_module_name}'.encode('utf-8'))\n\n        return wheel_file\n\n\ndef _validate_pyproject_config(pyproject: Dict[str, Any]) -> Dict[str, Any]:\n\n    def _table(scheme: Dict[str, Callable[[Any, str], Any]]) -> Callable[[Any, str], Dict[str, Any]]:\n        def func(value: Any, name: str) -> Dict[str, Any]:\n            if not isinstance(value, dict):\n                raise ConfigError(f'Configuration entry \"{name}\" must be a table')\n            table = {}\n            for key, val in value.items():\n                check = scheme.get(key)\n                if check is None:\n                    raise ConfigError(f'Unknown configuration entry \"{name}.{key}\"')\n                table[key] = check(val, f'{name}.{key}')\n            return table\n        return func\n\n    def _strings(value: Any, name: str) -> List[str]:\n        if not isinstance(value, list) or not all(isinstance(x, str) for x in value):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a list of strings')\n        return value\n\n    def _bool(value: Any, name: str) -> bool:\n        if not isinstance(value, bool):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a boolean')\n        return value\n\n    def _string_or_path(value: Any, name: str) -> str:\n        if not isinstance(value, str):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a string')\n        if os.path.isfile(value):\n            value = os.path.abspath(value)\n        return value\n\n    scheme = _table({\n        'meson': _string_or_path,\n        'limited-api': _bool,\n        'args': _table({\n            name: _strings for name in _MESON_ARGS_KEYS\n        }),\n    })\n\n    table = pyproject.get('tool', {}).get('meson-python', {})\n    return scheme(table, 'tool.meson-python')\n\n\ndef _validate_config_settings(config_settings: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Validate options received from build frontend.\"\"\"\n\n    def _string(value: Any, name: str) -> str:\n        if not isinstance(value, str):\n            raise ConfigError(f'Only one value for \"{name}\" can be specified')\n        return value\n\n    def _bool(value: Any, name: str) -> bool:\n        return True\n\n    def _string_or_strings(value: Any, name: str) -> List[str]:\n        return list([value,] if isinstance(value, str) else value)\n\n    options = {\n        'builddir': _string,\n        'build-dir': _string,\n        'editable-verbose': _bool,\n        'dist-args': _string_or_strings,\n        'setup-args': _string_or_strings,\n        'compile-args': _string_or_strings,\n        'install-args': _string_or_strings,\n    }\n    assert all(f'{name}-args' in options for name in _MESON_ARGS_KEYS)\n\n    config = {}\n    for key, value in config_settings.items():\n        parser = options.get(key)\n        if parser is None:\n            matches = difflib.get_close_matches(key, options.keys(), n=2)\n            if matches:\n                alternatives = ' or '.join(f'\"{match}\"' for match in matches)\n                raise ConfigError(f'Unknown option \"{key}\". Did you mean {alternatives}?')\n            else:\n                raise ConfigError(f'Unknown option \"{key}\"')\n        config[key] = parser(value, key)\n\n    # Check backward compatibility aliases.\n    aliases = {\n        'build-dir': 'builddir',\n    }\n    for key, alt in aliases.items():\n        if key in config and alt in config:\n            raise ConfigError(f'Option \"{alt}\" is a backward compatibility alias for \"{key}\". Only one can be used')\n        if alt in config:\n            config[key] = config[alt]\n\n    return config\n\n\nclass Project():\n    \"\"\"Meson project wrapper to generate Python artifacts.\"\"\"\n\n    def __init__(\n        self,\n        source_dir: Path,\n        build_dir: Path,\n        meson_args: Optional[MesonArgs] = None,\n        editable_verbose: bool = False,\n    ) -> None:\n        self._source_dir = pathlib.Path(source_dir).absolute()\n        self._build_dir = pathlib.Path(build_dir).absolute()\n        self._editable_verbose = editable_verbose\n        self._meson_native_file = self._build_dir / 'meson-python-native-file.ini'\n        self._meson_cross_file = self._build_dir / 'meson-python-cross-file.ini'\n        self._meson_args: MesonArgs = collections.defaultdict(list)\n        self._limited_api = False\n\n        # load pyproject.toml\n        pyproject = tomllib.loads(self._source_dir.joinpath('pyproject.toml').read_text(encoding='utf-8'))\n\n        # load meson args from pyproject.toml\n        pyproject_config = _validate_pyproject_config(pyproject)\n        for key, value in pyproject_config.get('args', {}).items():\n            self._meson_args[key].extend(value)\n\n        # meson arguments from the command line take precedence over\n        # arguments from the configuration file thus are added later\n        if meson_args:\n            for key, value in meson_args.items():\n                self._meson_args[key].extend(value)\n\n        # determine command to invoke meson\n        self._meson = _get_meson_command(pyproject_config.get('meson'))\n\n        self._ninja = _env_ninja_command()\n        if self._ninja is None:\n            raise ConfigError(f'Could not find ninja version {_NINJA_REQUIRED_VERSION} or newer.')\n        os.environ.setdefault('NINJA', self._ninja)\n\n        # make sure the build dir exists\n        self._build_dir.mkdir(exist_ok=True, parents=True)\n\n        # if the build dir is empty, add .gitignore and .hgignore files\n        if not any(self._build_dir.iterdir()):\n            _add_ignore_files(self._build_dir)\n\n        # setuptools-like ARCHFLAGS environment variable support\n        if sysconfig.get_platform().startswith('macosx-'):\n            archflags = os.environ.get('ARCHFLAGS', '').strip()\n            if archflags:\n\n                # parse the ARCHFLAGS environment variable\n                parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)\n                parser.add_argument('-arch', action='append')\n                args, unknown = parser.parse_known_args(archflags.split())\n                if unknown:\n                    raise ConfigError(f'Unknown flag specified in $ARCHFLAGS={archflags!r}')\n                arch, *other = set(args.arch)\n                if other:\n                    raise ConfigError(f'Multi-architecture builds are not supported but $ARCHFLAGS={archflags!r}')\n\n                macver, _, nativearch = platform.mac_ver()\n                if arch != nativearch:\n                    x = os.environ.setdefault('_PYTHON_HOST_PLATFORM', f'macosx-{macver}-{arch}')\n                    if not x.endswith(arch):\n                        raise ConfigError(f'$ARCHFLAGS={archflags!r} and $_PYTHON_HOST_PLATFORM={x!r} do not agree')\n                    family = 'aarch64' if arch == 'arm64' else arch\n                    cross_file_data = textwrap.dedent(f'''\n                        [binaries]\n                        c = ['cc', '-arch', {arch!r}]\n                        cpp = ['c++', '-arch', {arch!r}]\n                        objc = ['cc', '-arch', {arch!r}]\n                        objcpp = ['c++', '-arch', {arch!r}]\n                        [host_machine]\n                        system = 'darwin'\n                        cpu = {arch!r}\n                        cpu_family = {family!r}\n                        endian = 'little'\n                    ''')\n                    self._meson_cross_file.write_text(cross_file_data, encoding='utf-8')\n                    self._meson_args['setup'].extend(('--cross-file', os.fspath(self._meson_cross_file)))\n\n        # write the native file\n        native_file_data = textwrap.dedent(f'''\n            [binaries]\n            python = '{sys.executable}'\n        ''')\n        self._meson_native_file.write_text(native_file_data, encoding='utf-8')\n\n        # reconfigure if we have a valid Meson build directory. Meson\n        # uses the presence of the 'meson-private/coredata.dat' file\n        # in the build directory as indication that the build\n        # directory has already been configured and arranges this file\n        # to be created as late as possible or deleted if something\n        # goes wrong during setup.\n        reconfigure = self._build_dir.joinpath('meson-private/coredata.dat').is_file()\n\n        # run meson setup\n        self._configure(reconfigure=reconfigure)\n\n        # package metadata\n        if 'project' in pyproject:\n            self._metadata = Metadata.from_pyproject(pyproject, self._source_dir)\n            # set version from meson.build if version is declared as dynamic\n            if 'version' in self._metadata.dynamic:\n                version = self._meson_version\n                if version == 'undefined':\n                    raise pyproject_metadata.ConfigurationError(\n                        'Field \"version\" declared as dynamic but version is not defined in meson.build')\n                self._metadata.version = packaging.version.Version(version)\n        else:\n            # if project section is missing, use minimal metdata from meson.build\n            name, version = self._meson_name, self._meson_version\n            if version == 'undefined':\n                raise pyproject_metadata.ConfigurationError(\n                    'Section \"project\" missing in pyproject.toml and version is not defined in meson.build')\n            self._metadata = Metadata(name=name, version=packaging.version.Version(version))\n\n        # verify that we are running on a supported interpreter\n        if self._metadata.requires_python:\n            self._metadata.requires_python.prereleases = True\n            if platform.python_version().rstrip('+') not in self._metadata.requires_python:\n                raise MesonBuilderError(\n                    f'The package requires Python version {self._metadata.requires_python}, '\n                    f'running on {platform.python_version()}')\n\n        # limited API\n        self._limited_api = pyproject_config.get('limited-api', False)\n        if self._limited_api:\n            # check whether limited API is disabled for the Meson project\n            options = self._info('intro-buildoptions')\n            value = next((option['value'] for option in options if option['name'] == 'python.allow_limited_api'), None)\n            if not value:\n                self._limited_api = False\n\n        if self._limited_api and bool(sysconfig.get_config_var('Py_GIL_DISABLED')):\n            raise BuildError(\n                'The package targets Python\\'s Limited API, which is not supported by free-threaded CPython. '\n                'The \"python.allow_limited_api\" Meson build option may be used to override the package default.')\n\n    def _run(self, cmd: Sequence[str]) -> None:\n        \"\"\"Invoke a subprocess.\"\"\"\n        # Flush the line to ensure that the log line with the executed\n        # command line appears before the command output. Without it,\n        # the lines appear in the wrong order in pip output.\n        _log('{style.INFO}+ {cmd}{style.RESET}'.format(style=style, cmd=' '.join(cmd)), flush=True)\n        r = subprocess.run(cmd, cwd=self._build_dir)\n        if r.returncode != 0:\n            raise SystemExit(r.returncode)\n\n    def _configure(self, reconfigure: bool = False) -> None:\n        \"\"\"Configure Meson project.\"\"\"\n        setup_args = [\n            os.fspath(self._source_dir),\n            os.fspath(self._build_dir),\n            # default build options\n            '-Dbuildtype=release',\n            '-Db_ndebug=if-release',\n            '-Db_vscrt=md',\n            # user build options\n            *self._meson_args['setup'],\n            # pass native file last to have it override the python\n            # interpreter path that may have been specified in user\n            # provided native files\n            f'--native-file={os.fspath(self._meson_native_file)}',\n        ]\n        if reconfigure:\n            setup_args.insert(0, '--reconfigure')\n        self._run(self._meson + ['setup', *setup_args])\n\n    @property\n    def _build_command(self) -> List[str]:\n        assert self._ninja is not None  # help mypy out\n        if sys.platform == 'win32':\n            # On Windows use 'meson compile' to setup the MSVC compiler\n            # environment. Using the --ninja-args option allows to\n            # provide the exact same semantics for the compile arguments\n            # provided by the users.\n            cmd = self._meson + ['compile']\n            args = list(self._meson_args['compile'])\n            if args:\n                cmd.append(f'--ninja-args={args!r}')\n            return cmd\n        return [self._ninja, *self._meson_args['compile']]\n\n    @functools.lru_cache(maxsize=None)\n    def build(self) -> None:\n        \"\"\"Build the Meson project.\"\"\"\n        self._run(self._build_command)\n\n    @functools.lru_cache()\n    def _info(self, name: str) -> Any:\n        \"\"\"Read info from meson-info directory.\"\"\"\n        info = self._build_dir.joinpath('meson-info', f'{name}.json')\n        return json.loads(info.read_text(encoding='utf-8'))\n\n    @property\n    def _manifest(self) -> DefaultDict[str, List[Tuple[pathlib.Path, str]]]:\n        \"\"\"The files to be added to the wheel, organized by wheel path.\"\"\"\n\n        # Obtain the list of files Meson would install.\n        install_plan = self._info('intro-install_plan')\n\n        # Parse the 'meson install' args to extract --tags and --skip-subprojects\n        parser = argparse.ArgumentParser(add_help=False)\n        parser.add_argument('--tags')\n        parser.add_argument('--skip-subprojects', nargs='?', const='*', default='')\n        args, _ = parser.parse_known_args(self._meson_args['install'])\n        install_tags = {t.strip() for t in args.tags.split(',')} if args.tags else None\n        skip_subprojects = {p for p in (p.strip() for p in args.skip_subprojects.split(',')) if p}\n\n        # Filter the install plan accordingly.\n        sources: DefaultDict[str, Dict[str, Dict[str, str]]] = collections.defaultdict(dict)\n        for key, targets in install_plan.items():\n            for target, details in targets.items():\n                if install_tags is not None and details['tag'] not in install_tags:\n                    continue\n                subproject = details.get('subproject')\n                if subproject is not None and (subproject in skip_subprojects or '*' in skip_subprojects):\n                    continue\n                sources[key][target] = details\n\n        # Map Meson installation locations to wheel paths.\n        return _map_to_wheel(sources)\n\n    @property\n    def _meson_name(self) -> str:\n        \"\"\"Name in meson.build.\"\"\"\n        name = self._info('intro-projectinfo')['descriptive_name']\n        assert isinstance(name, str)\n        return name\n\n    @property\n    def _meson_version(self) -> str:\n        \"\"\"Version in meson.build.\"\"\"\n        name = self._info('intro-projectinfo')['version']\n        assert isinstance(name, str)\n        return name\n\n    def sdist(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates a sdist (source distribution) in the specified directory.\"\"\"\n        # Generate meson dist file.\n        self._run(self._meson + ['dist', '--allow-dirty', '--no-tests', '--formats', 'gztar', *self._meson_args['dist']])\n\n        dist_name = f'{self._metadata.distribution_name}-{self._metadata.version}'\n        meson_dist_name = f'{self._meson_name}-{self._meson_version}'\n        meson_dist_path = pathlib.Path(self._build_dir, 'meson-dist', f'{meson_dist_name}.tar.gz')\n        sdist_path = pathlib.Path(directory, f'{dist_name}.tar.gz')\n        pyproject_toml_mtime = 0\n\n        with tarfile.open(meson_dist_path, 'r:gz') as meson_dist, mesonpy._util.create_targz(sdist_path) as sdist:\n            for member in meson_dist.getmembers():\n                if member.isfile():\n                    file = meson_dist.extractfile(member.name)\n\n                    # Reset pax extended header.  The tar archive member may be\n                    # using pax headers to store some file metadata.  The pax\n                    # headers are not reset when the metadata is modified and\n                    # they take precedence when the member is deserialized.\n                    # This is relevant because when rewriting the member name,\n                    # the length of the path may shrink from being more than\n                    # 100 characters (requiring the path to be stored in the\n                    # pax headers) to being less than 100 characters. When this\n                    # happens, the tar archive member is serialized with the\n                    # shorter name in the regular header and the longer one in\n                    # the extended pax header.  The archives handled here are\n                    # not expected to use extended pax headers other than for\n                    # the ones required to encode file metadata.  The easiest\n                    # solution is to reset the pax extended headers.\n                    member.pax_headers = {}\n\n                    # Rewrite the path to match the sdist distribution name.\n                    stem = member.name.split('/', 1)[1]\n                    member.name = '/'.join((dist_name, stem))\n\n                    if stem == 'pyproject.toml':\n                        pyproject_toml_mtime = member.mtime\n\n                    # Reset owner and group to root:root.  This mimics what\n                    # 'git archive' does and makes the sdist reproducible upon\n                    # being built by different users.\n                    member.uname = member.gname = 'root'\n                    member.uid = member.gid = 0\n\n                    sdist.addfile(member, file)\n\n            # Add 'PKG-INFO'.\n            member = tarfile.TarInfo(f'{dist_name}/PKG-INFO')\n            member.uid = member.gid = 0\n            member.uname = member.gname = 'root'\n\n            # Set the 'PKG-INFO' modification time to the modification time of\n            # 'pyproject.toml' in the archive generated by 'meson dist'.  In\n            # turn this is the last commit time, unless touched by a dist\n            # script.  This makes the sdist reproducible upon being built at\n            # different times, when dist scripts are not used, which should be\n            # the majority of cases.\n            #\n            # Note that support for dynamic version in project metadata allows\n            # the version to depend on the build time.  Therefore, setting the\n            # 'PKG-INFO' modification time to the 'pyproject.toml'\n            # modification time can be seen as not strictly correct.  However,\n            # the sdist standard does not dictate which modification time to\n            # use for 'PKG-INFO'.  This choice allows to make the sdist\n            # byte-for-byte reproducible in the most common case.\n            member.mtime = pyproject_toml_mtime\n\n            metadata = bytes(self._metadata.as_rfc822())\n            member.size = len(metadata)\n            sdist.addfile(member, io.BytesIO(metadata))\n\n        return sdist_path\n\n    def wheel(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates a wheel in the specified directory.\"\"\"\n        self.build()\n        builder = _WheelBuilder(self._metadata, self._manifest, self._limited_api)\n        return builder.build(directory)\n\n    def editable(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates an editable wheel in the specified directory.\"\"\"\n        self.build()\n        builder = _EditableWheelBuilder(self._metadata, self._manifest, self._limited_api)\n        return builder.build(directory, self._source_dir, self._build_dir, self._build_command, self._editable_verbose)\n\n\n@contextlib.contextmanager\ndef _project(config_settings: Optional[Dict[Any, Any]] = None) -> Iterator[Project]:\n    \"\"\"Create the project given the given config settings.\"\"\"\n\n    settings = _validate_config_settings(config_settings or {})\n    meson_args = typing.cast('MesonArgs', {name: settings.get(f'{name}-args', []) for name in _MESON_ARGS_KEYS})\n    source_dir = os.path.curdir\n    build_dir = settings.get('build-dir')\n    editable_verbose = bool(settings.get('editable-verbose'))\n\n    with contextlib.ExitStack() as ctx:\n        if build_dir is None:\n            build_dir = ctx.enter_context(tempfile.TemporaryDirectory(prefix='.mesonpy-', dir=source_dir))\n        yield Project(source_dir, build_dir, meson_args, editable_verbose)\n\n\ndef _parse_version_string(string: str) -> Tuple[int, ...]:\n    \"\"\"Parse version string.\"\"\"\n    try:\n        return tuple(map(int, string.split('.')[:3]))\n    except ValueError:\n        return (0, )\n\n\ndef _get_meson_command(\n        meson: Optional[str] = None, *, version: str = _MESON_REQUIRED_VERSION\n    ) -> List[str]:\n    \"\"\"Return the command to invoke meson.\"\"\"\n\n    # The MESON env var, if set, overrides the config value from pyproject.toml.\n    # The config value, if given, is an absolute path or the name of an executable.\n    meson = os.environ.get('MESON', meson or 'meson')\n\n    # If the specified Meson string ends in `.py`, we run it with the current\n    # Python executable. This avoids problems for users on Windows, where\n    # making a script executable isn't enough to get it to run when invoked\n    # directly. For packages that vendor a forked Meson, the `meson.py` in the\n    # root of the Meson repo can be used this way.\n    if meson.endswith('.py'):\n        if not os.path.exists(meson):\n            raise ConfigError(f'Could not find the specified meson: \"{meson}\"')\n        cmd = [sys.executable, meson]\n    else:\n        cmd = [meson]\n\n    # The meson Python package is a dependency of the meson-python Python\n    # package, however, it may occur that the meson Python package is installed\n    # but the corresponding meson command is not available in $PATH. Implement\n    # a runtime check to verify that the build environment is setup correcly.\n    try:\n        r = subprocess.run(cmd + ['--version'], text=True, capture_output=True)\n    except FileNotFoundError as err:\n        raise ConfigError(f'meson executable \"{meson}\" not found') from err\n    if r.returncode != 0:\n        raise ConfigError(f'Could not execute meson: {r.stderr.strip()}')\n    meson_version = r.stdout.strip()\n\n    if _parse_version_string(meson_version) < _parse_version_string(version):\n        raise ConfigError(f'Could not find meson version {version} or newer, found {meson_version}.')\n\n    return cmd\n\n\ndef _env_ninja_command(*, version: str = _NINJA_REQUIRED_VERSION) -> Optional[str]:\n    \"\"\"Returns the path to ninja, or None if no ninja found.\"\"\"\n    required_version = _parse_version_string(version)\n    env_ninja = os.environ.get('NINJA')\n    ninja_candidates = [env_ninja] if env_ninja else ['ninja', 'ninja-build', 'samu']\n    for ninja in ninja_candidates:\n        ninja_path = shutil.which(ninja)\n        if ninja_path is not None:\n            version = subprocess.run([ninja_path, '--version'], check=False, text=True, capture_output=True).stdout\n            if _parse_version_string(version) >= required_version:\n                return ninja_path\n    return None\n\n\ndef _add_ignore_files(directory: pathlib.Path) -> None:\n    directory.joinpath('.gitignore').write_text(textwrap.dedent('''\n        # This file is generated by meson-python. It will not be recreated if deleted or modified.\n        *\n    '''), encoding='utf-8')\n    directory.joinpath('.hgignore').write_text(textwrap.dedent('''\n        # This file is generated by meson-python. It will not be recreated if deleted or modified.\n        syntax: glob\n        **/*\n    '''), encoding='utf-8')\n\n\ndef _pyproject_hook(func: Callable[P, T]) -> Callable[P, T]:\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        warnings.showwarning = _showwarning\n        try:\n            return func(*args, **kwargs)\n        except (Error, pyproject_metadata.ConfigurationError) as exc:\n            prefix = f'{style.ERROR}meson-python: error:{style.RESET} '\n            _log('\\n' + textwrap.indent(str(exc), prefix))\n            raise SystemExit(1) from exc\n    return wrapper\n\n\n@_pyproject_hook\ndef get_requires_for_build_sdist(config_settings: Optional[Dict[str, str]] = None) -> List[str]:\n    dependencies = []\n\n    if os.environ.get('NINJA') is None and _env_ninja_command() is None:\n        dependencies.append(f'ninja >= {_NINJA_REQUIRED_VERSION}')\n\n    return dependencies\n\n\n@_pyproject_hook\ndef get_requires_for_build_wheel(config_settings: Optional[Dict[str, str]] = None) -> List[str]:\n    dependencies = []\n\n    if os.environ.get('NINJA') is None and _env_ninja_command() is None:\n        dependencies.append(f'ninja >= {_NINJA_REQUIRED_VERSION}')\n\n    if sys.platform.startswith('linux') and not shutil.which('patchelf'):\n        dependencies.append('patchelf >= 0.11.0')\n\n    return dependencies\n\n\nget_requires_for_build_editable = get_requires_for_build_wheel\n\n\n@_pyproject_hook\ndef build_sdist(\n    sdist_directory: str,\n    config_settings: Optional[Dict[Any, Any]] = None,\n) -> str:\n\n    out = pathlib.Path(sdist_directory)\n    with _project(config_settings) as project:\n        return project.sdist(out).name\n\n\n@_pyproject_hook\ndef build_wheel(\n    wheel_directory: str, config_settings:\n    Optional[Dict[Any, Any]] = None,\n    metadata_directory: Optional[str] = None,\n) -> str:\n\n    out = pathlib.Path(wheel_directory)\n    with _project(config_settings) as project:\n        return project.wheel(out).name\n\n\n@_pyproject_hook\ndef build_editable(\n    wheel_directory: str,\n    config_settings: Optional[Dict[Any, Any]] = None,\n    metadata_directory: Optional[str] = None,\n) -> str:\n\n    # Force set a permanent build directory.\n    if not config_settings:\n        config_settings = {}\n    if 'build-dir' not in config_settings and 'builddir' not in config_settings:\n        config_settings['build-dir'] = 'build/' + mesonpy._tags.get_abi_tag()\n\n    out = pathlib.Path(wheel_directory)\n    with _project(config_settings) as project:\n        return project.editable(out).name\n"
  },
  "GT_src_dict": {
    "mesonpy/_tags.py": {
      "get_interpreter_tag": {
        "code": "def get_interpreter_tag() -> str:\n    \"\"\"Returns a string representing the Python interpreter's tag, which includes the interpreter's name and version. The interpreter's name is obtained from `sys.implementation.name` and mapped to a more concise identifier using the `INTERPRETERS` constant, defined at the top of the code. The version is derived from `sys.version_info`, which provides major and minor version numbers. The resulting tag is formatted as `'{name}{major}{minor}'`, where `name` is the interpreter's identifier and `major` and `minor` are the version numbers. This function does not take any parameters and returns the constructed tag as a string.\"\"\"\n    name = sys.implementation.name\n    name = INTERPRETERS.get(name, name)\n    version = sys.version_info\n    return f'{name}{version[0]}{version[1]}'",
        "docstring": "Returns a string representing the Python interpreter's tag, which includes the interpreter's name and version. The interpreter's name is obtained from `sys.implementation.name` and mapped to a more concise identifier using the `INTERPRETERS` constant, defined at the top of the code. The version is derived from `sys.version_info`, which provides major and minor version numbers. The resulting tag is formatted as `'{name}{major}{minor}'`, where `name` is the interpreter's identifier and `major` and `minor` are the version numbers. This function does not take any parameters and returns the constructed tag as a string.",
        "signature": "def get_interpreter_tag() -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_abi_tag": {
        "code": "def get_abi_tag() -> str:\n    \"\"\"Returns the ABI (Application Binary Interface) tag for the current Python interpreter. This tag is determined by parsing the `$SOABI` or `$EXT_SUFFIX` variables from the sysconfig module, as specified in PEP-314. If these variables are unavailable or cannot be parsed correctly, the function falls back to using the CPython ABI information obtained through the `_get_cpython_abi()` helper function.\n\nThe function interacts with the global constants defined in the code, specifically leveraging the `sys` and `sysconfig` modules to retrieve interpreter-related configurations. The `sys.implementation.name` is checked to ensure the fallback is only triggered for CPython, enhancing compatibility with other Python implementations like PyPy and GraalPy.\n\nThe output is a string formatted in a way that represents the Python ABI, with specific handling for known prefixes and removing unnecessary characters (like '.' and '-').\n\nReturns:\n    str: The ABI tag formatted for the current Python interpreter.\"\"\"\n    try:\n        empty, abi, ext = str(sysconfig.get_config_var('EXT_SUFFIX')).split('.')\n    except ValueError as exc:\n        if sys.implementation.name != 'cpython':\n            raise NotImplementedError from exc\n        return _get_cpython_abi()\n    if abi.startswith('cpython'):\n        abi = 'cp' + abi.split('-')[1]\n    elif abi.startswith('cp'):\n        abi = abi.split('-')[0]\n    elif abi.startswith('pypy'):\n        abi = '_'.join(abi.split('-')[:2])\n    elif abi.startswith('graalpy'):\n        abi = '_'.join(abi.split('-')[:3])\n    return abi.replace('.', '_').replace('-', '_')",
        "docstring": "Returns the ABI (Application Binary Interface) tag for the current Python interpreter. This tag is determined by parsing the `$SOABI` or `$EXT_SUFFIX` variables from the sysconfig module, as specified in PEP-314. If these variables are unavailable or cannot be parsed correctly, the function falls back to using the CPython ABI information obtained through the `_get_cpython_abi()` helper function.\n\nThe function interacts with the global constants defined in the code, specifically leveraging the `sys` and `sysconfig` modules to retrieve interpreter-related configurations. The `sys.implementation.name` is checked to ensure the fallback is only triggered for CPython, enhancing compatibility with other Python implementations like PyPy and GraalPy.\n\nThe output is a string formatted in a way that represents the Python ABI, with specific handling for known prefixes and removing unnecessary characters (like '.' and '-').\n\nReturns:\n    str: The ABI tag formatted for the current Python interpreter.",
        "signature": "def get_abi_tag() -> str:",
        "type": "Function",
        "class_signature": null
      },
      "get_platform_tag": {
        "code": "def get_platform_tag() -> str:\n    \"\"\"Get the platform tag for the current Python interpreter's operating system.\n\nThis function determines the platform tag based on the system's configuration using the `sysconfig.get_platform()` function. If the platform is macOS, it calls the helper function `_get_macosx_platform_tag()` to generate a detailed tag. For 32-bit interpreters run on 64-bit Linux, it returns specific tags for `linux-x86_64` and `linux-aarch64`. Otherwise, it formats the raw platform string by replacing hyphens and periods with underscores and converting it to lowercase.\n\nReturns:\n    str: A platform tag that reflects the current operating system, architecture, and Python interpreter's bitness.\n\nDependencies:\n- `_32_BIT_INTERPRETER`: A constant defined outside this function, indicating if the interpreter is 32-bit.\n- `sysconfig`: A module used to retrieve platform information.\n- `_get_macosx_platform_tag()`: A helper function called if the platform is macOS.\"\"\"\n    platform = sysconfig.get_platform()\n    if platform.startswith('macosx'):\n        return _get_macosx_platform_tag()\n    if _32_BIT_INTERPRETER:\n        if platform == 'linux-x86_64':\n            return 'linux_i686'\n        if platform == 'linux-aarch64':\n            return 'linux_armv7l'\n    return platform.replace('-', '_').replace('.', '_').lower()",
        "docstring": "Get the platform tag for the current Python interpreter's operating system.\n\nThis function determines the platform tag based on the system's configuration using the `sysconfig.get_platform()` function. If the platform is macOS, it calls the helper function `_get_macosx_platform_tag()` to generate a detailed tag. For 32-bit interpreters run on 64-bit Linux, it returns specific tags for `linux-x86_64` and `linux-aarch64`. Otherwise, it formats the raw platform string by replacing hyphens and periods with underscores and converting it to lowercase.\n\nReturns:\n    str: A platform tag that reflects the current operating system, architecture, and Python interpreter's bitness.\n\nDependencies:\n- `_32_BIT_INTERPRETER`: A constant defined outside this function, indicating if the interpreter is 32-bit.\n- `sysconfig`: A module used to retrieve platform information.\n- `_get_macosx_platform_tag()`: A helper function called if the platform is macOS.",
        "signature": "def get_platform_tag() -> str:",
        "type": "Function",
        "class_signature": null
      },
      "Tag.__init__": {
        "code": "    def __init__(self, interpreter: Optional[str]=None, abi: Optional[str]=None, platform: Optional[str]=None):\n        \"\"\"Initializes a Tag object representing the Python environment's interpreter, ABI, and platform.\n\nParameters:\n- interpreter (Optional[str]): A string specifying the interpreter tag. If not provided, it defaults to the value returned by the `get_interpreter_tag()` function.\n- abi (Optional[str]): A string specifying the ABI tag. If not provided, it defaults to the value returned by the `get_abi_tag()` function.\n- platform (Optional[str]): A string specifying the platform tag. If not provided, it defaults to the value returned by the `get_platform_tag()` function.\n\nAttributes:\n- interpreter (str): The tag for the Python interpreter (e.g., 'cp38' for CPython 3.8).\n- abi (str): The tag representing the ABI (e.g., 'cp38m' for CPython 3.8 with pymalloc).\n- platform (str): The tag for the platform (e.g., 'linux_x86_64').\n\nDependencies:\n- Utilizes the functions `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` to determine default values for attributes if not specified during initialization. These functions rely on the `sys` and `sysconfig` modules to obtain details about the Python environment and configuration.\"\"\"\n        self.interpreter = interpreter or get_interpreter_tag()\n        self.abi = abi or get_abi_tag()\n        self.platform = platform or get_platform_tag()",
        "docstring": "Initializes a Tag object representing the Python environment's interpreter, ABI, and platform.\n\nParameters:\n- interpreter (Optional[str]): A string specifying the interpreter tag. If not provided, it defaults to the value returned by the `get_interpreter_tag()` function.\n- abi (Optional[str]): A string specifying the ABI tag. If not provided, it defaults to the value returned by the `get_abi_tag()` function.\n- platform (Optional[str]): A string specifying the platform tag. If not provided, it defaults to the value returned by the `get_platform_tag()` function.\n\nAttributes:\n- interpreter (str): The tag for the Python interpreter (e.g., 'cp38' for CPython 3.8).\n- abi (str): The tag representing the ABI (e.g., 'cp38m' for CPython 3.8 with pymalloc).\n- platform (str): The tag for the platform (e.g., 'linux_x86_64').\n\nDependencies:\n- Utilizes the functions `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` to determine default values for attributes if not specified during initialization. These functions rely on the `sys` and `sysconfig` modules to obtain details about the Python environment and configuration.",
        "signature": "def __init__(self, interpreter: Optional[str]=None, abi: Optional[str]=None, platform: Optional[str]=None):",
        "type": "Method",
        "class_signature": "class Tag:"
      },
      "Tag.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Returns a string representation of the Tag instance, formatted as 'interpreter-abi-platform'. \n\nThe interpreter, abi, and platform attributes of the Tag class are instantiated using the corresponding methods: `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` if not explicitly provided. The interpreter tag includes the Python implementation name (mapped from the `INTERPRETERS` constant) and its version. The ABI tag indicates the compatibility level for extensions, while the platform tag provides the underlying operating system and architecture details, with specific handling for macOS versions as described in the full code context. \n\nThe output is used to generate identifiers essential for packaging and distributing Python packages, ensuring compatibility across different environments.\"\"\"\n        return f'{self.interpreter}-{self.abi}-{self.platform}'",
        "docstring": "Returns a string representation of the Tag instance, formatted as 'interpreter-abi-platform'. \n\nThe interpreter, abi, and platform attributes of the Tag class are instantiated using the corresponding methods: `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` if not explicitly provided. The interpreter tag includes the Python implementation name (mapped from the `INTERPRETERS` constant) and its version. The ABI tag indicates the compatibility level for extensions, while the platform tag provides the underlying operating system and architecture details, with specific handling for macOS versions as described in the full code context. \n\nThe output is used to generate identifiers essential for packaging and distributing Python packages, ensuring compatibility across different environments.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class Tag:"
      }
    },
    "mesonpy/__init__.py": {
      "Error.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Returns a string representation of the Error instance, extracting the first element from the `args` attribute. This method overrides the default string conversion behavior by providing a more specific message tied to the instantiation of the Error.\n\nParameters:\n- None.\n\nReturns:\n- A string that represents the error message associated with the Error instance.\n\nThis method is particularly useful for providing clear feedback during error handling, allowing other parts of the code that raise or catch the Error to easily access a human-readable message. The `args` attribute is utilized, which is defined at the time of the Error object creation, typically during an exception raise.\"\"\"\n        return str(self.args[0])",
        "docstring": "Returns a string representation of the Error instance, extracting the first element from the `args` attribute. This method overrides the default string conversion behavior by providing a more specific message tied to the instantiation of the Error.\n\nParameters:\n- None.\n\nReturns:\n- A string that represents the error message associated with the Error instance.\n\nThis method is particularly useful for providing clear feedback during error handling, allowing other parts of the code that raise or catch the Error to easily access a human-readable message. The `args` attribute is utilized, which is defined at the time of the Error object creation, typically during an exception raise.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class Error(RuntimeError):"
      },
      "_WheelBuilder.__init__": {
        "code": "    def __init__(self, metadata: Metadata, manifest: Dict[str, List[Tuple[pathlib.Path, str]]], limited_api: bool) -> None:\n        \"\"\"Initialize a _WheelBuilder instance to facilitate the creation of Python wheel packages.\n\nParameters:\n- metadata (Metadata): An instance containing the package's metadata, which includes essential details such as name and version, and is validated according to PEP 503.\n- manifest (Dict[str, List[Tuple[pathlib.Path, str]]]): A mapping that organizes files to be included in the wheel by their corresponding directory paths. It is generated from the build process and helps determine which files belong to which wheel location.\n- limited_api (bool): A flag indicating whether the package uses Python's Limited API, impacting how the wheel is constructed and tagged.\n\nThis constructor sets the internal state of the _WheelBuilder, storing the provided metadata, manifest, and limited API flag for further usage in methods like `build()`, which creates the wheel file using the stored information.\"\"\"\n        self._metadata = metadata\n        self._manifest = manifest\n        self._limited_api = limited_api",
        "docstring": "Initialize a _WheelBuilder instance to facilitate the creation of Python wheel packages.\n\nParameters:\n- metadata (Metadata): An instance containing the package's metadata, which includes essential details such as name and version, and is validated according to PEP 503.\n- manifest (Dict[str, List[Tuple[pathlib.Path, str]]]): A mapping that organizes files to be included in the wheel by their corresponding directory paths. It is generated from the build process and helps determine which files belong to which wheel location.\n- limited_api (bool): A flag indicating whether the package uses Python's Limited API, impacting how the wheel is constructed and tagged.\n\nThis constructor sets the internal state of the _WheelBuilder, storing the provided metadata, manifest, and limited API flag for further usage in methods like `build()`, which creates the wheel file using the stored information.",
        "signature": "def __init__(self, metadata: Metadata, manifest: Dict[str, List[Tuple[pathlib.Path, str]]], limited_api: bool) -> None:",
        "type": "Method",
        "class_signature": "class _WheelBuilder:"
      },
      "_WheelBuilder._has_extension_modules": {
        "code": "    def _has_extension_modules(self) -> bool:\n        \"\"\"Determine whether the Wheel contains any extension modules.\n\nThis property checks the `_manifest` attribute, which holds the mapping of files to be included in the Wheel, organized by wheel path. It specifically looks for entries in the `platlib` section of the manifest, which is assumed to contain platform-dependent code that ties to the Python ABI.\n\nReturns:\n    bool: True if there are extension modules in the `platlib` section, otherwise False.\n\nDependencies:\n    - _manifest: A property of the _WheelBuilder class that provides the mapping of files.\"\"\"\n        return bool(self._manifest.get('platlib'))",
        "docstring": "Determine whether the Wheel contains any extension modules.\n\nThis property checks the `_manifest` attribute, which holds the mapping of files to be included in the Wheel, organized by wheel path. It specifically looks for entries in the `platlib` section of the manifest, which is assumed to contain platform-dependent code that ties to the Python ABI.\n\nReturns:\n    bool: True if there are extension modules in the `platlib` section, otherwise False.\n\nDependencies:\n    - _manifest: A property of the _WheelBuilder class that provides the mapping of files.",
        "signature": "def _has_extension_modules(self) -> bool:",
        "type": "Method",
        "class_signature": "class _WheelBuilder:"
      },
      "_WheelBuilder._pure": {
        "code": "    def _pure(self) -> bool:\n        \"\"\"Determine whether the built wheel is architecture-independent (pure). \n\n    A wheel is considered pure if it does not contain platform-specific files. This method checks two main conditions:\n    1. It verifies that neither 'platlib' (a key in the manifest) nor 'mesonpy-libs' contains any items, indicating no platform-dependent libraries or files.\n    2. It iterates through the scripts in the manifest to check if any of them are native files using the helper function `_is_native`.\n\n    Returns:\n        bool: True if the wheel is architecture-independent (pure), otherwise False.\n\n    Dependencies:\n        - `self._manifest`: A dictionary attribute containing wheel files organized by their destination directories, specifically checking for keys 'platlib' and 'mesonpy-libs'.\n        - `_is_native(file)`: A function that determines if a given file is a native binary for the current platform, which helps identify if script files are platform-dependent.\"\"\"\n        'Whether the wheel is architecture independent'\n        if self._manifest['platlib'] or self._manifest['mesonpy-libs']:\n            return False\n        for _, file in self._manifest['scripts']:\n            if _is_native(file):\n                return False\n        return True",
        "docstring": "Determine whether the built wheel is architecture-independent (pure). \n\nA wheel is considered pure if it does not contain platform-specific files. This method checks two main conditions:\n1. It verifies that neither 'platlib' (a key in the manifest) nor 'mesonpy-libs' contains any items, indicating no platform-dependent libraries or files.\n2. It iterates through the scripts in the manifest to check if any of them are native files using the helper function `_is_native`.\n\nReturns:\n    bool: True if the wheel is architecture-independent (pure), otherwise False.\n\nDependencies:\n    - `self._manifest`: A dictionary attribute containing wheel files organized by their destination directories, specifically checking for keys 'platlib' and 'mesonpy-libs'.\n    - `_is_native(file)`: A function that determines if a given file is a native binary for the current platform, which helps identify if script files are platform-dependent.",
        "signature": "def _pure(self) -> bool:",
        "type": "Method",
        "class_signature": "class _WheelBuilder:"
      },
      "_WheelBuilder.tag": {
        "code": "    def tag(self) -> mesonpy._tags.Tag:\n        \"\"\"Return the wheel tag for this package, which determines the compatibility of the wheel with different Python versions and implementations.\n\nThe method checks if the wheel is pure (architecture-independent) by evaluating the `_pure` property. If it is pure, it returns a tag of `('py3', 'none', 'any')`, indicating compatibility with any platform. If the wheel is not pure and does not contain any extension modules, it returns a tag of `('py3', 'none', None)` to indicate a generic implementation. Otherwise, it retrieves the stable ABI tag using the `_stable_abi` property and returns a tag with that ABI.\n\nThe method relies on the `mesonpy._tags.Tag` class to create the tag objects and the properties `_pure`, `_has_extension_modules`, and `_stable_abi` defined in the `_WheelBuilder` class. The constants representing the tags are important for determining the supported configurations for the wheel file.\"\"\"\n        'Wheel tags.'\n        if self._pure:\n            return mesonpy._tags.Tag('py3', 'none', 'any')\n        if not self._has_extension_modules:\n            return mesonpy._tags.Tag('py3', 'none', None)\n        return mesonpy._tags.Tag(None, self._stable_abi, None)",
        "docstring": "Return the wheel tag for this package, which determines the compatibility of the wheel with different Python versions and implementations.\n\nThe method checks if the wheel is pure (architecture-independent) by evaluating the `_pure` property. If it is pure, it returns a tag of `('py3', 'none', 'any')`, indicating compatibility with any platform. If the wheel is not pure and does not contain any extension modules, it returns a tag of `('py3', 'none', None)` to indicate a generic implementation. Otherwise, it retrieves the stable ABI tag using the `_stable_abi` property and returns a tag with that ABI.\n\nThe method relies on the `mesonpy._tags.Tag` class to create the tag objects and the properties `_pure`, `_has_extension_modules`, and `_stable_abi` defined in the `_WheelBuilder` class. The constants representing the tags are important for determining the supported configurations for the wheel file.",
        "signature": "def tag(self) -> mesonpy._tags.Tag:",
        "type": "Method",
        "class_signature": "class _WheelBuilder:"
      },
      "_WheelBuilder._stable_abi": {
        "code": "    def _stable_abi(self) -> Optional[str]:\n        \"\"\"Determine the stable ABI (Application Binary Interface) for Python extension modules in the context of the wheel being built.\n\nThis method checks if the package is compatible with Python's limited API and whether it is not running on PyPy (which does not provide a stable ABI). If the package is marked as using the limited API, it verifies that all installed extension modules in the `platlib` directory do not have version-specific ABI tags other than 'abi3'. If any are found, a `BuildError` is raised, indicating a conflict.\n\nReturns:\n    Optional[str]: Returns 'abi3' if the package is compatible with the limited API and has no conflicting extension modules. Otherwise, returns None.\n\nDependencies:\n- This method interacts with the `_limited_api` attribute of the `_WheelBuilder` class, which determines if the package targets Python's limited API.\n- It uses the `_manifest` attribute, specifically extracting files from the 'platlib' key to check for installed extension modules.\n- The `_EXTENSION_SUFFIX_REGEX` constant is defined in the full code context to match against the file names of extension modules to determine their ABI compatibility.\"\"\"\n        if self._limited_api and '__pypy__' not in sys.builtin_module_names:\n            for path, _ in self._manifest['platlib']:\n                match = _EXTENSION_SUFFIX_REGEX.match(path.name)\n                if match:\n                    abi = match.group('abi')\n                    if abi is not None and abi != 'abi3':\n                        raise BuildError(f'The package declares compatibility with Python limited API but extension module {os.fspath(path)!r} is tagged for a specific Python version.')\n            return 'abi3'\n        return None",
        "docstring": "Determine the stable ABI (Application Binary Interface) for Python extension modules in the context of the wheel being built.\n\nThis method checks if the package is compatible with Python's limited API and whether it is not running on PyPy (which does not provide a stable ABI). If the package is marked as using the limited API, it verifies that all installed extension modules in the `platlib` directory do not have version-specific ABI tags other than 'abi3'. If any are found, a `BuildError` is raised, indicating a conflict.\n\nReturns:\n    Optional[str]: Returns 'abi3' if the package is compatible with the limited API and has no conflicting extension modules. Otherwise, returns None.\n\nDependencies:\n- This method interacts with the `_limited_api` attribute of the `_WheelBuilder` class, which determines if the package targets Python's limited API.\n- It uses the `_manifest` attribute, specifically extracting files from the 'platlib' key to check for installed extension modules.\n- The `_EXTENSION_SUFFIX_REGEX` constant is defined in the full code context to match against the file names of extension modules to determine their ABI compatibility.",
        "signature": "def _stable_abi(self) -> Optional[str]:",
        "type": "Method",
        "class_signature": "class _WheelBuilder:"
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "tests/test_tags.py:test_wheel_tag": {
      "mesonpy/_tags.py:Tag:__init__": {
        "mesonpy/_tags.py:get_interpreter_tag": {},
        "mesonpy/_tags.py:get_abi_tag": {},
        "mesonpy/_tags.py:get_platform_tag": {}
      },
      "mesonpy/_tags.py:Tag:__str__": {}
    },
    "tests/test_tags.py:test_tag_empty_wheel": {
      "tests/test_tags.py:wheel_builder_test_factory": {
        "mesonpy/__init__.py:_WheelBuilder:__init__": {}
      },
      "mesonpy/__init__.py:_WheelBuilder:tag": {
        "mesonpy/__init__.py:_WheelBuilder:_pure": {},
        "mesonpy/_tags.py:Tag:__init__": {}
      },
      "mesonpy/_tags.py:Tag:__str__": {}
    },
    "tests/test_tags.py:test_tag_purelib_wheel": {
      "tests/test_tags.py:wheel_builder_test_factory": {
        "mesonpy/__init__.py:_WheelBuilder:__init__": {}
      },
      "mesonpy/__init__.py:_WheelBuilder:tag": {
        "mesonpy/__init__.py:_WheelBuilder:_pure": {},
        "mesonpy/_tags.py:Tag:__init__": {}
      },
      "mesonpy/_tags.py:Tag:__str__": {}
    },
    "tests/test_tags.py:test_tag_platlib_wheel": {
      "tests/test_tags.py:wheel_builder_test_factory": {
        "mesonpy/__init__.py:_WheelBuilder:__init__": {}
      },
      "mesonpy/__init__.py:_WheelBuilder:tag": {
        "mesonpy/__init__.py:_WheelBuilder:_pure": {},
        "mesonpy/__init__.py:_WheelBuilder:_has_extension_modules": {},
        "mesonpy/__init__.py:_WheelBuilder:_stable_abi": {},
        "mesonpy/_tags.py:Tag:__init__": {
          "mesonpy/_tags.py:get_interpreter_tag": {},
          "mesonpy/_tags.py:get_abi_tag": {},
          "mesonpy/_tags.py:get_platform_tag": {}
        }
      },
      "mesonpy/_tags.py:Tag:__str__": {}
    },
    "tests/test_tags.py:test_tag_stable_abi": {
      "tests/test_tags.py:wheel_builder_test_factory": {
        "mesonpy/__init__.py:_WheelBuilder:__init__": {}
      },
      "mesonpy/__init__.py:_WheelBuilder:tag": {
        "mesonpy/__init__.py:_WheelBuilder:_pure": {},
        "mesonpy/__init__.py:_WheelBuilder:_has_extension_modules": {},
        "mesonpy/__init__.py:_WheelBuilder:_stable_abi": {},
        "mesonpy/_tags.py:Tag:__init__": {
          "mesonpy/_tags.py:get_interpreter_tag": {},
          "mesonpy/_tags.py:get_platform_tag": {}
        }
      },
      "mesonpy/_tags.py:Tag:__str__": {}
    },
    "tests/test_tags.py:test_tag_mixed_abi": {
      "tests/test_tags.py:wheel_builder_test_factory": {
        "mesonpy/__init__.py:_WheelBuilder:__init__": {}
      },
      "mesonpy/__init__.py:_WheelBuilder:tag": {
        "mesonpy/__init__.py:_WheelBuilder:_pure": {},
        "mesonpy/__init__.py:_WheelBuilder:_has_extension_modules": {},
        "mesonpy/__init__.py:_WheelBuilder:_stable_abi": {}
      },
      "mesonpy/__init__.py:Error:__str__": {}
    }
  },
  "PRD": "# PROJECT NAME: meson_python-test_tags\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mesonpy/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 Error.__str__\n    \u2502   \u251c\u2500\u2500 _WheelBuilder.__init__\n    \u2502   \u251c\u2500\u2500 _WheelBuilder._has_extension_modules\n    \u2502   \u251c\u2500\u2500 _WheelBuilder._pure\n    \u2502   \u251c\u2500\u2500 _WheelBuilder._stable_abi\n    \u2502   \u2514\u2500\u2500 _WheelBuilder.tag\n    \u2514\u2500\u2500 _tags.py\n        \u251c\u2500\u2500 Tag.__init__\n        \u251c\u2500\u2500 Tag.__str__\n        \u251c\u2500\u2500 get_abi_tag\n        \u251c\u2500\u2500 get_interpreter_tag\n        \u2514\u2500\u2500 get_platform_tag\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to verify and manage platform compatibility tags for Python wheel distributions, ensuring accurate metadata and compatibility across environments. It enables the consistent generation and validation of wheel tags, including support for stable ABI versions, macOS platform-specific variations, and system-level compatibility factors such as processor architecture and deployment targets. By automating the validation process and handling complex tag scenarios, the module streamlines the packaging and distribution of Python applications, reducing errors and manual intervention for developers working with meson-based Python builds.\n\n## FILE 1: mesonpy/_tags.py\n\n- FUNCTION NAME: get_interpreter_tag\n  - SIGNATURE: def get_interpreter_tag() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representing the Python interpreter's tag, which includes the interpreter's name and version. The interpreter's name is obtained from `sys.implementation.name` and mapped to a more concise identifier using the `INTERPRETERS` constant, defined at the top of the code. The version is derived from `sys.version_info`, which provides major and minor version numbers. The resulting tag is formatted as `'{name}{major}{minor}'`, where `name` is the interpreter's identifier and `major` and `minor` are the version numbers. This function does not take any parameters and returns the constructed tag as a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mesonpy/_tags.py:Tag:__init__\n\n- FUNCTION NAME: get_platform_tag\n  - SIGNATURE: def get_platform_tag() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the platform tag for the current Python interpreter's operating system.\n\nThis function determines the platform tag based on the system's configuration using the `sysconfig.get_platform()` function. If the platform is macOS, it calls the helper function `_get_macosx_platform_tag()` to generate a detailed tag. For 32-bit interpreters run on 64-bit Linux, it returns specific tags for `linux-x86_64` and `linux-aarch64`. Otherwise, it formats the raw platform string by replacing hyphens and periods with underscores and converting it to lowercase.\n\nReturns:\n    str: A platform tag that reflects the current operating system, architecture, and Python interpreter's bitness.\n\nDependencies:\n- `_32_BIT_INTERPRETER`: A constant defined outside this function, indicating if the interpreter is 32-bit.\n- `sysconfig`: A module used to retrieve platform information.\n- `_get_macosx_platform_tag()`: A helper function called if the platform is macOS.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mesonpy/_tags.py:Tag:__init__\n\n- FUNCTION NAME: get_abi_tag\n  - SIGNATURE: def get_abi_tag() -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the ABI (Application Binary Interface) tag for the current Python interpreter. This tag is determined by parsing the `$SOABI` or `$EXT_SUFFIX` variables from the sysconfig module, as specified in PEP-314. If these variables are unavailable or cannot be parsed correctly, the function falls back to using the CPython ABI information obtained through the `_get_cpython_abi()` helper function.\n\nThe function interacts with the global constants defined in the code, specifically leveraging the `sys` and `sysconfig` modules to retrieve interpreter-related configurations. The `sys.implementation.name` is checked to ensure the fallback is only triggered for CPython, enhancing compatibility with other Python implementations like PyPy and GraalPy.\n\nThe output is a string formatted in a way that represents the Python ABI, with specific handling for known prefixes and removing unnecessary characters (like '.' and '-').\n\nReturns:\n    str: The ABI tag formatted for the current Python interpreter.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mesonpy/_tags.py:Tag:__init__\n\n- CLASS METHOD: Tag.__str__\n  - CLASS SIGNATURE: class Tag:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the Tag instance, formatted as 'interpreter-abi-platform'. \n\nThe interpreter, abi, and platform attributes of the Tag class are instantiated using the corresponding methods: `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` if not explicitly provided. The interpreter tag includes the Python implementation name (mapped from the `INTERPRETERS` constant) and its version. The ABI tag indicates the compatibility level for extensions, while the platform tag provides the underlying operating system and architecture details, with specific handling for macOS versions as described in the full code context. \n\nThe output is used to generate identifiers essential for packaging and distributing Python packages, ensuring compatibility across different environments.\n\"\"\"\n```\n\n- CLASS METHOD: Tag.__init__\n  - CLASS SIGNATURE: class Tag:\n  - SIGNATURE: def __init__(self, interpreter: Optional[str]=None, abi: Optional[str]=None, platform: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Tag object representing the Python environment's interpreter, ABI, and platform.\n\nParameters:\n- interpreter (Optional[str]): A string specifying the interpreter tag. If not provided, it defaults to the value returned by the `get_interpreter_tag()` function.\n- abi (Optional[str]): A string specifying the ABI tag. If not provided, it defaults to the value returned by the `get_abi_tag()` function.\n- platform (Optional[str]): A string specifying the platform tag. If not provided, it defaults to the value returned by the `get_platform_tag()` function.\n\nAttributes:\n- interpreter (str): The tag for the Python interpreter (e.g., 'cp38' for CPython 3.8).\n- abi (str): The tag representing the ABI (e.g., 'cp38m' for CPython 3.8 with pymalloc).\n- platform (str): The tag for the platform (e.g., 'linux_x86_64').\n\nDependencies:\n- Utilizes the functions `get_interpreter_tag()`, `get_abi_tag()`, and `get_platform_tag()` to determine default values for attributes if not specified during initialization. These functions rely on the `sys` and `sysconfig` modules to obtain details about the Python environment and configuration.\n\"\"\"\n```\n\n## FILE 2: mesonpy/__init__.py\n\n- CLASS METHOD: _WheelBuilder._stable_abi\n  - CLASS SIGNATURE: class _WheelBuilder:\n  - SIGNATURE: def _stable_abi(self) -> Optional[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine the stable ABI (Application Binary Interface) for Python extension modules in the context of the wheel being built.\n\nThis method checks if the package is compatible with Python's limited API and whether it is not running on PyPy (which does not provide a stable ABI). If the package is marked as using the limited API, it verifies that all installed extension modules in the `platlib` directory do not have version-specific ABI tags other than 'abi3'. If any are found, a `BuildError` is raised, indicating a conflict.\n\nReturns:\n    Optional[str]: Returns 'abi3' if the package is compatible with the limited API and has no conflicting extension modules. Otherwise, returns None.\n\nDependencies:\n- This method interacts with the `_limited_api` attribute of the `_WheelBuilder` class, which determines if the package targets Python's limited API.\n- It uses the `_manifest` attribute, specifically extracting files from the 'platlib' key to check for installed extension modules.\n- The `_EXTENSION_SUFFIX_REGEX` constant is defined in the full code context to match against the file names of extension modules to determine their ABI compatibility.\n\"\"\"\n```\n\n- CLASS METHOD: _WheelBuilder._has_extension_modules\n  - CLASS SIGNATURE: class _WheelBuilder:\n  - SIGNATURE: def _has_extension_modules(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine whether the Wheel contains any extension modules.\n\nThis property checks the `_manifest` attribute, which holds the mapping of files to be included in the Wheel, organized by wheel path. It specifically looks for entries in the `platlib` section of the manifest, which is assumed to contain platform-dependent code that ties to the Python ABI.\n\nReturns:\n    bool: True if there are extension modules in the `platlib` section, otherwise False.\n\nDependencies:\n    - _manifest: A property of the _WheelBuilder class that provides the mapping of files.\n\"\"\"\n```\n\n- CLASS METHOD: Error.__str__\n  - CLASS SIGNATURE: class Error(RuntimeError):\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the Error instance, extracting the first element from the `args` attribute. This method overrides the default string conversion behavior by providing a more specific message tied to the instantiation of the Error.\n\nParameters:\n- None.\n\nReturns:\n- A string that represents the error message associated with the Error instance.\n\nThis method is particularly useful for providing clear feedback during error handling, allowing other parts of the code that raise or catch the Error to easily access a human-readable message. The `args` attribute is utilized, which is defined at the time of the Error object creation, typically during an exception raise.\n\"\"\"\n```\n\n- CLASS METHOD: _WheelBuilder._pure\n  - CLASS SIGNATURE: class _WheelBuilder:\n  - SIGNATURE: def _pure(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine whether the built wheel is architecture-independent (pure). \n\nA wheel is considered pure if it does not contain platform-specific files. This method checks two main conditions:\n1. It verifies that neither 'platlib' (a key in the manifest) nor 'mesonpy-libs' contains any items, indicating no platform-dependent libraries or files.\n2. It iterates through the scripts in the manifest to check if any of them are native files using the helper function `_is_native`.\n\nReturns:\n    bool: True if the wheel is architecture-independent (pure), otherwise False.\n\nDependencies:\n    - `self._manifest`: A dictionary attribute containing wheel files organized by their destination directories, specifically checking for keys 'platlib' and 'mesonpy-libs'.\n    - `_is_native(file)`: A function that determines if a given file is a native binary for the current platform, which helps identify if script files are platform-dependent.\n\"\"\"\n```\n\n- CLASS METHOD: _WheelBuilder.tag\n  - CLASS SIGNATURE: class _WheelBuilder:\n  - SIGNATURE: def tag(self) -> mesonpy._tags.Tag:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the wheel tag for this package, which determines the compatibility of the wheel with different Python versions and implementations.\n\nThe method checks if the wheel is pure (architecture-independent) by evaluating the `_pure` property. If it is pure, it returns a tag of `('py3', 'none', 'any')`, indicating compatibility with any platform. If the wheel is not pure and does not contain any extension modules, it returns a tag of `('py3', 'none', None)` to indicate a generic implementation. Otherwise, it retrieves the stable ABI tag using the `_stable_abi` property and returns a tag with that ABI.\n\nThe method relies on the `mesonpy._tags.Tag` class to create the tag objects and the properties `_pure`, `_has_extension_modules`, and `_stable_abi` defined in the `_WheelBuilder` class. The constants representing the tags are important for determining the supported configurations for the wheel file.\n\"\"\"\n```\n\n- CLASS METHOD: _WheelBuilder.__init__\n  - CLASS SIGNATURE: class _WheelBuilder:\n  - SIGNATURE: def __init__(self, metadata: Metadata, manifest: Dict[str, List[Tuple[pathlib.Path, str]]], limited_api: bool) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a _WheelBuilder instance to facilitate the creation of Python wheel packages.\n\nParameters:\n- metadata (Metadata): An instance containing the package's metadata, which includes essential details such as name and version, and is validated according to PEP 503.\n- manifest (Dict[str, List[Tuple[pathlib.Path, str]]]): A mapping that organizes files to be included in the wheel by their corresponding directory paths. It is generated from the build process and helps determine which files belong to which wheel location.\n- limited_api (bool): A flag indicating whether the package uses Python's Limited API, impacting how the wheel is constructed and tagged.\n\nThis constructor sets the internal state of the _WheelBuilder, storing the provided metadata, manifest, and limited API flag for further usage in methods like `build()`, which creates the wheel file using the stored information.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mesonpy/_tags.py": "from __future__ import annotations\nimport os\nimport platform\nimport struct\nimport sys\nimport sysconfig\nimport typing\nif typing.TYPE_CHECKING:\n    from typing import Optional, Union\nINTERPRETERS = {'python': 'py', 'cpython': 'cp', 'pypy': 'pp', 'ironpython': 'ip', 'jython': 'jy'}\n_32_BIT_INTERPRETER = struct.calcsize('P') == 4\n\ndef _get_config_var(name: str, default: Union[str, int, None]=None) -> Union[str, int, None]:\n    value: Union[str, int, None] = sysconfig.get_config_var(name)\n    if value is None:\n        return default\n    return value\n\ndef _get_cpython_abi() -> str:\n    version = sys.version_info\n    debug = pymalloc = ''\n    if _get_config_var('Py_DEBUG', hasattr(sys, 'gettotalrefcount')):\n        debug = 'd'\n    if version < (3, 8) and _get_config_var('WITH_PYMALLOC', True):\n        pymalloc = 'm'\n    return f'cp{version[0]}{version[1]}{debug}{pymalloc}'\n\ndef _get_macosx_platform_tag() -> str:\n    ver, _, arch = platform.mac_ver()\n    try:\n        arch = os.environ.get('_PYTHON_HOST_PLATFORM', '').split('-')[2]\n    except IndexError:\n        pass\n    try:\n        version = tuple(map(int, os.environ.get('MACOSX_DEPLOYMENT_TARGET', '').split('.')))[:2]\n    except ValueError:\n        version = tuple(map(int, ver.split('.')))[:2]\n    if arch == 'arm64' and version < (11, 0):\n        version = (11, 0)\n    major, minor = version\n    if major >= 11:\n        minor = 0\n    if _32_BIT_INTERPRETER:\n        if arch == 'ppc64':\n            arch = 'ppc'\n        if arch == 'x86_64':\n            arch = 'i386'\n    return f'macosx_{major}_{minor}_{arch}'\n\nclass Tag:",
    "mesonpy/__init__.py": "\"\"\"Meson Python build backend\n\nImplements PEP 517 hooks.\n\"\"\"\nfrom __future__ import annotations\nimport argparse\nimport collections\nimport contextlib\nimport difflib\nimport functools\nimport importlib.machinery\nimport io\nimport itertools\nimport json\nimport os\nimport pathlib\nimport platform\nimport re\nimport shutil\nimport subprocess\nimport sys\nimport sysconfig\nimport tarfile\nimport tempfile\nimport textwrap\nimport typing\nimport warnings\nif sys.version_info < (3, 11):\n    import tomli as tomllib\nelse:\n    import tomllib\nimport packaging.utils\nimport packaging.version\nimport pyproject_metadata\nimport mesonpy._compat\nimport mesonpy._rpath\nimport mesonpy._tags\nimport mesonpy._util\nimport mesonpy._wheelfile\nfrom mesonpy._compat import cached_property, read_binary\nif typing.TYPE_CHECKING:\n    from typing import Any, Callable, DefaultDict, Dict, List, Literal, Optional, Sequence, TextIO, Tuple, Type, TypeVar, Union\n    from mesonpy._compat import Collection, Iterator, Mapping, ParamSpec, Path, Self\n    P = ParamSpec('P')\n    T = TypeVar('T')\n    MesonArgsKeys = Literal['dist', 'setup', 'compile', 'install']\n    MesonArgs = Mapping[MesonArgsKeys, List[str]]\n_NINJA_REQUIRED_VERSION = '1.8.2'\n_MESON_REQUIRED_VERSION = '0.63.3'\n_MESON_ARGS_KEYS = ['dist', 'setup', 'compile', 'install']\n_SUFFIXES = importlib.machinery.all_suffixes()\n_EXTENSION_SUFFIX_REGEX = re.compile('^[^.]+\\\\.(?:(?P<abi>[^.]+)\\\\.)?(?:so|pyd|dll)$')\nassert all((re.match(_EXTENSION_SUFFIX_REGEX, f'foo{x}') for x in importlib.machinery.EXTENSION_SUFFIXES))\n_INSTALLATION_PATH_MAP = {'{bindir}': 'scripts', '{py_purelib}': 'purelib', '{py_platlib}': 'platlib', '{moduledir_shared}': 'platlib', '{includedir}': 'headers', '{datadir}': 'data', '{libdir}': 'mesonpy-libs', '{libdir_shared}': 'mesonpy-libs'}\n\ndef _map_to_wheel(sources: Dict[str, Dict[str, Any]]) -> DefaultDict[str, List[Tuple[pathlib.Path, str]]]:\n    \"\"\"Map files to the wheel, organized by wheel installation directory.\"\"\"\n    wheel_files: DefaultDict[str, List[Tuple[pathlib.Path, str]]] = collections.defaultdict(list)\n    packages: Dict[str, str] = {}\n    for key, group in sources.items():\n        for src, target in group.items():\n            destination = pathlib.Path(target['destination'])\n            anchor = destination.parts[0]\n            dst = pathlib.Path(*destination.parts[1:])\n            path = _INSTALLATION_PATH_MAP.get(anchor)\n            if path is None:\n                raise BuildError(f'Could not map installation path to an equivalent wheel directory: {str(destination)!r}')\n            if path == 'purelib' or path == 'platlib':\n                package = destination.parts[1]\n                other = packages.setdefault(package, path)\n                if other != path:\n                    this = os.fspath(pathlib.Path(path, *destination.parts[1:]))\n                    that = os.fspath(other / next((d for d, s in wheel_files[other] if d.parts[0] == destination.parts[1])))\n                    raise BuildError(f'''The {package} package is split between {path} and {other}: {this!r} and {that!r}, a \"pure: false\" argument may be missing in meson.build. It is recommended to set it in \"import('python').find_installation()\"''')\n            if key == 'install_subdirs' or (key == 'targets' and os.path.isdir(src)):\n                exclude_files = {os.path.normpath(x) for x in target.get('exclude_files', [])}\n                exclude_dirs = {os.path.normpath(x) for x in target.get('exclude_dirs', [])}\n                for root, dirnames, filenames in os.walk(src):\n                    for name in dirnames.copy():\n                        dirsrc = os.path.join(root, name)\n                        relpath = os.path.relpath(dirsrc, src)\n                        if relpath in exclude_dirs:\n                            dirnames.remove(name)\n                    dirnames.sort()\n                    for name in sorted(filenames):\n                        filesrc = os.path.join(root, name)\n                        relpath = os.path.relpath(filesrc, src)\n                        if relpath in exclude_files:\n                            continue\n                        filedst = dst / relpath\n                        wheel_files[path].append((filedst, filesrc))\n            else:\n                wheel_files[path].append((dst, src))\n    return wheel_files\n\nclass style:\n    ERROR = '\\x1b[31m'\n    WARNING = '\\x1b[93m'\n    INFO = '\\x1b[36m\\x1b[1m'\n    RESET = '\\x1b[0m'\n\n    @staticmethod\n    def strip(string: str) -> str:\n        \"\"\"Strip ANSI escape sequences from string.\"\"\"\n        return re.sub('\\\\033\\\\[[;?0-9]*[a-zA-Z]', '', string)\n\n@functools.lru_cache()\ndef _use_ansi_escapes() -> bool:\n    \"\"\"Determine whether logging should use ANSI escapes.\"\"\"\n    sys.stdout.reconfigure(errors='replace')\n    if 'NO_COLOR' in os.environ:\n        return False\n    if 'FORCE_COLOR' in os.environ or (sys.stdout.isatty() and os.environ.get('TERM') != 'dumb'):\n        if sys.platform == 'win32' and (not os.environ.get('ANSICON')):\n            return mesonpy._util.setup_windows_console()\n        return True\n    return False\n\ndef _log(string: str, **kwargs: Any) -> None:\n    if not _use_ansi_escapes():\n        string = style.strip(string)\n    print(string, **kwargs)\n\ndef _showwarning(message: Union[Warning, str], category: Type[Warning], filename: str, lineno: int, file: Optional[TextIO]=None, line: Optional[str]=None) -> None:\n    \"\"\"Callable to override the default warning handler, to have colored output.\"\"\"\n    _log(f'{style.WARNING}meson-python: warning:{style.RESET} {message}')\n\nclass _clicounter:\n\n    def __init__(self, total: int) -> None:\n        self._total = total\n        self._count = itertools.count(start=1)\n\n    def __enter__(self) -> Self:\n        return self\n\n    def update(self, description: str) -> None:\n        line = f'[{next(self._count)}/{self._total}] {description}'\n        if _use_ansi_escapes():\n            print('\\r', line, sep='', end='\\x1b[0K', flush=True)\n        else:\n            print(line)\n\n    def __exit__(self, exc_type: Any, exc_value: Any, exc_tb: Any) -> None:\n        if _use_ansi_escapes():\n            print()\n\nclass Error(RuntimeError):\n\nclass ConfigError(Error):\n    \"\"\"Error in the backend configuration.\"\"\"\n\nclass BuildError(Error):\n    \"\"\"Error when building the wheel.\"\"\"\n\nclass MesonBuilderError(Error):\n    \"\"\"Error when building the Meson package.\"\"\"\n\nclass Metadata(pyproject_metadata.StandardMetadata):\n\n    def __init__(self, name: str, *args: Any, **kwargs: Any):\n        if not re.match('^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$', name, re.IGNORECASE):\n            raise pyproject_metadata.ConfigurationError(f'Invalid project name \"{name}\". A valid name consists only of ASCII letters and numbers, period, underscore and hyphen. It must start and end with a letter or number')\n        super().__init__(name, *args, **kwargs)\n\n    @classmethod\n    def from_pyproject(cls, data: Mapping[str, Any], project_dir: Path=os.path.curdir, metadata_version: Optional[str]=None) -> Self:\n        metadata = super().from_pyproject(data, project_dir, metadata_version)\n        unsupported_dynamic = set(metadata.dynamic) - {'version'}\n        if unsupported_dynamic:\n            fields = ', '.join((f'\"{x}\"' for x in unsupported_dynamic))\n            raise pyproject_metadata.ConfigurationError(f'Unsupported dynamic fields: {fields}')\n        return metadata\n\n    @property\n    def distribution_name(self) -> str:\n        \"\"\"Name to be used in wheel and sdist file names.\"\"\"\n        return self.canonical_name.replace('-', '_')\n\ndef _is_native(file: Path) -> bool:\n    \"\"\"Check if file is a native file.\"\"\"\n    with open(file, 'rb') as f:\n        if sys.platform == 'darwin':\n            return f.read(4) in (b'\\xfe\\xed\\xfa\\xce', b'\\xfe\\xed\\xfa\\xcf', b'\\xcf\\xfa\\xed\\xfe', b'\\xca\\xfe\\xba\\xbe')\n        elif sys.platform == 'win32' or sys.platform == 'cygwin':\n            return f.read(2) == b'MZ'\n        else:\n            return f.read(4) == b'\\x7fELF'\n\nclass _WheelBuilder:\n    \"\"\"Helper class to build wheels from projects.\"\"\"\n\n    @property\n    def _has_internal_libs(self) -> bool:\n        return bool(self._manifest.get('mesonpy-libs'))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Wheel name, this includes the basename and tag.\"\"\"\n        return f'{self._metadata.distribution_name}-{self._metadata.version}-{self.tag}'\n\n    @property\n    def _distinfo_dir(self) -> str:\n        return f'{self._metadata.distribution_name}-{self._metadata.version}.dist-info'\n\n    @property\n    def _data_dir(self) -> str:\n        return f'{self._metadata.distribution_name}-{self._metadata.version}.data'\n\n    @property\n    def _libs_dir(self) -> str:\n        return f'.{self._metadata.distribution_name}.mesonpy.libs'\n\n    @property\n    def _license_file(self) -> Optional[pathlib.Path]:\n        license_ = self._metadata.license\n        if license_ and isinstance(license_, pyproject_metadata.License):\n            return license_.file\n        return None\n\n    @property\n    def wheel(self) -> bytes:\n        \"\"\"Return WHEEL file for dist-info.\"\"\"\n        return textwrap.dedent('\\n            Wheel-Version: 1.0\\n            Generator: meson\\n            Root-Is-Purelib: {is_purelib}\\n            Tag: {tag}\\n        ').strip().format(is_purelib='true' if self._pure else 'false', tag=self.tag).encode()\n\n    @property\n    def entrypoints_txt(self) -> bytes:\n        \"\"\"dist-info entry_points.txt.\"\"\"\n        data = self._metadata.entrypoints.copy()\n        data.update({'console_scripts': self._metadata.scripts, 'gui_scripts': self._metadata.gui_scripts})\n        text = ''\n        for entrypoint in data:\n            if data[entrypoint]:\n                text += f'[{entrypoint}]\\n'\n                for name, target in data[entrypoint].items():\n                    text += f'{name} = {target}\\n'\n                text += '\\n'\n        return text.encode()\n\n    def _install_path(self, wheel_file: mesonpy._wheelfile.WheelFile, origin: Path, destination: pathlib.Path) -> None:\n        \"\"\"Add a file to the wheel.\"\"\"\n        if self._has_internal_libs:\n            if _is_native(origin):\n                libspath = os.path.relpath(self._libs_dir, destination.parent)\n                mesonpy._rpath.fix_rpath(origin, libspath)\n        try:\n            wheel_file.write(origin, destination.as_posix())\n        except FileNotFoundError:\n            if not os.fspath(origin).endswith('.pdb'):\n                raise\n\n    def _wheel_write_metadata(self, whl: mesonpy._wheelfile.WheelFile) -> None:\n        whl.writestr(f'{self._distinfo_dir}/METADATA', bytes(self._metadata.as_rfc822()))\n        whl.writestr(f'{self._distinfo_dir}/WHEEL', self.wheel)\n        if self.entrypoints_txt:\n            whl.writestr(f'{self._distinfo_dir}/entry_points.txt', self.entrypoints_txt)\n        if self._license_file:\n            whl.write(self._license_file, f'{self._distinfo_dir}/{os.path.basename(self._license_file)}')\n\n    def build(self, directory: Path) -> pathlib.Path:\n        wheel_file = pathlib.Path(directory, f'{self.name}.whl')\n        with mesonpy._wheelfile.WheelFile(wheel_file, 'w') as whl:\n            self._wheel_write_metadata(whl)\n            with _clicounter(sum((len(x) for x in self._manifest.values()))) as counter:\n                root = 'purelib' if self._pure else 'platlib'\n                for path, entries in self._manifest.items():\n                    for dst, src in entries:\n                        counter.update(src)\n                        if path == root:\n                            pass\n                        elif path == 'mesonpy-libs':\n                            dst = pathlib.Path(self._libs_dir, dst)\n                        else:\n                            dst = pathlib.Path(self._data_dir, path, dst)\n                        self._install_path(whl, src, dst)\n        return wheel_file\n\nclass _EditableWheelBuilder(_WheelBuilder):\n\n    @property\n    def _top_level_modules(self) -> Collection[str]:\n        modules = set()\n        for type_ in self._manifest:\n            for path, _ in self._manifest[type_]:\n                name, dot, ext = path.parts[0].partition('.')\n                if dot:\n                    suffix = dot + ext\n                    if suffix in _SUFFIXES:\n                        modules.add(name)\n                else:\n                    modules.add(name)\n        return modules\n\n    def build(self, directory: Path, source_dir: pathlib.Path, build_dir: pathlib.Path, build_command: List[str], verbose: bool=False) -> pathlib.Path:\n        wheel_file = pathlib.Path(directory, f'{self.name}.whl')\n        with mesonpy._wheelfile.WheelFile(wheel_file, 'w') as whl:\n            self._wheel_write_metadata(whl)\n            whl.writestr(f'{self._distinfo_dir}/direct_url.json', source_dir.as_uri().encode('utf-8'))\n            loader_module_name = f'_{self._metadata.distribution_name}_editable_loader'\n            whl.writestr(f'{loader_module_name}.py', read_binary('mesonpy', '_editable.py') + textwrap.dedent(f'\\n                   install(\\n                       {self._metadata.name!r},\\n                       {self._top_level_modules!r},\\n                       {os.fspath(build_dir)!r},\\n                       {build_command!r},\\n                       {verbose!r},\\n                   )').encode('utf-8'))\n            whl.writestr(f'{self._metadata.canonical_name}-editable.pth', f'import {loader_module_name}'.encode('utf-8'))\n        return wheel_file\n\ndef _validate_pyproject_config(pyproject: Dict[str, Any]) -> Dict[str, Any]:\n\n    def _table(scheme: Dict[str, Callable[[Any, str], Any]]) -> Callable[[Any, str], Dict[str, Any]]:\n\n        def func(value: Any, name: str) -> Dict[str, Any]:\n            if not isinstance(value, dict):\n                raise ConfigError(f'Configuration entry \"{name}\" must be a table')\n            table = {}\n            for key, val in value.items():\n                check = scheme.get(key)\n                if check is None:\n                    raise ConfigError(f'Unknown configuration entry \"{name}.{key}\"')\n                table[key] = check(val, f'{name}.{key}')\n            return table\n        return func\n\n    def _strings(value: Any, name: str) -> List[str]:\n        if not isinstance(value, list) or not all((isinstance(x, str) for x in value)):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a list of strings')\n        return value\n\n    def _bool(value: Any, name: str) -> bool:\n        if not isinstance(value, bool):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a boolean')\n        return value\n\n    def _string_or_path(value: Any, name: str) -> str:\n        if not isinstance(value, str):\n            raise ConfigError(f'Configuration entry \"{name}\" must be a string')\n        if os.path.isfile(value):\n            value = os.path.abspath(value)\n        return value\n    scheme = _table({'meson': _string_or_path, 'limited-api': _bool, 'args': _table({name: _strings for name in _MESON_ARGS_KEYS})})\n    table = pyproject.get('tool', {}).get('meson-python', {})\n    return scheme(table, 'tool.meson-python')\n\ndef _validate_config_settings(config_settings: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Validate options received from build frontend.\"\"\"\n\n    def _string(value: Any, name: str) -> str:\n        if not isinstance(value, str):\n            raise ConfigError(f'Only one value for \"{name}\" can be specified')\n        return value\n\n    def _bool(value: Any, name: str) -> bool:\n        return True\n\n    def _string_or_strings(value: Any, name: str) -> List[str]:\n        return list([value] if isinstance(value, str) else value)\n    options = {'builddir': _string, 'build-dir': _string, 'editable-verbose': _bool, 'dist-args': _string_or_strings, 'setup-args': _string_or_strings, 'compile-args': _string_or_strings, 'install-args': _string_or_strings}\n    assert all((f'{name}-args' in options for name in _MESON_ARGS_KEYS))\n    config = {}\n    for key, value in config_settings.items():\n        parser = options.get(key)\n        if parser is None:\n            matches = difflib.get_close_matches(key, options.keys(), n=2)\n            if matches:\n                alternatives = ' or '.join((f'\"{match}\"' for match in matches))\n                raise ConfigError(f'Unknown option \"{key}\". Did you mean {alternatives}?')\n            else:\n                raise ConfigError(f'Unknown option \"{key}\"')\n        config[key] = parser(value, key)\n    aliases = {'build-dir': 'builddir'}\n    for key, alt in aliases.items():\n        if key in config and alt in config:\n            raise ConfigError(f'Option \"{alt}\" is a backward compatibility alias for \"{key}\". Only one can be used')\n        if alt in config:\n            config[key] = config[alt]\n    return config\n\nclass Project:\n    \"\"\"Meson project wrapper to generate Python artifacts.\"\"\"\n\n    def __init__(self, source_dir: Path, build_dir: Path, meson_args: Optional[MesonArgs]=None, editable_verbose: bool=False) -> None:\n        self._source_dir = pathlib.Path(source_dir).absolute()\n        self._build_dir = pathlib.Path(build_dir).absolute()\n        self._editable_verbose = editable_verbose\n        self._meson_native_file = self._build_dir / 'meson-python-native-file.ini'\n        self._meson_cross_file = self._build_dir / 'meson-python-cross-file.ini'\n        self._meson_args: MesonArgs = collections.defaultdict(list)\n        self._limited_api = False\n        pyproject = tomllib.loads(self._source_dir.joinpath('pyproject.toml').read_text(encoding='utf-8'))\n        pyproject_config = _validate_pyproject_config(pyproject)\n        for key, value in pyproject_config.get('args', {}).items():\n            self._meson_args[key].extend(value)\n        if meson_args:\n            for key, value in meson_args.items():\n                self._meson_args[key].extend(value)\n        self._meson = _get_meson_command(pyproject_config.get('meson'))\n        self._ninja = _env_ninja_command()\n        if self._ninja is None:\n            raise ConfigError(f'Could not find ninja version {_NINJA_REQUIRED_VERSION} or newer.')\n        os.environ.setdefault('NINJA', self._ninja)\n        self._build_dir.mkdir(exist_ok=True, parents=True)\n        if not any(self._build_dir.iterdir()):\n            _add_ignore_files(self._build_dir)\n        if sysconfig.get_platform().startswith('macosx-'):\n            archflags = os.environ.get('ARCHFLAGS', '').strip()\n            if archflags:\n                parser = argparse.ArgumentParser(add_help=False, allow_abbrev=False)\n                parser.add_argument('-arch', action='append')\n                args, unknown = parser.parse_known_args(archflags.split())\n                if unknown:\n                    raise ConfigError(f'Unknown flag specified in $ARCHFLAGS={archflags!r}')\n                arch, *other = set(args.arch)\n                if other:\n                    raise ConfigError(f'Multi-architecture builds are not supported but $ARCHFLAGS={archflags!r}')\n                macver, _, nativearch = platform.mac_ver()\n                if arch != nativearch:\n                    x = os.environ.setdefault('_PYTHON_HOST_PLATFORM', f'macosx-{macver}-{arch}')\n                    if not x.endswith(arch):\n                        raise ConfigError(f'$ARCHFLAGS={archflags!r} and $_PYTHON_HOST_PLATFORM={x!r} do not agree')\n                    family = 'aarch64' if arch == 'arm64' else arch\n                    cross_file_data = textwrap.dedent(f\"\\n                        [binaries]\\n                        c = ['cc', '-arch', {arch!r}]\\n                        cpp = ['c++', '-arch', {arch!r}]\\n                        objc = ['cc', '-arch', {arch!r}]\\n                        objcpp = ['c++', '-arch', {arch!r}]\\n                        [host_machine]\\n                        system = 'darwin'\\n                        cpu = {arch!r}\\n                        cpu_family = {family!r}\\n                        endian = 'little'\\n                    \")\n                    self._meson_cross_file.write_text(cross_file_data, encoding='utf-8')\n                    self._meson_args['setup'].extend(('--cross-file', os.fspath(self._meson_cross_file)))\n        native_file_data = textwrap.dedent(f\"\\n            [binaries]\\n            python = '{sys.executable}'\\n        \")\n        self._meson_native_file.write_text(native_file_data, encoding='utf-8')\n        reconfigure = self._build_dir.joinpath('meson-private/coredata.dat').is_file()\n        self._configure(reconfigure=reconfigure)\n        if 'project' in pyproject:\n            self._metadata = Metadata.from_pyproject(pyproject, self._source_dir)\n            if 'version' in self._metadata.dynamic:\n                version = self._meson_version\n                if version == 'undefined':\n                    raise pyproject_metadata.ConfigurationError('Field \"version\" declared as dynamic but version is not defined in meson.build')\n                self._metadata.version = packaging.version.Version(version)\n        else:\n            name, version = (self._meson_name, self._meson_version)\n            if version == 'undefined':\n                raise pyproject_metadata.ConfigurationError('Section \"project\" missing in pyproject.toml and version is not defined in meson.build')\n            self._metadata = Metadata(name=name, version=packaging.version.Version(version))\n        if self._metadata.requires_python:\n            self._metadata.requires_python.prereleases = True\n            if platform.python_version().rstrip('+') not in self._metadata.requires_python:\n                raise MesonBuilderError(f'The package requires Python version {self._metadata.requires_python}, running on {platform.python_version()}')\n        self._limited_api = pyproject_config.get('limited-api', False)\n        if self._limited_api:\n            options = self._info('intro-buildoptions')\n            value = next((option['value'] for option in options if option['name'] == 'python.allow_limited_api'), None)\n            if not value:\n                self._limited_api = False\n        if self._limited_api and bool(sysconfig.get_config_var('Py_GIL_DISABLED')):\n            raise BuildError('The package targets Python\\'s Limited API, which is not supported by free-threaded CPython. The \"python.allow_limited_api\" Meson build option may be used to override the package default.')\n\n    def _run(self, cmd: Sequence[str]) -> None:\n        \"\"\"Invoke a subprocess.\"\"\"\n        _log('{style.INFO}+ {cmd}{style.RESET}'.format(style=style, cmd=' '.join(cmd)), flush=True)\n        r = subprocess.run(cmd, cwd=self._build_dir)\n        if r.returncode != 0:\n            raise SystemExit(r.returncode)\n\n    def _configure(self, reconfigure: bool=False) -> None:\n        \"\"\"Configure Meson project.\"\"\"\n        setup_args = [os.fspath(self._source_dir), os.fspath(self._build_dir), '-Dbuildtype=release', '-Db_ndebug=if-release', '-Db_vscrt=md', *self._meson_args['setup'], f'--native-file={os.fspath(self._meson_native_file)}']\n        if reconfigure:\n            setup_args.insert(0, '--reconfigure')\n        self._run(self._meson + ['setup', *setup_args])\n\n    @property\n    def _build_command(self) -> List[str]:\n        assert self._ninja is not None\n        if sys.platform == 'win32':\n            cmd = self._meson + ['compile']\n            args = list(self._meson_args['compile'])\n            if args:\n                cmd.append(f'--ninja-args={args!r}')\n            return cmd\n        return [self._ninja, *self._meson_args['compile']]\n\n    @functools.lru_cache(maxsize=None)\n    def build(self) -> None:\n        \"\"\"Build the Meson project.\"\"\"\n        self._run(self._build_command)\n\n    @functools.lru_cache()\n    def _info(self, name: str) -> Any:\n        \"\"\"Read info from meson-info directory.\"\"\"\n        info = self._build_dir.joinpath('meson-info', f'{name}.json')\n        return json.loads(info.read_text(encoding='utf-8'))\n\n    @property\n    def _manifest(self) -> DefaultDict[str, List[Tuple[pathlib.Path, str]]]:\n        \"\"\"The files to be added to the wheel, organized by wheel path.\"\"\"\n        install_plan = self._info('intro-install_plan')\n        parser = argparse.ArgumentParser(add_help=False)\n        parser.add_argument('--tags')\n        parser.add_argument('--skip-subprojects', nargs='?', const='*', default='')\n        args, _ = parser.parse_known_args(self._meson_args['install'])\n        install_tags = {t.strip() for t in args.tags.split(',')} if args.tags else None\n        skip_subprojects = {p for p in (p.strip() for p in args.skip_subprojects.split(',')) if p}\n        sources: DefaultDict[str, Dict[str, Dict[str, str]]] = collections.defaultdict(dict)\n        for key, targets in install_plan.items():\n            for target, details in targets.items():\n                if install_tags is not None and details['tag'] not in install_tags:\n                    continue\n                subproject = details.get('subproject')\n                if subproject is not None and (subproject in skip_subprojects or '*' in skip_subprojects):\n                    continue\n                sources[key][target] = details\n        return _map_to_wheel(sources)\n\n    @property\n    def _meson_name(self) -> str:\n        \"\"\"Name in meson.build.\"\"\"\n        name = self._info('intro-projectinfo')['descriptive_name']\n        assert isinstance(name, str)\n        return name\n\n    @property\n    def _meson_version(self) -> str:\n        \"\"\"Version in meson.build.\"\"\"\n        name = self._info('intro-projectinfo')['version']\n        assert isinstance(name, str)\n        return name\n\n    def sdist(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates a sdist (source distribution) in the specified directory.\"\"\"\n        self._run(self._meson + ['dist', '--allow-dirty', '--no-tests', '--formats', 'gztar', *self._meson_args['dist']])\n        dist_name = f'{self._metadata.distribution_name}-{self._metadata.version}'\n        meson_dist_name = f'{self._meson_name}-{self._meson_version}'\n        meson_dist_path = pathlib.Path(self._build_dir, 'meson-dist', f'{meson_dist_name}.tar.gz')\n        sdist_path = pathlib.Path(directory, f'{dist_name}.tar.gz')\n        pyproject_toml_mtime = 0\n        with tarfile.open(meson_dist_path, 'r:gz') as meson_dist, mesonpy._util.create_targz(sdist_path) as sdist:\n            for member in meson_dist.getmembers():\n                if member.isfile():\n                    file = meson_dist.extractfile(member.name)\n                    member.pax_headers = {}\n                    stem = member.name.split('/', 1)[1]\n                    member.name = '/'.join((dist_name, stem))\n                    if stem == 'pyproject.toml':\n                        pyproject_toml_mtime = member.mtime\n                    member.uname = member.gname = 'root'\n                    member.uid = member.gid = 0\n                    sdist.addfile(member, file)\n            member = tarfile.TarInfo(f'{dist_name}/PKG-INFO')\n            member.uid = member.gid = 0\n            member.uname = member.gname = 'root'\n            member.mtime = pyproject_toml_mtime\n            metadata = bytes(self._metadata.as_rfc822())\n            member.size = len(metadata)\n            sdist.addfile(member, io.BytesIO(metadata))\n        return sdist_path\n\n    def wheel(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates a wheel in the specified directory.\"\"\"\n        self.build()\n        builder = _WheelBuilder(self._metadata, self._manifest, self._limited_api)\n        return builder.build(directory)\n\n    def editable(self, directory: Path) -> pathlib.Path:\n        \"\"\"Generates an editable wheel in the specified directory.\"\"\"\n        self.build()\n        builder = _EditableWheelBuilder(self._metadata, self._manifest, self._limited_api)\n        return builder.build(directory, self._source_dir, self._build_dir, self._build_command, self._editable_verbose)\n\n@contextlib.contextmanager\ndef _project(config_settings: Optional[Dict[Any, Any]]=None) -> Iterator[Project]:\n    \"\"\"Create the project given the given config settings.\"\"\"\n    settings = _validate_config_settings(config_settings or {})\n    meson_args = typing.cast('MesonArgs', {name: settings.get(f'{name}-args', []) for name in _MESON_ARGS_KEYS})\n    source_dir = os.path.curdir\n    build_dir = settings.get('build-dir')\n    editable_verbose = bool(settings.get('editable-verbose'))\n    with contextlib.ExitStack() as ctx:\n        if build_dir is None:\n            build_dir = ctx.enter_context(tempfile.TemporaryDirectory(prefix='.mesonpy-', dir=source_dir))\n        yield Project(source_dir, build_dir, meson_args, editable_verbose)\n\ndef _parse_version_string(string: str) -> Tuple[int, ...]:\n    \"\"\"Parse version string.\"\"\"\n    try:\n        return tuple(map(int, string.split('.')[:3]))\n    except ValueError:\n        return (0,)\n\ndef _get_meson_command(meson: Optional[str]=None, *, version: str=_MESON_REQUIRED_VERSION) -> List[str]:\n    \"\"\"Return the command to invoke meson.\"\"\"\n    meson = os.environ.get('MESON', meson or 'meson')\n    if meson.endswith('.py'):\n        if not os.path.exists(meson):\n            raise ConfigError(f'Could not find the specified meson: \"{meson}\"')\n        cmd = [sys.executable, meson]\n    else:\n        cmd = [meson]\n    try:\n        r = subprocess.run(cmd + ['--version'], text=True, capture_output=True)\n    except FileNotFoundError as err:\n        raise ConfigError(f'meson executable \"{meson}\" not found') from err\n    if r.returncode != 0:\n        raise ConfigError(f'Could not execute meson: {r.stderr.strip()}')\n    meson_version = r.stdout.strip()\n    if _parse_version_string(meson_version) < _parse_version_string(version):\n        raise ConfigError(f'Could not find meson version {version} or newer, found {meson_version}.')\n    return cmd\n\ndef _env_ninja_command(*, version: str=_NINJA_REQUIRED_VERSION) -> Optional[str]:\n    \"\"\"Returns the path to ninja, or None if no ninja found.\"\"\"\n    required_version = _parse_version_string(version)\n    env_ninja = os.environ.get('NINJA')\n    ninja_candidates = [env_ninja] if env_ninja else ['ninja', 'ninja-build', 'samu']\n    for ninja in ninja_candidates:\n        ninja_path = shutil.which(ninja)\n        if ninja_path is not None:\n            version = subprocess.run([ninja_path, '--version'], check=False, text=True, capture_output=True).stdout\n            if _parse_version_string(version) >= required_version:\n                return ninja_path\n    return None\n\ndef _add_ignore_files(directory: pathlib.Path) -> None:\n    directory.joinpath('.gitignore').write_text(textwrap.dedent('\\n        # This file is generated by meson-python. It will not be recreated if deleted or modified.\\n        *\\n    '), encoding='utf-8')\n    directory.joinpath('.hgignore').write_text(textwrap.dedent('\\n        # This file is generated by meson-python. It will not be recreated if deleted or modified.\\n        syntax: glob\\n        **/*\\n    '), encoding='utf-8')\n\ndef _pyproject_hook(func: Callable[P, T]) -> Callable[P, T]:\n\n    @functools.wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        warnings.showwarning = _showwarning\n        try:\n            return func(*args, **kwargs)\n        except (Error, pyproject_metadata.ConfigurationError) as exc:\n            prefix = f'{style.ERROR}meson-python: error:{style.RESET} '\n            _log('\\n' + textwrap.indent(str(exc), prefix))\n            raise SystemExit(1) from exc\n    return wrapper\n\n@_pyproject_hook\ndef get_requires_for_build_sdist(config_settings: Optional[Dict[str, str]]=None) -> List[str]:\n    dependencies = []\n    if os.environ.get('NINJA') is None and _env_ninja_command() is None:\n        dependencies.append(f'ninja >= {_NINJA_REQUIRED_VERSION}')\n    return dependencies\n\n@_pyproject_hook\ndef get_requires_for_build_wheel(config_settings: Optional[Dict[str, str]]=None) -> List[str]:\n    dependencies = []\n    if os.environ.get('NINJA') is None and _env_ninja_command() is None:\n        dependencies.append(f'ninja >= {_NINJA_REQUIRED_VERSION}')\n    if sys.platform.startswith('linux') and (not shutil.which('patchelf')):\n        dependencies.append('patchelf >= 0.11.0')\n    return dependencies\nget_requires_for_build_editable = get_requires_for_build_wheel\n\n@_pyproject_hook\ndef build_sdist(sdist_directory: str, config_settings: Optional[Dict[Any, Any]]=None) -> str:\n    out = pathlib.Path(sdist_directory)\n    with _project(config_settings) as project:\n        return project.sdist(out).name\n\n@_pyproject_hook\ndef build_wheel(wheel_directory: str, config_settings: Optional[Dict[Any, Any]]=None, metadata_directory: Optional[str]=None) -> str:\n    out = pathlib.Path(wheel_directory)\n    with _project(config_settings) as project:\n        return project.wheel(out).name\n\n@_pyproject_hook\ndef build_editable(wheel_directory: str, config_settings: Optional[Dict[Any, Any]]=None, metadata_directory: Optional[str]=None) -> str:\n    if not config_settings:\n        config_settings = {}\n    if 'build-dir' not in config_settings and 'builddir' not in config_settings:\n        config_settings['build-dir'] = 'build/' + mesonpy._tags.get_abi_tag()\n    out = pathlib.Path(wheel_directory)\n    with _project(config_settings) as project:\n        return project.editable(out).name"
  }
}