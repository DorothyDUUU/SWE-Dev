{
  "dir_path": "/app/stestr",
  "package_name": "stestr",
  "sample_name": "stestr-test_test_processor",
  "src_dir": "stestr/",
  "test_dir": "stestr/tests/",
  "test_file": "modified_testcases/test_test_processor.py",
  "test_code": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport subprocess\nfrom unittest import mock\n\nfrom stestr import test_processor\nfrom stestr.tests import base\n\n\nclass TestTestProcessorFixture(base.TestCase):\n    def setUp(self):\n        super().setUp()\n        self._fixture = test_processor.TestProcessorFixture(\n            mock.sentinel.test_ids,\n            mock.sentinel.options,\n            mock.sentinel.cmd_template,\n            mock.sentinel.listopt,\n            mock.sentinel.idoption,\n            mock.sentinel.repository,\n        )\n\n    @mock.patch.object(subprocess, \"Popen\")\n    @mock.patch.object(test_processor, \"sys\")\n    def _check_start_process(\n        self, mock_sys, mock_Popen, platform=\"win32\", expected_fn=None\n    ):\n        mock_sys.platform = platform\n\n        self._fixture._start_process(mock.sentinel.cmd)\n\n        mock_Popen.assert_called_once_with(\n            mock.sentinel.cmd,\n            shell=True,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            preexec_fn=expected_fn,\n        )\n\n    def test_start_process_win32(self):\n        self._check_start_process()\n\n    def test_start_process_linux(self):\n        self._check_start_process(\n            platform=\"linux2\", expected_fn=self._fixture._clear_SIGPIPE\n        )\n",
  "GT_file_code": {
    "stestr/test_processor.py": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport io\nimport os\nimport re\nimport signal\nimport subprocess\nimport sys\nimport tempfile\n\nimport fixtures\nfrom subunit import v2\n\nfrom stestr import results\nfrom stestr import scheduler\nfrom stestr import selection\nfrom stestr import testlist\n\n\nclass TestProcessorFixture(fixtures.Fixture):\n    \"\"\"Write a temporary file to disk with test ids in it.\n\n    The TestProcessorFixture is used to handle the lifecycle of running\n    the subunit.run commands. A fixture is used for this class to handle\n    the temporary list files creation.\n\n    :param test_ids: The test_ids to use. May be None indicating that\n        no ids are known and they should be discovered by listing or\n        configuration if they must be known to run tests. Test ids are\n        needed to run tests when filtering or partitioning is needed: if\n        the run concurrency is > 1 partitioning is needed, and filtering is\n        needed if the user has passed in filters.\n    :param cmd_template: string to be used for the command that will be\n        filled out with the IDFILE when it is created.\n    :param listopt: Option to substitute into LISTOPT to cause test listing\n                    to take place.\n    :param idoption: Option to substitute into cmd when supplying any test ids.\n    :param repository: The repository to query for test times, if needed.\n    :param parallel: If not True, prohibit parallel use : used to implement\n                     --parallel run recursively.\n    :param listpath: The file listing path to use. If None, a unique path\n                     is created.\n    :param test_filters: An optional list of test filters to apply. Each\n        filter should be a string suitable for passing to re.compile.\n        Filters are applied using search() rather than match(), so if\n        anchoring is needed it should be included in the regex.\n        The test ids used for executing are the union of all the\n        individual filters: to take the intersection instead, craft a\n        single regex that matches all your criteria. Filters are\n        automatically applied by run_tests(), or can be applied by calling\n        filter_tests(test_ids).\n    :param group_callback: If supplied, should be a function that accepts a\n        test id and returns a group id. A group id is an arbitrary value\n        used as a dictionary key in the scheduler. All test ids with the\n        same group id are scheduled onto the same backend test process.\n    :param bool serial: Run tests serially\n    :param path worker_path: Optional path of a manual worker grouping file\n        to use for the run\n    :param int concurrency: How many processes to use. The default (0)\n        autodetects your CPU count and uses that.\n    :param path exclude_list: Path to an exclusion list file, this file\n        contains a separate regex exclude on each newline.\n    :param path include_list: Path to an inclusion list file, this file\n         contains a separate regex on each newline.\n    :param boolean randomize: Randomize the test order after they are\n        partitioned into separate workers\n    \"\"\"\n\n    def __init__(\n        self,\n        test_ids,\n        cmd_template,\n        listopt,\n        idoption,\n        repository,\n        parallel=True,\n        listpath=None,\n        test_filters=None,\n        group_callback=None,\n        serial=False,\n        worker_path=None,\n        concurrency=0,\n        exclude_list=None,\n        exclude_regex=None,\n        include_list=None,\n        randomize=False,\n    ):\n        \"\"\"Create a TestProcessorFixture.\"\"\"\n\n        self.test_ids = test_ids\n        self.template = cmd_template\n        self.listopt = listopt\n        self.idoption = idoption\n        self.repository = repository\n        self.parallel = parallel\n        if serial:\n            self.parallel = False\n        self._listpath = listpath\n        self.test_filters = test_filters\n        self._group_callback = group_callback\n        self.worker_path = None\n        self.worker_path = worker_path\n        self.concurrency_value = concurrency\n        self.exclude_list = exclude_list\n        self.include_list = include_list\n        self.exclude_regex = exclude_regex\n        self.randomize = randomize\n\n    def setUp(self):\n        super().setUp()\n        variable_regex = r\"\\$(IDOPTION|IDFILE|IDLIST|LISTOPT)\"\n        variables = {}\n        list_variables = {\"LISTOPT\": self.listopt}\n        cmd = self.template\n        default_idstr = None\n\n        def list_subst(match):\n            return list_variables.get(match.groups(1)[0], \"\")\n\n        self.list_cmd = re.sub(variable_regex, list_subst, cmd)\n        nonparallel = not self.parallel\n        selection_logic = (\n            self.test_filters\n            or self.exclude_list\n            or self.include_list\n            or self.exclude_regex\n        )\n        if nonparallel:\n            self.concurrency = 1\n        else:\n            self.concurrency = None\n            if self.concurrency_value:\n                self.concurrency = int(self.concurrency_value)\n            if not self.concurrency:\n                self.concurrency = scheduler.local_concurrency()\n            if not self.concurrency:\n                self.concurrency = 1\n        if self.test_ids is None:\n            if self.concurrency == 1:\n                if default_idstr:\n                    self.test_ids = default_idstr.split()\n            if self.concurrency != 1 or selection_logic or self.worker_path:\n                # Have to be able to tell each worker what to run / filter\n                # tests.\n                self.test_ids = self.list_tests()\n        if self.test_ids is None:\n            # No test ids to supply to the program.\n            self.list_file_name = None\n            name = \"\"\n            idlist = \"\"\n        else:\n            self.test_ids = selection.construct_list(\n                self.test_ids,\n                exclude_list=self.exclude_list,\n                include_list=self.include_list,\n                regexes=self.test_filters,\n                exclude_regex=self.exclude_regex,\n            )\n            name = self.make_listfile()\n            variables[\"IDFILE\"] = name\n            idlist = \" \".join(self.test_ids)\n        variables[\"IDLIST\"] = idlist\n\n        def subst(match):\n            return variables.get(match.groups(1)[0], \"\")\n\n        if self.test_ids is None:\n            # No test ids, no id option.\n            idoption = \"\"\n        else:\n            idoption = re.sub(variable_regex, subst, self.idoption)\n            variables[\"IDOPTION\"] = idoption\n        self.cmd = re.sub(variable_regex, subst, cmd)\n\n    def make_listfile(self):\n        name = None\n        try:\n            if self._listpath:\n                name = self._listpath\n                stream = open(name, \"wb\")\n            else:\n                fd, name = tempfile.mkstemp()\n                stream = os.fdopen(fd, \"wb\")\n            with stream:\n                self.list_file_name = name\n                testlist.write_list(stream, self.test_ids)\n        except Exception:\n            if name:\n                os.unlink(name)\n            raise\n        self.addCleanup(os.unlink, name)\n        return name\n\n    def _clear_SIGPIPE(self):\n        \"\"\"Clear SIGPIPE : child processes expect the default handler.\"\"\"\n        signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n    def _start_process(self, cmd):\n        # NOTE(claudiub): Windows does not support passing in a preexec_fn\n        # argument.\n        preexec_fn = None if sys.platform == \"win32\" else self._clear_SIGPIPE\n        return subprocess.Popen(\n            cmd,\n            shell=True,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            preexec_fn=preexec_fn,\n        )\n\n    def list_tests(self):\n        \"\"\"List the tests returned by list_cmd.\n\n        :return: A list of test ids.\n        \"\"\"\n        run_proc = self._start_process(self.list_cmd)\n        out, err = run_proc.communicate()\n        if run_proc.returncode != 0:\n            sys.stdout.write(\n                \"\\n=========================\\n\"\n                \"Failures during discovery\"\n                \"\\n=========================\\n\"\n            )\n            new_out = io.BytesIO()\n            v2.ByteStreamToStreamResult(io.BytesIO(out), \"stdout\").run(\n                results.CatFiles(new_out)\n            )\n            out = new_out.getvalue()\n            if out:\n                sys.stdout.write(out.decode(\"utf8\"))\n            if err:\n                sys.stderr.write(err.decode(\"utf8\"))\n            sys.stdout.write(\n                \"\\n\" + \"=\" * 80 + \"\\n\"\n                \"The above traceback was encountered during \"\n                \"test discovery which imports all the found test\"\n                \" modules in the specified test_path.\\n\"\n            )\n            exit(100)\n        ids = testlist.parse_enumeration(out)\n        return ids\n\n    def run_tests(self):\n        \"\"\"Run the tests defined by the command\n\n        :return: A list of spawned processes.\n        \"\"\"\n        result = []\n        test_ids = self.test_ids\n        # Handle the single worker case (this is also run recursively per\n        # worker in the parallel case)\n        if self.concurrency == 1 and (test_ids is None or test_ids):\n            run_proc = self._start_process(self.cmd)\n            # Prevent processes stalling if they read from stdin; we could\n            # pass this through in future, but there is no point doing that\n            # until we have a working can-run-debugger-inline story.\n            run_proc.stdin.close()\n            return [run_proc]\n        # If there is a worker path, use that to get worker groups\n        elif self.worker_path:\n            test_id_groups = scheduler.generate_worker_partitions(\n                test_ids,\n                self.worker_path,\n                self.repository,\n                self._group_callback,\n                self.randomize,\n            )\n        # If we have multiple workers partition the tests and recursively\n        # create single worker TestProcessorFixtures for each worker\n        else:\n            test_id_groups = scheduler.partition_tests(\n                test_ids, self.concurrency, self.repository, self._group_callback\n            )\n        for test_ids in test_id_groups:\n            if not test_ids:\n                # No tests in this partition\n                continue\n            fixture = self.useFixture(\n                TestProcessorFixture(\n                    test_ids,\n                    self.template,\n                    self.listopt,\n                    self.idoption,\n                    self.repository,\n                    parallel=False,\n                )\n            )\n            result.extend(fixture.run_tests())\n        return result\n"
  },
  "GT_src_dict": {
    "stestr/test_processor.py": {
      "TestProcessorFixture.__init__": {
        "code": "    def __init__(self, test_ids, cmd_template, listopt, idoption, repository, parallel=True, listpath=None, test_filters=None, group_callback=None, serial=False, worker_path=None, concurrency=0, exclude_list=None, exclude_regex=None, include_list=None, randomize=False):\n        \"\"\"Initialize a TestProcessorFixture for managing the lifecycle of test execution.\n\nParameters:\n- test_ids: List of test identifiers. If None, tests will be discovered at runtime.\n- cmd_template: Command template for running tests, with placeholders for IDFILE concepts.\n- listopt: String for listing options that will be substituted into the command.\n- idoption: String for ID options to be filled in the command when test IDs are available.\n- repository: Reference to the repository used for querying test times.\n- parallel: Boolean indicating whether tests can run in parallel (default is True).\n- listpath: Optional path for the generated list file of test IDs; if None, a temporary path is created.\n- test_filters: List of regular expressions for filtering tests, applied via re.compile.\n- group_callback: Optional function to determine group identifiers for scheduling tests.\n- serial: If True, enforces serial test execution, overriding parallel behavior.\n- worker_path: Optional path for a worker grouping file used during the test run.\n- concurrency: Integer indicating how many processes to use; defaults to auto-detect CPU count.\n- exclude_list: Path to a file containing regex expressions for excluding specific tests.\n- exclude_regex: Regex for excluding tests, applied during filtering.\n- include_list: Path to a file with included tests, specified by regex.\n- randomize: Boolean for reordering the tests randomly after partitioning.\n\nThis initializer populates the instance variables necessary for constructing test execution commands with the provided configurations and sets up the groundwork for discovering and running tests based on the specified parameters.\"\"\"\n        'Create a TestProcessorFixture.'\n        self.test_ids = test_ids\n        self.template = cmd_template\n        self.listopt = listopt\n        self.idoption = idoption\n        self.repository = repository\n        self.parallel = parallel\n        if serial:\n            self.parallel = False\n        self._listpath = listpath\n        self.test_filters = test_filters\n        self._group_callback = group_callback\n        self.worker_path = None\n        self.worker_path = worker_path\n        self.concurrency_value = concurrency\n        self.exclude_list = exclude_list\n        self.include_list = include_list\n        self.exclude_regex = exclude_regex\n        self.randomize = randomize",
        "docstring": "Initialize a TestProcessorFixture for managing the lifecycle of test execution.\n\nParameters:\n- test_ids: List of test identifiers. If None, tests will be discovered at runtime.\n- cmd_template: Command template for running tests, with placeholders for IDFILE concepts.\n- listopt: String for listing options that will be substituted into the command.\n- idoption: String for ID options to be filled in the command when test IDs are available.\n- repository: Reference to the repository used for querying test times.\n- parallel: Boolean indicating whether tests can run in parallel (default is True).\n- listpath: Optional path for the generated list file of test IDs; if None, a temporary path is created.\n- test_filters: List of regular expressions for filtering tests, applied via re.compile.\n- group_callback: Optional function to determine group identifiers for scheduling tests.\n- serial: If True, enforces serial test execution, overriding parallel behavior.\n- worker_path: Optional path for a worker grouping file used during the test run.\n- concurrency: Integer indicating how many processes to use; defaults to auto-detect CPU count.\n- exclude_list: Path to a file containing regex expressions for excluding specific tests.\n- exclude_regex: Regex for excluding tests, applied during filtering.\n- include_list: Path to a file with included tests, specified by regex.\n- randomize: Boolean for reordering the tests randomly after partitioning.\n\nThis initializer populates the instance variables necessary for constructing test execution commands with the provided configurations and sets up the groundwork for discovering and running tests based on the specified parameters.",
        "signature": "def __init__(self, test_ids, cmd_template, listopt, idoption, repository, parallel=True, listpath=None, test_filters=None, group_callback=None, serial=False, worker_path=None, concurrency=0, exclude_list=None, exclude_regex=None, include_list=None, randomize=False):",
        "type": "Method",
        "class_signature": "class TestProcessorFixture(fixtures.Fixture):"
      },
      "TestProcessorFixture._start_process": {
        "code": "    def _start_process(self, cmd):\n        \"\"\"Start a subprocess to run the specified command.\n\nThis method launches a new process using the `subprocess.Popen` class, which allows for the execution of the command provided in the `cmd` parameter. It sets up pipes for standard input and output while managing the SIGPIPE signal behavior for non-Windows platforms.\n\nParameters:\n- cmd (str): The command string to execute in the new process.\n\nReturns:\n- subprocess.Popen: Returns a Popen object that represents the process being created. This object can be used to interact with the process, such as retrieving output or checking the exit status.\n\nNotes:\n- The method checks the operating system; if on Windows, it does not set a custom preexec function for handling the SIGPIPE signal due to incompatibility.\n- The `_clear_SIGPIPE` method is defined within the same class and is used to reset the signal handler for SIGPIPE, ensuring child processes receive the default behavior.\"\"\"\n        preexec_fn = None if sys.platform == 'win32' else self._clear_SIGPIPE\n        return subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, preexec_fn=preexec_fn)",
        "docstring": "Start a subprocess to run the specified command.\n\nThis method launches a new process using the `subprocess.Popen` class, which allows for the execution of the command provided in the `cmd` parameter. It sets up pipes for standard input and output while managing the SIGPIPE signal behavior for non-Windows platforms.\n\nParameters:\n- cmd (str): The command string to execute in the new process.\n\nReturns:\n- subprocess.Popen: Returns a Popen object that represents the process being created. This object can be used to interact with the process, such as retrieving output or checking the exit status.\n\nNotes:\n- The method checks the operating system; if on Windows, it does not set a custom preexec function for handling the SIGPIPE signal due to incompatibility.\n- The `_clear_SIGPIPE` method is defined within the same class and is used to reset the signal handler for SIGPIPE, ensuring child processes receive the default behavior.",
        "signature": "def _start_process(self, cmd):",
        "type": "Method",
        "class_signature": "class TestProcessorFixture(fixtures.Fixture):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: stestr-test_test_processor\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 stestr/\n    \u2514\u2500\u2500 test_processor.py\n        \u251c\u2500\u2500 TestProcessorFixture.__init__\n        \u2514\u2500\u2500 TestProcessorFixture._start_process\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the execution and management of test processes within a larger testing framework by coordinating the interaction between test definitions, execution commands, and system-level process handling. It provides capabilities for initializing and configuring test execution parameters, managing platform-specific process handling, and ensuring compatibility across diverse operating systems such as Windows and Linux. This enables developers to execute and parallelize test cases efficiently while ensuring seamless interaction with system resources, addressing the challenges of cross-platform test process management and streamlining the integration of complex test workflows.\n\n## FILE 1: stestr/test_processor.py\n\n- CLASS METHOD: TestProcessorFixture.__init__\n  - CLASS SIGNATURE: class TestProcessorFixture(fixtures.Fixture):\n  - SIGNATURE: def __init__(self, test_ids, cmd_template, listopt, idoption, repository, parallel=True, listpath=None, test_filters=None, group_callback=None, serial=False, worker_path=None, concurrency=0, exclude_list=None, exclude_regex=None, include_list=None, randomize=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TestProcessorFixture for managing the lifecycle of test execution.\n\nParameters:\n- test_ids: List of test identifiers. If None, tests will be discovered at runtime.\n- cmd_template: Command template for running tests, with placeholders for IDFILE concepts.\n- listopt: String for listing options that will be substituted into the command.\n- idoption: String for ID options to be filled in the command when test IDs are available.\n- repository: Reference to the repository used for querying test times.\n- parallel: Boolean indicating whether tests can run in parallel (default is True).\n- listpath: Optional path for the generated list file of test IDs; if None, a temporary path is created.\n- test_filters: List of regular expressions for filtering tests, applied via re.compile.\n- group_callback: Optional function to determine group identifiers for scheduling tests.\n- serial: If True, enforces serial test execution, overriding parallel behavior.\n- worker_path: Optional path for a worker grouping file used during the test run.\n- concurrency: Integer indicating how many processes to use; defaults to auto-detect CPU count.\n- exclude_list: Path to a file containing regex expressions for excluding specific tests.\n- exclude_regex: Regex for excluding tests, applied during filtering.\n- include_list: Path to a file with included tests, specified by regex.\n- randomize: Boolean for reordering the tests randomly after partitioning.\n\nThis initializer populates the instance variables necessary for constructing test execution commands with the provided configurations and sets up the groundwork for discovering and running tests based on the specified parameters.\n\"\"\"\n```\n\n- CLASS METHOD: TestProcessorFixture._start_process\n  - CLASS SIGNATURE: class TestProcessorFixture(fixtures.Fixture):\n  - SIGNATURE: def _start_process(self, cmd):\n  - DOCSTRING: \n```python\n\"\"\"\nStart a subprocess to run the specified command.\n\nThis method launches a new process using the `subprocess.Popen` class, which allows for the execution of the command provided in the `cmd` parameter. It sets up pipes for standard input and output while managing the SIGPIPE signal behavior for non-Windows platforms.\n\nParameters:\n- cmd (str): The command string to execute in the new process.\n\nReturns:\n- subprocess.Popen: Returns a Popen object that represents the process being created. This object can be used to interact with the process, such as retrieving output or checking the exit status.\n\nNotes:\n- The method checks the operating system; if on Windows, it does not set a custom preexec function for handling the SIGPIPE signal due to incompatibility.\n- The `_clear_SIGPIPE` method is defined within the same class and is used to reset the signal handler for SIGPIPE, ensuring child processes receive the default behavior.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "stestr/test_processor.py": "import io\nimport os\nimport re\nimport signal\nimport subprocess\nimport sys\nimport tempfile\nimport fixtures\nfrom subunit import v2\nfrom stestr import results\nfrom stestr import scheduler\nfrom stestr import selection\nfrom stestr import testlist\n\nclass TestProcessorFixture(fixtures.Fixture):\n    \"\"\"Write a temporary file to disk with test ids in it.\n\n    The TestProcessorFixture is used to handle the lifecycle of running\n    the subunit.run commands. A fixture is used for this class to handle\n    the temporary list files creation.\n\n    :param test_ids: The test_ids to use. May be None indicating that\n        no ids are known and they should be discovered by listing or\n        configuration if they must be known to run tests. Test ids are\n        needed to run tests when filtering or partitioning is needed: if\n        the run concurrency is > 1 partitioning is needed, and filtering is\n        needed if the user has passed in filters.\n    :param cmd_template: string to be used for the command that will be\n        filled out with the IDFILE when it is created.\n    :param listopt: Option to substitute into LISTOPT to cause test listing\n                    to take place.\n    :param idoption: Option to substitute into cmd when supplying any test ids.\n    :param repository: The repository to query for test times, if needed.\n    :param parallel: If not True, prohibit parallel use : used to implement\n                     --parallel run recursively.\n    :param listpath: The file listing path to use. If None, a unique path\n                     is created.\n    :param test_filters: An optional list of test filters to apply. Each\n        filter should be a string suitable for passing to re.compile.\n        Filters are applied using search() rather than match(), so if\n        anchoring is needed it should be included in the regex.\n        The test ids used for executing are the union of all the\n        individual filters: to take the intersection instead, craft a\n        single regex that matches all your criteria. Filters are\n        automatically applied by run_tests(), or can be applied by calling\n        filter_tests(test_ids).\n    :param group_callback: If supplied, should be a function that accepts a\n        test id and returns a group id. A group id is an arbitrary value\n        used as a dictionary key in the scheduler. All test ids with the\n        same group id are scheduled onto the same backend test process.\n    :param bool serial: Run tests serially\n    :param path worker_path: Optional path of a manual worker grouping file\n        to use for the run\n    :param int concurrency: How many processes to use. The default (0)\n        autodetects your CPU count and uses that.\n    :param path exclude_list: Path to an exclusion list file, this file\n        contains a separate regex exclude on each newline.\n    :param path include_list: Path to an inclusion list file, this file\n         contains a separate regex on each newline.\n    :param boolean randomize: Randomize the test order after they are\n        partitioned into separate workers\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        variable_regex = '\\\\$(IDOPTION|IDFILE|IDLIST|LISTOPT)'\n        variables = {}\n        list_variables = {'LISTOPT': self.listopt}\n        cmd = self.template\n        default_idstr = None\n\n        def list_subst(match):\n            return list_variables.get(match.groups(1)[0], '')\n        self.list_cmd = re.sub(variable_regex, list_subst, cmd)\n        nonparallel = not self.parallel\n        selection_logic = self.test_filters or self.exclude_list or self.include_list or self.exclude_regex\n        if nonparallel:\n            self.concurrency = 1\n        else:\n            self.concurrency = None\n            if self.concurrency_value:\n                self.concurrency = int(self.concurrency_value)\n            if not self.concurrency:\n                self.concurrency = scheduler.local_concurrency()\n            if not self.concurrency:\n                self.concurrency = 1\n        if self.test_ids is None:\n            if self.concurrency == 1:\n                if default_idstr:\n                    self.test_ids = default_idstr.split()\n            if self.concurrency != 1 or selection_logic or self.worker_path:\n                self.test_ids = self.list_tests()\n        if self.test_ids is None:\n            self.list_file_name = None\n            name = ''\n            idlist = ''\n        else:\n            self.test_ids = selection.construct_list(self.test_ids, exclude_list=self.exclude_list, include_list=self.include_list, regexes=self.test_filters, exclude_regex=self.exclude_regex)\n            name = self.make_listfile()\n            variables['IDFILE'] = name\n            idlist = ' '.join(self.test_ids)\n        variables['IDLIST'] = idlist\n\n        def subst(match):\n            return variables.get(match.groups(1)[0], '')\n        if self.test_ids is None:\n            idoption = ''\n        else:\n            idoption = re.sub(variable_regex, subst, self.idoption)\n            variables['IDOPTION'] = idoption\n        self.cmd = re.sub(variable_regex, subst, cmd)\n\n    def make_listfile(self):\n        name = None\n        try:\n            if self._listpath:\n                name = self._listpath\n                stream = open(name, 'wb')\n            else:\n                fd, name = tempfile.mkstemp()\n                stream = os.fdopen(fd, 'wb')\n            with stream:\n                self.list_file_name = name\n                testlist.write_list(stream, self.test_ids)\n        except Exception:\n            if name:\n                os.unlink(name)\n            raise\n        self.addCleanup(os.unlink, name)\n        return name\n\n    def _clear_SIGPIPE(self):\n        \"\"\"Clear SIGPIPE : child processes expect the default handler.\"\"\"\n        signal.signal(signal.SIGPIPE, signal.SIG_DFL)\n\n    def list_tests(self):\n        \"\"\"List the tests returned by list_cmd.\n\n        :return: A list of test ids.\n        \"\"\"\n        run_proc = self._start_process(self.list_cmd)\n        out, err = run_proc.communicate()\n        if run_proc.returncode != 0:\n            sys.stdout.write('\\n=========================\\nFailures during discovery\\n=========================\\n')\n            new_out = io.BytesIO()\n            v2.ByteStreamToStreamResult(io.BytesIO(out), 'stdout').run(results.CatFiles(new_out))\n            out = new_out.getvalue()\n            if out:\n                sys.stdout.write(out.decode('utf8'))\n            if err:\n                sys.stderr.write(err.decode('utf8'))\n            sys.stdout.write('\\n' + '=' * 80 + '\\nThe above traceback was encountered during test discovery which imports all the found test modules in the specified test_path.\\n')\n            exit(100)\n        ids = testlist.parse_enumeration(out)\n        return ids\n\n    def run_tests(self):\n        \"\"\"Run the tests defined by the command\n\n        :return: A list of spawned processes.\n        \"\"\"\n        result = []\n        test_ids = self.test_ids\n        if self.concurrency == 1 and (test_ids is None or test_ids):\n            run_proc = self._start_process(self.cmd)\n            run_proc.stdin.close()\n            return [run_proc]\n        elif self.worker_path:\n            test_id_groups = scheduler.generate_worker_partitions(test_ids, self.worker_path, self.repository, self._group_callback, self.randomize)\n        else:\n            test_id_groups = scheduler.partition_tests(test_ids, self.concurrency, self.repository, self._group_callback)\n        for test_ids in test_id_groups:\n            if not test_ids:\n                continue\n            fixture = self.useFixture(TestProcessorFixture(test_ids, self.template, self.listopt, self.idoption, self.repository, parallel=False))\n            result.extend(fixture.run_tests())\n        return result"
  },
  "call_tree": {
    "modified_testcases/test_test_processor.py:TestTestProcessorFixture:setUp": {
      "stestr/tests/base.py:TestCase:setUp": {},
      "stestr/test_processor.py:TestProcessorFixture:__init__": {}
    },
    "modified_testcases/test_test_processor.py:TestTestProcessorFixture:test_start_process_linux": {
      "modified_testcases/test_test_processor.py:TestTestProcessorFixture:_check_start_process": {
        "stestr/test_processor.py:TestProcessorFixture:_start_process": {}
      }
    },
    "modified_testcases/test_test_processor.py:TestTestProcessorFixture:test_start_process_win32": {
      "modified_testcases/test_test_processor.py:TestTestProcessorFixture:_check_start_process": {
        "stestr/test_processor.py:TestProcessorFixture:_start_process": {}
      }
    }
  }
}