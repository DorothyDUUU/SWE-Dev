{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_distributed_api",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/test_distributed_api.py",
  "test_code": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport casbin\nfrom tests.test_enforcer import get_examples, TestCaseBase\n\n\nclass TestDistributedApi(TestCaseBase):\n    def get_enforcer(self, model=None, adapter=None):\n        return casbin.DistributedEnforcer(\n            model,\n            adapter,\n        )\n\n    def test(self):\n        e = self.get_enforcer(get_examples(\"rbac_model.conf\"), get_examples(\"rbac_policy.csv\"))\n\n        e.add_policy_self(\n            False,\n            \"p\",\n            \"p\",\n            [\n                [\"alice\", \"data1\", \"read\"],\n                [\"bob\", \"data2\", \"write\"],\n                [\"data2_admin\", \"data2\", \"read\"],\n                [\"data2_admin\", \"data2\", \"write\"],\n            ],\n        )\n        e.add_policy_self(False, \"g\", \"g\", [[\"alice\", \"data2_admin\"]])\n\n        self.assertTrue(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"write\"))\n        self.assertTrue(e.enforce(\"bob\", \"data2\", \"write\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"write\"))\n        self.assertTrue(e.enforce(\"alice\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"alice\", \"data2\", \"write\"))\n\n        e.update_policy_self(False, \"p\", \"p\", [\"alice\", \"data1\", \"read\"], [\"alice\", \"data1\", \"write\"])\n        e.update_policy_self(False, \"g\", \"g\", [\"alice\", \"data2_admin\"], [\"tom\", \"alice\"])\n\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertTrue(e.enforce(\"alice\", \"data1\", \"write\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"bob\", \"data2\", \"write\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"write\"))\n        self.assertFalse(e.enforce(\"tom\", \"data1\", \"read\"))\n        self.assertTrue(e.enforce(\"tom\", \"data1\", \"write\"))\n\n        e.remove_policy_self(False, \"p\", \"p\", [[\"alice\", \"data1\", \"write\"]])\n\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"write\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"bob\", \"data2\", \"write\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"write\"))\n        self.assertFalse(e.enforce(\"alice\", \"data2\", \"read\"))\n        self.assertFalse(e.enforce(\"alice\", \"data2\", \"write\"))\n\n        e.remove_filtered_policy_self(False, \"p\", \"p\", 0, \"bob\", \"data2\", \"write\")\n        e.remove_filtered_policy_self(False, \"g\", \"g\", 0, \"tom\", \"data2_admin\")\n\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"write\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"read\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"write\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"read\"))\n        self.assertTrue(e.enforce(\"data2_admin\", \"data2\", \"write\"))\n        self.assertFalse(e.enforce(\"tom\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"tom\", \"data1\", \"write\"))\n\n        e.clear_policy_self(False)\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"alice\", \"data1\", \"write\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"read\"))\n        self.assertFalse(e.enforce(\"bob\", \"data2\", \"write\"))\n        self.assertFalse(e.enforce(\"data2_admin\", \"data2\", \"read\"))\n        self.assertFalse(e.enforce(\"data2_admin\", \"data2\", \"write\"))\n",
  "GT_file_code": {
    "casbin/distributed_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom casbin.model.policy_op import PolicyOp\nfrom casbin.persist import batch_adapter, update_adapter\nfrom casbin.synced_enforcer import SyncedEnforcer\n\n\nclass DistributedEnforcer(SyncedEnforcer):\n    \"\"\"DistributedEnforcer wraps SyncedEnforcer for dispatcher.\"\"\"\n\n    def __init__(self, model=None, adapter=None):\n        SyncedEnforcer.__init__(self, model, adapter)\n\n    def add_policy_self(self, should_persist, sec, ptype, rules):\n        \"\"\"\n        AddPolicySelf provides a method for dispatcher to add authorization rules to the current policy.\n        The function returns the rules affected and error.\n        \"\"\"\n\n        no_exists_policy = []\n        for rule in rules:\n            if not self.get_model().has_policy(sec, ptype, rule):\n                no_exists_policy.append(rule)\n\n        if should_persist:\n            try:\n                if isinstance(self.adapter, batch_adapter):\n                    self.adapter.add_policies(sec, ptype, rules)\n            except Exception as e:\n                self._e.logger.error(\"An error occurred: \" + e)\n\n        self.get_model().add_policies(sec, ptype, no_exists_policy)\n\n        if sec == \"g\":\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_add, ptype, no_exists_policy)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n                return no_exists_policy\n\n        return no_exists_policy\n\n    def remove_policy_self(self, should_persist, sec, ptype, rules):\n        \"\"\"\n        remove_policy_self provides a method for dispatcher to remove policies from current policy.\n        The function returns the rules affected and error.\n        \"\"\"\n        if should_persist:\n            try:\n                if isinstance(self.adapter, batch_adapter):\n                    self.adapter.remove_policy(sec, ptype, rules)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n\n        effected = self.get_model().remove_policies_with_effected(sec, ptype, rules)\n\n        if sec == \"g\":\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, rules)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n                return effected\n\n        return effected\n\n    def remove_filtered_policy_self(self, should_persist, sec, ptype, field_index, *field_values):\n        \"\"\"\n        remove_filtered_policy_self provides a method for dispatcher to remove an authorization\n        rule from the current policy,field filters can be specified.\n        The function returns the rules affected and error.\n        \"\"\"\n        if should_persist:\n            try:\n                self.adapter.remove_filtered_policy(sec, ptype, field_index, field_values)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n\n        effects = self.get_model().remove_filtered_policy_returns_effects(sec, ptype, field_index, *field_values)\n\n        if sec == \"g\":\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, effects)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n                return effects\n\n        return effects\n\n    def clear_policy_self(self, should_persist):\n        \"\"\"\n        clear_policy_self provides a method for dispatcher to clear all rules from the current policy.\n        \"\"\"\n        if should_persist:\n            try:\n                self.adapter.save_policy(None)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n\n        self.get_model().clear_policy()\n\n    def update_policy_self(self, should_persist, sec, ptype, old_rule, new_rule):\n        \"\"\"\n        update_policy_self provides a method for dispatcher to update an authorization rule from the current policy.\n        \"\"\"\n        if should_persist:\n            try:\n                if isinstance(self.adapter, update_adapter):\n                    self.adapter.update_policy(sec, ptype, old_rule, new_rule)\n            except Exception as e:\n                self._e.logger.error(\"An exception occurred: \" + e)\n                return False\n\n        rule_updated = self.get_model().update_policy(sec, ptype, old_rule, new_rule)\n\n        if not rule_updated:\n            return False\n\n        if sec == \"g\":\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, [old_rule])\n            except Exception as e:\n                return False\n\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_add, ptype, [new_rule])\n            except Exception as e:\n                return False\n\n        return True\n",
    "casbin/synced_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport threading\nimport time\n\nfrom casbin.enforcer import Enforcer\nfrom casbin.util.rwlock import RWLockWrite\n\n\nclass AtomicBool:\n    def __init__(self, value):\n        self._lock = threading.Lock()\n        self._value = value\n\n    @property\n    def value(self):\n        with self._lock:\n            return self._value\n\n    @value.setter\n    def value(self, value):\n        with self._lock:\n            self._value = value\n\n\nclass SyncedEnforcer:\n\n    \"\"\"SyncedEnforcer wraps Enforcer and provides synchronized access.\n    It's also a drop-in replacement for Enforcer\"\"\"\n\n    def __init__(self, model=None, adapter=None):\n        self._e = Enforcer(model, adapter)\n        self._rwlock = RWLockWrite()\n        self._rl = self._rwlock.gen_rlock()\n        self._wl = self._rwlock.gen_wlock()\n        self._auto_loading = AtomicBool(False)\n        self._auto_loading_thread = None\n\n    def is_auto_loading_running(self):\n        \"\"\"check if SyncedEnforcer is auto loading policies\"\"\"\n        return self._auto_loading.value\n\n    def _auto_load_policy(self, interval):\n        while self.is_auto_loading_running():\n            time.sleep(interval)\n            try:\n                self.load_policy()\n            except Exception as e:\n                self._e.logger.error(repr(e))\n\n    def start_auto_load_policy(self, interval):\n        \"\"\"starts a thread that will call load_policy every interval seconds\"\"\"\n        if self.is_auto_loading_running():\n            return\n        self._auto_loading.value = True\n        self._auto_loading_thread = threading.Thread(target=self._auto_load_policy, args=[interval], daemon=True)\n        self._auto_loading_thread.start()\n\n    def stop_auto_load_policy(self):\n        \"\"\"stops the thread started by start_auto_load_policy\"\"\"\n        if self.is_auto_loading_running():\n            self._auto_loading.value = False\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n        with self._wl:\n            return self._e.set_model(m)\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n        with self._wl:\n            return self._e.load_model()\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        with self._rl:\n            return self._e.get_role_manager()\n\n    def set_role_manager(self, rm):\n        with self._wl:\n            self._e.set_role_manager(rm)\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n        with self._rl:\n            self._e.get_adapter()\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n        with self._wl:\n            self._e.set_adapter(adapter)\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n        with self._wl:\n            self._e.set_watcher(watcher)\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        with self._wl:\n            self._e.set_effector(eft)\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n        with self._wl:\n            return self._e.clear_policy()\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        with self._wl:\n            return self._e.load_policy()\n\n    def load_filtered_policy(self, filter):\n        \"\"\" \"reloads a filtered policy from file/database.\"\"\"\n        with self._wl:\n            return self._e.load_filtered_policy(filter)\n\n    def save_policy(self):\n        with self._rl:\n            return self._e.save_policy()\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        with self._rl:\n            return self._e.build_role_links()\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        with self._rl:\n            return self._e.enforce(*rvals)\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        with self._rl:\n            return self._e.enforce_ex(*rvals)\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches,\n        input parameters are usually: [(sub, obj, act), (sub, obj, act), ...].\n        \"\"\"\n        with self._rl:\n            return self._e.batch_enforce(rvals)\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_subjects()\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_subjects(ptype)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_objects()\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_objects(ptype)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_actions()\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_actions(ptype)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_roles()\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_roles(ptype)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_policy()\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_policy(field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        with self._rl:\n            return self._e.get_named_policy(ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_named_policy(ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_grouping_policy()\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_grouping_policy(field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_named_grouping_policy(ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_named_grouping_policy(ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_policy(*params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_named_policy(ptype, *params)\n\n    def add_policy(self, *params):\n        \"\"\"adds an authorization rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_policy(*params)\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_named_policy(ptype, *params)\n\n    def remove_policy(self, *params):\n        \"\"\"removes an authorization rule from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_policy(*params)\n\n    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_policy(field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_policy(ptype, *params)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_named_policy(ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_grouping_policy(*params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_named_grouping_policy(ptype, *params)\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_grouping_policy(*params)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_named_grouping_policy(ptype, *params)\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_grouping_policy(*params)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_grouping_policy(field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_grouping_policy(ptype, *params)\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_named_grouping_policy(ptype, field_index, *field_values)\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        with self._wl:\n            return self._e.add_function(name, func)\n\n    # enforcer.py\n\n    def get_roles_for_user(self, name):\n        \"\"\"gets the roles that a user has.\"\"\"\n        with self._rl:\n            return self._e.get_roles_for_user(name)\n\n    def get_users_for_role(self, name):\n        \"\"\"gets the users that has a role.\"\"\"\n        with self._rl:\n            return self._e.get_users_for_role(name)\n\n    def has_role_for_user(self, name, role):\n        \"\"\"determines whether a user has a role.\"\"\"\n        with self._rl:\n            return self._e.has_role_for_user(name, role)\n\n    def add_role_for_user(self, user, role):\n        \"\"\"\n        adds a role for a user.\n        Returns false if the user already has the role (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.add_role_for_user(user, role)\n\n    def delete_role_for_user(self, user, role):\n        \"\"\"\n        deletes a role for a user.\n        Returns false if the user does not have the role (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_role_for_user(user, role)\n\n    def delete_roles_for_user(self, user):\n        \"\"\"\n        deletes all roles for a user.\n        Returns false if the user does not have any roles (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_roles_for_user(user)\n\n    def delete_user(self, user):\n        \"\"\"\n        deletes a user.\n        Returns false if the user does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_user(user)\n\n    def delete_role(self, role):\n        \"\"\"\n        deletes a role.\n        Returns false if the role does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_role(role)\n\n    def delete_permission(self, *permission):\n        \"\"\"\n        deletes a permission.\n        Returns false if the permission does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permission(*permission)\n\n    def add_permission_for_user(self, user, *permission):\n        \"\"\"\n        adds a permission for a user or role.\n        Returns false if the user or role already has the permission (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.add_permission_for_user(user, *permission)\n\n    def delete_permission_for_user(self, user, *permission):\n        \"\"\"\n        deletes a permission for a user or role.\n        Returns false if the user or role does not have the permission (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permission_for_user(user, *permission)\n\n    def delete_permissions_for_user(self, user):\n        \"\"\"\n        deletes permissions for a user or role.\n        Returns false if the user or role does not have any permissions (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permissions_for_user(user)\n\n    def get_permissions_for_user(self, user):\n        \"\"\"\n        gets permissions for a user or role.\n        \"\"\"\n        with self._rl:\n            return self._e.get_permissions_for_user(user)\n\n    def has_permission_for_user(self, user, *permission):\n        \"\"\"\n        determines whether a user has a permission.\n        \"\"\"\n        with self._rl:\n            return self._e.has_permission_for_user(user, *permission)\n\n    def get_implicit_roles_for_user(self, name, *domain):\n        \"\"\"\n        gets implicit roles that a user has.\n        Compared to get_roles_for_user(), this function retrieves indirect roles besides direct roles.\n        For example:\n        g, alice, role:admin\n        g, role:admin, role:user\n\n        get_roles_for_user(\"alice\") can only get: [\"role:admin\"].\n        But get_implicit_roles_for_user(\"alice\") will get: [\"role:admin\", \"role:user\"].\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_roles_for_user(name, *domain)\n\n    def get_implicit_permissions_for_user(self, user, *domain, filter_policy_dom=True):\n        \"\"\"\n        gets implicit permissions for a user or role.\n        Compared to get_permissions_for_user(), this function retrieves permissions for inherited roles.\n        For example:\n        p, admin, data1, read\n        p, alice, data2, read\n        g, alice, admin\n\n        get_permissions_for_user(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n        But get_implicit_permissions_for_user(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_permissions_for_user(user, *domain, filter_policy_dom=filter_policy_dom)\n\n    def get_named_implicit_permissions_for_user(self, ptype, user, *domain, filter_policy_dom=True):\n        \"\"\"\n        gets implicit permissions for a user or role by named policy.\n        Compared to get_permissions_for_user(), this function retrieves permissions for inherited roles.\n        For example:\n        p, admin, data1, read\n        p, alice, data2, read\n        g, alice, admin\n\n        get_permissions_for_user(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n        But get_implicit_permissions_for_user(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\n        \"\"\"\n        with self._rl:\n            return self._e.get_named_implicit_permissions_for_user(\n                ptype, user, *domain, filter_policy_dom=filter_policy_dom\n            )\n\n    def get_implicit_users_for_permission(self, *permission):\n        \"\"\"\n        gets implicit users for a permission.\n        For example:\n        p, admin, data1, read\n        p, bob, data1, read\n        g, alice, admin\n\n        get_implicit_users_for_permission(\"data1\", \"read\") will get: [\"alice\", \"bob\"].\n        Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_permission(*permission)\n\n    def get_roles_for_user_in_domain(self, name, domain):\n        \"\"\"gets the roles that a user has inside a domain.\"\"\"\n        with self._rl:\n            return self._e.get_roles_for_user_in_domain(name, domain)\n\n    def get_users_for_role_in_domain(self, name, domain):\n        \"\"\"gets the users that has a role inside a domain.\"\"\"\n        with self._rl:\n            return self._e.get_users_for_role_in_domain(name, domain)\n\n    def add_role_for_user_in_domain(self, user, role, domain):\n        \"\"\"adds a role for a user inside a domain.\"\"\"\n        \"\"\"Returns false if the user already has the role (aka not affected).\"\"\"\n        with self._wl:\n            return self._e.add_role_for_user_in_domain(user, role, domain)\n\n    def delete_roles_for_user_in_domain(self, user, role, domain):\n        \"\"\"deletes a role for a user inside a domain.\"\"\"\n        \"\"\"Returns false if the user does not have any roles (aka not affected).\"\"\"\n        with self._wl:\n            return self._e.delete_roles_for_user_in_domain(user, role, domain)\n\n    def get_permissions_for_user_in_domain(self, user, domain):\n        \"\"\"gets permissions for a user or role inside domain.\"\"\"\n        with self._rl:\n            return self._e.get_permissions_for_user_in_domain(user, domain)\n\n    def get_named_permissions_for_user_in_domain(self, ptype, user, domain):\n        \"\"\"gets permissions for a user or role by named policy inside domain.\"\"\"\n        with self._rl:\n            return self._e.get_named_permissions_for_user_in_domain(ptype, user, domain)\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        with self._wl:\n            return self._e.enable_auto_build_role_links(auto_build_role_links)\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        with self._wl:\n            return self._e.enable_auto_save(auto_save)\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n        with self._wl:\n            return self._e.enable_enforce(enabled)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        with self._wl:\n            self._e.add_named_matching_func(ptype, fn)\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        with self._wl:\n            self._e.add_named_link_condition_func(ptype, user, role, fn)\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        with self._wl:\n            self._e.add_named_domain_matching_func(ptype, fn)\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        with self._wl:\n            self._e.add_named_domain_link_condition_func(ptype, user, role, domain, fn)\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        with self._wl:\n            self._e.set_named_domain_link_condition_func_params(ptype, user, role, domain, *params)\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        with self._wl:\n            self._e.set_named_link_condition_func_params(ptype, user, role, *params)\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        with self._rl:\n            self._e.is_filtered()\n\n    def add_policies(self, rules):\n        \"\"\"adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_policies(rules)\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        with self._wl:\n            return self._e.add_named_policies(ptype, rules)\n\n    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_policies(rules)\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_policies(ptype, rules)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_grouping_policies(rules)\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\" \"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        with self._wl:\n            return self._e.add_named_grouping_policies(ptype, rules)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_grouping_policies(rules)\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_grouping_policies(ptype, rules)\n\n    def build_incremental_role_links(self, op, ptype, rules):\n        self.get_model().build_incremental_role_links(self.get_role_manager(), op, \"g\", ptype, rules)\n\n    def new_enforce_context(self, suffix: str) -> \"EnforceContext\":\n        return self._e.new_enforce_context(suffix)\n\n    def get_field_index(self, ptype, field):\n        \"\"\"gets the index of the field name.\"\"\"\n        return self._e.model.get_field_index(ptype, field)\n\n    def set_field_index(self, ptype, field, index):\n        \"\"\"sets the index of the field name.\"\"\"\n        assertion = self._e.model[\"p\"][ptype]\n        assertion.field_index_map[field] = index\n\n    def get_all_roles_by_domain(self, domain):\n        \"\"\"gets all roles associated with the domain.\n        note: Not applicable to Domains with inheritance relationship  (implicit roles)\"\"\"\n        with self._rl:\n            return self._e.get_all_roles_by_domain(domain)\n\n    def get_implicit_users_for_resource(self, resource):\n        \"\"\"gets implicit user based on resource.\n        for example:\n            p, alice, data1, read\n            p, bob, data2, write\n            p, data2_admin, data2, read\n            p, data2_admin, data2, write\n            g, alice, data2_admin\n        get_implicit_users_for_resource(\"data2\") will return [[bob data2 write] [alice data2 read] [alice data2 write]]\n        get_implicit_users_for_resource(\"data1\") will return [[alice data1 read]]\n        Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_resource(resource)\n\n    def get_implicit_users_for_resource_by_domain(self, resource, domain):\n        \"\"\"get implicit user based on resource and domain.\n        Compared to GetImplicitUsersForResource, domain is supported\"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_resource_by_domain(resource, domain)\n"
  },
  "GT_src_dict": {
    "casbin/distributed_enforcer.py": {
      "DistributedEnforcer.__init__": {
        "code": "    def __init__(self, model=None, adapter=None):\n        \"\"\"Initializes a DistributedEnforcer instance, which is a wrapper around the SyncedEnforcer for handling dispatcher functionalities. \n\nParameters:\n- model (optional): An optional model specification used for the enforcer, inherited from the SyncedEnforcer.\n- adapter (optional): An optional adapter that provides persistence functionality for storing policies, also inherited from the SyncedEnforcer.\n\nThe method initializes the DistributedEnforcer by calling the __init__ method of the SyncedEnforcer, allowing it to leverage the existing functionality defined therein. No return value is produced.\"\"\"\n        SyncedEnforcer.__init__(self, model, adapter)",
        "docstring": "Initializes a DistributedEnforcer instance, which is a wrapper around the SyncedEnforcer for handling dispatcher functionalities. \n\nParameters:\n- model (optional): An optional model specification used for the enforcer, inherited from the SyncedEnforcer.\n- adapter (optional): An optional adapter that provides persistence functionality for storing policies, also inherited from the SyncedEnforcer.\n\nThe method initializes the DistributedEnforcer by calling the __init__ method of the SyncedEnforcer, allowing it to leverage the existing functionality defined therein. No return value is produced.",
        "signature": "def __init__(self, model=None, adapter=None):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      },
      "DistributedEnforcer.add_policy_self": {
        "code": "    def add_policy_self(self, should_persist, sec, ptype, rules):\n        \"\"\"Adds authorization rules to the current policy within the DistributedEnforcer, which extends the SyncedEnforcer. The method checks for existing policies to avoid duplicates and optionally persists the new policies using the adapter. \n\nParameters:\n- should_persist (bool): Indicates whether the changes should be saved to the adapter.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for role mappings).\n- ptype (str): The policy type for the rules being added.\n- rules (list): A list of rules to be added to the specified section and policy type.\n\nReturns:\n- list: The rules that were successfully added, excluding any that were duplicates.\n\nSide Effects:\n- If should_persist is True, the new policies may be saved to the data store via the defined adapter.\n- In the case of section \"g\", the method updates incremental role links, making use of the PolicyOp.Policy_add constant to indicate the operation type. \n- Errors during the policy addition or updating role links are logged.\n\nDependencies:\n- Requires the `batch_adapter` class, which handles batch operations for policy manipulation.\n- Uses `PolicyOp` from the `casbin.model.policy_op` module to track policy operations.\n- Interacts with the underlying model through methods like `has_policy`, `add_policies`, `build_incremental_role_links`, and an internal logging mechanism.\"\"\"\n        '\\n        AddPolicySelf provides a method for dispatcher to add authorization rules to the current policy.\\n        The function returns the rules affected and error.\\n        '\n        no_exists_policy = []\n        for rule in rules:\n            if not self.get_model().has_policy(sec, ptype, rule):\n                no_exists_policy.append(rule)\n        if should_persist:\n            try:\n                if isinstance(self.adapter, batch_adapter):\n                    self.adapter.add_policies(sec, ptype, rules)\n            except Exception as e:\n                self._e.logger.error('An error occurred: ' + e)\n        self.get_model().add_policies(sec, ptype, no_exists_policy)\n        if sec == 'g':\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_add, ptype, no_exists_policy)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n                return no_exists_policy\n        return no_exists_policy",
        "docstring": "Adds authorization rules to the current policy within the DistributedEnforcer, which extends the SyncedEnforcer. The method checks for existing policies to avoid duplicates and optionally persists the new policies using the adapter. \n\nParameters:\n- should_persist (bool): Indicates whether the changes should be saved to the adapter.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for role mappings).\n- ptype (str): The policy type for the rules being added.\n- rules (list): A list of rules to be added to the specified section and policy type.\n\nReturns:\n- list: The rules that were successfully added, excluding any that were duplicates.\n\nSide Effects:\n- If should_persist is True, the new policies may be saved to the data store via the defined adapter.\n- In the case of section \"g\", the method updates incremental role links, making use of the PolicyOp.Policy_add constant to indicate the operation type. \n- Errors during the policy addition or updating role links are logged.\n\nDependencies:\n- Requires the `batch_adapter` class, which handles batch operations for policy manipulation.\n- Uses `PolicyOp` from the `casbin.model.policy_op` module to track policy operations.\n- Interacts with the underlying model through methods like `has_policy`, `add_policies`, `build_incremental_role_links`, and an internal logging mechanism.",
        "signature": "def add_policy_self(self, should_persist, sec, ptype, rules):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      },
      "DistributedEnforcer.remove_policy_self": {
        "code": "    def remove_policy_self(self, should_persist, sec, ptype, rules):\n        \"\"\"Removes specified authorization policy rules from the current policy of the DistributedEnforcer.\n\nParameters:\n- should_persist (bool): If true, the changes will be saved to the storage adapter.\n- sec (str): The policy section to modify, such as \"p\" for permission policies or \"g\" for role policies.\n- ptype (str): The type of policy being modified.\n- rules (list): A list of rules to be removed from the policy.\n\nReturns:\n- list: A list of rules that were affected by the removal operation.\n\nSide Effects:\n- If `should_persist` is true and the adapter is an instance of `batch_adapter`, the rules are removed in persistent storage.\n- The method will also attempt to build incremental role links using `build_incremental_role_links` if the section is \"g\". It logs any exceptions that occur during the process.\n\nDependencies:\n- Relies on `self.adapter`, which is expected to be set upon instantiation and can be an instance of `batch_adapter` for persistent storage.\n- Uses `self.get_model()` to interact with the underlying policy model and `PolicyOp` from `casbin.model.policy_op` for role linking operations.\"\"\"\n        '\\n        remove_policy_self provides a method for dispatcher to remove policies from current policy.\\n        The function returns the rules affected and error.\\n        '\n        if should_persist:\n            try:\n                if isinstance(self.adapter, batch_adapter):\n                    self.adapter.remove_policy(sec, ptype, rules)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n        effected = self.get_model().remove_policies_with_effected(sec, ptype, rules)\n        if sec == 'g':\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, rules)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n                return effected\n        return effected",
        "docstring": "Removes specified authorization policy rules from the current policy of the DistributedEnforcer.\n\nParameters:\n- should_persist (bool): If true, the changes will be saved to the storage adapter.\n- sec (str): The policy section to modify, such as \"p\" for permission policies or \"g\" for role policies.\n- ptype (str): The type of policy being modified.\n- rules (list): A list of rules to be removed from the policy.\n\nReturns:\n- list: A list of rules that were affected by the removal operation.\n\nSide Effects:\n- If `should_persist` is true and the adapter is an instance of `batch_adapter`, the rules are removed in persistent storage.\n- The method will also attempt to build incremental role links using `build_incremental_role_links` if the section is \"g\". It logs any exceptions that occur during the process.\n\nDependencies:\n- Relies on `self.adapter`, which is expected to be set upon instantiation and can be an instance of `batch_adapter` for persistent storage.\n- Uses `self.get_model()` to interact with the underlying policy model and `PolicyOp` from `casbin.model.policy_op` for role linking operations.",
        "signature": "def remove_policy_self(self, should_persist, sec, ptype, rules):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      },
      "DistributedEnforcer.remove_filtered_policy_self": {
        "code": "    def remove_filtered_policy_self(self, should_persist, sec, ptype, field_index, *field_values):\n        \"\"\"Removes authorization rules from the current policy based on specified field filters. This method allows for fine-grained control when deleting policies by using criteria defined through field indices and values.\n\nParameters:\n- should_persist (bool): Indicates whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions or \"g\" for roles).\n- ptype (str): The type of policy being modified.\n- field_index (int): The index of the field to filter on within the policy rules.\n- *field_values: Variable-length argument list representing the values to filter for the specified field.\n\nReturns:\n- List: The rules that were affected by the removal operation, or an empty list if none were removed.\n\nSide Effects:\n- If `should_persist` is True, this method attempts to persist the changes to the adapter.\n- An incremental update for role links may occur if the section is \"g\" (group) after removing policies.\n\nDependencies:\n- The method relies on the adapter (expected to be an instance with `remove_filtered_policy`) to handle persistent storage for policies.\n- It interacts with `self.get_model()` to manage policy state and uses `self.build_incremental_role_links` to handle role changes.\n- The `PolicyOp` class provides definitions for policy operation types, where `Policy_remove` is utilized for updating the role links.\"\"\"\n        '\\n        remove_filtered_policy_self provides a method for dispatcher to remove an authorization\\n        rule from the current policy,field filters can be specified.\\n        The function returns the rules affected and error.\\n        '\n        if should_persist:\n            try:\n                self.adapter.remove_filtered_policy(sec, ptype, field_index, field_values)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n        effects = self.get_model().remove_filtered_policy_returns_effects(sec, ptype, field_index, *field_values)\n        if sec == 'g':\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, effects)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n                return effects\n        return effects",
        "docstring": "Removes authorization rules from the current policy based on specified field filters. This method allows for fine-grained control when deleting policies by using criteria defined through field indices and values.\n\nParameters:\n- should_persist (bool): Indicates whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions or \"g\" for roles).\n- ptype (str): The type of policy being modified.\n- field_index (int): The index of the field to filter on within the policy rules.\n- *field_values: Variable-length argument list representing the values to filter for the specified field.\n\nReturns:\n- List: The rules that were affected by the removal operation, or an empty list if none were removed.\n\nSide Effects:\n- If `should_persist` is True, this method attempts to persist the changes to the adapter.\n- An incremental update for role links may occur if the section is \"g\" (group) after removing policies.\n\nDependencies:\n- The method relies on the adapter (expected to be an instance with `remove_filtered_policy`) to handle persistent storage for policies.\n- It interacts with `self.get_model()` to manage policy state and uses `self.build_incremental_role_links` to handle role changes.\n- The `PolicyOp` class provides definitions for policy operation types, where `Policy_remove` is utilized for updating the role links.",
        "signature": "def remove_filtered_policy_self(self, should_persist, sec, ptype, field_index, *field_values):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      },
      "DistributedEnforcer.clear_policy_self": {
        "code": "    def clear_policy_self(self, should_persist):\n        \"\"\"Clears all authorization rules from the current policy of the DistributedEnforcer instance. If the `should_persist` parameter is set to True, the method attempts to save the empty policy using the associated adapter. The method does not return a value but directly affects the state of the policy.\n\nParameters:\n- `should_persist` (bool): Indicates whether the change should be persisted. If True, triggers the persistence logic to save the cleared policy state.\n\nDependencies:\n- `self.adapter`: An adapter that handles policy persistence. The method calls `self.adapter.save_policy(None)` to save the changes, if `should_persist` is True.\n- `self.get_model()`: Retrieves the current model, which is used to clear the policy by calling `clear_policy()`.\n\nSide Effects:\n- The current policy is modified to remove all rules, impacting authorization decisions made subsequently by the DistributedEnforcer.\"\"\"\n        '\\n        clear_policy_self provides a method for dispatcher to clear all rules from the current policy.\\n        '\n        if should_persist:\n            try:\n                self.adapter.save_policy(None)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n        self.get_model().clear_policy()",
        "docstring": "Clears all authorization rules from the current policy of the DistributedEnforcer instance. If the `should_persist` parameter is set to True, the method attempts to save the empty policy using the associated adapter. The method does not return a value but directly affects the state of the policy.\n\nParameters:\n- `should_persist` (bool): Indicates whether the change should be persisted. If True, triggers the persistence logic to save the cleared policy state.\n\nDependencies:\n- `self.adapter`: An adapter that handles policy persistence. The method calls `self.adapter.save_policy(None)` to save the changes, if `should_persist` is True.\n- `self.get_model()`: Retrieves the current model, which is used to clear the policy by calling `clear_policy()`.\n\nSide Effects:\n- The current policy is modified to remove all rules, impacting authorization decisions made subsequently by the DistributedEnforcer.",
        "signature": "def clear_policy_self(self, should_persist):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      },
      "DistributedEnforcer.update_policy_self": {
        "code": "    def update_policy_self(self, should_persist, sec, ptype, old_rule, new_rule):\n        \"\"\"Update an authorization rule in the current policy.\n\nParameters:\n- should_persist (bool): A flag indicating whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for grouping).\n- ptype (str): The type of policy being updated.\n- old_rule (list): The existing rule that needs to be updated.\n- new_rule (list): The new rule to replace the old one.\n\nReturns:\n- bool: Returns True if the update is successful; otherwise, False. \n\nSide Effects:\nIf `should_persist` is True, the old rule will be updated to the new rule in the adapter if the adapter is of type `update_adapter`. The method also updates the model and handles role link adjustments for grouping policies by building incremental role links using `PolicyOp.Policy_remove` and `PolicyOp.Policy_add`.\n\nDependencies:\n- `PolicyOp`: A constant from the `casbin.model.policy_op` module used for indicating the type of policy operation (adding or removing).\n- `self.adapter`: The persistence layer for managing policy states, which is required to handle the saving of policy changes.\n- `self.get_model()`: Retrieves the current policy model, which is essential for updating the rules.\"\"\"\n        '\\n        update_policy_self provides a method for dispatcher to update an authorization rule from the current policy.\\n        '\n        if should_persist:\n            try:\n                if isinstance(self.adapter, update_adapter):\n                    self.adapter.update_policy(sec, ptype, old_rule, new_rule)\n            except Exception as e:\n                self._e.logger.error('An exception occurred: ' + e)\n                return False\n        rule_updated = self.get_model().update_policy(sec, ptype, old_rule, new_rule)\n        if not rule_updated:\n            return False\n        if sec == 'g':\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_remove, ptype, [old_rule])\n            except Exception as e:\n                return False\n            try:\n                self.build_incremental_role_links(PolicyOp.Policy_add, ptype, [new_rule])\n            except Exception as e:\n                return False\n        return True",
        "docstring": "Update an authorization rule in the current policy.\n\nParameters:\n- should_persist (bool): A flag indicating whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for grouping).\n- ptype (str): The type of policy being updated.\n- old_rule (list): The existing rule that needs to be updated.\n- new_rule (list): The new rule to replace the old one.\n\nReturns:\n- bool: Returns True if the update is successful; otherwise, False. \n\nSide Effects:\nIf `should_persist` is True, the old rule will be updated to the new rule in the adapter if the adapter is of type `update_adapter`. The method also updates the model and handles role link adjustments for grouping policies by building incremental role links using `PolicyOp.Policy_remove` and `PolicyOp.Policy_add`.\n\nDependencies:\n- `PolicyOp`: A constant from the `casbin.model.policy_op` module used for indicating the type of policy operation (adding or removing).\n- `self.adapter`: The persistence layer for managing policy states, which is required to handle the saving of policy changes.\n- `self.get_model()`: Retrieves the current policy model, which is essential for updating the rules.",
        "signature": "def update_policy_self(self, should_persist, sec, ptype, old_rule, new_rule):",
        "type": "Method",
        "class_signature": "class DistributedEnforcer(SyncedEnforcer):"
      }
    },
    "casbin/synced_enforcer.py": {
      "SyncedEnforcer.enforce": {
        "code": "    def enforce(self, *rvals):\n        \"\"\"Decides whether a \"subject\" can access a specified \"object\" with an associated \"action\". \n\nParameters:\n- *rvals: A variable-length argument list, typically representing three values: \n  - sub (subject): The entity trying to access the resource. \n  - obj (object): The resource being accessed. \n  - act (action): The operation that the subject wants to perform on the object.\n\nReturns:\n- bool: Returns True if the subject is allowed to perform the action on the object, otherwise returns False.\n\nThis method uses a read lock (_rl) to ensure synchronized access to the underlying Enforcer's enforcement logic, providing thread-safe operations. The *rvals argument is directly passed to the Enforcer's `enforce` method, which performs the actual access control decision based on the defined policy rules.\"\"\"\n        'decides whether a \"subject\" can access a \"object\" with the operation \"action\",\\n        input parameters are usually: (sub, obj, act).\\n        '\n        with self._rl:\n            return self._e.enforce(*rvals)",
        "docstring": "Decides whether a \"subject\" can access a specified \"object\" with an associated \"action\". \n\nParameters:\n- *rvals: A variable-length argument list, typically representing three values: \n  - sub (subject): The entity trying to access the resource. \n  - obj (object): The resource being accessed. \n  - act (action): The operation that the subject wants to perform on the object.\n\nReturns:\n- bool: Returns True if the subject is allowed to perform the action on the object, otherwise returns False.\n\nThis method uses a read lock (_rl) to ensure synchronized access to the underlying Enforcer's enforcement logic, providing thread-safe operations. The *rvals argument is directly passed to the Enforcer's `enforce` method, which performs the actual access control decision based on the defined policy rules.",
        "signature": "def enforce(self, *rvals):",
        "type": "Method",
        "class_signature": "class SyncedEnforcer:"
      }
    }
  },
  "dependency_dict": {
    "casbin/distributed_enforcer.py:DistributedEnforcer:__init__": {
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.__init__": {
          "code": "    def __init__(self, model=None, adapter=None):\n        self._e = Enforcer(model, adapter)\n        self._rwlock = RWLockWrite()\n        self._rl = self._rwlock.gen_rlock()\n        self._wl = self._rwlock.gen_wlock()\n        self._auto_loading = AtomicBool(False)\n        self._auto_loading_thread = None",
          "docstring": "",
          "signature": "def __init__(self, model=None, adapter=None):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      }
    },
    "casbin/distributed_enforcer.py:DistributedEnforcer:add_policy_self": {
      "casbin/model/policy.py": {
        "Policy.has_policy": {
          "code": "    def has_policy(self, sec, ptype, rule):\n        \"\"\"determines whether a model has the specified policy rule.\"\"\"\n        if sec not in self.keys():\n            return False\n        if ptype not in self[sec]:\n            return False\n\n        return rule in self[sec][ptype].policy",
          "docstring": "determines whether a model has the specified policy rule.",
          "signature": "def has_policy(self, sec, ptype, rule):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.add_policies": {
          "code": "    def add_policies(self, sec, ptype, rules):\n        \"\"\"adds policy rules to the model.\"\"\"\n\n        for rule in rules:\n            if self.has_policy(sec, ptype, rule):\n                return False\n\n        for rule in rules:\n            self[sec][ptype].policy.append(rule)\n\n        return True",
          "docstring": "adds policy rules to the model.",
          "signature": "def add_policies(self, sec, ptype, rules):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.get_model": {
          "code": "    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()",
          "docstring": "gets the current model.",
          "signature": "def get_model(self):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        },
        "SyncedEnforcer.build_incremental_role_links": {
          "code": "    def build_incremental_role_links(self, op, ptype, rules):\n        self.get_model().build_incremental_role_links(self.get_role_manager(), op, 'g', ptype, rules)",
          "docstring": "",
          "signature": "def build_incremental_role_links(self, op, ptype, rules):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      }
    },
    "casbin/synced_enforcer.py:SyncedEnforcer:enforce": {
      "casbin/util/rwlock.py": {
        "ReadRWLock.__enter__": {
          "code": "    def __enter__(self):\n        self.rwlock.aquire_read()",
          "docstring": "",
          "signature": "def __enter__(self):",
          "type": "Method",
          "class_signature": "class ReadRWLock:"
        },
        "ReadRWLock.__exit__": {
          "code": "    def __exit__(self, exc_type, exc_value, traceback):\n        self.rwlock.release_read()\n        return False",
          "docstring": "",
          "signature": "def __exit__(self, exc_type, exc_value, traceback):",
          "type": "Method",
          "class_signature": "class ReadRWLock:"
        }
      },
      "casbin/core_enforcer.py": {
        "CoreEnforcer.enforce": {
          "code": "    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result",
          "docstring": "decides whether a \"subject\" can access a \"object\" with the operation \"action\",\ninput parameters are usually: (sub, obj, act).",
          "signature": "def enforce(self, *rvals):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      }
    },
    "casbin/distributed_enforcer.py:DistributedEnforcer:update_policy_self": {
      "casbin/model/policy.py": {
        "Policy.update_policy": {
          "code": "    def update_policy(self, sec, ptype, old_rule, new_rule):\n        \"\"\"update a policy rule from the model.\"\"\"\n\n        if sec not in self.keys():\n            return False\n        if ptype not in self[sec]:\n            return False\n\n        ast = self[sec][ptype]\n\n        if old_rule in ast.policy:\n            rule_index = ast.policy.index(old_rule)\n        else:\n            return False\n\n        if \"p_priority\" in ast.tokens:\n            priority_index = ast.tokens.index(\"p_priority\")\n            if old_rule[priority_index] == new_rule[priority_index]:\n                ast.policy[rule_index] = new_rule\n            else:\n                raise Exception(\"New rule should have the same priority with old rule.\")\n        else:\n            ast.policy[rule_index] = new_rule\n\n        return True",
          "docstring": "update a policy rule from the model.",
          "signature": "def update_policy(self, sec, ptype, old_rule, new_rule):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.get_model": {
          "code": "    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()",
          "docstring": "gets the current model.",
          "signature": "def get_model(self):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        },
        "SyncedEnforcer.build_incremental_role_links": {
          "code": "    def build_incremental_role_links(self, op, ptype, rules):\n        self.get_model().build_incremental_role_links(self.get_role_manager(), op, 'g', ptype, rules)",
          "docstring": "",
          "signature": "def build_incremental_role_links(self, op, ptype, rules):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      }
    },
    "casbin/distributed_enforcer.py:DistributedEnforcer:remove_policy_self": {
      "casbin/model/policy.py": {
        "Policy.remove_policies_with_effected": {
          "code": "    def remove_policies_with_effected(self, sec, ptype, rules):\n        effected = []\n        for rule in rules:\n            if self.has_policy(sec, ptype, rule):\n                effected.append(rule)\n                self.remove_policy(sec, ptype, rule)\n\n        return effected",
          "docstring": "",
          "signature": "def remove_policies_with_effected(self, sec, ptype, rules):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.get_model": {
          "code": "    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()",
          "docstring": "gets the current model.",
          "signature": "def get_model(self):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      }
    },
    "casbin/distributed_enforcer.py:DistributedEnforcer:remove_filtered_policy_self": {
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.get_model": {
          "code": "    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()",
          "docstring": "gets the current model.",
          "signature": "def get_model(self):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        },
        "SyncedEnforcer.build_incremental_role_links": {
          "code": "    def build_incremental_role_links(self, op, ptype, rules):\n        self.get_model().build_incremental_role_links(self.get_role_manager(), op, 'g', ptype, rules)",
          "docstring": "",
          "signature": "def build_incremental_role_links(self, op, ptype, rules):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      },
      "casbin/model/policy.py": {
        "Policy.remove_filtered_policy_returns_effects": {
          "code": "    def remove_filtered_policy_returns_effects(self, sec, ptype, field_index, *field_values):\n        \"\"\"\n        remove_filtered_policy_returns_effects removes policy rules based on field filters from the model.\n        \"\"\"\n        tmp = []\n        effects = []\n\n        if len(field_values) == 0:\n            return []\n        if sec not in self.keys():\n            return []\n        if ptype not in self[sec]:\n            return []\n\n        for rule in self[sec][ptype].policy:\n            if all(value == \"\" or rule[field_index + i] == value for i, value in enumerate(field_values)):\n                effects.append(rule)\n            else:\n                tmp.append(rule)\n\n        self[sec][ptype].policy = tmp\n\n        return effects",
          "docstring": "remove_filtered_policy_returns_effects removes policy rules based on field filters from the model.",
          "signature": "def remove_filtered_policy_returns_effects(self, sec, ptype, field_index, *field_values):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      }
    },
    "casbin/distributed_enforcer.py:DistributedEnforcer:clear_policy_self": {
      "casbin/synced_enforcer.py": {
        "SyncedEnforcer.get_model": {
          "code": "    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()",
          "docstring": "gets the current model.",
          "signature": "def get_model(self):",
          "type": "Method",
          "class_signature": "class SyncedEnforcer:"
        }
      },
      "casbin/model/policy.py": {
        "Policy.clear_policy": {
          "code": "    def clear_policy(self):\n        \"\"\"clears all current policy.\"\"\"\n\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key in self[sec].keys():\n                self[sec][key].policy = []",
          "docstring": "clears all current policy.",
          "signature": "def clear_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_distributed_api.py:TestDistributedApi:test": {
      "tests/test_enforcer.py:get_examples": {},
      "tests/test_distributed_api.py:TestDistributedApi:get_enforcer": {
        "casbin/distributed_enforcer.py:DistributedEnforcer:__init__": {
          "casbin/synced_enforcer.py:SyncedEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:__init__": {
              "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
                "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
                "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                  "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                    "casbin/model/policy.py:Policy:__init__": {},
                    "casbin/model/model.py:Model:load_model": {
                      "casbin/config/config.py:Config:new_config": {},
                      "casbin/model/model.py:Model:_load_section": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                    "casbin/model/model.py:Model:Model": {},
                    "casbin/persist/adapter.py:Adapter:Adapter": {},
                    "casbin/model/model.py:Model:print_model": {
                      "casbin/model/policy.py:Policy:items": {}
                    },
                    "casbin/model/function.py:FunctionMap:load_function_map": {
                      "casbin/model/function.py:FunctionMap:__init__": {},
                      "casbin/model/function.py:FunctionMap:add_function": {}
                    },
                    "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/effect/__init__.py:get_effector": {},
                      "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {}
                    },
                    "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                    "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {},
                      "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {},
                      "casbin/model/model.py:Model:sort_policies_by_priority": {},
                      "casbin/model/policy.py:Policy:print_policy": {},
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:clear": {},
                      "casbin/model/policy.py:Policy:build_role_links": {}
                    }
                  }
                }
              },
              "casbin/util/log.py:disabled_logging": {}
            },
            "casbin/util/rwlock.py:RWLockWrite:__init__": {},
            "casbin/util/rwlock.py:RWLockWrite:gen_rlock": {
              "casbin/util/rwlock.py:ReadRWLock:__init__": {}
            },
            "casbin/util/rwlock.py:RWLockWrite:gen_wlock": {
              "casbin/util/rwlock.py:WriteRWLock:__init__": {}
            },
            "casbin/synced_enforcer.py:AtomicBool:__init__": {}
          }
        }
      },
      "casbin/distributed_enforcer.py:DistributedEnforcer:add_policy_self": {
        "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
          "casbin/util/rwlock.py:ReadRWLock:__enter__": {
            "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
          },
          "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
          "casbin/util/rwlock.py:ReadRWLock:__exit__": {
            "casbin/util/rwlock.py:RWLockWrite:release_read": {}
          }
        },
        "casbin/model/policy.py:Policy:has_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:add_policies": {},
        "casbin/synced_enforcer.py:SyncedEnforcer:build_incremental_role_links": {
          "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/synced_enforcer.py:SyncedEnforcer:get_role_manager": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_role_manager": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/model/policy.py:Policy:build_incremental_role_links": {
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_incremental_role_links": {}
          }
        }
      },
      "casbin/synced_enforcer.py:SyncedEnforcer:enforce": {
        "casbin/util/rwlock.py:ReadRWLock:__enter__": {
          "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:enforce": {
          "casbin/core_enforcer.py:CoreEnforcer:enforce_ex": {
            "casbin/core_enforcer.py:EnforceContext:EnforceContext": {},
            "casbin/model/function.py:FunctionMap:get_functions": {},
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/util/builtin_operators.py:generate_g_function": {},
            "casbin/util/util.py:has_eval": {},
            "casbin/core_enforcer.py:CoreEnforcer:_get_expression": {
              "casbin/util/expression.py:SimpleEval:__init__": {}
            },
            "casbin/util/expression.py:SimpleEval:eval": {
              "casbin/util/builtin_operators.py:f": {
                "casbin/rbac/default_role_manager/role_manager.py:RoleManager:has_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_get_role": {
                    "casbin/rbac/default_role_manager/role_manager.py:Role:__init__": {}
                  },
                  "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_has_link": {
                    "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_has_link": {
                      "[ignored_or_cut_off]": "..."
                    }
                  }
                }
              }
            },
            "casbin/effect/default_effectors.py:AllowOverrideEffector:intermediate_effect": {},
            "casbin/effect/default_effectors.py:AllowOverrideEffector:final_effect": {},
            "casbin/effect/__init__.py:effect_to_bool": {}
          }
        },
        "casbin/util/rwlock.py:ReadRWLock:__exit__": {
          "casbin/util/rwlock.py:RWLockWrite:release_read": {}
        }
      },
      "casbin/distributed_enforcer.py:DistributedEnforcer:update_policy_self": {
        "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
          "casbin/util/rwlock.py:ReadRWLock:__enter__": {
            "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
          },
          "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
          "casbin/util/rwlock.py:ReadRWLock:__exit__": {
            "casbin/util/rwlock.py:RWLockWrite:release_read": {}
          }
        },
        "casbin/model/policy.py:Policy:update_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/synced_enforcer.py:SyncedEnforcer:build_incremental_role_links": {
          "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/synced_enforcer.py:SyncedEnforcer:get_role_manager": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_role_manager": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/model/policy.py:Policy:build_incremental_role_links": {
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_incremental_role_links": {
              "casbin/rbac/default_role_manager/role_manager.py:RoleManager:delete_link": {
                "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_get_role": {},
                "casbin/rbac/default_role_manager/role_manager.py:Role:remove_role": {
                  "casbin/rbac/default_role_manager/role_manager.py:Role:_remove_user": {}
                },
                "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_matching_fn": {
                  "casbin/rbac/default_role_manager/role_manager.py:match_error_handler": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:RoleManager:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_get_role": {
                  "casbin/rbac/default_role_manager/role_manager.py:Role:__init__": {}
                },
                "casbin/rbac/default_role_manager/role_manager.py:Role:add_role": {
                  "casbin/rbac/default_role_manager/role_manager.py:Role:_add_user": {}
                }
              }
            }
          }
        }
      },
      "casbin/distributed_enforcer.py:DistributedEnforcer:remove_policy_self": {
        "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
          "casbin/util/rwlock.py:ReadRWLock:__enter__": {
            "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
          },
          "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
          "casbin/util/rwlock.py:ReadRWLock:__exit__": {
            "casbin/util/rwlock.py:RWLockWrite:release_read": {}
          }
        },
        "casbin/model/policy.py:Policy:remove_policies_with_effected": {
          "casbin/model/policy.py:Policy:has_policy": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {}
          },
          "casbin/model/policy.py:Policy:remove_policy": {
            "casbin/model/policy.py:Policy:has_policy": {
              "casbin/model/policy.py:Policy:keys": {},
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/model/policy.py:Policy:__getitem__": {}
          }
        }
      },
      "casbin/distributed_enforcer.py:DistributedEnforcer:remove_filtered_policy_self": {
        "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
          "casbin/util/rwlock.py:ReadRWLock:__enter__": {
            "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
          },
          "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
          "casbin/util/rwlock.py:ReadRWLock:__exit__": {
            "casbin/util/rwlock.py:RWLockWrite:release_read": {}
          }
        },
        "casbin/model/policy.py:Policy:remove_filtered_policy_returns_effects": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/synced_enforcer.py:SyncedEnforcer:build_incremental_role_links": {
          "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/synced_enforcer.py:SyncedEnforcer:get_role_manager": {
            "casbin/util/rwlock.py:ReadRWLock:__enter__": {
              "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:get_role_manager": {},
            "casbin/util/rwlock.py:ReadRWLock:__exit__": {
              "casbin/util/rwlock.py:RWLockWrite:release_read": {}
            }
          },
          "casbin/model/policy.py:Policy:build_incremental_role_links": {
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_incremental_role_links": {}
          }
        }
      },
      "casbin/distributed_enforcer.py:DistributedEnforcer:clear_policy_self": {
        "casbin/synced_enforcer.py:SyncedEnforcer:get_model": {
          "casbin/util/rwlock.py:ReadRWLock:__enter__": {
            "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
          },
          "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
          "casbin/util/rwlock.py:ReadRWLock:__exit__": {
            "casbin/util/rwlock.py:RWLockWrite:release_read": {}
          }
        },
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        }
      }
    },
    "tests/test_distributed_api.py:TestDistributedApi:get_enforcer": {
      "casbin/distributed_enforcer.py:DistributedEnforcer:__init__": {
        "casbin/synced_enforcer.py:SyncedEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:__init__": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/policy.py:Policy:clear_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:build_role_links": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/model/assertion.py:Assertion:build_role_links": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_distributed_api\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u251c\u2500\u2500 distributed_enforcer.py\n    \u2502   \u251c\u2500\u2500 DistributedEnforcer.__init__\n    \u2502   \u251c\u2500\u2500 DistributedEnforcer.add_policy_self\n    \u2502   \u251c\u2500\u2500 DistributedEnforcer.clear_policy_self\n    \u2502   \u251c\u2500\u2500 DistributedEnforcer.remove_filtered_policy_self\n    \u2502   \u251c\u2500\u2500 DistributedEnforcer.remove_policy_self\n    \u2502   \u2514\u2500\u2500 DistributedEnforcer.update_policy_self\n    \u2514\u2500\u2500 synced_enforcer.py\n        \u2514\u2500\u2500 SyncedEnforcer.enforce\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a distributed, role-based access control (RBAC) enforcement mechanism, leveraging Casbin's capabilities to define, manage, and enforce fine-grained access control policies. It supports operations such as adding, updating, and deleting access policies, assigning roles, and performing permission checks dynamically. By enabling programmatically configurable policy management, the module ensures flexible and scalable access control for systems with distributed components or complex permission hierarchies. This solves the problem of centralizing authorization logic, reducing manual configuration errors, and improving security by automating and validating access decisions against predefined policies.\n\n## FILE 1: casbin/distributed_enforcer.py\n\n- CLASS METHOD: DistributedEnforcer.clear_policy_self\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def clear_policy_self(self, should_persist):\n  - DOCSTRING: \n```python\n\"\"\"\nClears all authorization rules from the current policy of the DistributedEnforcer instance. If the `should_persist` parameter is set to True, the method attempts to save the empty policy using the associated adapter. The method does not return a value but directly affects the state of the policy.\n\nParameters:\n- `should_persist` (bool): Indicates whether the change should be persisted. If True, triggers the persistence logic to save the cleared policy state.\n\nDependencies:\n- `self.adapter`: An adapter that handles policy persistence. The method calls `self.adapter.save_policy(None)` to save the changes, if `should_persist` is True.\n- `self.get_model()`: Retrieves the current model, which is used to clear the policy by calling `clear_policy()`.\n\nSide Effects:\n- The current policy is modified to remove all rules, impacting authorization decisions made subsequently by the DistributedEnforcer.\n\"\"\"\n```\n\n- CLASS METHOD: DistributedEnforcer.add_policy_self\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def add_policy_self(self, should_persist, sec, ptype, rules):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds authorization rules to the current policy within the DistributedEnforcer, which extends the SyncedEnforcer. The method checks for existing policies to avoid duplicates and optionally persists the new policies using the adapter. \n\nParameters:\n- should_persist (bool): Indicates whether the changes should be saved to the adapter.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for role mappings).\n- ptype (str): The policy type for the rules being added.\n- rules (list): A list of rules to be added to the specified section and policy type.\n\nReturns:\n- list: The rules that were successfully added, excluding any that were duplicates.\n\nSide Effects:\n- If should_persist is True, the new policies may be saved to the data store via the defined adapter.\n- In the case of section \"g\", the method updates incremental role links, making use of the PolicyOp.Policy_add constant to indicate the operation type. \n- Errors during the policy addition or updating role links are logged.\n\nDependencies:\n- Requires the `batch_adapter` class, which handles batch operations for policy manipulation.\n- Uses `PolicyOp` from the `casbin.model.policy_op` module to track policy operations.\n- Interacts with the underlying model through methods like `has_policy`, `add_policies`, `build_incremental_role_links`, and an internal logging mechanism.\n\"\"\"\n```\n\n- CLASS METHOD: DistributedEnforcer.remove_filtered_policy_self\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def remove_filtered_policy_self(self, should_persist, sec, ptype, field_index, *field_values):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves authorization rules from the current policy based on specified field filters. This method allows for fine-grained control when deleting policies by using criteria defined through field indices and values.\n\nParameters:\n- should_persist (bool): Indicates whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions or \"g\" for roles).\n- ptype (str): The type of policy being modified.\n- field_index (int): The index of the field to filter on within the policy rules.\n- *field_values: Variable-length argument list representing the values to filter for the specified field.\n\nReturns:\n- List: The rules that were affected by the removal operation, or an empty list if none were removed.\n\nSide Effects:\n- If `should_persist` is True, this method attempts to persist the changes to the adapter.\n- An incremental update for role links may occur if the section is \"g\" (group) after removing policies.\n\nDependencies:\n- The method relies on the adapter (expected to be an instance with `remove_filtered_policy`) to handle persistent storage for policies.\n- It interacts with `self.get_model()` to manage policy state and uses `self.build_incremental_role_links` to handle role changes.\n- The `PolicyOp` class provides definitions for policy operation types, where `Policy_remove` is utilized for updating the role links.\n\"\"\"\n```\n\n- CLASS METHOD: DistributedEnforcer.__init__\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def __init__(self, model=None, adapter=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DistributedEnforcer instance, which is a wrapper around the SyncedEnforcer for handling dispatcher functionalities. \n\nParameters:\n- model (optional): An optional model specification used for the enforcer, inherited from the SyncedEnforcer.\n- adapter (optional): An optional adapter that provides persistence functionality for storing policies, also inherited from the SyncedEnforcer.\n\nThe method initializes the DistributedEnforcer by calling the __init__ method of the SyncedEnforcer, allowing it to leverage the existing functionality defined therein. No return value is produced.\n\"\"\"\n```\n\n- CLASS METHOD: DistributedEnforcer.remove_policy_self\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def remove_policy_self(self, should_persist, sec, ptype, rules):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves specified authorization policy rules from the current policy of the DistributedEnforcer.\n\nParameters:\n- should_persist (bool): If true, the changes will be saved to the storage adapter.\n- sec (str): The policy section to modify, such as \"p\" for permission policies or \"g\" for role policies.\n- ptype (str): The type of policy being modified.\n- rules (list): A list of rules to be removed from the policy.\n\nReturns:\n- list: A list of rules that were affected by the removal operation.\n\nSide Effects:\n- If `should_persist` is true and the adapter is an instance of `batch_adapter`, the rules are removed in persistent storage.\n- The method will also attempt to build incremental role links using `build_incremental_role_links` if the section is \"g\". It logs any exceptions that occur during the process.\n\nDependencies:\n- Relies on `self.adapter`, which is expected to be set upon instantiation and can be an instance of `batch_adapter` for persistent storage.\n- Uses `self.get_model()` to interact with the underlying policy model and `PolicyOp` from `casbin.model.policy_op` for role linking operations.\n\"\"\"\n```\n\n- CLASS METHOD: DistributedEnforcer.update_policy_self\n  - CLASS SIGNATURE: class DistributedEnforcer(SyncedEnforcer):\n  - SIGNATURE: def update_policy_self(self, should_persist, sec, ptype, old_rule, new_rule):\n  - DOCSTRING: \n```python\n\"\"\"\nUpdate an authorization rule in the current policy.\n\nParameters:\n- should_persist (bool): A flag indicating whether changes should be saved persistently.\n- sec (str): The section of the policy (e.g., \"p\" for permissions, \"g\" for grouping).\n- ptype (str): The type of policy being updated.\n- old_rule (list): The existing rule that needs to be updated.\n- new_rule (list): The new rule to replace the old one.\n\nReturns:\n- bool: Returns True if the update is successful; otherwise, False. \n\nSide Effects:\nIf `should_persist` is True, the old rule will be updated to the new rule in the adapter if the adapter is of type `update_adapter`. The method also updates the model and handles role link adjustments for grouping policies by building incremental role links using `PolicyOp.Policy_remove` and `PolicyOp.Policy_add`.\n\nDependencies:\n- `PolicyOp`: A constant from the `casbin.model.policy_op` module used for indicating the type of policy operation (adding or removing).\n- `self.adapter`: The persistence layer for managing policy states, which is required to handle the saving of policy changes.\n- `self.get_model()`: Retrieves the current policy model, which is essential for updating the rules.\n\"\"\"\n```\n\n## FILE 2: casbin/synced_enforcer.py\n\n- CLASS METHOD: SyncedEnforcer.enforce\n  - CLASS SIGNATURE: class SyncedEnforcer:\n  - SIGNATURE: def enforce(self, *rvals):\n  - DOCSTRING: \n```python\n\"\"\"\nDecides whether a \"subject\" can access a specified \"object\" with an associated \"action\". \n\nParameters:\n- *rvals: A variable-length argument list, typically representing three values: \n  - sub (subject): The entity trying to access the resource. \n  - obj (object): The resource being accessed. \n  - act (action): The operation that the subject wants to perform on the object.\n\nReturns:\n- bool: Returns True if the subject is allowed to perform the action on the object, otherwise returns False.\n\nThis method uses a read lock (_rl) to ensure synchronized access to the underlying Enforcer's enforcement logic, providing thread-safe operations. The *rvals argument is directly passed to the Enforcer's `enforce` method, which performs the actual access control decision based on the defined policy rules.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/distributed_enforcer.py": "from casbin.model.policy_op import PolicyOp\nfrom casbin.persist import batch_adapter, update_adapter\nfrom casbin.synced_enforcer import SyncedEnforcer\n\nclass DistributedEnforcer(SyncedEnforcer):\n    \"\"\"DistributedEnforcer wraps SyncedEnforcer for dispatcher.\"\"\"",
    "casbin/synced_enforcer.py": "import threading\nimport time\nfrom casbin.enforcer import Enforcer\nfrom casbin.util.rwlock import RWLockWrite\n\nclass AtomicBool:\n\n    def __init__(self, value):\n        self._lock = threading.Lock()\n        self._value = value\n\n    @property\n    def value(self):\n        with self._lock:\n            return self._value\n\n    @value.setter\n    def value(self, value):\n        with self._lock:\n            self._value = value\n\nclass SyncedEnforcer:\n    \"\"\"SyncedEnforcer wraps Enforcer and provides synchronized access.\n    It's also a drop-in replacement for Enforcer\"\"\"\n\n    def __init__(self, model=None, adapter=None):\n        self._e = Enforcer(model, adapter)\n        self._rwlock = RWLockWrite()\n        self._rl = self._rwlock.gen_rlock()\n        self._wl = self._rwlock.gen_wlock()\n        self._auto_loading = AtomicBool(False)\n        self._auto_loading_thread = None\n\n    def is_auto_loading_running(self):\n        \"\"\"check if SyncedEnforcer is auto loading policies\"\"\"\n        return self._auto_loading.value\n\n    def _auto_load_policy(self, interval):\n        while self.is_auto_loading_running():\n            time.sleep(interval)\n            try:\n                self.load_policy()\n            except Exception as e:\n                self._e.logger.error(repr(e))\n\n    def start_auto_load_policy(self, interval):\n        \"\"\"starts a thread that will call load_policy every interval seconds\"\"\"\n        if self.is_auto_loading_running():\n            return\n        self._auto_loading.value = True\n        self._auto_loading_thread = threading.Thread(target=self._auto_load_policy, args=[interval], daemon=True)\n        self._auto_loading_thread.start()\n\n    def stop_auto_load_policy(self):\n        \"\"\"stops the thread started by start_auto_load_policy\"\"\"\n        if self.is_auto_loading_running():\n            self._auto_loading.value = False\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        with self._rl:\n            return self._e.get_model()\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n        with self._wl:\n            return self._e.set_model(m)\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n        with self._wl:\n            return self._e.load_model()\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        with self._rl:\n            return self._e.get_role_manager()\n\n    def set_role_manager(self, rm):\n        with self._wl:\n            self._e.set_role_manager(rm)\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n        with self._rl:\n            self._e.get_adapter()\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n        with self._wl:\n            self._e.set_adapter(adapter)\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n        with self._wl:\n            self._e.set_watcher(watcher)\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        with self._wl:\n            self._e.set_effector(eft)\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n        with self._wl:\n            return self._e.clear_policy()\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        with self._wl:\n            return self._e.load_policy()\n\n    def load_filtered_policy(self, filter):\n        \"\"\" \"reloads a filtered policy from file/database.\"\"\"\n        with self._wl:\n            return self._e.load_filtered_policy(filter)\n\n    def save_policy(self):\n        with self._rl:\n            return self._e.save_policy()\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        with self._rl:\n            return self._e.build_role_links()\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        with self._rl:\n            return self._e.enforce_ex(*rvals)\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches,\n        input parameters are usually: [(sub, obj, act), (sub, obj, act), ...].\n        \"\"\"\n        with self._rl:\n            return self._e.batch_enforce(rvals)\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_subjects()\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_subjects(ptype)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_objects()\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_objects(ptype)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_actions()\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_actions(ptype)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_roles()\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_all_named_roles(ptype)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_policy()\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_policy(field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        with self._rl:\n            return self._e.get_named_policy(ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_named_policy(ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_grouping_policy()\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_grouping_policy(field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        with self._rl:\n            return self._e.get_named_grouping_policy(ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        with self._rl:\n            return self._e.get_filtered_named_grouping_policy(ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_policy(*params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_named_policy(ptype, *params)\n\n    def add_policy(self, *params):\n        \"\"\"adds an authorization rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_policy(*params)\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_named_policy(ptype, *params)\n\n    def remove_policy(self, *params):\n        \"\"\"removes an authorization rule from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_policy(*params)\n\n    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_policy(field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_policy(ptype, *params)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_named_policy(ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_grouping_policy(*params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n        with self._rl:\n            return self._e.has_named_grouping_policy(ptype, *params)\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_grouping_policy(*params)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_named_grouping_policy(ptype, *params)\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_grouping_policy(*params)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_grouping_policy(field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_grouping_policy(ptype, *params)\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        with self._wl:\n            return self._e.remove_filtered_named_grouping_policy(ptype, field_index, *field_values)\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        with self._wl:\n            return self._e.add_function(name, func)\n\n    def get_roles_for_user(self, name):\n        \"\"\"gets the roles that a user has.\"\"\"\n        with self._rl:\n            return self._e.get_roles_for_user(name)\n\n    def get_users_for_role(self, name):\n        \"\"\"gets the users that has a role.\"\"\"\n        with self._rl:\n            return self._e.get_users_for_role(name)\n\n    def has_role_for_user(self, name, role):\n        \"\"\"determines whether a user has a role.\"\"\"\n        with self._rl:\n            return self._e.has_role_for_user(name, role)\n\n    def add_role_for_user(self, user, role):\n        \"\"\"\n        adds a role for a user.\n        Returns false if the user already has the role (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.add_role_for_user(user, role)\n\n    def delete_role_for_user(self, user, role):\n        \"\"\"\n        deletes a role for a user.\n        Returns false if the user does not have the role (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_role_for_user(user, role)\n\n    def delete_roles_for_user(self, user):\n        \"\"\"\n        deletes all roles for a user.\n        Returns false if the user does not have any roles (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_roles_for_user(user)\n\n    def delete_user(self, user):\n        \"\"\"\n        deletes a user.\n        Returns false if the user does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_user(user)\n\n    def delete_role(self, role):\n        \"\"\"\n        deletes a role.\n        Returns false if the role does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_role(role)\n\n    def delete_permission(self, *permission):\n        \"\"\"\n        deletes a permission.\n        Returns false if the permission does not exist (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permission(*permission)\n\n    def add_permission_for_user(self, user, *permission):\n        \"\"\"\n        adds a permission for a user or role.\n        Returns false if the user or role already has the permission (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.add_permission_for_user(user, *permission)\n\n    def delete_permission_for_user(self, user, *permission):\n        \"\"\"\n        deletes a permission for a user or role.\n        Returns false if the user or role does not have the permission (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permission_for_user(user, *permission)\n\n    def delete_permissions_for_user(self, user):\n        \"\"\"\n        deletes permissions for a user or role.\n        Returns false if the user or role does not have any permissions (aka not affected).\n        \"\"\"\n        with self._wl:\n            return self._e.delete_permissions_for_user(user)\n\n    def get_permissions_for_user(self, user):\n        \"\"\"\n        gets permissions for a user or role.\n        \"\"\"\n        with self._rl:\n            return self._e.get_permissions_for_user(user)\n\n    def has_permission_for_user(self, user, *permission):\n        \"\"\"\n        determines whether a user has a permission.\n        \"\"\"\n        with self._rl:\n            return self._e.has_permission_for_user(user, *permission)\n\n    def get_implicit_roles_for_user(self, name, *domain):\n        \"\"\"\n        gets implicit roles that a user has.\n        Compared to get_roles_for_user(), this function retrieves indirect roles besides direct roles.\n        For example:\n        g, alice, role:admin\n        g, role:admin, role:user\n\n        get_roles_for_user(\"alice\") can only get: [\"role:admin\"].\n        But get_implicit_roles_for_user(\"alice\") will get: [\"role:admin\", \"role:user\"].\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_roles_for_user(name, *domain)\n\n    def get_implicit_permissions_for_user(self, user, *domain, filter_policy_dom=True):\n        \"\"\"\n        gets implicit permissions for a user or role.\n        Compared to get_permissions_for_user(), this function retrieves permissions for inherited roles.\n        For example:\n        p, admin, data1, read\n        p, alice, data2, read\n        g, alice, admin\n\n        get_permissions_for_user(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n        But get_implicit_permissions_for_user(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_permissions_for_user(user, *domain, filter_policy_dom=filter_policy_dom)\n\n    def get_named_implicit_permissions_for_user(self, ptype, user, *domain, filter_policy_dom=True):\n        \"\"\"\n        gets implicit permissions for a user or role by named policy.\n        Compared to get_permissions_for_user(), this function retrieves permissions for inherited roles.\n        For example:\n        p, admin, data1, read\n        p, alice, data2, read\n        g, alice, admin\n\n        get_permissions_for_user(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n        But get_implicit_permissions_for_user(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\n        \"\"\"\n        with self._rl:\n            return self._e.get_named_implicit_permissions_for_user(ptype, user, *domain, filter_policy_dom=filter_policy_dom)\n\n    def get_implicit_users_for_permission(self, *permission):\n        \"\"\"\n        gets implicit users for a permission.\n        For example:\n        p, admin, data1, read\n        p, bob, data1, read\n        g, alice, admin\n\n        get_implicit_users_for_permission(\"data1\", \"read\") will get: [\"alice\", \"bob\"].\n        Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\n        \"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_permission(*permission)\n\n    def get_roles_for_user_in_domain(self, name, domain):\n        \"\"\"gets the roles that a user has inside a domain.\"\"\"\n        with self._rl:\n            return self._e.get_roles_for_user_in_domain(name, domain)\n\n    def get_users_for_role_in_domain(self, name, domain):\n        \"\"\"gets the users that has a role inside a domain.\"\"\"\n        with self._rl:\n            return self._e.get_users_for_role_in_domain(name, domain)\n\n    def add_role_for_user_in_domain(self, user, role, domain):\n        \"\"\"adds a role for a user inside a domain.\"\"\"\n        'Returns false if the user already has the role (aka not affected).'\n        with self._wl:\n            return self._e.add_role_for_user_in_domain(user, role, domain)\n\n    def delete_roles_for_user_in_domain(self, user, role, domain):\n        \"\"\"deletes a role for a user inside a domain.\"\"\"\n        'Returns false if the user does not have any roles (aka not affected).'\n        with self._wl:\n            return self._e.delete_roles_for_user_in_domain(user, role, domain)\n\n    def get_permissions_for_user_in_domain(self, user, domain):\n        \"\"\"gets permissions for a user or role inside domain.\"\"\"\n        with self._rl:\n            return self._e.get_permissions_for_user_in_domain(user, domain)\n\n    def get_named_permissions_for_user_in_domain(self, ptype, user, domain):\n        \"\"\"gets permissions for a user or role by named policy inside domain.\"\"\"\n        with self._rl:\n            return self._e.get_named_permissions_for_user_in_domain(ptype, user, domain)\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        with self._wl:\n            return self._e.enable_auto_build_role_links(auto_build_role_links)\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        with self._wl:\n            return self._e.enable_auto_save(auto_save)\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n        with self._wl:\n            return self._e.enable_enforce(enabled)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        with self._wl:\n            self._e.add_named_matching_func(ptype, fn)\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        with self._wl:\n            self._e.add_named_link_condition_func(ptype, user, role, fn)\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        with self._wl:\n            self._e.add_named_domain_matching_func(ptype, fn)\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        with self._wl:\n            self._e.add_named_domain_link_condition_func(ptype, user, role, domain, fn)\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        with self._wl:\n            self._e.set_named_domain_link_condition_func_params(ptype, user, role, domain, *params)\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        with self._wl:\n            self._e.set_named_link_condition_func_params(ptype, user, role, *params)\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        with self._rl:\n            self._e.is_filtered()\n\n    def add_policies(self, rules):\n        \"\"\"adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_policies(rules)\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        with self._wl:\n            return self._e.add_named_policies(ptype, rules)\n\n    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_policies(rules)\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_policies(ptype, rules)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        with self._wl:\n            return self._e.add_grouping_policies(rules)\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\" \"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        with self._wl:\n            return self._e.add_named_grouping_policies(ptype, rules)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        with self._wl:\n            return self._e.remove_grouping_policies(rules)\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        with self._wl:\n            return self._e.remove_named_grouping_policies(ptype, rules)\n\n    def build_incremental_role_links(self, op, ptype, rules):\n        self.get_model().build_incremental_role_links(self.get_role_manager(), op, 'g', ptype, rules)\n\n    def new_enforce_context(self, suffix: str) -> 'EnforceContext':\n        return self._e.new_enforce_context(suffix)\n\n    def get_field_index(self, ptype, field):\n        \"\"\"gets the index of the field name.\"\"\"\n        return self._e.model.get_field_index(ptype, field)\n\n    def set_field_index(self, ptype, field, index):\n        \"\"\"sets the index of the field name.\"\"\"\n        assertion = self._e.model['p'][ptype]\n        assertion.field_index_map[field] = index\n\n    def get_all_roles_by_domain(self, domain):\n        \"\"\"gets all roles associated with the domain.\n        note: Not applicable to Domains with inheritance relationship  (implicit roles)\"\"\"\n        with self._rl:\n            return self._e.get_all_roles_by_domain(domain)\n\n    def get_implicit_users_for_resource(self, resource):\n        \"\"\"gets implicit user based on resource.\n        for example:\n            p, alice, data1, read\n            p, bob, data2, write\n            p, data2_admin, data2, read\n            p, data2_admin, data2, write\n            g, alice, data2_admin\n        get_implicit_users_for_resource(\"data2\") will return [[bob data2 write] [alice data2 read] [alice data2 write]]\n        get_implicit_users_for_resource(\"data1\") will return [[alice data1 read]]\n        Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_resource(resource)\n\n    def get_implicit_users_for_resource_by_domain(self, resource, domain):\n        \"\"\"get implicit user based on resource and domain.\n        Compared to GetImplicitUsersForResource, domain is supported\"\"\"\n        with self._rl:\n            return self._e.get_implicit_users_for_resource_by_domain(resource, domain)"
  }
}