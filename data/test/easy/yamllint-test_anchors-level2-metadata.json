{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_anchors",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/rules/test_anchors.py",
  "test_code": "# Copyright (C) 2023 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom tests.common import RuleTestCase\n\n\nclass AnchorsTestCase(RuleTestCase):\n    rule_id = 'anchors'\n\n    def test_disabled(self):\n        conf = 'anchors: disable'\n        self.check('---\\n'\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- &f_m {k: v}\\n'\n                   '- &f_s [1, 2]\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'\n                   '---\\n'  # redeclare anchors in a new document\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &y 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   '- &i 42\\n'\n                   '---\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'    # declared in a previous document\n                   '- *f_m\\n'  # never declared\n                   '- *f_m\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'  # declared after\n                   '- &f_s [1, 2]\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   '---\\n'\n                   'block mapping 1: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'block mapping 2: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &x 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf)\n\n    def test_forbid_undeclared_aliases(self):\n        conf = ('anchors:\\n'\n                '  forbid-undeclared-aliases: true\\n'\n                '  forbid-duplicated-anchors: false\\n'\n                '  forbid-unused-anchors: false\\n')\n        self.check('---\\n'\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- &f_m {k: v}\\n'\n                   '- &f_s [1, 2]\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'\n                   '---\\n'  # redeclare anchors in a new document\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &y 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   '- &i 42\\n'\n                   '---\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'    # declared in a previous document\n                   '- *f_m\\n'  # never declared\n                   '- *f_m\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'  # declared after\n                   '- &f_s [1, 2]\\n'\n                   '...\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   '---\\n'\n                   'block mapping 1: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'block mapping 2: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &x 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf,\n                   problem1=(9, 3),\n                   problem2=(10, 3),\n                   problem3=(11, 3),\n                   problem4=(12, 3),\n                   problem5=(13, 3),\n                   problem6=(25, 7),\n                   problem7=(28, 37))\n\n    def test_forbid_duplicated_anchors(self):\n        conf = ('anchors:\\n'\n                '  forbid-undeclared-aliases: false\\n'\n                '  forbid-duplicated-anchors: true\\n'\n                '  forbid-unused-anchors: false\\n')\n        self.check('---\\n'\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- &f_m {k: v}\\n'\n                   '- &f_s [1, 2]\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'\n                   '---\\n'  # redeclare anchors in a new document\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &y 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   '- &i 42\\n'\n                   '---\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'    # declared in a previous document\n                   '- *f_m\\n'  # never declared\n                   '- *f_m\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'  # declared after\n                   '- &f_s [1, 2]\\n'\n                   '...\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   '---\\n'\n                   'block mapping 1: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'block mapping 2: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &x 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf,\n                   problem1=(5, 3),\n                   problem2=(6, 3),\n                   problem3=(22, 18),\n                   problem4=(28, 20))\n\n    def test_forbid_unused_anchors(self):\n        conf = ('anchors:\\n'\n                '  forbid-undeclared-aliases: false\\n'\n                '  forbid-duplicated-anchors: false\\n'\n                '  forbid-unused-anchors: true\\n')\n\n        self.check('---\\n'\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- &f_m {k: v}\\n'\n                   '- &f_s [1, 2]\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'\n                   '---\\n'  # redeclare anchors in a new document\n                   '- &b true\\n'\n                   '- &i 42\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'\n                   '- *s\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &y 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   '- &i 42\\n'\n                   '---\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &b true\\n'\n                   '- &s hello\\n'\n                   '- *b\\n'\n                   '- *i\\n'    # declared in a previous document\n                   '- *f_m\\n'  # never declared\n                   '- *f_m\\n'\n                   '- *f_m\\n'\n                   '- *f_s\\n'  # declared after\n                   '- &f_s [1, 2]\\n'\n                   '...\\n'\n                   '---\\n'\n                   'block mapping: &b_m\\n'\n                   '  key: value\\n'\n                   '---\\n'\n                   'block mapping 1: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'block mapping 2: &b_m_bis\\n'\n                   '  key: value\\n'\n                   'extended:\\n'\n                   '  <<: *b_m\\n'\n                   '  foo: bar\\n'\n                   '---\\n'\n                   '{a: 1, &x b: 2, c: &x 3, *x : 4, e: *y}\\n'\n                   '...\\n', conf,\n                   problem1=(2, 3),\n                   problem2=(7, 3),\n                   problem3=(14, 3),\n                   problem4=(17, 16),\n                   problem5=(22, 18))\n",
  "GT_file_code": {
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem instance, representing a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was found, starting at 1.\n- column (int): The column number where the problem was found, starting at 1.\n- desc (str, optional): A human-readable description of the problem. Defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem. Defaults to None.\n\nAttributes:\n- line (int): Stores the line number of the problem.\n- column (int): Stores the column number of the problem.\n- desc (str): Stores the description of the problem.\n- rule (str): Stores the identifier of the rule that indicated the problem.\n- level (int or None): Initialized as None, intended to represent the severity level of the linting problem.\n\nThis class is used in conjunction with linting rules defined elsewhere in the code, allowing it to capture and represent specific issues detected during YAML linting.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem instance, representing a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was found, starting at 1.\n- column (int): The column number where the problem was found, starting at 1.\n- desc (str, optional): A human-readable description of the problem. Defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem. Defaults to None.\n\nAttributes:\n- line (int): Stores the line number of the problem.\n- column (int): Stores the column number of the problem.\n- desc (str): Stores the description of the problem.\n- rule (str): Stores the identifier of the rule that indicated the problem.\n- level (int or None): Initialized as None, intended to represent the severity level of the linting problem.\n\nThis class is used in conjunction with linting rules defined elsewhere in the code, allowing it to capture and represent specific issues detected during YAML linting.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if both instances represent the same lint problem (same line, column, and rule); False otherwise.\n\nThis method is important for determining if two LintProblem objects represent the same issue in YAML linting, allowing for proper aggregation and handling of unique linting problems.\"\"\"\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)",
        "docstring": "Checks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if both instances represent the same lint problem (same line, column, and rule); False otherwise.\n\nThis method is important for determining if two LintProblem objects represent the same issue in YAML linting, allowing for proper aggregation and handling of unique linting problems.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__lt__": {
        "code": "    def __lt__(self, other):\n        \"\"\"Determines the ordering of LintProblem instances based on their line and column attributes.\n\nThis method compares two LintProblem objects, `self` and `other`, to establish their relative order. It first compares the `line` attribute; if they are equal, it then compares the `column` attribute. The purpose of this method is to enable sorting of linting problems based on their position in the YAML document, making it easier to organize and display them.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if `self` is less than `other` in terms of line and column, otherwise False.\n\nThis method interacts with the `line` and `column` attributes of the LintProblem class, which are defined in its constructor. These attributes are crucial for identifying the location of linting issues in the source YAML.\"\"\"\n        return self.line < other.line or (self.line == other.line and self.column < other.column)",
        "docstring": "Determines the ordering of LintProblem instances based on their line and column attributes.\n\nThis method compares two LintProblem objects, `self` and `other`, to establish their relative order. It first compares the `line` attribute; if they are equal, it then compares the `column` attribute. The purpose of this method is to enable sorting of linting problems based on their position in the YAML document, making it easier to organize and display them.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if `self` is less than `other` in terms of line and column, otherwise False.\n\nThis method interacts with the `line` and `column` attributes of the LintProblem class, which are defined in its constructor. These attributes are crucial for identifying the location of linting issues in the source YAML.",
        "signature": "def __lt__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "_run": {
        "code": "def _run(buffer, conf, filepath):\n    \"\"\"Runs the YAML linting process on a provided buffer, checking for syntax errors and generating cosmetic problem reports.\n\nParameters:\n- buffer: A string, bytes, or a buffer-like object containing the YAML content to lint.\n- conf: A configuration object that defines linting rules and directives.\n- filepath: An optional string representing the file path of the YAML document (used for rule application context).\n\nReturns:\n- A generator yielding LintProblem instances, which encapsulate linting issues found in the YAML source.\n\nDependencies:\n- The function uses the `get_syntax_error` function to check for syntax errors and `get_cosmetic_problems` to identify stylistic issues.\n- If the content includes a disable-file directive on the first line, linting is skipped.\n- The function asserts that the input buffer supports indexing, as it requires access to specific lines of the input.\n\nSide Effects:\n- The function can yield a syntax error if present, immediately prioritizing it over cosmetic problems to prevent redundancy in output.\"\"\"\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
        "docstring": "Runs the YAML linting process on a provided buffer, checking for syntax errors and generating cosmetic problem reports.\n\nParameters:\n- buffer: A string, bytes, or a buffer-like object containing the YAML content to lint.\n- conf: A configuration object that defines linting rules and directives.\n- filepath: An optional string representing the file path of the YAML document (used for rule application context).\n\nReturns:\n- A generator yielding LintProblem instances, which encapsulate linting issues found in the YAML source.\n\nDependencies:\n- The function uses the `get_syntax_error` function to check for syntax errors and `get_cosmetic_problems` to identify stylistic issues.\n- If the content includes a disable-file directive on the first line, linting is skipped.\n- The function asserts that the input buffer supports indexing, as it requires access to specific lines of the input.\n\nSide Effects:\n- The function can yield a syntax error if present, immediately prioritizing it over cosmetic problems to prevent redundancy in output.",
        "signature": "def _run(buffer, conf, filepath):",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source and identifies potential problems using the yamllint configuration.\n\nThis function checks the provided YAML input for syntax errors and cosmetic issues according to the `yamllint` rules. It returns a generator that yields instances of `LintProblem`, which encapsulate the details of any detected problems.\n\nParameters:\n- input: A buffer, string, or stream to read from containing the YAML source.\n- conf: A configuration object specific to `yamllint`, which defines the linting rules and their statuses.\n- filepath: An optional string representing the file path of the input, used to check if the file is ignored by the configuration.\n\nReturns:\n- A generator of `LintProblem` objects representing any linting issues or syntax errors found in the input. If the file is ignored or if the input is of unsupported type, appropriate handling is performed.\n\nDependencies:\n- This function relies on the `_run` function to process the input and the `get_cosmetic_problems` function to identify linting issues. Additionally, it interacts with `io` for reading from stream inputs and uses `yaml` for parsing YAML content.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source and identifies potential problems using the yamllint configuration.\n\nThis function checks the provided YAML input for syntax errors and cosmetic issues according to the `yamllint` rules. It returns a generator that yields instances of `LintProblem`, which encapsulate the details of any detected problems.\n\nParameters:\n- input: A buffer, string, or stream to read from containing the YAML source.\n- conf: A configuration object specific to `yamllint`, which defines the linting rules and their statuses.\n- filepath: An optional string representing the file path of the input, used to check if the file is ignored by the configuration.\n\nReturns:\n- A generator of `LintProblem` objects representing any linting issues or syntax errors found in the input. If the file is ignored or if the input is of unsupported type, appropriate handling is performed.\n\nDependencies:\n- This function relies on the `_run` function to process the input and the `get_cosmetic_problems` function to identify linting issues. Additionally, it interacts with `io` for reading from stream inputs and uses `yaml` for parsing YAML content.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:_run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      },
      "yamllint/parser.py": {
        "Line.content": {
          "code": "    def content(self):\n        return self.buffer[self.start:self.end]",
          "docstring": "",
          "signature": "def content(self):",
          "type": "Method",
          "class_signature": "class Line:"
        },
        "line_generator": {
          "code": "def line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))",
          "docstring": "",
          "signature": "def line_generator(buffer):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/linter.py": {
        "get_cosmetic_problems": {
          "code": "def get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []",
          "docstring": "",
          "signature": "def get_cosmetic_problems(buffer, conf, filepath):",
          "type": "Function",
          "class_signature": null
        },
        "get_syntax_error": {
          "code": "def get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
          "docstring": "",
          "signature": "def get_syntax_error(buffer):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/linter.py:LintProblem:__init__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__lt__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__eq__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/rules/test_anchors.py:AnchorsTestCase:test_disabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {
                "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
              }
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        }
      }
    },
    "modified_testcases/rules/test_anchors.py:AnchorsTestCase:test_forbid_duplicated_anchors": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__lt__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_anchors.py:AnchorsTestCase:test_forbid_undeclared_aliases": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__lt__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_anchors.py:AnchorsTestCase:test_forbid_unused_anchors": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__lt__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_anchors/yamllint-test_anchors/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_anchors/yamllint-test_anchors/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_anchors\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__eq__\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 LintProblem.__lt__\n    \u2502   \u251c\u2500\u2500 _run\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and enforce rules around the usage of anchors and aliases in YAML documents, ensuring compliance with specified configurations. It provides capabilities to detect and optionally forbid issues such as undeclared aliases, duplicated anchors, and unused anchors, offering configurable settings for each rule. By automating the identification of these potential problems, the module helps developers maintain clean, consistent, and error-free YAML structures, reducing the risk of misconfigurations and improving the reliability of YAML-based workflows. This functionality is particularly useful for teams managing complex YAML files or adhering to strict style guidelines.\n\n## FILE 1: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source and identifies potential problems using the yamllint configuration.\n\nThis function checks the provided YAML input for syntax errors and cosmetic issues according to the `yamllint` rules. It returns a generator that yields instances of `LintProblem`, which encapsulate the details of any detected problems.\n\nParameters:\n- input: A buffer, string, or stream to read from containing the YAML source.\n- conf: A configuration object specific to `yamllint`, which defines the linting rules and their statuses.\n- filepath: An optional string representing the file path of the input, used to check if the file is ignored by the configuration.\n\nReturns:\n- A generator of `LintProblem` objects representing any linting issues or syntax errors found in the input. If the file is ignored or if the input is of unsupported type, appropriate handling is performed.\n\nDependencies:\n- This function relies on the `_run` function to process the input and the `get_cosmetic_problems` function to identify linting issues. Additionally, it interacts with `io` for reading from stream inputs and uses `yaml` for parsing YAML content.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem instance, representing a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was found, starting at 1.\n- column (int): The column number where the problem was found, starting at 1.\n- desc (str, optional): A human-readable description of the problem. Defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem. Defaults to None.\n\nAttributes:\n- line (int): Stores the line number of the problem.\n- column (int): Stores the column number of the problem.\n- desc (str): Stores the description of the problem.\n- rule (str): Stores the identifier of the rule that indicated the problem.\n- level (int or None): Initialized as None, intended to represent the severity level of the linting problem.\n\nThis class is used in conjunction with linting rules defined elsewhere in the code, allowing it to capture and represent specific issues detected during YAML linting.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__lt__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __lt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines the ordering of LintProblem instances based on their line and column attributes.\n\nThis method compares two LintProblem objects, `self` and `other`, to establish their relative order. It first compares the `line` attribute; if they are equal, it then compares the `column` attribute. The purpose of this method is to enable sorting of linting problems based on their position in the YAML document, making it easier to organize and display them.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if `self` is less than `other` in terms of line and column, otherwise False.\n\nThis method interacts with the `line` and `column` attributes of the LintProblem class, which are defined in its constructor. These attributes are crucial for identifying the location of linting issues in the source YAML.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__eq__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if both instances represent the same lint problem (same line, column, and rule); False otherwise.\n\nThis method is important for determining if two LintProblem objects represent the same issue in YAML linting, allowing for proper aggregation and handling of unique linting problems.\n\"\"\"\n```\n\n- FUNCTION NAME: _run\n  - SIGNATURE: def _run(buffer, conf, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nRuns the YAML linting process on a provided buffer, checking for syntax errors and generating cosmetic problem reports.\n\nParameters:\n- buffer: A string, bytes, or a buffer-like object containing the YAML content to lint.\n- conf: A configuration object that defines linting rules and directives.\n- filepath: An optional string representing the file path of the YAML document (used for rule application context).\n\nReturns:\n- A generator yielding LintProblem instances, which encapsulate linting issues found in the YAML source.\n\nDependencies:\n- The function uses the `get_syntax_error` function to check for syntax errors and `get_cosmetic_problems` to identify stylistic issues.\n- If the content includes a disable-file directive on the first line, linting is skipped.\n- The function asserts that the input buffer supports indexing, as it requires access to specific lines of the input.\n\nSide Effects:\n- The function can yield a syntax error if present, immediately prioritizing it over cosmetic problems to prevent redundancy in output.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n    - yamllint/parser.py:Line:content\n    - yamllint/parser.py:line_generator\n    - yamllint/linter.py:get_cosmetic_problems\n    - yamllint/linter.py:get_syntax_error\n\n## FILE 2: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}