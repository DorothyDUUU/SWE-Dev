{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_sk",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_sk.py",
  "test_code": "\n# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom unittest import TestCase\n\nfrom num2words import num2words\n\n\nclass Num2WordsSKTest(TestCase):\n    def test_cardinal(self):\n        self.assertEqual(num2words(100, lang='sk'), \"sto\")\n        self.assertEqual(num2words(101, lang='sk'), \"stojeden\")\n        self.assertEqual(num2words(110, lang='sk'), \"stodesa\u0165\")\n        self.assertEqual(num2words(115, lang='sk'), \"stop\u00e4tn\u00e1s\u0165\")\n        self.assertEqual(num2words(123, lang='sk'), \"stodvadsa\u0165tri\")\n        self.assertEqual(num2words(1000, lang='sk'), \"tis\u00edc\")\n        self.assertEqual(num2words(1001, lang='sk'), \"tis\u00edcjeden\")\n        self.assertEqual(num2words(2012, lang='sk'), \"dvetis\u00edcdvan\u00e1s\u0165\")\n        self.assertEqual(\n            num2words(10.02, lang='sk'),\n            \"desa\u0165 cel\u00fdch nula dva\"\n        )\n        self.assertEqual(\n            num2words(15.007, lang='sk'),\n            \"p\u00e4tn\u00e1s\u0165 cel\u00fdch nula nula sedem\"\n        )\n        self.assertEqual(\n            num2words(12519.85, lang='sk'),\n            \"dvan\u00e1s\u0165tis\u00edcp\u00e4\u0165stodev\u00e4tn\u00e1s\u0165 cel\u00fdch osemdesiatp\u00e4\u0165\"\n        )\n        self.assertEqual(\n            num2words(123.50, lang='sk'),\n            \"stodvadsa\u0165tri cel\u00fdch p\u00e4\u0165\"\n        )\n        self.assertEqual(\n            num2words(1234567890, lang='sk'),\n            \"miliarda dvestotridsa\u0165\u0161tyri mili\u00f3nov p\u00e4\u0165sto\u0161es\u0165desiat\"\n            \"sedemtis\u00edcosemstodev\u00e4\u0165desiat\"\n        )\n        self.assertEqual(\n            num2words(215461407892039002157189883901676, lang='sk'),\n            \"dvestop\u00e4tn\u00e1s\u0165 kvintili\u00f3nov \u0161tyristo\u0161es\u0165desiatjeden kvadrili\u00e1rd \"\n            \"\u0161tyristosedem kvadrili\u00f3nov osemstodev\u00e4\u0165desiatdva trili\u00e1rd \"\n            \"tridsa\u0165dev\u00e4\u0165 trili\u00f3nov dve biliardy stop\u00e4\u0165desiatsedem bili\u00f3nov \"\n            \"stoosemdesiatdev\u00e4\u0165 mili\u00e1rd osemstoosemdesiattri mili\u00f3nov \"\n            \"dev\u00e4\u0165stojedentis\u00edc\u0161es\u0165stosedemdesiat\u0161es\u0165\"\n        )\n        self.assertEqual(\n            num2words(719094234693663034822824384220291, lang='sk'),\n            \"sedemstodev\u00e4tn\u00e1s\u0165 kvintili\u00f3nov dev\u00e4\u0165desiat\u0161tyri kvadrili\u00e1rd \"\n            \"dvestotridsa\u0165\u0161tyri kvadrili\u00f3nov \u0161es\u0165stodev\u00e4\u0165desiattri trili\u00e1rd \"\n            \"\u0161es\u0165sto\u0161es\u0165desiattri trili\u00f3nov tridsa\u0165\u0161tyri bili\u00e1rd \"\n            \"osemstodvadsa\u0165dva bili\u00f3nov osemstodvadsa\u0165\u0161tyri mili\u00e1rd \"\n            \"tristoosemdesiat\u0161tyri mili\u00f3nov \"\n            \"dvestodvadsa\u0165tis\u00edcdvestodev\u00e4\u0165desiatjeden\"\n        )\n\n    def test_to_ordinal(self):\n        # @TODO: implement to_ordinal\n        with self.assertRaises(NotImplementedError):\n            num2words(1, lang='sk', to='ordinal')\n\n    def test_currency(self):\n        self.assertEqual(\n            num2words(10.0, lang='sk', to='currency', currency='EUR'),\n            \"desa\u0165 eur, nula centov\")\n        self.assertEqual(\n            num2words(1234.56, lang='sk', to='currency', currency='EUR'),\n            \"tis\u00edcdvestotridsa\u0165\u0161tyri eur, p\u00e4\u0165desiat\u0161es\u0165 centov\")\n        self.assertEqual(\n            num2words(101.11, lang='sk', to='currency', currency='EUR',\n                      separator=' a'),\n            \"stojeden eur a jeden\u00e1s\u0165 centov\")\n        self.assertEqual(\n            num2words(-12519.85, lang='sk', to='currency', cents=False),\n            \"m\u00ednus dvan\u00e1s\u0165tis\u00edcp\u00e4\u0165stodev\u00e4tn\u00e1s\u0165 eur, 85 centov\"\n        )\n        self.assertEqual(\n            num2words(19.50, lang='sk', to='currency', cents=False),\n            \"dev\u00e4tn\u00e1s\u0165 eur, 50 centov\"\n        )\n",
  "GT_file_code": {
    "num2words/__init__.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom . import (lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE,\n               lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN,\n               lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR,\n               lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR,\n               lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID,\n               lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT,\n               lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR,\n               lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE,\n               lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI)\n\nCONVERTER_CLASSES = {\n    'am': lang_AM.Num2Word_AM(),\n    'ar': lang_AR.Num2Word_AR(),\n    'az': lang_AZ.Num2Word_AZ(),\n    'be': lang_BE.Num2Word_BE(),\n    'bn': lang_BN.Num2Word_BN(),\n    'ca': lang_CA.Num2Word_CA(),\n    'ce': lang_CE.Num2Word_CE(),\n    'cy': lang_CY.Num2Word_CY(),\n    'cz': lang_CZ.Num2Word_CZ(),\n    'en': lang_EN.Num2Word_EN(),\n    'en_IN': lang_EN_IN.Num2Word_EN_IN(),\n    'en_NG': lang_EN_NG.Num2Word_EN_NG(),\n    'fa': lang_FA.Num2Word_FA(),\n    'fr': lang_FR.Num2Word_FR(),\n    'fr_CH': lang_FR_CH.Num2Word_FR_CH(),\n    'fr_BE': lang_FR_BE.Num2Word_FR_BE(),\n    'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(),\n    'de': lang_DE.Num2Word_DE(),\n    'fi': lang_FI.Num2Word_FI(),\n    'eo': lang_EO.Num2Word_EO(),\n    'es': lang_ES.Num2Word_ES(),\n    'es_CO': lang_ES_CO.Num2Word_ES_CO(),\n    'es_CR': lang_ES_CR.Num2Word_ES_CR(),\n    'es_GT': lang_ES_GT.Num2Word_ES_GT(),\n    'es_NI': lang_ES_NI.Num2Word_ES_NI(),\n    'es_VE': lang_ES_VE.Num2Word_ES_VE(),\n    'id': lang_ID.Num2Word_ID(),\n    'ja': lang_JA.Num2Word_JA(),\n    'kn': lang_KN.Num2Word_KN(),\n    'ko': lang_KO.Num2Word_KO(),\n    'kz': lang_KZ.Num2Word_KZ(),\n    'lt': lang_LT.Num2Word_LT(),\n    'lv': lang_LV.Num2Word_LV(),\n    'pl': lang_PL.Num2Word_PL(),\n    'ro': lang_RO.Num2Word_RO(),\n    'ru': lang_RU.Num2Word_RU(),\n    'sk': lang_SK.Num2Word_SK(),\n    'sl': lang_SL.Num2Word_SL(),\n    'sr': lang_SR.Num2Word_SR(),\n    'sv': lang_SV.Num2Word_SV(),\n    'no': lang_NO.Num2Word_NO(),\n    'dk': lang_DK.Num2Word_DK(),\n    'pt': lang_PT.Num2Word_PT(),\n    'pt_BR': lang_PT_BR.Num2Word_PT_BR(),\n    'he': lang_HE.Num2Word_HE(),\n    'it': lang_IT.Num2Word_IT(),\n    'vi': lang_VI.Num2Word_VI(),\n    'tg': lang_TG.Num2Word_TG(),\n    'th': lang_TH.Num2Word_TH(),\n    'tr': lang_TR.Num2Word_TR(),\n    'nl': lang_NL.Num2Word_NL(),\n    'uk': lang_UK.Num2Word_UK(),\n    'te': lang_TE.Num2Word_TE(),\n    'tet': lang_TET.Num2Word_TET(),\n    'hu': lang_HU.Num2Word_HU(),\n    'is': lang_IS.Num2Word_IS(),\n}\n\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']\n\n\ndef num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    # We try the full language first\n    if lang not in CONVERTER_CLASSES:\n        # ... and then try only the first 2 letters\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n\n    # backwards compatible\n    if ordinal:\n        to = 'ordinal'\n\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)\n"
  },
  "GT_src_dict": {
    "num2words/__init__.py": {
      "num2words": {
        "code": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    \"\"\"Convert a given number into words for different languages and formats (cardinal, ordinal, etc.).\n\nParameters:\n- number (int, float, str): The number to be converted into words. Can be a string that represents a number.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., first, second). Defaults to False.\n- lang (str): The language code for conversion. Should be a supported language code (e.g., 'en', 'fr'). Defaults to 'en'.\n- to (str): Specifies the type of conversion. Must be one of the allowed types in CONVERTES_TYPES ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The textual representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not recognized.\n\nDependencies:\nThis function uses the CONVERTER_CLASSES dictionary to map language codes to their respective number-to-word converter classes. Also, it references the CONVERTES_TYPES list to validate allowed conversion types, ensuring compatibility with the converters defined in the imported language modules.\"\"\"\n    if lang not in CONVERTER_CLASSES:\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n    if ordinal:\n        to = 'ordinal'\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)",
        "docstring": "Convert a given number into words for different languages and formats (cardinal, ordinal, etc.).\n\nParameters:\n- number (int, float, str): The number to be converted into words. Can be a string that represents a number.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., first, second). Defaults to False.\n- lang (str): The language code for conversion. Should be a supported language code (e.g., 'en', 'fr'). Defaults to 'en'.\n- to (str): Specifies the type of conversion. Must be one of the allowed types in CONVERTES_TYPES ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The textual representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not recognized.\n\nDependencies:\nThis function uses the CONVERTER_CLASSES dictionary to map language codes to their respective number-to-word converter classes. Also, it references the CONVERTES_TYPES list to validate allowed conversion types, ensuring compatibility with the converters defined in the imported language modules.",
        "signature": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "num2words/__init__.py:num2words": {
      "num2words/lang_SK.py": {
        "Num2Word_SK.to_cardinal": {
          "code": "    def to_cardinal(self, number):\n        n = str(number).replace(',', '.')\n        if '.' in n:\n            left, right = n.split('.')\n            leading_zero_count = len(right) - len(right.lstrip('0'))\n            decimal_part = ((ZERO[0] + ' ') * leading_zero_count +\n                            self._int2word(int(right)))\n            return u'%s %s %s' % (\n                self._int2word(int(left)),\n                self.pointword,\n                decimal_part\n            )\n        else:\n            return self._int2word(int(n))",
          "docstring": "",
          "signature": "def to_cardinal(self, number):",
          "type": "Method",
          "class_signature": "class Num2Word_SK(Num2Word_Base):"
        },
        "Num2Word_SK.to_ordinal": {
          "code": "    def to_ordinal(self, value):\n        raise NotImplementedError()",
          "docstring": "",
          "signature": "def to_ordinal(self, value):",
          "type": "Method",
          "class_signature": "class Num2Word_SK(Num2Word_Base):"
        }
      },
      "num2words/base.py": {
        "Num2Word_Base.to_currency": {
          "code": "    def to_currency(self, val, currency='EUR', cents=True, separator=',',\n                    adjective=False):\n        \"\"\"\n        Args:\n            val: Numeric value\n            currency (str): Currency code\n            cents (bool): Verbose cents\n            separator (str): Cent separator\n            adjective (bool): Prefix currency name with adjective\n        Returns:\n            str: Formatted string\n\n        \"\"\"\n        left, right, is_negative = parse_currency_parts(val)\n\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n\n        except KeyError:\n            raise NotImplementedError(\n                'Currency code \"%s\" not implemented for \"%s\"' %\n                (currency, self.__class__.__name__))\n\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n\n        minus_str = \"%s \" % self.negword.strip() if is_negative else \"\"\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) \\\n            if cents else self._cents_terse(right, currency)\n\n        return u'%s%s %s%s %s %s' % (\n            minus_str,\n            money_str,\n            self.pluralize(left, cr1),\n            separator,\n            cents_str,\n            self.pluralize(right, cr2)\n        )",
          "docstring": "Args:\n    val: Numeric value\n    currency (str): Currency code\n    cents (bool): Verbose cents\n    separator (str): Cent separator\n    adjective (bool): Prefix currency name with adjective\nReturns:\n    str: Formatted string",
          "signature": "def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):",
          "type": "Method",
          "class_signature": "class Num2Word_Base(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: num2words-test_sk\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 num2words\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for converting numerical values into their Slovak language word representations, including support for cardinal numbers, floating-point values, and currency formatting. It enables users to generate grammatically correct Slovak textual expressions for integers, decimals, and monetary amounts, addressing the need for localized number-to-word translations in applications requiring accurate linguistic formatting. By offering a seamless integration for handling Slovak numeral formats, the module simplifies development tasks related to generating human-readable outputs for numerical data in the Slovak language, improving user experience and localization in software systems.\n\n## FILE 1: num2words/__init__.py\n\n- FUNCTION NAME: num2words\n  - SIGNATURE: def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a given number into words for different languages and formats (cardinal, ordinal, etc.).\n\nParameters:\n- number (int, float, str): The number to be converted into words. Can be a string that represents a number.\n- ordinal (bool): If True, converts the number to its ordinal form (e.g., first, second). Defaults to False.\n- lang (str): The language code for conversion. Should be a supported language code (e.g., 'en', 'fr'). Defaults to 'en'.\n- to (str): Specifies the type of conversion. Must be one of the allowed types in CONVERTES_TYPES ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments specific to the language converter.\n\nReturns:\n- str: The textual representation of the number in the specified language and format.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not recognized.\n\nDependencies:\nThis function uses the CONVERTER_CLASSES dictionary to map language codes to their respective number-to-word converter classes. Also, it references the CONVERTES_TYPES list to validate allowed conversion types, ensuring compatibility with the converters defined in the imported language modules.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - num2words/lang_SK.py:Num2Word_SK:to_cardinal\n    - num2words/lang_SK.py:Num2Word_SK:to_ordinal\n    - num2words/base.py:Num2Word_Base:to_currency\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/__init__.py": "from __future__ import unicode_literals\nfrom . import lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE, lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN, lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR, lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR, lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID, lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT, lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR, lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE, lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI\nCONVERTER_CLASSES = {'am': lang_AM.Num2Word_AM(), 'ar': lang_AR.Num2Word_AR(), 'az': lang_AZ.Num2Word_AZ(), 'be': lang_BE.Num2Word_BE(), 'bn': lang_BN.Num2Word_BN(), 'ca': lang_CA.Num2Word_CA(), 'ce': lang_CE.Num2Word_CE(), 'cy': lang_CY.Num2Word_CY(), 'cz': lang_CZ.Num2Word_CZ(), 'en': lang_EN.Num2Word_EN(), 'en_IN': lang_EN_IN.Num2Word_EN_IN(), 'en_NG': lang_EN_NG.Num2Word_EN_NG(), 'fa': lang_FA.Num2Word_FA(), 'fr': lang_FR.Num2Word_FR(), 'fr_CH': lang_FR_CH.Num2Word_FR_CH(), 'fr_BE': lang_FR_BE.Num2Word_FR_BE(), 'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(), 'de': lang_DE.Num2Word_DE(), 'fi': lang_FI.Num2Word_FI(), 'eo': lang_EO.Num2Word_EO(), 'es': lang_ES.Num2Word_ES(), 'es_CO': lang_ES_CO.Num2Word_ES_CO(), 'es_CR': lang_ES_CR.Num2Word_ES_CR(), 'es_GT': lang_ES_GT.Num2Word_ES_GT(), 'es_NI': lang_ES_NI.Num2Word_ES_NI(), 'es_VE': lang_ES_VE.Num2Word_ES_VE(), 'id': lang_ID.Num2Word_ID(), 'ja': lang_JA.Num2Word_JA(), 'kn': lang_KN.Num2Word_KN(), 'ko': lang_KO.Num2Word_KO(), 'kz': lang_KZ.Num2Word_KZ(), 'lt': lang_LT.Num2Word_LT(), 'lv': lang_LV.Num2Word_LV(), 'pl': lang_PL.Num2Word_PL(), 'ro': lang_RO.Num2Word_RO(), 'ru': lang_RU.Num2Word_RU(), 'sk': lang_SK.Num2Word_SK(), 'sl': lang_SL.Num2Word_SL(), 'sr': lang_SR.Num2Word_SR(), 'sv': lang_SV.Num2Word_SV(), 'no': lang_NO.Num2Word_NO(), 'dk': lang_DK.Num2Word_DK(), 'pt': lang_PT.Num2Word_PT(), 'pt_BR': lang_PT_BR.Num2Word_PT_BR(), 'he': lang_HE.Num2Word_HE(), 'it': lang_IT.Num2Word_IT(), 'vi': lang_VI.Num2Word_VI(), 'tg': lang_TG.Num2Word_TG(), 'th': lang_TH.Num2Word_TH(), 'tr': lang_TR.Num2Word_TR(), 'nl': lang_NL.Num2Word_NL(), 'uk': lang_UK.Num2Word_UK(), 'te': lang_TE.Num2Word_TE(), 'tet': lang_TET.Num2Word_TET(), 'hu': lang_HU.Num2Word_HU(), 'is': lang_IS.Num2Word_IS()}\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']"
  },
  "call_tree": {
    "modified_testcases/test_sk.py:Num2WordsSKTest:test_cardinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_SK.py:Num2Word_SK:to_cardinal": {
          "num2words/lang_SK.py:Num2Word_SK:_int2word": {
            "num2words/utils.py:splitbyx": {},
            "num2words/utils.py:get_digits": {},
            "num2words/lang_SK.py:Num2Word_SK:pluralize": {}
          }
        }
      }
    },
    "modified_testcases/test_sk.py:Num2WordsSKTest:test_currency": {
      "num2words/__init__.py:num2words": {
        "num2words/base.py:Num2Word_Base:to_currency": {
          "num2words/currency.py:parse_currency_parts": {},
          "num2words/base.py:Num2Word_Base:_money_verbose": {
            "num2words/lang_SK.py:Num2Word_SK:to_cardinal": {
              "num2words/lang_SK.py:Num2Word_SK:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {},
                "num2words/lang_SK.py:Num2Word_SK:pluralize": {}
              }
            }
          },
          "num2words/base.py:Num2Word_Base:_cents_verbose": {
            "num2words/lang_SK.py:Num2Word_SK:to_cardinal": {
              "num2words/lang_SK.py:Num2Word_SK:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {}
              }
            }
          },
          "num2words/lang_SK.py:Num2Word_SK:pluralize": {},
          "num2words/base.py:Num2Word_Base:_cents_terse": {}
        }
      }
    },
    "modified_testcases/test_sk.py:Num2WordsSKTest:test_to_ordinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_SK.py:Num2Word_SK:to_ordinal": {}
      }
    }
  }
}