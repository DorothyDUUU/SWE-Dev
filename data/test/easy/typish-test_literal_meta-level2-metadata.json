{
  "dir_path": "/app/typish",
  "package_name": "typish",
  "sample_name": "typish-test_literal_meta",
  "src_dir": "test_resources/",
  "test_dir": "tests/",
  "test_file": "tests/classes/test_literal_meta.py",
  "test_code": "from unittest import TestCase\n\nfrom typish import LiteralAlias\n\n\nclass TestLiteralMeta(TestCase):\n    def test_from_literal(self):\n\n        class LiteralMock:\n            __args__ = (42,)\n\n        alias = LiteralAlias.from_literal(LiteralMock)\n\n        self.assertTrue(isinstance(42, alias))\n\n    def test_str(self):\n        self.assertEqual('Literal[42]', str(LiteralAlias[42]))\n\n    def test_multiple_args(self):\n        self.assertTrue(isinstance(1, LiteralAlias[1, 2]))\n        self.assertTrue(isinstance(2, LiteralAlias[1, 2]))\n        self.assertTrue(isinstance(1, LiteralAlias[(1, 2)]))\n        self.assertTrue(isinstance(2, LiteralAlias[(1, 2)]))\n        self.assertTrue(isinstance(1, LiteralAlias[((1, 2),)]))\n        self.assertTrue(isinstance(2, LiteralAlias[((1, 2),)]))\n",
  "GT_file_code": {
    "typish/classes/_subscriptable_type.py": "class _SubscribedType(type):\n    \"\"\"\n    This class is a placeholder to let the IDE know the attributes of the\n    returned type after a __getitem__.\n    \"\"\"\n    __origin__ = None\n    __args__ = None\n\n\nclass SubscriptableType(type):\n    \"\"\"\n    This metaclass will allow a type to become subscriptable.\n\n    >>> class SomeType(metaclass=SubscriptableType):\n    ...     pass\n    >>> SomeTypeSub = SomeType['some args']\n    >>> SomeTypeSub.__args__\n    'some args'\n    >>> SomeTypeSub.__origin__.__name__\n    'SomeType'\n    \"\"\"\n    def __init_subclass__(mcs, **kwargs):\n        mcs._hash = None\n        mcs.__args__ = None\n        mcs.__origin__ = None\n\n    def __getitem__(self, item) -> _SubscribedType:\n        body = {\n            **self.__dict__,\n            '__args__': item,\n            '__origin__': self,\n        }\n        bases = self, *self.__bases__\n        result = type(self.__name__, bases, body)\n        if hasattr(result, '_after_subscription'):\n            # TODO check if _after_subscription is static\n            result._after_subscription(item)\n        return result\n\n    def __eq__(self, other):\n        self_args = getattr(self, '__args__', None)\n        self_origin = getattr(self, '__origin__', None)\n        other_args = getattr(other, '__args__', None)\n        other_origin = getattr(other, '__origin__', None)\n        return self_args == other_args and self_origin == other_origin\n\n    def __hash__(self):\n        if not getattr(self, '_hash', None):\n            self._hash = hash('{}{}'.format(self.__origin__, self.__args__))\n        return self._hash\n",
    "typish/classes/_literal.py": "import typing\n\nfrom typish.classes._subscriptable_type import SubscriptableType\n\n\ndef is_literal_type(cls: typing.Any) -> bool:\n    \"\"\"\n    Return whether cls is a Literal type.\n    :param cls: the type that is to be checked.\n    :return: True if cls is a Literal type.\n    \"\"\"\n    from typish.functions._get_simple_name import get_simple_name\n\n    return get_simple_name(cls) == 'Literal'\n\n\nclass _LiteralMeta(SubscriptableType):\n    \"\"\"\n    A Metaclass that exists to serve Literal and alter the __args__ attribute.\n    \"\"\"\n    def __getattribute__(cls, item):\n        \"\"\"\n        This method makes sure that __args__ is a tuple, like with\n        typing.Literal.\n        :param item: the name of the attribute that is obtained.\n        :return: the attribute.\n        \"\"\"\n        if item == '__args__':\n            try:\n                result = SubscriptableType.__getattribute__(cls, item)\n                if (result and isinstance(result, tuple)\n                        and isinstance(result[0], tuple)):\n                    result = result[0]  # result was a tuple in a tuple.\n                if result and not isinstance(result, tuple):\n                    result = (result,)\n            except AttributeError:  # pragma: no cover\n                # In case of Python 3.5\n                result = tuple()\n        elif item in ('__origin__', '__name__', '_name'):\n            result = 'Literal'\n        else:\n            result = SubscriptableType.__getattribute__(cls, item)\n        return result\n\n    def __instancecheck__(self, instance):\n        return self.__args__ and instance in self.__args__\n\n    def __str__(self):\n        args = ', '.join(str(arg) for arg in self.__args__)\n        return '{}[{}]'.format(self.__name__, args)\n\n    def __subclasscheck__(self, subclass: typing.Any) -> bool:\n        return is_literal_type(subclass)\n\n\nclass LiteralAlias(type, metaclass=_LiteralMeta):\n    \"\"\"\n    This is a backwards compatible variant of typing.Literal (Python 3.8+).\n    \"\"\"\n    @staticmethod\n    def from_literal(literal: typing.Any) -> typing.Type['LiteralAlias']:\n        \"\"\"\n        Create a LiteralAlias from the given typing.Literal.\n        :param literal: the typing.Literal type.\n        :return: a LiteralAlias type.\n        \"\"\"\n        from typish.functions._get_args import get_args\n\n        args = get_args(literal)\n        return LiteralAlias[args] if args else LiteralAlias\n\n\n# If Literal is available (Python 3.8+), then return that type instead.\nLiteral = getattr(typing, 'Literal', LiteralAlias)\n",
    "typish/functions/_get_args.py": "import typing\n\n\ndef get_args(t: type) -> typing.Tuple[type, ...]:\n    \"\"\"\n    Get the arguments from a collection type (e.g. ``typing.List[int]``) as a\n    ``tuple``.\n    :param t: the collection type.\n    :return: a ``tuple`` containing types.\n    \"\"\"\n    args_ = getattr(t, '__args__', tuple()) or tuple()\n    args = tuple([attr for attr in args_\n                  if type(attr) != typing.TypeVar])\n    return args\n"
  },
  "GT_src_dict": {
    "typish/classes/_subscriptable_type.py": {
      "SubscriptableType.__getitem__": {
        "code": "    def __getitem__(self, item) -> _SubscribedType:\n        \"\"\"Returns a new subtype of the class that is subscripted with the given item.\n\nParameters:\n- item: The subscript value, which can be any type passed during the subscription operation.\n\nReturns:\n- A new type that inherits from the original class, containing the original class's attributes along with `__args__` set to the provided item and `__origin__` referencing the original class.\n\nIf the resulting type has an `_after_subscription` method, that method is called with the item as an argument, allowing for any additional processing after the subscription. \n\nThis method relies on class attributes such as `__name__`, `__bases__`, and `__dict__` to create the new type dynamically, enabling the functionality of subscriptable classes defined with the `SubscriptableType` metaclass.\"\"\"\n        body = {**self.__dict__, '__args__': item, '__origin__': self}\n        bases = (self, *self.__bases__)\n        result = type(self.__name__, bases, body)\n        if hasattr(result, '_after_subscription'):\n            result._after_subscription(item)\n        return result",
        "docstring": "Returns a new subtype of the class that is subscripted with the given item.\n\nParameters:\n- item: The subscript value, which can be any type passed during the subscription operation.\n\nReturns:\n- A new type that inherits from the original class, containing the original class's attributes along with `__args__` set to the provided item and `__origin__` referencing the original class.\n\nIf the resulting type has an `_after_subscription` method, that method is called with the item as an argument, allowing for any additional processing after the subscription. \n\nThis method relies on class attributes such as `__name__`, `__bases__`, and `__dict__` to create the new type dynamically, enabling the functionality of subscriptable classes defined with the `SubscriptableType` metaclass.",
        "signature": "def __getitem__(self, item) -> _SubscribedType:",
        "type": "Method",
        "class_signature": "class SubscriptableType(type):"
      }
    },
    "typish/classes/_literal.py": {
      "_LiteralMeta.__getattribute__": {
        "code": "    def __getattribute__(cls, item):\n        \"\"\"This method is an overridden implementation of __getattribute__ in the _LiteralMeta metaclass, ensuring that the __args__ attribute behaves like the __args__ attribute of typing.Literal. It checks if the requested attribute is '__args__', and if so, retrieves it from the superclass (SubscriptableType), ensuring it is returned as a tuple. If the result is a nested tuple, it simplifies it. If the attribute is '__origin__', '__name__', or '_name', it returns the string 'Literal'. For all other attributes, it uses the superclass implementation. \n\nParameters:\n- cls: The class (of type _LiteralMeta) the method is called on.\n- item: The name of the attribute being accessed.\n\nReturns:\n- The value of the requested attribute. If '__args__', it is guaranteed to be a tuple, ensuring compatibility with the expected behavior of Literal types.\n\nDependencies:\n- Utilizes SubscriptableType's __getattribute__ to fetch attributes, ensuring compatibility with existing subscriptable types.\"\"\"\n        '\\n        This method makes sure that __args__ is a tuple, like with\\n        typing.Literal.\\n        :param item: the name of the attribute that is obtained.\\n        :return: the attribute.\\n        '\n        if item == '__args__':\n            try:\n                result = SubscriptableType.__getattribute__(cls, item)\n                if result and isinstance(result, tuple) and isinstance(result[0], tuple):\n                    result = result[0]\n                if result and (not isinstance(result, tuple)):\n                    result = (result,)\n            except AttributeError:\n                result = tuple()\n        elif item in ('__origin__', '__name__', '_name'):\n            result = 'Literal'\n        else:\n            result = SubscriptableType.__getattribute__(cls, item)\n        return result",
        "docstring": "This method is an overridden implementation of __getattribute__ in the _LiteralMeta metaclass, ensuring that the __args__ attribute behaves like the __args__ attribute of typing.Literal. It checks if the requested attribute is '__args__', and if so, retrieves it from the superclass (SubscriptableType), ensuring it is returned as a tuple. If the result is a nested tuple, it simplifies it. If the attribute is '__origin__', '__name__', or '_name', it returns the string 'Literal'. For all other attributes, it uses the superclass implementation. \n\nParameters:\n- cls: The class (of type _LiteralMeta) the method is called on.\n- item: The name of the attribute being accessed.\n\nReturns:\n- The value of the requested attribute. If '__args__', it is guaranteed to be a tuple, ensuring compatibility with the expected behavior of Literal types.\n\nDependencies:\n- Utilizes SubscriptableType's __getattribute__ to fetch attributes, ensuring compatibility with existing subscriptable types.",
        "signature": "def __getattribute__(cls, item):",
        "type": "Method",
        "class_signature": "class _LiteralMeta(SubscriptableType):"
      },
      "_LiteralMeta.__instancecheck__": {
        "code": "    def __instancecheck__(self, instance):\n        \"\"\"Checks if the given instance is a member of the Literal type's defined arguments (__args__).\n\n:param instance: The object to check against the defined literal values.\n:return: True if the instance is among the values defined in __args__; otherwise, False.\n\nThis method leverages the __args__ attribute, which is a tuple containing the possible values of the LiteralAlias.\"\"\"\n        return self.__args__ and instance in self.__args__",
        "docstring": "Checks if the given instance is a member of the Literal type's defined arguments (__args__).\n\n:param instance: The object to check against the defined literal values.\n:return: True if the instance is among the values defined in __args__; otherwise, False.\n\nThis method leverages the __args__ attribute, which is a tuple containing the possible values of the LiteralAlias.",
        "signature": "def __instancecheck__(self, instance):",
        "type": "Method",
        "class_signature": "class _LiteralMeta(SubscriptableType):"
      },
      "_LiteralMeta.__str__": {
        "code": "    def __str__(self):\n        \"\"\"Returns a string representation of the _LiteralMeta instance, formatted as 'Literal[arg1, arg2, ...]', where 'arg1', 'arg2', etc. are the elements of the __args__ attribute. The method constructs the string by joining each argument (converted to a string) with commas. The __args__ attribute is expected to be a tuple of literal values associated with the instance, defined by the Metaclass functionality derived from SubscriptableType. The method interacts with the __name__ attribute, which is set to 'Literal', ensuring that the string representation reflects the class name and its arguments correctly.\"\"\"\n        args = ', '.join((str(arg) for arg in self.__args__))\n        return '{}[{}]'.format(self.__name__, args)",
        "docstring": "Returns a string representation of the _LiteralMeta instance, formatted as 'Literal[arg1, arg2, ...]', where 'arg1', 'arg2', etc. are the elements of the __args__ attribute. The method constructs the string by joining each argument (converted to a string) with commas. The __args__ attribute is expected to be a tuple of literal values associated with the instance, defined by the Metaclass functionality derived from SubscriptableType. The method interacts with the __name__ attribute, which is set to 'Literal', ensuring that the string representation reflects the class name and its arguments correctly.",
        "signature": "def __str__(self):",
        "type": "Method",
        "class_signature": "class _LiteralMeta(SubscriptableType):"
      },
      "LiteralAlias.from_literal": {
        "code": "    def from_literal(literal: typing.Any) -> typing.Type['LiteralAlias']:\n        \"\"\"Create a `LiteralAlias` type from a given `typing.Literal`.\n\nThis static method extracts the type arguments from the provided `literal`, which should be of type `typing.Literal`. If arguments are found, it returns a `LiteralAlias` typed with those arguments; otherwise, it returns a base `LiteralAlias`. The method relies on the `get_args` function from `typish.functions._get_args` to retrieve the arguments from the `literal`.\n\nParameters:\n- `literal` (typing.Any): The `typing.Literal` type from which to create a `LiteralAlias`.\n\nReturns:\n- typing.Type['LiteralAlias']: A `LiteralAlias` type corresponding to the provided literal or the base `LiteralAlias` if no arguments are found.\n\nDependencies:\n- The method depends on the `get_args` function from `typish.functions._get_args` to extract the arguments from the `literal`.\"\"\"\n        '\\n        Create a LiteralAlias from the given typing.Literal.\\n        :param literal: the typing.Literal type.\\n        :return: a LiteralAlias type.\\n        '\n        from typish.functions._get_args import get_args\n        args = get_args(literal)\n        return LiteralAlias[args] if args else LiteralAlias",
        "docstring": "Create a `LiteralAlias` type from a given `typing.Literal`.\n\nThis static method extracts the type arguments from the provided `literal`, which should be of type `typing.Literal`. If arguments are found, it returns a `LiteralAlias` typed with those arguments; otherwise, it returns a base `LiteralAlias`. The method relies on the `get_args` function from `typish.functions._get_args` to retrieve the arguments from the `literal`.\n\nParameters:\n- `literal` (typing.Any): The `typing.Literal` type from which to create a `LiteralAlias`.\n\nReturns:\n- typing.Type['LiteralAlias']: A `LiteralAlias` type corresponding to the provided literal or the base `LiteralAlias` if no arguments are found.\n\nDependencies:\n- The method depends on the `get_args` function from `typish.functions._get_args` to extract the arguments from the `literal`.",
        "signature": "def from_literal(literal: typing.Any) -> typing.Type['LiteralAlias']:",
        "type": "Method",
        "class_signature": "class LiteralAlias(type, metaclass=_LiteralMeta):"
      }
    },
    "typish/functions/_get_args.py": {
      "get_args": {
        "code": "def get_args(t: type) -> typing.Tuple[type, ...]:\n    \"\"\"Retrieve the arguments from a generic collection type (e.g., ``typing.List[int]``) as a tuple of types.\n\nParameters:\n- t (type): The collection type whose arguments are to be extracted.\n\nReturns:\n- typing.Tuple[type, ...]: A tuple containing the types of the arguments. If no arguments are found or if they are of type ``typing.TypeVar``, an empty tuple is returned.\n\nNotes:\n- The function uses `getattr` to access the `__args__` attribute of the type `t`, which holds the parameters of the generic type. It filters out any `TypeVar` instances to return only specific types.\"\"\"\n    '\\n    Get the arguments from a collection type (e.g. ``typing.List[int]``) as a\\n    ``tuple``.\\n    :param t: the collection type.\\n    :return: a ``tuple`` containing types.\\n    '\n    args_ = getattr(t, '__args__', tuple()) or tuple()\n    args = tuple([attr for attr in args_ if type(attr) != typing.TypeVar])\n    return args",
        "docstring": "Retrieve the arguments from a generic collection type (e.g., ``typing.List[int]``) as a tuple of types.\n\nParameters:\n- t (type): The collection type whose arguments are to be extracted.\n\nReturns:\n- typing.Tuple[type, ...]: A tuple containing the types of the arguments. If no arguments are found or if they are of type ``typing.TypeVar``, an empty tuple is returned.\n\nNotes:\n- The function uses `getattr` to access the `__args__` attribute of the type `t`, which holds the parameters of the generic type. It filters out any `TypeVar` instances to return only specific types.",
        "signature": "def get_args(t: type) -> typing.Tuple[type, ...]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: typish-test_literal_meta\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 typish/\n    \u251c\u2500\u2500 classes/\n    \u2502   \u251c\u2500\u2500 _literal.py\n    \u2502   \u2502   \u251c\u2500\u2500 LiteralAlias.from_literal\n    \u2502   \u2502   \u251c\u2500\u2500 _LiteralMeta.__getattribute__\n    \u2502   \u2502   \u251c\u2500\u2500 _LiteralMeta.__instancecheck__\n    \u2502   \u2502   \u2514\u2500\u2500 _LiteralMeta.__str__\n    \u2502   \u2514\u2500\u2500 _subscriptable_type.py\n    \u2502       \u2514\u2500\u2500 SubscriptableType.__getitem__\n    \u2514\u2500\u2500 functions/\n        \u2514\u2500\u2500 _get_args.py\n            \u2514\u2500\u2500 get_args\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and facilitate work with type aliases that represent specific literal values in Python, enhancing type safety and clarity in codebases. It provides functionality to dynamically create and validate instances of literal type aliases, supporting both individual and composite values (e.g., single values, tuples). By abstracting the complexity of managing literal type constraints, the module simplifies type-checking workflows for developers, ensuring stricter adherence to expected input or output types. This ultimately helps reduce errors in systems that rely heavily on precise data definitions and type integrity.\n\n## FILE 1: typish/classes/_subscriptable_type.py\n\n- CLASS METHOD: SubscriptableType.__getitem__\n  - CLASS SIGNATURE: class SubscriptableType(type):\n  - SIGNATURE: def __getitem__(self, item) -> _SubscribedType:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a new subtype of the class that is subscripted with the given item.\n\nParameters:\n- item: The subscript value, which can be any type passed during the subscription operation.\n\nReturns:\n- A new type that inherits from the original class, containing the original class's attributes along with `__args__` set to the provided item and `__origin__` referencing the original class.\n\nIf the resulting type has an `_after_subscription` method, that method is called with the item as an argument, allowing for any additional processing after the subscription. \n\nThis method relies on class attributes such as `__name__`, `__bases__`, and `__dict__` to create the new type dynamically, enabling the functionality of subscriptable classes defined with the `SubscriptableType` metaclass.\n\"\"\"\n```\n\n## FILE 2: typish/classes/_literal.py\n\n- CLASS METHOD: LiteralAlias.from_literal\n  - CLASS SIGNATURE: class LiteralAlias(type, metaclass=_LiteralMeta):\n  - SIGNATURE: def from_literal(literal: typing.Any) -> typing.Type['LiteralAlias']:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a `LiteralAlias` type from a given `typing.Literal`.\n\nThis static method extracts the type arguments from the provided `literal`, which should be of type `typing.Literal`. If arguments are found, it returns a `LiteralAlias` typed with those arguments; otherwise, it returns a base `LiteralAlias`. The method relies on the `get_args` function from `typish.functions._get_args` to retrieve the arguments from the `literal`.\n\nParameters:\n- `literal` (typing.Any): The `typing.Literal` type from which to create a `LiteralAlias`.\n\nReturns:\n- typing.Type['LiteralAlias']: A `LiteralAlias` type corresponding to the provided literal or the base `LiteralAlias` if no arguments are found.\n\nDependencies:\n- The method depends on the `get_args` function from `typish.functions._get_args` to extract the arguments from the `literal`.\n\"\"\"\n```\n\n- CLASS METHOD: _LiteralMeta.__str__\n  - CLASS SIGNATURE: class _LiteralMeta(SubscriptableType):\n  - SIGNATURE: def __str__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the _LiteralMeta instance, formatted as 'Literal[arg1, arg2, ...]', where 'arg1', 'arg2', etc. are the elements of the __args__ attribute. The method constructs the string by joining each argument (converted to a string) with commas. The __args__ attribute is expected to be a tuple of literal values associated with the instance, defined by the Metaclass functionality derived from SubscriptableType. The method interacts with the __name__ attribute, which is set to 'Literal', ensuring that the string representation reflects the class name and its arguments correctly.\n\"\"\"\n```\n\n- CLASS METHOD: _LiteralMeta.__instancecheck__\n  - CLASS SIGNATURE: class _LiteralMeta(SubscriptableType):\n  - SIGNATURE: def __instancecheck__(self, instance):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the given instance is a member of the Literal type's defined arguments (__args__).\n\n:param instance: The object to check against the defined literal values.\n:return: True if the instance is among the values defined in __args__; otherwise, False.\n\nThis method leverages the __args__ attribute, which is a tuple containing the possible values of the LiteralAlias.\n\"\"\"\n```\n\n- CLASS METHOD: _LiteralMeta.__getattribute__\n  - CLASS SIGNATURE: class _LiteralMeta(SubscriptableType):\n  - SIGNATURE: def __getattribute__(cls, item):\n  - DOCSTRING: \n```python\n\"\"\"\nThis method is an overridden implementation of __getattribute__ in the _LiteralMeta metaclass, ensuring that the __args__ attribute behaves like the __args__ attribute of typing.Literal. It checks if the requested attribute is '__args__', and if so, retrieves it from the superclass (SubscriptableType), ensuring it is returned as a tuple. If the result is a nested tuple, it simplifies it. If the attribute is '__origin__', '__name__', or '_name', it returns the string 'Literal'. For all other attributes, it uses the superclass implementation. \n\nParameters:\n- cls: The class (of type _LiteralMeta) the method is called on.\n- item: The name of the attribute being accessed.\n\nReturns:\n- The value of the requested attribute. If '__args__', it is guaranteed to be a tuple, ensuring compatibility with the expected behavior of Literal types.\n\nDependencies:\n- Utilizes SubscriptableType's __getattribute__ to fetch attributes, ensuring compatibility with existing subscriptable types.\n\"\"\"\n```\n\n## FILE 3: typish/functions/_get_args.py\n\n- FUNCTION NAME: get_args\n  - SIGNATURE: def get_args(t: type) -> typing.Tuple[type, ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the arguments from a generic collection type (e.g., ``typing.List[int]``) as a tuple of types.\n\nParameters:\n- t (type): The collection type whose arguments are to be extracted.\n\nReturns:\n- typing.Tuple[type, ...]: A tuple containing the types of the arguments. If no arguments are found or if they are of type ``typing.TypeVar``, an empty tuple is returned.\n\nNotes:\n- The function uses `getattr` to access the `__args__` attribute of the type `t`, which holds the parameters of the generic type. It filters out any `TypeVar` instances to return only specific types.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - typish/classes/_literal.py:LiteralAlias:from_literal\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "typish/classes/_subscriptable_type.py": "class _SubscribedType(type):\n    \"\"\"\n    This class is a placeholder to let the IDE know the attributes of the\n    returned type after a __getitem__.\n    \"\"\"\n    __origin__ = None\n    __args__ = None\n\nclass SubscriptableType(type):\n    \"\"\"\n    This metaclass will allow a type to become subscriptable.\n\n    >>> class SomeType(metaclass=SubscriptableType):\n    ...     pass\n    >>> SomeTypeSub = SomeType['some args']\n    >>> SomeTypeSub.__args__\n    'some args'\n    >>> SomeTypeSub.__origin__.__name__\n    'SomeType'\n    \"\"\"\n\n    def __init_subclass__(mcs, **kwargs):\n        mcs._hash = None\n        mcs.__args__ = None\n        mcs.__origin__ = None\n\n    def __eq__(self, other):\n        self_args = getattr(self, '__args__', None)\n        self_origin = getattr(self, '__origin__', None)\n        other_args = getattr(other, '__args__', None)\n        other_origin = getattr(other, '__origin__', None)\n        return self_args == other_args and self_origin == other_origin\n\n    def __hash__(self):\n        if not getattr(self, '_hash', None):\n            self._hash = hash('{}{}'.format(self.__origin__, self.__args__))\n        return self._hash",
    "typish/classes/_literal.py": "import typing\nfrom typish.classes._subscriptable_type import SubscriptableType\n\ndef is_literal_type(cls: typing.Any) -> bool:\n    \"\"\"\n    Return whether cls is a Literal type.\n    :param cls: the type that is to be checked.\n    :return: True if cls is a Literal type.\n    \"\"\"\n    from typish.functions._get_simple_name import get_simple_name\n    return get_simple_name(cls) == 'Literal'\n\nclass _LiteralMeta(SubscriptableType):\n    \"\"\"\n    A Metaclass that exists to serve Literal and alter the __args__ attribute.\n    \"\"\"\n\n    def __subclasscheck__(self, subclass: typing.Any) -> bool:\n        return is_literal_type(subclass)\n\nclass LiteralAlias(type, metaclass=_LiteralMeta):\n    \"\"\"\n    This is a backwards compatible variant of typing.Literal (Python 3.8+).\n    \"\"\"\nLiteral = getattr(typing, 'Literal', LiteralAlias)",
    "typish/functions/_get_args.py": "import typing"
  },
  "call_tree": {
    "tests/classes/test_literal_meta.py:TestLiteralMeta:test_from_literal": {
      "tests/classes/test_literal_meta.py:TestLiteralMeta:LiteralMock": {},
      "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {},
      "typish/classes/_literal.py:LiteralAlias:from_literal": {
        "typish/functions/_get_args.py:get_args": {},
        "typish/classes/_subscriptable_type.py:SubscriptableType:__getitem__": {
          "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
        }
      },
      "typish/classes/_literal.py:_LiteralMeta:__instancecheck__": {
        "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
      }
    },
    "tests/classes/test_literal_meta.py:TestLiteralMeta:test_multiple_args": {
      "typish/classes/_subscriptable_type.py:SubscriptableType:__getitem__": {
        "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
      },
      "typish/classes/_literal.py:_LiteralMeta:__instancecheck__": {
        "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
      }
    },
    "tests/classes/test_literal_meta.py:TestLiteralMeta:test_str": {
      "typish/classes/_subscriptable_type.py:SubscriptableType:__getitem__": {
        "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
      },
      "typish/classes/_literal.py:_LiteralMeta:__str__": {
        "typish/classes/_literal.py:_LiteralMeta:__getattribute__": {}
      }
    }
  }
}