{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_collection",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_collection.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.collection import Collection\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\n\n\nclass TestPaginator:\n    @property\n    def collection(self) -> Collection:\n        return Collection(\n            name=\"name\",\n            attribute_name=\"attribute\",\n            parent_name=\"Parent\",\n            service_name=ServiceName(\"s3\", \"S3\"),\n            type_annotation=ExternalImport.from_class(ServiceName),\n            object_class_name=\"object\",\n        )\n\n    def test_init(self) -> None:\n        collection = self.collection\n        assert collection.name == \"name\"\n        assert collection.bases\n        assert collection.boto3_doc_link\n\n    def test_get_types(self) -> None:\n        assert len(set(self.collection.iterate_types())) == 2\n",
  "GT_file_code": {
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterator\n\nfrom boto3.resources.collection import ResourceCollection\n\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        name: str,\n        attribute_name: str,\n        parent_name: str,\n        service_name: ServiceName,\n        type_annotation: FakeAnnotation,\n        object_class_name: str,\n    ) -> None:\n        super().__init__(\n            name=name,\n            use_alias=True,\n            bases=[ExternalImport.from_class(ResourceCollection)],\n        )\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = (\n            \"service-resource\" if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        )\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}\"\n            f\"/{parent_name_part}/{self.attribute_name}.html\"\n        )\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.boto3_doc_link_parent}\"\n            f\"#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}\"\n        )\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations.\n        \"\"\"\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/structures/collection.py": {
      "Collection.__init__": {
        "code": "    def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n        \"\"\"Initialize a Collection instance representing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource.\n- service_name (ServiceName): An instance of ServiceName representing the service to which this collection belongs.\n- type_annotation (FakeAnnotation): The type annotation associated with the collection's objects.\n- object_class_name (str): The name of the object class contained by the collection.\n\nThis constructor initializes the Collection by invoking the superclass's initializer from ClassRecord, using specified parameters and creating a base class reference to ResourceCollection via ExternalImport.\n\nConstants:\n- The `SERVICE_RESOURCE` constant is used to determine whether to denote a service resource or another kind of parent entity in the generated documentation links.\"\"\"\n        super().__init__(name=name, use_alias=True, bases=[ExternalImport.from_class(ResourceCollection)])\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name",
        "docstring": "Initialize a Collection instance representing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource.\n- service_name (ServiceName): An instance of ServiceName representing the service to which this collection belongs.\n- type_annotation (FakeAnnotation): The type annotation associated with the collection's objects.\n- object_class_name (str): The name of the object class contained by the collection.\n\nThis constructor initializes the Collection by invoking the superclass's initializer from ClassRecord, using specified parameters and creating a base class reference to ResourceCollection via ExternalImport.\n\nConstants:\n- The `SERVICE_RESOURCE` constant is used to determine whether to denote a service resource or another kind of parent entity in the generated documentation links.",
        "signature": "def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      },
      "Collection.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Generate a link to the Boto3 documentation for the specified resource collection.\n\nThis method constructs a URL that directs to the appropriate section of the Boto3 documentation based on the service name, parent resource name, and attribute name. It utilizes the `boto3_doc_link_parent` property to establish the base URL and appends a fragment identifier to link directly to the specific resource section.\n\nReturns:\n    str: A formatted URL string pointing to the Boto3 documentation for the resource collection.\n\nDependencies:\n- `self.boto3_doc_link_parent`: Computes the base documentation link based on the service name and parent resource name.\n- `self.service_name`: An instance of `ServiceName`, which provides the `class_name` needed for forming the link.\n- `self.parent_name` and `self.attribute_name`: Strings used in the link to specify the exact resource being referenced.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'{self.boto3_doc_link_parent}#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}'",
        "docstring": "Generate a link to the Boto3 documentation for the specified resource collection.\n\nThis method constructs a URL that directs to the appropriate section of the Boto3 documentation based on the service name, parent resource name, and attribute name. It utilizes the `boto3_doc_link_parent` property to establish the base URL and appends a fragment identifier to link directly to the specific resource section.\n\nReturns:\n    str: A formatted URL string pointing to the Boto3 documentation for the resource collection.\n\nDependencies:\n- `self.boto3_doc_link_parent`: Computes the base documentation link based on the service name and parent resource name.\n- `self.service_name`: An instance of `ServiceName`, which provides the `class_name` needed for forming the link.\n- `self.parent_name` and `self.attribute_name`: Strings used in the link to specify the exact resource being referenced.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      },
      "Collection.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"Iterate over all type annotations related to the Collection instance.\n\nThis method yields type annotations from the superclass (`ClassRecord`) as well as from the `type_annotation` attribute, which is an instance of `FakeAnnotation`. Each yielded annotation can be iterated over for further processing. The `type_annotation` is an integral part of the Collection's type system, and is expected to provide its own method `iterate_types` to return its annotations.\n\nReturns:\n    An iterator of `FakeAnnotation` instances reflecting the type annotations associated with the Collection.\"\"\"\n        '\\n        Iterate over all type annotations.\\n        '\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()",
        "docstring": "Iterate over all type annotations related to the Collection instance.\n\nThis method yields type annotations from the superclass (`ClassRecord`) as well as from the `type_annotation` attribute, which is an instance of `FakeAnnotation`. Each yielded annotation can be iterated over for further processing. The `type_annotation` is an integral part of the Collection's type system, and is expected to provide its own method `iterate_types` to return its annotations.\n\nReturns:\n    An iterator of `FakeAnnotation` instances reflecting the type annotations associated with the Collection.",
        "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.__init__": {
        "code": "    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        \"\"\"Initialize a ServiceName instance with specified attributes.\n\nParameters:\n    name (str): The name of the service (e.g., \"ec2\", \"s3\").\n    class_name (str): The class name corresponding to the service (e.g., \"EC2\", \"S3\").\n    override_boto3_name (str, optional): An optional string to override the default boto3 name of the service. Defaults to an empty string.\n\nAttributes:\n    name (str): Stores the name of the service.\n    class_name (str): Stores the class name associated with the service.\n    boto3_version (str): Tracks the version of the service, initialized to the constant LATEST which is defined as \"latest\".\n    override_boto3_name (str): Stores the overridden boto3 service name if provided.\n\nThis constructor sets up a ServiceName object that represents a specific AWS service \nused in boto3, enabling the organization and management of service-related details \nutilized in interactions with the boto3 library.\"\"\"\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name",
        "docstring": "Initialize a ServiceName instance with specified attributes.\n\nParameters:\n    name (str): The name of the service (e.g., \"ec2\", \"s3\").\n    class_name (str): The class name corresponding to the service (e.g., \"EC2\", \"S3\").\n    override_boto3_name (str, optional): An optional string to override the default boto3 name of the service. Defaults to an empty string.\n\nAttributes:\n    name (str): Stores the name of the service.\n    class_name (str): Stores the class name associated with the service.\n    boto3_version (str): Tracks the version of the service, initialized to the constant LATEST which is defined as \"latest\".\n    override_boto3_name (str): Stores the overridden boto3 service name if provided.\n\nThis constructor sets up a ServiceName object that represents a specific AWS service \nused in boto3, enabling the organization and management of service-related details \nutilized in interactions with the boto3 library.",
        "signature": "def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.from_class": {
        "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"Create an `ExternalImport` instance from a given class.\n\nParameters:\n- `cls`: The class method's class.\n- `obj`: A type representing any class for which the wrapper is to be created.\n- `alias`: A string representing the local name for the import. Default is an empty string.\n- `safe`: A boolean indicating whether the import should be wrapped in a try-except block. Default is False.\n\nReturns:\nAn instance of `ExternalImport` initialized with the module name of the provided class, the class's name, the specified alias, and the safe flag. \n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class cannot be determined.\n\nThis method leverages `inspect.getmodule()` to retrieve the module of the class, ensuring that the import string can be derived correctly using `ImportString.from_str()`, which is imported from the `import_string` module in the codebase.\"\"\"\n        '\\n        Create an instance from an imported class.\\n\\n        Arguments:\\n            value -- Any Class.\\n            alias -- Local name.\\n            safe -- Whether import is wrapped in try-except.\\n        '\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
        "docstring": "Create an `ExternalImport` instance from a given class.\n\nParameters:\n- `cls`: The class method's class.\n- `obj`: A type representing any class for which the wrapper is to be created.\n- `alias`: A string representing the local name for the import. Default is an empty string.\n- `safe`: A boolean indicating whether the import should be wrapped in a try-except block. Default is False.\n\nReturns:\nAn instance of `ExternalImport` initialized with the module name of the provided class, the class's name, the specified alias, and the safe flag. \n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class cannot be determined.\n\nThis method leverages `inspect.getmodule()` to retrieve the module of the class, ensuring that the import string can be derived correctly using `ImportString.from_str()`, which is imported from the `import_string` module in the codebase.",
        "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ExternalImport instance based on its defining attributes.\n\nThis method utilizes the tuple of the instance's `source`, `name`, `alias`, and `safe` attributes to generate a unique hash. The attributes include:\n- `source`: An instance of ImportString that represents the module import string.\n- `name`: A string representing the import name.\n- `alias`: A string representing the local alias for the import.\n- `safe`: A boolean indicating whether the import is safely wrapped in a try-except block.\n\nThe computed hash can be used for storing instances in hash-based collections, ensuring that instances with the same attributes generate the same hash value.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate a hash value for the ExternalImport instance based on its defining attributes.\n\nThis method utilizes the tuple of the instance's `source`, `name`, `alias`, and `safe` attributes to generate a unique hash. The attributes include:\n- `source`: An instance of ImportString that represents the module import string.\n- `name`: A string representing the import name.\n- `alias`: A string representing the local alias for the import.\n- `safe`: A boolean indicating whether the import is safely wrapped in a try-except block.\n\nThe computed hash can be used for storing instances in hash-based collections, ensuring that instances with the same attributes generate the same hash value.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.__init__": {
          "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe",
          "docstring": "",
          "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.from_str": {
          "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))",
          "docstring": "Create from string.",
          "signature": "def from_str(cls, import_string: str) -> Self:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.__init__": {
          "code": "    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"",
          "docstring": "",
          "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      }
    },
    "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link": {
      "mypy_boto3_builder/structures/collection.py": {
        "Collection.boto3_doc_link_parent": {
          "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = 'service-resource' if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        return f'{self.service_name.boto3_doc_link_parent}/{parent_name_part}/{self.attribute_name}.html'",
          "docstring": "Link to boto3 docs parent directory.",
          "signature": "def boto3_doc_link_parent(self) -> str:",
          "type": "Method",
          "class_signature": "class Collection(ClassRecord):"
        }
      }
    },
    "mypy_boto3_builder/structures/collection.py:Collection:iterate_types": {
      "mypy_boto3_builder/structures/class_record.py": {
        "ClassRecord.iterate_types": {
          "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over type annotations for methods, attributes and bases.\n        \"\"\"\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()",
          "docstring": "Iterate over type annotations for methods, attributes and bases.",
          "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
          "type": "Method",
          "class_signature": "class ClassRecord:"
        }
      },
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation.iterate_types": {
          "code": "    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self",
          "docstring": "Iterate over all used type annotations recursively including self.",
          "signature": "def iterate_types(self) -> Iterator['FakeAnnotation']:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_collection\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u2514\u2500\u2500 ServiceName.__init__\n    \u251c\u2500\u2500 structures/\n    \u2502   \u2514\u2500\u2500 collection.py\n    \u2502       \u251c\u2500\u2500 Collection.__init__\n    \u2502       \u251c\u2500\u2500 Collection.boto3_doc_link\n    \u2502       \u2514\u2500\u2500 Collection.iterate_types\n    \u2514\u2500\u2500 type_annotations/\n        \u2514\u2500\u2500 external_import.py\n            \u251c\u2500\u2500 ExternalImport.__hash__\n            \u2514\u2500\u2500 ExternalImport.from_class\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the validation and testing of Boto3 service collection structures, ensuring proper interaction with AWS services. It provides functionality to instantiate and verify attributes of a `Collection` object, which represents a logical grouping of service-related resources or data, and includes support for service-specific metadata through integrations with the `ServiceName` and `ExternalImport` components. By offering methods to validate key attributes, relationships, and type annotations associated with a collection, the module aids developers in maintaining consistency and correctness when working with dynamically generated SDK components. This solves challenges related to automated type generation and ensures that services and their collections conform to expected design standards in complex API ecosystems.\n\n## FILE 1: mypy_boto3_builder/structures/collection.py\n\n- CLASS METHOD: Collection.iterate_types\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def iterate_types(self) -> Iterator[FakeAnnotation]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over all type annotations related to the Collection instance.\n\nThis method yields type annotations from the superclass (`ClassRecord`) as well as from the `type_annotation` attribute, which is an instance of `FakeAnnotation`. Each yielded annotation can be iterated over for further processing. The `type_annotation` is an integral part of the Collection's type system, and is expected to provide its own method `iterate_types` to return its annotations.\n\nReturns:\n    An iterator of `FakeAnnotation` instances reflecting the type annotations associated with the Collection.\n\"\"\"\n```\n\n- CLASS METHOD: Collection.boto3_doc_link\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a link to the Boto3 documentation for the specified resource collection.\n\nThis method constructs a URL that directs to the appropriate section of the Boto3 documentation based on the service name, parent resource name, and attribute name. It utilizes the `boto3_doc_link_parent` property to establish the base URL and appends a fragment identifier to link directly to the specific resource section.\n\nReturns:\n    str: A formatted URL string pointing to the Boto3 documentation for the resource collection.\n\nDependencies:\n- `self.boto3_doc_link_parent`: Computes the base documentation link based on the service name and parent resource name.\n- `self.service_name`: An instance of `ServiceName`, which provides the `class_name` needed for forming the link.\n- `self.parent_name` and `self.attribute_name`: Strings used in the link to specify the exact resource being referenced.\n\"\"\"\n```\n\n- CLASS METHOD: Collection.__init__\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Collection instance representing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The attribute name associated with the collection.\n- parent_name (str): The name of the parent resource.\n- service_name (ServiceName): An instance of ServiceName representing the service to which this collection belongs.\n- type_annotation (FakeAnnotation): The type annotation associated with the collection's objects.\n- object_class_name (str): The name of the object class contained by the collection.\n\nThis constructor initializes the Collection by invoking the superclass's initializer from ClassRecord, using specified parameters and creating a base class reference to ResourceCollection via ExternalImport.\n\nConstants:\n- The `SERVICE_RESOURCE` constant is used to determine whether to denote a service resource or another kind of parent entity in the generated documentation links.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.__init__\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ServiceName instance with specified attributes.\n\nParameters:\n    name (str): The name of the service (e.g., \"ec2\", \"s3\").\n    class_name (str): The class name corresponding to the service (e.g., \"EC2\", \"S3\").\n    override_boto3_name (str, optional): An optional string to override the default boto3 name of the service. Defaults to an empty string.\n\nAttributes:\n    name (str): Stores the name of the service.\n    class_name (str): Stores the class name associated with the service.\n    boto3_version (str): Tracks the version of the service, initialized to the constant LATEST which is defined as \"latest\".\n    override_boto3_name (str): Stores the overridden boto3 service name if provided.\n\nThis constructor sets up a ServiceName object that represents a specific AWS service \nused in boto3, enabling the organization and management of service-related details \nutilized in interactions with the boto3 library.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ExternalImport instance based on its defining attributes.\n\nThis method utilizes the tuple of the instance's `source`, `name`, `alias`, and `safe` attributes to generate a unique hash. The attributes include:\n- `source`: An instance of ImportString that represents the module import string.\n- `name`: A string representing the import name.\n- `alias`: A string representing the local alias for the import.\n- `safe`: A boolean indicating whether the import is safely wrapped in a try-except block.\n\nThe computed hash can be used for storing instances in hash-based collections, ensuring that instances with the same attributes generate the same hash value.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.from_class\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an `ExternalImport` instance from a given class.\n\nParameters:\n- `cls`: The class method's class.\n- `obj`: A type representing any class for which the wrapper is to be created.\n- `alias`: A string representing the local name for the import. Default is an empty string.\n- `safe`: A boolean indicating whether the import should be wrapped in a try-except block. Default is False.\n\nReturns:\nAn instance of `ExternalImport` initialized with the module name of the provided class, the class's name, the specified alias, and the safe flag. \n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class cannot be determined.\n\nThis method leverages `inspect.getmodule()` to retrieve the module of the class, ensuring that the import string can be derived correctly using `ImportString.from_str()`, which is imported from the `import_string` module in the codebase.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterator\nfrom boto3.resources.collection import ResourceCollection\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = 'service-resource' if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        return f'{self.service_name.boto3_doc_link_parent}/{parent_name_part}/{self.attribute_name}.html'",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe"
  },
  "call_tree": {
    "tests/structures/test_collection.py:TestPaginator:test_init": {
      "tests/structures/test_collection.py:TestPaginator:collection": {
        "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
            },
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
          },
          "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
        }
      },
      "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link": {
        "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link_parent": {
          "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
            "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
          }
        }
      }
    },
    "tests/structures/test_collection.py:TestPaginator:test_get_types": {
      "tests/structures/test_collection.py:TestPaginator:collection": {
        "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
            },
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
          },
          "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
        }
      },
      "mypy_boto3_builder/structures/collection.py:Collection:iterate_types": {
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:iterate_types": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
        },
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      }
    }
  }
}