{
  "dir_path": "/app/pydicom",
  "package_name": "pydicom",
  "sample_name": "pydicom-test_decoder_base",
  "src_dir": "pydicom/src/pydicom/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/pixels/test_decoder_base.py",
  "test_code": "\"\"\"Tests for pydicom.pixels.decoder.base.\"\"\"\n\nfrom io import BytesIO\nimport logging\nfrom math import ceil\nfrom struct import pack, unpack\nfrom sys import byteorder\n\nimport pytest\n\nfrom pydicom import config, dcmread\nfrom pydicom.dataset import Dataset\nfrom pydicom.encaps import get_frame, generate_frames, encapsulate\nfrom pydicom.pixels import get_decoder\nfrom pydicom.pixels.common import PhotometricInterpretation as PI\nfrom pydicom.pixels.decoders import ExplicitVRLittleEndianDecoder\nfrom pydicom.pixels.decoders.base import DecodeRunner, Decoder\nfrom pydicom.pixels.processing import convert_color_space\n\nfrom pydicom.uid import (\n    ExplicitVRLittleEndian,\n    ImplicitVRLittleEndian,\n    DeflatedExplicitVRLittleEndian,\n    ExplicitVRBigEndian,\n    JPEGBaseline8Bit,\n    RLELossless,\n    SMPTEST211030PCMDigitalAudio,\n)\n\ntry:\n    import numpy as np\n\n    HAVE_NP = True\nexcept ImportError:\n    HAVE_NP = False\n\nfrom .pixels_reference import (\n    EXPL_1_1_3F_NONALIGNED,\n    PIXEL_REFERENCE,\n    RLE_16_1_1F,\n    RLE_16_1_10F,\n    EXPL_16_1_10F,\n    EXPL_8_3_1F_YBR,\n    EXPL_8_3_1F_YBR422,\n    EXPL_1_1_1F,\n    EXPB_8_1_1F,\n)\n\n\nRLE_REFERENCE = PIXEL_REFERENCE[RLELossless]\n\n\nclass TestDecodeRunner:\n    \"\"\"Tests for DecodeRunner.\"\"\"\n\n    def test_init(self):\n        \"\"\"Test initial creation.\"\"\"\n        # Encapsulated transfer syntax - pixel_keyword set, view_only not set\n        runner = DecodeRunner(RLELossless)\n        assert runner.transfer_syntax == RLELossless\n        assert runner.get_option(\"pixel_keyword\") == \"PixelData\"\n        assert runner.get_option(\"as_rgb\")\n        assert runner.get_option(\"view_only\") is None\n\n        # Native transfer syntax - pixel_keyword not set, view_only set\n        runner = DecodeRunner(ExplicitVRLittleEndian)\n        assert runner.transfer_syntax == ExplicitVRLittleEndian\n        assert runner.get_option(\"pixel_keyword\") is None\n        assert runner.get_option(\"as_rgb\")\n        assert not runner.get_option(\"view_only\")\n\n    def test_del_option(self):\n        \"\"\"Test for del_option()\"\"\"\n        runner = DecodeRunner(RLELossless)\n        for name in (\"transfer_syntax_uid\", \"pixel_keyword\"):\n            msg = f\"Deleting '{name}' is not allowed\"\n            with pytest.raises(ValueError, match=msg):\n                runner.del_option(name)\n\n    def test_set_source_dataset(self):\n        \"\"\"Test setting runner source and options via dataset.\"\"\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(RLE_16_1_1F.ds)\n        assert runner.bits_allocated == 16\n        assert runner.bits_stored == 16\n        assert runner.columns == 64\n        assert runner.extended_offsets is None\n        assert runner.number_of_frames == 1\n        assert runner.photometric_interpretation == PI.MONOCHROME2\n        assert runner.pixel_keyword == \"PixelData\"\n        assert runner.pixel_representation == 1\n        assert runner.rows == 64\n        assert runner.samples_per_pixel == 1\n        assert runner.get_option(\"planar_configuration\") is None\n\n        ds = Dataset()\n        ds.BitsAllocated = 32\n        ds.BitsStored = 24\n        ds.Columns = 10\n        ds.Rows = 8\n        ds.SamplesPerPixel = 3\n        ds.NumberOfFrames = \"5\"\n        ds.FloatPixelData = None\n        ds.PlanarConfiguration = 1\n        ds.ExtendedOffsetTable = b\"\\x00\\x01\"\n        ds.ExtendedOffsetTableLengths = b\"\\x00\\x02\"\n        ds.PhotometricInterpretation = \"PALETTE COLOR\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(ds)\n        assert runner.is_dataset\n\n        assert runner.bits_allocated == 32\n        assert runner.bits_stored == 24\n        assert runner.columns == 10\n        assert runner.extended_offsets == (b\"\\x00\\x01\", b\"\\x00\\x02\")\n        assert runner.number_of_frames == 5\n        assert runner.photometric_interpretation == PI.PALETTE_COLOR\n        assert runner.pixel_keyword == \"FloatPixelData\"\n        assert runner.get_option(\"pixel_representation\") is None\n        assert runner.rows == 8\n        assert runner.samples_per_pixel == 3\n        assert runner.planar_configuration == 1\n\n        del ds.ExtendedOffsetTable\n        ds.SamplesPerPixel = 1\n        del ds.PlanarConfiguration\n        del ds.FloatPixelData\n        ds.DoubleFloatPixelData = None\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(ds)\n        assert runner.extended_offsets is None\n        assert runner.pixel_keyword == \"DoubleFloatPixelData\"\n        assert runner.get_option(\"planar_configuration\") is None\n\n        ds.PixelData = None\n        msg = (\n            \"One and only one of 'Pixel Data', 'Float Pixel Data' or \"\n            \"'Double Float Pixel Data' may be present in the dataset\"\n        )\n        with pytest.raises(AttributeError, match=msg):\n            runner.set_source(ds)\n\n        del ds.PixelData\n        del ds.DoubleFloatPixelData\n        msg = (\n            \"The dataset has no 'Pixel Data', 'Float Pixel Data' or 'Double \"\n            \"Float Pixel Data' element, no pixel data to decode\"\n        )\n        with pytest.raises(AttributeError, match=msg):\n            runner.set_source(ds)\n\n        ds.file_meta = Dataset()\n        ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n\n        msg = (\n            \"The dataset's transfer syntax 'Explicit VR Little Endian' doesn't \"\n            \"match the pixel data decoder\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            runner.set_source(ds)\n\n    def test_str(self):\n        \"\"\"Test str(DecodeRunner)\"\"\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_decoders({\"foo\": None})\n        assert str(runner) == (\n            \"DecodeRunner for 'RLE Lossless'\\n\"\n            \"Options\\n\"\n            \"  transfer_syntax_uid: 1.2.840.10008.1.2.5\\n\"\n            \"  as_rgb: True\\n\"\n            \"  allow_excess_frames: True\\n\"\n            \"  pixel_keyword: PixelData\\n\"\n            \"  correct_unused_bits: True\\n\"\n            \"Decoders\\n\"\n            \"  foo\"\n        )\n\n    def test_test_for_be_swap(self):\n        \"\"\"Test test_for('be_swap_ow')\"\"\"\n        runner = DecodeRunner(ExplicitVRBigEndian)\n        with pytest.raises(ValueError, match=r\"Unknown test 'foo'\"):\n            runner._test_for(\"foo\")\n\n        runner.set_option(\"bits_allocated\", 8)\n        runner.set_option(\"pixel_keyword\", \"PixelData\")\n\n        assert runner._test_for(\"be_swap_ow\") is False\n        runner.set_option(\"be_swap_ow\", True)\n        assert runner._test_for(\"be_swap_ow\") is True\n        runner.set_option(\"be_swap_ow\", False)\n        assert runner._test_for(\"be_swap_ow\") is False\n        runner.set_option(\"pixel_vr\", \"OW\")\n        assert runner._test_for(\"be_swap_ow\") is True\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_pixel_dtype_unsupported_raises(self):\n        \"\"\"Test unsupported dtypes raise exception.\"\"\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_option(\"bits_allocated\", 24)\n        runner.set_option(\"pixel_representation\", 0)\n\n        msg = \"The data type 'u3' needed to contain the pixel data\"\n        with pytest.raises(NotImplementedError, match=msg):\n            runner.pixel_dtype\n\n    @pytest.mark.skipif(HAVE_NP, reason=\"Numpy is available\")\n    def test_pixel_dtype_no_numpy_raises(self):\n        \"\"\"Tests exception raised if numpy not available.\"\"\"\n        runner = DecodeRunner(RLELossless)\n        msg = \"NumPy is required for 'DecodeRunner.pixel_dtype'\"\n        with pytest.raises(ImportError, match=msg):\n            runner.pixel_dtype\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_pixel_dtype(self):\n        \"\"\"Test supported dtypes.\"\"\"\n        reference = [\n            (1, 0, \"u1\"),\n            (1, 1, \"u1\"),\n            (8, 0, \"u1\"),\n            (8, 1, \"i1\"),\n            (16, 0, \"u2\"),\n            (16, 1, \"i2\"),\n            (32, 0, \"u4\"),\n            (32, 1, \"i4\"),\n        ]\n\n        runner = DecodeRunner(RLELossless)\n        for bits, pixel_repr, dtype in reference:\n            runner.set_option(\"bits_allocated\", bits)\n            runner.set_option(\"pixel_representation\", pixel_repr)\n\n            # Correct for endianness of system\n            ref_dtype = np.dtype(dtype)\n            if not (byteorder == \"little\"):\n                ref_dtype = ref_dtype.newbyteorder(\"S\")\n\n            assert ref_dtype == runner.pixel_dtype\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_pixel_dtype_float(self):\n        runner = DecodeRunner(ExplicitVRLittleEndian)\n        runner.set_option(\"pixel_keyword\", \"FloatPixelData\")\n        assert runner.pixel_dtype == \"<f4\"\n        runner.set_option(\"pixel_keyword\", \"DoubleFloatPixelData\")\n        assert runner.pixel_dtype == \"<f8\"\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_pixel_dtype_byte_swapping(self):\n        \"\"\"Test that the endianness of the system is taken into account.\"\"\"\n        # The main problem is that our testing environments are probably\n        #   all little endian, but we'll try our best\n        runner = DecodeRunner(RLELossless)\n        runner.set_option(\"bits_allocated\", 16)\n        runner.set_option(\"pixel_representation\", 0)\n\n        # < is little, = is native, > is big\n        if byteorder == \"little\":\n            assert runner.pixel_dtype.byteorder in [\"<\", \"=\"]\n            runner._opts[\"transfer_syntax_uid\"] = ExplicitVRBigEndian\n            assert runner.pixel_dtype.byteorder == \">\"\n        elif byteorder == \"big\":\n            assert runner.pixel_dtype.byteorder == \"<\"\n            runner._opts[\"transfer_syntax_uid\"] = ExplicitVRBigEndian\n            assert runner.pixel_dtype.byteorder in [\">\", \"=\"]\n\n    def test_validate_buffer(self):\n        \"\"\"Tests for validate_buffer()\"\"\"\n        runner = DecodeRunner(RLELossless)\n        # Padded\n        runner.set_source(b\"\\x01\\x02\\x03\\x00\")\n        runner.set_option(\"bits_allocated\", 8)\n        runner.set_option(\"rows\", 1)\n        runner.set_option(\"columns\", 1)\n        runner.set_option(\"samples_per_pixel\", 3)\n        runner.set_option(\"photometric_interpretation\", \"RGB\")\n        runner.set_option(\"number_of_frames\", 1)\n\n        msg = (\n            \"The number of bytes of compressed pixel data matches the \"\n            \"expected number for uncompressed data - check that the \"\n            \"transfer syntax has been set correctly\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            runner._validate_buffer()\n\n        # Unpadded\n        runner.set_source(b\"\\x01\\x02\\x03\")\n        with pytest.warns(UserWarning, match=msg):\n            runner._validate_buffer()\n\n        runner = DecodeRunner(ExplicitVRLittleEndian)\n        runner.set_source(b\"\\x00\\x00\")\n        runner.set_option(\"bits_allocated\", 8)\n        runner.set_option(\"rows\", 1)\n        runner.set_option(\"columns\", 1)\n        runner.set_option(\"samples_per_pixel\", 3)\n        runner.set_option(\"photometric_interpretation\", \"RGB\")\n        runner.set_option(\"number_of_frames\", 1)\n\n        # Actual length 2 is less than expected 3\n        msg = (\n            \"The number of bytes of pixel data is less than expected \"\n            r\"\\(2 vs 4 bytes\\) - the dataset may be corrupted, have an invalid \"\n            \"group 0028 element value, or the transfer syntax may be incorrect\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            runner._validate_buffer()\n\n        # Actual length 5 is greater than expected 3  (padding 2)\n        runner.set_source(b\"\\x00\" * 5)\n        msg = (\n            \"The pixel data is 5 bytes long, which indicates it \"\n            \"contains 2 bytes of excess padding to be removed\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            runner._validate_buffer()\n\n        # YBR_FULL_422 but has unsubsampled length\n        # expected 18 // 3 * 2 = 12, actual 18\n        runner.set_option(\"photometric_interpretation\", \"YBR_FULL_422\")\n        runner.set_option(\"rows\", 2)\n        runner.set_option(\"columns\", 3)\n        runner.set_source(b\"\\x00\" * 18)\n\n        msg = (\n            \"The number of bytes of pixel data is a third larger than expected \"\n            r\"\\(18 vs 12 bytes\\) which indicates the set \\(0028,0004\\) \"\n            r\"'Photometric Interpretation' value of 'YBR_FULL_422' is \"\n            \"incorrect and may need to be changed to either 'RGB' or 'YBR_FULL'\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            runner._validate_buffer()\n\n    def test_validate_options(self):\n        \"\"\"Tests for validate_options()\"\"\"\n        # DecodeRunner-specific option validation\n        runner = DecodeRunner(ExplicitVRLittleEndian)\n        runner.set_option(\"bits_allocated\", 8)\n        runner.set_option(\"bits_stored\", 8)\n        runner.set_option(\"columns\", 8)\n        runner.set_option(\"photometric_interpretation\", PI.RGB)\n        runner.set_option(\"pixel_keyword\", \"PixelData\")\n        runner.set_option(\"pixel_representation\", 0)\n        runner.set_option(\"rows\", 10)\n        runner.set_option(\"samples_per_pixel\", 3)\n        runner.set_option(\"planar_configuration\", 1)\n        runner.set_option(\"number_of_frames\", 8)\n        runner.set_option(\"extended_offsets\", ([1, 2], [1]))\n        msg = (\n            r\"The number of items in \\(7FE0,0001\\) 'Extended Offset Table' and \"\n            r\"\\(7FE0,0002\\) 'Extended Offset Table Lengths' don't match - the \"\n            \"extended offset table will be ignored\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            runner._validate_options()\n\n        runner.set_option(\"extended_offsets\", ([0], [10]))\n        runner._validate_options()\n\n        # Float/Double Float Pixel Data\n        runner.del_option(\"bits_stored\")\n        runner.set_option(\"pixel_keyword\", \"FloatPixelData\")\n        runner._validate_options()\n\n        runner.set_option(\"pixel_keyword\", \"DoubleFloatPixelData\")\n        runner._validate_options()\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_decode(self):\n        \"\"\"Test decode()\"\"\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(RLE_16_1_10F.ds)\n\n        msg = \"Unable to decode as exceptions were raised by all available plugins\"\n        with pytest.raises(RuntimeError, match=msg):\n            runner.decode(0)\n\n        decoder = get_decoder(RLELossless)\n        runner.set_decoders(decoder._validate_plugins(\"pydicom\"))\n        buffer = runner.decode(0)\n\n        assert runner._previous[1] == runner._decoders[\"pydicom\"]\n\n        arr = np.frombuffer(buffer, dtype=runner.pixel_dtype)\n        arr = runner.reshape(arr, as_frame=True)\n        RLE_16_1_10F.test(arr, index=0)\n\n        buffer = runner.decode(9)\n        arr = np.frombuffer(buffer, dtype=runner.pixel_dtype)\n        arr = runner.reshape(arr, as_frame=True)\n        RLE_16_1_10F.test(arr, index=9)\n\n        def decode1(src, opts):\n            raise ValueError(\"Bad decoding, many errors\")\n\n        def decode2(src, opts):\n            raise AttributeError(\"Also bad, not helpful\")\n\n        # Check that exception messages on decoder failure\n        # Need to update the attr to avoid resetting _previous\n        runner._decoders = {\"foo\": decode1, \"bar\": decode2}\n        assert hasattr(runner, \"_previous\")\n        msg = (\n            r\"Unable to decode as exceptions were raised by all available plugins:\"\n            r\"\\n  foo: Bad decoding, many errors\\n  bar: Also bad, not helpful\"\n        )\n        with pytest.raises(RuntimeError, match=msg):\n            runner.decode(0)\n\n    @pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\n    def test_iter_decode(self, caplog):\n        \"\"\"Test iter_decode()\"\"\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(RLE_16_1_10F.ds)\n\n        msg = \"Unable to decode as exceptions were raised by all available plugins\"\n        with pytest.raises(RuntimeError, match=msg):\n            runner.decode(0)\n\n        decoder = get_decoder(RLELossless)\n        plugins = decoder._validate_plugins(\"pydicom\")\n        runner.set_decoders(plugins)\n        data = runner.iter_decode()\n        buffer = next(data)\n\n        assert runner._previous[1] == runner._decoders[\"pydicom\"]\n\n        arr = np.frombuffer(buffer, dtype=runner.pixel_dtype)\n        arr = runner.reshape(arr, as_frame=True)\n        RLE_16_1_10F.test(arr, index=0)\n\n        for ii in range(9):\n            buffer = next(data)\n\n        arr = np.frombuffer(buffer, dtype=runner.pixel_dtype)\n        arr = runner.reshape(arr, as_frame=True)\n        RLE_16_1_10F.test(arr, index=9)\n\n        pytest.raises(StopIteration, next, data)\n\n        raise_exc = [False]\n\n        def foo(src, opts):\n            if raise_exc[0]:\n                raise ValueError(\"Oops\")\n\n            return b\"\\x00\\x00\"\n\n        runner.set_decoders({\"foo\": foo})\n        assert not hasattr(runner, \"_previous\")\n        data = runner.iter_decode()\n        assert b\"\\x00\\x00\" == next(data)\n        assert runner._previous[1] == foo\n        raise_exc[0] = True\n        pytest.raises(RuntimeError, next, data)\n\n        # Test decode failure during\n        raise_exc = [False]\n\n        def decode_partial(src, opts):\n            if raise_exc[0]:\n                raise ValueError(\"Whoops\")\n\n            return b\"\\x00\\x00\\x00\\x00\"\n\n        def decode_all(src, opts):\n            return b\"\\x03\\x02\\x01\\x00\"\n\n        runner._src = encapsulate([b\"\\x00\\x01\\x02\\x03\"] * 10)\n        runner.set_decoders({\"foo\": decode_partial})\n        runner.set_decoders({\"foo\": decode_partial, \"bar\": decode_all})\n        frame_generator = runner.iter_decode()\n        assert next(frame_generator) == b\"\\x00\\x00\\x00\\x00\"\n        raise_exc = [True]\n        msg = (\n            \"The decoding plugin has changed from 'foo' to 'bar' during the \"\n            \"decoding process - you may get inconsistent inter-frame results, \"\n            \"consider passing 'decoding_plugin=\\\"bar\\\"' instead\"\n        )\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            with pytest.warns(UserWarning, match=msg):\n                assert next(frame_generator) == b\"\\x03\\x02\\x01\\x00\"\n\n            assert (\n                \"The decoding plugin 'foo' failed to decode the frame at index 1\"\n            ) in caplog.text\n\n    def test_get_data(self):\n        \"\"\"Test get_data()\"\"\"\n        src = b\"\\x00\\x01\\x02\\x03\\x04\\x05\"\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(src)\n        assert runner.is_buffer\n        assert runner.get_data(src, 0, 4) == b\"\\x00\\x01\\x02\\x03\"\n        assert runner.get_data(src, 3, 4) == b\"\\x03\\x04\\x05\"\n\n        src = BytesIO(src)\n        runner.set_source(src)\n        assert not runner.is_buffer\n        assert runner.get_data(src, 0, 4) == b\"\\x00\\x01\\x02\\x03\"\n        assert src.tell() == 0\n        assert runner.get_data(src, 3, 4) == b\"\\x03\\x04\\x05\"\n        assert src.seek(2)\n        assert runner.get_data(src, 3, 4) == b\"\\x03\\x04\\x05\"\n        assert src.tell() == 2\n\n    def test_pixel_properties(self):\n        \"\"\"Test pixel_properties()\"\"\"\n        runner = DecodeRunner(RLELossless)\n        opts = {\n            \"columns\": 9,\n            \"rows\": 10,\n            \"samples_per_pixel\": 1,\n            \"number_of_frames\": 3,\n            \"pixel_keyword\": \"PixelData\",\n            \"photometric_interpretation\": PI.RGB,\n            \"pixel_representation\": 0,\n            \"bits_allocated\": 16,\n            \"bits_stored\": 8,\n        }\n        runner.set_options(**opts)\n        d = runner.pixel_properties()\n        assert d[\"columns\"] == 9\n        assert d[\"rows\"] == 10\n        assert d[\"samples_per_pixel\"] == 1\n        assert d[\"number_of_frames\"] == 3\n        assert d[\"photometric_interpretation\"] == PI.RGB\n        assert d[\"pixel_representation\"] == 0\n        assert d[\"bits_allocated\"] == 16\n        assert d[\"bits_stored\"] == 8\n        assert d[\"number_of_frames\"] == 3\n        assert \"planar_configuration\" not in d\n\n        runner.set_option(\"pixel_keyword\", \"FloatPixelData\")\n        assert \"pixel_representation\" not in runner.pixel_properties()\n\n        runner.set_option(\"samples_per_pixel\", 3)\n        runner.set_option(\"planar_configuration\", 1)\n        assert runner.pixel_properties()[\"planar_configuration\"] == 1\n\n\n@pytest.mark.skipif(not HAVE_NP, reason=\"Numpy is not available\")\nclass TestDecodeRunner_Reshape:\n    def setup_method(self):\n        \"\"\"Setup the test dataset.\"\"\"\n        self.runner = DecodeRunner(ExplicitVRLittleEndian)\n        self.runner.set_option(\"rows\", 4)\n        self.runner.set_option(\"columns\", 5)\n        self.runner.set_option(\"number_of_frames\", 1)\n\n        self.reference = np.asarray(\n            [\n                [  # Frame 1\n                    [[1, 9, 17], [2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21]],\n                    [[2, 10, 18], [3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14, 22]],\n                    [[3, 11, 19], [4, 12, 20], [5, 13, 21], [6, 14, 22], [7, 15, 23]],\n                    [[4, 12, 20], [5, 13, 21], [6, 14, 22], [7, 15, 23], [8, 16, 24]],\n                ],\n                [  # Frame 2\n                    [\n                        [25, 33, 41],\n                        [26, 34, 42],\n                        [27, 35, 43],\n                        [28, 36, 44],\n                        [29, 37, 45],\n                    ],\n                    [\n                        [26, 34, 42],\n                        [27, 35, 43],\n                        [28, 36, 44],\n                        [29, 37, 45],\n                        [30, 38, 46],\n                    ],\n                    [\n                        [27, 35, 43],\n                        [28, 36, 44],\n                        [29, 37, 45],\n                        [30, 38, 46],\n                        [31, 39, 47],\n                    ],\n                    [\n                        [28, 36, 44],\n                        [29, 37, 45],\n                        [30, 38, 46],\n                        [31, 39, 47],\n                        [32, 40, 48],\n                    ],\n                ],\n            ]\n        )\n        self.ref_1_1 = self.reference[0, :, :, 0]\n        self.ref_1_3 = self.reference[0]\n        self.ref_2_1 = self.reference[:, :, :, 0]\n        self.ref_2_3 = self.reference\n\n    @pytest.fixture\n    def _1frame_1sample(self):\n        return np.asarray([1, 2, 3, 4, 5, 2, 3, 4, 5, 6, 3, 4, 5, 6, 7, 4, 5, 6, 7, 8])\n\n    @pytest.fixture\n    def _2frame_1sample(self):\n        return np.asarray(\n            [\n                [1, 2, 3, 4, 5, 2, 3, 4, 5, 6],\n                [3, 4, 5, 6, 7, 4, 5, 6, 7, 8],\n                [25, 26, 27, 28, 29, 26, 27, 28, 29, 30],\n                [27, 28, 29, 30, 31, 28, 29, 30, 31, 32],\n            ]\n        ).ravel()\n\n    @pytest.fixture\n    def _1frame_3sample_0config(self):\n        return np.asarray(\n            [\n                [1, 9, 17, 2, 10, 18, 3, 11, 19, 4],\n                [12, 20, 5, 13, 21, 2, 10, 18, 3, 11],\n                [19, 4, 12, 20, 5, 13, 21, 6, 14, 22],\n                [3, 11, 19, 4, 12, 20, 5, 13, 21, 6],\n                [14, 22, 7, 15, 23, 4, 12, 20, 5, 13],\n                [21, 6, 14, 22, 7, 15, 23, 8, 16, 24],\n            ]\n        ).ravel()\n\n    @pytest.fixture\n    def _1frame_3sample_1config(self):\n        return np.asarray(\n            [\n                [1, 2, 3, 4, 5, 2, 3, 4, 5, 6],  # Red\n                [3, 4, 5, 6, 7, 4, 5, 6, 7, 8],\n                [9, 10, 11, 12, 13, 10, 11, 12, 13, 14],  # Green\n                [11, 12, 13, 14, 15, 12, 13, 14, 15, 16],\n                [17, 18, 19, 20, 21, 18, 19, 20, 21, 22],  # Blue\n                [19, 20, 21, 22, 23, 20, 21, 22, 23, 24],\n            ]\n        ).ravel()\n\n    @pytest.fixture\n    def _2frame_3sample_0config(self):\n        return np.asarray(\n            [\n                [1, 9, 17, 2, 10, 18, 3, 11, 19, 4, 12, 20],  # Frame 1\n                [5, 13, 21, 2, 10, 18, 3, 11, 19, 4, 12, 20],\n                [5, 13, 21, 6, 14, 22, 3, 11, 19, 4, 12, 20],\n                [5, 13, 21, 6, 14, 22, 7, 15, 23, 4, 12, 20],\n                [5, 13, 21, 6, 14, 22, 7, 15, 23, 8, 16, 24],\n                [25, 33, 41, 26, 34, 42, 27, 35, 43, 28, 36, 44],  # Frame 2\n                [29, 37, 45, 26, 34, 42, 27, 35, 43, 28, 36, 44],\n                [29, 37, 45, 30, 38, 46, 27, 35, 43, 28, 36, 44],\n                [29, 37, 45, 30, 38, 46, 31, 39, 47, 28, 36, 44],\n                [29, 37, 45, 30, 38, 46, 31, 39, 47, 32, 40, 48],\n            ]\n        ).ravel()\n\n    @pytest.fixture\n    def _2frame_3sample_1config(self):\n        return np.asarray(\n            [\n                [1, 2, 3, 4, 5, 2, 3, 4, 5, 6],  # Frame 1, red\n                [3, 4, 5, 6, 7, 4, 5, 6, 7, 8],\n                [9, 10, 11, 12, 13, 10, 11, 12, 13, 14],  # Frame 1, green\n                [11, 12, 13, 14, 15, 12, 13, 14, 15, 16],\n                [17, 18, 19, 20, 21, 18, 19, 20, 21, 22],  # Frame 1, blue\n                [19, 20, 21, 22, 23, 20, 21, 22, 23, 24],\n                [25, 26, 27, 28, 29, 26, 27, 28, 29, 30],  # Frame 2, red\n                [27, 28, 29, 30, 31, 28, 29, 30, 31, 32],\n                [33, 34, 35, 36, 37, 34, 35, 36, 37, 38],  # Frame 2, green\n                [35, 36, 37, 38, 39, 36, 37, 38, 39, 40],\n                [41, 42, 43, 44, 45, 42, 43, 44, 45, 46],  # Frame 2, blue\n                [43, 44, 45, 46, 47, 44, 45, 46, 47, 48],\n            ]\n        ).ravel()\n\n    def test_reference_1frame_1sample(self):\n        \"\"\"Test the 1 frame 1 sample/pixel reference array is as expected.\"\"\"\n        # (rows, columns)\n        assert (4, 5) == self.ref_1_1.shape\n        assert np.array_equal(\n            self.ref_1_1,\n            np.asarray(\n                [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]\n            ),\n        )\n\n    def test_reference_1frame_3sample(self):\n        \"\"\"Test the 1 frame 3 sample/pixel reference array is as expected.\"\"\"\n        # (rows, columns, planes)\n        assert (4, 5, 3) == self.ref_1_3.shape\n\n        # Red channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 0],\n            np.asarray(\n                [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]\n            ),\n        )\n        # Green channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 1],\n            np.asarray(\n                [\n                    [9, 10, 11, 12, 13],\n                    [10, 11, 12, 13, 14],\n                    [11, 12, 13, 14, 15],\n                    [12, 13, 14, 15, 16],\n                ]\n            ),\n        )\n        # Blue channel\n        assert np.array_equal(\n            self.ref_1_3[:, :, 2],\n            np.asarray(\n                [\n                    [17, 18, 19, 20, 21],\n                    [18, 19, 20, 21, 22],\n                    [19, 20, 21, 22, 23],\n                    [20, 21, 22, 23, 24],\n                ]\n            ),\n        )\n\n    def test_reference_2frame_1sample(self):\n        \"\"\"Test the 2 frame 1 sample/pixel reference array is as expected.\"\"\"\n        # (nr frames, rows, columns)\n        assert (2, 4, 5) == self.ref_2_1.shape\n\n        # Frame 1\n        assert np.array_equal(\n            self.ref_2_1[0, :, :],\n            np.asarray(\n                [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]\n            ),\n        )\n        # Frame 2\n        assert np.array_equal(\n            self.ref_2_1[1, :, :],\n            np.asarray(\n                [\n                    [25, 26, 27, 28, 29],\n                    [26, 27, 28, 29, 30],\n                    [27, 28, 29, 30, 31],\n                    [28, 29, 30, 31, 32],\n                ]\n            ),\n        )\n\n    def test_reference_2frame_3sample(self):\n        \"\"\"Test the 2 frame 3 sample/pixel reference array is as expected.\"\"\"\n        # (nr frames, row, columns, planes)\n        assert (2, 4, 5, 3) == self.ref_2_3.shape\n\n        # Red channel, frame 1\n        assert np.array_equal(\n            self.ref_2_3[0, :, :, 0],\n            np.asarray(\n                [[1, 2, 3, 4, 5], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8]]\n            ),\n        )\n        # Green channel, frame 2\n        assert np.array_equal(\n            self.ref_2_3[1, :, :, 1],\n            np.asarray(\n                [\n                    [33, 34, 35, 36, 37],\n                    [34, 35, 36, 37, 38],\n                    [35, 36, 37, 38, 39],\n                    [36, 37, 38, 39, 40],\n                ]\n            ),\n        )\n\n    def test_1frame_1sample(self, _1frame_1sample):\n        \"\"\"Test reshaping 1 frame, 1 sample/pixel.\"\"\"\n        self.runner.set_option(\"samples_per_pixel\", 1)\n        arr = self.runner.reshape(_1frame_1sample)\n        assert (4, 5) == arr.shape\n        assert np.array_equal(arr, self.ref_1_1)\n\n        # Test reshape to (rows, cols) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n    def test_1frame_3sample_0conf(self, _1frame_3sample_0config):\n        \"\"\"Test reshaping 1 frame, 3 sample/pixel for 0 planar config.\"\"\"\n        self.runner.set_option(\"number_of_frames\", 1)\n        self.runner.set_option(\"samples_per_pixel\", 3)\n        self.runner.set_option(\"planar_configuration\", 0)\n        arr = self.runner.reshape(_1frame_3sample_0config)\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n\n        # Test reshape to (rows, cols, planes) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n    def test_1frame_3sample_1conf(self, _1frame_3sample_1config):\n        \"\"\"Test reshaping 1 frame, 3 sample/pixel for 1 planar config.\"\"\"\n        self.runner.set_option(\"number_of_frames\", 1)\n        self.runner.set_option(\"samples_per_pixel\", 3)\n        self.runner.set_option(\"planar_configuration\", 1)\n        arr = self.runner.reshape(_1frame_3sample_1config)\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n\n        # Test reshape to (rows, cols, planes) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n    def test_2frame_1sample(self, _1frame_1sample, _2frame_1sample):\n        \"\"\"Test reshaping 2 frame, 1 sample/pixel.\"\"\"\n        self.runner.set_option(\"number_of_frames\", 2)\n        self.runner.set_option(\"samples_per_pixel\", 1)\n        arr = self.runner.reshape(_2frame_1sample)\n        assert (2, 4, 5) == arr.shape\n        assert np.array_equal(arr, self.ref_2_1)\n\n        # Test reshape to (frames, rows, cols) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n        arr = self.runner.reshape(_1frame_1sample, as_frame=True)\n        assert (4, 5) == arr.shape\n        assert np.array_equal(arr, self.ref_1_1)\n\n    def test_2frame_3sample_0conf(\n        self, _1frame_3sample_0config, _2frame_3sample_0config\n    ):\n        \"\"\"Test reshaping 2 frame, 3 sample/pixel for 0 planar config.\"\"\"\n        self.runner.set_option(\"number_of_frames\", 2)\n        self.runner.set_option(\"samples_per_pixel\", 3)\n        self.runner.set_option(\"planar_configuration\", 0)\n        arr = self.runner.reshape(_2frame_3sample_0config)\n        assert (2, 4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_2_3)\n\n        # Test reshape to (frames, rows, cols, planes) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n        arr = self.runner.reshape(_1frame_3sample_0config, as_frame=True)\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n\n    def test_2frame_3sample_1conf(\n        self, _1frame_3sample_1config, _2frame_3sample_1config\n    ):\n        \"\"\"Test reshaping 2 frame, 3 sample/pixel for 1 planar config.\"\"\"\n        self.runner.set_option(\"number_of_frames\", 2)\n        self.runner.set_option(\"samples_per_pixel\", 3)\n        self.runner.set_option(\"planar_configuration\", 1)\n        arr = self.runner.reshape(_2frame_3sample_1config)\n        assert (2, 4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_2_3)\n\n        # Test reshape to (frames, rows, cols, planes) is view-only\n        buffer = arr.tobytes()\n        out = np.frombuffer(buffer, arr.dtype)\n        assert not out.flags.writeable\n        out = self.runner.reshape(out)\n        assert not out.flags.writeable\n\n        arr = self.runner.reshape(_1frame_3sample_1config, as_frame=True)\n        assert (4, 5, 3) == arr.shape\n        assert np.array_equal(arr, self.ref_1_3)\n\n\nclass TestDecoder:\n    \"\"\"Tests for Decoder\"\"\"\n\n    def test_init(self):\n        \"\"\"Test creating a new Decoder\"\"\"\n        dec = Decoder(ExplicitVRLittleEndian)\n        assert {} == dec._available\n        assert {} == dec._unavailable\n        assert dec.missing_dependencies == []\n        assert dec._validate_plugins() == {}\n        assert dec._decoder is True\n\n    def test_properties(self):\n        \"\"\"Test Decoder properties\"\"\"\n        dec = Decoder(RLELossless)\n        assert RLELossless == dec.UID\n        assert not dec.is_available\n        assert dec.is_encapsulated\n        assert not dec.is_native\n\n    @pytest.mark.skipif(HAVE_NP, reason=\"Numpy is available\")\n    def test_missing_numpy_raises(self):\n        \"\"\"Test as_array() raises if no numpy\"\"\"\n        dec = Decoder(RLELossless)\n\n        msg = \"NumPy is required when converting pixel data to an ndarray\"\n        with pytest.raises(ImportError, match=msg):\n            dec.as_array(None)\n\n        with pytest.raises(ImportError, match=msg):\n            next(dec.iter_array(None))\n\n    def test_buffer(self):\n        \"\"\"Test as_buffer() and iter_buffer()\"\"\"\n        # Functionality test that numpy isn't required\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        buffer, meta = decoder.as_buffer(reference.ds)\n        assert isinstance(buffer, bytes | bytearray)\n        assert isinstance(meta, dict)\n        for buffer, meta in decoder.iter_buffer(reference.ds):\n            assert isinstance(buffer, bytes | bytearray)\n            assert isinstance(meta, dict)\n\n    def test_validate_plugins(self):\n        \"\"\"Test _validate_plugins() with plugins available\"\"\"\n        decoder = get_decoder(RLELossless)\n        msg = (\n            \"No plugin named 'foo' has been added to 'RLELosslessDecoder', \"\n            \"available plugins are\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            decoder._validate_plugins(\"foo\")\n\n\n@pytest.fixture()\ndef enable_logging():\n    original = config.debugging\n    config.debugging = True\n    yield\n    config.debugging = original\n\n\n@pytest.mark.skipif(not HAVE_NP, reason=\"NumPy is not available\")\nclass TestDecoder_Array:\n    \"\"\"Tests for Decoder.as_array() and Decoder.iter_array().\"\"\"\n\n    def test_logging(self, enable_logging, caplog):\n        \"\"\"Test that the logging works during decode\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        with caplog.at_level(logging.DEBUG, logger=\"pydicom\"):\n            decoder.as_array(EXPL_1_1_1F.ds)\n            assert \"DecodeRunner for 'Explicit VR Little Endian'\" in caplog.text\n            assert \"  as_rgb: True\" in caplog.text\n\n        with caplog.at_level(logging.DEBUG, logger=\"pydicom\"):\n            next(decoder.iter_array(EXPL_1_1_1F.ds, as_rgb=False))\n            assert \"DecodeRunner for 'Explicit VR Little Endian'\" in caplog.text\n            assert \"  as_rgb: False\" in caplog.text\n\n    def test_bad_index_raises(self):\n        \"\"\"Test invalid 'index'\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        msg = \"'index' must be greater than or equal to 0\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_array(None, index=-1)\n\n        msg = \"There is insufficient pixel data to contain 11 frames\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_array(EXPL_16_1_10F.ds, index=10)\n\n        msg = \"There is insufficient pixel data to contain 2 frames\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_array(EXPL_8_3_1F_YBR.ds, index=1)\n\n    def test_native_bitpacked_view_warns(self, caplog):\n        \"\"\"Test warning for bit packed data with `view_only`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(EXPL_1_1_1F.ds)\n            assert not caplog.text\n\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(EXPL_1_1_1F.ds, view_only=True)\n\n            assert (\n                \"Unable to return an ndarray that's a view on the original \"\n                \"buffer for bit-packed pixel data\"\n            ) in caplog.text\n\n    def test_native_ybr422_view_warns(self, caplog):\n        \"\"\"Test warning for YBR_FULL_422 data with `view_only`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(EXPL_8_3_1F_YBR422.ds)\n            assert not caplog.text\n\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(EXPL_8_3_1F_YBR422.ds, view_only=True, raw=True)\n\n            assert (\n                \"Unable to return an ndarray that's a view on the original \"\n                \"buffer for uncompressed pixel data with a photometric \"\n                \"interpretation of 'YBR_FULL_422'\"\n            ) in caplog.text\n\n    def test_colorspace_change_view_warns(self, caplog):\n        \"\"\"Test warning for color space change with `view_only`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(EXPL_8_3_1F_YBR.ds, view_only=True)\n\n            assert (\n                \"Unable to return an ndarray that's a view on the original \"\n                \"buffer if applying a color space conversion\"\n            ) in caplog.text\n\n    def test_native_index(self):\n        \"\"\"Test as_array(index=X)\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        reference = EXPL_16_1_10F\n        for index in [0, 4, 9]:\n            arr, meta = decoder.as_array(reference.ds, index=index)\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert meta[\"bits_stored\"] == 12\n\n    def test_native_view_only(self):\n        \"\"\"Test as_array(view_only=True)\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        # Also tests Dataset `src`\n        reference = EXPL_8_3_1F_YBR\n        arr, meta = decoder.as_array(reference.ds, view_only=True, raw=True)\n        assert isinstance(reference.ds.PixelData, bytes)  # immutable\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert not arr.flags.writeable  # read-only\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n\n        # Also tests buffer-like `src`\n        ds = reference.ds\n        opts = {\n            \"rows\": ds.Rows,\n            \"columns\": ds.Columns,\n            \"samples_per_pixel\": ds.SamplesPerPixel,\n            \"photometric_interpretation\": ds.PhotometricInterpretation,\n            \"pixel_representation\": ds.PixelRepresentation,\n            \"bits_allocated\": ds.BitsAllocated,\n            \"bits_stored\": ds.BitsStored,\n            \"number_of_frames\": ds.get(\"NumberOfFrames\", 1),\n            \"planar_configuration\": ds.get(\"PlanarConfiguration\", 0),\n            \"pixel_keyword\": \"PixelData\",\n        }\n\n        arr, _ = decoder.as_array(\n            bytearray(ds.PixelData),  # mutable\n            raw=True,\n            view_only=True,\n            **opts,\n        )\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert arr.flags.writeable  # not read-only\n\n        arr, _ = decoder.as_array(\n            memoryview(ds.PixelData),  # view of an immutable\n            raw=True,\n            view_only=True,\n            **opts,\n        )\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert not arr.flags.writeable  # read-only\n\n        arr, _ = decoder.as_array(\n            memoryview(bytearray(ds.PixelData)),  # view of a mutable\n            raw=True,\n            view_only=True,\n            **opts,\n        )\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert arr.flags.writeable  # not read-only\n\n        # BinaryIO\n        with open(reference.path, \"rb\") as f:\n            f.seek(ds[\"PixelData\"].file_tell)\n            arr, _ = decoder.as_array(\n                f,\n                raw=True,\n                view_only=True,\n                **opts,\n            )\n\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert not arr.flags.writeable  # read-only\n\n    def test_native_excess_frames(self):\n        \"\"\"Test returning excess frame data\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        ds = dcmread(EXPL_16_1_10F.path)\n        ds.NumberOfFrames = 9\n\n        msg = (\n            \"The number of bytes of pixel data is sufficient to contain 10 frames \"\n            r\"which is larger than the given \\(0028,0008\\) 'Number of Frames' \"\n            \"value of 9. The returned data will include these extra frames and if \"\n            \"it's correct then you should update 'Number of Frames' accordingly, \"\n            \"otherwise pass 'allow_excess_frames=False' to return only the first \"\n            \"9 frames.\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            arr, meta = decoder.as_array(ds)\n\n        assert arr.shape == (10, 64, 64)\n        assert meta[\"number_of_frames\"] == 10\n\n        msg = \"contains 8192 bytes of excess padding\"\n        with pytest.warns(UserWarning, match=msg):\n            arr, meta = decoder.as_array(ds, allow_excess_frames=False)\n\n        assert arr.shape == (9, 64, 64)\n        assert meta[\"number_of_frames\"] == 9\n\n    def test_native_from_buffer(self):\n        \"\"\"Test decoding a dataset which uses buffered Pixel Data.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        ds = dcmread(EXPL_16_1_10F.path)\n        ds.PixelData = BytesIO(ds.PixelData)\n        for index in [0, 4, 9]:\n            arr, meta = decoder.as_array(ds, index=index)\n            EXPL_16_1_10F.test(arr, index=index)\n            assert arr.shape == EXPL_16_1_10F.shape[1:]\n            assert arr.dtype == EXPL_16_1_10F.dtype\n            assert arr.flags.writeable\n            assert meta[\"bits_stored\"] == 12\n\n    def test_encapsulated_index(self):\n        \"\"\"Test `index` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n\n        reference = RLE_16_1_10F\n        for index in [0, 4, 9]:\n            arr, meta = decoder.as_array(\n                reference.ds, index=index, decoding_plugin=\"pydicom\"\n            )\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert meta[\"bits_stored\"] == 12\n\n    def test_encapsulated_plugin(self):\n        \"\"\"Test `decoding_plugin` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n\n        reference = RLE_16_1_10F\n        arr, meta = decoder.as_array(reference.ds, decoding_plugin=\"pydicom\")\n        reference.test(arr)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert arr.flags.writeable\n        assert meta[\"bits_stored\"] == 12\n\n    def test_encapsulated_excess_frames(self):\n        \"\"\"Test returning excess frame data\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        frames = [x for x in generate_frames(reference.ds.PixelData)]\n        frames.append(frames[-1])\n        src = encapsulate(frames)\n\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(reference.ds)\n\n        msg = (\n            \"11 frames have been found in the encapsulated pixel data, which is \"\n            r\"larger than the given \\(0028,0008\\) 'Number of Frames' value of 10. \"\n            \"The returned data will include these extra frames and if it's correct \"\n            \"then you should update 'Number of Frames' accordingly, otherwise pass \"\n            \"'allow_excess_frames=False' to return only the first 10 frames.\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            arr, meta = decoder.as_array(src, **runner.options)\n\n        assert arr.shape == (11, 64, 64)\n        assert meta[\"number_of_frames\"] == 11\n\n        runner.set_option(\"allow_excess_frames\", False)\n        arr, meta = decoder.as_array(src, **runner.options)\n        assert arr.shape == (10, 64, 64)\n        assert meta[\"number_of_frames\"] == 10\n\n    def test_encapsulated_from_buffer(self):\n        \"\"\"Test decoding a dataset which uses buffered Pixel Data.\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        ds = dcmread(reference.path)\n        ds.PixelData = BytesIO(ds.PixelData)\n        for index in [0, 4, 9]:\n            arr, meta = decoder.as_array(ds, index=index)\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert meta[\"bits_stored\"] == 12\n\n    def test_processing_colorspace(self):\n        \"\"\"Test the processing colorspace options.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        reference = EXPL_8_3_1F_YBR\n        assert reference.ds.PhotometricInterpretation == PI.YBR_FULL\n\n        msg = \"'force_ybr' and 'force_rgb' cannot both be True\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_array(reference.ds, force_rgb=True, force_ybr=True)\n\n        # as_rgb (default)\n        arr, meta = decoder.as_array(reference.ds)\n        reference.test(arr, as_rgb=True)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert arr.flags.writeable\n        assert meta[\"photometric_interpretation\"] == PI.RGB\n\n        # force_rgb\n        rgb, meta = decoder.as_array(\n            reference.ds,\n            photometric_interpretation=\"RGB\",\n            force_rgb=True,\n        )\n        reference.test(rgb, as_rgb=True)\n        assert meta[\"photometric_interpretation\"] == PI.RGB\n\n        # force_ybr\n        # Test ignores as_rgb\n        ybr, meta = decoder.as_array(reference.ds, as_rgb=False, force_ybr=True)\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        ybr2, meta = decoder.as_array(reference.ds, as_rgb=True, force_ybr=True)\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        assert np.array_equal(ybr, ybr2)\n\n        # Test is actually ybr + ybr = ybr`\n        raw, meta = decoder.as_array(reference.ds, raw=True)\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        out = convert_color_space(ybr, PI.YBR_FULL, PI.RGB)\n        # Lossy conversion, equal to within 1 intensity unit\n        assert np.allclose(out, raw, atol=1)\n\n    def test_expb_ow_view_only_warns(self, caplog):\n        \"\"\"Test view_only with BE swapped OW warns\"\"\"\n        decoder = get_decoder(ExplicitVRBigEndian)\n        reference = EXPB_8_1_1F\n        msg = (\n            \"Unable to return an ndarray that's a view on the original buffer \"\n            \"for 8-bit pixel data encoded as OW with 'Explicit VR Big Endian'\"\n        )\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            decoder.as_array(reference.ds, view_only=True)\n            assert msg in caplog.text\n\n    def test_expb_ow_index_invalid_raises(self):\n        \"\"\"Test invalid index with BE swapped OW raises\"\"\"\n        decoder = get_decoder(ExplicitVRBigEndian)\n        reference = EXPB_8_1_1F\n        msg = \"There is insufficient pixel data to contain 2 frames\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_array(reference.ds, index=1)\n\n    def test_expb_ow(self):\n        \"\"\"Test BE swapped OW\"\"\"\n        decoder = get_decoder(ExplicitVRBigEndian)\n        opts = {\n            \"rows\": 3,\n            \"columns\": 3,\n            \"samples_per_pixel\": 1,\n            \"photometric_interpretation\": \"MONOCHROME1\",\n            \"pixel_representation\": 0,\n            \"bits_allocated\": 8,\n            \"bits_stored\": 8,\n            \"number_of_frames\": 3,\n            \"pixel_keyword\": \"PixelData\",\n            \"pixel_vr\": \"OW\",\n        }\n\n        src = (  #                            | 2_1 | 1_9\n            b\"\\x01\\x00\\x03\\x02\\x05\\x04\\x07\\x06\\x09\\x08\"\n            # 2_2 | 2_3\n            b\"\\x0B\\x0A\\x0D\\x0C\\x0F\\x0E\\x11\\x10\"\n            # 3_1                             | pad | 3_9\n            b\"\\x13\\x12\\x15\\x14\\x17\\x16\\x19\\x18\\x00\\x1A\"\n        )\n        # Test by frame - odd-length\n        arr, _ = decoder.as_array(src, **opts, index=0)\n        assert arr.ravel().tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        arr, _ = decoder.as_array(src, **opts, index=1)\n        assert arr.ravel().tolist() == [9, 10, 11, 12, 13, 14, 15, 16, 17]\n        arr, _ = decoder.as_array(src, **opts, index=2)\n        assert arr.ravel().tolist() == [18, 19, 20, 21, 22, 23, 24, 25, 26]\n\n        # Test all - odd-length\n        opts[\"number_of_frames\"] = 1\n        arr, _ = decoder.as_array(b\"\\x01\\x00\\x03\\x02\\x05\\x04\\x07\\x06\\x00\\x08\", **opts)\n        assert arr.ravel().tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n        # Test all - even-length\n        opts[\"rows\"] = 5\n        opts[\"columns\"] = 2\n        arr, _ = decoder.as_array(b\"\\x01\\x00\\x03\\x02\\x05\\x04\\x07\\x06\\x09\\x08\", **opts)\n        assert arr.ravel().tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        # Test by frame - even length\n        opts[\"number_of_frames\"] = 3\n        arr, _ = decoder.as_array(src + b\"\\x1D\\x1C\", **opts, index=0)\n        assert arr.ravel().tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        arr, _ = decoder.as_array(src + b\"\\x1D\\x1C\", **opts, index=1)\n        assert arr.ravel().tolist() == [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n        arr, _ = decoder.as_array(src + b\"\\x1D\\x1C\", **opts, index=2)\n        assert arr.ravel().tolist() == [20, 21, 22, 23, 24, 25, 26, 0, 28, 29]\n\n    def test_iter_native_indices(self):\n        \"\"\"Test the `indices` argument with native data.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        reference = EXPL_16_1_10F\n\n        indices = [0, 4, 9]\n        func = decoder.iter_array(reference.ds, raw=True, indices=indices)\n        for idx, (arr, meta) in enumerate(func):\n            reference.test(arr, index=indices[idx])\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert arr.shape == reference.shape[1:]\n            assert meta[\"bits_stored\"] == 12\n            assert meta[\"number_of_frames\"] == 1\n\n        assert idx == 2\n\n    def test_iter_native_view_only(self, caplog):\n        \"\"\"Test as_array(view_only=True)\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        reference = EXPL_16_1_10F\n        ds = reference.ds\n        assert ds.BitsAllocated == 16\n        assert ds.BitsStored == 12\n\n        assert isinstance(ds.PixelData, bytes)  # immutable\n        func = decoder.iter_array(ds, view_only=True, raw=True)\n        msg = (\n            \"Unable to return an ndarray that's a view on the original buffer when \"\n            \"(0028,0101) 'Bits Stored' doesn't equal (0028,0100) 'Bits Allocated' \"\n            \"and 'correct_unused_bits=True'. In most cases you can pass \"\n            \"'correct_unused_bits=False' instead to get a view if the uncorrected \"\n            \"array is equivalent to the corrected one.\"\n        )\n        with caplog.at_level(logging.WARNING, logger=\"pydicom\"):\n            arr, _ = next(func)\n            reference.test(arr, index=0)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable  # not a view due to bit-shift\n            assert msg in caplog.text\n\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index + 1)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable  # not a view due to bit-shift\n\n        func = decoder.iter_array(\n            ds, view_only=True, raw=True, correct_unused_bits=False\n        )\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert not arr.flags.writeable  # read-only\n\n        func = decoder.iter_array(\n            bytearray(ds.PixelData),  # mutable\n            raw=True,\n            view_only=True,\n            rows=ds.Rows,\n            columns=ds.Columns,\n            samples_per_pixel=ds.SamplesPerPixel,\n            photometric_interpretation=ds.PhotometricInterpretation,\n            pixel_representation=ds.PixelRepresentation,\n            bits_allocated=ds.BitsAllocated,\n            bits_stored=ds.BitsStored,\n            number_of_frames=ds.get(\"NumberOfFrames\", 1),\n            planar_configuration=ds.get(\"PlanarConfiguration\", 0),\n            pixel_keyword=\"PixelData\",\n        )\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable  # not read-only\n\n        func = decoder.iter_array(\n            memoryview(ds.PixelData),  # view of an immutable\n            raw=True,\n            view_only=True,\n            rows=ds.Rows,\n            columns=ds.Columns,\n            samples_per_pixel=ds.SamplesPerPixel,\n            photometric_interpretation=ds.PhotometricInterpretation,\n            pixel_representation=ds.PixelRepresentation,\n            bits_allocated=ds.BitsAllocated,\n            bits_stored=ds.BitsStored,\n            number_of_frames=ds.get(\"NumberOfFrames\", 1),\n            planar_configuration=ds.get(\"PlanarConfiguration\", 0),\n            pixel_keyword=\"PixelData\",\n            correct_unused_bits=False,\n        )\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert not arr.flags.writeable  # read-only\n\n        func = decoder.iter_array(\n            memoryview(bytearray(ds.PixelData)),  # view of a mutable\n            raw=True,\n            view_only=True,\n            rows=ds.Rows,\n            columns=ds.Columns,\n            samples_per_pixel=ds.SamplesPerPixel,\n            photometric_interpretation=ds.PhotometricInterpretation,\n            pixel_representation=ds.PixelRepresentation,\n            bits_allocated=ds.BitsAllocated,\n            bits_stored=ds.BitsStored,\n            number_of_frames=ds.get(\"NumberOfFrames\", 1),\n            planar_configuration=ds.get(\"PlanarConfiguration\", 0),\n            pixel_keyword=\"PixelData\",\n        )\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index)\n            assert arr.shape == reference.shape[1:]\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable  # not read-only\n\n    def test_iter_encapsulated_indices(self):\n        \"\"\"Test the `indices` argument with encapsulated data.\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n\n        indices = [0, 4, 9]\n        func = decoder.iter_array(\n            reference.ds, raw=True, indices=indices, decoding_plugin=\"pydicom\"\n        )\n        for idx, (arr, meta) in enumerate(func):\n            reference.test(arr, index=indices[idx])\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert arr.shape == reference.shape[1:]\n            assert meta[\"bits_stored\"] == 12\n            assert meta[\"number_of_frames\"] == 1\n\n        assert idx == 2\n\n    def test_iter_encapsulated_plugin(self):\n        \"\"\"Test `decoding_plugin` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n\n        reference = RLE_16_1_10F\n        func = decoder.iter_array(reference.ds, decoding_plugin=\"pydicom\")\n        for index, (arr, _) in enumerate(func):\n            reference.test(arr, index=index)\n            assert arr.dtype == reference.dtype\n            assert arr.flags.writeable\n            assert arr.shape == reference.shape[1:]\n\n    def test_iter_processing(self):\n        \"\"\"Test the processing options.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        reference = EXPL_8_3_1F_YBR\n        assert reference.ds.PhotometricInterpretation == PI.YBR_FULL\n\n        msg = \"'force_ybr' and 'force_rgb' cannot both be True\"\n        with pytest.raises(ValueError, match=msg):\n            next(decoder.iter_array(reference.ds, force_rgb=True, force_ybr=True))\n\n        # as_rgb\n        func = decoder.iter_array(reference.ds)\n        arr, meta = next(func)\n        reference.test(arr, as_rgb=True)\n        assert arr.shape == reference.shape\n        assert arr.dtype == reference.dtype\n        assert arr.flags.writeable\n        assert meta[\"photometric_interpretation\"] == PI.RGB\n\n        # force_rgb\n        func = decoder.iter_array(\n            reference.ds,\n            photometric_interpretation=\"RGB\",\n            force_rgb=True,\n        )\n        rgb, meta = next(func)\n        reference.test(rgb, as_rgb=True)\n        assert meta[\"photometric_interpretation\"] == PI.RGB\n\n        # force_ybr\n        # Test ignores as_rgb\n        ybr, meta = next(decoder.iter_array(reference.ds, as_rgb=False, force_ybr=True))\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        ybr2, meta = next(decoder.iter_array(reference.ds, as_rgb=True, force_ybr=True))\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        assert np.array_equal(ybr, ybr2)\n\n        # Test is actually ybr + ybr = ybr`\n        raw, meta = next(decoder.iter_array(reference.ds, raw=True))\n        assert meta[\"photometric_interpretation\"] == PI.YBR_FULL\n        out = convert_color_space(ybr, PI.YBR_FULL, PI.RGB)\n        # Lossy conversion, equal to within 1 intensity unit\n        assert np.allclose(out, raw, atol=1)\n\n    def test_iter_ybr_to_rgb(self):\n        \"\"\"Test conversion from YBR to RGB for multi-framed data.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        ds = dcmread(EXPL_8_3_1F_YBR.path)\n        ds.PixelData = ds.PixelData * 2\n        ds.NumberOfFrames = 2\n        assert ds.PhotometricInterpretation == PI.YBR_FULL\n\n        for arr, meta in decoder.iter_array(ds):\n            assert meta[\"photometric_interpretation\"] == PI.RGB\n            EXPL_8_3_1F_YBR.test(arr, as_rgb=True)\n\n    def test_iter_planar_configuration(self):\n        \"\"\"Test iter_pixels() with planar configuration.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        ds = dcmread(EXPL_8_3_1F_YBR.path)\n        ds.PixelData = ds.PixelData * 2\n        ds.NumberOfFrames = 2\n        ds.PlanarConfiguration = 1\n\n        # Always 0 when converting to an ndarray\n        for _, meta in decoder.iter_array(ds):\n            assert meta[\"planar_configuration\"] == 0\n\n\n@pytest.mark.skipif(not HAVE_NP, reason=\"NumPy is not available\")\nclass TestDecoder_Buffer:\n    \"\"\"Tests for Decoder.as_buffer() and Decoder.iter_buffer().\"\"\"\n\n    def test_native_index(self):\n        \"\"\"Test `index`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        assert decoder.is_available\n\n        reference = EXPL_16_1_10F\n        for index in [0, 4, 9]:\n            arr, meta_a = decoder.as_array(reference.ds, index=index)\n            buffer, meta_b = decoder.as_buffer(reference.ds, index=index)\n            assert arr.tobytes() == buffer\n            assert meta_a == meta_b\n            assert meta_a[\"number_of_frames\"] == 1\n\n        msg = \"There is insufficient pixel data to contain 11 frames\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_buffer(reference.ds, index=10)\n\n    def test_native_view_only(self):\n        \"\"\"Test `view_only`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        # immutable source buffer\n        # Also tests Dataset `src`\n        reference = EXPL_8_3_1F_YBR\n        arr, meta_a = decoder.as_array(reference.ds, view_only=True, raw=True)\n        buffer, meta_b = decoder.as_buffer(reference.ds, view_only=True, raw=True)\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is reference.ds.PixelData\n        assert meta_a == meta_b\n\n        # mutable source buffer\n        # Also tests buffer-like `src`\n        src = bytearray()\n        src += b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n        opts = {\n            \"raw\": True,\n            \"view_only\": True,\n            \"rows\": 3,\n            \"columns\": 3,\n            \"samples_per_pixel\": 1,\n            \"photometric_interpretation\": PI.MONOCHROME1,\n            \"pixel_representation\": 0,\n            \"bits_allocated\": 8,\n            \"bits_stored\": 8,\n            \"number_of_frames\": 1,\n            \"pixel_keyword\": \"PixelData\",\n        }\n        arr, _ = decoder.as_array(src, **opts)\n        buffer, _ = decoder.as_buffer(src, **opts)\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n        # view of a mutable\n        mview = memoryview(src)\n        arr, _ = decoder.as_array(mview, **opts)\n        buffer, _ = decoder.as_buffer(mview, **opts)\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n        # view of an immutable\n        src = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n        mview = memoryview(src)\n        arr, _ = decoder.as_array(mview, **opts)\n        buffer, _ = decoder.as_buffer(mview, **opts)\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n    def test_native_single_bit_nonaligned(self):\n        \"\"\"Test `as_buffer` with a single bit image whose frame boundaries are\n        not aligned with byte boundaries.\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        assert decoder.is_available\n\n        reference = EXPL_1_1_3F_NONALIGNED\n        full_buffer, _ = decoder.as_buffer(reference.ds)\n\n        full_len = ceil(\n            (\n                reference.ds.Rows\n                * reference.ds.Columns\n                * reference.ds.SamplesPerPixel\n                * reference.ds.NumberOfFrames\n            )\n            / 8\n        )\n        assert len(full_buffer) == full_len\n\n        # When requesting a single frame, the returned buffer will contain some\n        # pixels from neighnoring frames\n        frame_1_buffer, _ = decoder.as_buffer(reference.ds, index=1)\n\n        frame_length_pixels = reference.ds.Rows * reference.ds.Columns\n        assert (\n            frame_1_buffer\n            == full_buffer[frame_length_pixels // 8 : ceil(2 * frame_length_pixels / 8)]\n        )\n\n    def test_encapsulated_index(self):\n        \"\"\"Test `index` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n\n        reference = RLE_16_1_10F\n        for index in [0, 4, 9]:\n            arr, _ = decoder.as_array(reference.ds, index=index)\n            buffer, meta = decoder.as_buffer(reference.ds, index=index)\n            assert isinstance(buffer, bytes | bytearray)\n            assert arr.tobytes() == buffer\n            assert meta[\"bits_stored\"] == 12\n            assert meta[\"number_of_frames\"] == 1\n\n    def test_encapsulated_plugin(self):\n        \"\"\"Test `decoding_plugin` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        arr, _ = decoder.as_array(reference.ds, decoding_plugin=\"pydicom\")\n        buffer, _ = decoder.as_buffer(reference.ds, decoding_plugin=\"pydicom\")\n        assert isinstance(buffer, bytes | bytearray)\n        assert arr.tobytes() == buffer\n\n    def test_encapsulated_invalid_decode_raises(self):\n        \"\"\"Test invalid decode raises\"\"\"\n        decoder = Decoder(RLELossless)\n        reference = RLE_16_1_10F\n\n        def foo(src, opts):\n            return b\"\\x00\\x01\"\n\n        msg = (\n            \"Unexpected number of bytes in the decoded frame with index 0 \"\n            r\"\\(2 bytes actual vs 8192 expected\\)\"\n        )\n        decoder._available = {\"foo\": foo}\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_buffer(reference.ds)\n\n        msg = (\n            \"Unexpected number of bytes in the decoded frame with index 9 \"\n            r\"\\(2 bytes actual vs 8192 expected\\)\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_buffer(reference.ds, index=9)\n\n    def test_encapsulated_excess_frames(self):\n        \"\"\"Test returning excess frame data\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        frames = [x for x in generate_frames(reference.ds.PixelData)]\n        frames.append(frames[-1])\n        src = encapsulate(frames)\n\n        runner = DecodeRunner(RLELossless)\n        runner.set_source(reference.ds)\n\n        msg = (\n            \"11 frames have been found in the encapsulated pixel data, which is \"\n            r\"larger than the given \\(0028,0008\\) 'Number of Frames' value of 10. \"\n            \"The returned data will include these extra frames and if it's correct \"\n            \"then you should update 'Number of Frames' accordingly, otherwise pass \"\n            \"'allow_excess_frames=False' to return only the first 10 frames.\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            buffer, meta = decoder.as_buffer(src, **runner.options)\n\n        assert len(buffer) == 11 * 64 * 64 * 2\n        assert meta[\"number_of_frames\"] == 11\n\n        runner.set_option(\"allow_excess_frames\", False)\n        buffer, meta = decoder.as_buffer(src, **runner.options)\n        assert len(buffer) == 10 * 64 * 64 * 2\n        assert meta[\"number_of_frames\"] == 10\n\n    def test_expb_ow_index_invalid_raises(self):\n        \"\"\"Test invalid index with BE swapped OW raises\"\"\"\n        decoder = get_decoder(ExplicitVRBigEndian)\n        reference = EXPB_8_1_1F\n        msg = \"There is insufficient pixel data to contain 2 frames\"\n        with pytest.raises(ValueError, match=msg):\n            decoder.as_buffer(reference.ds, index=1)\n\n    def test_expb_ow_index_odd_length(self):\n        \"\"\"Test index with odd length BE swapped OW\"\"\"\n        decoder = get_decoder(ExplicitVRBigEndian)\n        opts = {\n            \"rows\": 3,\n            \"columns\": 3,\n            \"samples_per_pixel\": 1,\n            \"photometric_interpretation\": \"MONOCHROME1\",\n            \"pixel_representation\": 0,\n            \"bits_allocated\": 8,\n            \"bits_stored\": 8,\n            \"number_of_frames\": 3,\n            \"pixel_keyword\": \"PixelData\",\n            \"pixel_vr\": \"OW\",\n        }\n\n        src = (  #                            | 2_1 | 1_9\n            b\"\\x01\\x00\\x03\\x02\\x05\\x04\\x07\\x06\\x09\\x08\"\n            # 2_2 | 2_3\n            b\"\\x0B\\x0A\\x0D\\x0C\\x0F\\x0E\\x11\\x10\"\n            # 3_1                             | pad | 3_9\n            b\"\\x13\\x12\\x15\\x14\\x17\\x16\\x19\\x18\\x00\\x1A\"\n        )\n        # Includes +1 at end\n        buffer, _ = decoder.as_buffer(src, **opts, index=0)\n        assert buffer == b\"\\x01\\x00\\x03\\x02\\x05\\x04\\x07\\x06\\x09\\x08\"\n        # Includes -1 at start\n        buffer, _ = decoder.as_buffer(src, **opts, index=1)\n        assert buffer == b\"\\x09\\x08\\x0B\\x0A\\x0D\\x0C\\x0F\\x0E\\x11\\x10\"\n        # Includes +1 at end\n        buffer, _ = decoder.as_buffer(src, **opts, index=2)\n        assert buffer == b\"\\x13\\x12\\x15\\x14\\x17\\x16\\x19\\x18\\x00\\x1A\"\n\n    def test_iter_native_indices(self):\n        \"\"\"Test `index`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n        reference = EXPL_16_1_10F\n\n        indices = [0, 4, 9]\n        arr_func = decoder.iter_array(reference.ds, indices=indices)\n        buf_func = decoder.iter_buffer(reference.ds, indices=indices)\n        for idx, ((arr, _), (buffer, _)) in enumerate(zip(arr_func, buf_func)):\n            assert isinstance(buffer, bytes | bytearray)\n            assert arr.tobytes() == buffer\n\n        assert idx == 2\n\n    def test_iter_native_view_only(self):\n        \"\"\"Test `view_only`\"\"\"\n        decoder = get_decoder(ExplicitVRLittleEndian)\n\n        # immutable source buffer\n        # Also tests Dataset `src`\n        reference = EXPL_8_3_1F_YBR\n        arr, _ = next(decoder.iter_array(reference.ds, view_only=True, raw=True))\n        buffer, _ = next(decoder.iter_buffer(reference.ds, view_only=True, raw=True))\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is reference.ds.PixelData\n\n        # mutable source buffer\n        # Also tests buffer-like `src`\n        src = bytearray()\n        src += b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n        opts = {\n            \"raw\": True,\n            \"view_only\": True,\n            \"rows\": 3,\n            \"columns\": 3,\n            \"samples_per_pixel\": 1,\n            \"photometric_interpretation\": PI.MONOCHROME1,\n            \"pixel_representation\": 0,\n            \"bits_allocated\": 8,\n            \"bits_stored\": 8,\n            \"number_of_frames\": 1,\n            \"pixel_keyword\": \"PixelData\",\n        }\n        arr, _ = next(decoder.iter_array(src, **opts))\n        buffer, _ = next(decoder.iter_buffer(src, **opts))\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n        # view of a mutable\n        mview = memoryview(src)\n        arr, _ = next(decoder.iter_array(mview, **opts))\n        buffer, _ = next(decoder.iter_buffer(mview, **opts))\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n        # view of an immutable\n        src = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\"\n        mview = memoryview(src)\n        arr, _ = next(decoder.iter_array(mview, **opts))\n        buffer, _ = next(decoder.iter_buffer(mview, **opts))\n        assert isinstance(buffer, memoryview)\n        assert arr.tobytes() == buffer\n        assert buffer.obj is src\n\n    def test_iter_encapsulated_indices(self):\n        \"\"\"Test `indices` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        indices = [0, 4, 9]\n        arr_func = decoder.iter_array(reference.ds, indices=indices)\n        buf_func = decoder.iter_buffer(reference.ds, indices=indices)\n        for idx, ((arr, _), (buffer, _)) in enumerate(zip(arr_func, buf_func)):\n            assert isinstance(buffer, bytes | bytearray)\n            assert arr.tobytes() == buffer\n\n    def test_iter_encapsulated_plugin(self):\n        \"\"\"Test `decoding_plugin` with an encapsulated pixel data.\"\"\"\n        decoder = get_decoder(RLELossless)\n        reference = RLE_16_1_10F\n        arr, _ = next(decoder.iter_array(reference.ds, decoding_plugin=\"pydicom\"))\n        buffer, _ = next(decoder.iter_buffer(reference.ds, decoding_plugin=\"pydicom\"))\n        assert isinstance(buffer, bytes | bytearray)\n        assert arr.tobytes() == buffer\n\n\ndef test_get_decoder():\n    \"\"\"Test get_decoder()\"\"\"\n    uids = [\n        ExplicitVRLittleEndian,\n        ImplicitVRLittleEndian,\n        DeflatedExplicitVRLittleEndian,\n        ExplicitVRBigEndian,\n        RLELossless,\n    ]\n    for uid in uids:\n        decoder = get_decoder(uid)\n        assert isinstance(decoder, Decoder)\n        assert decoder.UID == uid\n\n    msg = (\n        \"No pixel data decoders have been implemented for 'SMPTE ST 2110-30 \"\n        \"PCM Digital Audio'\"\n    )\n    with pytest.raises(NotImplementedError, match=msg):\n        get_decoder(SMPTEST211030PCMDigitalAudio)\n",
  "GT_file_code": {
    "modified_testcases/pixels/pixels_reference.py": "from collections.abc import Callable\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\ntry:\n    import numpy as np\n\n    HAVE_NP = True\nexcept ImportError:\n    HAVE_NP = False\n\nfrom pydicom.data import get_testdata_file\nfrom pydicom.uid import (\n    ExplicitVRLittleEndian,\n    ImplicitVRLittleEndian,\n    DeflatedExplicitVRLittleEndian,\n    ExplicitVRBigEndian,\n    JPEGBaseline8Bit,\n    JPEGExtended12Bit,\n    JPEGLossless,\n    JPEGLosslessSV1,\n    JPEGLSLossless,\n    JPEGLSNearLossless,\n    JPEG2000Lossless,\n    JPEG2000,\n    HTJ2KLossless,\n    HTJ2KLosslessRPCL,\n    HTJ2K,\n    RLELossless,\n)\n\nif TYPE_CHECKING:\n    from pydicom import Dataset\n\n\nclass PixelReference:\n    def __init__(\n        self,\n        name: str,\n        dtype: str,\n        test: Callable[[\"PixelReference\", \"np.ndarray\", dict[str, Any]], None],\n    ) -> None:\n        self.name = name\n        self.dtype = dtype\n        self._ds: Dataset\n        self._test = test\n\n    @property\n    def ds(self) -> \"Dataset\":\n        \"\"\"Return the dataset containing the pixel data\"\"\"\n        if getattr(self, \"_ds\", None) is None:\n            self._ds = get_testdata_file(self.name, read=True)\n\n        return self._ds\n\n    @property\n    def number_of_frames(self) -> int:\n        \"\"\"Return the expected number of frames of pixel data\"\"\"\n        value = self.ds.get(\"NumberOfFrames\", 1)\n        value = int(value) if isinstance(value, str) else value\n        if value in (None, 0):\n            value = 1\n\n        return value\n\n    @property\n    def meta(self) -> list[str | int]:\n        \"\"\"Return a list of pixel metadata.\"\"\"\n        attr = [\n            self.ds.file_meta.TransferSyntaxUID,\n            self.ds.BitsAllocated,\n            self.ds.BitsStored,\n            self.ds.Rows,\n            self.ds.Columns,\n            self.ds.SamplesPerPixel,\n            self.number_of_frames,\n            self.ds.PhotometricInterpretation,\n            self.ds[self.pixel_keyword].VR,\n        ]\n        if self.pixel_keyword == \"PixelData\":\n            attr.append(self.ds.PixelRepresentation)\n\n        return attr\n\n    @property\n    def path(self) -> Path:\n        return Path(get_testdata_file(self.name))\n\n    @property\n    def pixel_keyword(self) -> str:\n        \"\"\"Return the keyword used by the pixel data.\"\"\"\n        if \"PixelData\" in self.ds:\n            return \"PixelData\"\n\n        if \"FloatPixelData\" in self.ds:\n            return \"FloatPixelData\"\n\n        if \"DoubleFloatPixelData\" in self.ds:\n            return \"DoubleFloatPixelData\"\n\n        return \"\"\n\n    @property\n    def shape(self) -> tuple[int, ...]:\n        \"\"\"Return the expected array shape.\"\"\"\n        shape = []\n        if self.number_of_frames > 1:\n            shape.append(self.number_of_frames)\n\n        shape += [self.ds.Rows, self.ds.Columns]\n        if self.ds.SamplesPerPixel > 1:\n            shape.append(self.ds.SamplesPerPixel)\n\n        return tuple(shape)\n\n    def __str__(self) -> str:\n        \"\"\"Return a string representation of the pixel reference.\"\"\"\n        s = [\n            self.name,\n            f\"  Transfer Syntax: {self.ds.file_meta.TransferSyntaxUID.name}\",\n            f\"  BitsAllocated: {self.ds.BitsAllocated}\",\n            f\"  BitsStored: {self.ds.BitsStored}\",\n            f\"  Rows: {self.ds.Rows}\",\n            f\"  Columns: {self.ds.Columns}\",\n            f\"  SamplesPerPixel: {self.ds.SamplesPerPixel}\",\n            f\"  NumberOfFrames: {self.number_of_frames}\",\n            f\"  PhotometricInterpretation: {self.ds.PhotometricInterpretation}\",\n            f\"  Pixel VR: {self.ds[self.pixel_keyword].VR}\",\n        ]\n        if self.pixel_keyword == \"PixelData\":\n            s.append(f\"  PixelRepresentation: {self.ds.PixelRepresentation}\")\n\n        return \"\\n\".join(s)\n\n    def test(self, arr: \"np.ndarray\", **kwargs: dict[str, Any]) -> None:\n        self._test(self, arr, **kwargs)\n\n\nPIXEL_REFERENCE = {}\n\n\n# Little endian native datasets\n# EXPL: ExplicitVRLittleEndian\n# IMPL: ImplicitVRLittleEndian\n# DEFL: DeflatedExplicitVRLittleEndian\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n\n\n# EXPL, (1, 1), (1, 512, 512, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert (0, 1, 1) == tuple(arr[155, 180:183])\n    assert (1, 0, 1, 0) == tuple(arr[155, 310:314])\n    assert (0, 1, 1) == tuple(arr[254, 78:81])\n    assert (1, 0, 0, 1, 1, 0) == tuple(arr[254, 304:310])\n\n\nEXPL_1_1_1F = PixelReference(\"liver_1frame.dcm\", \"u1\", test)\n\n\n# EXPL, (1, 1), (3, 512, 512, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    assert arr.max() == 1\n    assert arr.min() == 0\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 0 == frame[0][0]\n        assert (0, 1, 1) == tuple(frame[155, 180:183])\n        assert (1, 0, 1, 0) == tuple(frame[155, 310:314])\n        assert (0, 1, 1) == tuple(frame[254, 78:81])\n        assert (1, 0, 0, 1, 1, 0) == tuple(frame[254, 304:310])\n\n    # Frame 2\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 1 == frame[256][256]\n        assert 0 == frame[146, :254].max()\n        assert (0, 1, 1, 1, 1, 1, 0, 1) == tuple(frame[146, 253:261])\n        assert 0 == frame[146, 261:].max()\n        assert 0 == frame[210, :97].max()\n        assert 1 == frame[210, 97:350].max()\n        assert 0 == frame[210, 350:].max()\n\n    # Frame 3\n    if index in (None, 2):\n        frame = arr if index == 2 else arr[2]\n        assert 0 == frame[-1][-1]\n        assert 0 == frame[147, :249].max()\n        assert (0, 1, 0, 1, 1, 1) == tuple(frame[147, 248:254])\n        assert (1, 0, 1, 0, 1, 1) == tuple(frame[147, 260:266])\n        assert 0 == frame[147, 283:].max()\n        assert 0 == frame[364, :138].max()\n        assert (0, 1, 0, 1, 1, 0, 0, 1) == tuple(frame[364, 137:145])\n        assert (1, 0, 0, 1, 0) == tuple(frame[364, 152:157])\n        assert 0 == frame[364, 157:].max()\n\n\nEXPL_1_1_3F = PixelReference(\"liver.dcm\", \"u1\", test)\n\n\n# Same image cropped from 512 x 512 to 510 x 511 such that frame boundaries are\n# no longer aligned with byte boundaries\nEXPL_1_1_3F_NONALIGNED = PixelReference(\"liver_nonbyte_aligned.dcm\", \"u1\", test)\n\n\n# DEFL, (8, 8), (1, 512, 512, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert 41 == arr[10].min()\n    assert 255 == arr[10].max()\n    assert (138, 65, 65, 65, 65, 35, 35, 35) == tuple(arr[300, 255:263])\n    assert 65 == arr[500].min()\n    assert 219 == arr[500].max()\n\n\nDEFL_8_1_1F = PixelReference(\"image_dfl.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (1, 600, 800, 1), OW, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[0].min() == arr[0].max()\n    assert (1, 246, 1) == tuple(arr[300, 491:494])\n    assert 0 == arr[-1].min() == arr[-1].max()\n\n\nEXPL_8_1_1F = PixelReference(\"OBXXXX1A.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (2, 600, 800, 1), OW, PALETTE COLOR, \"u1\"\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max()\n        assert (1, 246, 1) == tuple(frame[300, 491:494])\n        assert 0 == frame[-1].min() == frame[-1].max()\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert (254, 9, 254) == tuple(frame[300, 491:494])\n        assert 255 == frame[-1].min() == frame[-1].max()\n\n\nEXPL_8_1_2F = PixelReference(\"OBXXXX1A_2frame.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (255, 0, 0) == tuple(arr[5, 50, :])\n    assert (255, 128, 128) == tuple(arr[15, 50, :])\n    assert (0, 255, 0) == tuple(arr[25, 50, :])\n    assert (128, 255, 128) == tuple(arr[35, 50, :])\n    assert (0, 0, 255) == tuple(arr[45, 50, :])\n    assert (128, 128, 255) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (64, 64, 64) == tuple(arr[75, 50, :])\n    assert (192, 192, 192) == tuple(arr[85, 50, :])\n    assert (255, 255, 255) == tuple(arr[95, 50, :])\n\n\nEXPL_8_3_1F = PixelReference(\"SC_rgb.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (1, 3, 3, 3), OW, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert arr[0].tolist() == [\n        [166, 141, 52],\n        [166, 141, 52],\n        [166, 141, 52],\n    ]\n    assert arr[1].tolist() == [\n        [63, 87, 176],\n        [63, 87, 176],\n        [63, 87, 176],\n    ]\n    assert arr[2].tolist() == [\n        [158, 158, 158],\n        [158, 158, 158],\n        [158, 158, 158],\n    ]\n\n\nEXPL_8_3_1F_ODD = PixelReference(\"SC_rgb_small_odd.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (1, 100, 100, 3), OB, YBR_FULL_422, 0\ndef test(ref, arr, **kwargs):\n    assert (76, 85, 255) == tuple(arr[5, 50, :])\n    assert (166, 106, 193) == tuple(arr[15, 50, :])\n    assert (150, 46, 20) == tuple(arr[25, 50, :])\n    assert (203, 86, 75) == tuple(arr[35, 50, :])\n    assert (29, 255, 107) == tuple(arr[45, 50, :])\n    assert (142, 193, 118) == tuple(arr[55, 50, :])\n    assert (0, 128, 128) == tuple(arr[65, 50, :])\n    assert (64, 128, 128) == tuple(arr[75, 50, :])\n    assert (192, 128, 128) == tuple(arr[85, 50, :])\n    assert (255, 128, 128) == tuple(arr[95, 50, :])\n\n\nEXPL_8_3_1F_YBR422 = PixelReference(\"SC_ybr_full_422_uncompressed.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8),  (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    if kwargs.get(\"as_rgb\"):\n        assert (254, 0, 0) == tuple(arr[5, 50, :])\n        assert (255, 127, 127) == tuple(arr[15, 50, :])\n        assert (0, 255, 5) == tuple(arr[25, 50, :])\n        assert (129, 255, 129) == tuple(arr[35, 50, :])\n        assert (0, 0, 254) == tuple(arr[45, 50, :])\n        assert (128, 127, 255) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (64, 64, 64) == tuple(arr[75, 50, :])\n        assert (192, 192, 192) == tuple(arr[85, 50, :])\n        assert (255, 255, 255) == tuple(arr[95, 50, :])\n    else:\n        assert (76, 85, 255) == tuple(arr[5, 50, :])\n        assert (166, 106, 193) == tuple(arr[15, 50, :])\n        assert (150, 46, 20) == tuple(arr[25, 50, :])\n        assert (203, 86, 75) == tuple(arr[35, 50, :])\n        assert (29, 255, 107) == tuple(arr[45, 50, :])\n        assert (142, 193, 118) == tuple(arr[55, 50, :])\n        assert (0, 128, 128) == tuple(arr[65, 50, :])\n        assert (64, 128, 128) == tuple(arr[75, 50, :])\n        assert (192, 128, 128) == tuple(arr[85, 50, :])\n        assert (255, 128, 128) == tuple(arr[95, 50, :])\n\n\nEXPL_8_3_1F_YBR = PixelReference(\"SC_ybr_full_uncompressed.dcm\", \"u1\", test)\n\n\n# EXPL, (8, 8), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (255, 0, 0) == tuple(frame[5, 50, :])\n        assert (255, 128, 128) == tuple(frame[15, 50, :])\n        assert (0, 255, 0) == tuple(frame[25, 50, :])\n        assert (128, 255, 128) == tuple(frame[35, 50, :])\n        assert (0, 0, 255) == tuple(frame[45, 50, :])\n        assert (128, 128, 255) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (64, 64, 64) == tuple(frame[75, 50, :])\n        assert (192, 192, 192) == tuple(frame[85, 50, :])\n        assert (255, 255, 255) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 255, 255) == tuple(frame[5, 50, :])\n        assert (0, 127, 127) == tuple(frame[15, 50, :])\n        assert (255, 0, 255) == tuple(frame[25, 50, :])\n        assert (127, 0, 127) == tuple(frame[35, 50, :])\n        assert (255, 255, 0) == tuple(frame[45, 50, :])\n        assert (127, 127, 0) == tuple(frame[55, 50, :])\n        assert (255, 255, 255) == tuple(frame[65, 50, :])\n        assert (191, 191, 191) == tuple(frame[75, 50, :])\n        assert (63, 63, 63) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPL_8_3_2F = PixelReference(\"SC_rgb_2frame.dcm\", \"u1\", test)\n\n\n# IMPL, (8, 8), (1, 256, 256, 3), OW, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert arr[29, 77:81].tolist() == [\n        [240, 243, 246],\n        [214, 210, 213],\n        [150, 134, 134],\n        [244, 244, 244],\n    ]\n    assert arr[224:227, 253].tolist() == [\n        [231, 236, 238],\n        [190, 175, 178],\n        [215, 200, 202],\n    ]\n\n\nIMPL_08_08_3_0_1F_RGB = PixelReference(\"SC_rgb_jpeg_dcmd.dcm\", \"u1\", test)\n\n\n# EXPL, (16, 16), (1, 128, 128, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert arr[24, 36:40].tolist() == [520, 802, 930, 1008]\n    assert arr[40:45, 40].tolist() == [1138, 1165, 1113, 1088, 1072]\n\n\nEXPL_16_16_1F = PixelReference(\"CT_small.dcm\", \"<i2\", test)\n\n\n# IMPL, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    # Last pixel\n    assert 862 == arr[-1, -1]\n\n\nIMPL_16_1_1F = PixelReference(\"MR_small_implicit.dcm\", \"<i2\", test)\n\n\n# EXPL, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    # Last pixel\n    assert 862 == arr[-1, -1]\n\n\nEXPL_16_1_1F = PixelReference(\"MR_small.dcm\", \"<i2\", test)\n\n\n# EXPL, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\n# Pixel Data with 128 bytes trailing padding\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    # Last pixel\n    assert 862 == arr[-1, -1]\n\n\nEXPL_16_1_1F_PAD = PixelReference(\"MR_small_padded.dcm\", \"<i2\", test)\n\n\n# EXPL, (16, 12), (10, 64, 64, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (206, 197, 159) == tuple(frame[0, 31:34])\n        assert (49, 78, 128) == tuple(frame[31, :3])\n        assert (362, 219, 135) == tuple(frame[-1, -3:])\n\n    # Frame 5\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert (67, 82, 44) == tuple(frame[0, 31:34])\n        assert (37, 41, 17) == tuple(frame[31, :3])\n        assert (225, 380, 355) == tuple(frame[-1, -3:])\n\n    # Frame 10\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert (72, 86, 69) == tuple(frame[0, 31:34])\n        assert (25, 4, 9) == tuple(frame[31, :3])\n        assert (227, 300, 147) == tuple(frame[-1, -3:])\n\n\nEXPL_16_1_10F = PixelReference(\"emri_small.dcm\", \"<u2\", test)\n\n\n# EXPL, (16, 16), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (65535, 0, 0) == tuple(arr[5, 50, :])\n    assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n    assert (0, 65535, 0) == tuple(arr[25, 50, :])\n    assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n    assert (0, 0, 65535) == tuple(arr[45, 50, :])\n    assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n    assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n    assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\n\n\nEXPL_16_3_1F = PixelReference(\"SC_rgb_16bit.dcm\", \"<u2\", test)\n\n\n# EXPL, (16, 16), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (65535, 0, 0) == tuple(frame[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(frame[15, 50, :])\n        assert (0, 65535, 0) == tuple(frame[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(frame[35, 50, :])\n        assert (0, 0, 65535) == tuple(frame[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(frame[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(frame[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 65535, 65535) == tuple(frame[5, 50, :])\n        assert (0, 32639, 32639) == tuple(frame[15, 50, :])\n        assert (65535, 0, 65535) == tuple(frame[25, 50, :])\n        assert (32639, 0, 32639) == tuple(frame[35, 50, :])\n        assert (65535, 65535, 0) == tuple(frame[45, 50, :])\n        assert (32639, 32639, 0) == tuple(frame[55, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[65, 50, :])\n        assert (49087, 49087, 49087) == tuple(frame[75, 50, :])\n        assert (16191, 16191, 16191) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPL_16_3_2F = PixelReference(\"SC_rgb_16bit_2frame.dcm\", \"<u2\", test)\n\n\n# IMPL, (32, 32), (1, 10, 10, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n    assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n    assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\n\n\nIMPL_32_1_1F = PixelReference(\"rtdose_1frame.dcm\", \"<u4\", test)\n\n\n# IMPL, (32, 32), (15, 10, 10, 1), OW, MONOCHROME2,\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\")\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (1249000, 1249000, 1250000) == tuple(frame[0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(frame[4, 3:6])\n        assert (803000, 801000, 798000) == tuple(frame[-1, -3:])\n\n    # Frame 8\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert (1253000, 1253000, 1249000) == tuple(frame[0, :3])\n        assert (1026000, 1023000, 1022000) == tuple(frame[4, 3:6])\n        assert (803000, 803000, 803000) == tuple(frame[-1, -3:])\n\n    # Frame 15\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert (1249000, 1250000, 1251000) == tuple(frame[0, :3])\n        assert (1031000, 1031000, 1031000) == tuple(frame[4, 3:6])\n        assert (801000, 800000, 799000) == tuple(frame[-1, -3:])\n\n\nIMPL_32_1_15F = PixelReference(\"rtdose.dcm\", \"<u4\", test)\n\n\n# EXPL, (32, 32), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (4294967295, 0, 0) == tuple(arr[5, 50, :])\n    assert (4294967295, 2155905152, 2155905152) == tuple(arr[15, 50, :])\n    assert (0, 4294967295, 0) == tuple(arr[25, 50, :])\n    assert (2155905152, 4294967295, 2155905152) == tuple(arr[35, 50, :])\n    assert (0, 0, 4294967295) == tuple(arr[45, 50, :])\n    assert (2155905152, 2155905152, 4294967295) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (1077952576, 1077952576, 1077952576) == tuple(arr[75, 50, :])\n    assert (3233857728, 3233857728, 3233857728) == tuple(arr[85, 50, :])\n    assert (4294967295, 4294967295, 4294967295) == tuple(arr[95, 50, :])\n\n\nEXPL_32_3_1F = PixelReference(\"SC_rgb_32bit.dcm\", \"<u4\", test)\n\n\n# EXPL, (32, 32), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (4294967295, 0, 0) == tuple(frame[5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(frame[15, 50, :])\n        assert (0, 4294967295, 0) == tuple(frame[25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(frame[35, 50, :])\n        assert (0, 0, 4294967295) == tuple(frame[45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(frame[75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(frame[85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 4294967295, 4294967295) == tuple(frame[5, 50, :])\n        assert (0, 2139062143, 2139062143) == tuple(frame[15, 50, :])\n        assert (4294967295, 0, 4294967295) == tuple(frame[25, 50, :])\n        assert (2139062143, 0, 2139062143) == tuple(frame[35, 50, :])\n        assert (4294967295, 4294967295, 0) == tuple(frame[45, 50, :])\n        assert (2139062143, 2139062143, 0) == tuple(frame[55, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[65, 50, :])\n        assert (3217014719, 3217014719, 3217014719) == tuple(frame[75, 50, :])\n        assert (1061109567, 1061109567, 1061109567) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPL_32_3_2F = PixelReference(\"SC_rgb_32bit_2frame.dcm\", \"<u4\", test)\n\n\n# EXPL, (32, NA), (1, 128, 128, 1), OD, MONOCHROME2\n# Float Pixel Data\ndef test(ref, arr, **kwargs):\n    assert [0.92012787, 0.91510725, 0.9160201, 0.92104053] == [\n        round(x, 8) for x in arr[:4, 0]\n    ]\n\n\nEXPL_32_1F_FLOAT = PixelReference(\"parametric_map_float.dcm\", \"<f4\", test)\n\n\n# EXPL, (64, NA), (1, 128, 128, 1), OD, MONOCHROME2\n# Double Float Pixel Data\ndef test(ref, arr, **kwargs):\n    assert [0.9201278, 0.91510726, 0.91602008, 0.92104062] == [\n        round(x, 8) for x in arr[:4, 0]\n    ]\n\n\nEXPL_64_1F_DOUBLE_FLOAT = PixelReference(\"parametric_map_double_float.dcm\", \"<f8\", test)\n\n\nPIXEL_REFERENCE[ExplicitVRLittleEndian] = [\n    EXPL_1_1_1F,\n    EXPL_1_1_3F,\n    EXPL_1_1_3F_NONALIGNED,\n    EXPL_8_1_1F,\n    EXPL_8_1_2F,\n    EXPL_8_3_1F,\n    EXPL_8_3_1F_ODD,\n    EXPL_8_3_1F_YBR422,\n    EXPL_8_3_1F_YBR,\n    EXPL_8_3_2F,\n    EXPL_16_16_1F,\n    EXPL_16_1_1F,\n    EXPL_16_1_1F_PAD,\n    EXPL_16_1_10F,\n    EXPL_16_3_1F,\n    EXPL_16_3_2F,\n    EXPL_32_3_1F,\n    EXPL_32_3_2F,\n    EXPL_32_1F_FLOAT,  # Float Pixel Data\n    EXPL_64_1F_DOUBLE_FLOAT,  # Double Float Pixel Data\n]\nPIXEL_REFERENCE[ImplicitVRLittleEndian] = [\n    IMPL_08_08_3_0_1F_RGB,\n    IMPL_16_1_1F,\n    IMPL_32_1_1F,\n    IMPL_32_1_15F,\n]\nPIXEL_REFERENCE[DeflatedExplicitVRLittleEndian] = [DEFL_8_1_1F]\n\n\n# Big endian datasets\n# EXPB: ExplicitVRBigEndian\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n\n\n# EXPB, (1, 1), (1, 512, 512, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert 0 == arr.min()\n    assert 1 == arr.max()\n    assert tuple(arr[145, 250:260]) == (0, 0, 0, 0, 1, 1, 1, 1, 1, 0)\n\n\nEXPB_1_1_1F = PixelReference(\"liver_expb_1frame.dcm\", \"u1\", test)\n\n\n# EXPB, (1, 1), (3, 512, 512, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    assert arr.max() == 1\n    assert arr.min() == 0\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 0 == frame[0][0]\n        assert (0, 1, 1) == tuple(frame[155, 180:183])\n        assert (1, 0, 1, 0) == tuple(frame[155, 310:314])\n        assert (0, 1, 1) == tuple(frame[254, 78:81])\n        assert (1, 0, 0, 1, 1, 0) == tuple(frame[254, 304:310])\n\n    # Frame 2\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 1 == frame[256][256]\n        assert 0 == frame[146, :254].max()\n        assert (0, 1, 1, 1, 1, 1, 0, 1) == tuple(frame[146, 253:261])\n        assert 0 == frame[146, 261:].max()\n        assert 0 == frame[210, :97].max()\n        assert 1 == frame[210, 97:350].max()\n        assert 0 == frame[210, 350:].max()\n\n    # Frame 3\n    if index in (None, 2):\n        frame = arr if index == 2 else arr[2]\n        assert 0 == frame[147, :249].max()\n        assert 0 == frame[511][511]\n        assert (0, 1, 0, 1, 1, 1) == tuple(frame[147, 248:254])\n        assert (1, 0, 1, 0, 1, 1) == tuple(frame[147, 260:266])\n        assert 0 == frame[147, 283:].max()\n        assert 0 == frame[364, :138].max()\n        assert (0, 1, 0, 1, 1, 0, 0, 1) == tuple(frame[364, 137:145])\n        assert (1, 0, 0, 1, 0) == tuple(frame[364, 152:157])\n        assert 0 == frame[364, 157:].max()\n\n\nEXPB_1_1_3F = PixelReference(\"liver_expb.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (1, 600, 800, 1), OW, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[0].min() == arr[0].max()\n    assert (1, 246, 1) == tuple(arr[300, 491:494])\n    assert 0 == arr[-1].min() == arr[-1].max()\n\n\nEXPB_8_1_1F = PixelReference(\"OBXXXX1A_expb.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (2, 600, 800, 1), OW, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max()\n        assert (1, 246, 1) == tuple(frame[300, 491:494])\n        assert 0 == frame[-1].min() == frame[-1].max()\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert (254, 9, 254) == tuple(frame[300, 491:494])\n        assert 255 == frame[-1].min() == frame[-1].max()\n\n\nEXPB_8_1_2F = PixelReference(\"OBXXXX1A_expb_2frame.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (255, 0, 0) == tuple(arr[5, 50, :])\n    assert (255, 128, 128) == tuple(arr[15, 50, :])\n    assert (0, 255, 0) == tuple(arr[25, 50, :])\n    assert (128, 255, 128) == tuple(arr[35, 50, :])\n    assert (0, 0, 255) == tuple(arr[45, 50, :])\n    assert (128, 128, 255) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (64, 64, 64) == tuple(arr[75, 50, :])\n    assert (192, 192, 192) == tuple(arr[85, 50, :])\n    assert (255, 255, 255) == tuple(arr[95, 50, :])\n\n\nEXPB_8_3_1F = PixelReference(\"SC_rgb_expb.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (1, 3, 3, 3), OW, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [166, 141, 52]\n    assert arr[1, 0].tolist() == [63, 87, 176]\n    assert arr[2, 0].tolist() == [158, 158, 158]\n    assert arr[-1, -1].tolist() == [158, 158, 158]\n\n\nEXPB_8_3_1F_ODD = PixelReference(\"SC_rgb_small_odd_big_endian.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (1, 60, 80, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert arr[9, 3:6].tolist() == [[171, 171, 171], [255, 255, 255], [255, 255, 0]]\n    assert arr[58, 8:12].tolist() == [\n        [255, 236, 0],\n        [255, 183, 0],\n        [255, 175, 0],\n        [255, 183, 0],\n    ]\n\n\nEXPB_8_8_3_1F_RGB = PixelReference(\"ExplVR_BigEnd.dcm\", \"u1\", test)\n\n\n# EXPB, (8, 8), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (255, 0, 0) == tuple(frame[5, 50, :])\n        assert (255, 128, 128) == tuple(frame[15, 50, :])\n        assert (0, 255, 0) == tuple(frame[25, 50, :])\n        assert (128, 255, 128) == tuple(frame[35, 50, :])\n        assert (0, 0, 255) == tuple(frame[45, 50, :])\n        assert (128, 128, 255) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (64, 64, 64) == tuple(frame[75, 50, :])\n        assert (192, 192, 192) == tuple(frame[85, 50, :])\n        assert (255, 255, 255) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 255, 255) == tuple(frame[5, 50, :])\n        assert (0, 127, 127) == tuple(frame[15, 50, :])\n        assert (255, 0, 255) == tuple(frame[25, 50, :])\n        assert (127, 0, 127) == tuple(frame[35, 50, :])\n        assert (255, 255, 0) == tuple(frame[45, 50, :])\n        assert (127, 127, 0) == tuple(frame[55, 50, :])\n        assert (255, 255, 255) == tuple(frame[65, 50, :])\n        assert (191, 191, 191) == tuple(frame[75, 50, :])\n        assert (63, 63, 63) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPB_8_3_2F = PixelReference(\"SC_rgb_expb_2frame.dcm\", \"u1\", test)\n\n\n# EXPB, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    # Last pixel\n    assert 862 == arr[-1, -1]\n\n\nEXPB_16_1_1F = PixelReference(\"MR_small_expb.dcm\", \">i2\", test)\n\n\n# EXPB, (16, 12), (10, 64, 64, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (206, 197, 159) == tuple(frame[0, 31:34])\n        assert (49, 78, 128) == tuple(frame[31, :3])\n        assert (362, 219, 135) == tuple(frame[-1, -3:])\n\n    # Frame 5\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert (67, 82, 44) == tuple(frame[0, 31:34])\n        assert (37, 41, 17) == tuple(frame[31, :3])\n        assert (225, 380, 355) == tuple(frame[-1, -3:])\n\n    # Frame 10\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert (72, 86, 69) == tuple(frame[0, 31:34])\n        assert (25, 4, 9) == tuple(frame[31, :3])\n        assert (227, 300, 147) == tuple(frame[-1, -3:])\n\n\nEXPB_16_1_10F = PixelReference(\"emri_small_big_endian.dcm\", \">u2\", test)\n\n\n# EXPB, (16, 16), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (65535, 0, 0) == tuple(arr[5, 50, :])\n    assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n    assert (0, 65535, 0) == tuple(arr[25, 50, :])\n    assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n    assert (0, 0, 65535) == tuple(arr[45, 50, :])\n    assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n    assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n    assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\n\n\nEXPB_16_3_1F = PixelReference(\"SC_rgb_expb_16bit.dcm\", \">u2\", test)\n\n\n# EXPB, (16, 16), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (65535, 0, 0) == tuple(frame[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(frame[15, 50, :])\n        assert (0, 65535, 0) == tuple(frame[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(frame[35, 50, :])\n        assert (0, 0, 65535) == tuple(frame[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(frame[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(frame[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 65535, 65535) == tuple(frame[5, 50, :])\n        assert (0, 32639, 32639) == tuple(frame[15, 50, :])\n        assert (65535, 0, 65535) == tuple(frame[25, 50, :])\n        assert (32639, 0, 32639) == tuple(frame[35, 50, :])\n        assert (65535, 65535, 0) == tuple(frame[45, 50, :])\n        assert (32639, 32639, 0) == tuple(frame[55, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[65, 50, :])\n        assert (49087, 49087, 49087) == tuple(frame[75, 50, :])\n        assert (16191, 16191, 16191) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPB_16_3_2F = PixelReference(\"SC_rgb_expb_16bit_2frame.dcm\", \">u2\", test)\n\n\n# EXPB, (32, 32), (1, 10, 10, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n    assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n    assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\n\n\nEXPB_32_1_1F = PixelReference(\"rtdose_expb_1frame.dcm\", \">u4\", test)\n\n\n# EXPB, (32, 32), (15, 10, 10, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (1249000, 1249000, 1250000) == tuple(frame[0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(frame[4, 3:6])\n        assert (803000, 801000, 798000) == tuple(frame[-1, -3:])\n\n    # Frame 8\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert (1253000, 1253000, 1249000) == tuple(frame[0, :3])\n        assert (1026000, 1023000, 1022000) == tuple(frame[4, 3:6])\n        assert (803000, 803000, 803000) == tuple(frame[-1, -3:])\n\n    # Frame 15\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert (1249000, 1250000, 1251000) == tuple(frame[0, :3])\n        assert (1031000, 1031000, 1031000) == tuple(frame[4, 3:6])\n        assert (801000, 800000, 799000) == tuple(frame[-1, -3:])\n\n\nEXPB_32_1_15F = PixelReference(\"rtdose_expb.dcm\", \">u4\", test)\n\n\n# EXPB, (32, 32), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert (4294967295, 0, 0) == tuple(arr[5, 50, :])\n    assert (4294967295, 2155905152, 2155905152) == tuple(arr[15, 50, :])\n    assert (0, 4294967295, 0) == tuple(arr[25, 50, :])\n    assert (2155905152, 4294967295, 2155905152) == tuple(arr[35, 50, :])\n    assert (0, 0, 4294967295) == tuple(arr[45, 50, :])\n    assert (2155905152, 2155905152, 4294967295) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (1077952576, 1077952576, 1077952576) == tuple(arr[75, 50, :])\n    assert (3233857728, 3233857728, 3233857728) == tuple(arr[85, 50, :])\n    assert (4294967295, 4294967295, 4294967295) == tuple(arr[95, 50, :])\n\n\nEXPB_32_3_1F = PixelReference(\"SC_rgb_expb_32bit.dcm\", \">u4\", test)\n\n\n# EXPB, (32, 32), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (4294967295, 0, 0) == tuple(frame[5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(frame[15, 50, :])\n        assert (0, 4294967295, 0) == tuple(frame[25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(frame[35, 50, :])\n        assert (0, 0, 4294967295) == tuple(frame[45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(frame[75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(frame[85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[95, 50, :])\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 4294967295, 4294967295) == tuple(frame[5, 50, :])\n        assert (0, 2139062143, 2139062143) == tuple(frame[15, 50, :])\n        assert (4294967295, 0, 4294967295) == tuple(frame[25, 50, :])\n        assert (2139062143, 0, 2139062143) == tuple(frame[35, 50, :])\n        assert (4294967295, 4294967295, 0) == tuple(frame[45, 50, :])\n        assert (2139062143, 2139062143, 0) == tuple(frame[55, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[65, 50, :])\n        assert (3217014719, 3217014719, 3217014719) == tuple(frame[75, 50, :])\n        assert (1061109567, 1061109567, 1061109567) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\n\n\nEXPB_32_3_2F = PixelReference(\"SC_rgb_expb_32bit_2frame.dcm\", \">u4\", test)\n\n\nPIXEL_REFERENCE[ExplicitVRBigEndian] = [\n    EXPB_1_1_1F,\n    EXPB_1_1_3F,\n    EXPB_8_1_1F,\n    EXPB_8_1_2F,\n    EXPB_8_3_1F,\n    EXPB_8_3_1F_ODD,\n    EXPB_8_8_3_1F_RGB,\n    EXPB_8_3_2F,\n    EXPB_16_1_1F,\n    EXPB_16_1_10F,\n    EXPB_16_3_1F,\n    EXPB_16_3_2F,\n    EXPB_32_1_1F,\n    EXPB_32_1_15F,\n    EXPB_32_3_1F,\n    EXPB_32_3_2F,\n]\n\n\n# RLE Lossless\n# RLE: RLELossless\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n\n\n# RLE, (8, 8), (1, 600, 800, 1), OB, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    assert arr[0].min() == arr[0].max() == 244\n    assert tuple(arr[300, 491:494]) == (1, 246, 1)\n    assert arr[-1].min() == arr[-1].max() == 0\n\n\nRLE_8_1_1F = PixelReference(\"OBXXXX1A_rle.dcm\", \"u1\", test)\n\n\n# RLE, (8, 8), (2, 600, 800, 1), OB, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max() == 244\n        assert tuple(frame[300, 491:494]) == (1, 246, 1)\n        assert frame[-1].min() == frame[-1].max() == 0\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert tuple(frame[300, 491:494]) == (254, 9, 254)\n        assert frame[-1].min() == frame[-1].max() == 255\n\n\nRLE_8_1_2F = PixelReference(\"OBXXXX1A_rle_2frame.dcm\", \"u1\", test)\n\n\n# RLE, (8, 8), (1, 100, 100, 3), OB, PALETTE COLOR, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\n\n\nRLE_8_3_1F = PixelReference(\"SC_rgb_rle.dcm\", \"u1\", test)\n\n\n# RLE, (8, 8), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (255, 0, 0)\n        assert tuple(frame[15, 50, :]) == (255, 128, 128)\n        assert tuple(frame[25, 50, :]) == (0, 255, 0)\n        assert tuple(frame[35, 50, :]) == (128, 255, 128)\n        assert tuple(frame[45, 50, :]) == (0, 0, 255)\n        assert tuple(frame[55, 50, :]) == (128, 128, 255)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (64, 64, 64)\n        assert tuple(frame[85, 50, :]) == (192, 192, 192)\n        assert tuple(frame[95, 50, :]) == (255, 255, 255)\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 255, 255)\n        assert tuple(frame[15, 50, :]) == (0, 127, 127)\n        assert tuple(frame[25, 50, :]) == (255, 0, 255)\n        assert tuple(frame[35, 50, :]) == (127, 0, 127)\n        assert tuple(frame[45, 50, :]) == (255, 255, 0)\n        assert tuple(frame[55, 50, :]) == (127, 127, 0)\n        assert tuple(frame[65, 50, :]) == (255, 255, 255)\n        assert tuple(frame[75, 50, :]) == (191, 191, 191)\n        assert tuple(frame[85, 50, :]) == (63, 63, 63)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\n\n\nRLE_8_3_2F = PixelReference(\"SC_rgb_rle_2frame.dcm\", \"u1\", test)\n\n\n# RLE, (16, 16), (1, 64, 64, 1), OB, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[0, 31:34]) == (422, 319, 361)\n    assert tuple(arr[31, :3]) == (366, 363, 322)\n    assert tuple(arr[-1, -3:]) == (1369, 1129, 862)\n\n\nRLE_16_1_1F = PixelReference(\"MR_small_RLE.dcm\", \"<i2\", test)\n\n\n# RLE, (16, 12), (10, 64, 64, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[0, 31:34]) == (206, 197, 159)\n        assert tuple(frame[31, :3]) == (49, 78, 128)\n        assert tuple(frame[-1, -3:]) == (362, 219, 135)\n\n    # Frame 5\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert tuple(frame[0, 31:34]) == (67, 82, 44)\n        assert tuple(frame[31, :3]) == (37, 41, 17)\n        assert tuple(frame[-1, -3:]) == (225, 380, 355)\n\n    # Frame 10\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert tuple(frame[0, 31:34]) == (72, 86, 69)\n        assert tuple(frame[31, :3]) == (25, 4, 9)\n        assert tuple(frame[-1, -3:]) == (227, 300, 147)\n\n\nRLE_16_1_10F = PixelReference(\"emri_small_RLE.dcm\", \"<u2\", test)\n\n\n# RLE, (16, 16), (1, 100, 100, 3), OW, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (65535, 0, 0)\n    assert tuple(arr[15, 50, :]) == (65535, 32896, 32896)\n    assert tuple(arr[25, 50, :]) == (0, 65535, 0)\n    assert tuple(arr[35, 50, :]) == (32896, 65535, 32896)\n    assert tuple(arr[45, 50, :]) == (0, 0, 65535)\n    assert tuple(arr[55, 50, :]) == (32896, 32896, 65535)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (16448, 16448, 16448)\n    assert tuple(arr[85, 50, :]) == (49344, 49344, 49344)\n    assert tuple(arr[95, 50, :]) == (65535, 65535, 65535)\n\n\nRLE_16_3_1F = PixelReference(\"SC_rgb_rle_16bit.dcm\", \"<u2\", test)\n\n\n# RLE, (16, 16), (2, 100, 100, 3), OW, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (65535, 0, 0)\n        assert tuple(frame[15, 50, :]) == (65535, 32896, 32896)\n        assert tuple(frame[25, 50, :]) == (0, 65535, 0)\n        assert tuple(frame[35, 50, :]) == (32896, 65535, 32896)\n        assert tuple(frame[45, 50, :]) == (0, 0, 65535)\n        assert tuple(frame[55, 50, :]) == (32896, 32896, 65535)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (16448, 16448, 16448)\n        assert tuple(frame[85, 50, :]) == (49344, 49344, 49344)\n        assert tuple(frame[95, 50, :]) == (65535, 65535, 65535)\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 65535, 65535)\n        assert tuple(frame[15, 50, :]) == (0, 32639, 32639)\n        assert tuple(frame[25, 50, :]) == (65535, 0, 65535)\n        assert tuple(frame[35, 50, :]) == (32639, 0, 32639)\n        assert tuple(frame[45, 50, :]) == (65535, 65535, 0)\n        assert tuple(frame[55, 50, :]) == (32639, 32639, 0)\n        assert tuple(frame[65, 50, :]) == (65535, 65535, 65535)\n        assert tuple(frame[75, 50, :]) == (49087, 49087, 49087)\n        assert tuple(frame[85, 50, :]) == (16191, 16191, 16191)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\n\n\nRLE_16_3_2F = PixelReference(\"SC_rgb_rle_16bit_2frame.dcm\", \"<u2\", test)\n\n\n# RLE, (32, 32), (1, 10, 10, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[0, :3]) == (1249000, 1249000, 1250000)\n    assert tuple(arr[4, 3:6]) == (1031000, 1029000, 1027000)\n    assert tuple(arr[-1, -3:]) == (803000, 801000, 798000)\n\n\nRLE_32_1_1F = PixelReference(\"rtdose_rle_1frame.dcm\", \"<u4\", test)\n\n\n# RLE, (32, 32), (15, 10, 10, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[0, :3]) == (1249000, 1249000, 1250000)\n        assert tuple(frame[4, 3:6]) == (1031000, 1029000, 1027000)\n        assert tuple(frame[-1, -3:]) == (803000, 801000, 798000)\n\n    # Frame 8\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert tuple(frame[0, :3]) == (1253000, 1253000, 1249000)\n        assert tuple(frame[4, 3:6]) == (1026000, 1023000, 1022000)\n        assert tuple(frame[-1, -3:]) == (803000, 803000, 803000)\n\n    # Frame 15\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert tuple(frame[0, :3]) == (1249000, 1250000, 1251000)\n        assert tuple(frame[4, 3:6]) == (1031000, 1031000, 1031000)\n        assert tuple(frame[-1, -3:]) == (801000, 800000, 799000)\n\n\nRLE_32_1_15F = PixelReference(\"rtdose_rle.dcm\", \"<u4\", test)\n\n\n# RLE, (32, 32), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (4294967295, 0, 0)\n    assert tuple(arr[15, 50, :]) == (4294967295, 2155905152, 2155905152)\n    assert tuple(arr[25, 50, :]) == (0, 4294967295, 0)\n    assert tuple(arr[35, 50, :]) == (2155905152, 4294967295, 2155905152)\n    assert tuple(arr[45, 50, :]) == (0, 0, 4294967295)\n    assert tuple(arr[55, 50, :]) == (2155905152, 2155905152, 4294967295)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (1077952576, 1077952576, 1077952576)\n    assert tuple(arr[85, 50, :]) == (3233857728, 3233857728, 3233857728)\n    assert tuple(arr[95, 50, :]) == (4294967295, 4294967295, 4294967295)\n\n\nRLE_32_3_1F = PixelReference(\"SC_rgb_rle_32bit.dcm\", \"<u4\", test)\n\n\n# RLE, (32, 32), (2, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    index = kwargs.get(\"index\", None)\n\n    # Frame 1\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (4294967295, 0, 0)\n        assert tuple(frame[15, 50, :]) == (4294967295, 2155905152, 2155905152)\n        assert tuple(frame[25, 50, :]) == (0, 4294967295, 0)\n        assert tuple(frame[35, 50, :]) == (2155905152, 4294967295, 2155905152)\n        assert tuple(frame[45, 50, :]) == (0, 0, 4294967295)\n        assert tuple(frame[55, 50, :]) == (2155905152, 2155905152, 4294967295)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (1077952576, 1077952576, 1077952576)\n        assert tuple(frame[85, 50, :]) == (3233857728, 3233857728, 3233857728)\n        assert tuple(frame[95, 50, :]) == (4294967295, 4294967295, 4294967295)\n\n    # Frame 2 is frame 1 inverted\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 4294967295, 4294967295)\n        assert tuple(frame[15, 50, :]) == (0, 2139062143, 2139062143)\n        assert tuple(frame[25, 50, :]) == (4294967295, 0, 4294967295)\n        assert tuple(frame[35, 50, :]) == (2139062143, 0, 2139062143)\n        assert tuple(frame[45, 50, :]) == (4294967295, 4294967295, 0)\n        assert tuple(frame[55, 50, :]) == (2139062143, 2139062143, 0)\n        assert tuple(frame[65, 50, :]) == (4294967295, 4294967295, 4294967295)\n        assert tuple(frame[75, 50, :]) == (3217014719, 3217014719, 3217014719)\n        assert tuple(frame[85, 50, :]) == (1061109567, 1061109567, 1061109567)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\n\n\nRLE_32_3_2F = PixelReference(\"SC_rgb_rle_32bit_2frame.dcm\", \"<u4\", test)\n\n\nPIXEL_REFERENCE[RLELossless] = [\n    RLE_8_1_1F,\n    RLE_8_1_2F,\n    RLE_8_3_1F,\n    RLE_8_3_2F,\n    RLE_16_1_1F,\n    RLE_16_1_10F,\n    RLE_16_3_1F,\n    RLE_16_3_2F,\n    RLE_32_1_1F,\n    RLE_32_1_15F,\n    RLE_32_3_1F,\n    RLE_32_3_2F,\n]\n\n\n# JPEG - ISO/IEC 10918 Standard\n# JPGB: JPEGBaseline8Bit\n# JPGE: JPEGExtended12Bit\n# JPGL: JPEGLossless\n# JPGS: JPEGLosslessSV1\n\n\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n# 0: JPGB, (8, 8), (1, 3, 3, 3), OB, YBR_FULL, 0\n# Uses a JFIF APP marker\ndef test(ref, arr, **kwargs):\n    # Pillow, pylibjpeg\n    assert tuple(arr[0, 0, :]) == (138, 78, 147)\n    assert tuple(arr[1, 0, :]) == (90, 178, 108)\n    assert tuple(arr[2, 0, :]) == (158, 126, 129)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL = PixelReference(\"SC_rgb_small_odd_jpeg.dcm\", \"u1\", test)\n\n\n# JPGB, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# JPEG baseline in RGB colourspace with no APP14 marker\ndef test(ref, arr, **kwargs):\n    assert arr[29, 77:81].tolist() == [\n        [240, 243, 246],\n        [214, 210, 213],\n        [150, 134, 134],\n        [244, 244, 244],\n    ]\n    if kwargs.get(\"plugin\", None) in (\"pillow\", \"gdcm\"):\n        assert arr[224:227, 253].tolist() == [\n            [231, 236, 238],\n            [190, 175, 178],\n            [215, 200, 202],\n        ]\n    else:\n        assert arr[224:227, 253].tolist() == [\n            [232, 236, 238],\n            [190, 175, 178],\n            [215, 200, 202],\n        ]\n\n\nJPGB_08_08_3_0_1F_RGB_NO_APP14 = PixelReference(\n    \"SC_jpeg_no_color_transform.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# JPEG baseline in RGB colourspace with APP14 Adobe v101 marker\ndef test(ref, arr, **kwargs):\n    plugin = kwargs.get(\"plugin\", None)\n    if plugin in (\"pillow\", \"gdcm\"):\n        assert arr[99:104, 172].tolist() == [\n            [243, 244, 246],\n            [229, 224, 235],\n            [204, 190, 213],\n            [194, 176, 203],\n            [204, 188, 211],\n        ]\n        assert arr[84, 239:243].tolist() == [\n            [229, 225, 234],\n            [174, 174, 202],\n            [187, 185, 203],\n            [210, 207, 225],\n        ]\n    elif plugin == \"pylibjpeg\":\n        assert arr[99:104, 172].tolist() == [\n            [243, 244, 246],\n            [229, 224, 235],\n            [204, 191, 213],\n            [194, 176, 203],\n            [204, 188, 211],\n        ]\n        assert arr[84, 239:243].tolist() == [\n            [229, 225, 234],\n            [174, 174, 202],\n            [187, 185, 203],\n            [211, 207, 225],\n        ]\n\n\nJPGB_08_08_3_0_1F_RGB_APP14 = PixelReference(\n    \"SC_jpeg_no_color_transform_2.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# JPEG baseline in RGB colourspace with APP14 Adobe v101 marker\ndef test(ref, arr, **kwargs):\n    plugin = kwargs.get(\"plugin\", None)\n    if plugin in (\"pillow\", \"gdcm\"):\n        assert arr[99:104, 172].tolist() == [\n            [243, 244, 246],\n            [229, 224, 235],\n            [204, 190, 213],\n            [194, 176, 203],\n            [204, 188, 211],\n        ]\n        assert arr[84, 239:243].tolist() == [\n            [229, 225, 234],\n            [174, 174, 202],\n            [187, 185, 203],\n            [210, 207, 225],\n        ]\n    elif plugin == \"pylibjpeg\":\n        assert arr[99:104, 172].tolist() == [\n            [243, 244, 246],\n            [229, 224, 235],\n            [204, 191, 213],\n            [194, 176, 203],\n            [204, 188, 211],\n        ]\n        assert arr[84, 239:243].tolist() == [\n            [229, 225, 234],\n            [174, 174, 202],\n            [187, 185, 203],\n            [211, 207, 225],\n        ]\n\n\nJPGB_08_08_3_0_1F_RGB_DCMD_APP14 = PixelReference(\n    \"SC_rgb_jpeg_app14_dcmd.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (120, 480, 640, 3), OB, YBR_FULL_422, 0\ndef test(ref, arr, **kwargs):\n    # Pillow, pylibjpeg, gdcm\n    if kwargs.get(\"as_rgb\", False) and kwargs.get(\"plugin\", None) == \"pylibjpeg\":\n        index = kwargs.get(\"index\", None)\n        if index == 0:\n            assert arr[278, 300:310].tolist() == [\n                [64, 64, 64],\n                [76, 76, 76],\n                [86, 86, 86],\n                [95, 95, 95],\n                [95, 95, 95],\n                [97, 97, 97],\n                [98, 98, 98],\n                [98, 98, 98],\n                [106, 106, 106],\n                [108, 108, 108],\n            ]\n\n        if index == 60:\n            assert arr[278, 300:310].tolist() == [\n                [36, 36, 36],\n                [38, 38, 38],\n                [41, 41, 41],\n                [47, 47, 47],\n                [50, 50, 50],\n                [50, 50, 50],\n                [53, 53, 53],\n                [51, 51, 51],\n                [47, 47, 47],\n                [38, 38, 38],\n            ]\n\n        if index == -1:\n            assert arr[278, 300:310].tolist() == [\n                [46, 46, 46],\n                [55, 55, 55],\n                [64, 64, 64],\n                [74, 74, 74],\n                [81, 81, 81],\n                [86, 86, 86],\n                [97, 97, 97],\n                [104, 104, 104],\n                [110, 110, 110],\n                [117, 117, 117],\n            ]\n\n        return\n\n    assert arr[0, 278, 300:310].tolist() == [\n        [64, 128, 128],\n        [76, 128, 128],\n        [86, 128, 128],\n        [95, 128, 128],\n        [95, 128, 128],\n        [97, 128, 128],\n        [98, 128, 128],\n        [98, 128, 128],\n        [106, 128, 128],\n        [108, 128, 128],\n    ]\n    if kwargs.get(\"plugin\", None) in (\"pillow\", \"gdcm\"):\n        assert arr[59, 278, 300:310].tolist() == [\n            [22, 128, 128],\n            [22, 128, 128],\n            [27, 128, 128],\n            [32, 128, 128],\n            [32, 128, 128],\n            [29, 128, 128],\n            [23, 128, 128],\n            [21, 128, 128],\n            [24, 128, 128],\n            [33, 128, 128],\n        ]\n        assert arr[-1, 278, 300:310].tolist() == [\n            [46, 128, 128],\n            [55, 128, 128],\n            [64, 128, 128],\n            [74, 128, 128],\n            [80, 128, 128],\n            [86, 128, 128],\n            [97, 128, 128],\n            [104, 128, 128],\n            [110, 128, 128],\n            [117, 128, 128],\n        ]\n    elif kwargs.get(\"plugin\", None) == \"pylibjpeg\":\n        assert arr[59, 278, 300:310].tolist() == [\n            [22, 128, 128],\n            [22, 128, 128],\n            [27, 128, 128],\n            [32, 128, 128],\n            [32, 128, 128],\n            [30, 128, 128],\n            [23, 128, 128],\n            [21, 128, 128],\n            [24, 128, 128],\n            [33, 128, 128],\n        ]\n        assert arr[-1, 278, 300:310].tolist() == [\n            [46, 128, 128],\n            [55, 128, 128],\n            [64, 128, 128],\n            [74, 128, 128],\n            [81, 128, 128],\n            [86, 128, 128],\n            [97, 128, 128],\n            [104, 128, 128],\n            [110, 128, 128],\n            [117, 128, 128],\n        ]\n\n\nJPGB_08_08_3_0_120F_YBR_FULL_422 = PixelReference(\n    \"color3d_jpeg_baseline.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_1F_YBR_FULL = PixelReference(\"SC_rgb_jpeg_dcmtk.dcm\", \"u1\", test)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL_422, 0\n# Different subsampling 411, 422, 444\ndef test(ref, arr, **kwargs):\n    if kwargs.get(\"plugin\", None) in (\"pillow\", \"gdcm\"):\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 109, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 85, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 108)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n    else:\n        # pylibjpeg\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 108, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 86, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 107)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL_422_411 = PixelReference(\n    \"SC_rgb_dcmtk_+eb+cy+np.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL_422, 0\ndef test(ref, arr, **kwargs):\n    # Pillow, pylibjpeg\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL_422_422 = PixelReference(\n    \"SC_rgb_dcmtk_+eb+cy+s2.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    if kwargs.get(\"plugin\", None) in (\"pillow\", \"gdcm\"):\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 109, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 85, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 108)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n    else:\n        # pylibjpeg\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 108, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 86, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 107)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL_411 = PixelReference(\n    \"SC_rgb_dcmtk_+eb+cy+n1.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    # pillow, pylibjpeg\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL_422 = PixelReference(\n    \"SC_rgb_dcmtk_+eb+cy+n2.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    # pillow, pylibjpeg\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_0_1F_YBR_FULL_444 = PixelReference(\n    \"SC_rgb_dcmtk_+eb+cy+s4.dcm\", \"u1\", test\n)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, RGB, 0\n# Uses RGB component IDs\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\n\n\nJPGB_08_08_3_0_1F_RGB = PixelReference(\"SC_rgb_dcmtk_+eb+cr.dcm\", \"u1\", test)\n\n\n# JPGB, (8, 8), (1, 100, 100, 3), OB, YBR_FULL, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 107, 191)\n    assert tuple(arr[25, 50, :]) == (150, 44, 21)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 191, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\n\n\nJPGB_08_08_3_1F_YBR_FULL = PixelReference(\"SC_rgb_jpeg_lossy_gdcm.dcm\", \"u1\", test)\n\n\n# JPGE, (16, 12), (1, 1024, 256, 1), OB, MONOCHROME2, 0\n# Bad file - scan stop has invalid value\ndef test(ref, arr, **kwargs):\n    # pylibjpeg won't decode due to invalid value scan stop value\n    # gdcm won't decode due to 12-bit\n    assert 244 == arr[420, 140]\n    assert 95 == arr[230, 120]\n\n\nJPGE_BAD = PixelReference(\"JPEG-lossy.dcm\", \"<u2\", test)\n\n\n# JPGE, (16, 12), (1, 1024, 256, 1), OB, MONOCHROME2,\n# Fixed version of JPEG_BAD\ndef test(ref, arr, **kwargs):\n    # pylibjpeg, gdcm\n    assert 244 == arr[420, 140]\n    assert 95 == arr[230, 120]\n\n\nJPGE_16_12_1_0_1F_M2 = PixelReference(\"JPGExtended.dcm\", \"<u2\", test)\n\n\n# JPGS, (8, 8), (1, 768, 1024, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    # pylibjpeg\n    assert tuple(arr[300, 512:520]) == (26, 26, 25, 22, 19, 16, 14, 15)\n    assert tuple(arr[600, 512:520]) == (45, 43, 41, 38, 33, 30, 26, 21)\n\n\nJPGS_08_08_1_0_1F = PixelReference(\"JPGLosslessP14SV1_1s_1f_8b.dcm\", \"u1\", test)\n\n\n# JPGS, (16, 16), (1, 1024, 256, 1), OB, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    # pylibjpeg\n    assert tuple(arr[400, 124:132]) == (60, 58, 61, 68, 59, 65, 64, 67)\n    assert tuple(arr[600, 124:132]) == (3, 1, 2, 0, 2, 1, 2, 0)\n\n\nJPGS_16_16_1_1_1F_M2 = PixelReference(\"JPEG-LL.dcm\", \"<i2\", test)\n\n\n# JPGS, (8, 8), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\n\n\nJPGS_08_08_3_1F_RGB = PixelReference(\"SC_rgb_jpeg_gdcm.dcm\", \"u1\", test)\n\n\nPIXEL_REFERENCE[JPEGBaseline8Bit] = [\n    JPGB_08_08_3_0_1F_YBR_FULL,\n    JPGB_08_08_3_0_1F_RGB_NO_APP14,\n    JPGB_08_08_3_0_1F_RGB_APP14,\n    JPGB_08_08_3_0_1F_RGB_DCMD_APP14,\n    JPGB_08_08_3_0_120F_YBR_FULL_422,\n    JPGB_08_08_3_1F_YBR_FULL,\n    JPGB_08_08_3_0_1F_YBR_FULL_422_411,\n    JPGB_08_08_3_0_1F_YBR_FULL_422_422,\n    JPGB_08_08_3_0_1F_YBR_FULL_411,\n    JPGB_08_08_3_0_1F_YBR_FULL_422,\n    JPGB_08_08_3_0_1F_YBR_FULL_444,\n    JPGB_08_08_3_0_1F_RGB,\n    JPGB_08_08_3_1F_YBR_FULL,\n]\nPIXEL_REFERENCE[JPEGExtended12Bit] = [JPGE_BAD, JPGE_16_12_1_0_1F_M2]\nPIXEL_REFERENCE[JPEGLossless] = []\nPIXEL_REFERENCE[JPEGLosslessSV1] = [\n    JPGS_08_08_1_0_1F,\n    JPGS_16_16_1_1_1F_M2,\n    JPGS_08_08_3_1F_RGB,\n]\n\n\n# JPEG-LS - ISO/IEC 14495 Standard\n# JLSL: JPEGLSLossless\n# JLSN: JPEGLSNearLossless\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n\n\n# JLSL, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# Plane interleaved (ILV 0)\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [\n        [115, 109, 91],\n        [109, 105, 100],\n        [100, 111, 94],\n        [192, 53, 172],\n    ]\n\n\nJLSL_08_08_3_0_1F_ILV0 = PixelReference(\"JLSL_RGB_ILV0.dcm\", \"u1\", test)\n\n\n# JLSL, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# Line interleaved (ILV 1)\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [\n        [115, 109, 91],\n        [109, 105, 100],\n        [100, 111, 94],\n        [192, 53, 172],\n    ]\n\n\nJLSL_08_08_3_0_1F_ILV1 = PixelReference(\"JLSL_RGB_ILV1.dcm\", \"u1\", test)\n\n\n# JLSL, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# Sample interleaved (ILV 2)\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [\n        [115, 109, 91],\n        [109, 105, 100],\n        [100, 111, 94],\n        [192, 53, 172],\n    ]\n\n\nJLSL_08_08_3_0_1F_ILV2 = PixelReference(\"JLSL_RGB_ILV2.dcm\", \"u1\", test)\n\n\n# JLSL, (8, 7), (1, 128, 128, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert arr[59:69, 58].tolist() == [55, 53, 58, 85, 109, 123, 116, 102, 98, 89]\n\n\nJLSL_08_07_1_0_1F = PixelReference(\"JLSL_08_07_0_1F.dcm\", \"u1\", test)\n\n\n# JLSL, (16, 15), (1, 128, 128, 1), OB, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    assert arr[59:65, 58].tolist() == [-2073, -2629, -1167, 5566, 11808, 15604]\n\n\nJLSL_16_15_1_1_1F = PixelReference(\"JLSL_16_15_1_1F.dcm\", \"<i2\", test)\n\n\n# JLSL, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    # pylibjpeg, pyjpegls\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert arr[55:65, 35].tolist() == [170, 193, 191, 373, 1293, 2053, 1879, 1683, 1711]\n\n\nJLSL_16_16_1_1_1F = PixelReference(\"MR_small_jpeg_ls_lossless.dcm\", \"<i2\", test)\n\n\n# JLSL, (16, 12), (10, 64, 64, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"emri_small.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJLSL_16_12_1_1_10F = PixelReference(\"emri_small_jpeg_ls_lossless.dcm\", \"<u2\", test)\n\n\n# JLSN, (8, 8), (1, 45, 10, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0] == 255\n    assert arr[5, 0] == 125\n    assert arr[10, 0] == 65\n    assert arr[15, 0] == 30\n    assert arr[20, 0] == 15\n    assert arr[25, 0] == 5\n    assert arr[30, 0] == 5\n    assert arr[35, 0] == 0\n    assert arr[40, 0] == 0\n\n\nJLSN_08_01_1_0_1F = PixelReference(\"JPEGLSNearLossless_08.dcm\", \"u1\", test)\n\n\n# JLSN, (8, 8), (1, 256, 256, 3), OB, RGB, 0\n# Plane interleaved (ILV 0), lossy error 3\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [\n        [118, 110, 92],\n        [110, 103, 99],\n        [97, 113, 96],\n        [191, 55, 175],\n    ]\n\n\nJLSN_08_08_3_0_1F_ILV0 = PixelReference(\"JLSN_RGB_ILV0.dcm\", \"u1\", test)\n\n\n# JLSN, (8, 8), (1, 100, 100, 3), OB, RGB, 0\n# Line interleaved (ILV 1)\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [255, 0, 0]\n    assert arr[10, 0].tolist() == [255, 130, 130]\n    assert arr[20, 0].tolist() == [0, 255, 0]\n    assert arr[30, 0].tolist() == [130, 255, 130]\n    assert arr[40, 0].tolist() == [0, 0, 255]\n    assert arr[50, 0].tolist() == [130, 130, 255]\n    assert arr[60, 0].tolist() == [0, 0, 0]\n    assert arr[70, 0].tolist() == [65, 65, 65]\n    assert arr[80, 0].tolist() == [190, 190, 190]\n    assert arr[90, 0].tolist() == [255, 255, 255]\n\n\nJLSN_08_08_1_0_3F_LINE = PixelReference(\"SC_rgb_jls_lossy_line.dcm\", \"u1\", test)\n\n\n# JLSN, (8, 8), (1, 100, 100, 3), OB, RGB, 0\n# Sample interleaved (ILV 2)\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [255, 0, 0]\n    assert arr[10, 0].tolist() == [255, 130, 130]\n    assert arr[20, 0].tolist() == [0, 255, 0]\n    assert arr[30, 0].tolist() == [130, 255, 130]\n    assert arr[40, 0].tolist() == [0, 0, 255]\n    assert arr[50, 0].tolist() == [130, 130, 255]\n    assert arr[60, 0].tolist() == [0, 0, 0]\n    assert arr[70, 0].tolist() == [65, 65, 65]\n    assert arr[80, 0].tolist() == [190, 190, 190]\n    assert arr[90, 0].tolist() == [255, 255, 255]\n\n\nJLSN_08_08_1_0_3F_SAMPLE = PixelReference(\"SC_rgb_jls_lossy_sample.dcm\", \"u1\", test)\n\n\n# JLSN, (16, 16), (1, 45, 10, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0] == 65535\n    assert arr[5, 0] == 32765\n    assert arr[10, 0] == 16385\n    assert arr[15, 0] == 4095\n    assert arr[20, 0] == 1025\n    assert arr[25, 0] == 255\n    assert arr[30, 0] == 65\n    assert arr[35, 0] == 15\n    assert arr[40, 0] == 5\n\n\nJLSN_16_16_1_0_1F = PixelReference(\"JPEGLSNearLossless_16.dcm\", \"<u2\", test)\n\n\nPIXEL_REFERENCE[JPEGLSLossless] = [\n    JLSL_08_08_3_0_1F_ILV0,\n    JLSL_08_08_3_0_1F_ILV1,\n    JLSL_08_08_3_0_1F_ILV2,\n    JLSL_08_07_1_0_1F,\n    JLSL_16_15_1_1_1F,\n    JLSL_16_16_1_1_1F,\n    JLSL_16_12_1_1_10F,\n]\nPIXEL_REFERENCE[JPEGLSNearLossless] = [\n    JLSN_08_01_1_0_1F,\n    JLSN_08_08_3_0_1F_ILV0,\n    JLSN_08_08_1_0_3F_LINE,\n    JLSN_08_08_1_0_3F_SAMPLE,\n    JLSN_16_16_1_0_1F,\n]\n\n\n# JPEG 2000 - ISO/IEC 15444 Standard\n# J2KR: JPEG2000Lossless\n# J2KI: JPEG2000\n# HTJR: HTJ2KLossless\n# HTJL: HTJ2KLosslessRPCL\n# HTJI: HTJ2K\n\n\n# tsyntax, (bits allocated, stored), (frames, rows, cols, planes), VR, PI, pixel repr.\n# 0: J2KR, (8, 8), (1, 480, 640, 3), OB, YBR_RCT, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"US1_UNCR.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_08_08_3_0_1F_YBR_ICT = PixelReference(\"US1_J2KR.dcm\", \"u1\", test)\n\n\n# J2KR, (16, 10), (1, 1760, 1760, 1), OB, MONOCHROME1, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"RG3_UNCR.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_10_1_0_1F_M1 = PixelReference(\"RG3_J2KR.dcm\", \"<u2\", test)\n\n\n# J2KR, (16, 12), (1, 1024, 1024, 1), OB, MONOCHROME2,\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"MR2_UNCR.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_12_1_0_1F_M2 = PixelReference(\"MR2_J2KR.dcm\", \"<u2\", test)\n\n\n# J2KR, (16, 15), (1, 1955, 1841, 1), OB, MONOCHROME1, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"RG1_UNCR.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_15_1_0_1F_M1 = PixelReference(\"RG1_J2KR.dcm\", \"<u2\", test)\n\n\n# J2KR, (16, 12), (10, 64, 64, 1), OW, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"emri_small.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_12_1_0_10F_M2 = PixelReference(\"emri_small_jpeg_2k_lossless.dcm\", \"<u2\", test)\n\n\n# J2KR, (16, 16), (1, 512, 512, 1), OB, MONOCHROME2, 1\n# J2K codestream has 14-bit precision\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"693_UNCR.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_14_1_1_1F_M2 = PixelReference(\"693_J2KR.dcm\", \"<i2\", test)\n\n\n# J2KR, (16, 16), (1, 64, 64, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"MR_small.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KR_16_16_1_1_1F_M2 = PixelReference(\"MR_small_jp2klossless.dcm\", \"<i2\", test)\n\n\n# J2KR, (16, 13), (1, 512, 512, 1), OB, MONOCHROME2, 1\n# Mismatch between J2K sign and dataset Pixel Representation\ndef test(ref, arr, **kwargs):\n    assert -2000 == arr[0, 0]\n    assert [621, 412, 138, -193, -520, -767, -907, -966, -988, -995] == (\n        arr[47:57, 279].tolist()\n    )\n    assert [-377, -121, 141, 383, 633, 910, 1198, 1455, 1638, 1732] == (\n        arr[328:338, 106].tolist()\n    )\n\n\nJ2KR_16_13_1_1_1F_M2_MISMATCH = PixelReference(\"J2K_pixelrep_mismatch.dcm\", \"<i2\", test)\n\n\n# J2KR, (8, 8), (1, 400, 400, 3), OB, YBR_RCT, 0\n# Non-conformant pixel data -> JP2 header present\ndef test(ref, arr, **kwargs):\n    # Decoding error with pillow, OK in gdcm, pylibjpeg\n    assert tuple(arr[45, 140]) == (223, 32, 32)\n    assert tuple(arr[46, 140]) == (255, 0, 0)\n    assert tuple(arr[350, 195]) == (128, 128, 128)\n\n\nJ2KR_08_08_3_0_1F_YBR_RCT = PixelReference(\"GDCMJ2K_TextGBR.dcm\", \"u1\", test)\n\n\n# J2KI, (8, 8), (1, 100, 100, 3), OB, RGB, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"SC_rgb_gdcm2k_uncompressed.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KI_08_08_3_0_1F_RGB = PixelReference(\"SC_rgb_gdcm_KY.dcm\", \"u1\", test)\n\n\n# J2KI, (8, 8), (1, 480, 640, 3), OB, YBR_ICT, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"US1_UNCI.dcm\", read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\n\n\nJ2KI_08_08_3_0_1F_YBR_ICT = PixelReference(\"US1_J2KI.dcm\", \"u1\", test)\n\n\n# J2KI, (16, 10), (1, 1760, 1760, 1), OB, MONOCHROME1, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"RG3_UNCI.dcm\", read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\n\n\nJ2KI_16_10_1_0_1F_M1 = PixelReference(\"RG3_J2KI.dcm\", \"<u2\", test)\n\n\n# J2KI, (16, 12), (1, 1024, 1024, 1), OB, MONOCHROME2, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"MR2_UNCI.dcm\", read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\n\n\nJ2KI_16_12_1_0_1F_M2 = PixelReference(\"MR2_J2KI.dcm\", \"<u2\", test)\n\n\n# J2KI, (16, 15), (1, 1955, 1841, 1), OB, MONOCHROME1, 0\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"RG1_UNCI.dcm\", read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\n\n\nJ2KI_16_15_1_0_1F_M1 = PixelReference(\"RG1_J2KI.dcm\", \"<u2\", test)\n\n\n# J2KI, (16, 14), (1, 512, 512, 1), OW, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"693_UNCI.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KI_16_14_1_1_1F_M2 = PixelReference(\"693_J2KI.dcm\", \"<i2\", test)\n\n\n# J2KI, (16, 16), (1, 1024, 256, 1), OB, MONOCHROME2, 1\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file(\"JPEG2000_UNC.dcm\", read=True).pixel_array\n    assert np.array_equal(arr, ref)\n\n\nJ2KI_16_16_1_1_1F_M2 = PixelReference(\"JPEG2000.dcm\", \"<i2\", test)\n\n\n# HTJR, (8, 8), (1, 480, 640, 3), OB, RBG, 0\ndef test(ref, arr, **kwargs):\n    assert arr[160, 295:305].tolist() == [\n        [90, 38, 1],\n        [94, 40, 1],\n        [97, 42, 5],\n        [173, 122, 59],\n        [172, 133, 69],\n        [169, 135, 75],\n        [168, 136, 79],\n        [169, 137, 79],\n        [169, 137, 81],\n        [169, 136, 79],\n    ]\n    assert arr[275:285, 635].tolist() == [\n        [208, 193, 172],\n        [238, 228, 215],\n        [235, 229, 216],\n        [233, 226, 212],\n        [239, 231, 218],\n        [238, 232, 219],\n        [224, 218, 205],\n        [239, 234, 223],\n        [246, 241, 232],\n        [242, 236, 226],\n    ]\n\n\nHTJR_08_08_1_1_1F_RGB = PixelReference(\"HTJ2KLossless_08_RGB.dcm\", \"u1\", test)\n\n\n# HTJI, (8, 8), (1, 480, 640, 3), OB, RBG, 0\ndef test(ref, arr, **kwargs):\n    assert arr[160, 295:305].tolist() == [\n        [91, 37, 2],\n        [94, 40, 1],\n        [97, 42, 5],\n        [174, 123, 59],\n        [172, 132, 69],\n        [169, 134, 74],\n        [168, 136, 77],\n        [168, 137, 80],\n        [168, 136, 80],\n        [169, 136, 78],\n    ]\n    assert arr[275:285, 635].tolist() == [\n        [207, 193, 171],\n        [238, 229, 215],\n        [235, 228, 216],\n        [233, 226, 213],\n        [238, 231, 218],\n        [239, 232, 219],\n        [225, 218, 206],\n        [240, 234, 223],\n        [247, 240, 232],\n        [242, 236, 227],\n    ]\n\n\nHTJI_08_08_1_1_1F_RGB = PixelReference(\"HTJ2K_08_RGB.dcm\", \"u1\", test)\n\n\nPIXEL_REFERENCE[JPEG2000Lossless] = [\n    J2KR_08_08_3_0_1F_YBR_ICT,\n    J2KR_16_10_1_0_1F_M1,\n    J2KR_16_12_1_0_1F_M2,\n    J2KR_16_15_1_0_1F_M1,\n    J2KR_16_12_1_0_10F_M2,\n    J2KR_16_14_1_1_1F_M2,\n    J2KR_16_16_1_1_1F_M2,\n    J2KR_16_13_1_1_1F_M2_MISMATCH,\n    J2KR_08_08_3_0_1F_YBR_RCT,\n]\nPIXEL_REFERENCE[JPEG2000] = [\n    J2KI_08_08_3_0_1F_RGB,\n    J2KI_08_08_3_0_1F_YBR_ICT,\n    J2KI_16_10_1_0_1F_M1,\n    J2KI_16_12_1_0_1F_M2,\n    J2KI_16_15_1_0_1F_M1,\n    J2KI_16_14_1_1_1F_M2,\n    J2KI_16_16_1_1_1F_M2,\n]\nPIXEL_REFERENCE[HTJ2KLossless] = [HTJR_08_08_1_1_1F_RGB]\nPIXEL_REFERENCE[HTJ2KLosslessRPCL] = []\nPIXEL_REFERENCE[HTJ2K] = [HTJI_08_08_1_1_1F_RGB]\n"
  },
  "GT_src_dict": {
    "modified_testcases/pixels/pixels_reference.py": {
      "PixelReference.ds": {
        "code": "    def ds(self) -> 'Dataset':\n        \"\"\"Return the dataset containing the pixel data associated with the PixelReference instance.\n\nThis property ensures that the pixel data is lazily loaded. If the pixel data (stored in the private attribute _ds) has not been previously fetched (i.e., it is None), it calls the `get_testdata_file` function with the name of the file specified during initialization (self.name) to load the dataset. The dataset is expected to conform to the DICOM standard.\n\nReturns:\n    Dataset: The DICOM dataset containing the pixel data, read from a file.\n\nDependencies:\n    - get_testdata_file: A function from the pydicom.data module that retrieves and reads the DICOM file based on the name.\n    \nInteraction:\n    This property relies on the `name` attribute of the PixelReference instance to locate the DICOM file, providing centralized access to pixel data across different instances of the class.\"\"\"\n        'Return the dataset containing the pixel data'\n        if getattr(self, '_ds', None) is None:\n            self._ds = get_testdata_file(self.name, read=True)\n        return self._ds",
        "docstring": "Return the dataset containing the pixel data associated with the PixelReference instance.\n\nThis property ensures that the pixel data is lazily loaded. If the pixel data (stored in the private attribute _ds) has not been previously fetched (i.e., it is None), it calls the `get_testdata_file` function with the name of the file specified during initialization (self.name) to load the dataset. The dataset is expected to conform to the DICOM standard.\n\nReturns:\n    Dataset: The DICOM dataset containing the pixel data, read from a file.\n\nDependencies:\n    - get_testdata_file: A function from the pydicom.data module that retrieves and reads the DICOM file based on the name.\n    \nInteraction:\n    This property relies on the `name` attribute of the PixelReference instance to locate the DICOM file, providing centralized access to pixel data across different instances of the class.",
        "signature": "def ds(self) -> 'Dataset':",
        "type": "Method",
        "class_signature": "class PixelReference:"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: pydicom-test_decoder_base\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 modified_testcases/\n    \u2514\u2500\u2500 pixels/\n        \u2514\u2500\u2500 pixels_reference.py\n            \u2514\u2500\u2500 PixelReference.ds\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the decoding and processing of pixel data in DICOM (Digital Imaging and Communications in Medicine) files, supporting both encapsulated and native transfer syntaxes. Its primary functionality includes handling pixel data transformations, validating datasets for decoding compatibility, and converting imagery into structured numerical formats such as NumPy arrays or raw byte buffers. The module provides features such as decoding multi-frame images, managing color space conversions (including RGB and YBR), and ensuring compliance with metadata specifications like photometric interpretation and bit accuracy. By abstracting complex pixel data decoding processes, the module streamlines the workflow for developers working with medical imaging applications, reducing effort and ensuring robust handling of diverse encoding formats.\n\n## FILE 1: modified_testcases/pixels/pixels_reference.py\n\n- CLASS METHOD: PixelReference.ds\n  - CLASS SIGNATURE: class PixelReference:\n  - SIGNATURE: def ds(self) -> 'Dataset':\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the dataset containing the pixel data associated with the PixelReference instance.\n\nThis property ensures that the pixel data is lazily loaded. If the pixel data (stored in the private attribute _ds) has not been previously fetched (i.e., it is None), it calls the `get_testdata_file` function with the name of the file specified during initialization (self.name) to load the dataset. The dataset is expected to conform to the DICOM standard.\n\nReturns:\n    Dataset: The DICOM dataset containing the pixel data, read from a file.\n\nDependencies:\n    - get_testdata_file: A function from the pydicom.data module that retrieves and reads the DICOM file based on the name.\n    \nInteraction:\n    This property relies on the `name` attribute of the PixelReference instance to locate the DICOM file, providing centralized access to pixel data across different instances of the class.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "modified_testcases/pixels/pixels_reference.py": "from collections.abc import Callable\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\ntry:\n    import numpy as np\n    HAVE_NP = True\nexcept ImportError:\n    HAVE_NP = False\nfrom pydicom.data import get_testdata_file\nfrom pydicom.uid import ExplicitVRLittleEndian, ImplicitVRLittleEndian, DeflatedExplicitVRLittleEndian, ExplicitVRBigEndian, JPEGBaseline8Bit, JPEGExtended12Bit, JPEGLossless, JPEGLosslessSV1, JPEGLSLossless, JPEGLSNearLossless, JPEG2000Lossless, JPEG2000, HTJ2KLossless, HTJ2KLosslessRPCL, HTJ2K, RLELossless\nif TYPE_CHECKING:\n    from pydicom import Dataset\n\nclass PixelReference:\n\n    def __init__(self, name: str, dtype: str, test: Callable[['PixelReference', 'np.ndarray', dict[str, Any]], None]) -> None:\n        self.name = name\n        self.dtype = dtype\n        self._ds: Dataset\n        self._test = test\n\n    @property\n    def number_of_frames(self) -> int:\n        \"\"\"Return the expected number of frames of pixel data\"\"\"\n        value = self.ds.get('NumberOfFrames', 1)\n        value = int(value) if isinstance(value, str) else value\n        if value in (None, 0):\n            value = 1\n        return value\n\n    @property\n    def meta(self) -> list[str | int]:\n        \"\"\"Return a list of pixel metadata.\"\"\"\n        attr = [self.ds.file_meta.TransferSyntaxUID, self.ds.BitsAllocated, self.ds.BitsStored, self.ds.Rows, self.ds.Columns, self.ds.SamplesPerPixel, self.number_of_frames, self.ds.PhotometricInterpretation, self.ds[self.pixel_keyword].VR]\n        if self.pixel_keyword == 'PixelData':\n            attr.append(self.ds.PixelRepresentation)\n        return attr\n\n    @property\n    def path(self) -> Path:\n        return Path(get_testdata_file(self.name))\n\n    @property\n    def pixel_keyword(self) -> str:\n        \"\"\"Return the keyword used by the pixel data.\"\"\"\n        if 'PixelData' in self.ds:\n            return 'PixelData'\n        if 'FloatPixelData' in self.ds:\n            return 'FloatPixelData'\n        if 'DoubleFloatPixelData' in self.ds:\n            return 'DoubleFloatPixelData'\n        return ''\n\n    @property\n    def shape(self) -> tuple[int, ...]:\n        \"\"\"Return the expected array shape.\"\"\"\n        shape = []\n        if self.number_of_frames > 1:\n            shape.append(self.number_of_frames)\n        shape += [self.ds.Rows, self.ds.Columns]\n        if self.ds.SamplesPerPixel > 1:\n            shape.append(self.ds.SamplesPerPixel)\n        return tuple(shape)\n\n    def __str__(self) -> str:\n        \"\"\"Return a string representation of the pixel reference.\"\"\"\n        s = [self.name, f'  Transfer Syntax: {self.ds.file_meta.TransferSyntaxUID.name}', f'  BitsAllocated: {self.ds.BitsAllocated}', f'  BitsStored: {self.ds.BitsStored}', f'  Rows: {self.ds.Rows}', f'  Columns: {self.ds.Columns}', f'  SamplesPerPixel: {self.ds.SamplesPerPixel}', f'  NumberOfFrames: {self.number_of_frames}', f'  PhotometricInterpretation: {self.ds.PhotometricInterpretation}', f'  Pixel VR: {self.ds[self.pixel_keyword].VR}']\n        if self.pixel_keyword == 'PixelData':\n            s.append(f'  PixelRepresentation: {self.ds.PixelRepresentation}')\n        return '\\n'.join(s)\n\n    def test(self, arr: 'np.ndarray', **kwargs: dict[str, Any]) -> None:\n        self._test(self, arr, **kwargs)\nPIXEL_REFERENCE = {}\n\ndef test(ref, arr, **kwargs):\n    assert (0, 1, 1) == tuple(arr[155, 180:183])\n    assert (1, 0, 1, 0) == tuple(arr[155, 310:314])\n    assert (0, 1, 1) == tuple(arr[254, 78:81])\n    assert (1, 0, 0, 1, 1, 0) == tuple(arr[254, 304:310])\nEXPL_1_1_1F = PixelReference('liver_1frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    assert arr.max() == 1\n    assert arr.min() == 0\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 0 == frame[0][0]\n        assert (0, 1, 1) == tuple(frame[155, 180:183])\n        assert (1, 0, 1, 0) == tuple(frame[155, 310:314])\n        assert (0, 1, 1) == tuple(frame[254, 78:81])\n        assert (1, 0, 0, 1, 1, 0) == tuple(frame[254, 304:310])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 1 == frame[256][256]\n        assert 0 == frame[146, :254].max()\n        assert (0, 1, 1, 1, 1, 1, 0, 1) == tuple(frame[146, 253:261])\n        assert 0 == frame[146, 261:].max()\n        assert 0 == frame[210, :97].max()\n        assert 1 == frame[210, 97:350].max()\n        assert 0 == frame[210, 350:].max()\n    if index in (None, 2):\n        frame = arr if index == 2 else arr[2]\n        assert 0 == frame[-1][-1]\n        assert 0 == frame[147, :249].max()\n        assert (0, 1, 0, 1, 1, 1) == tuple(frame[147, 248:254])\n        assert (1, 0, 1, 0, 1, 1) == tuple(frame[147, 260:266])\n        assert 0 == frame[147, 283:].max()\n        assert 0 == frame[364, :138].max()\n        assert (0, 1, 0, 1, 1, 0, 0, 1) == tuple(frame[364, 137:145])\n        assert (1, 0, 0, 1, 0) == tuple(frame[364, 152:157])\n        assert 0 == frame[364, 157:].max()\nEXPL_1_1_3F = PixelReference('liver.dcm', 'u1', test)\nEXPL_1_1_3F_NONALIGNED = PixelReference('liver_nonbyte_aligned.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert 41 == arr[10].min()\n    assert 255 == arr[10].max()\n    assert (138, 65, 65, 65, 65, 35, 35, 35) == tuple(arr[300, 255:263])\n    assert 65 == arr[500].min()\n    assert 219 == arr[500].max()\nDEFL_8_1_1F = PixelReference('image_dfl.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[0].min() == arr[0].max()\n    assert (1, 246, 1) == tuple(arr[300, 491:494])\n    assert 0 == arr[-1].min() == arr[-1].max()\nEXPL_8_1_1F = PixelReference('OBXXXX1A.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max()\n        assert (1, 246, 1) == tuple(frame[300, 491:494])\n        assert 0 == frame[-1].min() == frame[-1].max()\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert (254, 9, 254) == tuple(frame[300, 491:494])\n        assert 255 == frame[-1].min() == frame[-1].max()\nEXPL_8_1_2F = PixelReference('OBXXXX1A_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert (255, 0, 0) == tuple(arr[5, 50, :])\n    assert (255, 128, 128) == tuple(arr[15, 50, :])\n    assert (0, 255, 0) == tuple(arr[25, 50, :])\n    assert (128, 255, 128) == tuple(arr[35, 50, :])\n    assert (0, 0, 255) == tuple(arr[45, 50, :])\n    assert (128, 128, 255) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (64, 64, 64) == tuple(arr[75, 50, :])\n    assert (192, 192, 192) == tuple(arr[85, 50, :])\n    assert (255, 255, 255) == tuple(arr[95, 50, :])\nEXPL_8_3_1F = PixelReference('SC_rgb.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0].tolist() == [[166, 141, 52], [166, 141, 52], [166, 141, 52]]\n    assert arr[1].tolist() == [[63, 87, 176], [63, 87, 176], [63, 87, 176]]\n    assert arr[2].tolist() == [[158, 158, 158], [158, 158, 158], [158, 158, 158]]\nEXPL_8_3_1F_ODD = PixelReference('SC_rgb_small_odd.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert (76, 85, 255) == tuple(arr[5, 50, :])\n    assert (166, 106, 193) == tuple(arr[15, 50, :])\n    assert (150, 46, 20) == tuple(arr[25, 50, :])\n    assert (203, 86, 75) == tuple(arr[35, 50, :])\n    assert (29, 255, 107) == tuple(arr[45, 50, :])\n    assert (142, 193, 118) == tuple(arr[55, 50, :])\n    assert (0, 128, 128) == tuple(arr[65, 50, :])\n    assert (64, 128, 128) == tuple(arr[75, 50, :])\n    assert (192, 128, 128) == tuple(arr[85, 50, :])\n    assert (255, 128, 128) == tuple(arr[95, 50, :])\nEXPL_8_3_1F_YBR422 = PixelReference('SC_ybr_full_422_uncompressed.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    if kwargs.get('as_rgb'):\n        assert (254, 0, 0) == tuple(arr[5, 50, :])\n        assert (255, 127, 127) == tuple(arr[15, 50, :])\n        assert (0, 255, 5) == tuple(arr[25, 50, :])\n        assert (129, 255, 129) == tuple(arr[35, 50, :])\n        assert (0, 0, 254) == tuple(arr[45, 50, :])\n        assert (128, 127, 255) == tuple(arr[55, 50, :])\n        assert (0, 0, 0) == tuple(arr[65, 50, :])\n        assert (64, 64, 64) == tuple(arr[75, 50, :])\n        assert (192, 192, 192) == tuple(arr[85, 50, :])\n        assert (255, 255, 255) == tuple(arr[95, 50, :])\n    else:\n        assert (76, 85, 255) == tuple(arr[5, 50, :])\n        assert (166, 106, 193) == tuple(arr[15, 50, :])\n        assert (150, 46, 20) == tuple(arr[25, 50, :])\n        assert (203, 86, 75) == tuple(arr[35, 50, :])\n        assert (29, 255, 107) == tuple(arr[45, 50, :])\n        assert (142, 193, 118) == tuple(arr[55, 50, :])\n        assert (0, 128, 128) == tuple(arr[65, 50, :])\n        assert (64, 128, 128) == tuple(arr[75, 50, :])\n        assert (192, 128, 128) == tuple(arr[85, 50, :])\n        assert (255, 128, 128) == tuple(arr[95, 50, :])\nEXPL_8_3_1F_YBR = PixelReference('SC_ybr_full_uncompressed.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (255, 0, 0) == tuple(frame[5, 50, :])\n        assert (255, 128, 128) == tuple(frame[15, 50, :])\n        assert (0, 255, 0) == tuple(frame[25, 50, :])\n        assert (128, 255, 128) == tuple(frame[35, 50, :])\n        assert (0, 0, 255) == tuple(frame[45, 50, :])\n        assert (128, 128, 255) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (64, 64, 64) == tuple(frame[75, 50, :])\n        assert (192, 192, 192) == tuple(frame[85, 50, :])\n        assert (255, 255, 255) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 255, 255) == tuple(frame[5, 50, :])\n        assert (0, 127, 127) == tuple(frame[15, 50, :])\n        assert (255, 0, 255) == tuple(frame[25, 50, :])\n        assert (127, 0, 127) == tuple(frame[35, 50, :])\n        assert (255, 255, 0) == tuple(frame[45, 50, :])\n        assert (127, 127, 0) == tuple(frame[55, 50, :])\n        assert (255, 255, 255) == tuple(frame[65, 50, :])\n        assert (191, 191, 191) == tuple(frame[75, 50, :])\n        assert (63, 63, 63) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPL_8_3_2F = PixelReference('SC_rgb_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[29, 77:81].tolist() == [[240, 243, 246], [214, 210, 213], [150, 134, 134], [244, 244, 244]]\n    assert arr[224:227, 253].tolist() == [[231, 236, 238], [190, 175, 178], [215, 200, 202]]\nIMPL_08_08_3_0_1F_RGB = PixelReference('SC_rgb_jpeg_dcmd.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[24, 36:40].tolist() == [520, 802, 930, 1008]\n    assert arr[40:45, 40].tolist() == [1138, 1165, 1113, 1088, 1072]\nEXPL_16_16_1F = PixelReference('CT_small.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert 862 == arr[-1, -1]\nIMPL_16_1_1F = PixelReference('MR_small_implicit.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert 862 == arr[-1, -1]\nEXPL_16_1_1F = PixelReference('MR_small.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert 862 == arr[-1, -1]\nEXPL_16_1_1F_PAD = PixelReference('MR_small_padded.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (206, 197, 159) == tuple(frame[0, 31:34])\n        assert (49, 78, 128) == tuple(frame[31, :3])\n        assert (362, 219, 135) == tuple(frame[-1, -3:])\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert (67, 82, 44) == tuple(frame[0, 31:34])\n        assert (37, 41, 17) == tuple(frame[31, :3])\n        assert (225, 380, 355) == tuple(frame[-1, -3:])\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert (72, 86, 69) == tuple(frame[0, 31:34])\n        assert (25, 4, 9) == tuple(frame[31, :3])\n        assert (227, 300, 147) == tuple(frame[-1, -3:])\nEXPL_16_1_10F = PixelReference('emri_small.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (65535, 0, 0) == tuple(arr[5, 50, :])\n    assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n    assert (0, 65535, 0) == tuple(arr[25, 50, :])\n    assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n    assert (0, 0, 65535) == tuple(arr[45, 50, :])\n    assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n    assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n    assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\nEXPL_16_3_1F = PixelReference('SC_rgb_16bit.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (65535, 0, 0) == tuple(frame[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(frame[15, 50, :])\n        assert (0, 65535, 0) == tuple(frame[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(frame[35, 50, :])\n        assert (0, 0, 65535) == tuple(frame[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(frame[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(frame[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 65535, 65535) == tuple(frame[5, 50, :])\n        assert (0, 32639, 32639) == tuple(frame[15, 50, :])\n        assert (65535, 0, 65535) == tuple(frame[25, 50, :])\n        assert (32639, 0, 32639) == tuple(frame[35, 50, :])\n        assert (65535, 65535, 0) == tuple(frame[45, 50, :])\n        assert (32639, 32639, 0) == tuple(frame[55, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[65, 50, :])\n        assert (49087, 49087, 49087) == tuple(frame[75, 50, :])\n        assert (16191, 16191, 16191) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPL_16_3_2F = PixelReference('SC_rgb_16bit_2frame.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n    assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n    assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\nIMPL_32_1_1F = PixelReference('rtdose_1frame.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index')\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (1249000, 1249000, 1250000) == tuple(frame[0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(frame[4, 3:6])\n        assert (803000, 801000, 798000) == tuple(frame[-1, -3:])\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert (1253000, 1253000, 1249000) == tuple(frame[0, :3])\n        assert (1026000, 1023000, 1022000) == tuple(frame[4, 3:6])\n        assert (803000, 803000, 803000) == tuple(frame[-1, -3:])\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert (1249000, 1250000, 1251000) == tuple(frame[0, :3])\n        assert (1031000, 1031000, 1031000) == tuple(frame[4, 3:6])\n        assert (801000, 800000, 799000) == tuple(frame[-1, -3:])\nIMPL_32_1_15F = PixelReference('rtdose.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    assert (4294967295, 0, 0) == tuple(arr[5, 50, :])\n    assert (4294967295, 2155905152, 2155905152) == tuple(arr[15, 50, :])\n    assert (0, 4294967295, 0) == tuple(arr[25, 50, :])\n    assert (2155905152, 4294967295, 2155905152) == tuple(arr[35, 50, :])\n    assert (0, 0, 4294967295) == tuple(arr[45, 50, :])\n    assert (2155905152, 2155905152, 4294967295) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (1077952576, 1077952576, 1077952576) == tuple(arr[75, 50, :])\n    assert (3233857728, 3233857728, 3233857728) == tuple(arr[85, 50, :])\n    assert (4294967295, 4294967295, 4294967295) == tuple(arr[95, 50, :])\nEXPL_32_3_1F = PixelReference('SC_rgb_32bit.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (4294967295, 0, 0) == tuple(frame[5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(frame[15, 50, :])\n        assert (0, 4294967295, 0) == tuple(frame[25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(frame[35, 50, :])\n        assert (0, 0, 4294967295) == tuple(frame[45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(frame[75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(frame[85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 4294967295, 4294967295) == tuple(frame[5, 50, :])\n        assert (0, 2139062143, 2139062143) == tuple(frame[15, 50, :])\n        assert (4294967295, 0, 4294967295) == tuple(frame[25, 50, :])\n        assert (2139062143, 0, 2139062143) == tuple(frame[35, 50, :])\n        assert (4294967295, 4294967295, 0) == tuple(frame[45, 50, :])\n        assert (2139062143, 2139062143, 0) == tuple(frame[55, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[65, 50, :])\n        assert (3217014719, 3217014719, 3217014719) == tuple(frame[75, 50, :])\n        assert (1061109567, 1061109567, 1061109567) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPL_32_3_2F = PixelReference('SC_rgb_32bit_2frame.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    assert [0.92012787, 0.91510725, 0.9160201, 0.92104053] == [round(x, 8) for x in arr[:4, 0]]\nEXPL_32_1F_FLOAT = PixelReference('parametric_map_float.dcm', '<f4', test)\n\ndef test(ref, arr, **kwargs):\n    assert [0.9201278, 0.91510726, 0.91602008, 0.92104062] == [round(x, 8) for x in arr[:4, 0]]\nEXPL_64_1F_DOUBLE_FLOAT = PixelReference('parametric_map_double_float.dcm', '<f8', test)\nPIXEL_REFERENCE[ExplicitVRLittleEndian] = [EXPL_1_1_1F, EXPL_1_1_3F, EXPL_1_1_3F_NONALIGNED, EXPL_8_1_1F, EXPL_8_1_2F, EXPL_8_3_1F, EXPL_8_3_1F_ODD, EXPL_8_3_1F_YBR422, EXPL_8_3_1F_YBR, EXPL_8_3_2F, EXPL_16_16_1F, EXPL_16_1_1F, EXPL_16_1_1F_PAD, EXPL_16_1_10F, EXPL_16_3_1F, EXPL_16_3_2F, EXPL_32_3_1F, EXPL_32_3_2F, EXPL_32_1F_FLOAT, EXPL_64_1F_DOUBLE_FLOAT]\nPIXEL_REFERENCE[ImplicitVRLittleEndian] = [IMPL_08_08_3_0_1F_RGB, IMPL_16_1_1F, IMPL_32_1_1F, IMPL_32_1_15F]\nPIXEL_REFERENCE[DeflatedExplicitVRLittleEndian] = [DEFL_8_1_1F]\n\ndef test(ref, arr, **kwargs):\n    assert 0 == arr.min()\n    assert 1 == arr.max()\n    assert tuple(arr[145, 250:260]) == (0, 0, 0, 0, 1, 1, 1, 1, 1, 0)\nEXPB_1_1_1F = PixelReference('liver_expb_1frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    assert arr.max() == 1\n    assert arr.min() == 0\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 0 == frame[0][0]\n        assert (0, 1, 1) == tuple(frame[155, 180:183])\n        assert (1, 0, 1, 0) == tuple(frame[155, 310:314])\n        assert (0, 1, 1) == tuple(frame[254, 78:81])\n        assert (1, 0, 0, 1, 1, 0) == tuple(frame[254, 304:310])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 1 == frame[256][256]\n        assert 0 == frame[146, :254].max()\n        assert (0, 1, 1, 1, 1, 1, 0, 1) == tuple(frame[146, 253:261])\n        assert 0 == frame[146, 261:].max()\n        assert 0 == frame[210, :97].max()\n        assert 1 == frame[210, 97:350].max()\n        assert 0 == frame[210, 350:].max()\n    if index in (None, 2):\n        frame = arr if index == 2 else arr[2]\n        assert 0 == frame[147, :249].max()\n        assert 0 == frame[511][511]\n        assert (0, 1, 0, 1, 1, 1) == tuple(frame[147, 248:254])\n        assert (1, 0, 1, 0, 1, 1) == tuple(frame[147, 260:266])\n        assert 0 == frame[147, 283:].max()\n        assert 0 == frame[364, :138].max()\n        assert (0, 1, 0, 1, 1, 0, 0, 1) == tuple(frame[364, 137:145])\n        assert (1, 0, 0, 1, 0) == tuple(frame[364, 152:157])\n        assert 0 == frame[364, 157:].max()\nEXPB_1_1_3F = PixelReference('liver_expb.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[0].min() == arr[0].max()\n    assert (1, 246, 1) == tuple(arr[300, 491:494])\n    assert 0 == arr[-1].min() == arr[-1].max()\nEXPB_8_1_1F = PixelReference('OBXXXX1A_expb.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max()\n        assert (1, 246, 1) == tuple(frame[300, 491:494])\n        assert 0 == frame[-1].min() == frame[-1].max()\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert (254, 9, 254) == tuple(frame[300, 491:494])\n        assert 255 == frame[-1].min() == frame[-1].max()\nEXPB_8_1_2F = PixelReference('OBXXXX1A_expb_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert (255, 0, 0) == tuple(arr[5, 50, :])\n    assert (255, 128, 128) == tuple(arr[15, 50, :])\n    assert (0, 255, 0) == tuple(arr[25, 50, :])\n    assert (128, 255, 128) == tuple(arr[35, 50, :])\n    assert (0, 0, 255) == tuple(arr[45, 50, :])\n    assert (128, 128, 255) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (64, 64, 64) == tuple(arr[75, 50, :])\n    assert (192, 192, 192) == tuple(arr[85, 50, :])\n    assert (255, 255, 255) == tuple(arr[95, 50, :])\nEXPB_8_3_1F = PixelReference('SC_rgb_expb.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [166, 141, 52]\n    assert arr[1, 0].tolist() == [63, 87, 176]\n    assert arr[2, 0].tolist() == [158, 158, 158]\n    assert arr[-1, -1].tolist() == [158, 158, 158]\nEXPB_8_3_1F_ODD = PixelReference('SC_rgb_small_odd_big_endian.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[9, 3:6].tolist() == [[171, 171, 171], [255, 255, 255], [255, 255, 0]]\n    assert arr[58, 8:12].tolist() == [[255, 236, 0], [255, 183, 0], [255, 175, 0], [255, 183, 0]]\nEXPB_8_8_3_1F_RGB = PixelReference('ExplVR_BigEnd.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (255, 0, 0) == tuple(frame[5, 50, :])\n        assert (255, 128, 128) == tuple(frame[15, 50, :])\n        assert (0, 255, 0) == tuple(frame[25, 50, :])\n        assert (128, 255, 128) == tuple(frame[35, 50, :])\n        assert (0, 0, 255) == tuple(frame[45, 50, :])\n        assert (128, 128, 255) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (64, 64, 64) == tuple(frame[75, 50, :])\n        assert (192, 192, 192) == tuple(frame[85, 50, :])\n        assert (255, 255, 255) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 255, 255) == tuple(frame[5, 50, :])\n        assert (0, 127, 127) == tuple(frame[15, 50, :])\n        assert (255, 0, 255) == tuple(frame[25, 50, :])\n        assert (127, 0, 127) == tuple(frame[35, 50, :])\n        assert (255, 255, 0) == tuple(frame[45, 50, :])\n        assert (127, 127, 0) == tuple(frame[55, 50, :])\n        assert (255, 255, 255) == tuple(frame[65, 50, :])\n        assert (191, 191, 191) == tuple(frame[75, 50, :])\n        assert (63, 63, 63) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPB_8_3_2F = PixelReference('SC_rgb_expb_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert 862 == arr[-1, -1]\nEXPB_16_1_1F = PixelReference('MR_small_expb.dcm', '>i2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (206, 197, 159) == tuple(frame[0, 31:34])\n        assert (49, 78, 128) == tuple(frame[31, :3])\n        assert (362, 219, 135) == tuple(frame[-1, -3:])\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert (67, 82, 44) == tuple(frame[0, 31:34])\n        assert (37, 41, 17) == tuple(frame[31, :3])\n        assert (225, 380, 355) == tuple(frame[-1, -3:])\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert (72, 86, 69) == tuple(frame[0, 31:34])\n        assert (25, 4, 9) == tuple(frame[31, :3])\n        assert (227, 300, 147) == tuple(frame[-1, -3:])\nEXPB_16_1_10F = PixelReference('emri_small_big_endian.dcm', '>u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (65535, 0, 0) == tuple(arr[5, 50, :])\n    assert (65535, 32896, 32896) == tuple(arr[15, 50, :])\n    assert (0, 65535, 0) == tuple(arr[25, 50, :])\n    assert (32896, 65535, 32896) == tuple(arr[35, 50, :])\n    assert (0, 0, 65535) == tuple(arr[45, 50, :])\n    assert (32896, 32896, 65535) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (16448, 16448, 16448) == tuple(arr[75, 50, :])\n    assert (49344, 49344, 49344) == tuple(arr[85, 50, :])\n    assert (65535, 65535, 65535) == tuple(arr[95, 50, :])\nEXPB_16_3_1F = PixelReference('SC_rgb_expb_16bit.dcm', '>u2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (65535, 0, 0) == tuple(frame[5, 50, :])\n        assert (65535, 32896, 32896) == tuple(frame[15, 50, :])\n        assert (0, 65535, 0) == tuple(frame[25, 50, :])\n        assert (32896, 65535, 32896) == tuple(frame[35, 50, :])\n        assert (0, 0, 65535) == tuple(frame[45, 50, :])\n        assert (32896, 32896, 65535) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (16448, 16448, 16448) == tuple(frame[75, 50, :])\n        assert (49344, 49344, 49344) == tuple(frame[85, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 65535, 65535) == tuple(frame[5, 50, :])\n        assert (0, 32639, 32639) == tuple(frame[15, 50, :])\n        assert (65535, 0, 65535) == tuple(frame[25, 50, :])\n        assert (32639, 0, 32639) == tuple(frame[35, 50, :])\n        assert (65535, 65535, 0) == tuple(frame[45, 50, :])\n        assert (32639, 32639, 0) == tuple(frame[55, 50, :])\n        assert (65535, 65535, 65535) == tuple(frame[65, 50, :])\n        assert (49087, 49087, 49087) == tuple(frame[75, 50, :])\n        assert (16191, 16191, 16191) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPB_16_3_2F = PixelReference('SC_rgb_expb_16bit_2frame.dcm', '>u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (1249000, 1249000, 1250000) == tuple(arr[0, :3])\n    assert (1031000, 1029000, 1027000) == tuple(arr[4, 3:6])\n    assert (803000, 801000, 798000) == tuple(arr[-1, -3:])\nEXPB_32_1_1F = PixelReference('rtdose_expb_1frame.dcm', '>u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (1249000, 1249000, 1250000) == tuple(frame[0, :3])\n        assert (1031000, 1029000, 1027000) == tuple(frame[4, 3:6])\n        assert (803000, 801000, 798000) == tuple(frame[-1, -3:])\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert (1253000, 1253000, 1249000) == tuple(frame[0, :3])\n        assert (1026000, 1023000, 1022000) == tuple(frame[4, 3:6])\n        assert (803000, 803000, 803000) == tuple(frame[-1, -3:])\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert (1249000, 1250000, 1251000) == tuple(frame[0, :3])\n        assert (1031000, 1031000, 1031000) == tuple(frame[4, 3:6])\n        assert (801000, 800000, 799000) == tuple(frame[-1, -3:])\nEXPB_32_1_15F = PixelReference('rtdose_expb.dcm', '>u4', test)\n\ndef test(ref, arr, **kwargs):\n    assert (4294967295, 0, 0) == tuple(arr[5, 50, :])\n    assert (4294967295, 2155905152, 2155905152) == tuple(arr[15, 50, :])\n    assert (0, 4294967295, 0) == tuple(arr[25, 50, :])\n    assert (2155905152, 4294967295, 2155905152) == tuple(arr[35, 50, :])\n    assert (0, 0, 4294967295) == tuple(arr[45, 50, :])\n    assert (2155905152, 2155905152, 4294967295) == tuple(arr[55, 50, :])\n    assert (0, 0, 0) == tuple(arr[65, 50, :])\n    assert (1077952576, 1077952576, 1077952576) == tuple(arr[75, 50, :])\n    assert (3233857728, 3233857728, 3233857728) == tuple(arr[85, 50, :])\n    assert (4294967295, 4294967295, 4294967295) == tuple(arr[95, 50, :])\nEXPB_32_3_1F = PixelReference('SC_rgb_expb_32bit.dcm', '>u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert (4294967295, 0, 0) == tuple(frame[5, 50, :])\n        assert (4294967295, 2155905152, 2155905152) == tuple(frame[15, 50, :])\n        assert (0, 4294967295, 0) == tuple(frame[25, 50, :])\n        assert (2155905152, 4294967295, 2155905152) == tuple(frame[35, 50, :])\n        assert (0, 0, 4294967295) == tuple(frame[45, 50, :])\n        assert (2155905152, 2155905152, 4294967295) == tuple(frame[55, 50, :])\n        assert (0, 0, 0) == tuple(frame[65, 50, :])\n        assert (1077952576, 1077952576, 1077952576) == tuple(frame[75, 50, :])\n        assert (3233857728, 3233857728, 3233857728) == tuple(frame[85, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[95, 50, :])\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert (0, 4294967295, 4294967295) == tuple(frame[5, 50, :])\n        assert (0, 2139062143, 2139062143) == tuple(frame[15, 50, :])\n        assert (4294967295, 0, 4294967295) == tuple(frame[25, 50, :])\n        assert (2139062143, 0, 2139062143) == tuple(frame[35, 50, :])\n        assert (4294967295, 4294967295, 0) == tuple(frame[45, 50, :])\n        assert (2139062143, 2139062143, 0) == tuple(frame[55, 50, :])\n        assert (4294967295, 4294967295, 4294967295) == tuple(frame[65, 50, :])\n        assert (3217014719, 3217014719, 3217014719) == tuple(frame[75, 50, :])\n        assert (1061109567, 1061109567, 1061109567) == tuple(frame[85, 50, :])\n        assert (0, 0, 0) == tuple(frame[95, 50, :])\nEXPB_32_3_2F = PixelReference('SC_rgb_expb_32bit_2frame.dcm', '>u4', test)\nPIXEL_REFERENCE[ExplicitVRBigEndian] = [EXPB_1_1_1F, EXPB_1_1_3F, EXPB_8_1_1F, EXPB_8_1_2F, EXPB_8_3_1F, EXPB_8_3_1F_ODD, EXPB_8_8_3_1F_RGB, EXPB_8_3_2F, EXPB_16_1_1F, EXPB_16_1_10F, EXPB_16_3_1F, EXPB_16_3_2F, EXPB_32_1_1F, EXPB_32_1_15F, EXPB_32_3_1F, EXPB_32_3_2F]\n\ndef test(ref, arr, **kwargs):\n    assert arr[0].min() == arr[0].max() == 244\n    assert tuple(arr[300, 491:494]) == (1, 246, 1)\n    assert arr[-1].min() == arr[-1].max() == 0\nRLE_8_1_1F = PixelReference('OBXXXX1A_rle.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert 244 == frame[0].min() == frame[0].max() == 244\n        assert tuple(frame[300, 491:494]) == (1, 246, 1)\n        assert frame[-1].min() == frame[-1].max() == 0\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert 11 == frame[0].min() == frame[0].max()\n        assert tuple(frame[300, 491:494]) == (254, 9, 254)\n        assert frame[-1].min() == frame[-1].max() == 255\nRLE_8_1_2F = PixelReference('OBXXXX1A_rle_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\nRLE_8_3_1F = PixelReference('SC_rgb_rle.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (255, 0, 0)\n        assert tuple(frame[15, 50, :]) == (255, 128, 128)\n        assert tuple(frame[25, 50, :]) == (0, 255, 0)\n        assert tuple(frame[35, 50, :]) == (128, 255, 128)\n        assert tuple(frame[45, 50, :]) == (0, 0, 255)\n        assert tuple(frame[55, 50, :]) == (128, 128, 255)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (64, 64, 64)\n        assert tuple(frame[85, 50, :]) == (192, 192, 192)\n        assert tuple(frame[95, 50, :]) == (255, 255, 255)\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 255, 255)\n        assert tuple(frame[15, 50, :]) == (0, 127, 127)\n        assert tuple(frame[25, 50, :]) == (255, 0, 255)\n        assert tuple(frame[35, 50, :]) == (127, 0, 127)\n        assert tuple(frame[45, 50, :]) == (255, 255, 0)\n        assert tuple(frame[55, 50, :]) == (127, 127, 0)\n        assert tuple(frame[65, 50, :]) == (255, 255, 255)\n        assert tuple(frame[75, 50, :]) == (191, 191, 191)\n        assert tuple(frame[85, 50, :]) == (63, 63, 63)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\nRLE_8_3_2F = PixelReference('SC_rgb_rle_2frame.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[0, 31:34]) == (422, 319, 361)\n    assert tuple(arr[31, :3]) == (366, 363, 322)\n    assert tuple(arr[-1, -3:]) == (1369, 1129, 862)\nRLE_16_1_1F = PixelReference('MR_small_RLE.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[0, 31:34]) == (206, 197, 159)\n        assert tuple(frame[31, :3]) == (49, 78, 128)\n        assert tuple(frame[-1, -3:]) == (362, 219, 135)\n    if index in (None, 4):\n        frame = arr if index == 4 else arr[4]\n        assert tuple(frame[0, 31:34]) == (67, 82, 44)\n        assert tuple(frame[31, :3]) == (37, 41, 17)\n        assert tuple(frame[-1, -3:]) == (225, 380, 355)\n    if index in (None, 9):\n        frame = arr if index == 9 else arr[9]\n        assert tuple(frame[0, 31:34]) == (72, 86, 69)\n        assert tuple(frame[31, :3]) == (25, 4, 9)\n        assert tuple(frame[-1, -3:]) == (227, 300, 147)\nRLE_16_1_10F = PixelReference('emri_small_RLE.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (65535, 0, 0)\n    assert tuple(arr[15, 50, :]) == (65535, 32896, 32896)\n    assert tuple(arr[25, 50, :]) == (0, 65535, 0)\n    assert tuple(arr[35, 50, :]) == (32896, 65535, 32896)\n    assert tuple(arr[45, 50, :]) == (0, 0, 65535)\n    assert tuple(arr[55, 50, :]) == (32896, 32896, 65535)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (16448, 16448, 16448)\n    assert tuple(arr[85, 50, :]) == (49344, 49344, 49344)\n    assert tuple(arr[95, 50, :]) == (65535, 65535, 65535)\nRLE_16_3_1F = PixelReference('SC_rgb_rle_16bit.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (65535, 0, 0)\n        assert tuple(frame[15, 50, :]) == (65535, 32896, 32896)\n        assert tuple(frame[25, 50, :]) == (0, 65535, 0)\n        assert tuple(frame[35, 50, :]) == (32896, 65535, 32896)\n        assert tuple(frame[45, 50, :]) == (0, 0, 65535)\n        assert tuple(frame[55, 50, :]) == (32896, 32896, 65535)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (16448, 16448, 16448)\n        assert tuple(frame[85, 50, :]) == (49344, 49344, 49344)\n        assert tuple(frame[95, 50, :]) == (65535, 65535, 65535)\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 65535, 65535)\n        assert tuple(frame[15, 50, :]) == (0, 32639, 32639)\n        assert tuple(frame[25, 50, :]) == (65535, 0, 65535)\n        assert tuple(frame[35, 50, :]) == (32639, 0, 32639)\n        assert tuple(frame[45, 50, :]) == (65535, 65535, 0)\n        assert tuple(frame[55, 50, :]) == (32639, 32639, 0)\n        assert tuple(frame[65, 50, :]) == (65535, 65535, 65535)\n        assert tuple(frame[75, 50, :]) == (49087, 49087, 49087)\n        assert tuple(frame[85, 50, :]) == (16191, 16191, 16191)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\nRLE_16_3_2F = PixelReference('SC_rgb_rle_16bit_2frame.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[0, :3]) == (1249000, 1249000, 1250000)\n    assert tuple(arr[4, 3:6]) == (1031000, 1029000, 1027000)\n    assert tuple(arr[-1, -3:]) == (803000, 801000, 798000)\nRLE_32_1_1F = PixelReference('rtdose_rle_1frame.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[0, :3]) == (1249000, 1249000, 1250000)\n        assert tuple(frame[4, 3:6]) == (1031000, 1029000, 1027000)\n        assert tuple(frame[-1, -3:]) == (803000, 801000, 798000)\n    if index in (None, 7):\n        frame = arr if index == 7 else arr[7]\n        assert tuple(frame[0, :3]) == (1253000, 1253000, 1249000)\n        assert tuple(frame[4, 3:6]) == (1026000, 1023000, 1022000)\n        assert tuple(frame[-1, -3:]) == (803000, 803000, 803000)\n    if index in (None, 14):\n        frame = arr if index == 14 else arr[14]\n        assert tuple(frame[0, :3]) == (1249000, 1250000, 1251000)\n        assert tuple(frame[4, 3:6]) == (1031000, 1031000, 1031000)\n        assert tuple(frame[-1, -3:]) == (801000, 800000, 799000)\nRLE_32_1_15F = PixelReference('rtdose_rle.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (4294967295, 0, 0)\n    assert tuple(arr[15, 50, :]) == (4294967295, 2155905152, 2155905152)\n    assert tuple(arr[25, 50, :]) == (0, 4294967295, 0)\n    assert tuple(arr[35, 50, :]) == (2155905152, 4294967295, 2155905152)\n    assert tuple(arr[45, 50, :]) == (0, 0, 4294967295)\n    assert tuple(arr[55, 50, :]) == (2155905152, 2155905152, 4294967295)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (1077952576, 1077952576, 1077952576)\n    assert tuple(arr[85, 50, :]) == (3233857728, 3233857728, 3233857728)\n    assert tuple(arr[95, 50, :]) == (4294967295, 4294967295, 4294967295)\nRLE_32_3_1F = PixelReference('SC_rgb_rle_32bit.dcm', '<u4', test)\n\ndef test(ref, arr, **kwargs):\n    index = kwargs.get('index', None)\n    if index in (None, 0):\n        frame = arr if index == 0 else arr[0]\n        assert tuple(frame[5, 50, :]) == (4294967295, 0, 0)\n        assert tuple(frame[15, 50, :]) == (4294967295, 2155905152, 2155905152)\n        assert tuple(frame[25, 50, :]) == (0, 4294967295, 0)\n        assert tuple(frame[35, 50, :]) == (2155905152, 4294967295, 2155905152)\n        assert tuple(frame[45, 50, :]) == (0, 0, 4294967295)\n        assert tuple(frame[55, 50, :]) == (2155905152, 2155905152, 4294967295)\n        assert tuple(frame[65, 50, :]) == (0, 0, 0)\n        assert tuple(frame[75, 50, :]) == (1077952576, 1077952576, 1077952576)\n        assert tuple(frame[85, 50, :]) == (3233857728, 3233857728, 3233857728)\n        assert tuple(frame[95, 50, :]) == (4294967295, 4294967295, 4294967295)\n    if index in (None, 1):\n        frame = arr if index == 1 else arr[1]\n        assert tuple(frame[5, 50, :]) == (0, 4294967295, 4294967295)\n        assert tuple(frame[15, 50, :]) == (0, 2139062143, 2139062143)\n        assert tuple(frame[25, 50, :]) == (4294967295, 0, 4294967295)\n        assert tuple(frame[35, 50, :]) == (2139062143, 0, 2139062143)\n        assert tuple(frame[45, 50, :]) == (4294967295, 4294967295, 0)\n        assert tuple(frame[55, 50, :]) == (2139062143, 2139062143, 0)\n        assert tuple(frame[65, 50, :]) == (4294967295, 4294967295, 4294967295)\n        assert tuple(frame[75, 50, :]) == (3217014719, 3217014719, 3217014719)\n        assert tuple(frame[85, 50, :]) == (1061109567, 1061109567, 1061109567)\n        assert tuple(frame[95, 50, :]) == (0, 0, 0)\nRLE_32_3_2F = PixelReference('SC_rgb_rle_32bit_2frame.dcm', '<u4', test)\nPIXEL_REFERENCE[RLELossless] = [RLE_8_1_1F, RLE_8_1_2F, RLE_8_3_1F, RLE_8_3_2F, RLE_16_1_1F, RLE_16_1_10F, RLE_16_3_1F, RLE_16_3_2F, RLE_32_1_1F, RLE_32_1_15F, RLE_32_3_1F, RLE_32_3_2F]\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[0, 0, :]) == (138, 78, 147)\n    assert tuple(arr[1, 0, :]) == (90, 178, 108)\n    assert tuple(arr[2, 0, :]) == (158, 126, 129)\nJPGB_08_08_3_0_1F_YBR_FULL = PixelReference('SC_rgb_small_odd_jpeg.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[29, 77:81].tolist() == [[240, 243, 246], [214, 210, 213], [150, 134, 134], [244, 244, 244]]\n    if kwargs.get('plugin', None) in ('pillow', 'gdcm'):\n        assert arr[224:227, 253].tolist() == [[231, 236, 238], [190, 175, 178], [215, 200, 202]]\n    else:\n        assert arr[224:227, 253].tolist() == [[232, 236, 238], [190, 175, 178], [215, 200, 202]]\nJPGB_08_08_3_0_1F_RGB_NO_APP14 = PixelReference('SC_jpeg_no_color_transform.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    plugin = kwargs.get('plugin', None)\n    if plugin in ('pillow', 'gdcm'):\n        assert arr[99:104, 172].tolist() == [[243, 244, 246], [229, 224, 235], [204, 190, 213], [194, 176, 203], [204, 188, 211]]\n        assert arr[84, 239:243].tolist() == [[229, 225, 234], [174, 174, 202], [187, 185, 203], [210, 207, 225]]\n    elif plugin == 'pylibjpeg':\n        assert arr[99:104, 172].tolist() == [[243, 244, 246], [229, 224, 235], [204, 191, 213], [194, 176, 203], [204, 188, 211]]\n        assert arr[84, 239:243].tolist() == [[229, 225, 234], [174, 174, 202], [187, 185, 203], [211, 207, 225]]\nJPGB_08_08_3_0_1F_RGB_APP14 = PixelReference('SC_jpeg_no_color_transform_2.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    plugin = kwargs.get('plugin', None)\n    if plugin in ('pillow', 'gdcm'):\n        assert arr[99:104, 172].tolist() == [[243, 244, 246], [229, 224, 235], [204, 190, 213], [194, 176, 203], [204, 188, 211]]\n        assert arr[84, 239:243].tolist() == [[229, 225, 234], [174, 174, 202], [187, 185, 203], [210, 207, 225]]\n    elif plugin == 'pylibjpeg':\n        assert arr[99:104, 172].tolist() == [[243, 244, 246], [229, 224, 235], [204, 191, 213], [194, 176, 203], [204, 188, 211]]\n        assert arr[84, 239:243].tolist() == [[229, 225, 234], [174, 174, 202], [187, 185, 203], [211, 207, 225]]\nJPGB_08_08_3_0_1F_RGB_DCMD_APP14 = PixelReference('SC_rgb_jpeg_app14_dcmd.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    if kwargs.get('as_rgb', False) and kwargs.get('plugin', None) == 'pylibjpeg':\n        index = kwargs.get('index', None)\n        if index == 0:\n            assert arr[278, 300:310].tolist() == [[64, 64, 64], [76, 76, 76], [86, 86, 86], [95, 95, 95], [95, 95, 95], [97, 97, 97], [98, 98, 98], [98, 98, 98], [106, 106, 106], [108, 108, 108]]\n        if index == 60:\n            assert arr[278, 300:310].tolist() == [[36, 36, 36], [38, 38, 38], [41, 41, 41], [47, 47, 47], [50, 50, 50], [50, 50, 50], [53, 53, 53], [51, 51, 51], [47, 47, 47], [38, 38, 38]]\n        if index == -1:\n            assert arr[278, 300:310].tolist() == [[46, 46, 46], [55, 55, 55], [64, 64, 64], [74, 74, 74], [81, 81, 81], [86, 86, 86], [97, 97, 97], [104, 104, 104], [110, 110, 110], [117, 117, 117]]\n        return\n    assert arr[0, 278, 300:310].tolist() == [[64, 128, 128], [76, 128, 128], [86, 128, 128], [95, 128, 128], [95, 128, 128], [97, 128, 128], [98, 128, 128], [98, 128, 128], [106, 128, 128], [108, 128, 128]]\n    if kwargs.get('plugin', None) in ('pillow', 'gdcm'):\n        assert arr[59, 278, 300:310].tolist() == [[22, 128, 128], [22, 128, 128], [27, 128, 128], [32, 128, 128], [32, 128, 128], [29, 128, 128], [23, 128, 128], [21, 128, 128], [24, 128, 128], [33, 128, 128]]\n        assert arr[-1, 278, 300:310].tolist() == [[46, 128, 128], [55, 128, 128], [64, 128, 128], [74, 128, 128], [80, 128, 128], [86, 128, 128], [97, 128, 128], [104, 128, 128], [110, 128, 128], [117, 128, 128]]\n    elif kwargs.get('plugin', None) == 'pylibjpeg':\n        assert arr[59, 278, 300:310].tolist() == [[22, 128, 128], [22, 128, 128], [27, 128, 128], [32, 128, 128], [32, 128, 128], [30, 128, 128], [23, 128, 128], [21, 128, 128], [24, 128, 128], [33, 128, 128]]\n        assert arr[-1, 278, 300:310].tolist() == [[46, 128, 128], [55, 128, 128], [64, 128, 128], [74, 128, 128], [81, 128, 128], [86, 128, 128], [97, 128, 128], [104, 128, 128], [110, 128, 128], [117, 128, 128]]\nJPGB_08_08_3_0_120F_YBR_FULL_422 = PixelReference('color3d_jpeg_baseline.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_1F_YBR_FULL = PixelReference('SC_rgb_jpeg_dcmtk.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    if kwargs.get('plugin', None) in ('pillow', 'gdcm'):\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 109, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 85, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 108)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n    else:\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 108, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 86, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 107)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_0_1F_YBR_FULL_422_411 = PixelReference('SC_rgb_dcmtk_+eb+cy+np.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_0_1F_YBR_FULL_422_422 = PixelReference('SC_rgb_dcmtk_+eb+cy+s2.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    if kwargs.get('plugin', None) in ('pillow', 'gdcm'):\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 109, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 85, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 108)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\n    else:\n        assert tuple(arr[5, 50, :]) == (76, 85, 254)\n        assert tuple(arr[15, 50, :]) == (166, 108, 190)\n        assert tuple(arr[25, 50, :]) == (150, 46, 21)\n        assert tuple(arr[35, 50, :]) == (203, 86, 74)\n        assert tuple(arr[45, 50, :]) == (29, 255, 107)\n        assert tuple(arr[55, 50, :]) == (142, 192, 117)\n        assert tuple(arr[65, 50, :]) == (0, 128, 128)\n        assert tuple(arr[75, 50, :]) == (64, 128, 128)\n        assert tuple(arr[85, 50, :]) == (192, 128, 128)\n        assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_0_1F_YBR_FULL_411 = PixelReference('SC_rgb_dcmtk_+eb+cy+n1.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_0_1F_YBR_FULL_422 = PixelReference('SC_rgb_dcmtk_+eb+cy+n2.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 106, 193)\n    assert tuple(arr[25, 50, :]) == (150, 46, 20)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 193, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_0_1F_YBR_FULL_444 = PixelReference('SC_rgb_dcmtk_+eb+cy+s4.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\nJPGB_08_08_3_0_1F_RGB = PixelReference('SC_rgb_dcmtk_+eb+cr.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (76, 85, 255)\n    assert tuple(arr[15, 50, :]) == (166, 107, 191)\n    assert tuple(arr[25, 50, :]) == (150, 44, 21)\n    assert tuple(arr[35, 50, :]) == (203, 86, 75)\n    assert tuple(arr[45, 50, :]) == (29, 255, 107)\n    assert tuple(arr[55, 50, :]) == (142, 191, 118)\n    assert tuple(arr[65, 50, :]) == (0, 128, 128)\n    assert tuple(arr[75, 50, :]) == (64, 128, 128)\n    assert tuple(arr[85, 50, :]) == (192, 128, 128)\n    assert tuple(arr[95, 50, :]) == (255, 128, 128)\nJPGB_08_08_3_1F_YBR_FULL = PixelReference('SC_rgb_jpeg_lossy_gdcm.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[420, 140]\n    assert 95 == arr[230, 120]\nJPGE_BAD = PixelReference('JPEG-lossy.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert 244 == arr[420, 140]\n    assert 95 == arr[230, 120]\nJPGE_16_12_1_0_1F_M2 = PixelReference('JPGExtended.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[300, 512:520]) == (26, 26, 25, 22, 19, 16, 14, 15)\n    assert tuple(arr[600, 512:520]) == (45, 43, 41, 38, 33, 30, 26, 21)\nJPGS_08_08_1_0_1F = PixelReference('JPGLosslessP14SV1_1s_1f_8b.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[400, 124:132]) == (60, 58, 61, 68, 59, 65, 64, 67)\n    assert tuple(arr[600, 124:132]) == (3, 1, 2, 0, 2, 1, 2, 0)\nJPGS_16_16_1_1_1F_M2 = PixelReference('JPEG-LL.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[5, 50, :]) == (255, 0, 0)\n    assert tuple(arr[15, 50, :]) == (255, 128, 128)\n    assert tuple(arr[25, 50, :]) == (0, 255, 0)\n    assert tuple(arr[35, 50, :]) == (128, 255, 128)\n    assert tuple(arr[45, 50, :]) == (0, 0, 255)\n    assert tuple(arr[55, 50, :]) == (128, 128, 255)\n    assert tuple(arr[65, 50, :]) == (0, 0, 0)\n    assert tuple(arr[75, 50, :]) == (64, 64, 64)\n    assert tuple(arr[85, 50, :]) == (192, 192, 192)\n    assert tuple(arr[95, 50, :]) == (255, 255, 255)\nJPGS_08_08_3_1F_RGB = PixelReference('SC_rgb_jpeg_gdcm.dcm', 'u1', test)\nPIXEL_REFERENCE[JPEGBaseline8Bit] = [JPGB_08_08_3_0_1F_YBR_FULL, JPGB_08_08_3_0_1F_RGB_NO_APP14, JPGB_08_08_3_0_1F_RGB_APP14, JPGB_08_08_3_0_1F_RGB_DCMD_APP14, JPGB_08_08_3_0_120F_YBR_FULL_422, JPGB_08_08_3_1F_YBR_FULL, JPGB_08_08_3_0_1F_YBR_FULL_422_411, JPGB_08_08_3_0_1F_YBR_FULL_422_422, JPGB_08_08_3_0_1F_YBR_FULL_411, JPGB_08_08_3_0_1F_YBR_FULL_422, JPGB_08_08_3_0_1F_YBR_FULL_444, JPGB_08_08_3_0_1F_RGB, JPGB_08_08_3_1F_YBR_FULL]\nPIXEL_REFERENCE[JPEGExtended12Bit] = [JPGE_BAD, JPGE_16_12_1_0_1F_M2]\nPIXEL_REFERENCE[JPEGLossless] = []\nPIXEL_REFERENCE[JPEGLosslessSV1] = [JPGS_08_08_1_0_1F, JPGS_16_16_1_1_1F_M2, JPGS_08_08_3_1F_RGB]\n\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [[115, 109, 91], [109, 105, 100], [100, 111, 94], [192, 53, 172]]\nJLSL_08_08_3_0_1F_ILV0 = PixelReference('JLSL_RGB_ILV0.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [[115, 109, 91], [109, 105, 100], [100, 111, 94], [192, 53, 172]]\nJLSL_08_08_3_0_1F_ILV1 = PixelReference('JLSL_RGB_ILV1.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [[115, 109, 91], [109, 105, 100], [100, 111, 94], [192, 53, 172]]\nJLSL_08_08_3_0_1F_ILV2 = PixelReference('JLSL_RGB_ILV2.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[59:69, 58].tolist() == [55, 53, 58, 85, 109, 123, 116, 102, 98, 89]\nJLSL_08_07_1_0_1F = PixelReference('JLSL_08_07_0_1F.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[59:65, 58].tolist() == [-2073, -2629, -1167, 5566, 11808, 15604]\nJLSL_16_15_1_1_1F = PixelReference('JLSL_16_15_1_1F.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert (422, 319, 361) == tuple(arr[0, 31:34])\n    assert (366, 363, 322) == tuple(arr[31, :3])\n    assert (1369, 1129, 862) == tuple(arr[-1, -3:])\n    assert arr[55:65, 35].tolist() == [170, 193, 191, 373, 1293, 2053, 1879, 1683, 1711]\nJLSL_16_16_1_1_1F = PixelReference('MR_small_jpeg_ls_lossless.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('emri_small.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJLSL_16_12_1_1_10F = PixelReference('emri_small_jpeg_ls_lossless.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0] == 255\n    assert arr[5, 0] == 125\n    assert arr[10, 0] == 65\n    assert arr[15, 0] == 30\n    assert arr[20, 0] == 15\n    assert arr[25, 0] == 5\n    assert arr[30, 0] == 5\n    assert arr[35, 0] == 0\n    assert arr[40, 0] == 0\nJLSN_08_01_1_0_1F = PixelReference('JPEGLSNearLossless_08.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[124:128, 40].tolist() == [[118, 110, 92], [110, 103, 99], [97, 113, 96], [191, 55, 175]]\nJLSN_08_08_3_0_1F_ILV0 = PixelReference('JLSN_RGB_ILV0.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [255, 0, 0]\n    assert arr[10, 0].tolist() == [255, 130, 130]\n    assert arr[20, 0].tolist() == [0, 255, 0]\n    assert arr[30, 0].tolist() == [130, 255, 130]\n    assert arr[40, 0].tolist() == [0, 0, 255]\n    assert arr[50, 0].tolist() == [130, 130, 255]\n    assert arr[60, 0].tolist() == [0, 0, 0]\n    assert arr[70, 0].tolist() == [65, 65, 65]\n    assert arr[80, 0].tolist() == [190, 190, 190]\n    assert arr[90, 0].tolist() == [255, 255, 255]\nJLSN_08_08_1_0_3F_LINE = PixelReference('SC_rgb_jls_lossy_line.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0].tolist() == [255, 0, 0]\n    assert arr[10, 0].tolist() == [255, 130, 130]\n    assert arr[20, 0].tolist() == [0, 255, 0]\n    assert arr[30, 0].tolist() == [130, 255, 130]\n    assert arr[40, 0].tolist() == [0, 0, 255]\n    assert arr[50, 0].tolist() == [130, 130, 255]\n    assert arr[60, 0].tolist() == [0, 0, 0]\n    assert arr[70, 0].tolist() == [65, 65, 65]\n    assert arr[80, 0].tolist() == [190, 190, 190]\n    assert arr[90, 0].tolist() == [255, 255, 255]\nJLSN_08_08_1_0_3F_SAMPLE = PixelReference('SC_rgb_jls_lossy_sample.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[0, 0] == 65535\n    assert arr[5, 0] == 32765\n    assert arr[10, 0] == 16385\n    assert arr[15, 0] == 4095\n    assert arr[20, 0] == 1025\n    assert arr[25, 0] == 255\n    assert arr[30, 0] == 65\n    assert arr[35, 0] == 15\n    assert arr[40, 0] == 5\nJLSN_16_16_1_0_1F = PixelReference('JPEGLSNearLossless_16.dcm', '<u2', test)\nPIXEL_REFERENCE[JPEGLSLossless] = [JLSL_08_08_3_0_1F_ILV0, JLSL_08_08_3_0_1F_ILV1, JLSL_08_08_3_0_1F_ILV2, JLSL_08_07_1_0_1F, JLSL_16_15_1_1_1F, JLSL_16_16_1_1_1F, JLSL_16_12_1_1_10F]\nPIXEL_REFERENCE[JPEGLSNearLossless] = [JLSN_08_01_1_0_1F, JLSN_08_08_3_0_1F_ILV0, JLSN_08_08_1_0_3F_LINE, JLSN_08_08_1_0_3F_SAMPLE, JLSN_16_16_1_0_1F]\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('US1_UNCR.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_08_08_3_0_1F_YBR_ICT = PixelReference('US1_J2KR.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('RG3_UNCR.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_10_1_0_1F_M1 = PixelReference('RG3_J2KR.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('MR2_UNCR.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_12_1_0_1F_M2 = PixelReference('MR2_J2KR.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('RG1_UNCR.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_15_1_0_1F_M1 = PixelReference('RG1_J2KR.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('emri_small.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_12_1_0_10F_M2 = PixelReference('emri_small_jpeg_2k_lossless.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('693_UNCR.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_14_1_1_1F_M2 = PixelReference('693_J2KR.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('MR_small.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KR_16_16_1_1_1F_M2 = PixelReference('MR_small_jp2klossless.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert -2000 == arr[0, 0]\n    assert [621, 412, 138, -193, -520, -767, -907, -966, -988, -995] == arr[47:57, 279].tolist()\n    assert [-377, -121, 141, 383, 633, 910, 1198, 1455, 1638, 1732] == arr[328:338, 106].tolist()\nJ2KR_16_13_1_1_1F_M2_MISMATCH = PixelReference('J2K_pixelrep_mismatch.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert tuple(arr[45, 140]) == (223, 32, 32)\n    assert tuple(arr[46, 140]) == (255, 0, 0)\n    assert tuple(arr[350, 195]) == (128, 128, 128)\nJ2KR_08_08_3_0_1F_YBR_RCT = PixelReference('GDCMJ2K_TextGBR.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('SC_rgb_gdcm2k_uncompressed.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KI_08_08_3_0_1F_RGB = PixelReference('SC_rgb_gdcm_KY.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('US1_UNCI.dcm', read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\nJ2KI_08_08_3_0_1F_YBR_ICT = PixelReference('US1_J2KI.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('RG3_UNCI.dcm', read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\nJ2KI_16_10_1_0_1F_M1 = PixelReference('RG3_J2KI.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('MR2_UNCI.dcm', read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\nJ2KI_16_12_1_0_1F_M2 = PixelReference('MR2_J2KI.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('RG1_UNCI.dcm', read=True).pixel_array\n    assert np.allclose(arr, ref, atol=1)\nJ2KI_16_15_1_0_1F_M1 = PixelReference('RG1_J2KI.dcm', '<u2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('693_UNCI.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KI_16_14_1_1_1F_M2 = PixelReference('693_J2KI.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    ref = get_testdata_file('JPEG2000_UNC.dcm', read=True).pixel_array\n    assert np.array_equal(arr, ref)\nJ2KI_16_16_1_1_1F_M2 = PixelReference('JPEG2000.dcm', '<i2', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[160, 295:305].tolist() == [[90, 38, 1], [94, 40, 1], [97, 42, 5], [173, 122, 59], [172, 133, 69], [169, 135, 75], [168, 136, 79], [169, 137, 79], [169, 137, 81], [169, 136, 79]]\n    assert arr[275:285, 635].tolist() == [[208, 193, 172], [238, 228, 215], [235, 229, 216], [233, 226, 212], [239, 231, 218], [238, 232, 219], [224, 218, 205], [239, 234, 223], [246, 241, 232], [242, 236, 226]]\nHTJR_08_08_1_1_1F_RGB = PixelReference('HTJ2KLossless_08_RGB.dcm', 'u1', test)\n\ndef test(ref, arr, **kwargs):\n    assert arr[160, 295:305].tolist() == [[91, 37, 2], [94, 40, 1], [97, 42, 5], [174, 123, 59], [172, 132, 69], [169, 134, 74], [168, 136, 77], [168, 137, 80], [168, 136, 80], [169, 136, 78]]\n    assert arr[275:285, 635].tolist() == [[207, 193, 171], [238, 229, 215], [235, 228, 216], [233, 226, 213], [238, 231, 218], [239, 232, 219], [225, 218, 206], [240, 234, 223], [247, 240, 232], [242, 236, 227]]\nHTJI_08_08_1_1_1F_RGB = PixelReference('HTJ2K_08_RGB.dcm', 'u1', test)\nPIXEL_REFERENCE[JPEG2000Lossless] = [J2KR_08_08_3_0_1F_YBR_ICT, J2KR_16_10_1_0_1F_M1, J2KR_16_12_1_0_1F_M2, J2KR_16_15_1_0_1F_M1, J2KR_16_12_1_0_10F_M2, J2KR_16_14_1_1_1F_M2, J2KR_16_16_1_1_1F_M2, J2KR_16_13_1_1_1F_M2_MISMATCH, J2KR_08_08_3_0_1F_YBR_RCT]\nPIXEL_REFERENCE[JPEG2000] = [J2KI_08_08_3_0_1F_RGB, J2KI_08_08_3_0_1F_YBR_ICT, J2KI_16_10_1_0_1F_M1, J2KI_16_12_1_0_1F_M2, J2KI_16_15_1_0_1F_M1, J2KI_16_14_1_1_1F_M2, J2KI_16_16_1_1_1F_M2]\nPIXEL_REFERENCE[HTJ2KLossless] = [HTJR_08_08_1_1_1F_RGB]\nPIXEL_REFERENCE[HTJ2KLosslessRPCL] = []\nPIXEL_REFERENCE[HTJ2K] = [HTJI_08_08_1_1_1F_RGB]"
  },
  "call_tree": {
    "modified_testcases/pixels/test_decoder_base.py:TestDecodeRunner:test_set_source_dataset": {
      "modified_testcases/pixels/pixels_reference.py:PixelReference:ds": {}
    },
    "modified_testcases/pixels/test_decoder_base.py:TestDecoder:test_buffer": {
      "modified_testcases/pixels/pixels_reference.py:PixelReference:ds": {}
    }
  }
}