{
  "dir_path": "/app/pathvalidate",
  "package_name": "pathvalidate",
  "sample_name": "pathvalidate-test_handler",
  "src_dir": "pathvalidate/",
  "test_dir": "test/",
  "test_file": "modified_testcases/test_handler.py",
  "test_code": "import re\nimport unittest\nfrom pathvalidate import ErrorReason, ValidationError\nfrom pathvalidate.handler import (\n    raise_error,\n    NullValueHandler,\n    ReservedNameHandler,\n)\n\ntimestamp_regexp = re.compile(r\"^\\d+\\.\\d+$\")\n\n\nclass TestRaiseError(unittest.TestCase):\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_normal(self):\n        exceptions = [\n            ValidationError(\n                description=\"hoge\",\n                reason=ErrorReason.INVALID_CHARACTER,\n            ),\n            ValidationError(\n                description=\"foo\",\n                reason=ErrorReason.INVALID_AFTER_SANITIZE,\n            ),\n        ]\n        \n        for exception in exceptions:\n            with self.assertRaises(ValidationError) as e:\n                raise_error(exception)\n            self.assertEqual(exception, e.exception)\n\n\nclass TestNullValueHandler(unittest.TestCase):\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_return_null_string(self):\n        exceptions = [\n            ValidationError(\n                description=\"hoge\",\n                reason=ErrorReason.INVALID_CHARACTER,\n            ),\n            ValidationError(\n                description=\"foo\",\n                reason=ErrorReason.INVALID_AFTER_SANITIZE,\n            ),\n        ]\n        \n        for exception in exceptions:\n            self.assertEqual(NullValueHandler.return_null_string(exception), \"\")\n\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_return_timestamp(self):\n        exceptions = [\n            ValidationError(\n                description=\"hoge\",\n                reason=ErrorReason.INVALID_CHARACTER,\n            ),\n            ValidationError(\n                description=\"foo\",\n                reason=ErrorReason.INVALID_AFTER_SANITIZE,\n            ),\n        ]\n        \n        for exception in exceptions:\n            self.assertIsNotNone(timestamp_regexp.search(NullValueHandler.return_timestamp(exception)))\n\n\nclass TestReservedNameHandler(unittest.TestCase):\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_add_leading_underscore(self):\n        test_cases = [\n            (\n                ValidationError(\n                    description=\"not reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"hoge\",\n                ),\n                \"_hoge\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=True,\n                    reserved_name=\"hoge\",\n                ),\n                \"hoge\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\".\",\n                ),\n                \".\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to double dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"..\",\n                ),\n                \"..\",\n            ),\n        ]\n\n        for exception, expected in test_cases:\n            self.assertEqual(ReservedNameHandler.add_leading_underscore(exception), expected)\n\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_add_trailing_underscore(self):\n        test_cases = [\n            (\n                ValidationError(\n                    description=\"not reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"hoge\",\n                ),\n                \"hoge_\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=True,\n                    reserved_name=\"hoge\",\n                ),\n                \"hoge\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\".\",\n                ),\n                \".\",\n            ),\n            (\n                ValidationError(\n                    description=\"do nothing to double dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"..\",\n                ),\n                \"..\",\n            ),\n        ]\n\n        for exception, expected in test_cases:\n            self.assertEqual(ReservedNameHandler.add_trailing_underscore(exception), expected)\n\n    @unittest.skipUnless(True, 'Skipping for illustration purposes')\n    def test_as_is(self):\n        test_cases = [\n            (\n                ValidationError(\n                    description=\"not reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"hoge\",\n                ),\n                \"hoge\",\n            ),\n            (\n                ValidationError(\n                    description=\"reusable reserved name\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=True,\n                    reserved_name=\"hoge\",\n                ),\n                \"hoge\",\n            ),\n            (\n                ValidationError(\n                    description=\"dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\".\",\n                ),\n                \".\",\n            ),\n            (\n                ValidationError(\n                    description=\"double dot\",\n                    reason=ErrorReason.RESERVED_NAME,\n                    reusable_name=False,\n                    reserved_name=\"..\",\n                ),\n                \"..\",\n            ),\n        ]\n\n        for exception, expected in test_cases:\n            self.assertEqual(ReservedNameHandler.as_is(exception), expected)\n\n\nif __name__ == '__main__':\n    unittest.main()",
  "GT_file_code": {
    "pathvalidate/handler.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport warnings\nfrom datetime import datetime\nfrom typing import Callable\n\nfrom .error import ValidationError\n\n\nValidationErrorHandler = Callable[[ValidationError], str]\n\n\ndef return_null_string(e: ValidationError) -> str:\n    \"\"\"Null value handler that always returns an empty string.\n\n    Args:\n        e (ValidationError): A validation error.\n\n    Returns:\n        str: An empty string.\n    \"\"\"\n\n    warnings.warn(\n        \"'return_null_string' is deprecated. Use 'NullValueHandler.return_null_string' instead.\",\n        DeprecationWarning,\n    )\n\n    return \"\"\n\n\ndef return_timestamp(e: ValidationError) -> str:\n    \"\"\"Null value handler that returns a timestamp of when the function was called.\n\n    Args:\n        e (ValidationError): A validation error.\n\n    Returns:\n        str: A timestamp.\n    \"\"\"\n\n    warnings.warn(\n        \"'return_timestamp' is deprecated. Use 'NullValueHandler.reserved_name_handler' instead.\",\n        DeprecationWarning,\n    )\n\n    return str(datetime.now().timestamp())\n\n\ndef raise_error(e: ValidationError) -> str:\n    \"\"\"Null value handler that always raises an exception.\n\n    Args:\n        e (ValidationError): A validation error.\n\n    Raises:\n        ValidationError: Always raised.\n    \"\"\"\n\n    raise e\n\n\nclass NullValueHandler:\n    @classmethod\n    def return_null_string(cls, e: ValidationError) -> str:\n        \"\"\"Null value handler that always returns an empty string.\n\n        Args:\n            e (ValidationError): A validation error.\n\n        Returns:\n            str: An empty string.\n        \"\"\"\n\n        return \"\"\n\n    @classmethod\n    def return_timestamp(cls, e: ValidationError) -> str:\n        \"\"\"Null value handler that returns a timestamp of when the function was called.\n\n        Args:\n            e (ValidationError): A validation error.\n\n        Returns:\n            str: A timestamp.\n        \"\"\"\n\n        return str(datetime.now().timestamp())\n\n\nclass ReservedNameHandler:\n    @classmethod\n    def add_leading_underscore(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that adds a leading underscore (``\"_\"``) to the name\n        except for ``\".\"`` and ``\"..\"``.\n\n        Args:\n            e (ValidationError): A reserved name error.\n\n        Returns:\n            str: The converted name.\n        \"\"\"\n\n        if e.reserved_name in (\".\", \"..\") or e.reusable_name:\n            return e.reserved_name\n\n        return f\"_{e.reserved_name}\"\n\n    @classmethod\n    def add_trailing_underscore(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that adds a trailing underscore (``\"_\"``) to the name\n        except for ``\".\"`` and ``\"..\"``.\n\n        Args:\n            e (ValidationError): A reserved name error.\n\n        Returns:\n            str: The converted name.\n        \"\"\"\n\n        if e.reserved_name in (\".\", \"..\") or e.reusable_name:\n            return e.reserved_name\n\n        return f\"{e.reserved_name}_\"\n\n    @classmethod\n    def as_is(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that returns the name as is.\n\n        Args:\n            e (ValidationError): A reserved name error.\n\n        Returns:\n            str: The name as is.\n        \"\"\"\n\n        return e.reserved_name\n",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport enum\nfrom typing import Dict, Optional\n\nfrom ._const import Platform\n\n\ndef _to_error_code(code: int) -> str:\n    return f\"PV{code:04d}\"\n\n\nclass ErrorAttrKey:\n    BYTE_COUNT = \"byte_count\"\n    DESCRIPTION = \"description\"\n    FS_ENCODING = \"fs_encoding\"\n    PLATFORM = \"platform\"\n    REASON = \"reason\"\n    RESERVED_NAME = \"reserved_name\"\n    REUSABLE_NAME = \"reusable_name\"\n\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n\n    NULL_NAME = (_to_error_code(1001), \"NULL_NAME\", \"the value must not be an empty string\")\n    RESERVED_NAME = (\n        _to_error_code(1002),\n        \"RESERVED_NAME\",\n        \"found a reserved name by a platform\",\n    )\n    INVALID_CHARACTER = (\n        _to_error_code(1100),\n        \"INVALID_CHARACTER\",\n        \"invalid characters found\",\n    )\n    INVALID_LENGTH = (\n        _to_error_code(1101),\n        \"INVALID_LENGTH\",\n        \"found an invalid string length\",\n    )\n    FOUND_ABS_PATH = (\n        _to_error_code(1200),\n        \"FOUND_ABS_PATH\",\n        \"found an absolute path where must be a relative path\",\n    )\n    MALFORMED_ABS_PATH = (\n        _to_error_code(1201),\n        \"MALFORMED_ABS_PATH\",\n        \"found a malformed absolute path\",\n    )\n    INVALID_AFTER_SANITIZE = (\n        _to_error_code(2000),\n        \"INVALID_AFTER_SANITIZE\",\n        \"found invalid value after sanitizing\",\n    )\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f\"[{self.__code}] {self.__description}\"\n\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f\"{ErrorAttrKey.REASON} must be specified\")\n\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, \"\")\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n\n        slog: Dict[str, str] = {\n            \"code\": self.reason.code,\n            ErrorAttrKey.DESCRIPTION: self.reason.description,\n        }\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n\n        if self.platform:\n            item_list.append(f\"{ErrorAttrKey.PLATFORM}={self.platform.value}\")\n        if self.description:\n            item_list.append(f\"{ErrorAttrKey.DESCRIPTION}={self.description}\")\n        if self.__reusable_name is not None:\n            item_list.append(f\"{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}\")\n        if self.__fs_encoding:\n            item_list.append(f\"{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}\")\n        if self.__byte_count is not None:\n            item_list.append(f\"{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}\")\n\n        if item_list:\n            header += \": \"\n\n        return header + \", \".join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n\n        super().__init__(args, **kwargs)\n\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n\n        super().__init__(args, **kwargs)\n"
  },
  "GT_src_dict": {
    "pathvalidate/handler.py": {
      "raise_error": {
        "code": "def raise_error(e: ValidationError) -> str:\n    \"\"\"Raises a ValidationError exception.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that represents the validation error to be raised.\n\nRaises:\n    ValidationError: This function always raises the provided validation error `e`, effectively terminating the current execution flow.\n\nThis function serves as a handler for validation errors, allowing the error to propagate up the call stack instead of returning a value. It does not return any output, as its primary role is to signal an exceptional condition.\"\"\"\n    'Null value handler that always raises an exception.\\n\\n    Args:\\n        e (ValidationError): A validation error.\\n\\n    Raises:\\n        ValidationError: Always raised.\\n    '\n    raise e",
        "docstring": "Raises a ValidationError exception.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that represents the validation error to be raised.\n\nRaises:\n    ValidationError: This function always raises the provided validation error `e`, effectively terminating the current execution flow.\n\nThis function serves as a handler for validation errors, allowing the error to propagate up the call stack instead of returning a value. It does not return any output, as its primary role is to signal an exceptional condition.",
        "signature": "def raise_error(e: ValidationError) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "NullValueHandler.return_null_string": {
        "code": "    def return_null_string(cls, e: ValidationError) -> str:\n        \"\"\"A class method that serves as a null value handler, always returning an empty string.\n\nArgs:\n    e (ValidationError): An instance of ValidationError, representing a validation error that has occurred. This parameter is required but is not utilized directly in the method.\n\nReturns:\n    str: An empty string, representing the null value response.\n\nThis method is part of the NullValueHandler class, which provides various strategies for handling null values in the context of validation errors. The method does not utilize any constants or external state and is deterministic, always producing the same output.\"\"\"\n        'Null value handler that always returns an empty string.\\n\\n        Args:\\n            e (ValidationError): A validation error.\\n\\n        Returns:\\n            str: An empty string.\\n        '\n        return ''",
        "docstring": "A class method that serves as a null value handler, always returning an empty string.\n\nArgs:\n    e (ValidationError): An instance of ValidationError, representing a validation error that has occurred. This parameter is required but is not utilized directly in the method.\n\nReturns:\n    str: An empty string, representing the null value response.\n\nThis method is part of the NullValueHandler class, which provides various strategies for handling null values in the context of validation errors. The method does not utilize any constants or external state and is deterministic, always producing the same output.",
        "signature": "def return_null_string(cls, e: ValidationError) -> str:",
        "type": "Method",
        "class_signature": "class NullValueHandler:"
      },
      "NullValueHandler.return_timestamp": {
        "code": "    def return_timestamp(cls, e: ValidationError) -> str:\n        \"\"\"NullValueHandler is a utility class that provides methods for handling null values encountered during validation processes. The `return_timestamp` method serves as a null value handler that returns the current timestamp as a string whenever it is called, which may be useful for logging or tracking purposes in response to validation errors.\n\nArgs:\n    e (ValidationError): A validation error instance that triggered this handler, though this argument is not used in the method's logic.\n\nReturns:\n    str: The current timestamp as a string, formatted as a floating-point number representing the seconds since the epoch.\n\nDependencies:\n- `datetime`: The `datetime` module is imported to obtain the current timestamp at the moment of the function call.\n- `ValidationError`: This is a custom error defined in the imported `error` module and serves as a type for the input parameter.\"\"\"\n        'Null value handler that returns a timestamp of when the function was called.\\n\\n        Args:\\n            e (ValidationError): A validation error.\\n\\n        Returns:\\n            str: A timestamp.\\n        '\n        return str(datetime.now().timestamp())",
        "docstring": "NullValueHandler is a utility class that provides methods for handling null values encountered during validation processes. The `return_timestamp` method serves as a null value handler that returns the current timestamp as a string whenever it is called, which may be useful for logging or tracking purposes in response to validation errors.\n\nArgs:\n    e (ValidationError): A validation error instance that triggered this handler, though this argument is not used in the method's logic.\n\nReturns:\n    str: The current timestamp as a string, formatted as a floating-point number representing the seconds since the epoch.\n\nDependencies:\n- `datetime`: The `datetime` module is imported to obtain the current timestamp at the moment of the function call.\n- `ValidationError`: This is a custom error defined in the imported `error` module and serves as a type for the input parameter.",
        "signature": "def return_timestamp(cls, e: ValidationError) -> str:",
        "type": "Method",
        "class_signature": "class NullValueHandler:"
      },
      "ReservedNameHandler.add_leading_underscore": {
        "code": "    def add_leading_underscore(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that adds a leading underscore (``\"_\"``) to the given reserved name, unless the name is either ``\".\"`` or ``\"..\"``, or marked as reusable.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that contains the reserved name to be modified. This class holds attributes like `reserved_name` (the name to adjust) and `reusable_name` (a boolean indicating if the name is reusable).\n\nReturns:\n    str: The modified name with a leading underscore, or the original name if it is `.` or `..`, or if it is marked reusable.\n\nNotes:\n    - Defined in the `ReservedNameHandler` class, which manages modifications to reserved names in a consistent manner.\n    - Utilizes the `reserved_name` attribute from the `ValidationError` class, which is imported from the `.error` module.\"\"\"\n        'Reserved name handler that adds a leading underscore (``\"_\"``) to the name\\n        except for ``\".\"`` and ``\"..\"``.\\n\\n        Args:\\n            e (ValidationError): A reserved name error.\\n\\n        Returns:\\n            str: The converted name.\\n        '\n        if e.reserved_name in ('.', '..') or e.reusable_name:\n            return e.reserved_name\n        return f'_{e.reserved_name}'",
        "docstring": "Reserved name handler that adds a leading underscore (``\"_\"``) to the given reserved name, unless the name is either ``\".\"`` or ``\"..\"``, or marked as reusable.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that contains the reserved name to be modified. This class holds attributes like `reserved_name` (the name to adjust) and `reusable_name` (a boolean indicating if the name is reusable).\n\nReturns:\n    str: The modified name with a leading underscore, or the original name if it is `.` or `..`, or if it is marked reusable.\n\nNotes:\n    - Defined in the `ReservedNameHandler` class, which manages modifications to reserved names in a consistent manner.\n    - Utilizes the `reserved_name` attribute from the `ValidationError` class, which is imported from the `.error` module.",
        "signature": "def add_leading_underscore(cls, e: ValidationError) -> str:",
        "type": "Method",
        "class_signature": "class ReservedNameHandler:"
      },
      "ReservedNameHandler.add_trailing_underscore": {
        "code": "    def add_trailing_underscore(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that modifies the provided reserved name by adding a trailing underscore (``\"_\"``) to it, unless the name is either ``\".\"`` or ``\"..\"`` or is a reusable name. This method helps in managing naming conflicts by ensuring that reserved names are modified appropriately.\n\nArgs:\n    e (ValidationError): An object that encapsulates information about a reserved name error, including its `reserved_name` attribute which represents the name to be processed and a `reusable_name` attribute indicating if the name can be reused as is.\n\nReturns:\n    str: The modified reserved name with a trailing underscore if applicable, or the original name if it is reserved or reusable.\n\nNote:\n    This method interacts with the properties of the `ValidationError` class, relying on its `reserved_name` and `reusable_name` attributes to determine whether a modification is necessary.\"\"\"\n        'Reserved name handler that adds a trailing underscore (``\"_\"``) to the name\\n        except for ``\".\"`` and ``\"..\"``.\\n\\n        Args:\\n            e (ValidationError): A reserved name error.\\n\\n        Returns:\\n            str: The converted name.\\n        '\n        if e.reserved_name in ('.', '..') or e.reusable_name:\n            return e.reserved_name\n        return f'{e.reserved_name}_'",
        "docstring": "Reserved name handler that modifies the provided reserved name by adding a trailing underscore (``\"_\"``) to it, unless the name is either ``\".\"`` or ``\"..\"`` or is a reusable name. This method helps in managing naming conflicts by ensuring that reserved names are modified appropriately.\n\nArgs:\n    e (ValidationError): An object that encapsulates information about a reserved name error, including its `reserved_name` attribute which represents the name to be processed and a `reusable_name` attribute indicating if the name can be reused as is.\n\nReturns:\n    str: The modified reserved name with a trailing underscore if applicable, or the original name if it is reserved or reusable.\n\nNote:\n    This method interacts with the properties of the `ValidationError` class, relying on its `reserved_name` and `reusable_name` attributes to determine whether a modification is necessary.",
        "signature": "def add_trailing_underscore(cls, e: ValidationError) -> str:",
        "type": "Method",
        "class_signature": "class ReservedNameHandler:"
      },
      "ReservedNameHandler.as_is": {
        "code": "    def as_is(cls, e: ValidationError) -> str:\n        \"\"\"Reserved name handler that returns the name as it is without any modifications.\n\nArgs:\n    e (ValidationError): A reserved name error, expected to contain a `reserved_name` attribute \n    representing the name that is to be processed.\n\nReturns:\n    str: The `reserved_name` from the `ValidationError` instance `e`, returned exactly as it is.\n\nThis method relies on the `ValidationError` class, which is defined elsewhere in the code\nand encompasses details regarding the error, including the specific reserved name being handled.\"\"\"\n        'Reserved name handler that returns the name as is.\\n\\n        Args:\\n            e (ValidationError): A reserved name error.\\n\\n        Returns:\\n            str: The name as is.\\n        '\n        return e.reserved_name",
        "docstring": "Reserved name handler that returns the name as it is without any modifications.\n\nArgs:\n    e (ValidationError): A reserved name error, expected to contain a `reserved_name` attribute \n    representing the name that is to be processed.\n\nReturns:\n    str: The `reserved_name` from the `ValidationError` instance `e`, returned exactly as it is.\n\nThis method relies on the `ValidationError` class, which is defined elsewhere in the code\nand encompasses details regarding the error, including the specific reserved name being handled.",
        "signature": "def as_is(cls, e: ValidationError) -> str:",
        "type": "Method",
        "class_signature": "class ReservedNameHandler:"
      }
    },
    "pathvalidate/error.py": {
      "ValidationError.reserved_name": {
        "code": "    def reserved_name(self) -> str:\n        \"\"\"@property\ndef reserved_name(self) -> str:\"\"\"\n        'str: Reserved name.'\n        return self.__reserved_name",
        "docstring": "@property\ndef reserved_name(self) -> str:",
        "signature": "def reserved_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      },
      "ValidationError.reusable_name": {
        "code": "    def reusable_name(self) -> Optional[bool]:\n        \"\"\"@property\ndef reusable_name(self) -> Optional[bool]:\"\"\"\n        'Optional[bool]: Whether the name is reusable or not.'\n        return self.__reusable_name",
        "docstring": "@property\ndef reusable_name(self) -> Optional[bool]:",
        "signature": "def reusable_name(self) -> Optional[bool]:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      },
      "ValidationError.__init__": {
        "code": "    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize a ValidationError instance.\n\nThis constructor validates and sets up various attributes related to the validation error.\n\nParameters:\n    *args: Positional arguments passed to the base ValueError class.\n    **kwargs: Keyword arguments to specify error attributes. The following keys are expected:\n        - ErrorAttrKey.REASON (required): The reason for the validation error, corresponding to an ErrorReason enum.\n        - ErrorAttrKey.BYTE_COUNT (optional): The byte count of the path associated with the error.\n        - ErrorAttrKey.PLATFORM (optional): Platform information associated with the error, represented by the Platform class.\n        - ErrorAttrKey.DESCRIPTION (optional): A custom description of the error.\n        - ErrorAttrKey.RESERVED_NAME (optional): The reserved name that caused the error, defaults to an empty string.\n        - ErrorAttrKey.REUSABLE_NAME (optional): Indicates if the name can be reused, represented as a boolean.\n        - ErrorAttrKey.FS_ENCODING (optional): The file system encoding related to the error.\n\nRaises:\n    ValueError: If the required ErrorAttrKey.REASON key is not provided in kwargs.\n\nThe constructor initializes the error attributes based on the provided keyword arguments and calls the base class constructor to handle the exception message.\"\"\"\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f'{ErrorAttrKey.REASON} must be specified')\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, '')\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)",
        "docstring": "Initialize a ValidationError instance.\n\nThis constructor validates and sets up various attributes related to the validation error.\n\nParameters:\n    *args: Positional arguments passed to the base ValueError class.\n    **kwargs: Keyword arguments to specify error attributes. The following keys are expected:\n        - ErrorAttrKey.REASON (required): The reason for the validation error, corresponding to an ErrorReason enum.\n        - ErrorAttrKey.BYTE_COUNT (optional): The byte count of the path associated with the error.\n        - ErrorAttrKey.PLATFORM (optional): Platform information associated with the error, represented by the Platform class.\n        - ErrorAttrKey.DESCRIPTION (optional): A custom description of the error.\n        - ErrorAttrKey.RESERVED_NAME (optional): The reserved name that caused the error, defaults to an empty string.\n        - ErrorAttrKey.REUSABLE_NAME (optional): Indicates if the name can be reused, represented as a boolean.\n        - ErrorAttrKey.FS_ENCODING (optional): The file system encoding related to the error.\n\nRaises:\n    ValueError: If the required ErrorAttrKey.REASON key is not provided in kwargs.\n\nThe constructor initializes the error attributes based on the provided keyword arguments and calls the base class constructor to handle the exception message.",
        "signature": "def __init__(self, *args, **kwargs) -> None:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: pathvalidate-test_handler\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pathvalidate/\n    \u251c\u2500\u2500 error.py\n    \u2502   \u251c\u2500\u2500 ValidationError.__init__\n    \u2502   \u251c\u2500\u2500 ValidationError.reserved_name\n    \u2502   \u2514\u2500\u2500 ValidationError.reusable_name\n    \u2514\u2500\u2500 handler.py\n        \u251c\u2500\u2500 NullValueHandler.return_null_string\n        \u251c\u2500\u2500 NullValueHandler.return_timestamp\n        \u251c\u2500\u2500 ReservedNameHandler.add_leading_underscore\n        \u251c\u2500\u2500 ReservedNameHandler.add_trailing_underscore\n        \u251c\u2500\u2500 ReservedNameHandler.as_is\n        \u2514\u2500\u2500 raise_error\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the validation, handling, and transformation of file path-related inputs to ensure compliance with predefined constraints and standards. It provides functionality for managing errors associated with invalid characters, reserved names, and null values in file paths and associated metadata. The capabilities include raising specific validation errors, returning sanitized fallback values such as timestamps or empty strings, and modifying reserved names by adding leading or trailing underscores based on their reusability. By automating these validations and transformations, the module streamlines error handling for developers, reduces the risk of invalid or problematic file path usage, and ensures a consistent approach to naming conventions across applications.\n\n## FILE 1: pathvalidate/handler.py\n\n- CLASS METHOD: NullValueHandler.return_null_string\n  - CLASS SIGNATURE: class NullValueHandler:\n  - SIGNATURE: def return_null_string(cls, e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nA class method that serves as a null value handler, always returning an empty string.\n\nArgs:\n    e (ValidationError): An instance of ValidationError, representing a validation error that has occurred. This parameter is required but is not utilized directly in the method.\n\nReturns:\n    str: An empty string, representing the null value response.\n\nThis method is part of the NullValueHandler class, which provides various strategies for handling null values in the context of validation errors. The method does not utilize any constants or external state and is deterministic, always producing the same output.\n\"\"\"\n```\n\n- CLASS METHOD: ReservedNameHandler.as_is\n  - CLASS SIGNATURE: class ReservedNameHandler:\n  - SIGNATURE: def as_is(cls, e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReserved name handler that returns the name as it is without any modifications.\n\nArgs:\n    e (ValidationError): A reserved name error, expected to contain a `reserved_name` attribute \n    representing the name that is to be processed.\n\nReturns:\n    str: The `reserved_name` from the `ValidationError` instance `e`, returned exactly as it is.\n\nThis method relies on the `ValidationError` class, which is defined elsewhere in the code\nand encompasses details regarding the error, including the specific reserved name being handled.\n\"\"\"\n```\n\n- CLASS METHOD: ReservedNameHandler.add_trailing_underscore\n  - CLASS SIGNATURE: class ReservedNameHandler:\n  - SIGNATURE: def add_trailing_underscore(cls, e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReserved name handler that modifies the provided reserved name by adding a trailing underscore (``\"_\"``) to it, unless the name is either ``\".\"`` or ``\"..\"`` or is a reusable name. This method helps in managing naming conflicts by ensuring that reserved names are modified appropriately.\n\nArgs:\n    e (ValidationError): An object that encapsulates information about a reserved name error, including its `reserved_name` attribute which represents the name to be processed and a `reusable_name` attribute indicating if the name can be reused as is.\n\nReturns:\n    str: The modified reserved name with a trailing underscore if applicable, or the original name if it is reserved or reusable.\n\nNote:\n    This method interacts with the properties of the `ValidationError` class, relying on its `reserved_name` and `reusable_name` attributes to determine whether a modification is necessary.\n\"\"\"\n```\n\n- FUNCTION NAME: raise_error\n  - SIGNATURE: def raise_error(e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRaises a ValidationError exception.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that represents the validation error to be raised.\n\nRaises:\n    ValidationError: This function always raises the provided validation error `e`, effectively terminating the current execution flow.\n\nThis function serves as a handler for validation errors, allowing the error to propagate up the call stack instead of returning a value. It does not return any output, as its primary role is to signal an exceptional condition.\n\"\"\"\n```\n\n- CLASS METHOD: ReservedNameHandler.add_leading_underscore\n  - CLASS SIGNATURE: class ReservedNameHandler:\n  - SIGNATURE: def add_leading_underscore(cls, e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReserved name handler that adds a leading underscore (``\"_\"``) to the given reserved name, unless the name is either ``\".\"`` or ``\"..\"``, or marked as reusable.\n\nArgs:\n    e (ValidationError): An instance of ValidationError that contains the reserved name to be modified. This class holds attributes like `reserved_name` (the name to adjust) and `reusable_name` (a boolean indicating if the name is reusable).\n\nReturns:\n    str: The modified name with a leading underscore, or the original name if it is `.` or `..`, or if it is marked reusable.\n\nNotes:\n    - Defined in the `ReservedNameHandler` class, which manages modifications to reserved names in a consistent manner.\n    - Utilizes the `reserved_name` attribute from the `ValidationError` class, which is imported from the `.error` module.\n\"\"\"\n```\n\n- CLASS METHOD: NullValueHandler.return_timestamp\n  - CLASS SIGNATURE: class NullValueHandler:\n  - SIGNATURE: def return_timestamp(cls, e: ValidationError) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nNullValueHandler is a utility class that provides methods for handling null values encountered during validation processes. The `return_timestamp` method serves as a null value handler that returns the current timestamp as a string whenever it is called, which may be useful for logging or tracking purposes in response to validation errors.\n\nArgs:\n    e (ValidationError): A validation error instance that triggered this handler, though this argument is not used in the method's logic.\n\nReturns:\n    str: The current timestamp as a string, formatted as a floating-point number representing the seconds since the epoch.\n\nDependencies:\n- `datetime`: The `datetime` module is imported to obtain the current timestamp at the moment of the function call.\n- `ValidationError`: This is a custom error defined in the imported `error` module and serves as a type for the input parameter.\n\"\"\"\n```\n\n## FILE 2: pathvalidate/error.py\n\n- CLASS METHOD: ValidationError.__init__\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def __init__(self, *args, **kwargs) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ValidationError instance.\n\nThis constructor validates and sets up various attributes related to the validation error.\n\nParameters:\n    *args: Positional arguments passed to the base ValueError class.\n    **kwargs: Keyword arguments to specify error attributes. The following keys are expected:\n        - ErrorAttrKey.REASON (required): The reason for the validation error, corresponding to an ErrorReason enum.\n        - ErrorAttrKey.BYTE_COUNT (optional): The byte count of the path associated with the error.\n        - ErrorAttrKey.PLATFORM (optional): Platform information associated with the error, represented by the Platform class.\n        - ErrorAttrKey.DESCRIPTION (optional): A custom description of the error.\n        - ErrorAttrKey.RESERVED_NAME (optional): The reserved name that caused the error, defaults to an empty string.\n        - ErrorAttrKey.REUSABLE_NAME (optional): Indicates if the name can be reused, represented as a boolean.\n        - ErrorAttrKey.FS_ENCODING (optional): The file system encoding related to the error.\n\nRaises:\n    ValueError: If the required ErrorAttrKey.REASON key is not provided in kwargs.\n\nThe constructor initializes the error attributes based on the provided keyword arguments and calls the base class constructor to handle the exception message.\n\"\"\"\n```\n\n- CLASS METHOD: ValidationError.reserved_name\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reserved_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reserved_name(self) -> str:\n\"\"\"\n```\n\n- CLASS METHOD: ValidationError.reusable_name\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reusable_name(self) -> Optional[bool]:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reusable_name(self) -> Optional[bool]:\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pathvalidate/handler.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport warnings\nfrom datetime import datetime\nfrom typing import Callable\nfrom .error import ValidationError\nValidationErrorHandler = Callable[[ValidationError], str]\n\ndef return_null_string(e: ValidationError) -> str:\n    \"\"\"Null value handler that always returns an empty string.\n\n    Args:\n        e (ValidationError): A validation error.\n\n    Returns:\n        str: An empty string.\n    \"\"\"\n    warnings.warn(\"'return_null_string' is deprecated. Use 'NullValueHandler.return_null_string' instead.\", DeprecationWarning)\n    return ''\n\ndef return_timestamp(e: ValidationError) -> str:\n    \"\"\"Null value handler that returns a timestamp of when the function was called.\n\n    Args:\n        e (ValidationError): A validation error.\n\n    Returns:\n        str: A timestamp.\n    \"\"\"\n    warnings.warn(\"'return_timestamp' is deprecated. Use 'NullValueHandler.reserved_name_handler' instead.\", DeprecationWarning)\n    return str(datetime.now().timestamp())\n\nclass NullValueHandler:\n\nclass ReservedNameHandler:",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport enum\nfrom typing import Dict, Optional\nfrom ._const import Platform\n\ndef _to_error_code(code: int) -> str:\n    return f'PV{code:04d}'\n\nclass ErrorAttrKey:\n    BYTE_COUNT = 'byte_count'\n    DESCRIPTION = 'description'\n    FS_ENCODING = 'fs_encoding'\n    PLATFORM = 'platform'\n    REASON = 'reason'\n    RESERVED_NAME = 'reserved_name'\n    REUSABLE_NAME = 'reusable_name'\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n    NULL_NAME = (_to_error_code(1001), 'NULL_NAME', 'the value must not be an empty string')\n    RESERVED_NAME = (_to_error_code(1002), 'RESERVED_NAME', 'found a reserved name by a platform')\n    INVALID_CHARACTER = (_to_error_code(1100), 'INVALID_CHARACTER', 'invalid characters found')\n    INVALID_LENGTH = (_to_error_code(1101), 'INVALID_LENGTH', 'found an invalid string length')\n    FOUND_ABS_PATH = (_to_error_code(1200), 'FOUND_ABS_PATH', 'found an absolute path where must be a relative path')\n    MALFORMED_ABS_PATH = (_to_error_code(1201), 'MALFORMED_ABS_PATH', 'found a malformed absolute path')\n    INVALID_AFTER_SANITIZE = (_to_error_code(2000), 'INVALID_AFTER_SANITIZE', 'found invalid value after sanitizing')\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f'[{self.__code}] {self.__description}'\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n        slog: Dict[str, str] = {'code': self.reason.code, ErrorAttrKey.DESCRIPTION: self.reason.description}\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n        if self.platform:\n            item_list.append(f'{ErrorAttrKey.PLATFORM}={self.platform.value}')\n        if self.description:\n            item_list.append(f'{ErrorAttrKey.DESCRIPTION}={self.description}')\n        if self.__reusable_name is not None:\n            item_list.append(f'{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}')\n        if self.__fs_encoding:\n            item_list.append(f'{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}')\n        if self.__byte_count is not None:\n            item_list.append(f'{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}')\n        if item_list:\n            header += ': '\n        return header + ', '.join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n        super().__init__(args, **kwargs)\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n        super().__init__(args, **kwargs)\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n        super().__init__(args, **kwargs)\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n        super().__init__(args, **kwargs)"
  },
  "call_tree": {
    "modified_testcases/test_handler.py:TestRaiseError:test_normal": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:raise_error": {}
    },
    "modified_testcases/test_handler.py:TestNullValueHandler:test_return_null_string": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:NullValueHandler:return_null_string": {}
    },
    "modified_testcases/test_handler.py:TestNullValueHandler:test_return_timestamp": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:NullValueHandler:return_timestamp": {}
    },
    "modified_testcases/test_handler.py:TestReservedNameHandler:test_add_leading_underscore": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:ReservedNameHandler:add_leading_underscore": {
        "pathvalidate/error.py:ValidationError:reserved_name": {},
        "pathvalidate/error.py:ValidationError:reusable_name": {}
      }
    },
    "modified_testcases/test_handler.py:TestReservedNameHandler:test_add_trailing_underscore": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:ReservedNameHandler:add_trailing_underscore": {
        "pathvalidate/error.py:ValidationError:reserved_name": {},
        "pathvalidate/error.py:ValidationError:reusable_name": {}
      }
    },
    "modified_testcases/test_handler.py:TestReservedNameHandler:test_as_is": {
      "pathvalidate/error.py:ValidationError:__init__": {},
      "pathvalidate/handler.py:ReservedNameHandler:as_is": {
        "pathvalidate/error.py:ValidationError:reserved_name": {}
      }
    }
  }
}