{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_watcher_ex",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/test_watcher_ex.py",
  "test_code": "# Copyright 2023 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport casbin\nfrom tests.test_enforcer import get_examples, TestCaseBase\nfrom unittest import IsolatedAsyncioTestCase\n\n\nclass SampleWatcher:\n    def __init__(self):\n        self.callback = None\n        self.notify_message = None\n\n    def close(self):\n        pass\n\n    def set_update_callback(self, callback):\n        \"\"\"\n        sets the callback function to be called when the policy is updated\n        :param callable callback: callback(event)\n            - event: event received from the rabbitmq\n        :return:\n        \"\"\"\n        self.callback = callback\n\n    def update(self, msg):\n        \"\"\"\n        update the policy\n        \"\"\"\n        self.notify_message = msg\n        return True\n\n    def update_for_add_policy(self, section, ptype, *params):\n        \"\"\"\n        update for add policy\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:    True if updated\n        \"\"\"\n        message = \"called add policy\"\n        return self.update(message)\n\n    def update_for_remove_policy(self, section, ptype, *params):\n        \"\"\"\n        update for remove policy\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:    True if updated\n        \"\"\"\n        message = \"called remove policy\"\n        return self.update(message)\n\n    def update_for_remove_filtered_policy(self, section, ptype, field_index, *params):\n        \"\"\"\n        update for remove filtered policy\n        :param section: section\n        :param ptype:   policy type\n        :param field_index: field index\n        :param params: other params\n        :return:\n        \"\"\"\n        message = \"called remove filtered policy\"\n        return self.update(message)\n\n    def update_for_save_policy(self, model: casbin.Model):\n        \"\"\"\n        update for save policy\n        :param model: casbin model\n        :return:\n        \"\"\"\n        message = \"called save policy\"\n        return self.update(message)\n\n    def update_for_add_policies(self, section, ptype, *params):\n        \"\"\"\n        update for add policies\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:\n        \"\"\"\n        message = \"called add policies\"\n        return self.update(message)\n\n    def update_for_remove_policies(self, section, ptype, *params):\n        \"\"\"\n        update for remove policies\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:\n        \"\"\"\n        message = \"called remove policies\"\n        return self.update(message)\n\n    def start_watch(self):\n        \"\"\"\n        starts the watch thread\n        :return:\n        \"\"\"\n        pass\n\n\nclass AsyncSampleWatcher:\n    def __init__(self):\n        self.callback = None\n        self.notify_message = None\n\n    async def close(self):\n        pass\n\n    async def set_update_callback(self, callback):\n        \"\"\"\n        sets the callback function to be called when the policy is updated\n        :param callable callback: callback(event)\n            - event: event received from the rabbitmq\n        :return:\n        \"\"\"\n        self.callback = callback\n\n    async def update(self, msg):\n        \"\"\"\n        update the policy\n        \"\"\"\n        self.notify_message = msg\n        return True\n\n    async def update_for_add_policy(self, section, ptype, *params):\n        \"\"\"\n        update for add policy\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:    True if updated\n        \"\"\"\n        message = \"called add policy\"\n        return await self.update(message)\n\n    async def update_for_remove_policy(self, section, ptype, *params):\n        \"\"\"\n        update for remove policy\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:    True if updated\n        \"\"\"\n        message = \"called remove policy\"\n        return await self.update(message)\n\n    async def update_for_remove_filtered_policy(self, section, ptype, field_index, *params):\n        \"\"\"\n        update for remove filtered policy\n        :param section: section\n        :param ptype:   policy type\n        :param field_index: field index\n        :param params: other params\n        :return:\n        \"\"\"\n        message = \"called remove filtered policy\"\n        return await self.update(message)\n\n    async def update_for_save_policy(self, model: casbin.Model):\n        \"\"\"\n        update for save policy\n        :param model: casbin model\n        :return:\n        \"\"\"\n        message = \"called save policy\"\n        return await self.update(message)\n\n    async def update_for_add_policies(self, section, ptype, *params):\n        \"\"\"\n        update for add policies\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:\n        \"\"\"\n        message = \"called add policies\"\n        return await self.update(message)\n\n    async def update_for_remove_policies(self, section, ptype, *params):\n        \"\"\"\n        update for remove policies\n        :param section: section\n        :param ptype:   policy type\n        :param params:  other params\n        :return:\n        \"\"\"\n        message = \"called remove policies\"\n        return await self.update(message)\n\n    async def start_watch(self):\n        \"\"\"\n        starts the watch thread\n        :return:\n        \"\"\"\n        pass\n\n\nclass TestWatcherEx(TestCaseBase):\n    def get_enforcer(self, model=None, adapter=None):\n        return casbin.Enforcer(\n            model,\n            adapter,\n        )\n\n    def test_auto_notify_enabled(self):\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n        )\n        w = SampleWatcher()\n        e.set_watcher(w)\n        e.enable_auto_notify_watcher(True)\n\n        e.save_policy()\n        self.assertEqual(w.notify_message, \"called save policy\")\n\n        e.add_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, \"called add policy\")\n\n        e.remove_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, \"called remove policy\")\n\n        e.remove_filtered_policy(1, \"data1\")\n        self.assertEqual(w.notify_message, \"called remove filtered policy\")\n\n        rules = [\n            [\"jack\", \"data4\", \"read\"],\n            [\"katy\", \"data4\", \"write\"],\n            [\"leyo\", \"data4\", \"read\"],\n            [\"ham\", \"data4\", \"write\"],\n        ]\n        e.add_policies(rules)\n        self.assertEqual(w.notify_message, \"called add policies\")\n\n        e.remove_policies(rules)\n        self.assertEqual(w.notify_message, \"called remove policies\")\n\n    def test_auto_notify_disabled(self):\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n        )\n        w = SampleWatcher()\n        e.set_watcher(w)\n        e.enable_auto_notify_watcher(False)\n\n        e.save_policy()\n        self.assertEqual(w.notify_message, \"called save policy\")\n\n        w.notify_message = None\n\n        e.add_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, None)\n\n        e.remove_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, None)\n\n        e.remove_filtered_policy(1, \"data1\")\n        self.assertEqual(w.notify_message, None)\n\n        rules = [\n            [\"jack\", \"data4\", \"read\"],\n            [\"katy\", \"data4\", \"write\"],\n            [\"leyo\", \"data4\", \"read\"],\n            [\"ham\", \"data4\", \"write\"],\n        ]\n        e.add_policies(rules)\n        self.assertEqual(w.notify_message, None)\n\n        e.remove_policies(rules)\n        self.assertEqual(w.notify_message, None)\n\n\nclass TestAsyncWatcherEx(IsolatedAsyncioTestCase):\n    def get_enforcer(self, model=None, adapter=None):\n        return casbin.AsyncEnforcer(\n            model,\n            adapter,\n        )\n\n    async def test_auto_notify_enabled(self):\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n        )\n        await e.load_policy()\n\n        w = AsyncSampleWatcher()\n        e.set_watcher(w)\n        e.enable_auto_notify_watcher(True)\n\n        await e.save_policy()\n        self.assertEqual(w.notify_message, \"called save policy\")\n\n        await e.add_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, \"called add policy\")\n\n        await e.remove_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, \"called remove policy\")\n\n        await e.remove_filtered_policy(1, \"data1\")\n        self.assertEqual(w.notify_message, \"called remove filtered policy\")\n\n        rules = [\n            [\"jack\", \"data4\", \"read\"],\n            [\"katy\", \"data4\", \"write\"],\n            [\"leyo\", \"data4\", \"read\"],\n            [\"ham\", \"data4\", \"write\"],\n        ]\n        await e.add_policies(rules)\n        self.assertEqual(w.notify_message, \"called add policies\")\n\n        await e.remove_policies(rules)\n        self.assertEqual(w.notify_message, \"called remove policies\")\n\n    async def test_auto_notify_disabled(self):\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n        )\n        await e.load_policy()\n\n        w = SampleWatcher()\n        e.set_watcher(w)\n        e.enable_auto_notify_watcher(False)\n\n        await e.save_policy()\n        self.assertEqual(w.notify_message, \"called save policy\")\n\n        w.notify_message = None\n\n        await e.add_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, None)\n\n        await e.remove_policy(\"admin\", \"data1\", \"read\")\n        self.assertEqual(w.notify_message, None)\n\n        await e.remove_filtered_policy(1, \"data1\")\n        self.assertEqual(w.notify_message, None)\n\n        rules = [\n            [\"jack\", \"data4\", \"read\"],\n            [\"katy\", \"data4\", \"write\"],\n            [\"leyo\", \"data4\", \"read\"],\n            [\"ham\", \"data4\", \"write\"],\n        ]\n        await e.add_policies(rules)\n        self.assertEqual(w.notify_message, None)\n\n        await e.remove_policies(rules)\n        self.assertEqual(w.notify_message, None)\n",
  "GT_file_code": {
    "casbin/async_management_enforcer.py": "# Copyright 2023 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom casbin.async_internal_enforcer import AsyncInternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\n\n\nclass AsyncManagementEnforcer(AsyncInternalEnforcer):\n    \"\"\"\n    AsyncManagementEnforcer = AsyncInternalEnforcer + AsyncManagement API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects(\"p\")\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, 0)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects(\"p\")\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, 1)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions(\"p\")\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, 2)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles(\"g\")\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"g\", ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy(\"p\")\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy(\"p\", field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy(\"p\", ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy(\"g\")\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy(\"g\", ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"g\", ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        return self.has_named_policy(\"p\", *params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"p\", ptype, str_slice)\n\n        return self.model.has_policy(\"p\", ptype, list(params))\n\n    async def add_policy(self, *params):\n        \"\"\"async adds an authorization rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n        return await self.add_named_policy(\"p\", *params)\n\n    async def add_policies(self, rules):\n        \"\"\"async adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        return await self.add_named_policies(\"p\", rules)\n\n    async def add_named_policy(self, ptype, *params):\n        \"\"\"async adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = await self._add_policy(\"p\", ptype, str_slice)\n        else:\n            rule_added = await self._add_policy(\"p\", ptype, list(params))\n\n        return rule_added\n\n    async def add_named_policies(self, ptype, rules):\n        \"\"\"async adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding by adding the new rule.\n        \"\"\"\n        return await self._add_policies(\"p\", ptype, rules)\n\n    async def update_policy(self, old_rule, new_rule):\n        \"\"\"async updates an authorization rule from the current policy.\"\"\"\n        return await self.update_named_policy(\"p\", old_rule, new_rule)\n\n    async def update_policies(self, old_rules, new_rules):\n        \"\"\"async updates authorization rules from the current policy.\"\"\"\n        return await self.update_named_policies(\"p\", old_rules, new_rules)\n\n    async def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"async updates an authorization rule from the current named policy.\"\"\"\n        return await self._update_policy(\"p\", ptype, old_rule, new_rule)\n\n    async def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"async updates authorization rules from the current named policy.\"\"\"\n        return await self._update_policies(\"p\", ptype, old_rules, new_rules)\n\n    async def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"async update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return await self.update_filtered_named_policies(\"p\", new_rules, field_index, *field_values)\n\n    async def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"async update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return await self._update_filtered_policies(\"p\", ptype, new_rules, field_index, *field_values)\n\n    async def remove_policy(self, *params):\n        \"\"\"async removes an authorization rule from the current policy.\"\"\"\n        return await self.remove_named_policy(\"p\", *params)\n\n    async def remove_policies(self, rules):\n        \"\"\"async removes authorization rules from the current policy.\"\"\"\n        return await self.remove_named_policies(\"p\", rules)\n\n    async def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"async removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        return await self.remove_filtered_named_policy(\"p\", field_index, *field_values)\n\n    async def remove_named_policy(self, ptype, *params):\n        \"\"\"async removes an authorization rule from the current named policy.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = await self._remove_policy(\"p\", ptype, str_slice)\n        else:\n            rule_removed = await self._remove_policy(\"p\", ptype, list(params))\n\n        return rule_removed\n\n    async def remove_named_policies(self, ptype, rules):\n        \"\"\"async removes authorization rules from the current named policy.\"\"\"\n        return await self._remove_policies(\"p\", ptype, rules)\n\n    async def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"async removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return await self._remove_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n\n        return self.has_named_grouping_policy(\"g\", *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"g\", ptype, str_slice)\n\n        return self.model.has_policy(\"g\", ptype, list(params))\n\n    async def add_grouping_policy(self, *params):\n        \"\"\"async adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n        return await self.add_named_grouping_policy(\"g\", *params)\n\n    async def add_grouping_policies(self, rules):\n        \"\"\"async adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return await self.add_named_grouping_policies(\"g\", rules)\n\n    async def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"async adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = await self._add_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = await self._add_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n        return rule_added\n\n    async def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"async adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        rules_added = await self._add_policies(\"g\", ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n\n        return rules_added\n\n    async def remove_grouping_policy(self, *params):\n        \"\"\"async removes a role inheritance rule from the current policy.\"\"\"\n        return await self.remove_named_grouping_policy(\"g\", *params)\n\n    async def remove_grouping_policies(self, rules):\n        \"\"\"async removes role inheritance rules from the current policy.\"\"\"\n        return await self.remove_named_grouping_policies(\"g\", rules)\n\n    async def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"async removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return await self.remove_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    async def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"async removes a role inheritance rule from the current named policy.\"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = await self._remove_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = await self._remove_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n        return rule_removed\n\n    async def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"async removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = await self._remove_policies(\"g\", ptype, rules)\n\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n\n        return rules_removed\n\n    async def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"async removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = await self._remove_filtered_policy_returns_effects(\"g\", ptype, field_index, *field_values)\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(\n                self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rule_removed\n            )\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)\n",
    "casbin/management_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom casbin.internal_enforcer import InternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\nfrom casbin.constant.constants import ACTION_INDEX, SUBJECT_INDEX, OBJECT_INDEX\n\n\nclass ManagementEnforcer(InternalEnforcer):\n    \"\"\"\n    ManagementEnforcer = InternalEnforcer + Management API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects(\"p\")\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, SUBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects(\"p\")\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, OBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions(\"p\")\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, ACTION_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles(\"g\")\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"g\", ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy(\"p\")\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy(\"p\", field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy(\"p\", ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy(\"g\")\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy(\"g\", ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"g\", ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        return self.has_named_policy(\"p\", *params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"p\", ptype, str_slice)\n\n        return self.model.has_policy(\"p\", ptype, list(params))\n\n    def add_policy(self, *params):\n        \"\"\"adds an authorization rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_policy(\"p\", *params)\n\n    def add_policies(self, rules):\n        \"\"\"adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        return self.add_named_policies(\"p\", rules)\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy(\"p\", ptype, str_slice)\n        else:\n            rule_added = self._add_policy(\"p\", ptype, list(params))\n\n        return rule_added\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        return self._add_policies(\"p\", ptype, rules)\n\n    def update_policy(self, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current policy.\"\"\"\n        return self.update_named_policy(\"p\", old_rule, new_rule)\n\n    def update_policies(self, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current policy.\"\"\"\n        return self.update_named_policies(\"p\", old_rules, new_rules)\n\n    def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current named policy.\"\"\"\n        return self._update_policy(\"p\", ptype, old_rule, new_rule)\n\n    def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current named policy.\"\"\"\n        return self._update_policies(\"p\", ptype, old_rules, new_rules)\n\n    def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return self.update_filtered_named_policies(\"p\", new_rules, field_index, *field_values)\n\n    def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return self._update_filtered_policies(\"p\", ptype, new_rules, field_index, *field_values)\n\n    def remove_policy(self, *params):\n        \"\"\"removes an authorization rule from the current policy.\"\"\"\n        return self.remove_named_policy(\"p\", *params)\n\n    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\"\"\"\n        return self.remove_named_policies(\"p\", rules)\n\n    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_policy(\"p\", field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy(\"p\", ptype, str_slice)\n        else:\n            rule_removed = self._remove_policy(\"p\", ptype, list(params))\n\n        return rule_removed\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        return self._remove_policies(\"p\", ptype, rules)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return self._remove_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n\n        return self.has_named_grouping_policy(\"g\", *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"g\", ptype, str_slice)\n\n        return self.model.has_policy(\"g\", ptype, list(params))\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policy(\"g\", *params)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policies(\"g\", rules)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = self._add_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n            if ptype in self.cond_rm_map:\n                self.model.build_incremental_conditional_role_links(\n                    self.cond_rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules\n                )\n        return rule_added\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        rules_added = self._add_policies(\"g\", ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n\n        return rules_added\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        return self.remove_named_grouping_policy(\"g\", *params)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        return self.remove_named_grouping_policies(\"g\", rules)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = self._remove_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n        return rule_removed\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = self._remove_policies(\"g\", ptype, rules)\n\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n\n        return rules_removed\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = self._remove_filtered_policy_returns_effects(\"g\", ptype, field_index, *field_values)\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(\n                self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rule_removed\n            )\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)\n",
    "casbin/core_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport logging\n\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n\n    model_path = \"\"\n    model = None\n    fm = None\n    eft = None\n\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def __init__(self, model=None, adapter=None, enable_log=False):\n        self.logger = logging.getLogger(\"casbin.enforcer\")\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        else:\n            if isinstance(adapter, str):\n                raise RuntimeError(\"Invalid parameters for enforcer.\")\n            else:\n                self.init_with_model_and_adapter(model, adapter)\n\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n\n        if not isinstance(m, Model) or adapter is not None and not isinstance(adapter, Adapter):\n            raise RuntimeError(\"Invalid parameters for enforcer.\")\n\n        self.adapter = adapter\n\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n        self._initialize()\n\n        # Do not initialize the full policy when using a filtered adapter\n        if self.adapter and not self.is_filtered():\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model[\"e\"][\"e\"].value)\n        self.watcher = None\n\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path=\"\", text=\"\"):\n        \"\"\"creates a model.\"\"\"\n\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n\n        return self.model\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n\n        return self.adapter\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n\n        self.adapter = adapter\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n\n        self.watcher = watcher\n        pass\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map[\"g\"]\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError(\"ptype not found\")\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map[\"g\"] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n\n        self.model.clear_policy()\n\n    def init_rm_map(self):\n        if \"g\" in self.model.keys():\n            for ptype in self.model[\"g\"]:\n                assertion = self.model[\"g\"][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n\n        try:\n            self.adapter.load_policy(new_model)\n\n            new_model.sort_policies_by_subject_hierarchy()\n\n            new_model.sort_policies_by_priority()\n\n            new_model.print_policy()\n\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n\n            self.model = new_model\n\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n\n            raise e\n\n    def load_filtered_policy(self, filter):\n        \"\"\"reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n\n        self.model.sort_policies_by_priority()\n\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n\n        return hasattr(self.adapter, \"is_filtered\") and self.adapter.is_filtered()\n\n    def save_policy(self):\n        if self.is_filtered():\n            raise RuntimeError(\"cannot save a filtered policy\")\n\n        self.adapter.save_policy(self.model)\n\n        if self.watcher:\n            if callable(getattr(self.watcher, \"update_for_save_policy\", None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"controls whether to save a policy rule automatically notify the watcher when it is added or removed.\"\"\"\n        self.auto_notify_watcher = auto_notify_watcher\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n\n        for rm in self.rm_map.values():\n            rm.clear()\n\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(\n            rtype=\"r\" + suffix,\n            ptype=\"p\" + suffix,\n            etype=\"e\" + suffix,\n            mtype=\"m\" + suffix,\n        )\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n\n        rtype = \"r\"\n        ptype = \"p\"\n        etype = \"e\"\n        mtype = \"m\"\n\n        if not self.enabled:\n            return [True, []]\n\n        functions = self.fm.get_functions()\n\n        if \"g\" in self.model.keys():\n            for key, ast in self.model[\"g\"].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n\n        if \"m\" not in self.model.keys():\n            raise RuntimeError(\"model is undefined\")\n\n        if \"m\" not in self.model[\"m\"].keys():\n            raise RuntimeError(\"model is undefined\")\n\n        r_tokens = self.model[\"r\"][rtype].tokens\n        p_tokens = self.model[\"p\"][ptype].tokens\n\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError(\"invalid request size\")\n\n        exp_string = self.model[\"m\"][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n\n        policy_effects = set()\n\n        r_parameters = dict(zip(r_tokens, rvals))\n\n        policy_len = len(self.model[\"p\"][ptype].policy)\n\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model[\"p\"][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError(\"invalid policy size\")\n\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n\n                result = expression.eval(parameters)\n\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError(\"matcher result should be bool, int or float\")\n\n                p_eft_key = ptype + \"_eft\"\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if \"allow\" == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif \"deny\" == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n\n        else:\n            if exp_has_eval:\n                raise RuntimeError(\"please make sure rule exists in policy when using eval() in matcher\")\n\n            parameters = r_parameters.copy()\n\n            for token in self.model[\"p\"][ptype].tokens:\n                parameters[token] = \"\"\n\n            result = expression.eval(parameters)\n\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n\n        # Log request.\n\n        req_str = \"Request: \"\n        req_str = req_str + \", \".join([str(v) for v in rvals])\n\n        req_str = req_str + \" ---> %s\" % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            # leaving this in warning for now, if it's very noise this can be changed to info or debug,\n            # or change the log level\n            self.logger.warning(req_str)\n\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model[\"p\"][ptype].policy[explain_index]\n\n        return result, explain_rule\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace(\"&&\", \"and\")\n        expr = expr.replace(\"||\", \"or\")\n        expr = expr.replace(\"!\", \"not\")\n\n        return SimpleEval(expr, functions)\n",
    "casbin/async_internal_enforcer.py": "# Copyright 2023 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport copy\nimport inspect\n\nfrom casbin.core_enforcer import CoreEnforcer\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist.adapters.asyncio import AsyncFileAdapter, AsyncAdapter\n\n\nclass AsyncInternalEnforcer(CoreEnforcer):\n    \"\"\"\n    AsyncInternalEnforcer = CoreEnforcer + Async Internal API.\n    \"\"\"\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = AsyncFileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n\n        if not isinstance(m, Model) or adapter is not None and not isinstance(adapter, AsyncAdapter):\n            raise RuntimeError(\"Invalid parameters for enforcer.\")\n\n        self.adapter = adapter\n\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n        self._initialize()\n\n    async def load_policy(self):\n        \"\"\"async reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n\n        try:\n            await self.adapter.load_policy(new_model)\n\n            new_model.sort_policies_by_subject_hierarchy()\n\n            new_model.sort_policies_by_priority()\n\n            new_model.print_policy()\n\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n\n                new_model.build_role_links(self.rm_map)\n\n            self.model = new_model\n\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n\n            raise e\n\n    async def load_filtered_policy(self, filter):\n        \"\"\"async reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        await self.adapter.load_filtered_policy(self.model, filter)\n\n        self.model.sort_policies_by_priority()\n\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    async def load_increment_filtered_policy(self, filter):\n        \"\"\"async append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    async def save_policy(self):\n        if self.is_filtered():\n            raise RuntimeError(\"cannot save a filtered policy\")\n\n        await self.adapter.save_policy(self.model)\n\n        if self.watcher:\n            update_for_save_policy = getattr(self.watcher, \"update_for_save_policy\", None)\n            if callable(update_for_save_policy):\n                if inspect.iscoroutinefunction(update_for_save_policy):\n                    await update_for_save_policy(self.model)\n                else:\n                    update_for_save_policy(self.model)\n            else:\n                self.watcher.update()\n\n    async def _add_policy(self, sec, ptype, rule):\n        \"\"\"async adds a rule to the current policy.\"\"\"\n        rule_added = self.model.add_policy(sec, ptype, rule)\n        if not rule_added:\n            return rule_added\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.add_policy(sec, ptype, rule)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                update_for_add_policy = getattr(self.watcher, \"update_for_add_policy\", None)\n                if callable(update_for_add_policy):\n                    if inspect.iscoroutinefunction(update_for_add_policy):\n                        await update_for_add_policy(sec, ptype, rule)\n                    else:\n                        update_for_add_policy(sec, ptype, rule)\n                else:\n                    self.watcher.update()\n\n        return rule_added\n\n    async def _add_policies(self, sec, ptype, rules):\n        \"\"\"async adds rules to the current policy.\"\"\"\n        rules_added = self.model.add_policies(sec, ptype, rules)\n        if not rules_added:\n            return rules_added\n\n        if self.adapter and self.auto_save:\n            if hasattr(self.adapter, \"add_policies\") is False:\n                return False\n\n            result = await self.adapter.add_policies(sec, ptype, rules)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                update_for_add_policies = getattr(self.watcher, \"update_for_add_policies\", None)\n                if callable(update_for_add_policies):\n                    if inspect.iscoroutinefunction(update_for_add_policies):\n                        await update_for_add_policies(sec, ptype, rules)\n                    else:\n                        update_for_add_policies(sec, ptype, rules)\n                else:\n                    self.watcher.update()\n\n        return rules_added\n\n    async def _update_policy(self, sec, ptype, old_rule, new_rule):\n        \"\"\"async updates a rule from the current policy.\"\"\"\n        rule_updated = self.model.update_policy(sec, ptype, old_rule, new_rule)\n\n        if not rule_updated:\n            return rule_updated\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.update_policy(sec, ptype, old_rule, new_rule)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n\n        return rule_updated\n\n    async def _update_policies(self, sec, ptype, old_rules, new_rules):\n        \"\"\"async updates rules from the current policy.\"\"\"\n        rules_updated = self.model.update_policies(sec, ptype, old_rules, new_rules)\n\n        if not rules_updated:\n            return rules_updated\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.update_policies(sec, ptype, old_rules, new_rules)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n\n        return rules_updated\n\n    async def _update_filtered_policies(self, sec, ptype, new_rules, field_index, *field_values):\n        \"\"\"async deletes old rules and adds new rules.\"\"\"\n\n        old_rules = self.model.get_filtered_policy(sec, ptype, field_index, *field_values)\n\n        if self.adapter and self.auto_save:\n            try:\n                old_rules = await self.adapter.update_filtered_policies(\n                    sec, ptype, new_rules, field_index, *field_values\n                )\n            except:\n                pass\n\n        if not old_rules:\n            return False\n\n        is_rule_changed = self.model.remove_policies(sec, ptype, old_rules)\n        self.model.add_policies(sec, ptype, new_rules)\n        is_rule_changed = is_rule_changed and len(new_rules) != 0\n        if not is_rule_changed:\n            return is_rule_changed\n        if sec == \"g\":\n            self.build_role_links()\n        if self.watcher and self.auto_notify_watcher:\n            self.watcher.update()\n        return is_rule_changed\n\n    async def _remove_policy(self, sec, ptype, rule):\n        \"\"\"async removes a rule from the current policy.\"\"\"\n        rule_removed = self.model.remove_policy(sec, ptype, rule)\n        if not rule_removed:\n            return rule_removed\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_policy(sec, ptype, rule)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_policy = getattr(self.watcher, \"update_for_remove_policy\", None)\n                if callable(update_for_remove_policy):\n                    if inspect.iscoroutinefunction(update_for_remove_policy):\n                        await update_for_remove_policy(sec, ptype, rule)\n                    else:\n                        update_for_remove_policy(sec, ptype, rule)\n                else:\n                    self.watcher.update()\n\n        return rule_removed\n\n    async def _remove_policies(self, sec, ptype, rules):\n        \"\"\"async RemovePolicies removes policy rules from the model.\"\"\"\n        rules_removed = self.model.remove_policies(sec, ptype, rules)\n        if not rules_removed:\n            return rules_removed\n\n        if self.adapter and self.auto_save:\n            if hasattr(self.adapter, \"remove_policies\") is False:\n                return False\n\n            result = await self.adapter.remove_policies(sec, ptype, rules)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_policies = getattr(self.watcher, \"update_for_remove_policies\", None)\n                if callable(update_for_remove_policies):\n                    if inspect.iscoroutinefunction(update_for_remove_policies):\n                        await update_for_remove_policies(sec, ptype, rules)\n                    else:\n                        update_for_remove_policies(sec, ptype, rules)\n                else:\n                    self.watcher.update()\n\n        return rules_removed\n\n    async def _remove_filtered_policy(self, sec, ptype, field_index, *field_values):\n        \"\"\"async removes rules based on field filters from the current policy.\"\"\"\n        rule_removed = self.model.remove_filtered_policy(sec, ptype, field_index, *field_values)\n        if not rule_removed:\n            return rule_removed\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_filtered_policy(sec, ptype, field_index, *field_values)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_filtered_policy = getattr(self.watcher, \"update_for_remove_filtered_policy\", None)\n                if callable(update_for_remove_filtered_policy):\n                    if inspect.iscoroutinefunction(update_for_remove_filtered_policy):\n                        await update_for_remove_filtered_policy(sec, ptype, field_index, *field_values)\n                    else:\n                        update_for_remove_filtered_policy(sec, ptype, field_index, *field_values)\n                else:\n                    self.watcher.update()\n\n        return rule_removed\n\n    async def _remove_filtered_policy_returns_effects(self, sec, ptype, field_index, *field_values):\n        \"\"\"async removes rules based on field filters from the current policy.\"\"\"\n        rule_removed = self.model.remove_filtered_policy_returns_effects(sec, ptype, field_index, *field_values)\n        if len(rule_removed) == 0:\n            return rule_removed\n\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_filtered_policy(sec, ptype, field_index, *field_values)\n            if result is False:\n                return False\n\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n\n        return rule_removed\n\n    async def get_field_index(self, ptype, field):\n        \"\"\"gets the index of the field name.\"\"\"\n        return self.model.get_field_index(ptype, field)\n\n    async def set_field_index(self, ptype, field, index):\n        \"\"\"sets the index of the field name.\"\"\"\n        assertion = self.model[\"p\"][ptype]\n        assertion.field_index_map[field] = index\n"
  },
  "GT_src_dict": {
    "casbin/async_management_enforcer.py": {},
    "casbin/management_enforcer.py": {
      "ManagementEnforcer.add_policy": {
        "code": "    def add_policy(self, *params):\n        \"\"\"Adds an authorization rule to the current policy.\n\nThis method calls `add_named_policy` with the policy type `\"p\"`, appending the specified parameters as the new rule. If the rule already exists in the policy, it will return `False` without adding it; otherwise, it returns `True` upon successful addition. This method is intended to manage the add operation for authorization rules and integrates directly with the underlying policy management defined in the parent class.\n\nParameters:\n- *params: Variable length arguments representing the new authorization rule to be added.\n\nReturns:\n- bool: `True` if the rule was successfully added; `False` if the rule already exists.\n\nDependencies:\n- `add_named_policy`: This method is crucial for the actual addition of the policy rule and is part of the ManagementEnforcer class.\n- The constant `\"p\"` refers to the default policy type for permissions and is a fundamental part of the Casbin policy model design.\"\"\"\n        'adds an authorization rule to the current policy.\\n\\n        If the rule already exists, the function returns false and the rule will not be added.\\n        Otherwise the function returns true by adding the new rule.\\n        '\n        return self.add_named_policy('p', *params)",
        "docstring": "Adds an authorization rule to the current policy.\n\nThis method calls `add_named_policy` with the policy type `\"p\"`, appending the specified parameters as the new rule. If the rule already exists in the policy, it will return `False` without adding it; otherwise, it returns `True` upon successful addition. This method is intended to manage the add operation for authorization rules and integrates directly with the underlying policy management defined in the parent class.\n\nParameters:\n- *params: Variable length arguments representing the new authorization rule to be added.\n\nReturns:\n- bool: `True` if the rule was successfully added; `False` if the rule already exists.\n\nDependencies:\n- `add_named_policy`: This method is crucial for the actual addition of the policy rule and is part of the ManagementEnforcer class.\n- The constant `\"p\"` refers to the default policy type for permissions and is a fundamental part of the Casbin policy model design.",
        "signature": "def add_policy(self, *params):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      },
      "ManagementEnforcer.add_policies": {
        "code": "    def add_policies(self, rules):\n        \"\"\"Adds multiple authorization rules to the current policy.\n\nThis method leverages the `add_named_policies` function with the policy type set to 'p'. Each rule is tested for existence; if a rule already exists, it will not be added, and the function will return false for that specific rule. Conversely, new rules will be successfully added, returning true.\n\nParameters:\n- rules (list): A list of authorization rules that are to be added to the current policy.\n\nReturns:\n- list: A list indicating the success (true) or failure (false) status for each rule added, corresponding to the input rules.\n\nDependencies:\n- This method interacts with the `add_named_policies` method which is defined in the same class, ManagementEnforcer. It relies on the 'p' policy type, which defines the access control rules in the context of the Enforcer's model.\"\"\"\n        'adds authorization rules to the current policy.\\n\\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\\n        '\n        return self.add_named_policies('p', rules)",
        "docstring": "Adds multiple authorization rules to the current policy.\n\nThis method leverages the `add_named_policies` function with the policy type set to 'p'. Each rule is tested for existence; if a rule already exists, it will not be added, and the function will return false for that specific rule. Conversely, new rules will be successfully added, returning true.\n\nParameters:\n- rules (list): A list of authorization rules that are to be added to the current policy.\n\nReturns:\n- list: A list indicating the success (true) or failure (false) status for each rule added, corresponding to the input rules.\n\nDependencies:\n- This method interacts with the `add_named_policies` method which is defined in the same class, ManagementEnforcer. It relies on the 'p' policy type, which defines the access control rules in the context of the Enforcer's model.",
        "signature": "def add_policies(self, rules):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      },
      "ManagementEnforcer.remove_policy": {
        "code": "    def remove_policy(self, *params):\n        \"\"\"Removes an authorization rule from the current policy.\n\nParameters:\n*params: The parameters that specify the authorization rule to remove. The parameters can be provided as individual arguments or as a single list.\n\nReturns:\nbool: True if the rule was successfully removed, False if the rule did not exist.\n\nThis method relies on the `remove_named_policy` function, specifically targeting the policy type `\"p\"` which represents the main policy rules. It interacts with the underlying policy management functions to ensure the specified rule is correctly removed from the stored policies.\"\"\"\n        'removes an authorization rule from the current policy.'\n        return self.remove_named_policy('p', *params)",
        "docstring": "Removes an authorization rule from the current policy.\n\nParameters:\n*params: The parameters that specify the authorization rule to remove. The parameters can be provided as individual arguments or as a single list.\n\nReturns:\nbool: True if the rule was successfully removed, False if the rule did not exist.\n\nThis method relies on the `remove_named_policy` function, specifically targeting the policy type `\"p\"` which represents the main policy rules. It interacts with the underlying policy management functions to ensure the specified rule is correctly removed from the stored policies.",
        "signature": "def remove_policy(self, *params):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      },
      "ManagementEnforcer.remove_policies": {
        "code": "    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\n\nParameters:\n- rules (list): A list of authorization rules to be removed from the current policy.\n\nReturns:\n- bool: Returns true if all specified rules were successfully removed; otherwise, returns false for the corresponding rule that could not be removed.\n\nThe method interacts with the `remove_named_policies` method, which specifically handles the removal of rules from the \"p\" (policy) type. The constant \"p\" is used to denote this policy type consistently across the class, ensuring that rules related to permissions are correctly targeted during removal.\"\"\"\n        'removes authorization rules from the current policy.'\n        return self.remove_named_policies('p', rules)",
        "docstring": "removes authorization rules from the current policy.\n\nParameters:\n- rules (list): A list of authorization rules to be removed from the current policy.\n\nReturns:\n- bool: Returns true if all specified rules were successfully removed; otherwise, returns false for the corresponding rule that could not be removed.\n\nThe method interacts with the `remove_named_policies` method, which specifically handles the removal of rules from the \"p\" (policy) type. The constant \"p\" is used to denote this policy type consistently across the class, ensuring that rules related to permissions are correctly targeted during removal.",
        "signature": "def remove_policies(self, rules):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      },
      "ManagementEnforcer.remove_filtered_policy": {
        "code": "    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"Removes an authorization rule from the current policy with the option to specify field filters. This method utilizes the `remove_filtered_named_policy` method to target specific policies based on the provided field index and values.\n\nParameters:\n- field_index (int): The index of the field in the policy for filtering the rules to be removed.\n- *field_values: The values corresponding to the filtered field index. These specify which rules to remove from the policy.\n\nReturns:\n- bool: Returns true if the rule was successfully removed, false otherwise.\n\nThis method interacts with the named policy \"p\" (standard policy type) defined in the context of the ManagementEnforcer class, facilitating finer control over policy management by allowing selective removal based on given criteria.\"\"\"\n        'removes an authorization rule from the current policy, field filters can be specified.'\n        return self.remove_filtered_named_policy('p', field_index, *field_values)",
        "docstring": "Removes an authorization rule from the current policy with the option to specify field filters. This method utilizes the `remove_filtered_named_policy` method to target specific policies based on the provided field index and values.\n\nParameters:\n- field_index (int): The index of the field in the policy for filtering the rules to be removed.\n- *field_values: The values corresponding to the filtered field index. These specify which rules to remove from the policy.\n\nReturns:\n- bool: Returns true if the rule was successfully removed, false otherwise.\n\nThis method interacts with the named policy \"p\" (standard policy type) defined in the context of the ManagementEnforcer class, facilitating finer control over policy management by allowing selective removal based on given criteria.",
        "signature": "def remove_filtered_policy(self, field_index, *field_values):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      }
    },
    "casbin/core_enforcer.py": {
      "CoreEnforcer.__init__": {
        "code": "    def __init__(self, model=None, adapter=None, enable_log=False):\n        \"\"\"Initializes a CoreEnforcer instance which defines the core functionality of an access control enforcer in the Casbin framework. It can be initialized with different configurations including model files, adapters, and logging options.\n\n    Parameters:\n    - model (Union[str, Model], optional): The model file path or a Model object that defines the access control model.\n    - adapter (Union[str, Adapter], optional): The policy adapter file path or an Adapter object for policy persistence.\n    - enable_log (bool, optional): Enables logging if set to True; defaults to False.\n\n    Raises:\n    - RuntimeError: If the parameters are invalid, particularly when model or adapter types do not match the expected formats.\n\n    This initializer reads model and policy configurations and sets up logging based on the provided parameters. It also interacts with various methods such as `init_with_file`, `init_with_adapter`, and `init_with_model_and_adapter` to set up the enforcer according to the given configurations.\"\"\"\n        self.logger = logging.getLogger('casbin.enforcer')\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        elif isinstance(adapter, str):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        else:\n            self.init_with_model_and_adapter(model, adapter)\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()",
        "docstring": "Initializes a CoreEnforcer instance which defines the core functionality of an access control enforcer in the Casbin framework. It can be initialized with different configurations including model files, adapters, and logging options.\n\nParameters:\n- model (Union[str, Model], optional): The model file path or a Model object that defines the access control model.\n- adapter (Union[str, Adapter], optional): The policy adapter file path or an Adapter object for policy persistence.\n- enable_log (bool, optional): Enables logging if set to True; defaults to False.\n\nRaises:\n- RuntimeError: If the parameters are invalid, particularly when model or adapter types do not match the expected formats.\n\nThis initializer reads model and policy configurations and sets up logging based on the provided parameters. It also interacts with various methods such as `init_with_file`, `init_with_adapter`, and `init_with_model_and_adapter` to set up the enforcer according to the given configurations.",
        "signature": "def __init__(self, model=None, adapter=None, enable_log=False):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.set_watcher": {
        "code": "    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher for the CoreEnforcer.\n\n    Parameters:\n        watcher: An object or function that implements a watching mechanism to receive notifications on policy changes. The specific implementation details of the watcher are not enforced within this method.\n\n    This method stores the provided watcher in the `self.watcher` attribute, allowing the CoreEnforcer to utilize it for automatic notifications related to policy changes. The interactions between the watcher and the CoreEnforcer facilitate dynamic response mechanisms upon policy updates, depending on how the watcher is implemented.\"\"\"\n        'sets the current watcher.'\n        self.watcher = watcher\n        pass",
        "docstring": "sets the current watcher for the CoreEnforcer.\n\nParameters:\n    watcher: An object or function that implements a watching mechanism to receive notifications on policy changes. The specific implementation details of the watcher are not enforced within this method.\n\nThis method stores the provided watcher in the `self.watcher` attribute, allowing the CoreEnforcer to utilize it for automatic notifications related to policy changes. The interactions between the watcher and the CoreEnforcer facilitate dynamic response mechanisms upon policy updates, depending on how the watcher is implemented.",
        "signature": "def set_watcher(self, watcher):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.save_policy": {
        "code": "    def save_policy(self):\n        \"\"\"Saves the current policy to the adapter, persisting any changes made to the policy model.\n    \n    This method checks whether the policy is filtered by calling `is_filtered()`. If it is, a RuntimeError is raised since filtered policies cannot be saved. If not filtered, the current model's policy is saved through the methods defined in the `adapter`, which can be any implementation of the `Adapter` interface (e.g., `FileAdapter`).\n\n    If a watcher is set (indicated by `self.watcher`), and if it has an `update_for_save_policy` method, that method is called to notify the watcher of the saved policy. If the method is not defined, the generic `update` method is called instead.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n\n    Raises:\n        RuntimeError: If the currently loaded policy is a filtered policy.\n        \n    Attributes Used:\n        - `self.adapter`: The adapter responsible for saving the policy, which must implement the `save_policy` method.\n        - `self.watcher`: An optional watcher that can be notified of changes to the policy.\"\"\"\n        if self.is_filtered():\n            raise RuntimeError('cannot save a filtered policy')\n        self.adapter.save_policy(self.model)\n        if self.watcher:\n            if callable(getattr(self.watcher, 'update_for_save_policy', None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()",
        "docstring": "Saves the current policy to the adapter, persisting any changes made to the policy model.\n\nThis method checks whether the policy is filtered by calling `is_filtered()`. If it is, a RuntimeError is raised since filtered policies cannot be saved. If not filtered, the current model's policy is saved through the methods defined in the `adapter`, which can be any implementation of the `Adapter` interface (e.g., `FileAdapter`).\n\nIf a watcher is set (indicated by `self.watcher`), and if it has an `update_for_save_policy` method, that method is called to notify the watcher of the saved policy. If the method is not defined, the generic `update` method is called instead.\n\nParameters:\n    None\n\nReturns:\n    None\n\nRaises:\n    RuntimeError: If the currently loaded policy is a filtered policy.\n    \nAttributes Used:\n    - `self.adapter`: The adapter responsible for saving the policy, which must implement the `save_policy` method.\n    - `self.watcher`: An optional watcher that can be notified of changes to the policy.",
        "signature": "def save_policy(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.enable_auto_notify_watcher": {
        "code": "    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"Controls whether to automatically notify the watcher when a policy rule is added or removed.\n    \n    This method sets the `auto_notify_watcher` attribute of the `CoreEnforcer` class. If `auto_notify_watcher` is set to `True`, any changes to policies will trigger an update notification to the watcher. This is useful for synchronizing changes across distributed systems or components that rely on the current state of policies.\n\n    Parameters:\n        auto_notify_watcher (bool): A flag to enable or disable automatic notifications to the watcher when policy changes occur.\n    \n    Returns:\n        None\n    \n    Side Effects:\n        Modifies the state of the `auto_notify_watcher` attribute within the `CoreEnforcer` instance. It does not return any values.\n    \n    Attributes:\n        auto_notify_watcher (bool): Controls the notification behavior to the watcher. Defined and initialized in the `CoreEnforcer` class.\"\"\"\n        'controls whether to save a policy rule automatically notify the watcher when it is added or removed.'\n        self.auto_notify_watcher = auto_notify_watcher",
        "docstring": "Controls whether to automatically notify the watcher when a policy rule is added or removed.\n\nThis method sets the `auto_notify_watcher` attribute of the `CoreEnforcer` class. If `auto_notify_watcher` is set to `True`, any changes to policies will trigger an update notification to the watcher. This is useful for synchronizing changes across distributed systems or components that rely on the current state of policies.\n\nParameters:\n    auto_notify_watcher (bool): A flag to enable or disable automatic notifications to the watcher when policy changes occur.\n\nReturns:\n    None\n\nSide Effects:\n    Modifies the state of the `auto_notify_watcher` attribute within the `CoreEnforcer` instance. It does not return any values.\n\nAttributes:\n    auto_notify_watcher (bool): Controls the notification behavior to the watcher. Defined and initialized in the `CoreEnforcer` class.",
        "signature": "def enable_auto_notify_watcher(self, auto_notify_watcher):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      }
    },
    "casbin/async_internal_enforcer.py": {}
  },
  "dependency_dict": {
    "casbin/core_enforcer.py:CoreEnforcer:__init__": {
      "casbin/async_internal_enforcer.py": {
        "AsyncInternalEnforcer.init_with_file": {
          "code": "    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = AsyncFileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)",
          "docstring": "initializes an enforcer with a model file and a policy file.",
          "signature": "def init_with_file(self, model_path, policy_path):",
          "type": "Method",
          "class_signature": "class AsyncInternalEnforcer(CoreEnforcer):"
        }
      },
      "casbin/core_enforcer.py": {
        "CoreEnforcer.init_with_file": {
          "code": "    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)",
          "docstring": "initializes an enforcer with a model file and a policy file.",
          "signature": "def init_with_file(self, model_path, policy_path):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "casbin/util/log.py": {
        "disabled_logging": {
          "code": "def disabled_logging():\n    for logger_name in DEFAULT_LOGGING[\"loggers\"].keys():\n        logging.getLogger(logger_name).disabled = True",
          "docstring": "",
          "signature": "def disabled_logging():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:save_policy": {
      "tests/test_watcher_ex.py": {
        "SampleWatcher.update_for_save_policy": {
          "code": "    def update_for_save_policy(self, model: casbin.Model):\n        \"\"\"\n        update for save policy\n        :param model: casbin model\n        :return:\n        \"\"\"\n        message = \"called save policy\"\n        return self.update(message)",
          "docstring": "update for save policy\n:param model: casbin model\n:return:",
          "signature": "def update_for_save_policy(self, model: casbin.Model):",
          "type": "Method",
          "class_signature": "class SampleWatcher:"
        }
      },
      "casbin/core_enforcer.py": {
        "CoreEnforcer.is_filtered": {
          "code": "    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        return hasattr(self.adapter, 'is_filtered') and self.adapter.is_filtered()",
          "docstring": "returns true if the loaded policy has been filtered.",
          "signature": "def is_filtered(self):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "casbin/persist/adapters/file_adapter.py": {
        "FileAdapter.save_policy": {
          "code": "    def save_policy(self, model):\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError(\"invalid file path, file path cannot be empty\")\n\n        self._save_policy_file(model)",
          "docstring": "",
          "signature": "def save_policy(self, model):",
          "type": "Method",
          "class_signature": "class FileAdapter(Adapter):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:add_policy": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.add_named_policy": {
          "code": "    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy('p', ptype, str_slice)\n        else:\n            rule_added = self._add_policy('p', ptype, list(params))\n        return rule_added",
          "docstring": "adds an authorization rule to the current named policy.\n\nIf the rule already exists, the function returns false and the rule will not be added.\nOtherwise the function returns true by adding the new rule.",
          "signature": "def add_named_policy(self, ptype, *params):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:remove_policy": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.remove_named_policy": {
          "code": "    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy('p', ptype, str_slice)\n        else:\n            rule_removed = self._remove_policy('p', ptype, list(params))\n        return rule_removed",
          "docstring": "removes an authorization rule from the current named policy.",
          "signature": "def remove_named_policy(self, ptype, *params):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:remove_filtered_policy": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.remove_filtered_named_policy": {
          "code": "    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return self._remove_filtered_policy('p', ptype, field_index, *field_values)",
          "docstring": "removes an authorization rule from the current named policy, field filters can be specified.",
          "signature": "def remove_filtered_named_policy(self, ptype, field_index, *field_values):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:add_policies": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.add_named_policies": {
          "code": "    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        return self._add_policies('p', ptype, rules)",
          "docstring": "adds authorization rules to the current named policy.\n\nIf the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\nOtherwise the function returns true for the corresponding by adding the new rule.",
          "signature": "def add_named_policies(self, ptype, rules):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:remove_policies": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.remove_named_policies": {
          "code": "    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        return self._remove_policies('p', ptype, rules)",
          "docstring": "removes authorization rules from the current named policy.",
          "signature": "def remove_named_policies(self, ptype, rules):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:load_policy": {
      "casbin/model/policy.py": {
        "Policy.build_role_links": {
          "code": "    def build_role_links(self, rm_map):\n        \"\"\"initializes the roles in RBAC.\"\"\"\n\n        if \"g\" not in self.keys():\n            return\n\n        for ptype, ast in self[\"g\"].items():\n            rm = rm_map.get(ptype)\n            if rm:\n                ast.build_role_links(rm)",
          "docstring": "initializes the roles in RBAC.",
          "signature": "def build_role_links(self, rm_map):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.print_policy": {
          "code": "    def print_policy(self):\n        \"\"\"Log using info\"\"\"\n\n        self.logger.info(\"Policy:\")\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key, ast in self[sec].items():\n                self.logger.info(\"{} : {} : {}\".format(key, ast.value, ast.policy))",
          "docstring": "Log using info",
          "signature": "def print_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.clear_policy": {
          "code": "    def clear_policy(self):\n        \"\"\"clears all current policy.\"\"\"\n\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key in self[sec].keys():\n                self[sec][key].policy = []",
          "docstring": "clears all current policy.",
          "signature": "def clear_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/model/model.py": {
        "Model.sort_policies_by_priority": {
          "code": "    def sort_policies_by_priority(self):\n        for ptype, assertion in self[\"p\"].items():\n            for index, token in enumerate(assertion.tokens):\n                if token == f\"{ptype}_priority\":\n                    assertion.priority_index = index\n                    break\n\n            if assertion.priority_index == -1:\n                continue\n\n            assertion.policy = sorted(\n                assertion.policy,\n                key=lambda x: int(x[assertion.priority_index])\n                if x[assertion.priority_index].isdigit()\n                else x[assertion.priority_index],\n            )\n\n            for i, policy in enumerate(assertion.policy):\n                assertion.policy_map[\",\".join(policy)] = i\n\n        return None",
          "docstring": "",
          "signature": "def sort_policies_by_priority(self):",
          "type": "Method",
          "class_signature": "class Model(Policy):"
        },
        "Model.sort_policies_by_subject_hierarchy": {
          "code": "    def sort_policies_by_subject_hierarchy(self):\n        if self[\"e\"][\"e\"].value != \"subjectPriority(p_eft) || deny\":\n            return\n\n        sub_index = 0\n        domain_index = -1\n        for ptype, assertion in self[\"p\"].items():\n            for index, token in enumerate(assertion.tokens):\n                if token == \"{}_dom\".format(ptype):\n                    domain_index = index\n                    break\n\n            subject_hierarchy_map = self.get_subject_hierarchy_map(self[\"g\"][\"g\"].policy)\n\n            def compare_policy(policy):\n                domain = DEFAULT_DOMAIN\n                if domain_index != -1:\n                    domain = policy[domain_index]\n                name = self.get_name_with_domain(domain, policy[sub_index])\n                return subject_hierarchy_map.get(name, 0)\n\n            assertion.policy = sorted(assertion.policy, key=compare_policy)\n            for i, policy in enumerate(assertion.policy):\n                assertion.policy_map[\",\".join(policy)] = i",
          "docstring": "",
          "signature": "def sort_policies_by_subject_hierarchy(self):",
          "type": "Method",
          "class_signature": "class Model(Policy):"
        }
      }
    },
    "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:save_policy": {
      "casbin/core_enforcer.py": {
        "CoreEnforcer.is_filtered": {
          "code": "    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        return hasattr(self.adapter, 'is_filtered') and self.adapter.is_filtered()",
          "docstring": "returns true if the loaded policy has been filtered.",
          "signature": "def is_filtered(self):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "tests/test_watcher_ex.py": {
        "SampleWatcher.update_for_save_policy": {
          "code": "    def update_for_save_policy(self, model: casbin.Model):\n        \"\"\"\n        update for save policy\n        :param model: casbin model\n        :return:\n        \"\"\"\n        message = \"called save policy\"\n        return self.update(message)",
          "docstring": "update for save policy\n:param model: casbin model\n:return:",
          "signature": "def update_for_save_policy(self, model: casbin.Model):",
          "type": "Method",
          "class_signature": "class SampleWatcher:"
        }
      }
    },
    "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policy": {},
    "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policy": {},
    "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_filtered_policy": {},
    "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policies": {},
    "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policies": {}
  },
  "call_tree": {
    "tests/test_watcher_ex.py:TestWatcherEx:test_auto_notify_disabled": {
      "tests/test_enforcer.py:get_examples": {},
      "tests/test_watcher_ex.py:TestWatcherEx:get_enforcer": {
        "casbin/core_enforcer.py:CoreEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
            "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
            "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
              "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                "casbin/model/policy.py:Policy:__init__": {},
                "casbin/model/model.py:Model:load_model": {
                  "casbin/config/config.py:Config:new_config": {
                    "casbin/config/config.py:Config:__init__": {},
                    "casbin/config/config.py:Config:_parse": {
                      "casbin/config/config.py:Config:_parse_buffer": {}
                    }
                  },
                  "casbin/model/model.py:Model:_load_section": {
                    "casbin/model/model.py:Model:_get_key_suffix": {},
                    "casbin/model/model.py:Model:_load_assertion": {
                      "casbin/config/config.py:Config:get": {},
                      "casbin/model/model.py:Model:add_def": {}
                    }
                  }
                }
              },
              "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                "casbin/model/model.py:Model:Model": {},
                "casbin/persist/adapter.py:Adapter:Adapter": {},
                "casbin/model/model.py:Model:print_model": {
                  "casbin/model/policy.py:Policy:items": {}
                },
                "casbin/model/function.py:FunctionMap:load_function_map": {
                  "casbin/model/function.py:FunctionMap:__init__": {},
                  "casbin/model/function.py:FunctionMap:add_function": {}
                },
                "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/effect/__init__.py:get_effector": {},
                  "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                    "casbin/model/policy.py:Policy:keys": {}
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                  "casbin/model/policy.py:Policy:clear_policy": {
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
                      "casbin/persist/adapter.py:load_policy_line": {}
                    }
                  },
                  "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/model/model.py:Model:sort_policies_by_priority": {
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/model/policy.py:Policy:print_policy": {
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  }
                }
              }
            }
          },
          "casbin/util/log.py:disabled_logging": {}
        }
      },
      "tests/test_watcher_ex.py:SampleWatcher:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:set_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:enable_auto_notify_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
        "casbin/persist/adapters/file_adapter.py:FileAdapter:save_policy": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:_save_policy_file": {}
        },
        "tests/test_watcher_ex.py:SampleWatcher:update_for_save_policy": {
          "tests/test_watcher_ex.py:SampleWatcher:update": {}
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:add_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:add_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_add_policy": {
            "casbin/model/policy.py:Policy:add_policy": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              }
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:add_policy": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_policy": {
            "casbin/model/policy.py:Policy:remove_policy": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:remove_policy": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_filtered_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_filtered_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_filtered_policy": {
            "casbin/model/policy.py:Policy:remove_filtered_policy": {
              "casbin/model/policy.py:Policy:keys": {},
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapter.py:Adapter:remove_filtered_policy": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:add_policies": {
        "casbin/management_enforcer.py:ManagementEnforcer:add_named_policies": {
          "casbin/internal_enforcer.py:InternalEnforcer:_add_policies": {
            "casbin/model/policy.py:Policy:add_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:add_policies": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_policies": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_named_policies": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_policies": {
            "casbin/model/policy.py:Policy:remove_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:remove_policies": {}
          }
        }
      }
    },
    "tests/test_watcher_ex.py:TestWatcherEx:get_enforcer": {
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
          "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
            "casbin/core_enforcer.py:CoreEnforcer:new_model": {
              "casbin/model/model.py:Model:load_model": {
                "casbin/config/config.py:Config:new_config": {
                  "casbin/config/config.py:Config:_parse": {
                    "casbin/config/config.py:Config:_parse_buffer": {
                      "casbin/config/config.py:Config:_write": {}
                    }
                  }
                },
                "casbin/model/model.py:Model:_load_section": {
                  "casbin/model/model.py:Model:_load_assertion": {
                    "casbin/model/model.py:Model:add_def": {
                      "casbin/model/assertion.py:Assertion:__init__": {},
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__setitem__": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/util/util.py:escape_assertion": {},
                      "casbin/util/util.py:remove_comments": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "tests/test_watcher_ex.py:TestWatcherEx:test_auto_notify_enabled": {
      "tests/test_enforcer.py:get_examples": {},
      "tests/test_watcher_ex.py:TestWatcherEx:get_enforcer": {
        "casbin/core_enforcer.py:CoreEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
            "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
            "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
              "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                "casbin/model/policy.py:Policy:__init__": {},
                "casbin/model/model.py:Model:load_model": {
                  "casbin/config/config.py:Config:new_config": {
                    "casbin/config/config.py:Config:__init__": {},
                    "casbin/config/config.py:Config:_parse": {
                      "casbin/config/config.py:Config:_parse_buffer": {}
                    }
                  },
                  "casbin/model/model.py:Model:_load_section": {
                    "casbin/model/model.py:Model:_get_key_suffix": {},
                    "casbin/model/model.py:Model:_load_assertion": {
                      "casbin/config/config.py:Config:get": {},
                      "casbin/model/model.py:Model:add_def": {}
                    }
                  }
                }
              },
              "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                "casbin/model/model.py:Model:print_model": {
                  "casbin/model/policy.py:Policy:items": {}
                },
                "casbin/model/function.py:FunctionMap:load_function_map": {
                  "casbin/model/function.py:FunctionMap:__init__": {},
                  "casbin/model/function.py:FunctionMap:add_function": {}
                },
                "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/effect/__init__.py:get_effector": {},
                  "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                    "casbin/model/policy.py:Policy:keys": {}
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                  "casbin/model/policy.py:Policy:clear_policy": {
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
                      "casbin/persist/adapter.py:load_policy_line": {}
                    }
                  },
                  "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/model/model.py:Model:sort_policies_by_priority": {
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  },
                  "casbin/model/policy.py:Policy:print_policy": {
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__getitem__": {}
                  }
                }
              }
            }
          },
          "casbin/util/log.py:disabled_logging": {}
        }
      },
      "tests/test_watcher_ex.py:SampleWatcher:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:set_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:enable_auto_notify_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
        "casbin/persist/adapters/file_adapter.py:FileAdapter:save_policy": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:_save_policy_file": {}
        },
        "tests/test_watcher_ex.py:SampleWatcher:update_for_save_policy": {
          "tests/test_watcher_ex.py:SampleWatcher:update": {}
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:add_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:add_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_add_policy": {
            "casbin/model/policy.py:Policy:add_policy": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              }
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:add_policy": {},
            "tests/test_watcher_ex.py:SampleWatcher:update_for_add_policy": {
              "tests/test_watcher_ex.py:SampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_policy": {
            "casbin/model/policy.py:Policy:remove_policy": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:remove_policy": {},
            "tests/test_watcher_ex.py:SampleWatcher:update_for_remove_policy": {
              "tests/test_watcher_ex.py:SampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_filtered_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_filtered_named_policy": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_filtered_policy": {
            "casbin/model/policy.py:Policy:remove_filtered_policy": {
              "casbin/model/policy.py:Policy:keys": {},
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapter.py:Adapter:remove_filtered_policy": {},
            "tests/test_watcher_ex.py:SampleWatcher:update_for_remove_filtered_policy": {
              "tests/test_watcher_ex.py:SampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:add_policies": {
        "casbin/management_enforcer.py:ManagementEnforcer:add_named_policies": {
          "casbin/internal_enforcer.py:InternalEnforcer:_add_policies": {
            "casbin/model/policy.py:Policy:add_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:add_policies": {},
            "tests/test_watcher_ex.py:SampleWatcher:update_for_add_policies": {
              "tests/test_watcher_ex.py:SampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:remove_policies": {
        "casbin/management_enforcer.py:ManagementEnforcer:remove_named_policies": {
          "casbin/internal_enforcer.py:InternalEnforcer:_remove_policies": {
            "casbin/model/policy.py:Policy:remove_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/file_adapter.py:FileAdapter:remove_policies": {},
            "tests/test_watcher_ex.py:SampleWatcher:update_for_remove_policies": {
              "tests/test_watcher_ex.py:SampleWatcher:update": {}
            }
          }
        }
      }
    },
    "tests/test_watcher_ex.py:TestAsyncWatcherEx:test_auto_notify_disabled": {
      "tests/test_enforcer.py:get_examples": {},
      "tests/test_watcher_ex.py:TestAsyncWatcherEx:get_enforcer": {
        "casbin/core_enforcer.py:CoreEnforcer:__init__": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:init_with_file": {
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:__init__": {},
            "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
              "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                "casbin/model/policy.py:Policy:__init__": {},
                "casbin/model/model.py:Model:load_model": {
                  "casbin/config/config.py:Config:new_config": {
                    "casbin/config/config.py:Config:__init__": {},
                    "casbin/config/config.py:Config:_parse": {
                      "casbin/config/config.py:Config:_parse_buffer": {}
                    }
                  },
                  "casbin/model/model.py:Model:_load_section": {
                    "casbin/model/model.py:Model:_get_key_suffix": {},
                    "casbin/model/model.py:Model:_load_assertion": {
                      "casbin/config/config.py:Config:get": {},
                      "casbin/model/model.py:Model:add_def": {}
                    }
                  }
                }
              },
              "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:init_with_model_and_adapter": {
                "casbin/model/model.py:Model:Model": {},
                "casbin/persist/adapters/asyncio/adapter.py:AsyncAdapter:AsyncAdapter": {},
                "casbin/model/model.py:Model:print_model": {
                  "casbin/model/policy.py:Policy:items": {}
                },
                "casbin/model/function.py:FunctionMap:load_function_map": {
                  "casbin/model/function.py:FunctionMap:__init__": {},
                  "casbin/model/function.py:FunctionMap:add_function": {}
                },
                "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/effect/__init__.py:get_effector": {},
                  "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                    "casbin/model/policy.py:Policy:keys": {}
                  }
                }
              }
            }
          },
          "casbin/util/log.py:disabled_logging": {}
        }
      },
      "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:load_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:load_policy": {
          "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:_load_policy_file": {
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:build_role_links": {
          "casbin/model/policy.py:Policy:keys": {}
        }
      },
      "tests/test_watcher_ex.py:SampleWatcher:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:set_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:enable_auto_notify_watcher": {},
      "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
        "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:save_policy": {
          "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:_save_policy_file": {}
        },
        "tests/test_watcher_ex.py:SampleWatcher:update_for_save_policy": {
          "tests/test_watcher_ex.py:SampleWatcher:update": {}
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_add_policy": {
            "casbin/model/policy.py:Policy:add_policy": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              }
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:add_policy": {}
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_policy": {
            "casbin/model/policy.py:Policy:remove_policy": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_policy": {}
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_filtered_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_filtered_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_filtered_policy": {
            "casbin/model/policy.py:Policy:remove_filtered_policy": {
              "casbin/model/policy.py:Policy:keys": {},
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_filtered_policy": {}
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policies": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_named_policies": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_add_policies": {
            "casbin/model/policy.py:Policy:add_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:add_policies": {}
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policies": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_named_policies": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_policies": {
            "casbin/model/policy.py:Policy:remove_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_policies": {}
          }
        }
      }
    },
    "tests/test_watcher_ex.py:TestAsyncWatcherEx:get_enforcer": {
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:init_with_file": {
          "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
            "casbin/core_enforcer.py:CoreEnforcer:new_model": {
              "casbin/model/model.py:Model:load_model": {
                "casbin/config/config.py:Config:new_config": {
                  "casbin/config/config.py:Config:_parse": {
                    "casbin/config/config.py:Config:_parse_buffer": {
                      "casbin/config/config.py:Config:_write": {}
                    }
                  }
                },
                "casbin/model/model.py:Model:_load_section": {
                  "casbin/model/model.py:Model:_load_assertion": {
                    "casbin/model/model.py:Model:add_def": {
                      "casbin/model/assertion.py:Assertion:__init__": {},
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__setitem__": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/util/util.py:escape_assertion": {},
                      "casbin/util/util.py:remove_comments": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "tests/test_watcher_ex.py:TestAsyncWatcherEx:test_auto_notify_enabled": {
      "tests/test_enforcer.py:get_examples": {},
      "tests/test_watcher_ex.py:TestAsyncWatcherEx:get_enforcer": {
        "casbin/core_enforcer.py:CoreEnforcer:__init__": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:init_with_file": {
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:__init__": {},
            "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
              "casbin/core_enforcer.py:CoreEnforcer:new_model": {
                "casbin/model/policy.py:Policy:__init__": {},
                "casbin/model/model.py:Model:load_model": {
                  "casbin/config/config.py:Config:new_config": {
                    "casbin/config/config.py:Config:__init__": {},
                    "casbin/config/config.py:Config:_parse": {
                      "casbin/config/config.py:Config:_parse_buffer": {}
                    }
                  },
                  "casbin/model/model.py:Model:_load_section": {
                    "casbin/model/model.py:Model:_get_key_suffix": {},
                    "casbin/model/model.py:Model:_load_assertion": {
                      "casbin/config/config.py:Config:get": {},
                      "casbin/model/model.py:Model:add_def": {}
                    }
                  }
                }
              },
              "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:init_with_model_and_adapter": {
                "casbin/model/model.py:Model:print_model": {
                  "casbin/model/policy.py:Policy:items": {}
                },
                "casbin/model/function.py:FunctionMap:load_function_map": {
                  "casbin/model/function.py:FunctionMap:__init__": {},
                  "casbin/model/function.py:FunctionMap:add_function": {}
                },
                "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/effect/__init__.py:get_effector": {},
                  "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                    "casbin/model/policy.py:Policy:keys": {}
                  }
                }
              }
            }
          },
          "casbin/util/log.py:disabled_logging": {}
        }
      },
      "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:load_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:load_policy": {
          "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:_load_policy_file": {
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:build_role_links": {
          "casbin/model/policy.py:Policy:keys": {}
        }
      },
      "tests/test_watcher_ex.py:AsyncSampleWatcher:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:set_watcher": {},
      "casbin/core_enforcer.py:CoreEnforcer:enable_auto_notify_watcher": {},
      "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
        "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:save_policy": {
          "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:_save_policy_file": {}
        },
        "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_save_policy": {
          "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_add_policy": {
            "casbin/model/policy.py:Policy:add_policy": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              }
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:add_policy": {},
            "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_add_policy": {
              "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_policy": {
            "casbin/model/policy.py:Policy:remove_policy": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_policy": {},
            "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_remove_policy": {
              "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_filtered_policy": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_filtered_named_policy": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_filtered_policy": {
            "casbin/model/policy.py:Policy:remove_filtered_policy": {
              "casbin/model/policy.py:Policy:keys": {},
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_filtered_policy": {},
            "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_remove_filtered_policy": {
              "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_policies": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:add_named_policies": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_add_policies": {
            "casbin/model/policy.py:Policy:add_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:add_policies": {},
            "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_add_policies": {
              "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
            }
          }
        }
      },
      "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_policies": {
        "casbin/async_management_enforcer.py:AsyncManagementEnforcer:remove_named_policies": {
          "casbin/async_internal_enforcer.py:AsyncInternalEnforcer:_remove_policies": {
            "casbin/model/policy.py:Policy:remove_policies": {
              "casbin/model/policy.py:Policy:has_policy": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {}
              },
              "casbin/model/policy.py:Policy:__getitem__": {}
            },
            "casbin/persist/adapters/asyncio/file_adapter.py:AsyncFileAdapter:remove_policies": {},
            "tests/test_watcher_ex.py:AsyncSampleWatcher:update_for_remove_policies": {
              "tests/test_watcher_ex.py:AsyncSampleWatcher:update": {}
            }
          }
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_watcher_ex\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u251c\u2500\u2500 async_internal_enforcer.py\n    \u2502   \u251c\u2500\u2500 AsyncInternalEnforcer.load_policy\n    \u2502   \u2514\u2500\u2500 AsyncInternalEnforcer.save_policy\n    \u251c\u2500\u2500 async_management_enforcer.py\n    \u2502   \u251c\u2500\u2500 AsyncManagementEnforcer.add_policies\n    \u2502   \u251c\u2500\u2500 AsyncManagementEnforcer.add_policy\n    \u2502   \u251c\u2500\u2500 AsyncManagementEnforcer.remove_filtered_policy\n    \u2502   \u251c\u2500\u2500 AsyncManagementEnforcer.remove_policies\n    \u2502   \u2514\u2500\u2500 AsyncManagementEnforcer.remove_policy\n    \u251c\u2500\u2500 core_enforcer.py\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.__init__\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.enable_auto_notify_watcher\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.save_policy\n    \u2502   \u2514\u2500\u2500 CoreEnforcer.set_watcher\n    \u2514\u2500\u2500 management_enforcer.py\n        \u251c\u2500\u2500 ManagementEnforcer.add_policies\n        \u251c\u2500\u2500 ManagementEnforcer.add_policy\n        \u251c\u2500\u2500 ManagementEnforcer.remove_filtered_policy\n        \u251c\u2500\u2500 ManagementEnforcer.remove_policies\n        \u2514\u2500\u2500 ManagementEnforcer.remove_policy\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates real-time policy updates within the Casbin access control framework by providing watcher implementations that notify enforcers about policy changes. It includes both synchronous (`SampleWatcher`) and asynchronous (`AsyncSampleWatcher`) variants, enabling seamless integration with synchronous and asynchronous environments. Core functionalities include tracking and triggering updates for policy additions, removals, and modifications, ensuring consistency across distributed systems where policy synchronization is critical. By allowing developers to set custom update callbacks and enabling automatic notifications between policy enforcers, the module streamlines policy management, reduces manual synchronization overhead, and ensures robust, dynamic access control in complex architectures.\n\n## FILE 1: casbin/async_management_enforcer.py\n\n## FILE 2: casbin/management_enforcer.py\n\n- CLASS METHOD: ManagementEnforcer.add_policy\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def add_policy(self, *params):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds an authorization rule to the current policy.\n\nThis method calls `add_named_policy` with the policy type `\"p\"`, appending the specified parameters as the new rule. If the rule already exists in the policy, it will return `False` without adding it; otherwise, it returns `True` upon successful addition. This method is intended to manage the add operation for authorization rules and integrates directly with the underlying policy management defined in the parent class.\n\nParameters:\n- *params: Variable length arguments representing the new authorization rule to be added.\n\nReturns:\n- bool: `True` if the rule was successfully added; `False` if the rule already exists.\n\nDependencies:\n- `add_named_policy`: This method is crucial for the actual addition of the policy rule and is part of the ManagementEnforcer class.\n- The constant `\"p\"` refers to the default policy type for permissions and is a fundamental part of the Casbin policy model design.\n\"\"\"\n```\n\n- CLASS METHOD: ManagementEnforcer.remove_policies\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def remove_policies(self, rules):\n  - DOCSTRING: \n```python\n\"\"\"\nremoves authorization rules from the current policy.\n\nParameters:\n- rules (list): A list of authorization rules to be removed from the current policy.\n\nReturns:\n- bool: Returns true if all specified rules were successfully removed; otherwise, returns false for the corresponding rule that could not be removed.\n\nThe method interacts with the `remove_named_policies` method, which specifically handles the removal of rules from the \"p\" (policy) type. The constant \"p\" is used to denote this policy type consistently across the class, ensuring that rules related to permissions are correctly targeted during removal.\n\"\"\"\n```\n\n- CLASS METHOD: ManagementEnforcer.remove_filtered_policy\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def remove_filtered_policy(self, field_index, *field_values):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves an authorization rule from the current policy with the option to specify field filters. This method utilizes the `remove_filtered_named_policy` method to target specific policies based on the provided field index and values.\n\nParameters:\n- field_index (int): The index of the field in the policy for filtering the rules to be removed.\n- *field_values: The values corresponding to the filtered field index. These specify which rules to remove from the policy.\n\nReturns:\n- bool: Returns true if the rule was successfully removed, false otherwise.\n\nThis method interacts with the named policy \"p\" (standard policy type) defined in the context of the ManagementEnforcer class, facilitating finer control over policy management by allowing selective removal based on given criteria.\n\"\"\"\n```\n\n- CLASS METHOD: ManagementEnforcer.add_policies\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def add_policies(self, rules):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds multiple authorization rules to the current policy.\n\nThis method leverages the `add_named_policies` function with the policy type set to 'p'. Each rule is tested for existence; if a rule already exists, it will not be added, and the function will return false for that specific rule. Conversely, new rules will be successfully added, returning true.\n\nParameters:\n- rules (list): A list of authorization rules that are to be added to the current policy.\n\nReturns:\n- list: A list indicating the success (true) or failure (false) status for each rule added, corresponding to the input rules.\n\nDependencies:\n- This method interacts with the `add_named_policies` method which is defined in the same class, ManagementEnforcer. It relies on the 'p' policy type, which defines the access control rules in the context of the Enforcer's model.\n\"\"\"\n```\n\n- CLASS METHOD: ManagementEnforcer.remove_policy\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def remove_policy(self, *params):\n  - DOCSTRING: \n```python\n\"\"\"\nRemoves an authorization rule from the current policy.\n\nParameters:\n*params: The parameters that specify the authorization rule to remove. The parameters can be provided as individual arguments or as a single list.\n\nReturns:\nbool: True if the rule was successfully removed, False if the rule did not exist.\n\nThis method relies on the `remove_named_policy` function, specifically targeting the policy type `\"p\"` which represents the main policy rules. It interacts with the underlying policy management functions to ensure the specified rule is correctly removed from the stored policies.\n\"\"\"\n```\n\n## FILE 3: casbin/core_enforcer.py\n\n- CLASS METHOD: CoreEnforcer.__init__\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def __init__(self, model=None, adapter=None, enable_log=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a CoreEnforcer instance which defines the core functionality of an access control enforcer in the Casbin framework. It can be initialized with different configurations including model files, adapters, and logging options.\n\nParameters:\n- model (Union[str, Model], optional): The model file path or a Model object that defines the access control model.\n- adapter (Union[str, Adapter], optional): The policy adapter file path or an Adapter object for policy persistence.\n- enable_log (bool, optional): Enables logging if set to True; defaults to False.\n\nRaises:\n- RuntimeError: If the parameters are invalid, particularly when model or adapter types do not match the expected formats.\n\nThis initializer reads model and policy configurations and sets up logging based on the provided parameters. It also interacts with various methods such as `init_with_file`, `init_with_adapter`, and `init_with_model_and_adapter` to set up the enforcer according to the given configurations.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.save_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def save_policy(self):\n  - DOCSTRING: \n```python\n\"\"\"\nSaves the current policy to the adapter, persisting any changes made to the policy model.\n\nThis method checks whether the policy is filtered by calling `is_filtered()`. If it is, a RuntimeError is raised since filtered policies cannot be saved. If not filtered, the current model's policy is saved through the methods defined in the `adapter`, which can be any implementation of the `Adapter` interface (e.g., `FileAdapter`).\n\nIf a watcher is set (indicated by `self.watcher`), and if it has an `update_for_save_policy` method, that method is called to notify the watcher of the saved policy. If the method is not defined, the generic `update` method is called instead.\n\nParameters:\n    None\n\nReturns:\n    None\n\nRaises:\n    RuntimeError: If the currently loaded policy is a filtered policy.\n    \nAttributes Used:\n    - `self.adapter`: The adapter responsible for saving the policy, which must implement the `save_policy` method.\n    - `self.watcher`: An optional watcher that can be notified of changes to the policy.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.set_watcher\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def set_watcher(self, watcher):\n  - DOCSTRING: \n```python\n\"\"\"\nsets the current watcher for the CoreEnforcer.\n\nParameters:\n    watcher: An object or function that implements a watching mechanism to receive notifications on policy changes. The specific implementation details of the watcher are not enforced within this method.\n\nThis method stores the provided watcher in the `self.watcher` attribute, allowing the CoreEnforcer to utilize it for automatic notifications related to policy changes. The interactions between the watcher and the CoreEnforcer facilitate dynamic response mechanisms upon policy updates, depending on how the watcher is implemented.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.enable_auto_notify_watcher\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def enable_auto_notify_watcher(self, auto_notify_watcher):\n  - DOCSTRING: \n```python\n\"\"\"\nControls whether to automatically notify the watcher when a policy rule is added or removed.\n\nThis method sets the `auto_notify_watcher` attribute of the `CoreEnforcer` class. If `auto_notify_watcher` is set to `True`, any changes to policies will trigger an update notification to the watcher. This is useful for synchronizing changes across distributed systems or components that rely on the current state of policies.\n\nParameters:\n    auto_notify_watcher (bool): A flag to enable or disable automatic notifications to the watcher when policy changes occur.\n\nReturns:\n    None\n\nSide Effects:\n    Modifies the state of the `auto_notify_watcher` attribute within the `CoreEnforcer` instance. It does not return any values.\n\nAttributes:\n    auto_notify_watcher (bool): Controls the notification behavior to the watcher. Defined and initialized in the `CoreEnforcer` class.\n\"\"\"\n```\n\n## FILE 4: casbin/async_internal_enforcer.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/async_management_enforcer.py": "from casbin.async_internal_enforcer import AsyncInternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\n\nclass AsyncManagementEnforcer(AsyncInternalEnforcer):\n    \"\"\"\n    AsyncManagementEnforcer = AsyncInternalEnforcer + AsyncManagement API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects('p')\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('p', ptype, 0)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects('p')\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('p', ptype, 1)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions('p')\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('p', ptype, 2)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles('g')\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('g', ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy('p')\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy('p', field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy('p', ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('p', ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy('g')\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy('g', ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('g', ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        return self.has_named_policy('p', *params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('p', ptype, str_slice)\n        return self.model.has_policy('p', ptype, list(params))\n\n    async def add_named_policy(self, ptype, *params):\n        \"\"\"async adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = await self._add_policy('p', ptype, str_slice)\n        else:\n            rule_added = await self._add_policy('p', ptype, list(params))\n        return rule_added\n\n    async def add_named_policies(self, ptype, rules):\n        \"\"\"async adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding by adding the new rule.\n        \"\"\"\n        return await self._add_policies('p', ptype, rules)\n\n    async def update_policy(self, old_rule, new_rule):\n        \"\"\"async updates an authorization rule from the current policy.\"\"\"\n        return await self.update_named_policy('p', old_rule, new_rule)\n\n    async def update_policies(self, old_rules, new_rules):\n        \"\"\"async updates authorization rules from the current policy.\"\"\"\n        return await self.update_named_policies('p', old_rules, new_rules)\n\n    async def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"async updates an authorization rule from the current named policy.\"\"\"\n        return await self._update_policy('p', ptype, old_rule, new_rule)\n\n    async def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"async updates authorization rules from the current named policy.\"\"\"\n        return await self._update_policies('p', ptype, old_rules, new_rules)\n\n    async def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"async update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return await self.update_filtered_named_policies('p', new_rules, field_index, *field_values)\n\n    async def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"async update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return await self._update_filtered_policies('p', ptype, new_rules, field_index, *field_values)\n\n    async def remove_named_policy(self, ptype, *params):\n        \"\"\"async removes an authorization rule from the current named policy.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = await self._remove_policy('p', ptype, str_slice)\n        else:\n            rule_removed = await self._remove_policy('p', ptype, list(params))\n        return rule_removed\n\n    async def remove_named_policies(self, ptype, rules):\n        \"\"\"async removes authorization rules from the current named policy.\"\"\"\n        return await self._remove_policies('p', ptype, rules)\n\n    async def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"async removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return await self._remove_filtered_policy('p', ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n        return self.has_named_grouping_policy('g', *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('g', ptype, str_slice)\n        return self.model.has_policy('g', ptype, list(params))\n\n    async def add_grouping_policy(self, *params):\n        \"\"\"async adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n        return await self.add_named_grouping_policy('g', *params)\n\n    async def add_grouping_policies(self, rules):\n        \"\"\"async adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return await self.add_named_grouping_policies('g', rules)\n\n    async def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"async adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise, the function returns true by adding the new rule.\n        \"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = await self._add_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = await self._add_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rule_added\n\n    async def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"async adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise, the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        rules_added = await self._add_policies('g', ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rules_added\n\n    async def remove_grouping_policy(self, *params):\n        \"\"\"async removes a role inheritance rule from the current policy.\"\"\"\n        return await self.remove_named_grouping_policy('g', *params)\n\n    async def remove_grouping_policies(self, rules):\n        \"\"\"async removes role inheritance rules from the current policy.\"\"\"\n        return await self.remove_named_grouping_policies('g', rules)\n\n    async def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"async removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return await self.remove_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    async def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"async removes a role inheritance rule from the current named policy.\"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = await self._remove_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = await self._remove_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rule_removed\n\n    async def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"async removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = await self._remove_policies('g', ptype, rules)\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rules_removed\n\n    async def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"async removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = await self._remove_filtered_policy_returns_effects('g', ptype, field_index, *field_values)\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rule_removed)\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)",
    "casbin/management_enforcer.py": "from casbin.internal_enforcer import InternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\nfrom casbin.constant.constants import ACTION_INDEX, SUBJECT_INDEX, OBJECT_INDEX\n\nclass ManagementEnforcer(InternalEnforcer):\n    \"\"\"\n    ManagementEnforcer = InternalEnforcer + Management API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects('p')\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, SUBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects('p')\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, OBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions('p')\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, ACTION_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles('g')\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('g', ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy('p')\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy('p', field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy('p', ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('p', ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy('g')\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy('g', ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('g', ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        return self.has_named_policy('p', *params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('p', ptype, str_slice)\n        return self.model.has_policy('p', ptype, list(params))\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy('p', ptype, str_slice)\n        else:\n            rule_added = self._add_policy('p', ptype, list(params))\n        return rule_added\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        return self._add_policies('p', ptype, rules)\n\n    def update_policy(self, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current policy.\"\"\"\n        return self.update_named_policy('p', old_rule, new_rule)\n\n    def update_policies(self, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current policy.\"\"\"\n        return self.update_named_policies('p', old_rules, new_rules)\n\n    def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current named policy.\"\"\"\n        return self._update_policy('p', ptype, old_rule, new_rule)\n\n    def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current named policy.\"\"\"\n        return self._update_policies('p', ptype, old_rules, new_rules)\n\n    def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return self.update_filtered_named_policies('p', new_rules, field_index, *field_values)\n\n    def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return self._update_filtered_policies('p', ptype, new_rules, field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy('p', ptype, str_slice)\n        else:\n            rule_removed = self._remove_policy('p', ptype, list(params))\n        return rule_removed\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        return self._remove_policies('p', ptype, rules)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return self._remove_filtered_policy('p', ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n        return self.has_named_grouping_policy('g', *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('g', ptype, str_slice)\n        return self.model.has_policy('g', ptype, list(params))\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policy('g', *params)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policies('g', rules)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = self._add_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n            if ptype in self.cond_rm_map:\n                self.model.build_incremental_conditional_role_links(self.cond_rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rule_added\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        rules_added = self._add_policies('g', ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rules_added\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        return self.remove_named_grouping_policy('g', *params)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        return self.remove_named_grouping_policies('g', rules)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = self._remove_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rule_removed\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = self._remove_policies('g', ptype, rules)\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rules_removed\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = self._remove_filtered_policy_returns_effects('g', ptype, field_index, *field_values)\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rule_removed)\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)",
    "casbin/core_enforcer.py": "import copy\nimport logging\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n    model_path = ''\n    model = None\n    fm = None\n    eft = None\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n        if not isinstance(m, Model) or (adapter is not None and (not isinstance(adapter, Adapter))):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        self.adapter = adapter\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n        self._initialize()\n        if self.adapter and (not self.is_filtered()):\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model['e']['e'].value)\n        self.watcher = None\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path='', text=''):\n        \"\"\"creates a model.\"\"\"\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        return self.model\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n        return self.adapter\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n        self.adapter = adapter\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map['g']\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError('ptype not found')\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map['g'] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n        self.model.clear_policy()\n\n    def init_rm_map(self):\n        if 'g' in self.model.keys():\n            for ptype in self.model['g']:\n                assertion = self.model['g'][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n        try:\n            self.adapter.load_policy(new_model)\n            new_model.sort_policies_by_subject_hierarchy()\n            new_model.sort_policies_by_priority()\n            new_model.print_policy()\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n            self.model = new_model\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n            raise e\n\n    def load_filtered_policy(self, filter):\n        \"\"\"reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.sort_policies_by_priority()\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        return hasattr(self.adapter, 'is_filtered') and self.adapter.is_filtered()\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        for rm in self.rm_map.values():\n            rm.clear()\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(rtype='r' + suffix, ptype='p' + suffix, etype='e' + suffix, mtype='m' + suffix)\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        rtype = 'r'\n        ptype = 'p'\n        etype = 'e'\n        mtype = 'm'\n        if not self.enabled:\n            return [True, []]\n        functions = self.fm.get_functions()\n        if 'g' in self.model.keys():\n            for key, ast in self.model['g'].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n        if 'm' not in self.model.keys():\n            raise RuntimeError('model is undefined')\n        if 'm' not in self.model['m'].keys():\n            raise RuntimeError('model is undefined')\n        r_tokens = self.model['r'][rtype].tokens\n        p_tokens = self.model['p'][ptype].tokens\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError('invalid request size')\n        exp_string = self.model['m'][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n        policy_effects = set()\n        r_parameters = dict(zip(r_tokens, rvals))\n        policy_len = len(self.model['p'][ptype].policy)\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model['p'][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError('invalid policy size')\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n                result = expression.eval(parameters)\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError('matcher result should be bool, int or float')\n                p_eft_key = ptype + '_eft'\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if 'allow' == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif 'deny' == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n        else:\n            if exp_has_eval:\n                raise RuntimeError('please make sure rule exists in policy when using eval() in matcher')\n            parameters = r_parameters.copy()\n            for token in self.model['p'][ptype].tokens:\n                parameters[token] = ''\n            result = expression.eval(parameters)\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n        req_str = 'Request: '\n        req_str = req_str + ', '.join([str(v) for v in rvals])\n        req_str = req_str + ' ---> %s' % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            self.logger.warning(req_str)\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model['p'][ptype].policy[explain_index]\n        return (result, explain_rule)\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace('&&', 'and')\n        expr = expr.replace('||', 'or')\n        expr = expr.replace('!', 'not')\n        return SimpleEval(expr, functions)",
    "casbin/async_internal_enforcer.py": "import copy\nimport inspect\nfrom casbin.core_enforcer import CoreEnforcer\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist.adapters.asyncio import AsyncFileAdapter, AsyncAdapter\n\nclass AsyncInternalEnforcer(CoreEnforcer):\n    \"\"\"\n    AsyncInternalEnforcer = CoreEnforcer + Async Internal API.\n    \"\"\"\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = AsyncFileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n        if not isinstance(m, Model) or (adapter is not None and (not isinstance(adapter, AsyncAdapter))):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        self.adapter = adapter\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n        self._initialize()\n\n    async def load_filtered_policy(self, filter):\n        \"\"\"async reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        await self.adapter.load_filtered_policy(self.model, filter)\n        self.model.sort_policies_by_priority()\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    async def load_increment_filtered_policy(self, filter):\n        \"\"\"async append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    async def _add_policy(self, sec, ptype, rule):\n        \"\"\"async adds a rule to the current policy.\"\"\"\n        rule_added = self.model.add_policy(sec, ptype, rule)\n        if not rule_added:\n            return rule_added\n        if self.adapter and self.auto_save:\n            result = await self.adapter.add_policy(sec, ptype, rule)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                update_for_add_policy = getattr(self.watcher, 'update_for_add_policy', None)\n                if callable(update_for_add_policy):\n                    if inspect.iscoroutinefunction(update_for_add_policy):\n                        await update_for_add_policy(sec, ptype, rule)\n                    else:\n                        update_for_add_policy(sec, ptype, rule)\n                else:\n                    self.watcher.update()\n        return rule_added\n\n    async def _add_policies(self, sec, ptype, rules):\n        \"\"\"async adds rules to the current policy.\"\"\"\n        rules_added = self.model.add_policies(sec, ptype, rules)\n        if not rules_added:\n            return rules_added\n        if self.adapter and self.auto_save:\n            if hasattr(self.adapter, 'add_policies') is False:\n                return False\n            result = await self.adapter.add_policies(sec, ptype, rules)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                update_for_add_policies = getattr(self.watcher, 'update_for_add_policies', None)\n                if callable(update_for_add_policies):\n                    if inspect.iscoroutinefunction(update_for_add_policies):\n                        await update_for_add_policies(sec, ptype, rules)\n                    else:\n                        update_for_add_policies(sec, ptype, rules)\n                else:\n                    self.watcher.update()\n        return rules_added\n\n    async def _update_policy(self, sec, ptype, old_rule, new_rule):\n        \"\"\"async updates a rule from the current policy.\"\"\"\n        rule_updated = self.model.update_policy(sec, ptype, old_rule, new_rule)\n        if not rule_updated:\n            return rule_updated\n        if self.adapter and self.auto_save:\n            result = await self.adapter.update_policy(sec, ptype, old_rule, new_rule)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n        return rule_updated\n\n    async def _update_policies(self, sec, ptype, old_rules, new_rules):\n        \"\"\"async updates rules from the current policy.\"\"\"\n        rules_updated = self.model.update_policies(sec, ptype, old_rules, new_rules)\n        if not rules_updated:\n            return rules_updated\n        if self.adapter and self.auto_save:\n            result = await self.adapter.update_policies(sec, ptype, old_rules, new_rules)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n        return rules_updated\n\n    async def _update_filtered_policies(self, sec, ptype, new_rules, field_index, *field_values):\n        \"\"\"async deletes old rules and adds new rules.\"\"\"\n        old_rules = self.model.get_filtered_policy(sec, ptype, field_index, *field_values)\n        if self.adapter and self.auto_save:\n            try:\n                old_rules = await self.adapter.update_filtered_policies(sec, ptype, new_rules, field_index, *field_values)\n            except:\n                pass\n        if not old_rules:\n            return False\n        is_rule_changed = self.model.remove_policies(sec, ptype, old_rules)\n        self.model.add_policies(sec, ptype, new_rules)\n        is_rule_changed = is_rule_changed and len(new_rules) != 0\n        if not is_rule_changed:\n            return is_rule_changed\n        if sec == 'g':\n            self.build_role_links()\n        if self.watcher and self.auto_notify_watcher:\n            self.watcher.update()\n        return is_rule_changed\n\n    async def _remove_policy(self, sec, ptype, rule):\n        \"\"\"async removes a rule from the current policy.\"\"\"\n        rule_removed = self.model.remove_policy(sec, ptype, rule)\n        if not rule_removed:\n            return rule_removed\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_policy(sec, ptype, rule)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_policy = getattr(self.watcher, 'update_for_remove_policy', None)\n                if callable(update_for_remove_policy):\n                    if inspect.iscoroutinefunction(update_for_remove_policy):\n                        await update_for_remove_policy(sec, ptype, rule)\n                    else:\n                        update_for_remove_policy(sec, ptype, rule)\n                else:\n                    self.watcher.update()\n        return rule_removed\n\n    async def _remove_policies(self, sec, ptype, rules):\n        \"\"\"async RemovePolicies removes policy rules from the model.\"\"\"\n        rules_removed = self.model.remove_policies(sec, ptype, rules)\n        if not rules_removed:\n            return rules_removed\n        if self.adapter and self.auto_save:\n            if hasattr(self.adapter, 'remove_policies') is False:\n                return False\n            result = await self.adapter.remove_policies(sec, ptype, rules)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_policies = getattr(self.watcher, 'update_for_remove_policies', None)\n                if callable(update_for_remove_policies):\n                    if inspect.iscoroutinefunction(update_for_remove_policies):\n                        await update_for_remove_policies(sec, ptype, rules)\n                    else:\n                        update_for_remove_policies(sec, ptype, rules)\n                else:\n                    self.watcher.update()\n        return rules_removed\n\n    async def _remove_filtered_policy(self, sec, ptype, field_index, *field_values):\n        \"\"\"async removes rules based on field filters from the current policy.\"\"\"\n        rule_removed = self.model.remove_filtered_policy(sec, ptype, field_index, *field_values)\n        if not rule_removed:\n            return rule_removed\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_filtered_policy(sec, ptype, field_index, *field_values)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                update_for_remove_filtered_policy = getattr(self.watcher, 'update_for_remove_filtered_policy', None)\n                if callable(update_for_remove_filtered_policy):\n                    if inspect.iscoroutinefunction(update_for_remove_filtered_policy):\n                        await update_for_remove_filtered_policy(sec, ptype, field_index, *field_values)\n                    else:\n                        update_for_remove_filtered_policy(sec, ptype, field_index, *field_values)\n                else:\n                    self.watcher.update()\n        return rule_removed\n\n    async def _remove_filtered_policy_returns_effects(self, sec, ptype, field_index, *field_values):\n        \"\"\"async removes rules based on field filters from the current policy.\"\"\"\n        rule_removed = self.model.remove_filtered_policy_returns_effects(sec, ptype, field_index, *field_values)\n        if len(rule_removed) == 0:\n            return rule_removed\n        if self.adapter and self.auto_save:\n            result = await self.adapter.remove_filtered_policy(sec, ptype, field_index, *field_values)\n            if result is False:\n                return False\n            if self.watcher and self.auto_notify_watcher:\n                self.watcher.update()\n        return rule_removed\n\n    async def get_field_index(self, ptype, field):\n        \"\"\"gets the index of the field name.\"\"\"\n        return self.model.get_field_index(ptype, field)\n\n    async def set_field_index(self, ptype, field, index):\n        \"\"\"sets the index of the field name.\"\"\"\n        assertion = self.model['p'][ptype]\n        assertion.field_index_map[field] = index"
  }
}