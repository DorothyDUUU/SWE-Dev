{
  "dir_path": "/app/datashader",
  "package_name": "datashader",
  "sample_name": "datashader-test_macros",
  "src_dir": "datashader/",
  "test_dir": "datashader/tests/",
  "test_file": "datashader/tests/test_macros.py",
  "test_code": "from __future__ import annotations\nimport warnings\nimport pytest\n\nfrom datashader.macros import expand_varargs\nimport inspect\nfrom numba import jit\n\n\n# Example functions to test expand_varargs on\ndef function_no_vararg(a, b):\n    return a + b\n\n\ndef function_with_vararg(a, b, *others):\n    return a + b - function_no_vararg(*others)\n\n\ndef function_with_unsupported_vararg_use(a, b, *others):\n    print(others[0])\n    function_with_vararg(a, b, *others)\n\n\n@jit(nopython=True, nogil=True)\ndef function_no_vararg_numba(a, b):\n    return a + b\n\n\ndef function_with_vararg_call_numba(a, b, *others):\n    return a + b - function_no_vararg_numba(*others)\n\n\n# Help functions\ndef get_args(fn):\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        spec = inspect.getfullargspec(fn)\n\n    args = spec.args\n    if spec.varargs:\n        args += ['*' + spec.varargs]\n\n    return args\n\n\n# Tests\ndef test_expand_varargs():\n    assert get_args(function_with_vararg) == ['a', 'b', '*others']\n    function_with_vararg_expanded = expand_varargs(2)(function_with_vararg)\n    assert get_args(function_with_vararg_expanded) == ['a', 'b', '_0', '_1']\n\n    assert (function_with_vararg(1, 2, 3, 4) ==\n            function_with_vararg_expanded(1, 2, 3, 4))\n\n\ndef test_invalid_expand_number():\n    with pytest.raises(ValueError) as e:\n        # User forgets to construct decorator with expand_number\n        expand_varargs(function_no_vararg)\n\n    assert e.match(r\"non\\-negative integer\")\n\n\ndef test_no_varargs_error():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_no_vararg)\n\n    assert e.match(r\"does not have a variable length positional argument\")\n\n\ndef test_unsupported_vararg_use():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_with_unsupported_vararg_use)\n\n    assert e.match(r\"unsupported context\")\n\n\ndef test_numba_jit_expanded_function():\n    jit_fn = jit(nopython=True, nogil=True)(\n        expand_varargs(2)(function_with_vararg_call_numba)\n    )\n    assert function_with_vararg_call_numba(1, 2, 3, 4) == jit_fn(1, 2, 3, 4)\n",
  "GT_file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()\n\n    def visit_Name(self, node):\n        self.names.add(node.id)\n\n    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)\n\n    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile(r\"^_(\\d+)$\")\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n\n        return [\"_\" + str(n) for n in\n                range(start_number, start_number + num_names)]\n\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names\n\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n    # Python 3\n    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in\n                    self.expand_names]\n        else:\n            return node\n\n\ndef function_to_ast(fn):\n    \"\"\"\n    Get the AST representation of a function\n    \"\"\"\n    # Get source code for function\n    # Dedent is needed if this is a nested function\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n\n    # Parse function source code into an AST\n    fn_ast = ast.parse(fn_source)\n\n    # # The function will be the fist element of the module body\n    # fn_ast = module_ast.body[0]\n\n    return fn_ast\n\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)\n\n\ndef compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, \"<%s>\" % fndef_ast.name, mode='exec')\n\n\ndef function_ast_to_function(fn_ast, stacklevel=1):\n    # Validate\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Compile AST to code object\n    code = compile_function_ast(fn_ast)\n\n    # Evaluate the function in a scope that includes the globals and\n    # locals of desired frame.\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n\n    # Evaluate function in scope\n    eval(code, scope)\n\n    # Return the newly evaluated function from the scope\n    return scope[fndef_ast.name]\n\n\ndef _build_arg(name):\n    return ast.arg(arg=name)\n\n\ndef expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"\n    Given a function AST that use a variable length positional argument\n    (e.g. *args), return a function that replaces the use of this argument\n    with one or more fixed arguments.\n\n    To be supported, a function must have a starred argument in the function\n    signature, and it may only use this argument in starred form as the\n    input to other functions.\n\n    For example, suppose expand_number is 3 and fn_ast is an AST\n    representing this function...\n\n    def my_fn1(a, b, *args):\n        print(a, b)\n        other_fn(a, b, *args)\n\n    Then this function will return the AST of a function equivalent to...\n\n    def my_fn1(a, b, _0, _1, _2):\n        print(a, b)\n        other_fn(a, b, _0, _1, _2)\n\n    If the input function uses `args` for anything other than passing it to\n    other functions in starred form, an error will be raised.\n\n    Parameters\n    ----------\n    fn_ast: ast.FunctionDef\n    expand_number: int\n\n    Returns\n    -------\n    ast.FunctionDef\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n\n    # Copy ast so we don't modify the input\n    fn_ast = copy.deepcopy(fn_ast)\n\n    # Extract function definition\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Get function args\n    fn_args = fndef_ast.args\n\n    # Function variable arity argument\n    fn_vararg = fn_args.vararg\n\n    # Require vararg\n    if not fn_vararg:\n        raise ValueError(\"\"\"\\\nInput function AST does not have a variable length positional argument\n(e.g. *args) in the function signature\"\"\")\n    assert fn_vararg\n\n    # Get vararg name\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n\n    # Compute new unique names to use in place of the variable argument\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n\n    # Replace use of *args in function body\n    expand_transformer = ExpandVarargTransformerStarred\n\n    new_fn_ast = expand_transformer(\n        vararg_name, expand_names\n    ).visit(fn_ast)\n\n    new_fndef_ast = new_fn_ast.body[0]\n\n    # Replace vararg with additional args in function signature\n    new_fndef_ast.args.args.extend(\n        [_build_arg(name=name) for name in expand_names]\n    )\n    new_fndef_ast.args.vararg = None\n\n    # Run a new NameVistor an see if there were any other non-starred uses\n    # of the variable length argument. If so, raise an exception\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError(\"\"\"\\\nThe variable length positional argument {n} is used in an unsupported context\n\"\"\".format(n=vararg_name))\n\n    # Remove decorators if present to avoid recursion\n    fndef_ast.decorator_list = []\n\n    # Add missing source code locations\n    ast.fix_missing_locations(new_fn_ast)\n\n    # Return result\n    return new_fn_ast\n\n\ndef expand_varargs(expand_number):\n    \"\"\"\n    Decorator to expand the variable length (starred) argument in a function\n    signature with a fixed number of arguments.\n\n    Parameters\n    ----------\n    expand_number: int\n        The number of fixed arguments that should replace the variable length\n        argument\n\n    Returns\n    -------\n    function\n        Decorator Function\n    \"\"\"\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError(\"expand_number must be a non-negative integer\")\n\n    def _expand_varargs(fn):\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs\n"
  },
  "GT_src_dict": {
    "datashader/macros.py": {
      "expand_varargs": {
        "code": "def expand_varargs(expand_number):\n    \"\"\"Decorator that expands a variable-length positional argument (*args) in a function's signature \nto a fixed number of individual parameters.\n\nParameters\n----------\nexpand_number: int\n    The number of fixed arguments that should replace the variable-length \n    argument. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that modifies the target function to use \n    a fixed number of arguments instead of the starred variable-length \n    argument.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nThis decorator relies on the following utility functions:\n- function_to_ast(fn): Converts the function to an Abstract Syntax Tree (AST).\n- expand_function_ast_varargs(fn_ast, expand_number): Transforms the function AST by \n  replacing the variable-length argument with fixed arguments.\n- function_ast_to_function(fn_ast, stacklevel): Compiles the modified AST back into \n  a callable function.\n\nThe decorator modifies the function's AST structure and thus can \nlead to errors if the variable-length argument is used in any \nunfitting context within the function body.\"\"\"\n    '\\n    Decorator to expand the variable length (starred) argument in a function\\n    signature with a fixed number of arguments.\\n\\n    Parameters\\n    ----------\\n    expand_number: int\\n        The number of fixed arguments that should replace the variable length\\n        argument\\n\\n    Returns\\n    -------\\n    function\\n        Decorator Function\\n    '\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError('expand_number must be a non-negative integer')\n\n    def _expand_varargs(fn):\n        \"\"\"Expand the variable-length positional argument in a function's signature to a specified number of fixed positional arguments.\n\nParameters\n----------\nfn: function\n    The function that will have its variable-length arguments expanded. It must\n    contain a starred argument in its signature.\n\nReturns\n-------\nfunction\n    A new function with a modified signature, replacing the starred argument\n    with a specified number of fixed arguments.\n\nDependencies\n------------\nThis function relies on several other functions:\n- `function_to_ast(fn)`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Takes the function's AST and the number of fixed arguments to generate a new AST with expanded arguments.\n- `function_ast_to_function(fn_ast, stacklevel=2)`: Converts the modified AST back into a function object for use.\n\nNotes\n-----\nThe `expand_number` constant, defined at a higher scope as the argument given to the decorator, specifies how many fixed arguments to replace the variable-length argument.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs",
        "docstring": "Decorator that expands a variable-length positional argument (*args) in a function's signature \nto a fixed number of individual parameters.\n\nParameters\n----------\nexpand_number: int\n    The number of fixed arguments that should replace the variable-length \n    argument. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that modifies the target function to use \n    a fixed number of arguments instead of the starred variable-length \n    argument.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nThis decorator relies on the following utility functions:\n- function_to_ast(fn): Converts the function to an Abstract Syntax Tree (AST).\n- expand_function_ast_varargs(fn_ast, expand_number): Transforms the function AST by \n  replacing the variable-length argument with fixed arguments.\n- function_ast_to_function(fn_ast, stacklevel): Compiles the modified AST back into \n  a callable function.\n\nThe decorator modifies the function's AST structure and thus can \nlead to errors if the variable-length argument is used in any \nunfitting context within the function body.",
        "signature": "def expand_varargs(expand_number):",
        "type": "Function",
        "class_signature": null
      },
      "_expand_varargs": {
        "code": "    def _expand_varargs(fn):\n        \"\"\"Expand the variable-length positional argument in a function's signature to a specified number of fixed positional arguments.\n\nParameters\n----------\nfn: function\n    The function that will have its variable-length arguments expanded. It must\n    contain a starred argument in its signature.\n\nReturns\n-------\nfunction\n    A new function with a modified signature, replacing the starred argument\n    with a specified number of fixed arguments.\n\nDependencies\n------------\nThis function relies on several other functions:\n- `function_to_ast(fn)`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Takes the function's AST and the number of fixed arguments to generate a new AST with expanded arguments.\n- `function_ast_to_function(fn_ast, stacklevel=2)`: Converts the modified AST back into a function object for use.\n\nNotes\n-----\nThe `expand_number` constant, defined at a higher scope as the argument given to the decorator, specifies how many fixed arguments to replace the variable-length argument.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)",
        "docstring": "Expand the variable-length positional argument in a function's signature to a specified number of fixed positional arguments.\n\nParameters\n----------\nfn: function\n    The function that will have its variable-length arguments expanded. It must\n    contain a starred argument in its signature.\n\nReturns\n-------\nfunction\n    A new function with a modified signature, replacing the starred argument\n    with a specified number of fixed arguments.\n\nDependencies\n------------\nThis function relies on several other functions:\n- `function_to_ast(fn)`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Takes the function's AST and the number of fixed arguments to generate a new AST with expanded arguments.\n- `function_ast_to_function(fn_ast, stacklevel=2)`: Converts the modified AST back into a function object for use.\n\nNotes\n-----\nThe `expand_number` constant, defined at a higher scope as the argument given to the decorator, specifies how many fixed arguments to replace the variable-length argument.",
        "signature": "def _expand_varargs(fn):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "datashader/macros.py:_expand_varargs": {
      "datashader/macros.py": {
        "function_to_ast": {
          "code": "def function_to_ast(fn):\n    \"\"\"\n    Get the AST representation of a function\n    \"\"\"\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n    fn_ast = ast.parse(fn_source)\n    return fn_ast",
          "docstring": "Get the AST representation of a function",
          "signature": "def function_to_ast(fn):",
          "type": "Function",
          "class_signature": null
        },
        "function_ast_to_function": {
          "code": "def function_ast_to_function(fn_ast, stacklevel=1):\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    code = compile_function_ast(fn_ast)\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n    eval(code, scope)\n    return scope[fndef_ast.name]",
          "docstring": "",
          "signature": "def function_ast_to_function(fn_ast, stacklevel=1):",
          "type": "Function",
          "class_signature": null
        },
        "expand_function_ast_varargs": {
          "code": "def expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"\n    Given a function AST that use a variable length positional argument\n    (e.g. *args), return a function that replaces the use of this argument\n    with one or more fixed arguments.\n\n    To be supported, a function must have a starred argument in the function\n    signature, and it may only use this argument in starred form as the\n    input to other functions.\n\n    For example, suppose expand_number is 3 and fn_ast is an AST\n    representing this function...\n\n    def my_fn1(a, b, *args):\n        print(a, b)\n        other_fn(a, b, *args)\n\n    Then this function will return the AST of a function equivalent to...\n\n    def my_fn1(a, b, _0, _1, _2):\n        print(a, b)\n        other_fn(a, b, _0, _1, _2)\n\n    If the input function uses `args` for anything other than passing it to\n    other functions in starred form, an error will be raised.\n\n    Parameters\n    ----------\n    fn_ast: ast.FunctionDef\n    expand_number: int\n\n    Returns\n    -------\n    ast.FunctionDef\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fn_ast = copy.deepcopy(fn_ast)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    fn_args = fndef_ast.args\n    fn_vararg = fn_args.vararg\n    if not fn_vararg:\n        raise ValueError('Input function AST does not have a variable length positional argument\\n(e.g. *args) in the function signature')\n    assert fn_vararg\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n    expand_transformer = ExpandVarargTransformerStarred\n    new_fn_ast = expand_transformer(vararg_name, expand_names).visit(fn_ast)\n    new_fndef_ast = new_fn_ast.body[0]\n    new_fndef_ast.args.args.extend([_build_arg(name=name) for name in expand_names])\n    new_fndef_ast.args.vararg = None\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError('The variable length positional argument {n} is used in an unsupported context\\n'.format(n=vararg_name))\n    fndef_ast.decorator_list = []\n    ast.fix_missing_locations(new_fn_ast)\n    return new_fn_ast",
          "docstring": "Given a function AST that use a variable length positional argument\n(e.g. *args), return a function that replaces the use of this argument\nwith one or more fixed arguments.\n\nTo be supported, a function must have a starred argument in the function\nsignature, and it may only use this argument in starred form as the\ninput to other functions.\n\nFor example, suppose expand_number is 3 and fn_ast is an AST\nrepresenting this function...\n\ndef my_fn1(a, b, *args):\n    print(a, b)\n    other_fn(a, b, *args)\n\nThen this function will return the AST of a function equivalent to...\n\ndef my_fn1(a, b, _0, _1, _2):\n    print(a, b)\n    other_fn(a, b, _0, _1, _2)\n\nIf the input function uses `args` for anything other than passing it to\nother functions in starred form, an error will be raised.\n\nParameters\n----------\nfn_ast: ast.FunctionDef\nexpand_number: int\n\nReturns\n-------\nast.FunctionDef",
          "signature": "def expand_function_ast_varargs(fn_ast, expand_number):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "datashader/tests/test_macros.py:test_expand_varargs": {
      "datashader/tests/test_macros.py:get_args": {},
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg": {
        "datashader/tests/test_macros.py:function_no_vararg": {}
      },
      "datashader/tests/test_macros.py:function_no_vararg": {}
    },
    "datashader/tests/test_macros.py:test_invalid_expand_number": {
      "datashader/macros.py:expand_varargs": {}
    },
    "datashader/tests/test_macros.py:test_no_varargs_error": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {}
      }
    },
    "datashader/tests/test_macros.py:test_unsupported_vararg_use": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        }
      }
    },
    "datashader/tests/test_macros.py:test_numba_jit_expanded_function": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg_call_numba": {}
    }
  },
  "PRD": "# PROJECT NAME: datashader-test_macros\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 datashader/\n    \u2514\u2500\u2500 macros.py\n        \u251c\u2500\u2500 _expand_varargs\n        \u2514\u2500\u2500 expand_varargs\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality to modify Python functions that utilize variadic arguments (*args), enabling them to operate as if a fixed number of positional arguments were specified. It introduces a decorator that dynamically expands functions with variadic parameters into ones that explicitly define a predefined number of additional arguments, streamlining their invocation in contexts where variadics are unsupported or require stricter control, such as with JIT-compiled functions. This enhances flexibility and compatibility, particularly in performance-critical scenarios involving libraries like Numba, by allowing optimized functions to process variadic inputs without runtime variability. By addressing the challenges of handling variadic arguments in constrained environments, the module simplifies development and promotes better integration with frameworks requiring explicit argument definitions.\n\n## FILE 1: datashader/macros.py\n\n- FUNCTION NAME: expand_varargs\n  - SIGNATURE: def expand_varargs(expand_number):\n  - DOCSTRING: \n```python\n\"\"\"\nDecorator that expands a variable-length positional argument (*args) in a function's signature \nto a fixed number of individual parameters.\n\nParameters\n----------\nexpand_number: int\n    The number of fixed arguments that should replace the variable-length \n    argument. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that modifies the target function to use \n    a fixed number of arguments instead of the starred variable-length \n    argument.\n\nRaises\n------\nValueError\n    If expand_number is not a non-negative integer.\n\nThis decorator relies on the following utility functions:\n- function_to_ast(fn): Converts the function to an Abstract Syntax Tree (AST).\n- expand_function_ast_varargs(fn_ast, expand_number): Transforms the function AST by \n  replacing the variable-length argument with fixed arguments.\n- function_ast_to_function(fn_ast, stacklevel): Compiles the modified AST back into \n  a callable function.\n\nThe decorator modifies the function's AST structure and thus can \nlead to errors if the variable-length argument is used in any \nunfitting context within the function body.\n\"\"\"\n```\n\n- FUNCTION NAME: _expand_varargs\n  - SIGNATURE: def _expand_varargs(fn):\n  - DOCSTRING: \n```python\n\"\"\"\nExpand the variable-length positional argument in a function's signature to a specified number of fixed positional arguments.\n\nParameters\n----------\nfn: function\n    The function that will have its variable-length arguments expanded. It must\n    contain a starred argument in its signature.\n\nReturns\n-------\nfunction\n    A new function with a modified signature, replacing the starred argument\n    with a specified number of fixed arguments.\n\nDependencies\n------------\nThis function relies on several other functions:\n- `function_to_ast(fn)`: Converts the input function into its Abstract Syntax Tree (AST) representation.\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Takes the function's AST and the number of fixed arguments to generate a new AST with expanded arguments.\n- `function_ast_to_function(fn_ast, stacklevel=2)`: Converts the modified AST back into a function object for use.\n\nNotes\n-----\nThe `expand_number` constant, defined at a higher scope as the argument given to the decorator, specifies how many fixed arguments to replace the variable-length argument.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:function_ast_to_function\n    - datashader/macros.py:expand_function_ast_varargs\n    - datashader/macros.py:function_to_ast\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()\n\n    def visit_Name(self, node):\n        self.names.add(node.id)\n\n    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)\n\n    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile('^_(\\\\d+)$')\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n        return ['_' + str(n) for n in range(start_number, start_number + num_names)]\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n\n    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n\n    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in self.expand_names]\n        else:\n            return node\n\ndef function_to_ast(fn):\n    \"\"\"\n    Get the AST representation of a function\n    \"\"\"\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n    fn_ast = ast.parse(fn_source)\n    return fn_ast\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)\n\ndef compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, '<%s>' % fndef_ast.name, mode='exec')\n\ndef function_ast_to_function(fn_ast, stacklevel=1):\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    code = compile_function_ast(fn_ast)\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n    eval(code, scope)\n    return scope[fndef_ast.name]\n\ndef _build_arg(name):\n    return ast.arg(arg=name)\n\ndef expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"\n    Given a function AST that use a variable length positional argument\n    (e.g. *args), return a function that replaces the use of this argument\n    with one or more fixed arguments.\n\n    To be supported, a function must have a starred argument in the function\n    signature, and it may only use this argument in starred form as the\n    input to other functions.\n\n    For example, suppose expand_number is 3 and fn_ast is an AST\n    representing this function...\n\n    def my_fn1(a, b, *args):\n        print(a, b)\n        other_fn(a, b, *args)\n\n    Then this function will return the AST of a function equivalent to...\n\n    def my_fn1(a, b, _0, _1, _2):\n        print(a, b)\n        other_fn(a, b, _0, _1, _2)\n\n    If the input function uses `args` for anything other than passing it to\n    other functions in starred form, an error will be raised.\n\n    Parameters\n    ----------\n    fn_ast: ast.FunctionDef\n    expand_number: int\n\n    Returns\n    -------\n    ast.FunctionDef\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fn_ast = copy.deepcopy(fn_ast)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    fn_args = fndef_ast.args\n    fn_vararg = fn_args.vararg\n    if not fn_vararg:\n        raise ValueError('Input function AST does not have a variable length positional argument\\n(e.g. *args) in the function signature')\n    assert fn_vararg\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n    expand_transformer = ExpandVarargTransformerStarred\n    new_fn_ast = expand_transformer(vararg_name, expand_names).visit(fn_ast)\n    new_fndef_ast = new_fn_ast.body[0]\n    new_fndef_ast.args.args.extend([_build_arg(name=name) for name in expand_names])\n    new_fndef_ast.args.vararg = None\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError('The variable length positional argument {n} is used in an unsupported context\\n'.format(n=vararg_name))\n    fndef_ast.decorator_list = []\n    ast.fix_missing_locations(new_fn_ast)\n    return new_fn_ast"
  }
}