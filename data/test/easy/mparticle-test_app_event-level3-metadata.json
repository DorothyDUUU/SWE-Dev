{
  "dir_path": "/app/mparticle",
  "package_name": "mparticle",
  "sample_name": "mparticle-test_app_event",
  "src_dir": "mparticle/",
  "test_dir": "test/",
  "test_file": "test/test_app_event.py",
  "test_code": "# coding: utf-8\n\n\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport os\nimport sys\nimport unittest\n\nimport mparticle\nfrom mparticle.rest import ApiException\nfrom mparticle.models.app_event import AppEvent\n\n\nclass TestAppEvent(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def testAppEvent(self):\n        event = mparticle.models.app_event.AppEvent(\n            event_name='test event',\n            custom_event_type='transaction',\n            custom_attributes={\n                'example attribute key': 'example attribute value'}\n        )\n        self.assertEqual('test event', event.event_name)\n        self.assertEqual('transaction', event.custom_event_type)\n        self.assertEqual('example attribute value',\n                         event.custom_attributes['example attribute key'])\n\n    def testAppEventAttributeValues(self):\n        with self.assertRaises(ValueError):\n            event = mparticle.models.app_event.AppEvent(\n                event_name='test event',\n                custom_event_type='transaction',\n                custom_attributes={'example attribute key': ['something']}\n            )\n\n        event = mparticle.models.app_event.AppEvent(\n            event_name='test event',\n            custom_event_type='transaction',\n            custom_attributes=None\n        )\n        with self.assertRaises(ValueError):\n            event.custom_attributes = {'example attribute key': ['something']}\n\n    def testAttributionEvent(self):\n        event = mparticle.models.app_event.AppEvent.create_attribution_event(\n            u'this is a publisher', 'this is a campaign')\n        self.assertEqual('attribution', event.custom_event_type)\n        self.assertEqual('attribution', event.event_name)\n        self.assertEqual('this is a campaign',\n                         event.custom_attributes['campaign'])\n        self.assertEqual(u'this is a publisher',\n                         event.custom_attributes['publisher'])\n\n    def testAttributionDeleteEvent(self):\n        event = mparticle.models.app_event.AppEvent.create_attribution_delete_event()\n        self.assertEqual('attribution', event.custom_event_type)\n        self.assertEqual('attribution', event.event_name)\n        self.assertEqual('delete', event.custom_attributes['action'])\n        self.assertFalse('campaign' in event.custom_attributes)\n        self.assertFalse('publisher' in event.custom_attributes)\n\n    def testAppEventCustomFlags(self):\n        custom_flags = {\n            \"foo\": 'bar',\n            'answer': 42,\n            'arrays': [\n                'foo', 'bar', 'baz'\n            ]\n        }\n\n        event = mparticle.models.app_event.AppEvent(\n            event_name='Test Custom flags',\n            custom_flags=custom_flags)\n\n        self.assertEqual(\"bar\", event.custom_flags.get('foo'))\n        self.assertEqual(42, event.custom_flags.get('answer'))\n        self.assertEqual(\n            ['foo', 'bar', 'baz'],\n            event.custom_flags.get('arrays'))\n\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "GT_file_code": {
    "mparticle/models/app_event.py": "# coding: utf-8\n\n\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\n\nfrom pprint import pformat\nfrom six import iteritems\nimport mparticle\n\n\nclass AppEvent(object):\n\n    def __init__(self, event_name=None, custom_event_type='other',\n                 timestamp_unixtime_ms=None, event_id=None,\n                 source_message_id=None, session_id=None,\n                 session_uuid=None, custom_attributes=None,\n                 location=None, device_current_state=None,\n                 media_info=None, custom_flags=None):\n        \"\"\"\n        AppEvent - a model defined in Swagger\n\n        :param dict swaggerTypes: The key is attribute name\n                                  and the value is attribute type.\n        :param dict attributeMap: The key is attribute name\n                                  and the value is json key in definition.\n        \"\"\"\n        self.swagger_types = {\n            'timestamp_unixtime_ms': 'int',\n            'event_id': 'int',\n            'source_message_id': 'str',\n            'session_id': 'int',\n            'session_uuid': 'str',\n            'custom_attributes': 'dict(str, str)',\n            'location': 'GeoLocation',\n            'device_current_state': 'DeviceCurrentState',\n            'custom_event_type': 'str',\n            'event_name': 'str',\n            'media_info': 'MediaInfo',\n            'custom_flags': 'dict(str, str)'\n        }\n\n        self.attribute_map = {\n            'timestamp_unixtime_ms': 'timestamp_unixtime_ms',\n            'event_id': 'event_id',\n            'source_message_id': 'source_message_id',\n            'session_id': 'session_id',\n            'session_uuid': 'session_uuid',\n            'custom_attributes': 'custom_attributes',\n            'location': 'location',\n            'device_current_state': 'device_current_state',\n            'custom_event_type': 'custom_event_type',\n            'event_name': 'event_name',\n            'media_info': 'media_info',\n            'custom_flags': 'custom_flags',\n        }\n\n        self._timestamp_unixtime_ms = timestamp_unixtime_ms\n        self._event_id = event_id\n        self._source_message_id = source_message_id\n        self._session_id = session_id\n        self._session_uuid = session_uuid\n        self.custom_attributes = custom_attributes\n        self._location = location\n        self._device_current_state = device_current_state\n        self._custom_event_type = custom_event_type\n        if event_name is None:\n            raise ValueError(\n                \"Event Name is required.\"\n            )\n        self._event_name = event_name\n        self._media_info = media_info\n        self._custom_flags = custom_flags\n\n    @classmethod\n    def create_attribution_event(cls, publisher=None, campaign=None):\n        return cls(\n            event_name='attribution',\n            custom_event_type='attribution',\n            custom_attributes={'campaign': campaign, 'publisher': publisher}\n        )\n\n    @classmethod\n    def create_attribution_delete_event(cls):\n        return cls(\n            event_name='attribution',\n            custom_event_type='attribution',\n            custom_attributes={'action': 'delete'}\n        )\n\n    @property\n    def timestamp_unixtime_ms(self):\n        \"\"\"\n        Gets the timestamp_unixtime_ms of this AppEvent.\n\n\n        :return: The timestamp_unixtime_ms of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._timestamp_unixtime_ms\n\n    @timestamp_unixtime_ms.setter\n    def timestamp_unixtime_ms(self, timestamp_unixtime_ms):\n        \"\"\"\n        Sets the timestamp_unixtime_ms of this AppEvent.\n\n\n        :param timestamp_unixtime_ms: The timestamp_unixtime_ms of this AppEvent.\n        :type: int\n        \"\"\"\n\n        self._timestamp_unixtime_ms = timestamp_unixtime_ms\n\n    @property\n    def event_id(self):\n        \"\"\"\n        Gets the event_id of this AppEvent.\n\n\n        :return: The event_id of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._event_id\n\n    @event_id.setter\n    def event_id(self, event_id):\n        \"\"\"\n        Sets the event_id of this AppEvent.\n\n\n        :param event_id: The event_id of this AppEvent.\n        :type: int\n        \"\"\"\n\n        self._event_id = event_id\n\n    @property\n    def source_message_id(self):\n        \"\"\"\n        Gets the source_message_id of this AppEvent.\n\n\n        :return: The source_message_id of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._source_message_id\n\n    @source_message_id.setter\n    def source_message_id(self, source_message_id):\n        \"\"\"\n        Sets the source_message_id of this AppEvent.\n\n\n        :param source_message_id: The source_message_id of this AppEvent.\n        :type: str\n        \"\"\"\n\n        self._source_message_id = source_message_id\n\n    @property\n    def session_id(self):\n        \"\"\"\n        Gets the session_id of this AppEvent.\n\n\n        :return: The session_id of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, session_id):\n        \"\"\"\n        Sets the session_id of this AppEvent.\n\n\n        :param session_id: The session_id of this AppEvent.\n        :type: int\n        \"\"\"\n\n        self._session_id = session_id\n\n    @property\n    def session_uuid(self):\n        \"\"\"\n        Gets the session_uuid of this AppEvent.\n\n\n        :return: The session_uuid of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._session_uuid\n\n    @session_uuid.setter\n    def session_uuid(self, session_uuid):\n        \"\"\"\n        Sets the session_uuid of this AppEvent.\n\n\n        :param session_uuid: The session_uuid of this AppEvent.\n        :type: str\n        \"\"\"\n\n        self._session_uuid = session_uuid\n\n    @property\n    def custom_attributes(self):\n        \"\"\"\n        Gets the custom_attributes of this AppEvent.\n\n\n        :return: The custom_attributes of this AppEvent.\n        :rtype: dict(str, str)\n        \"\"\"\n        return self._custom_attributes\n\n    @custom_attributes.setter\n    def custom_attributes(self, custom_attributes):\n        \"\"\"\n        Sets the custom_attributes of this AppEvent.\n\n\n        :param custom_attributes: The custom_attributes of this AppEvent.\n        :type: dict(str, str)\n        \"\"\"\n\n        if not mparticle.ApiClient.validate_attribute_bag_values(custom_attributes):\n            raise ValueError(\n                \"Invalid custom_attributes passed to AppEvent: \" + str(custom_attributes))\n\n        self._custom_attributes = custom_attributes\n\n    @property\n    def location(self):\n        \"\"\"\n        Gets the location of this AppEvent.\n\n\n        :return: The location of this AppEvent.\n        :rtype: GeoLocation\n        \"\"\"\n        return self._location\n\n    @location.setter\n    def location(self, location):\n        \"\"\"\n        Sets the location of this AppEvent.\n\n\n        :param location: The location of this AppEvent.\n        :type: GeoLocation\n        \"\"\"\n\n        self._location = location\n\n    @property\n    def device_current_state(self):\n        \"\"\"\n        Gets the device_current_state of this AppEvent.\n\n\n        :return: The device_current_state of this AppEvent.\n        :rtype: DeviceCurrentState\n        \"\"\"\n        return self._device_current_state\n\n    @device_current_state.setter\n    def device_current_state(self, device_current_state):\n        \"\"\"\n        Sets the device_current_state of this AppEvent.\n\n\n        :param device_current_state: The device_current_state of this AppEvent.\n        :type: DeviceCurrentState\n        \"\"\"\n\n        self._device_current_state = device_current_state\n\n    @property\n    def custom_event_type(self):\n        \"\"\"\n        Gets the custom_event_type of this AppEvent.\n\n\n        :return: The custom_event_type of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._custom_event_type\n\n    @custom_event_type.setter\n    def custom_event_type(self, custom_event_type):\n        \"\"\"\n        Sets the custom_event_type of this AppEvent.\n\n\n        :param custom_event_type: The custom_event_type of this AppEvent.\n        :type: str\n        \"\"\"\n        allowed_values = [\"unknown\", \"navigation\", \"location\", \"search\", \"transaction\",\n                          \"user_content\", \"user_preference\", \"social\", \"other\", \"attribution\"]\n        if custom_event_type not in allowed_values:\n            raise ValueError(\n                \"Invalid value for `custom_event_type` ({0}), must be one of {1}\"\n                .format(custom_event_type, allowed_values)\n            )\n\n        self._custom_event_type = custom_event_type\n\n    @property\n    def event_name(self):\n        \"\"\"\n        Gets the event_name of this AppEvent.\n\n\n        :return: The event_name of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._event_name\n\n    @event_name.setter\n    def event_name(self, event_name):\n        \"\"\"\n        Sets the event_name of this AppEvent.\n\n\n        :param event_name: The event_name of this AppEvent.\n        :type: str\n        \"\"\"\n\n        self._event_name = event_name\n\n    @property\n    def media_info(self):\n        \"\"\"\n        Gets the media_info of this AppEvent.\n\n\n        :return: The media_info of this AppEvent.\n        :rtype: MediaInfo\n        \"\"\"\n        return self._media_info\n\n    @media_info.setter\n    def media_info(self, media_info):\n        \"\"\"\n        Sets the media_info of this AppEvent.\n\n\n        :param media_info: The media_info of this AppEvent.\n        :type: MediaInfo\n        \"\"\"\n\n        self._media_info = media_info\n\n    @property\n    def ltv_amount(self):\n        \"\"\"\n        Gets the ltv_amount of this AppEvent.\n\n\n        :return: The ltv_amount of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._ltv_amount\n\n    @ltv_amount.setter\n    def ltv_amount(self, ltv_amount):\n        \"\"\"\n        Sets the ltv_amount of this AppEvent.\n\n\n        :param ltv_amount: The ltv_amount of this AppEvent.\n        :type: int\n        \"\"\"\n        self._ltv_amount = ltv_amount\n\n        if self.ltv_amount is not None:\n            if self._custom_attributes is None:\n                self._custom_attributes = {}\n            self._custom_attributes[\"$Amount\"] = self.ltv_amount\n            self._custom_attributes[\"MethodName\"] = \"LogLTVIncrease\"\n        elif self.custom_attributes is not None:\n            self._custom_attributes.pop(\"$Amount\", None)\n            self._custom_attributes.pop(\"MethodName\", None)\n\n    @property\n    def custom_flags(self):\n        \"\"\"\n        Gets the custom_flags of this AppEvent.\n\n\n        :return: The custom_flags of this AppEvent.\n        :rtype: dict(str, str)\n        \"\"\"\n        return self._custom_flags\n\n    @custom_flags.setter\n    def custom_flags(self, custom_flags):\n        \"\"\"\n        Sets the custom_flags of this AppEvent.\n\n\n        :param custom_flags: The custom_flags of this AppEvent.\n        :type: dict(str, str)\n        \"\"\"\n\n        self._custom_flags = custom_flags\n\n    def to_dict(self):\n        \"\"\"\n        Returns the model properties as a dict\n        \"\"\"\n        result = {}\n\n        for attr, _ in iteritems(self.swagger_types):\n            value = getattr(self, attr)\n            if isinstance(value, list):\n                result[attr] = list(map(\n                    lambda x: x.to_dict() if hasattr(x, \"to_dict\") else x,\n                    value\n                ))\n            elif hasattr(value, \"to_dict\"):\n                result[attr] = value.to_dict()\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0], item[1].to_dict())\n                    if hasattr(item[1], \"to_dict\") else item,\n                    value.items()\n                ))\n            else:\n                result[attr] = value\n\n        return result\n\n    def to_str(self):\n        \"\"\"\n        Returns the string representation of the model\n        \"\"\"\n        return pformat(self.to_dict())\n\n    def __repr__(self):\n        \"\"\"\n        For `print` and `pprint`\n        \"\"\"\n        return self.to_str()\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if both objects are equal\n        \"\"\"\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        \"\"\"\n        Returns true if both objects are not equal\n        \"\"\"\n        return not self == other\n",
    "mparticle/api_client.py": "# coding: utf-8\n\n\"\"\"\nCopyright 2016 SmartBear Software\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   ref: https://github.com/swagger-api/swagger-codegen\n\"\"\"\n\nfrom __future__ import absolute_import\nfrom . import models\nfrom .rest import RESTClientObject\nfrom .rest import ApiException\n\nimport os\nimport re\nimport sys\nimport urllib\nimport json\nimport mimetypes\nimport random\nimport tempfile\nimport threading\n\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import time\nfrom decimal import Decimal\n\n# python 2 and python 3 compatibility library\nfrom six import iteritems\nfrom six import string_types\nfrom six import integer_types\nfrom six import text_type\n\ntry:\n    # for python3\n    from urllib.parse import quote\nexcept ImportError:\n    # for python2\n    from urllib import quote\n\n# special handling of `long` (python2 only)\ntry:\n    # Python 2\n    long\nexcept NameError:\n    # Python 3\n    long = int\n\nfrom .configuration import Configuration\n\n\nclass ApiClient(object):\n    \"\"\"\n    Generic API client for Swagger client library builds.\n\n    Swagger generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the Swagger\n    templates.\n\n    :param host: The base path for the server to call.\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to the API.\n    \"\"\"\n    def __init__(self, host=None, header_name=None, header_value=None, cookie=None, configuration=None):\n\n        \"\"\"\n        Constructor of the class.\n        \"\"\"\n        self.config = configuration\n        self.rest_client = RESTClientObject(config=configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n        if host is None:\n            self.host = self.config.host\n        else:\n            self.host = host\n        self.cookie = cookie\n        # Set default User-Agent.\n        self.user_agent = 'mParticle Python client/0.16.0'\n\n    @property\n    def user_agent(self):\n        \"\"\"\n        Gets user agent.\n        \"\"\"\n        return self.default_headers['User-Agent']\n\n    @user_agent.setter\n    def user_agent(self, value):\n        \"\"\"\n        Sets user agent.\n        \"\"\"\n        self.default_headers['User-Agent'] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n    def __call_api(self, resource_path, method,\n                   path_params=None, query_params=None, header_params=None,\n                   body=None, post_params=None, files=None,\n                   response_type=None, auth_settings=None, callback=None, _return_http_data_only=None):\n\n        # headers parameters\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params['Cookie'] = self.cookie\n        if header_params:\n            header_params = ApiClient.sanitize_for_serialization(header_params)\n\n        # path parameters\n        if path_params:\n            path_params = ApiClient.sanitize_for_serialization(path_params)\n            for k, v in iteritems(path_params):\n                replacement = quote(str(self.to_path_value(v)))\n                resource_path = resource_path.\\\n                    replace('{' + k + '}', replacement)\n\n        # query parameters\n        if query_params:\n            query_params = ApiClient.sanitize_for_serialization(query_params)\n            query_params = {k: self.to_path_value(v)\n                            for k, v in iteritems(query_params)}\n\n        # post parameters\n        if post_params or files:\n            post_params = self.prepare_post_parameters(post_params, files)\n            post_params = ApiClient.sanitize_for_serialization(post_params)\n\n        # auth setting\n        self.update_params_for_auth(header_params, query_params, auth_settings)\n\n        # body\n        if body:\n            body = ApiClient.sanitize_for_serialization(body)\n\n        # request url\n        url = self.host + resource_path\n\n        # perform request and return response\n        try:\n            response_data = self.request(method, url,\n                                         query_params=query_params,\n                                         headers=header_params,\n                                         post_params=post_params, body=body)\n        except Exception as api_exception:\n            if callback:\n                callback(api_exception)\n                return\n            else:\n                raise\n\n        self.last_response = response_data\n\n        # deserialize response data\n        if response_type:\n            deserialized_data = self.deserialize(response_data, response_type)\n        else:\n            deserialized_data = None\n\n        if callback:\n            callback(deserialized_data) if _return_http_data_only else callback((deserialized_data, response_data.status, response_data.getheaders()))\n        elif _return_http_data_only:\n            return (deserialized_data)\n        else:\n            return (deserialized_data, response_data.status, response_data.getheaders())\n\n    def to_path_value(self, obj):\n        \"\"\"\n        Takes value and turn it into a string suitable for inclusion in\n        the path, by url-encoding.\n\n        :param obj: object or string value.\n\n        :return string: quoted value.\n        \"\"\"\n        if type(obj) == list:\n            return ','.join(obj)\n        else:\n            return str(obj)\n\n    @staticmethod\n    def validate_attribute_bag_values(custom_attributes):\n        return not (custom_attributes is not None and not all(value is None or isinstance(value, (float, bool) + integer_types + string_types) for value in custom_attributes.values()))\n\n    @staticmethod\n    def sanitize_for_serialization(obj):\n        \"\"\"\n        Builds a JSON POST object.\n\n        If obj is None, return None.\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date, datetime.time\n            convert to string in iso8601 format.\n        if obj is decimal.Decimal\n            convert to string\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is swagger model, return the properties dict.\n\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        types = string_types + integer_types + (float, bool, tuple)\n        if isinstance(obj, type(None)):\n            return None\n        elif isinstance(obj, types):\n            return obj\n        elif isinstance(obj, list):\n            return [ApiClient.sanitize_for_serialization(sub_obj)\n                    for sub_obj in obj]\n        elif isinstance(obj, (datetime, date, time)):\n            return obj.isoformat()\n        elif isinstance(obj, Decimal):\n            return str(obj)\n        else:\n            if isinstance(obj, dict):\n                obj_dict = obj\n            else:\n                # Convert model obj to dict except\n                # attributes `swagger_types`, `attribute_map`\n                # and attributes which value is not None.\n                # Convert attribute name to json key in\n                # model definition for request.\n                obj_dict = {obj.attribute_map[attr]: getattr(obj, attr)\n                            for attr, _ in iteritems(obj.swagger_types)\n                            if getattr(obj, attr) is not None}\n\n            return {key: ApiClient.sanitize_for_serialization(val)\n                    for key, val in iteritems(obj_dict)}\n\n    def deserialize(self, response, response_type):\n        \"\"\"\n        Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: class literal for\n            deserialzied object, or string of class name.\n\n        :return: deserialized object.\n        \"\"\"\n        # handle file downloading\n        # save response body into a tmp file and return the instance\n        if \"file\" == response_type:\n            return self.__deserialize_file(response)\n\n        # fetch data from response object\n        try:\n            data = json.loads(response.data)\n        except ValueError:\n            data = response.data\n\n        return self.__deserialize(data, response_type)\n\n    def __deserialize(self, data, klass):\n        \"\"\"\n        Deserializes dict, list, str into an object.\n\n        :param data: dict, list or str.\n        :param klass: class literal, or string of class name.\n\n        :return: object.\n        \"\"\"\n        if data is None:\n            return None\n\n        if type(klass) == str:\n            if klass.startswith('list['):\n                sub_kls = re.match(r'list\\[(.*)\\]', klass).group(1)\n                return [self.__deserialize(sub_data, sub_kls)\n                        for sub_data in data]\n\n            if klass.startswith('dict('):\n                sub_kls = re.match(r'dict\\(([^,]*), (.*)\\)', klass).group(2)\n                return {k: self.__deserialize(v, sub_kls)\n                        for k, v in iteritems(data)}\n\n            # convert str to class\n            # for native types\n            if klass in ['int', 'long', 'float', 'str', 'bool',\n                         \"date\", 'datetime', \"object\"]:\n                klass = eval(klass)\n            # for model types\n            else:\n                klass = eval('models.' + klass)\n\n        if klass in list(integer_types) + list(string_types) + [float, text_type, bool]:\n            return self.__deserialize_primitive(data, klass)\n        elif klass == object:\n            return self.__deserialize_object(data)\n        elif klass == date:\n            return self.__deserialize_date(data)\n        elif klass == datetime:\n            return self.__deserialize_datatime(data)\n        else:\n            return self.__deserialize_model(data, klass)\n\n    def call_api(self, resource_path, method,\n                 path_params=None, query_params=None, header_params=None,\n                 body=None, post_params=None, files=None,\n                 response_type=None, auth_settings=None, callback=None, _return_http_data_only=None):\n        \"\"\"\n        Makes the HTTP request (synchronous) and return the deserialized data.\n        To make an async request, define a function for callback.\n\n        :param resource_path: Path to method endpoint.\n        :param method: Method to call.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param response: Response data type.\n        :param files dict: key -> filename, value -> filepath,\n            for `multipart/form-data`.\n        :param callback function: Callback function for asynchronous request.\n            If provide this parameter,\n            the request will be called asynchronously.\n        :param _return_http_data_only: response data without head status code and headers\n        :return:\n            If provide parameter callback,\n            the request will be called asynchronously.\n            The method will return the request thread.\n            If parameter callback is None,\n            then the method will return the response directly.\n        \"\"\"\n        if callback is None:\n            return self.__call_api(resource_path, method,\n                                   path_params, query_params, header_params,\n                                   body, post_params, files,\n                                   response_type, auth_settings, callback, _return_http_data_only)\n        else:\n            thread = threading.Thread(target=self.__call_api,\n                                      args=(resource_path, method,\n                                            path_params, query_params,\n                                            header_params, body,\n                                            post_params, files,\n                                            response_type, auth_settings,\n                                            callback, _return_http_data_only))\n        thread.start()\n        return thread\n\n    def request(self, method, url, query_params=None, headers=None,\n                post_params=None, body=None):\n        \"\"\"\n        Makes the HTTP request using RESTClient.\n        \"\"\"\n        if method == \"GET\":\n            return self.rest_client.GET(url,\n                                        query_params=query_params,\n                                        headers=headers)\n        elif method == \"HEAD\":\n            return self.rest_client.HEAD(url,\n                                         query_params=query_params,\n                                         headers=headers)\n        elif method == \"OPTIONS\":\n            return self.rest_client.OPTIONS(url,\n                                            query_params=query_params,\n                                            headers=headers,\n                                            post_params=post_params,\n                                            body=body)\n        elif method == \"POST\":\n            return self.rest_client.POST(url,\n                                         query_params=query_params,\n                                         headers=headers,\n                                         post_params=post_params,\n                                         body=body)\n        elif method == \"PUT\":\n            return self.rest_client.PUT(url,\n                                        query_params=query_params,\n                                        headers=headers,\n                                        post_params=post_params,\n                                        body=body)\n        elif method == \"PATCH\":\n            return self.rest_client.PATCH(url,\n                                          query_params=query_params,\n                                          headers=headers,\n                                          post_params=post_params,\n                                          body=body)\n        elif method == \"DELETE\":\n            return self.rest_client.DELETE(url,\n                                           query_params=query_params,\n                                           headers=headers,\n                                           body=body)\n        else:\n            raise ValueError(\n                \"http method must be `GET`, `HEAD`,\"\n                \" `POST`, `PATCH`, `PUT` or `DELETE`.\"\n            )\n\n    def prepare_post_parameters(self, post_params=None, files=None):\n        \"\"\"\n        Builds form parameters.\n\n        :param post_params: Normal form parameters.\n        :param files: File parameters.\n        :return: Form parameters with files.\n        \"\"\"\n        params = []\n\n        if post_params:\n            params = post_params\n\n        if files:\n            for k, v in iteritems(files):\n                if not v:\n                    continue\n                file_names = v if type(v) is list else [v]\n                for n in file_names:\n                    with open(n, 'rb') as f:\n                        filename = os.path.basename(f.name)\n                        filedata = f.read()\n                        mimetype = mimetypes.\\\n                            guess_type(filename)[0] or 'application/octet-stream'\n                        params.append(tuple([k, tuple([filename, filedata, mimetype])]))\n\n        return params\n\n    def select_header_accept(self, accepts):\n        \"\"\"\n        Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return\n\n        accepts = list(map(lambda x: x.lower(), accepts))\n\n        if 'application/json' in accepts:\n            return 'application/json'\n        else:\n            return ', '.join(accepts)\n\n    def select_header_content_type(self, content_types):\n        \"\"\"\n        Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return 'application/json'\n\n        content_types = list(map(lambda x: x.lower(), content_types))\n\n        if 'application/json' in content_types:\n            return 'application/json'\n        else:\n            return content_types[0]\n\n    def update_params_for_auth(self, headers, querys, auth_settings):\n        \"\"\"\n        Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param querys: Query parameters dict to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        \"\"\"\n        if not auth_settings:\n            return\n\n        for auth in auth_settings:\n            auth_setting = self.config.auth_settings().get(auth)\n            if auth_setting:\n                if not auth_setting['value']:\n                    continue\n                elif auth_setting['in'] == 'header':\n                    headers[auth_setting['key']] = auth_setting['value']\n                elif auth_setting['in'] == 'query':\n                    querys[auth_setting['key']] = auth_setting['value']\n                else:\n                    raise ValueError(\n                        'Authentication token must be in `query` or `header`'\n                    )\n\n    def __deserialize_file(self, response):\n        \"\"\"\n        Saves response body into a file in a temporary folder,\n        using the filename from the `Content-Disposition` header if provided.\n\n        :param response:  RESTResponse.\n        :return: file path.\n        \"\"\"\n        fd, path = tempfile.mkstemp(dir=self.config.temp_folder_path)\n        os.close(fd)\n        os.remove(path)\n\n        content_disposition = response.getheader(\"Content-Disposition\")\n        if content_disposition:\n            filename = re.\\\n                search(r'filename=[\\'\"]?([^\\'\"\\s]+)[\\'\"]?', content_disposition).\\\n                group(1)\n            path = os.path.join(os.path.dirname(path), filename)\n\n        with open(path, \"w\") as f:\n            f.write(response.data)\n\n        return path\n\n    def __deserialize_primitive(self, data, klass):\n        \"\"\"\n        Deserializes string to primitive type.\n\n        :param data: str.\n        :param klass: class literal.\n\n        :return: int, long, float, str, bool.\n        \"\"\"\n        try:\n            value = klass(data)\n        except UnicodeEncodeError:\n            value = unicode(data)\n        except TypeError:\n            value = data\n        return value\n\n    def __deserialize_object(self, value):\n        \"\"\"\n        Return a original value.\n\n        :return: object.\n        \"\"\"\n        return value\n\n    def __deserialize_date(self, string):\n        \"\"\"\n        Deserializes string to date.\n\n        :param string: str.\n        :return: date.\n        \"\"\"\n        try:\n            from dateutil.parser import parse\n            return parse(string).date()\n        except ImportError:\n            return string\n        except ValueError:\n            raise ApiException(\n                status=0,\n                reason=\"Failed to parse `{0}` into a date object\"\n                .format(string)\n            )\n\n    def __deserialize_datatime(self, string):\n        \"\"\"\n        Deserializes string to datetime.\n\n        The string should be in iso8601 datetime format.\n\n        :param string: str.\n        :return: datetime.\n        \"\"\"\n        try:\n            from dateutil.parser import parse\n            return parse(string)\n        except ImportError:\n            return string\n        except ValueError:\n            raise ApiException(\n                status=0,\n                reason=\"Failed to parse `{0}` into a datetime object\".\n                format(string)\n            )\n\n    def __deserialize_model(self, data, klass):\n        \"\"\"\n        Deserializes list or dict to model.\n\n        :param data: dict, list.\n        :param klass: class literal.\n        :return: model object.\n        \"\"\"\n        instance = klass()\n\n        for attr, attr_type in iteritems(instance.swagger_types):\n            if data is not None \\\n               and instance.attribute_map[attr] in data\\\n               and isinstance(data, (list, dict)):\n                value = data[instance.attribute_map[attr]]\n                setattr(instance, attr, self.__deserialize(value, attr_type))\n\n        return instance\n"
  },
  "GT_src_dict": {
    "mparticle/models/app_event.py": {
      "AppEvent.__init__": {
        "code": "    def __init__(self, event_name=None, custom_event_type='other', timestamp_unixtime_ms=None, event_id=None, source_message_id=None, session_id=None, session_uuid=None, custom_attributes=None, location=None, device_current_state=None, media_info=None, custom_flags=None):\n        \"\"\"Initializes an instance of the AppEvent class, which represents an application event for the mParticle Event API.\n\n    This constructor requires an event name and optionally allows setting various parameters such as event ID, session ID, \n    timestamps, custom attributes, device information, and custom flags. The `custom_event_type` can default to 'other',\n    but will raise a ValueError if the event_name is not provided.\n\n    Parameters:\n    - event_name (str): The name of the event, which is required.\n    - custom_event_type (str): The type of the event (default is 'other'). Must be one of predefined types.\n    - timestamp_unixtime_ms (int): The event's timestamp in milliseconds since epoch.\n    - event_id (int): A unique identifier for the event.\n    - source_message_id (str): An identifier for the source message associated with the event.\n    - session_id (int): The ID of the session in which the event occurred.\n    - session_uuid (str): A universally unique identifier for the session.\n    - custom_attributes (dict[str, str]): Key-value pairs for custom attributes associated with the event.\n    - location (GeoLocation): A GeoLocation object representing the geographic location of the event.\n    - device_current_state (DeviceCurrentState): An object representing the current state of the device.\n    - media_info (MediaInfo): An object containing information about media related to the event.\n    - custom_flags (dict[str, str]): Custom flags for the event as key-value pairs.\n\n    Raises:\n    - ValueError: If the event_name is None.\n\n    This constructor also initializes two dictionaries: `swagger_types`, which maps attribute names to their data types,\n    and `attribute_map`, which contains the mapping of attribute names to their corresponding JSON keys. These mappings \n    assist in the serialization and deserialization of AppEvent objects within the mParticle framework.\"\"\"\n        '\\n        AppEvent - a model defined in Swagger\\n\\n        :param dict swaggerTypes: The key is attribute name\\n                                  and the value is attribute type.\\n        :param dict attributeMap: The key is attribute name\\n                                  and the value is json key in definition.\\n        '\n        self.swagger_types = {'timestamp_unixtime_ms': 'int', 'event_id': 'int', 'source_message_id': 'str', 'session_id': 'int', 'session_uuid': 'str', 'custom_attributes': 'dict(str, str)', 'location': 'GeoLocation', 'device_current_state': 'DeviceCurrentState', 'custom_event_type': 'str', 'event_name': 'str', 'media_info': 'MediaInfo', 'custom_flags': 'dict(str, str)'}\n        self.attribute_map = {'timestamp_unixtime_ms': 'timestamp_unixtime_ms', 'event_id': 'event_id', 'source_message_id': 'source_message_id', 'session_id': 'session_id', 'session_uuid': 'session_uuid', 'custom_attributes': 'custom_attributes', 'location': 'location', 'device_current_state': 'device_current_state', 'custom_event_type': 'custom_event_type', 'event_name': 'event_name', 'media_info': 'media_info', 'custom_flags': 'custom_flags'}\n        self._timestamp_unixtime_ms = timestamp_unixtime_ms\n        self._event_id = event_id\n        self._source_message_id = source_message_id\n        self._session_id = session_id\n        self._session_uuid = session_uuid\n        self.custom_attributes = custom_attributes\n        self._location = location\n        self._device_current_state = device_current_state\n        self._custom_event_type = custom_event_type\n        if event_name is None:\n            raise ValueError('Event Name is required.')\n        self._event_name = event_name\n        self._media_info = media_info\n        self._custom_flags = custom_flags",
        "docstring": "Initializes an instance of the AppEvent class, which represents an application event for the mParticle Event API.\n\nThis constructor requires an event name and optionally allows setting various parameters such as event ID, session ID, \ntimestamps, custom attributes, device information, and custom flags. The `custom_event_type` can default to 'other',\nbut will raise a ValueError if the event_name is not provided.\n\nParameters:\n- event_name (str): The name of the event, which is required.\n- custom_event_type (str): The type of the event (default is 'other'). Must be one of predefined types.\n- timestamp_unixtime_ms (int): The event's timestamp in milliseconds since epoch.\n- event_id (int): A unique identifier for the event.\n- source_message_id (str): An identifier for the source message associated with the event.\n- session_id (int): The ID of the session in which the event occurred.\n- session_uuid (str): A universally unique identifier for the session.\n- custom_attributes (dict[str, str]): Key-value pairs for custom attributes associated with the event.\n- location (GeoLocation): A GeoLocation object representing the geographic location of the event.\n- device_current_state (DeviceCurrentState): An object representing the current state of the device.\n- media_info (MediaInfo): An object containing information about media related to the event.\n- custom_flags (dict[str, str]): Custom flags for the event as key-value pairs.\n\nRaises:\n- ValueError: If the event_name is None.\n\nThis constructor also initializes two dictionaries: `swagger_types`, which maps attribute names to their data types,\nand `attribute_map`, which contains the mapping of attribute names to their corresponding JSON keys. These mappings \nassist in the serialization and deserialization of AppEvent objects within the mParticle framework.",
        "signature": "def __init__(self, event_name=None, custom_event_type='other', timestamp_unixtime_ms=None, event_id=None, source_message_id=None, session_id=None, session_uuid=None, custom_attributes=None, location=None, device_current_state=None, media_info=None, custom_flags=None):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.create_attribution_event": {
        "code": "    def create_attribution_event(cls, publisher=None, campaign=None):\n        \"\"\"Creates an attribution event for the AppEvent class.\n\n        This class method facilitates the instantiation of an AppEvent object\n        specifically for tracking attribution with optional parameters for \n        publisher and campaign. The event_name and custom_event_type are \n        both set to 'attribution', and custom_attributes are populated \n        with the provided campaign and publisher values.\n\n        Parameters:\n            publisher (str): The name of the publisher associated with the \n                             attribution event.\n            campaign (str): The name of the campaign linked to the \n                            attribution event.\n\n        Returns:\n            AppEvent: An instance of the AppEvent class configured for an \n                       attribution tracking event.\n\n        Raises:\n            ValueError: If an invalid argument is provided, or if the \n                        required fields are not properly set, though this \n                        method ensures the event_name is valid by default.\"\"\"\n        return cls(event_name='attribution', custom_event_type='attribution', custom_attributes={'campaign': campaign, 'publisher': publisher})",
        "docstring": "Creates an attribution event for the AppEvent class.\n\nThis class method facilitates the instantiation of an AppEvent object\nspecifically for tracking attribution with optional parameters for \npublisher and campaign. The event_name and custom_event_type are \nboth set to 'attribution', and custom_attributes are populated \nwith the provided campaign and publisher values.\n\nParameters:\n    publisher (str): The name of the publisher associated with the \n                     attribution event.\n    campaign (str): The name of the campaign linked to the \n                    attribution event.\n\nReturns:\n    AppEvent: An instance of the AppEvent class configured for an \n               attribution tracking event.\n\nRaises:\n    ValueError: If an invalid argument is provided, or if the \n                required fields are not properly set, though this \n                method ensures the event_name is valid by default.",
        "signature": "def create_attribution_event(cls, publisher=None, campaign=None):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.create_attribution_delete_event": {
        "code": "    def create_attribution_delete_event(cls):\n        \"\"\"Creates a new attribution delete event instance of the AppEvent class.\n\n        This class method initializes an AppEvent with the predefined name 'attribution'\n        and a custom event type of 'attribution'. It also specifies the custom attributes\n        to indicate an action of 'delete'. This is useful for logging when an attribution\n        event is removed, adhering to a structured event logging system.\n\n        Returns:\n            AppEvent: An instance of the AppEvent class configured as an attribution delete event.\"\"\"\n        return cls(event_name='attribution', custom_event_type='attribution', custom_attributes={'action': 'delete'})",
        "docstring": "Creates a new attribution delete event instance of the AppEvent class.\n\nThis class method initializes an AppEvent with the predefined name 'attribution'\nand a custom event type of 'attribution'. It also specifies the custom attributes\nto indicate an action of 'delete'. This is useful for logging when an attribution\nevent is removed, adhering to a structured event logging system.\n\nReturns:\n    AppEvent: An instance of the AppEvent class configured as an attribution delete event.",
        "signature": "def create_attribution_delete_event(cls):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.custom_attributes": {
        "code": "    def custom_attributes(self, custom_attributes):\n        \"\"\"Sets the custom attributes for this AppEvent to provide additional contextual information related to the event.\n\n:param custom_attributes: A dictionary containing key-value pairs representing custom attributes for the event. The keys and values should be strings.\n:type: dict(str, str)\n\n:raises ValueError: If the provided custom_attributes are invalid, as determined by the `mparticle.ApiClient.validate_attribute_bag_values` method, which checks the validity of the attribute values according to defined criteria.\n\nThis method interacts with the `mparticle` library, specifically by calling its `ApiClient` to validate the attributes, ensuring that only acceptable values are set. It also maintains the internal state of the `AppEvent` class by storing the validated custom attributes in the `_custom_attributes` instance variable.\"\"\"\n        '\\n        Sets the custom_attributes of this AppEvent.\\n\\n\\n        :param custom_attributes: The custom_attributes of this AppEvent.\\n        :type: dict(str, str)\\n        '\n        if not mparticle.ApiClient.validate_attribute_bag_values(custom_attributes):\n            raise ValueError('Invalid custom_attributes passed to AppEvent: ' + str(custom_attributes))\n        self._custom_attributes = custom_attributes",
        "docstring": "Sets the custom attributes for this AppEvent to provide additional contextual information related to the event.\n\n:param custom_attributes: A dictionary containing key-value pairs representing custom attributes for the event. The keys and values should be strings.\n:type: dict(str, str)\n\n:raises ValueError: If the provided custom_attributes are invalid, as determined by the `mparticle.ApiClient.validate_attribute_bag_values` method, which checks the validity of the attribute values according to defined criteria.\n\nThis method interacts with the `mparticle` library, specifically by calling its `ApiClient` to validate the attributes, ensuring that only acceptable values are set. It also maintains the internal state of the `AppEvent` class by storing the validated custom attributes in the `_custom_attributes` instance variable.",
        "signature": "def custom_attributes(self, custom_attributes):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.custom_event_type": {
        "code": "    def custom_event_type(self, custom_event_type):\n        \"\"\"Sets the custom_event_type of this AppEvent.\n\nThis method assigns a specific category to the event, which helps in organizing and interpreting events in a meaningful way within the mParticle framework. The `custom_event_type` parameter must be one of the predefined allowed values, which include:\n- \"unknown\"\n- \"navigation\"\n- \"location\"\n- \"search\"\n- \"transaction\"\n- \"user_content\"\n- \"user_preference\"\n- \"social\"\n- \"other\"\n- \"attribution\"\n\nIf an invalid value is provided, a ValueError is raised, indicating the valid options. The `custom_event_type` is stored as a private attribute (`_custom_event_type`), which can be accessed later for event processing or reporting purposes.\n\nParameters:\n    custom_event_type (str): The type of custom event to be set.\n\nRaises:\n    ValueError: If the provided custom_event_type is not one of the allowed values.\"\"\"\n        '\\n        Sets the custom_event_type of this AppEvent.\\n\\n\\n        :param custom_event_type: The custom_event_type of this AppEvent.\\n        :type: str\\n        '\n        allowed_values = ['unknown', 'navigation', 'location', 'search', 'transaction', 'user_content', 'user_preference', 'social', 'other', 'attribution']\n        if custom_event_type not in allowed_values:\n            raise ValueError('Invalid value for `custom_event_type` ({0}), must be one of {1}'.format(custom_event_type, allowed_values))\n        self._custom_event_type = custom_event_type",
        "docstring": "Sets the custom_event_type of this AppEvent.\n\nThis method assigns a specific category to the event, which helps in organizing and interpreting events in a meaningful way within the mParticle framework. The `custom_event_type` parameter must be one of the predefined allowed values, which include:\n- \"unknown\"\n- \"navigation\"\n- \"location\"\n- \"search\"\n- \"transaction\"\n- \"user_content\"\n- \"user_preference\"\n- \"social\"\n- \"other\"\n- \"attribution\"\n\nIf an invalid value is provided, a ValueError is raised, indicating the valid options. The `custom_event_type` is stored as a private attribute (`_custom_event_type`), which can be accessed later for event processing or reporting purposes.\n\nParameters:\n    custom_event_type (str): The type of custom event to be set.\n\nRaises:\n    ValueError: If the provided custom_event_type is not one of the allowed values.",
        "signature": "def custom_event_type(self, custom_event_type):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.event_name": {
        "code": "    def event_name(self, event_name):\n        \"\"\"Sets the name of the event for this AppEvent instance.\n\n:param event_name: The name of the event, which is required for identifying and differentiating events. \n:type: str\n\nThis method directly updates the `_event_name` attribute of the AppEvent instance, reflecting the name of the event that is being logged or recorded. The `event_name` must be provided when creating an instance of AppEvent, as it is critical for the event's identification within the broader mParticle framework. There are no return values from this setter method, and it is used to modify the internal state of the object.\"\"\"\n        '\\n        Sets the event_name of this AppEvent.\\n\\n\\n        :param event_name: The event_name of this AppEvent.\\n        :type: str\\n        '\n        self._event_name = event_name",
        "docstring": "Sets the name of the event for this AppEvent instance.\n\n:param event_name: The name of the event, which is required for identifying and differentiating events. \n:type: str\n\nThis method directly updates the `_event_name` attribute of the AppEvent instance, reflecting the name of the event that is being logged or recorded. The `event_name` must be provided when creating an instance of AppEvent, as it is critical for the event's identification within the broader mParticle framework. There are no return values from this setter method, and it is used to modify the internal state of the object.",
        "signature": "def event_name(self, event_name):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      },
      "AppEvent.custom_flags": {
        "code": "    def custom_flags(self, custom_flags):\n        \"\"\"Sets the custom flags of this AppEvent, allowing additional metadata to be associated with the event. \n\n:param custom_flags: A dictionary where the keys and values are both strings, representing custom flags \n                     that can be used to provide contextual information for the event.\n:type: dict(str, str)\n\nThis setter method updates the instance's `_custom_flags` attribute. There are no return values, and it does not interact with other parts of the code directly. However, the unique structure of the flags enables granular tracking and categorization of events within the mParticle framework.\"\"\"\n        '\\n        Sets the custom_flags of this AppEvent.\\n\\n\\n        :param custom_flags: The custom_flags of this AppEvent.\\n        :type: dict(str, str)\\n        '\n        self._custom_flags = custom_flags",
        "docstring": "Sets the custom flags of this AppEvent, allowing additional metadata to be associated with the event. \n\n:param custom_flags: A dictionary where the keys and values are both strings, representing custom flags \n                     that can be used to provide contextual information for the event.\n:type: dict(str, str)\n\nThis setter method updates the instance's `_custom_flags` attribute. There are no return values, and it does not interact with other parts of the code directly. However, the unique structure of the flags enables granular tracking and categorization of events within the mParticle framework.",
        "signature": "def custom_flags(self, custom_flags):",
        "type": "Method",
        "class_signature": "class AppEvent(object):"
      }
    },
    "mparticle/api_client.py": {
      "ApiClient.validate_attribute_bag_values": {
        "code": "    def validate_attribute_bag_values(custom_attributes):\n        \"\"\"Validate the values in a custom attributes dictionary.\n\nThis method checks if the provided `custom_attributes` dictionary contains valid values. Valid values include `None`, `float`, `bool`, integers, and strings. If any value in the dictionary is not valid, the function returns `False`. Otherwise, it returns `True`.\n\n:param custom_attributes: A dictionary where the values are expected to be of specific types (float, bool, integer, string) or None.\n:type custom_attributes: dict\n:return: Returns `True` if all values are valid or if `custom_attributes` is None; returns `False` otherwise.\n:rtype: bool\n\nThis method leverages `integer_types` and `string_types` from the `six` library to ensure compatibility between Python 2 and Python 3. These types are used to check the validity of the values in the `custom_attributes` dictionary.\"\"\"\n        return not (custom_attributes is not None and (not all((value is None or isinstance(value, (float, bool) + integer_types + string_types) for value in custom_attributes.values()))))",
        "docstring": "Validate the values in a custom attributes dictionary.\n\nThis method checks if the provided `custom_attributes` dictionary contains valid values. Valid values include `None`, `float`, `bool`, integers, and strings. If any value in the dictionary is not valid, the function returns `False`. Otherwise, it returns `True`.\n\n:param custom_attributes: A dictionary where the values are expected to be of specific types (float, bool, integer, string) or None.\n:type custom_attributes: dict\n:return: Returns `True` if all values are valid or if `custom_attributes` is None; returns `False` otherwise.\n:rtype: bool\n\nThis method leverages `integer_types` and `string_types` from the `six` library to ensure compatibility between Python 2 and Python 3. These types are used to check the validity of the values in the `custom_attributes` dictionary.",
        "signature": "def validate_attribute_bag_values(custom_attributes):",
        "type": "Method",
        "class_signature": "class ApiClient(object):"
      }
    }
  },
  "dependency_dict": {
    "mparticle/models/app_event.py:AppEvent:__init__": {},
    "mparticle/models/app_event.py:AppEvent:custom_attributes": {},
    "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {},
    "mparticle/models/app_event.py:AppEvent:create_attribution_delete_event": {},
    "mparticle/models/app_event.py:AppEvent:create_attribution_event": {}
  },
  "PRD": "# PROJECT NAME: mparticle-test_app_event\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mparticle/\n    \u251c\u2500\u2500 api_client.py\n    \u2502   \u2514\u2500\u2500 ApiClient.validate_attribute_bag_values\n    \u2514\u2500\u2500 models/\n        \u2514\u2500\u2500 app_event.py\n            \u251c\u2500\u2500 AppEvent.__init__\n            \u251c\u2500\u2500 AppEvent.create_attribution_delete_event\n            \u251c\u2500\u2500 AppEvent.create_attribution_event\n            \u251c\u2500\u2500 AppEvent.custom_attributes\n            \u251c\u2500\u2500 AppEvent.custom_event_type\n            \u251c\u2500\u2500 AppEvent.custom_flags\n            \u2514\u2500\u2500 AppEvent.event_name\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe mParticle Event API module enables seamless creation and management of app event objects, designed to support robust event tracking and attribution functionalities. This module provides capabilities for defining custom app events, specifying event types, associating attributes, and managing custom flags to facilitate detailed analytics and personalized user experiences. Additionally, it includes specialized support for attribution events, allowing developers to capture and manage campaign-related data and publisher attributions while handling deletion events when needed. By streamlining the creation, validation, and structure of event data, this module helps developers effectively record and process behavioral insights, simplifying integration with the mParticle ecosystem and enhancing event-driven application logic.\n\n## FILE 1: mparticle/models/app_event.py\n\n- CLASS METHOD: AppEvent.create_attribution_delete_event\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def create_attribution_delete_event(cls):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates a new attribution delete event instance of the AppEvent class.\n\nThis class method initializes an AppEvent with the predefined name 'attribution'\nand a custom event type of 'attribution'. It also specifies the custom attributes\nto indicate an action of 'delete'. This is useful for logging when an attribution\nevent is removed, adhering to a structured event logging system.\n\nReturns:\n    AppEvent: An instance of the AppEvent class configured as an attribution delete event.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.create_attribution_event\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def create_attribution_event(cls, publisher=None, campaign=None):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates an attribution event for the AppEvent class.\n\nThis class method facilitates the instantiation of an AppEvent object\nspecifically for tracking attribution with optional parameters for \npublisher and campaign. The event_name and custom_event_type are \nboth set to 'attribution', and custom_attributes are populated \nwith the provided campaign and publisher values.\n\nParameters:\n    publisher (str): The name of the publisher associated with the \n                     attribution event.\n    campaign (str): The name of the campaign linked to the \n                    attribution event.\n\nReturns:\n    AppEvent: An instance of the AppEvent class configured for an \n               attribution tracking event.\n\nRaises:\n    ValueError: If an invalid argument is provided, or if the \n                required fields are not properly set, though this \n                method ensures the event_name is valid by default.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.__init__\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def __init__(self, event_name=None, custom_event_type='other', timestamp_unixtime_ms=None, event_id=None, source_message_id=None, session_id=None, session_uuid=None, custom_attributes=None, location=None, device_current_state=None, media_info=None, custom_flags=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the AppEvent class, which represents an application event for the mParticle Event API.\n\nThis constructor requires an event name and optionally allows setting various parameters such as event ID, session ID, \ntimestamps, custom attributes, device information, and custom flags. The `custom_event_type` can default to 'other',\nbut will raise a ValueError if the event_name is not provided.\n\nParameters:\n- event_name (str): The name of the event, which is required.\n- custom_event_type (str): The type of the event (default is 'other'). Must be one of predefined types.\n- timestamp_unixtime_ms (int): The event's timestamp in milliseconds since epoch.\n- event_id (int): A unique identifier for the event.\n- source_message_id (str): An identifier for the source message associated with the event.\n- session_id (int): The ID of the session in which the event occurred.\n- session_uuid (str): A universally unique identifier for the session.\n- custom_attributes (dict[str, str]): Key-value pairs for custom attributes associated with the event.\n- location (GeoLocation): A GeoLocation object representing the geographic location of the event.\n- device_current_state (DeviceCurrentState): An object representing the current state of the device.\n- media_info (MediaInfo): An object containing information about media related to the event.\n- custom_flags (dict[str, str]): Custom flags for the event as key-value pairs.\n\nRaises:\n- ValueError: If the event_name is None.\n\nThis constructor also initializes two dictionaries: `swagger_types`, which maps attribute names to their data types,\nand `attribute_map`, which contains the mapping of attribute names to their corresponding JSON keys. These mappings \nassist in the serialization and deserialization of AppEvent objects within the mParticle framework.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.custom_attributes\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def custom_attributes(self, custom_attributes):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the custom attributes for this AppEvent to provide additional contextual information related to the event.\n\n:param custom_attributes: A dictionary containing key-value pairs representing custom attributes for the event. The keys and values should be strings.\n:type: dict(str, str)\n\n:raises ValueError: If the provided custom_attributes are invalid, as determined by the `mparticle.ApiClient.validate_attribute_bag_values` method, which checks the validity of the attribute values according to defined criteria.\n\nThis method interacts with the `mparticle` library, specifically by calling its `ApiClient` to validate the attributes, ensuring that only acceptable values are set. It also maintains the internal state of the `AppEvent` class by storing the validated custom attributes in the `_custom_attributes` instance variable.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.event_name\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def event_name(self, event_name):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the name of the event for this AppEvent instance.\n\n:param event_name: The name of the event, which is required for identifying and differentiating events. \n:type: str\n\nThis method directly updates the `_event_name` attribute of the AppEvent instance, reflecting the name of the event that is being logged or recorded. The `event_name` must be provided when creating an instance of AppEvent, as it is critical for the event's identification within the broader mParticle framework. There are no return values from this setter method, and it is used to modify the internal state of the object.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.custom_event_type\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def custom_event_type(self, custom_event_type):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the custom_event_type of this AppEvent.\n\nThis method assigns a specific category to the event, which helps in organizing and interpreting events in a meaningful way within the mParticle framework. The `custom_event_type` parameter must be one of the predefined allowed values, which include:\n- \"unknown\"\n- \"navigation\"\n- \"location\"\n- \"search\"\n- \"transaction\"\n- \"user_content\"\n- \"user_preference\"\n- \"social\"\n- \"other\"\n- \"attribution\"\n\nIf an invalid value is provided, a ValueError is raised, indicating the valid options. The `custom_event_type` is stored as a private attribute (`_custom_event_type`), which can be accessed later for event processing or reporting purposes.\n\nParameters:\n    custom_event_type (str): The type of custom event to be set.\n\nRaises:\n    ValueError: If the provided custom_event_type is not one of the allowed values.\n\"\"\"\n```\n\n- CLASS METHOD: AppEvent.custom_flags\n  - CLASS SIGNATURE: class AppEvent(object):\n  - SIGNATURE: def custom_flags(self, custom_flags):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the custom flags of this AppEvent, allowing additional metadata to be associated with the event. \n\n:param custom_flags: A dictionary where the keys and values are both strings, representing custom flags \n                     that can be used to provide contextual information for the event.\n:type: dict(str, str)\n\nThis setter method updates the instance's `_custom_flags` attribute. There are no return values, and it does not interact with other parts of the code directly. However, the unique structure of the flags enables granular tracking and categorization of events within the mParticle framework.\n\"\"\"\n```\n\n## FILE 2: mparticle/api_client.py\n\n- CLASS METHOD: ApiClient.validate_attribute_bag_values\n  - CLASS SIGNATURE: class ApiClient(object):\n  - SIGNATURE: def validate_attribute_bag_values(custom_attributes):\n  - DOCSTRING: \n```python\n\"\"\"\nValidate the values in a custom attributes dictionary.\n\nThis method checks if the provided `custom_attributes` dictionary contains valid values. Valid values include `None`, `float`, `bool`, integers, and strings. If any value in the dictionary is not valid, the function returns `False`. Otherwise, it returns `True`.\n\n:param custom_attributes: A dictionary where the values are expected to be of specific types (float, bool, integer, string) or None.\n:type custom_attributes: dict\n:return: Returns `True` if all values are valid or if `custom_attributes` is None; returns `False` otherwise.\n:rtype: bool\n\nThis method leverages `integer_types` and `string_types` from the `six` library to ensure compatibility between Python 2 and Python 3. These types are used to check the validity of the values in the `custom_attributes` dictionary.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mparticle/models/app_event.py": "\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\nfrom pprint import pformat\nfrom six import iteritems\nimport mparticle\n\nclass AppEvent(object):\n\n    @property\n    def timestamp_unixtime_ms(self):\n        \"\"\"\n        Gets the timestamp_unixtime_ms of this AppEvent.\n\n\n        :return: The timestamp_unixtime_ms of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._timestamp_unixtime_ms\n\n    @timestamp_unixtime_ms.setter\n    def timestamp_unixtime_ms(self, timestamp_unixtime_ms):\n        \"\"\"\n        Sets the timestamp_unixtime_ms of this AppEvent.\n\n\n        :param timestamp_unixtime_ms: The timestamp_unixtime_ms of this AppEvent.\n        :type: int\n        \"\"\"\n        self._timestamp_unixtime_ms = timestamp_unixtime_ms\n\n    @property\n    def event_id(self):\n        \"\"\"\n        Gets the event_id of this AppEvent.\n\n\n        :return: The event_id of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._event_id\n\n    @event_id.setter\n    def event_id(self, event_id):\n        \"\"\"\n        Sets the event_id of this AppEvent.\n\n\n        :param event_id: The event_id of this AppEvent.\n        :type: int\n        \"\"\"\n        self._event_id = event_id\n\n    @property\n    def source_message_id(self):\n        \"\"\"\n        Gets the source_message_id of this AppEvent.\n\n\n        :return: The source_message_id of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._source_message_id\n\n    @source_message_id.setter\n    def source_message_id(self, source_message_id):\n        \"\"\"\n        Sets the source_message_id of this AppEvent.\n\n\n        :param source_message_id: The source_message_id of this AppEvent.\n        :type: str\n        \"\"\"\n        self._source_message_id = source_message_id\n\n    @property\n    def session_id(self):\n        \"\"\"\n        Gets the session_id of this AppEvent.\n\n\n        :return: The session_id of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._session_id\n\n    @session_id.setter\n    def session_id(self, session_id):\n        \"\"\"\n        Sets the session_id of this AppEvent.\n\n\n        :param session_id: The session_id of this AppEvent.\n        :type: int\n        \"\"\"\n        self._session_id = session_id\n\n    @property\n    def session_uuid(self):\n        \"\"\"\n        Gets the session_uuid of this AppEvent.\n\n\n        :return: The session_uuid of this AppEvent.\n        :rtype: str\n        \"\"\"\n        return self._session_uuid\n\n    @session_uuid.setter\n    def session_uuid(self, session_uuid):\n        \"\"\"\n        Sets the session_uuid of this AppEvent.\n\n\n        :param session_uuid: The session_uuid of this AppEvent.\n        :type: str\n        \"\"\"\n        self._session_uuid = session_uuid\n\n    @property\n    def location(self):\n        \"\"\"\n        Gets the location of this AppEvent.\n\n\n        :return: The location of this AppEvent.\n        :rtype: GeoLocation\n        \"\"\"\n        return self._location\n\n    @location.setter\n    def location(self, location):\n        \"\"\"\n        Sets the location of this AppEvent.\n\n\n        :param location: The location of this AppEvent.\n        :type: GeoLocation\n        \"\"\"\n        self._location = location\n\n    @property\n    def device_current_state(self):\n        \"\"\"\n        Gets the device_current_state of this AppEvent.\n\n\n        :return: The device_current_state of this AppEvent.\n        :rtype: DeviceCurrentState\n        \"\"\"\n        return self._device_current_state\n\n    @device_current_state.setter\n    def device_current_state(self, device_current_state):\n        \"\"\"\n        Sets the device_current_state of this AppEvent.\n\n\n        :param device_current_state: The device_current_state of this AppEvent.\n        :type: DeviceCurrentState\n        \"\"\"\n        self._device_current_state = device_current_state\n\n    @property\n    def media_info(self):\n        \"\"\"\n        Gets the media_info of this AppEvent.\n\n\n        :return: The media_info of this AppEvent.\n        :rtype: MediaInfo\n        \"\"\"\n        return self._media_info\n\n    @media_info.setter\n    def media_info(self, media_info):\n        \"\"\"\n        Sets the media_info of this AppEvent.\n\n\n        :param media_info: The media_info of this AppEvent.\n        :type: MediaInfo\n        \"\"\"\n        self._media_info = media_info\n\n    @property\n    def ltv_amount(self):\n        \"\"\"\n        Gets the ltv_amount of this AppEvent.\n\n\n        :return: The ltv_amount of this AppEvent.\n        :rtype: int\n        \"\"\"\n        return self._ltv_amount\n\n    @ltv_amount.setter\n    def ltv_amount(self, ltv_amount):\n        \"\"\"\n        Sets the ltv_amount of this AppEvent.\n\n\n        :param ltv_amount: The ltv_amount of this AppEvent.\n        :type: int\n        \"\"\"\n        self._ltv_amount = ltv_amount\n        if self.ltv_amount is not None:\n            if self._custom_attributes is None:\n                self._custom_attributes = {}\n            self._custom_attributes['$Amount'] = self.ltv_amount\n            self._custom_attributes['MethodName'] = 'LogLTVIncrease'\n        elif self.custom_attributes is not None:\n            self._custom_attributes.pop('$Amount', None)\n            self._custom_attributes.pop('MethodName', None)\n\n    def to_dict(self):\n        \"\"\"\n        Returns the model properties as a dict\n        \"\"\"\n        result = {}\n        for attr, _ in iteritems(self.swagger_types):\n            value = getattr(self, attr)\n            if isinstance(value, list):\n                result[attr] = list(map(lambda x: x.to_dict() if hasattr(x, 'to_dict') else x, value))\n            elif hasattr(value, 'to_dict'):\n                result[attr] = value.to_dict()\n            elif isinstance(value, dict):\n                result[attr] = dict(map(lambda item: (item[0], item[1].to_dict()) if hasattr(item[1], 'to_dict') else item, value.items()))\n            else:\n                result[attr] = value\n        return result\n\n    def to_str(self):\n        \"\"\"\n        Returns the string representation of the model\n        \"\"\"\n        return pformat(self.to_dict())\n\n    def __repr__(self):\n        \"\"\"\n        For `print` and `pprint`\n        \"\"\"\n        return self.to_str()\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if both objects are equal\n        \"\"\"\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        \"\"\"\n        Returns true if both objects are not equal\n        \"\"\"\n        return not self == other",
    "mparticle/api_client.py": "\"\"\"\nCopyright 2016 SmartBear Software\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   ref: https://github.com/swagger-api/swagger-codegen\n\"\"\"\nfrom __future__ import absolute_import\nfrom . import models\nfrom .rest import RESTClientObject\nfrom .rest import ApiException\nimport os\nimport re\nimport sys\nimport urllib\nimport json\nimport mimetypes\nimport random\nimport tempfile\nimport threading\nfrom datetime import datetime\nfrom datetime import date\nfrom datetime import time\nfrom decimal import Decimal\nfrom six import iteritems\nfrom six import string_types\nfrom six import integer_types\nfrom six import text_type\ntry:\n    from urllib.parse import quote\nexcept ImportError:\n    from urllib import quote\ntry:\n    long\nexcept NameError:\n    long = int\nfrom .configuration import Configuration\n\nclass ApiClient(object):\n    \"\"\"\n    Generic API client for Swagger client library builds.\n\n    Swagger generic API client. This client handles the client-\n    server communication, and is invariant across implementations. Specifics of\n    the methods and models for each application are generated from the Swagger\n    templates.\n\n    :param host: The base path for the server to call.\n    :param header_name: a header to pass when making calls to the API.\n    :param header_value: a header value to pass when making calls to the API.\n    \"\"\"\n\n    def __init__(self, host=None, header_name=None, header_value=None, cookie=None, configuration=None):\n        \"\"\"\n        Constructor of the class.\n        \"\"\"\n        self.config = configuration\n        self.rest_client = RESTClientObject(config=configuration)\n        self.default_headers = {}\n        if header_name is not None:\n            self.default_headers[header_name] = header_value\n        if host is None:\n            self.host = self.config.host\n        else:\n            self.host = host\n        self.cookie = cookie\n        self.user_agent = 'mParticle Python client/0.16.0'\n\n    @property\n    def user_agent(self):\n        \"\"\"\n        Gets user agent.\n        \"\"\"\n        return self.default_headers['User-Agent']\n\n    @user_agent.setter\n    def user_agent(self, value):\n        \"\"\"\n        Sets user agent.\n        \"\"\"\n        self.default_headers['User-Agent'] = value\n\n    def set_default_header(self, header_name, header_value):\n        self.default_headers[header_name] = header_value\n\n    def __call_api(self, resource_path, method, path_params=None, query_params=None, header_params=None, body=None, post_params=None, files=None, response_type=None, auth_settings=None, callback=None, _return_http_data_only=None):\n        header_params = header_params or {}\n        header_params.update(self.default_headers)\n        if self.cookie:\n            header_params['Cookie'] = self.cookie\n        if header_params:\n            header_params = ApiClient.sanitize_for_serialization(header_params)\n        if path_params:\n            path_params = ApiClient.sanitize_for_serialization(path_params)\n            for k, v in iteritems(path_params):\n                replacement = quote(str(self.to_path_value(v)))\n                resource_path = resource_path.replace('{' + k + '}', replacement)\n        if query_params:\n            query_params = ApiClient.sanitize_for_serialization(query_params)\n            query_params = {k: self.to_path_value(v) for k, v in iteritems(query_params)}\n        if post_params or files:\n            post_params = self.prepare_post_parameters(post_params, files)\n            post_params = ApiClient.sanitize_for_serialization(post_params)\n        self.update_params_for_auth(header_params, query_params, auth_settings)\n        if body:\n            body = ApiClient.sanitize_for_serialization(body)\n        url = self.host + resource_path\n        try:\n            response_data = self.request(method, url, query_params=query_params, headers=header_params, post_params=post_params, body=body)\n        except Exception as api_exception:\n            if callback:\n                callback(api_exception)\n                return\n            else:\n                raise\n        self.last_response = response_data\n        if response_type:\n            deserialized_data = self.deserialize(response_data, response_type)\n        else:\n            deserialized_data = None\n        if callback:\n            callback(deserialized_data) if _return_http_data_only else callback((deserialized_data, response_data.status, response_data.getheaders()))\n        elif _return_http_data_only:\n            return deserialized_data\n        else:\n            return (deserialized_data, response_data.status, response_data.getheaders())\n\n    def to_path_value(self, obj):\n        \"\"\"\n        Takes value and turn it into a string suitable for inclusion in\n        the path, by url-encoding.\n\n        :param obj: object or string value.\n\n        :return string: quoted value.\n        \"\"\"\n        if type(obj) == list:\n            return ','.join(obj)\n        else:\n            return str(obj)\n\n    @staticmethod\n    def sanitize_for_serialization(obj):\n        \"\"\"\n        Builds a JSON POST object.\n\n        If obj is None, return None.\n        If obj is str, int, long, float, bool, return directly.\n        If obj is datetime.datetime, datetime.date, datetime.time\n            convert to string in iso8601 format.\n        if obj is decimal.Decimal\n            convert to string\n        If obj is list, sanitize each element in the list.\n        If obj is dict, return the dict.\n        If obj is swagger model, return the properties dict.\n\n        :param obj: The data to serialize.\n        :return: The serialized form of data.\n        \"\"\"\n        types = string_types + integer_types + (float, bool, tuple)\n        if isinstance(obj, type(None)):\n            return None\n        elif isinstance(obj, types):\n            return obj\n        elif isinstance(obj, list):\n            return [ApiClient.sanitize_for_serialization(sub_obj) for sub_obj in obj]\n        elif isinstance(obj, (datetime, date, time)):\n            return obj.isoformat()\n        elif isinstance(obj, Decimal):\n            return str(obj)\n        else:\n            if isinstance(obj, dict):\n                obj_dict = obj\n            else:\n                obj_dict = {obj.attribute_map[attr]: getattr(obj, attr) for attr, _ in iteritems(obj.swagger_types) if getattr(obj, attr) is not None}\n            return {key: ApiClient.sanitize_for_serialization(val) for key, val in iteritems(obj_dict)}\n\n    def deserialize(self, response, response_type):\n        \"\"\"\n        Deserializes response into an object.\n\n        :param response: RESTResponse object to be deserialized.\n        :param response_type: class literal for\n            deserialzied object, or string of class name.\n\n        :return: deserialized object.\n        \"\"\"\n        if 'file' == response_type:\n            return self.__deserialize_file(response)\n        try:\n            data = json.loads(response.data)\n        except ValueError:\n            data = response.data\n        return self.__deserialize(data, response_type)\n\n    def __deserialize(self, data, klass):\n        \"\"\"\n        Deserializes dict, list, str into an object.\n\n        :param data: dict, list or str.\n        :param klass: class literal, or string of class name.\n\n        :return: object.\n        \"\"\"\n        if data is None:\n            return None\n        if type(klass) == str:\n            if klass.startswith('list['):\n                sub_kls = re.match('list\\\\[(.*)\\\\]', klass).group(1)\n                return [self.__deserialize(sub_data, sub_kls) for sub_data in data]\n            if klass.startswith('dict('):\n                sub_kls = re.match('dict\\\\(([^,]*), (.*)\\\\)', klass).group(2)\n                return {k: self.__deserialize(v, sub_kls) for k, v in iteritems(data)}\n            if klass in ['int', 'long', 'float', 'str', 'bool', 'date', 'datetime', 'object']:\n                klass = eval(klass)\n            else:\n                klass = eval('models.' + klass)\n        if klass in list(integer_types) + list(string_types) + [float, text_type, bool]:\n            return self.__deserialize_primitive(data, klass)\n        elif klass == object:\n            return self.__deserialize_object(data)\n        elif klass == date:\n            return self.__deserialize_date(data)\n        elif klass == datetime:\n            return self.__deserialize_datatime(data)\n        else:\n            return self.__deserialize_model(data, klass)\n\n    def call_api(self, resource_path, method, path_params=None, query_params=None, header_params=None, body=None, post_params=None, files=None, response_type=None, auth_settings=None, callback=None, _return_http_data_only=None):\n        \"\"\"\n        Makes the HTTP request (synchronous) and return the deserialized data.\n        To make an async request, define a function for callback.\n\n        :param resource_path: Path to method endpoint.\n        :param method: Method to call.\n        :param path_params: Path parameters in the url.\n        :param query_params: Query parameters in the url.\n        :param header_params: Header parameters to be\n            placed in the request header.\n        :param body: Request body.\n        :param post_params dict: Request post form parameters,\n            for `application/x-www-form-urlencoded`, `multipart/form-data`.\n        :param auth_settings list: Auth Settings names for the request.\n        :param response: Response data type.\n        :param files dict: key -> filename, value -> filepath,\n            for `multipart/form-data`.\n        :param callback function: Callback function for asynchronous request.\n            If provide this parameter,\n            the request will be called asynchronously.\n        :param _return_http_data_only: response data without head status code and headers\n        :return:\n            If provide parameter callback,\n            the request will be called asynchronously.\n            The method will return the request thread.\n            If parameter callback is None,\n            then the method will return the response directly.\n        \"\"\"\n        if callback is None:\n            return self.__call_api(resource_path, method, path_params, query_params, header_params, body, post_params, files, response_type, auth_settings, callback, _return_http_data_only)\n        else:\n            thread = threading.Thread(target=self.__call_api, args=(resource_path, method, path_params, query_params, header_params, body, post_params, files, response_type, auth_settings, callback, _return_http_data_only))\n        thread.start()\n        return thread\n\n    def request(self, method, url, query_params=None, headers=None, post_params=None, body=None):\n        \"\"\"\n        Makes the HTTP request using RESTClient.\n        \"\"\"\n        if method == 'GET':\n            return self.rest_client.GET(url, query_params=query_params, headers=headers)\n        elif method == 'HEAD':\n            return self.rest_client.HEAD(url, query_params=query_params, headers=headers)\n        elif method == 'OPTIONS':\n            return self.rest_client.OPTIONS(url, query_params=query_params, headers=headers, post_params=post_params, body=body)\n        elif method == 'POST':\n            return self.rest_client.POST(url, query_params=query_params, headers=headers, post_params=post_params, body=body)\n        elif method == 'PUT':\n            return self.rest_client.PUT(url, query_params=query_params, headers=headers, post_params=post_params, body=body)\n        elif method == 'PATCH':\n            return self.rest_client.PATCH(url, query_params=query_params, headers=headers, post_params=post_params, body=body)\n        elif method == 'DELETE':\n            return self.rest_client.DELETE(url, query_params=query_params, headers=headers, body=body)\n        else:\n            raise ValueError('http method must be `GET`, `HEAD`, `POST`, `PATCH`, `PUT` or `DELETE`.')\n\n    def prepare_post_parameters(self, post_params=None, files=None):\n        \"\"\"\n        Builds form parameters.\n\n        :param post_params: Normal form parameters.\n        :param files: File parameters.\n        :return: Form parameters with files.\n        \"\"\"\n        params = []\n        if post_params:\n            params = post_params\n        if files:\n            for k, v in iteritems(files):\n                if not v:\n                    continue\n                file_names = v if type(v) is list else [v]\n                for n in file_names:\n                    with open(n, 'rb') as f:\n                        filename = os.path.basename(f.name)\n                        filedata = f.read()\n                        mimetype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'\n                        params.append(tuple([k, tuple([filename, filedata, mimetype])]))\n        return params\n\n    def select_header_accept(self, accepts):\n        \"\"\"\n        Returns `Accept` based on an array of accepts provided.\n\n        :param accepts: List of headers.\n        :return: Accept (e.g. application/json).\n        \"\"\"\n        if not accepts:\n            return\n        accepts = list(map(lambda x: x.lower(), accepts))\n        if 'application/json' in accepts:\n            return 'application/json'\n        else:\n            return ', '.join(accepts)\n\n    def select_header_content_type(self, content_types):\n        \"\"\"\n        Returns `Content-Type` based on an array of content_types provided.\n\n        :param content_types: List of content-types.\n        :return: Content-Type (e.g. application/json).\n        \"\"\"\n        if not content_types:\n            return 'application/json'\n        content_types = list(map(lambda x: x.lower(), content_types))\n        if 'application/json' in content_types:\n            return 'application/json'\n        else:\n            return content_types[0]\n\n    def update_params_for_auth(self, headers, querys, auth_settings):\n        \"\"\"\n        Updates header and query params based on authentication setting.\n\n        :param headers: Header parameters dict to be updated.\n        :param querys: Query parameters dict to be updated.\n        :param auth_settings: Authentication setting identifiers list.\n        \"\"\"\n        if not auth_settings:\n            return\n        for auth in auth_settings:\n            auth_setting = self.config.auth_settings().get(auth)\n            if auth_setting:\n                if not auth_setting['value']:\n                    continue\n                elif auth_setting['in'] == 'header':\n                    headers[auth_setting['key']] = auth_setting['value']\n                elif auth_setting['in'] == 'query':\n                    querys[auth_setting['key']] = auth_setting['value']\n                else:\n                    raise ValueError('Authentication token must be in `query` or `header`')\n\n    def __deserialize_file(self, response):\n        \"\"\"\n        Saves response body into a file in a temporary folder,\n        using the filename from the `Content-Disposition` header if provided.\n\n        :param response:  RESTResponse.\n        :return: file path.\n        \"\"\"\n        fd, path = tempfile.mkstemp(dir=self.config.temp_folder_path)\n        os.close(fd)\n        os.remove(path)\n        content_disposition = response.getheader('Content-Disposition')\n        if content_disposition:\n            filename = re.search('filename=[\\\\\\'\"]?([^\\\\\\'\"\\\\s]+)[\\\\\\'\"]?', content_disposition).group(1)\n            path = os.path.join(os.path.dirname(path), filename)\n        with open(path, 'w') as f:\n            f.write(response.data)\n        return path\n\n    def __deserialize_primitive(self, data, klass):\n        \"\"\"\n        Deserializes string to primitive type.\n\n        :param data: str.\n        :param klass: class literal.\n\n        :return: int, long, float, str, bool.\n        \"\"\"\n        try:\n            value = klass(data)\n        except UnicodeEncodeError:\n            value = unicode(data)\n        except TypeError:\n            value = data\n        return value\n\n    def __deserialize_object(self, value):\n        \"\"\"\n        Return a original value.\n\n        :return: object.\n        \"\"\"\n        return value\n\n    def __deserialize_date(self, string):\n        \"\"\"\n        Deserializes string to date.\n\n        :param string: str.\n        :return: date.\n        \"\"\"\n        try:\n            from dateutil.parser import parse\n            return parse(string).date()\n        except ImportError:\n            return string\n        except ValueError:\n            raise ApiException(status=0, reason='Failed to parse `{0}` into a date object'.format(string))\n\n    def __deserialize_datatime(self, string):\n        \"\"\"\n        Deserializes string to datetime.\n\n        The string should be in iso8601 datetime format.\n\n        :param string: str.\n        :return: datetime.\n        \"\"\"\n        try:\n            from dateutil.parser import parse\n            return parse(string)\n        except ImportError:\n            return string\n        except ValueError:\n            raise ApiException(status=0, reason='Failed to parse `{0}` into a datetime object'.format(string))\n\n    def __deserialize_model(self, data, klass):\n        \"\"\"\n        Deserializes list or dict to model.\n\n        :param data: dict, list.\n        :param klass: class literal.\n        :return: model object.\n        \"\"\"\n        instance = klass()\n        for attr, attr_type in iteritems(instance.swagger_types):\n            if data is not None and instance.attribute_map[attr] in data and isinstance(data, (list, dict)):\n                value = data[instance.attribute_map[attr]]\n                setattr(instance, attr, self.__deserialize(value, attr_type))\n        return instance"
  },
  "call_tree": {
    "test/test_app_event.py:TestAppEvent:testAppEvent": {
      "mparticle/models/app_event.py:AppEvent:__init__": {
        "mparticle/models/app_event.py:AppEvent:custom_attributes": {
          "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
        }
      },
      "mparticle/models/app_event.py:AppEvent:event_name": {},
      "mparticle/models/app_event.py:AppEvent:custom_event_type": {},
      "mparticle/models/app_event.py:AppEvent:custom_attributes": {}
    },
    "test/test_app_event.py:TestAppEvent:testAppEventAttributeValues": {
      "mparticle/models/app_event.py:AppEvent:__init__": {
        "mparticle/models/app_event.py:AppEvent:custom_attributes": {
          "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
        }
      },
      "mparticle/models/app_event.py:AppEvent:custom_attributes": {
        "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
      }
    },
    "test/test_app_event.py:TestAppEvent:testAppEventCustomFlags": {
      "mparticle/models/app_event.py:AppEvent:__init__": {
        "mparticle/models/app_event.py:AppEvent:custom_attributes": {
          "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
        }
      },
      "mparticle/models/app_event.py:AppEvent:custom_flags": {}
    },
    "test/test_app_event.py:TestAppEvent:testAttributionDeleteEvent": {
      "mparticle/models/app_event.py:AppEvent:create_attribution_delete_event": {
        "mparticle/models/app_event.py:AppEvent:__init__": {
          "mparticle/models/app_event.py:AppEvent:custom_attributes": {
            "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
          }
        }
      },
      "mparticle/models/app_event.py:AppEvent:custom_event_type": {},
      "mparticle/models/app_event.py:AppEvent:event_name": {},
      "mparticle/models/app_event.py:AppEvent:custom_attributes": {}
    },
    "test/test_app_event.py:TestAppEvent:testAttributionEvent": {
      "mparticle/models/app_event.py:AppEvent:create_attribution_event": {
        "mparticle/models/app_event.py:AppEvent:__init__": {
          "mparticle/models/app_event.py:AppEvent:custom_attributes": {
            "mparticle/api_client.py:ApiClient:validate_attribute_bag_values": {}
          }
        }
      },
      "mparticle/models/app_event.py:AppEvent:custom_event_type": {},
      "mparticle/models/app_event.py:AppEvent:event_name": {},
      "mparticle/models/app_event.py:AppEvent:custom_attributes": {}
    }
  }
}