{
  "dir_path": "/app/selenium_wire",
  "package_name": "selenium_wire",
  "sample_name": "selenium_wire-test_utils",
  "src_dir": "seleniumwire/",
  "test_dir": "tests/",
  "test_file": "tests/seleniumwire/test_utils.py",
  "test_code": "import contextlib\nimport gzip\nimport os\nimport zlib\nfrom io import BytesIO\nfrom pathlib import Path\nfrom unittest import TestCase\nfrom unittest.mock import call, mock_open, patch\n\nfrom seleniumwire.utils import (\n    build_proxy_args,\n    decode,\n    extract_cert,\n    extract_cert_and_key,\n    get_upstream_proxy,\n    urlsafe_address,\n)\n\n\nclass GetUpstreamProxyTest(TestCase):\n    def test_get_config(self):\n        options = {\n            'proxy': {\n                'http': 'http://username1:password1@server1:8888',\n                'https': 'https://username2:password2@server2:8888',\n                'no_proxy': 'localhost',\n            }\n        }\n\n        proxy = get_upstream_proxy(options)\n\n        http = proxy['http']\n        self.assertEqual('http', http.scheme)\n        self.assertEqual('username1', http.username)\n        self.assertEqual('password1', http.password)\n        self.assertEqual('server1:8888', http.hostport)\n\n        https = proxy['https']\n        self.assertEqual('https', https.scheme)\n        self.assertEqual('username2', https.username)\n        self.assertEqual('password2', https.password)\n        self.assertEqual('server2:8888', https.hostport)\n\n        self.assertEqual(['localhost'], proxy['no_proxy'])\n\n    def test_get_from_env(self):\n        with self.set_env(\n            HTTP_PROXY='http://username1:password1@server1:8888',\n            HTTPS_PROXY='https://username2:password2@server2:8888',\n            NO_PROXY='localhost',\n        ):\n\n            proxy = get_upstream_proxy({})\n\n            http = proxy['http']\n            self.assertEqual('http', http.scheme)\n            self.assertEqual('username1', http.username)\n            self.assertEqual('password1', http.password)\n            self.assertEqual('server1:8888', http.hostport)\n\n            https = proxy['https']\n            self.assertEqual('https', https.scheme)\n            self.assertEqual('username2', https.username)\n            self.assertEqual('password2', https.password)\n            self.assertEqual('server2:8888', https.hostport)\n\n            self.assertEqual(['localhost'], proxy['no_proxy'])\n\n    def test_merge(self):\n        options = {'proxy': {'https': 'https://username3:password3@server3:8888', 'no_proxy': 'localhost'}}\n\n        with self.set_env(\n            HTTP_PROXY='http://username1:password1@server1:8888',\n            HTTPS_PROXY='https://username2:password2@server2:8888',\n            NO_PROXY='127.0.0.1',\n        ):\n\n            proxy = get_upstream_proxy(options)\n\n            http = proxy['http']\n            self.assertEqual('http', http.scheme)\n            self.assertEqual('username1', http.username)\n            self.assertEqual('password1', http.password)\n            self.assertEqual('server1:8888', http.hostport)\n\n            # The dict config overrides that defined in env variables\n            https = proxy['https']\n            self.assertEqual('https', https.scheme)\n            self.assertEqual('username3', https.username)\n            self.assertEqual('password3', https.password)\n            self.assertEqual('server3:8888', https.hostport)\n\n            self.assertEqual(['localhost'], proxy['no_proxy'])\n\n    def test_empty_password(self):\n        options = {\n            'proxy': {\n                'https': 'https://username:@server:8888',\n            }\n        }\n\n        proxy = get_upstream_proxy(options)\n\n        https = proxy['https']\n        self.assertEqual('https', https.scheme)\n        self.assertEqual('username', https.username)\n        self.assertEqual('', https.password)\n        self.assertEqual('server:8888', https.hostport)\n\n    def test_no_proxy(self):\n        options = {\n            'proxy': {\n                'https': 'https://username:@server:8888',\n                'no_proxy': 'localhost:8081, example.com  , test.com:80',\n            }\n        }\n\n        proxy = get_upstream_proxy(options)\n\n        self.assertEqual(['localhost:8081', 'example.com', 'test.com:80'], proxy['no_proxy'])\n\n    def test_no_proxy_as_list(self):\n        options = {\n            'proxy': {\n                'https': 'https://username:@server:8888',\n                'no_proxy': ['localhost:8081', 'example.com', 'test.com:80'],\n            }\n        }\n\n        proxy = get_upstream_proxy(options)\n\n        self.assertEqual(['localhost:8081', 'example.com', 'test.com:80'], proxy['no_proxy'])\n\n    def test_none(self):\n        options = None\n\n        proxy = get_upstream_proxy(options)\n\n        self.assertEqual({}, proxy)\n\n    @contextlib.contextmanager\n    def set_env(self, **environ):\n        \"\"\"Context manager used to temporarily set environment vars.\"\"\"\n        old_environ = dict(os.environ)\n        os.environ.update(environ)\n        try:\n            yield\n        finally:\n            os.environ.clear()\n            os.environ.update(old_environ)\n\n\nclass BuildProxyArgsTest(TestCase):\n    def test_args_both_schemes(self):\n        options = {\n            'proxy': {\n                'http': 'http://proxyserver:8080',\n                # We pick https when both are specified and the same\n                'https': 'https://proxyserver:8080',\n            },\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(args, {'mode': 'upstream:https://proxyserver:8080'})\n\n    def test_args_single_scheme(self):\n        options = {\n            'proxy': {\n                'http': 'http://proxyserver:8080',\n            },\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(args, {'mode': 'upstream:http://proxyserver:8080'})\n\n    def test_different_schemes(self):\n        options = {\n            'proxy': {'http': 'http://proxyserver1:8080', 'https': 'https://proxyserver2:8080'},\n        }\n\n        with self.assertRaises(ValueError):\n            build_proxy_args(get_upstream_proxy(options))\n\n    def test_args_auth(self):\n        options = {\n            'proxy': {\n                'https': 'https://user:pass@proxyserver:8080',\n            },\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(args, {'mode': 'upstream:https://proxyserver:8080', 'upstream_auth': 'user:pass'})\n\n    def test_args_auth_empty_password(self):\n        options = {\n            'proxy': {\n                'https': 'https://user:@proxyserver:8080',\n            },\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(args, {'mode': 'upstream:https://proxyserver:8080', 'upstream_auth': 'user:'})\n\n    def test_args_custom_auth(self):\n        options = {\n            'proxy': {'https': 'https://proxyserver:8080', 'custom_authorization': 'Bearer 12345'},\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(args, {'mode': 'upstream:https://proxyserver:8080', 'upstream_custom_auth': 'Bearer 12345'})\n\n    def test_args_no_proxy(self):\n        options = {\n            'proxy': {'https': 'https://proxyserver:8080', 'no_proxy': 'localhost:9090, example.com'},\n        }\n\n        args = build_proxy_args(get_upstream_proxy(options))\n\n        self.assertEqual(\n            args, {'mode': 'upstream:https://proxyserver:8080', 'no_proxy': ['localhost:9090', 'example.com']}\n        )\n\n\nclass ExtractCertTest(TestCase):\n    @patch('seleniumwire.utils.os.getcwd')\n    @patch('seleniumwire.utils.pkgutil')\n    def test_extract_cert(self, mock_pkgutil, mock_getcwd):\n        mock_pkgutil.get_data.return_value = b'cert_data'\n        mock_getcwd.return_value = 'cwd'\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.open', m_open):\n            extract_cert()\n\n        mock_pkgutil.get_data.assert_called_once_with('seleniumwire', 'ca.crt')\n        m_open.assert_called_once_with(Path('cwd', 'ca.crt'), 'wb')\n        m_open.return_value.write.assert_called_once_with(b'cert_data')\n\n    @patch('seleniumwire.utils.pkgutil')\n    def test_extract_cert_not_found(self, mock_pkgutil):\n        mock_pkgutil.get_data.side_effect = FileNotFoundError\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.open', m_open):\n            extract_cert('foo.crt')\n\n        mock_pkgutil.get_data.assert_called_once_with('seleniumwire', 'foo.crt')\n        m_open.assert_not_called()\n\n    @patch('seleniumwire.utils.os')\n    @patch('seleniumwire.utils.pkgutil')\n    @patch('seleniumwire.utils.Path')\n    def test_extract_cert_and_key(self, mock_path, mock_pkgutil, mock_os):\n        mock_path.return_value.exists.return_value = False\n        mock_pkgutil.get_data.side_effect = (b'cert_data', b'key_data')\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.open', m_open):\n            extract_cert_and_key(Path('some', 'path'))\n\n        mock_os.makedirs.assert_called_once_with(Path('some', 'path'), exist_ok=True)\n        mock_path.assert_called_once_with(Path('some', 'path'), 'seleniumwire-ca.pem')\n        mock_pkgutil.get_data.assert_has_calls([call('seleniumwire', 'ca.crt'), call('seleniumwire', 'ca.key')])\n        m_open.assert_called_once_with(mock_path.return_value, 'wb')\n        m_open.return_value.write.assert_called_once_with(b'cert_data\\nkey_data')\n\n    @patch('seleniumwire.utils.os')\n    @patch('seleniumwire.utils.pkgutil')\n    @patch('seleniumwire.utils.Path')\n    def test_extract_user_supplied_cert_and_key(self, mock_path, mock_pkgutil, mock_os):\n        mock_path.return_value.exists.return_value = False\n        mock_path.return_value.read_bytes.side_effect = (b'cert_data', b'key_data')\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.open', m_open):\n            extract_cert_and_key(Path('some', 'path'), cert_path='cert_path', key_path='key_path')\n\n        mock_os.makedirs.assert_called_once_with(Path('some', 'path'), exist_ok=True)\n        mock_path.assert_has_calls(\n            [\n                call(Path('some', 'path'), 'seleniumwire-ca.pem'),\n                call().exists(),\n                call('cert_path'),\n                call().read_bytes(),\n                call('key_path'),\n                call().read_bytes(),\n            ]\n        )\n        assert mock_pkgutil.get_data.call_count == 0\n        m_open.assert_called_once_with(mock_path.return_value, 'wb')\n        m_open.return_value.write.assert_called_once_with(b'cert_data\\nkey_data')\n\n    @patch('seleniumwire.utils.Path')\n    def test_extract_user_supplied_cert_missing_key(self, mock_path):\n        mock_path.return_value.exists.return_value = False\n\n        with patch('seleniumwire.utils.os'), self.assertRaises(ValueError):\n            extract_cert_and_key(Path('some', 'path'), cert_path='cert_path')\n\n    @patch('seleniumwire.utils.Path')\n    def test_extract_cert_and_key_exists(self, mock_path):\n        mock_path.return_value.exists.return_value = True\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.os'), patch('seleniumwire.utils.open', m_open):\n            extract_cert_and_key(Path('some', 'path'))\n\n        m_open.assert_not_called()\n\n    @patch('seleniumwire.utils.Path')\n    def test_extract_cert_and_key_no_check(self, mock_path):\n        mock_path.return_value.exists.return_value = True\n        m_open = mock_open()\n\n        with patch('seleniumwire.utils.os'), patch('seleniumwire.utils.open', m_open):\n            extract_cert_and_key(Path('some', 'path'), check_exists=False)\n\n        m_open.assert_called_once()\n\n\ndef test_urlsafe_address_ipv4():\n    assert urlsafe_address(('192.168.0.1', 9999)) == ('192.168.0.1', 9999)\n\n\ndef test_urlsafe_address_ipv6():\n    assert urlsafe_address(('::ffff:127.0.0.1', 9999, 0, 0)) == ('[::ffff:127.0.0.1]', 9999)\n\n\nclass DecodeTest(TestCase):\n    def test_decode_gzip_data(self):\n        data = b'test response body'\n        compressed = BytesIO()\n\n        with gzip.GzipFile(fileobj=compressed, mode='wb') as f:\n            f.write(data)\n\n        self.assertEqual(decode(compressed.getvalue(), 'gzip'), data)\n\n    def test_decode_zlib_data(self):\n        data = b'test response body'\n        compressed = zlib.compress(data)\n\n        self.assertEqual(decode(compressed, 'deflate'), data)\n\n    def test_decode_error(self):\n        data = b'test response body'\n\n        with self.assertRaises(ValueError):\n            self.assertEqual(decode(data, 'gzip'), data)\n",
  "GT_file_code": {
    "seleniumwire/utils.py": "import collections.abc\nimport logging\nimport os\nimport pkgutil\nfrom collections import namedtuple\nfrom pathlib import Path\nfrom typing import Dict, NamedTuple\nfrom urllib.request import _parse_proxy\n\nfrom seleniumwire.thirdparty.mitmproxy.net.http import encoding as decoder\n\nlog = logging.getLogger(__name__)\n\nROOT_CERT = 'ca.crt'\nROOT_KEY = 'ca.key'\nCOMBINED_CERT = 'seleniumwire-ca.pem'\n\nMITM_MODE = 'mode'\nMITM_UPSTREAM_AUTH = 'upstream_auth'\nMITM_UPSTREAM_CUSTOM_AUTH = 'upstream_custom_auth'\nMITM_NO_PROXY = 'no_proxy'\n\n\ndef get_upstream_proxy(options):\n    \"\"\"Get the upstream proxy configuration from the options dictionary.\n    This will be overridden with any configuration found in the environment\n    variables HTTP_PROXY, HTTPS_PROXY, NO_PROXY\n\n    The configuration will be returned as a dictionary with keys 'http',\n    'https' and 'no_proxy'. The value of the 'http' and 'https' keys will\n    be a named tuple with the attributes:\n        scheme, username, password, hostport\n    The value of 'no_proxy' will be a list.\n\n    Note that the keys will only be present in the dictionary when relevant\n    proxy configuration exists.\n\n    Args:\n        options: The selenium wire options.\n    Returns: A dictionary.\n    \"\"\"\n    proxy_options = (options or {}).pop('proxy', {})\n\n    http_proxy = os.environ.get('HTTP_PROXY')\n    https_proxy = os.environ.get('HTTPS_PROXY')\n    no_proxy = os.environ.get('NO_PROXY')\n\n    merged = {}\n\n    if http_proxy:\n        merged['http'] = http_proxy\n    if https_proxy:\n        merged['https'] = https_proxy\n    if no_proxy:\n        merged['no_proxy'] = no_proxy\n\n    merged.update(proxy_options)\n\n    no_proxy = merged.get('no_proxy')\n    if isinstance(no_proxy, str):\n        merged['no_proxy'] = [h.strip() for h in no_proxy.split(',')]\n\n    conf = namedtuple('ProxyConf', 'scheme username password hostport')\n\n    for proxy_type in ('http', 'https'):\n        # Parse the upstream proxy URL into (scheme, username, password, hostport)\n        # for ease of access.\n        if merged.get(proxy_type) is not None:\n            merged[proxy_type] = conf(*_parse_proxy(merged[proxy_type]))\n\n    return merged\n\n\ndef build_proxy_args(proxy_config: Dict[str, NamedTuple]) -> Dict[str, str]:\n    \"\"\"Build the arguments needed to pass an upstream proxy to mitmproxy.\n\n    Args:\n        proxy_config: The proxy config parsed out of the Selenium Wire options.\n    Returns: A dictionary of arguments suitable for passing to mitmproxy.\n    \"\"\"\n    http_proxy = proxy_config.get('http')\n    https_proxy = proxy_config.get('https')\n    conf = None\n\n    if http_proxy and https_proxy:\n        if http_proxy.hostport != https_proxy.hostport:  # noqa\n            # We only support a single upstream proxy server\n            raise ValueError('Different settings for http and https proxy servers not supported')\n\n        conf = https_proxy\n    elif http_proxy:\n        conf = http_proxy\n    elif https_proxy:\n        conf = https_proxy\n\n    args = {}\n\n    if conf:\n        scheme, username, password, hostport = conf\n\n        args[MITM_MODE] = 'upstream:{}://{}'.format(scheme, hostport)\n\n        if username:\n            args[MITM_UPSTREAM_AUTH] = '{}:{}'.format(username, password)\n\n        custom_auth = proxy_config.get('custom_authorization')\n\n        if custom_auth:\n            args[MITM_UPSTREAM_CUSTOM_AUTH] = custom_auth\n\n        no_proxy = proxy_config.get('no_proxy')\n\n        if no_proxy:\n            args[MITM_NO_PROXY] = no_proxy\n\n    return args\n\n\ndef extract_cert(cert_name='ca.crt'):\n    \"\"\"Extracts the root certificate to the current working directory.\"\"\"\n\n    try:\n        cert = pkgutil.get_data(__package__, cert_name)\n    except FileNotFoundError:\n        log.error(\"Invalid certificate '{}'\".format(cert_name))\n    else:\n        with open(Path(os.getcwd(), cert_name), 'wb') as out:\n            out.write(cert)\n        log.info('{} extracted. You can now import this into a browser.'.format(cert_name))\n\n\ndef extract_cert_and_key(dest_folder, cert_path=None, key_path=None, check_exists=True):\n    \"\"\"Extracts the root certificate and key and combines them into a\n    single file called seleniumwire-ca.pem in the specified destination\n    folder.\n\n    Args:\n        dest_folder: The destination folder that the combined certificate\n            and key will be written to.\n        cert_path: Optional path to the root certificate. When not supplied\n            selenium wire's own root certificate will be used.\n        key_path: Optional path to the private key. When not supplied\n            selenium wire's own private key will be used. Note that the key\n            must always be supplied when a certificate is supplied.\n        check_exists: If True the combined file will not be overwritten\n            if it already exists in the destination folder.\n    \"\"\"\n    os.makedirs(dest_folder, exist_ok=True)\n    combined_path = Path(dest_folder, COMBINED_CERT)\n    if check_exists and combined_path.exists():\n        return\n\n    if cert_path is not None and key_path is not None:\n        root_cert = Path(cert_path).read_bytes()\n        root_key = Path(key_path).read_bytes()\n    elif cert_path is not None or key_path is not None:\n        raise ValueError('A certificate and key must both be supplied')\n    else:\n        root_cert = pkgutil.get_data(__package__, ROOT_CERT)\n        root_key = pkgutil.get_data(__package__, ROOT_KEY)\n\n    with open(combined_path, 'wb') as f_out:\n        f_out.write(root_cert + b'\\n' + root_key)\n\n\ndef is_list_alike(container):\n    return isinstance(container, collections.abc.Sequence) and not isinstance(container, str)\n\n\ndef urlsafe_address(address):\n    \"\"\"Make an address safe to use in a URL.\n\n    Args:\n        address: A tuple of address information.\n    Returns:\n        A 2-tuple of url-safe (address, port)\n    \"\"\"\n    addr, port, *rest = address\n\n    if rest:\n        # An IPv6 address needs to be surrounded by square brackets\n        addr = f'[{addr}]'\n\n    return addr, port\n\n\ndef decode(data: bytes, encoding: str) -> bytes:\n    \"\"\"Attempt to decode data based on the supplied encoding.\n\n    If decoding fails a ValueError is raised.\n\n    Args:\n        data: The encoded data.\n        encoding: The encoding type.\n    Returns: The decoded data.\n    Raises: ValueError if the data could not be decoded.\n    \"\"\"\n    return decoder.decode(data, encoding)\n"
  },
  "GT_src_dict": {
    "seleniumwire/utils.py": {
      "get_upstream_proxy": {
        "code": "def get_upstream_proxy(options):\n    \"\"\"Get the upstream proxy configuration from the provided options dictionary, incorporating values from relevant environment variables. The function merges settings from the 'proxy' key in the options with values from the environment variables HTTP_PROXY, HTTPS_PROXY, and NO_PROXY.\n\nParameters:\n    options (dict): A dictionary containing Selenium Wire options, potentially including a 'proxy' key with proxy settings.\n\nReturns:\n    dict: A dictionary containing upstream proxy configurations with keys 'http', 'https', and 'no_proxy'. \n          The 'http' and 'https' keys map to a named tuple with attributes scheme, username, password, and hostport, \n          while 'no_proxy' maps to a list of addresses that should bypass the proxy.\n\nNotes:\n    - The proxy configuration is parsed using the _parse_proxy function from the urllib.request module.\n    - If a no_proxy string is present, it is converted to a list by splitting on commas.\"\"\"\n    \"Get the upstream proxy configuration from the options dictionary.\\n    This will be overridden with any configuration found in the environment\\n    variables HTTP_PROXY, HTTPS_PROXY, NO_PROXY\\n\\n    The configuration will be returned as a dictionary with keys 'http',\\n    'https' and 'no_proxy'. The value of the 'http' and 'https' keys will\\n    be a named tuple with the attributes:\\n        scheme, username, password, hostport\\n    The value of 'no_proxy' will be a list.\\n\\n    Note that the keys will only be present in the dictionary when relevant\\n    proxy configuration exists.\\n\\n    Args:\\n        options: The selenium wire options.\\n    Returns: A dictionary.\\n    \"\n    proxy_options = (options or {}).pop('proxy', {})\n    http_proxy = os.environ.get('HTTP_PROXY')\n    https_proxy = os.environ.get('HTTPS_PROXY')\n    no_proxy = os.environ.get('NO_PROXY')\n    merged = {}\n    if http_proxy:\n        merged['http'] = http_proxy\n    if https_proxy:\n        merged['https'] = https_proxy\n    if no_proxy:\n        merged['no_proxy'] = no_proxy\n    merged.update(proxy_options)\n    no_proxy = merged.get('no_proxy')\n    if isinstance(no_proxy, str):\n        merged['no_proxy'] = [h.strip() for h in no_proxy.split(',')]\n    conf = namedtuple('ProxyConf', 'scheme username password hostport')\n    for proxy_type in ('http', 'https'):\n        if merged.get(proxy_type) is not None:\n            merged[proxy_type] = conf(*_parse_proxy(merged[proxy_type]))\n    return merged",
        "docstring": "Get the upstream proxy configuration from the provided options dictionary, incorporating values from relevant environment variables. The function merges settings from the 'proxy' key in the options with values from the environment variables HTTP_PROXY, HTTPS_PROXY, and NO_PROXY.\n\nParameters:\n    options (dict): A dictionary containing Selenium Wire options, potentially including a 'proxy' key with proxy settings.\n\nReturns:\n    dict: A dictionary containing upstream proxy configurations with keys 'http', 'https', and 'no_proxy'. \n          The 'http' and 'https' keys map to a named tuple with attributes scheme, username, password, and hostport, \n          while 'no_proxy' maps to a list of addresses that should bypass the proxy.\n\nNotes:\n    - The proxy configuration is parsed using the _parse_proxy function from the urllib.request module.\n    - If a no_proxy string is present, it is converted to a list by splitting on commas.",
        "signature": "def get_upstream_proxy(options):",
        "type": "Function",
        "class_signature": null
      },
      "build_proxy_args": {
        "code": "def build_proxy_args(proxy_config: Dict[str, NamedTuple]) -> Dict[str, str]:\n    \"\"\"Build the arguments needed to configure an upstream proxy for mitmproxy based on the provided proxy configuration.\n\nArgs:\n    proxy_config (Dict[str, NamedTuple]): A dictionary containing proxy settings parsed from Selenium Wire options. It may include 'http' and 'https' configurations, both of which should be instances of a named tuple with attributes (scheme, username, password, hostport). It may also contain 'custom_authorization' and 'no_proxy' settings.\n\nReturns:\n    Dict[str, str]: A dictionary of arguments formatted for mitmproxy. This includes:\n        - MITM_MODE: Indicates how to connect to the upstream proxy.\n        - MITM_UPSTREAM_AUTH: Authorization credentials if provided.\n        - MITM_UPSTREAM_CUSTOM_AUTH: Any custom authorization string.\n        - MITM_NO_PROXY: A list of domains or IPs to exclude from proxying.\n\nRaises:\n    ValueError: If different http and https proxy servers are specified, or if they are not compatible.\n\nConstants:\n    MITM_MODE (str): Key for specifying the mode of the upstream proxy as an 'upstream' connection.\n    MITM_UPSTREAM_AUTH (str): Key used for the proxy's authentication credentials.\n    MITM_UPSTREAM_CUSTOM_AUTH (str): Key for any custom proxy authorization.\n    MITM_NO_PROXY (str): Key for domains to exclude from proxy use.\nThese constants help provide a standardized format for the configuration arguments sent to mitmproxy.\"\"\"\n    'Build the arguments needed to pass an upstream proxy to mitmproxy.\\n\\n    Args:\\n        proxy_config: The proxy config parsed out of the Selenium Wire options.\\n    Returns: A dictionary of arguments suitable for passing to mitmproxy.\\n    '\n    http_proxy = proxy_config.get('http')\n    https_proxy = proxy_config.get('https')\n    conf = None\n    if http_proxy and https_proxy:\n        if http_proxy.hostport != https_proxy.hostport:\n            raise ValueError('Different settings for http and https proxy servers not supported')\n        conf = https_proxy\n    elif http_proxy:\n        conf = http_proxy\n    elif https_proxy:\n        conf = https_proxy\n    args = {}\n    if conf:\n        scheme, username, password, hostport = conf\n        args[MITM_MODE] = 'upstream:{}://{}'.format(scheme, hostport)\n        if username:\n            args[MITM_UPSTREAM_AUTH] = '{}:{}'.format(username, password)\n        custom_auth = proxy_config.get('custom_authorization')\n        if custom_auth:\n            args[MITM_UPSTREAM_CUSTOM_AUTH] = custom_auth\n        no_proxy = proxy_config.get('no_proxy')\n        if no_proxy:\n            args[MITM_NO_PROXY] = no_proxy\n    return args",
        "docstring": "Build the arguments needed to configure an upstream proxy for mitmproxy based on the provided proxy configuration.\n\nArgs:\n    proxy_config (Dict[str, NamedTuple]): A dictionary containing proxy settings parsed from Selenium Wire options. It may include 'http' and 'https' configurations, both of which should be instances of a named tuple with attributes (scheme, username, password, hostport). It may also contain 'custom_authorization' and 'no_proxy' settings.\n\nReturns:\n    Dict[str, str]: A dictionary of arguments formatted for mitmproxy. This includes:\n        - MITM_MODE: Indicates how to connect to the upstream proxy.\n        - MITM_UPSTREAM_AUTH: Authorization credentials if provided.\n        - MITM_UPSTREAM_CUSTOM_AUTH: Any custom authorization string.\n        - MITM_NO_PROXY: A list of domains or IPs to exclude from proxying.\n\nRaises:\n    ValueError: If different http and https proxy servers are specified, or if they are not compatible.\n\nConstants:\n    MITM_MODE (str): Key for specifying the mode of the upstream proxy as an 'upstream' connection.\n    MITM_UPSTREAM_AUTH (str): Key used for the proxy's authentication credentials.\n    MITM_UPSTREAM_CUSTOM_AUTH (str): Key for any custom proxy authorization.\n    MITM_NO_PROXY (str): Key for domains to exclude from proxy use.\nThese constants help provide a standardized format for the configuration arguments sent to mitmproxy.",
        "signature": "def build_proxy_args(proxy_config: Dict[str, NamedTuple]) -> Dict[str, str]:",
        "type": "Function",
        "class_signature": null
      },
      "extract_cert": {
        "code": "def extract_cert(cert_name='ca.crt'):\n    \"\"\"Extracts the root certificate specified by `cert_name` from the package resources and saves it to the current working directory.\n\nArgs:\n    cert_name (str): The name of the certificate file to extract (default is 'ca.crt').\n\nReturns:\n    None: This function does not return a value but performs file IO operations.\n\nSide Effects:\n    - If the certificate is not found, an error is logged.\n    - A log message is generated confirming the extraction of the certificate.\n\nConstants Used:\n    - `__package__`: Used to locate the resource within the package.\"\"\"\n    'Extracts the root certificate to the current working directory.'\n    try:\n        cert = pkgutil.get_data(__package__, cert_name)\n    except FileNotFoundError:\n        log.error(\"Invalid certificate '{}'\".format(cert_name))\n    else:\n        with open(Path(os.getcwd(), cert_name), 'wb') as out:\n            out.write(cert)\n        log.info('{} extracted. You can now import this into a browser.'.format(cert_name))",
        "docstring": "Extracts the root certificate specified by `cert_name` from the package resources and saves it to the current working directory.\n\nArgs:\n    cert_name (str): The name of the certificate file to extract (default is 'ca.crt').\n\nReturns:\n    None: This function does not return a value but performs file IO operations.\n\nSide Effects:\n    - If the certificate is not found, an error is logged.\n    - A log message is generated confirming the extraction of the certificate.\n\nConstants Used:\n    - `__package__`: Used to locate the resource within the package.",
        "signature": "def extract_cert(cert_name='ca.crt'):",
        "type": "Function",
        "class_signature": null
      },
      "extract_cert_and_key": {
        "code": "def extract_cert_and_key(dest_folder, cert_path=None, key_path=None, check_exists=True):\n    \"\"\"Extracts the root certificate and key, combining them into a single file named 'seleniumwire-ca.pem' in the specified destination folder. \n\nParameters:\n    dest_folder (str): The folder where the combined certificate and key will be saved.\n    cert_path (str, optional): Path to an alternative root certificate. If not provided, the default certificate will be used.\n    key_path (str, optional): Path to an alternative private key. Must be supplied if cert_path is provided.\n    check_exists (bool, optional): If True, prevents overwriting the combined file if it already exists.\n\nReturns:\n    None - The function writes the combined certificate and key to the specified destination.\n\nThe function utilizes the constants ROOT_CERT and ROOT_KEY, defined at the top of the module, which specify the default certificate and key file names. If custom paths for the certificate and key are provided but one is missing, a ValueError is raised to ensure both are supplied.\"\"\"\n    \"Extracts the root certificate and key and combines them into a\\n    single file called seleniumwire-ca.pem in the specified destination\\n    folder.\\n\\n    Args:\\n        dest_folder: The destination folder that the combined certificate\\n            and key will be written to.\\n        cert_path: Optional path to the root certificate. When not supplied\\n            selenium wire's own root certificate will be used.\\n        key_path: Optional path to the private key. When not supplied\\n            selenium wire's own private key will be used. Note that the key\\n            must always be supplied when a certificate is supplied.\\n        check_exists: If True the combined file will not be overwritten\\n            if it already exists in the destination folder.\\n    \"\n    os.makedirs(dest_folder, exist_ok=True)\n    combined_path = Path(dest_folder, COMBINED_CERT)\n    if check_exists and combined_path.exists():\n        return\n    if cert_path is not None and key_path is not None:\n        root_cert = Path(cert_path).read_bytes()\n        root_key = Path(key_path).read_bytes()\n    elif cert_path is not None or key_path is not None:\n        raise ValueError('A certificate and key must both be supplied')\n    else:\n        root_cert = pkgutil.get_data(__package__, ROOT_CERT)\n        root_key = pkgutil.get_data(__package__, ROOT_KEY)\n    with open(combined_path, 'wb') as f_out:\n        f_out.write(root_cert + b'\\n' + root_key)",
        "docstring": "Extracts the root certificate and key, combining them into a single file named 'seleniumwire-ca.pem' in the specified destination folder. \n\nParameters:\n    dest_folder (str): The folder where the combined certificate and key will be saved.\n    cert_path (str, optional): Path to an alternative root certificate. If not provided, the default certificate will be used.\n    key_path (str, optional): Path to an alternative private key. Must be supplied if cert_path is provided.\n    check_exists (bool, optional): If True, prevents overwriting the combined file if it already exists.\n\nReturns:\n    None - The function writes the combined certificate and key to the specified destination.\n\nThe function utilizes the constants ROOT_CERT and ROOT_KEY, defined at the top of the module, which specify the default certificate and key file names. If custom paths for the certificate and key are provided but one is missing, a ValueError is raised to ensure both are supplied.",
        "signature": "def extract_cert_and_key(dest_folder, cert_path=None, key_path=None, check_exists=True):",
        "type": "Function",
        "class_signature": null
      },
      "urlsafe_address": {
        "code": "def urlsafe_address(address):\n    \"\"\"Make an address safe for use in a URL by formatting it according to the standards for IPv6 addresses.\n\nArgs:\n    address (tuple): A tuple consisting of address information, where the first element is the address (IPv4 or IPv6) and the second element is the port number. Additional elements may be present but are disregarded during processing.\n\nReturns:\n    tuple: A 2-tuple containing a url-safe address (formatted with square brackets if it's an IPv6 address) and the port.\n\nThis function is useful for ensuring proper URL formatting, especially when dealing with IPv6 addresses, which require a specific representation in URLs. It does not use any external constants or variables from the broader context.\"\"\"\n    'Make an address safe to use in a URL.\\n\\n    Args:\\n        address: A tuple of address information.\\n    Returns:\\n        A 2-tuple of url-safe (address, port)\\n    '\n    addr, port, *rest = address\n    if rest:\n        addr = f'[{addr}]'\n    return (addr, port)",
        "docstring": "Make an address safe for use in a URL by formatting it according to the standards for IPv6 addresses.\n\nArgs:\n    address (tuple): A tuple consisting of address information, where the first element is the address (IPv4 or IPv6) and the second element is the port number. Additional elements may be present but are disregarded during processing.\n\nReturns:\n    tuple: A 2-tuple containing a url-safe address (formatted with square brackets if it's an IPv6 address) and the port.\n\nThis function is useful for ensuring proper URL formatting, especially when dealing with IPv6 addresses, which require a specific representation in URLs. It does not use any external constants or variables from the broader context.",
        "signature": "def urlsafe_address(address):",
        "type": "Function",
        "class_signature": null
      },
      "decode": {
        "code": "def decode(data: bytes, encoding: str) -> bytes:\n    \"\"\"Attempt to decode the given byte data according to the specified encoding type using a decoding utility from the `mitmproxy` library.\n\nArgs:\n    data (bytes): The encoded byte data that needs to be decoded.\n    encoding (str): The encoding type to be used for decoding the data, such as 'utf-8' or 'ascii'.\n\nReturns:\n    bytes: The decoded data in bytes.\n\nRaises:\n    ValueError: If the data cannot be decoded using the provided encoding.\n\nThis function relies on the `decoder` module imported from `seleniumwire.thirdparty.mitmproxy.net.http` to handle the decoding process. It is important for converting byte-encoded data back to its original form based on the specified encoding.\"\"\"\n    'Attempt to decode data based on the supplied encoding.\\n\\n    If decoding fails a ValueError is raised.\\n\\n    Args:\\n        data: The encoded data.\\n        encoding: The encoding type.\\n    Returns: The decoded data.\\n    Raises: ValueError if the data could not be decoded.\\n    '\n    return decoder.decode(data, encoding)",
        "docstring": "Attempt to decode the given byte data according to the specified encoding type using a decoding utility from the `mitmproxy` library.\n\nArgs:\n    data (bytes): The encoded byte data that needs to be decoded.\n    encoding (str): The encoding type to be used for decoding the data, such as 'utf-8' or 'ascii'.\n\nReturns:\n    bytes: The decoded data in bytes.\n\nRaises:\n    ValueError: If the data cannot be decoded using the provided encoding.\n\nThis function relies on the `decoder` module imported from `seleniumwire.thirdparty.mitmproxy.net.http` to handle the decoding process. It is important for converting byte-encoded data back to its original form based on the specified encoding.",
        "signature": "def decode(data: bytes, encoding: str) -> bytes:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "seleniumwire/utils.py:decode": {
      "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py": {
        "decode": {
          "code": "def decode(encoded: Union[None, str, bytes], encoding: str, errors: str = 'strict') -> Union[None, str, bytes]:\n    \"\"\"\n    Decode the given input object\n\n    Returns:\n        The decoded value\n\n    Raises:\n        ValueError, if decoding fails.\n    \"\"\"\n    if encoded is None:\n        return None\n\n    global _cache\n    cached = (\n        isinstance(encoded, bytes)\n        and _cache.encoded == encoded\n        and _cache.encoding == encoding\n        and _cache.errors == errors\n    )\n    if cached:\n        return _cache.decoded\n    try:\n        try:\n            decoded = custom_decode[encoding](encoded)\n        except KeyError:\n            decoded = codecs.decode(encoded, encoding, errors)  # type: ignore\n        if encoding in (\"gzip\", \"deflate\", \"br\", \"zstd\"):\n            _cache = CachedDecode(encoded, encoding, errors, decoded)\n        return decoded\n    except TypeError:\n        raise\n    except Exception as e:\n        raise ValueError(\n            \"{} when decoding {} with {}: {}\".format(\n                type(e).__name__,\n                repr(encoded)[:10],\n                repr(encoding),\n                repr(e),\n            )\n        )",
          "docstring": "Decode the given input object\n\nReturns:\n    The decoded value\n\nRaises:\n    ValueError, if decoding fails.",
          "signature": "def decode(encoded: Union[None, str, bytes], encoding: str, errors: str='strict') -> Union[None, str, bytes]:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "call_tree": {
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_empty_password": {
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_get_config": {
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_get_from_env": {
      "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:set_env": {},
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_merge": {
      "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:set_env": {},
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_no_proxy": {
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_no_proxy_as_list": {
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:GetUpstreamProxyTest:test_none": {
      "seleniumwire/utils.py:get_upstream_proxy": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_auth": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_auth_empty_password": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_both_schemes": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_custom_auth": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_no_proxy": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_args_single_scheme": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "tests/seleniumwire/test_utils.py:BuildProxyArgsTest:test_different_schemes": {
      "seleniumwire/utils.py:get_upstream_proxy": {},
      "seleniumwire/utils.py:build_proxy_args": {}
    },
    "../../../app/selenium_wire/tests/seleniumwire/test_utils.py:test_extract_cert": {
      "../../../app/selenium_wire/seleniumwire/utils.py:extract_cert": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_cert_and_key": {
      "seleniumwire/utils.py:extract_cert_and_key": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_cert_and_key_exists": {
      "seleniumwire/utils.py:extract_cert_and_key": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_cert_and_key_no_check": {
      "seleniumwire/utils.py:extract_cert_and_key": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_cert_not_found": {
      "seleniumwire/utils.py:extract_cert": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_user_supplied_cert_and_key": {
      "seleniumwire/utils.py:extract_cert_and_key": {}
    },
    "tests/seleniumwire/test_utils.py:ExtractCertTest:test_extract_user_supplied_cert_missing_key": {
      "seleniumwire/utils.py:extract_cert_and_key": {}
    },
    "tests/seleniumwire/test_utils.py:test_urlsafe_address_ipv4": {
      "seleniumwire/utils.py:urlsafe_address": {}
    },
    "tests/seleniumwire/test_utils.py:test_urlsafe_address_ipv6": {
      "seleniumwire/utils.py:urlsafe_address": {}
    },
    "tests/seleniumwire/test_utils.py:DecodeTest:test_decode_error": {
      "seleniumwire/utils.py:decode": {
        "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode": {
          "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode_gzip": {}
        }
      }
    },
    "tests/seleniumwire/test_utils.py:DecodeTest:test_decode_gzip_data": {
      "seleniumwire/utils.py:decode": {
        "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode": {
          "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode_gzip": {}
        }
      }
    },
    "tests/seleniumwire/test_utils.py:DecodeTest:test_decode_zlib_data": {
      "seleniumwire/utils.py:decode": {
        "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode": {
          "seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode_deflate": {}
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: selenium_wire-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 seleniumwire/\n    \u2514\u2500\u2500 utils.py\n        \u251c\u2500\u2500 build_proxy_args\n        \u251c\u2500\u2500 decode\n        \u251c\u2500\u2500 extract_cert\n        \u251c\u2500\u2500 extract_cert_and_key\n        \u251c\u2500\u2500 get_upstream_proxy\n        \u2514\u2500\u2500 urlsafe_address\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates robust handling and configuration of proxy settings, enabling seamless integration with upstream proxies in diverse networking environments. It provides functionality to parse and merge proxy configurations from both explicit user-defined options and system environment variables, ensuring flexible and comprehensive proxy management. The module also supports advanced features such as authentication credentials, custom authorization headers, selective bypassing of proxies (no-proxy), and protocol-specific proxy definitions. Additionally, it offers utilities for secure certificate extraction and management, promoting secure connections for proxy scenarios. By offering an abstraction layer for complex proxy-related operations, the module simplifies development efforts for applications requiring dynamic network configurations or secure proxy management.\n\n## FILE 1: seleniumwire/utils.py\n\n- FUNCTION NAME: extract_cert\n  - SIGNATURE: def extract_cert(cert_name='ca.crt'):\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the root certificate specified by `cert_name` from the package resources and saves it to the current working directory.\n\nArgs:\n    cert_name (str): The name of the certificate file to extract (default is 'ca.crt').\n\nReturns:\n    None: This function does not return a value but performs file IO operations.\n\nSide Effects:\n    - If the certificate is not found, an error is logged.\n    - A log message is generated confirming the extraction of the certificate.\n\nConstants Used:\n    - `__package__`: Used to locate the resource within the package.\n\"\"\"\n```\n\n- FUNCTION NAME: extract_cert_and_key\n  - SIGNATURE: def extract_cert_and_key(dest_folder, cert_path=None, key_path=None, check_exists=True):\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the root certificate and key, combining them into a single file named 'seleniumwire-ca.pem' in the specified destination folder. \n\nParameters:\n    dest_folder (str): The folder where the combined certificate and key will be saved.\n    cert_path (str, optional): Path to an alternative root certificate. If not provided, the default certificate will be used.\n    key_path (str, optional): Path to an alternative private key. Must be supplied if cert_path is provided.\n    check_exists (bool, optional): If True, prevents overwriting the combined file if it already exists.\n\nReturns:\n    None - The function writes the combined certificate and key to the specified destination.\n\nThe function utilizes the constants ROOT_CERT and ROOT_KEY, defined at the top of the module, which specify the default certificate and key file names. If custom paths for the certificate and key are provided but one is missing, a ValueError is raised to ensure both are supplied.\n\"\"\"\n```\n\n- FUNCTION NAME: decode\n  - SIGNATURE: def decode(data: bytes, encoding: str) -> bytes:\n  - DOCSTRING: \n```python\n\"\"\"\nAttempt to decode the given byte data according to the specified encoding type using a decoding utility from the `mitmproxy` library.\n\nArgs:\n    data (bytes): The encoded byte data that needs to be decoded.\n    encoding (str): The encoding type to be used for decoding the data, such as 'utf-8' or 'ascii'.\n\nReturns:\n    bytes: The decoded data in bytes.\n\nRaises:\n    ValueError: If the data cannot be decoded using the provided encoding.\n\nThis function relies on the `decoder` module imported from `seleniumwire.thirdparty.mitmproxy.net.http` to handle the decoding process. It is important for converting byte-encoded data back to its original form based on the specified encoding.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - seleniumwire/thirdparty/mitmproxy/net/http/encoding.py:decode\n\n- FUNCTION NAME: build_proxy_args\n  - SIGNATURE: def build_proxy_args(proxy_config: Dict[str, NamedTuple]) -> Dict[str, str]:\n  - DOCSTRING: \n```python\n\"\"\"\nBuild the arguments needed to configure an upstream proxy for mitmproxy based on the provided proxy configuration.\n\nArgs:\n    proxy_config (Dict[str, NamedTuple]): A dictionary containing proxy settings parsed from Selenium Wire options. It may include 'http' and 'https' configurations, both of which should be instances of a named tuple with attributes (scheme, username, password, hostport). It may also contain 'custom_authorization' and 'no_proxy' settings.\n\nReturns:\n    Dict[str, str]: A dictionary of arguments formatted for mitmproxy. This includes:\n        - MITM_MODE: Indicates how to connect to the upstream proxy.\n        - MITM_UPSTREAM_AUTH: Authorization credentials if provided.\n        - MITM_UPSTREAM_CUSTOM_AUTH: Any custom authorization string.\n        - MITM_NO_PROXY: A list of domains or IPs to exclude from proxying.\n\nRaises:\n    ValueError: If different http and https proxy servers are specified, or if they are not compatible.\n\nConstants:\n    MITM_MODE (str): Key for specifying the mode of the upstream proxy as an 'upstream' connection.\n    MITM_UPSTREAM_AUTH (str): Key used for the proxy's authentication credentials.\n    MITM_UPSTREAM_CUSTOM_AUTH (str): Key for any custom proxy authorization.\n    MITM_NO_PROXY (str): Key for domains to exclude from proxy use.\nThese constants help provide a standardized format for the configuration arguments sent to mitmproxy.\n\"\"\"\n```\n\n- FUNCTION NAME: get_upstream_proxy\n  - SIGNATURE: def get_upstream_proxy(options):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the upstream proxy configuration from the provided options dictionary, incorporating values from relevant environment variables. The function merges settings from the 'proxy' key in the options with values from the environment variables HTTP_PROXY, HTTPS_PROXY, and NO_PROXY.\n\nParameters:\n    options (dict): A dictionary containing Selenium Wire options, potentially including a 'proxy' key with proxy settings.\n\nReturns:\n    dict: A dictionary containing upstream proxy configurations with keys 'http', 'https', and 'no_proxy'. \n          The 'http' and 'https' keys map to a named tuple with attributes scheme, username, password, and hostport, \n          while 'no_proxy' maps to a list of addresses that should bypass the proxy.\n\nNotes:\n    - The proxy configuration is parsed using the _parse_proxy function from the urllib.request module.\n    - If a no_proxy string is present, it is converted to a list by splitting on commas.\n\"\"\"\n```\n\n- FUNCTION NAME: urlsafe_address\n  - SIGNATURE: def urlsafe_address(address):\n  - DOCSTRING: \n```python\n\"\"\"\nMake an address safe for use in a URL by formatting it according to the standards for IPv6 addresses.\n\nArgs:\n    address (tuple): A tuple consisting of address information, where the first element is the address (IPv4 or IPv6) and the second element is the port number. Additional elements may be present but are disregarded during processing.\n\nReturns:\n    tuple: A 2-tuple containing a url-safe address (formatted with square brackets if it's an IPv6 address) and the port.\n\nThis function is useful for ensuring proper URL formatting, especially when dealing with IPv6 addresses, which require a specific representation in URLs. It does not use any external constants or variables from the broader context.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "seleniumwire/utils.py": "import collections.abc\nimport logging\nimport os\nimport pkgutil\nfrom collections import namedtuple\nfrom pathlib import Path\nfrom typing import Dict, NamedTuple\nfrom urllib.request import _parse_proxy\nfrom seleniumwire.thirdparty.mitmproxy.net.http import encoding as decoder\nlog = logging.getLogger(__name__)\nROOT_CERT = 'ca.crt'\nROOT_KEY = 'ca.key'\nCOMBINED_CERT = 'seleniumwire-ca.pem'\nMITM_MODE = 'mode'\nMITM_UPSTREAM_AUTH = 'upstream_auth'\nMITM_UPSTREAM_CUSTOM_AUTH = 'upstream_custom_auth'\nMITM_NO_PROXY = 'no_proxy'\n\ndef is_list_alike(container):\n    return isinstance(container, collections.abc.Sequence) and (not isinstance(container, str))"
  }
}