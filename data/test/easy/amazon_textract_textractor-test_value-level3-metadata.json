{
  "dir_path": "/app/amazon_textract_textractor",
  "package_name": "amazon_textract_textractor",
  "sample_name": "amazon_textract_textractor-test_value",
  "src_dir": "textractor/",
  "test_dir": "tests/",
  "test_file": "tests/test_value.py",
  "test_code": "import unittest\n\nfrom textractor.data.constants import TextTypes\nfrom textractor.entities.value import Value\nfrom textractor.entities.word import Word\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\n\nclass TestValue(unittest.TestCase):\n    def setUp(self):\n        self.word_bb_1 = {\n            \"Width\": 0.10809839516878128,\n            \"Height\": 0.01363567914813757,\n            \"Left\": 0.036161474883556366,\n            \"Top\": 0.03439946100115776,\n        }\n        self.word_bb_2 = {\n            \"Width\": 0.18033172190189362,\n            \"Height\": 0.01742148958146572,\n            \"Left\": 0.22032427787780762,\n            \"Top\": 0.03645794093608856,\n        }\n        self.word_bb_3 = {\n            \"Width\": 0.03744738921523094,\n            \"Height\": 0.016524378210306168,\n            \"Left\": 0.4087739884853363,\n            \"Top\": 0.0368686243891716,\n        }\n        self.value_bb = {\n            \"Width\": 0.02524515800178051,\n            \"Height\": 0.01746263913810253,\n            \"Left\": 0.18779051303863525,\n            \"Top\": 0.4229613244533539,\n        }\n\n        self.word_1 = Word(\n            entity_id=\"word-id-1\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_1, spatial_object=None),\n            text=\"TEST\",\n            text_type=TextTypes.PRINTED,\n        )\n        self.word_2 = Word(\n            entity_id=\"word-id-2\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_2, spatial_object=None),\n            text=\"WORDS\",\n            text_type=TextTypes.HANDWRITING,\n        )\n        self.word_3 = Word(\n            entity_id=\"word-id-3\",\n            bbox=BoundingBox.from_normalized_dict(self.word_bb_3, spatial_object=None),\n            text=\"ADDED\",\n            text_type=TextTypes.PRINTED,\n        )\n\n        self.value = Value(\n            entity_id=\"value-id\",\n            bbox=BoundingBox.from_normalized_dict(self.value_bb, spatial_object=None),\n        )\n        self.word_objs = [self.word_1, self.word_2, self.word_3]\n        self.value.words = self.word_objs\n        self.value.key_id = \"key-id\"\n        self.value.contains_checkbox = False\n        self.value.page = 2\n        self.value.page_id = \"page-id\"\n\n\n    def test_words(self):\n        \"\"\"Test case to add words to the Value field of a key-value pair\"\"\"\n        self.assertEqual(self.value.words, EntityList(self.word_objs))\n    \n    \n    def test_key_id(self):\n        \"\"\"Test case to access Key ID of a key-value pair\"\"\"\n        self.assertEqual(self.value.key_id, \"key-id\")\n    \n    \n    def test_contains_checkbox(self):\n        self.assertFalse(self.value.contains_checkbox)\n    \n\n    def test_set_page(self):\n        \"\"\"Test case setter for the page attribute\"\"\"\n        self.assertEqual(self.value.page, 2)\n    \n    \n    def test_set_page_id(self):\n        \"\"\"Test case setter for the page_id attribute\"\"\"\n        self.assertEqual(self.value.page_id, \"page-id\")\n    \n    \n    def test_get_words_by_type(self):\n        \"\"\"Test case to retrieve words of a specific type in the Value field of a key-value pair\"\"\"\n        self.assertEqual(\n            self.value.get_words_by_type(text_type=TextTypes.PRINTED),\n            EntityList([self.word_1, self.word_3])\n        )\n        self.assertEqual(\n            self.value.get_words_by_type(text_type=TextTypes.HANDWRITING),\n            EntityList([self.word_2])\n        )\n\n\n    def test_repr(self):\n        \"\"\"Test case to retrieve words of the Value field in a key-value pair as text\"\"\"\n        self.assertEqual(self.value.__repr__(), \"TEST WORDS ADDED\")\n",
  "GT_file_code": {
    "textractor/entities/word.py": "\"\"\"\nRepresents a single :class:`Word` within the :class:`Document`.\nThis class contains the associated metadata with the :class:`Word` entity including the text transcription, \ntext type, bounding box information, page number, Page ID and confidence of detection.\n\"\"\"\n\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.utils.html_utils import escape_text\n\nclass Word(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Word` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param text: Transcription of the Word object.\n    :type text: str\n    :param text_type: Enum value stating the type of text stored in the entity. Takes 2 values - PRINTED and HANDWRITING\n    :type text_type: TextTypes\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(\n        self,\n        entity_id: str,\n        bbox: BoundingBox,\n        text: str = \"\",\n        text_type: TextTypes = TextTypes.PRINTED,\n        confidence: float = 0,\n        is_clickable: bool = False,\n        is_structure: bool = False,\n    ):\n        super().__init__(entity_id, bbox)\n        self._text = text\n        self._text_type = text_type\n        self._confidence = confidence / 100\n        self.is_clickable = is_clickable\n        self.is_structure = is_structure\n        self._page = None\n        self._page_id = None\n        self.line = None\n        self.cell_bbox = None\n        self.cell_id = None\n        self.row_index = None\n        self.col_index = None\n        self.row_span = None\n        self.col_span = None\n        self.key_bbox = None\n        self.value_bbox = None\n        self.key_id = None\n        self.value_id = None\n        self.kv_id = None\n        self.kv_bbox = None\n        self.line_id = None\n        self.line_bbox = None\n        self.table_id = None\n        self.table_bbox = None\n        self.layout_id = None\n        self.layout_type = None\n        self.layout_bbox = None\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        :return: Returns the text transcription of the Word entity.\n        :rtype: str\n        \"\"\"\n        return self._text\n\n    @text.setter\n    def text(self, text: str):\n        \"\"\"\n        Sets the transcription of the :class:`Word` entity.\n\n        :param text: String containing the text transcription of the Word entity.\n        :type text: str\n        \"\"\"\n        self._text = text\n\n    @property\n    def text_type(self) -> TextTypes:\n        \"\"\"\n        :return: Returns the property of :class:`Word` class that holds the text type of Word object.\n        :rtype: str\n        \"\"\"\n        return self._text_type\n\n    @text_type.setter\n    def text_type(self, text_type: TextTypes):\n        \"\"\"\n        Sets the text type of the :class:`Word` entity.\n\n        :param text_type: Constant containing the type of text\n        \"\"\"\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the Word entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Word` entity.\n\n        :param page_num: Page number where the Word entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the Word entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    @property\n    def words(self):\n        \"\"\"Returns itself\n\n        :rtype: Word\n        \"\"\"\n        return [self]\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ):\n        return escape_text(self.text, config), [self]\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f\"{self.text}\"\n",
    "textractor/entities/value.py": "\"\"\"\nRepresents a single :class:`Value` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as KEY_VALUE_SET BlockTypes. These may be of KEY\nor VALUE type which is indicated by the EntityType attribute in the JSON response. \n\nThis class contains the associated metadata with the :class:`Value` entity including the entity ID, \nbounding box information, child words, associated key ID, page number, Page ID, confidence of detection\nand if it's a checkbox.\n\"\"\"\n\nfrom typing import List\nimport uuid\n\nfrom textractor.entities.word import Word\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import PRINTED, HANDWRITING, TextTypes\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.utils.text_utils import linearize_children\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\n\nclass Value(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Value` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float = 0):\n        super().__init__(entity_id, bbox)\n        self._words: List[Word] = []\n        self._key_id = None\n        self._contains_checkbox = False\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None\n\n    @property\n    def words(self) -> List[Word]:\n        \"\"\"\n        :return: Returns a list of all words in the entity if it exists else returns the\n                 checkbox status of the Value entity.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not self.contains_checkbox:\n            return EntityList(self._words)\n        else:\n            return self.children[0].words\n\n    @words.setter\n    def words(self, words: List[Word]):\n        \"\"\"\n        Add Word objects to the Value.\n\n        :param words: List of Word objects, each representing a word within the Value field.\n        No specific ordering is assumed as is it is ordered internally.\n        :type words: list\n        \"\"\"\n        self._words = sorted(words, key=lambda x: x.bbox.x + x.bbox.y)\n\n    @property\n    def key_id(self) -> str:\n        \"\"\"\n        Returns the associated Key ID for the :class:`Value` entity.\n\n        :return: Returns the associated KeyValue object ID.\n        :rtype: str\n        \"\"\"\n        return self._key_id\n\n    @key_id.setter\n    def key_id(self, key_id: str):\n        \"\"\"\n        Sets the :class:`KeyValue` ID to which this Value object is associated.\n\n        :param key_id: Unique identifier for the KeyValue entity to which this Value is associated.\n        :type key_id: str\n        \"\"\"\n        self._key_id = key_id\n\n    @property\n    def contains_checkbox(self) -> bool:\n        \"\"\"\n        Returns True if the value associated is a :class:`SelectionElement`.\n\n        :return: Returns True if the value associated is a checkbox/SelectionElement.\n        :rtype: bool\n        \"\"\"\n        return self._contains_checkbox\n\n    @contains_checkbox.setter\n    def contains_checkbox(self, checkbox_present: bool):\n        \"\"\"\n        Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\n\n        :param checkbox_present: True or False depending on checkbox presence.\n        :type checkbox_present: bool\n        \"\"\"\n        self._contains_checkbox = checkbox_present\n\n    @property\n    def page(self):\n        \"\"\"\n        :return: Returns the page number of the page the Value entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the Value entity.\n\n        :param page_num: Page number where the Value entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the :class:`Value` entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    def get_words_by_type(self, text_type: str = TextTypes.PRINTED) -> List[Word]:\n        \"\"\"\n        Returns list of :class:`Word` entities that match the input text type.\n\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\n        :type text_type: TextTypes\n\n        :return: Returns list of Word entities that match the input text type.\n        :rtype: EntityList[Word]\n        \"\"\"\n        if not isinstance(text_type, TextTypes):\n            raise InputError(\n                \"text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants\"\n            )\n\n        return EntityList([word for word in self.words if word.text_type == text_type])\n\n    def get_text_and_words(\n        self, config: TextLinearizationConfig = TextLinearizationConfig()\n    ):\n        # We will need to handle the case where the Value contains a checkbox.\n        if self.contains_checkbox:\n            text, words = self.children[0].get_text_and_words(config)\n        else:\n            text, words = linearize_children(\n                self.words,\n                config=config,\n                no_new_lines=config.remove_new_lines_in_leaf_elements,\n            )\n        if config.add_prefixes_and_suffixes_in_text:\n            text = add_id_to_html_tag(config.value_prefix, self.id, config) + text + config.value_suffix\n        if config.add_prefixes_and_suffixes_as_words:\n            words = (\n                (\n                    [\n                        Word(\n                            str(uuid.uuid4()),\n                            self.bbox,\n                            add_id_to_html_tag(config.value_prefix, self.id, config),\n                            is_structure=True,\n                            is_clickable=(\n                                bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected]\n                            )\n                        )\n                    ]\n                    if config.value_prefix else\n                    []\n                ) +\n                words +\n                (\n                    [\n                        Word(\n                            str(uuid.uuid4()),\n                            self.bbox,\n                            config.value_suffix,\n                            is_structure=True,\n                            is_clickable=(\n                                bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected]\n                            )\n                        )\n                    ]\n                    if config.value_suffix else\n                    []\n                )\n            )\n        for w in words:\n            w.value_id = str(self.id)\n            w.value_bbox = self.bbox\n        return text, words\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Value entity.\n        :rtype: str\n        \"\"\"\n        repr_string = \"\"\n        if self.contains_checkbox:\n            repr_string += f\"{self.children[0].__repr__()}\"\n        else:\n            words = \" \".join([word.text for word in self.words])\n            repr_string += f\"{words}\"\n        return repr_string\n",
    "textractor/data/constants.py": "\"\"\"Multiple feature calls within the Textractor tool require the use of input parameters from fixed choices. \\\nThey've been defined as :code:`Enum` within the data package.\"\"\"\n\nfrom enum import Enum\nfrom textractcaller.t_call import Textract_API\n\nfrom textractor.exceptions import InputError\n\nWORD = \"WORD\"\nLINE = \"LINE\"\nKEY_VALUE_SET = \"KEY_VALUE_SET\"\nSELECTION_ELEMENT = \"SELECTION_ELEMENT\"\nTABLE = \"TABLE\"\nTABLE_TITLE = \"TABLE_TITLE\"\nTABLE_FOOTER = \"TABLE_FOOTER\"\nTABLE_SUMMARY = \"TABLE_SUMMARY\"\nTABLE_SECTION_TITLE = \"TABLE_SECTION_TITLE\"\nTABLE_COLUMN_HEADER = \"COLUMN_HEADER\"\nTABLE_STRUCTURED = \"STRUCTURED_TABLE\"\nTABLE_SEMI_STRUCTURED = \"SEMI_STRUCTURED_TABLE\"\nCELL = \"CELL\"\nPAGE = \"PAGE\"\nMERGED_CELL = \"MERGED_CELL\"\nQUERY = \"QUERY\"\nQUERY_RESULT = \"QUERY_RESULT\"\nSIGNATURE = \"SIGNATURE\"\nLAYOUT = \"LAYOUT\"\nLAYOUT_TEXT = \"LAYOUT_TEXT\"\nLAYOUT_TITLE = \"LAYOUT_TITLE\"\nLAYOUT_HEADER = \"LAYOUT_HEADER\"\nLAYOUT_FOOTER = \"LAYOUT_FOOTER\"\nLAYOUT_SECTION_HEADER = \"LAYOUT_SECTION_HEADER\"\nLAYOUT_PAGE_NUMBER = \"LAYOUT_PAGE_NUMBER\"\nLAYOUT_LIST = \"LAYOUT_LIST\"\nLAYOUT_FIGURE = \"LAYOUT_FIGURE\"\nLAYOUT_TABLE = \"LAYOUT_TABLE\"\nLAYOUT_KEY_VALUE = \"LAYOUT_KEY_VALUE\"\n\n# This is not a base layout type, but a fake type for the text conversion logic\n# when an API is called without the AnalyzeLayout API, all the elements will be LAYOUT_ENTITY\nLAYOUT_ENTITY = \"LAYOUT_ENTITY\"\n\n# cell type attributes\nIS_COLUMN_HEAD = \"isColumnHead\"\nIS_SECTION_TITLE_CELL = \"isSectionTitleCell\"\nIS_SUMMARY_CELL = \"isSummaryCell\"\nIS_TITLE_CELL = \"isTitleCell\"\nIS_FOOTER_CELL = \"isFooterCell\"\nIS_MERGED_CELL = \"isMergedCell\"\n\n# Text Types\nHANDWRITING = \"HANDWRITING\"\nPRINTED = \"PRINTED\"\n\n\nclass TableTypes(Enum):\n    \"\"\"Types of tables recognized by Textract APIs.\"\"\"\n\n    UNKNOWN = 0\n    STRUCTURED = 1\n    SEMI_STRUCTURED = 2\n\n\nclass Direction(Enum):\n    \"\"\"Directions available for search using DirectionalFinder\"\"\"\n\n    ABOVE = 0\n    BELOW = 1\n    RIGHT = 2\n    LEFT = 3\n\n\nclass TextTypes(Enum):\n    \"\"\"Textract recognizes TextType of all words in the document to fall into one of these 2 categories.\"\"\"\n\n    HANDWRITING = 0\n    PRINTED = 1\n\n\n# selection element attributes\nSELECTED = \"SELECTED\"\nNOT_SELECTED = \"NOT_SELECTED\"\n\n\nclass SelectionStatus(Enum):\n    \"\"\"These are the 2 categories defined for the SelectionStatus of a :class:`SelectionElement`.\"\"\"\n\n    SELECTED = 0\n    NOT_SELECTED = 1\n\n\nCOLUMN_HEADER = \"COLUMN_HEADER\"\nSECTION_TITLE = \"SECTION_TITLE\"\nFLOATING_FOOTER = \"FLOATING_FOOTER\"\nFLOATING_TITLE = \"FLOATING_TITLE\"\nSUMMARY_CELL = \"SUMMARY_CELL\"\n\n\nclass CellTypes(Enum):\n    \"\"\"Special cells within the :class:`Table` belong to one of these categories.\"\"\"\n\n    COLUMN_HEADER = 0\n    SECTION_TITLE = 1\n    FLOATING_FOOTER = 2\n    FLOATING_TITLE = 3\n    SUMMARY_CELL = 4\n\n\nFORCE_SYNC = \"FORCE_SYNC\"\nFORCE_ASYNC = \"FORCE_ASYNC\"\nDEFAULT = \"DEFAULT\"\n\n\nFORMS = \"FORMS\"\nTABLES = \"TABLES\"\nQUERIES = \"QUERIES\"\nLAYOUT = \"LAYOUT\"\n\n\nclass TextractFeatures(Enum):\n    \"\"\"Features to be used as parameter for AnalyzeDocument and StartDocumentAnalysis.\"\"\"\n\n    FORMS = 0\n    TABLES = 1\n    QUERIES = 2\n    SIGNATURES = 3\n    LAYOUT = 4\n\n\nclass TextractType(Enum):\n    \"\"\"Document Entity types recognized by Textract APIs.\"\"\"\n\n    WORDS = 0\n    LINES = 1\n    KEY_VALUE_SET = 2\n    SELECTION_ELEMENT = 3\n    TABLES = 4\n    TABLE_CELL = 5\n\n\nclass DirectionalFinderType(Enum):\n    \"\"\"Document Entity types recognized by Textract APIs.\"\"\"\n\n    KEY_VALUE_SET = 0\n    SELECTION_ELEMENT = 1\n\n\nclass TableFormat(Enum):\n    \"\"\"Various formats of printing :class:`Table` data with the tabulate package.\"\"\"\n\n    CSV = 0\n    PLAIN = 1\n    SIMPLE = 2\n    GITHUB = 3\n    GRID = 4\n    FANCY_GRID = 5\n    PIPE = 6\n    ORGTBL = 7\n    JIRA = 8\n    PRESTO = 9\n    PRETTY = 10\n    PSQL = 11\n    RST = 12\n    MEDIAWIKI = 13\n    MOINMOIN = 14\n    YOUTRACK = 15\n    HTML = 16\n    UNSAFEHTML = 17\n    LATEX = 18\n    LATEX_RAW = 19\n    LATEX_BOOKTABS = 20\n    LATEX_LONGTABLE = 21\n    TEXTILE = 22\n    TSV = 23\n\n\nclass SimilarityMetric(Enum):\n    \"\"\"\n    Similarity metrics for search queries on Document data\n\n    COSINE: Cosine similarity is a metric used to measure the similarity of two vectors. It measures the similarity in the direction or orientation of the vectors ignoring differences in their magnitude or scale.\n    EUCLIDEAN: Euclidean distance is calculated as the square root of the sum of the squared differences between the two vectors.\n    LEVENSHTEIN: The Levenshtein distance is a string metric for measuring difference between two sequences. It is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other.\n    \"\"\"\n\n    COSINE = 0\n    EUCLIDEAN = 1\n    LEVENSHTEIN = 2\n\n\nclass TextractAPI(Enum):\n    \"\"\"API types for asynchronous type fetching\"\"\"\n\n    DETECT_TEXT = 0\n    ANALYZE = 1\n    EXPENSE = 2\n\n    @classmethod\n    def TextractAPI_to_Textract_API(cls, api):\n        if api == TextractAPI.DETECT_TEXT:\n            return Textract_API.DETECT\n        elif api == TextractAPI.ANALYZE:\n            return Textract_API.ANALYZE\n        elif api == TextractAPI.EXPENSE:\n            return Textract_API.EXPENSE\n        else:\n            raise InputError()\n\n    @classmethod\n    def Textract_API_to_TextractAPI(cls, api: Textract_API):\n        if api == Textract_API.DETECT:\n            return TextractAPI.DETECT_TEXT\n        elif api == Textract_API.ANALYZE:\n            return TextractAPI.ANALYZE\n        elif api == Textract_API.EXPENSE:\n            return TextractAPI.EXPENSE\n        else:\n            raise InputError()\n\n\nclass AnalyzeIDFields(Enum):\n    \"\"\"Enum containing all the AnalyzeID keys\"\"\"\n\n    FIRST_NAME = \"FIRST_NAME\"\n    LAST_NAME = \"LAST_NAME\"\n    MIDDLE_NAME = \"MIDDLE_NAME\"\n    SUFFIX = \"SUFFIX\"\n    CITY_IN_ADDRESS = \"CITY_IN_ADDRESS\"\n    ZIP_CODE_IN_ADDRESS = \"ZIP_CODE_IN_ADDRESS\"\n    STATE_IN_ADDRESS = \"STATE_IN_ADDRESS\"\n    COUNTY = \"COUNTY\"\n    DOCUMENT_NUMBER = \"DOCUMENT_NUMBER\"\n    EXPIRATION_DATE = \"EXPIRATION_DATE\"\n    DATE_OF_BIRTH = \"DATE_OF_BIRTH\"\n    STATE_NAME = \"STATE_NAME\"\n    DATE_OF_ISSUE = \"DATE_OF_ISSUE\"\n    CLASS = \"CLASS\"\n    RESTRICTIONS = \"RESTRICTIONS\"\n    ENDORSEMENTS = \"ENDORSEMENTS\"\n    ID_TYPE = \"ID_TYPE\"\n    VETERAN = \"VETERAN\"\n    ADDRESS = \"ADDRESS\"\n    # Only available in passports\n    PLACE_OF_BIRTH = \"PLACE_OF_BIRTH\"\n\n\nclass AnalyzeExpenseLineItemFields(Enum):\n    ITEM = \"ITEM\"\n    PRICE = \"PRICE\"\n    PRODUCT_CODE = \"PRODUCT_CODE\"\n    QUANTITY = \"QUANTITY\"\n    UNIT_PRICE = \"UNIT_PRICE\"\n    EXPENSE_ROW = \"EXPENSE_ROW\"\n\n\nclass AnalyzeExpenseFields(Enum):\n    ACCOUNT_NUMBER = \"ACCOUNT_NUMBER\"\n    ADDRESS = \"ADDRESS\"\n    ADDRESS_BLOCK = \"ADDRESS_BLOCK\"\n    AMOUNT_DUE = \"AMOUNT_DUE\"\n    AMOUNT_PAID = \"AMOUNT_PAID\"\n    CITY = \"CITY\"\n    COUNTRY = \"COUNTRY\"\n    CUSTOMER_NUMBER = \"CUSTOMER_NUMBER\"\n    DELIVERY_DATE = \"DELIVERY_DATE\"\n    DISCOUNT = \"DISCOUNT\"\n    DUE_DATE = \"DUE_DATE\"\n    GRATUITY = \"GRATUITY\"\n    INVOICE_RECEIPT_DATE = \"INVOICE_RECEIPT_DATE\"\n    INVOICE_RECEIPT_ID = \"INVOICE_RECEIPT_ID\"\n    NAME = \"NAME\"\n    ORDER_DATE = \"ORDER_DATE\"\n    OTHER = \"OTHER\"\n    PAYMENT_TERMS = \"PAYMENT_TERMS\"\n    PO_NUMBER = \"PO_NUMBER\"\n    PRIOR_BALANCE = \"PRIOR_BALANCE\"\n    RECEIVER_ABN_NUMBER = \"RECEIVER_ABN_NUMBER\"\n    RECEIVER_ADDRESS = \"RECEIVER_ADDRESS\"\n    RECEIVER_GST_NUMBER = \"RECEIVER_GST_NUMBER\"\n    RECEIVER_NAME = \"RECEIVER_NAME\"\n    RECEIVER_PAN_NUMBER = \"RECEIVER_PAN_NUMBER\"\n    RECEIVER_PHONE = \"RECEIVER_PHONE\"\n    RECEIVER_VAT_NUMBER = \"RECEIVER_VAT_NUMBER\"\n    SERVICE_CHARGE = \"SERVICE_CHARGE\"\n    SHIPPING_HANDLING_CHARGE = \"SHIPPING_HANDLING_CHARGE\"\n    STATE = \"STATE\"\n    STREET = \"STREET\"\n    SUBTOTAL = \"SUBTOTAL\"\n    TAX = \"TAX\"\n    TAX_PAYER_ID = \"TAX_PAYER_ID\"\n    TOTAL = \"TOTAL\"\n    VENDOR_ABN_NUMBER = \"VENDOR_ABN_NUMBER\"\n    VENDOR_ADDRESS = \"VENDOR_ADDRESS\"\n    VENDOR_GST_NUMBER = \"VENDOR_GST_NUMBER\"\n    VENDOR_NAME = \"VENDOR_NAME\"\n    VENDOR_PAN_NUMBER = \"VENDOR_PAN_NUMBER\"\n    VENDOR_PHONE = \"VENDOR_PHONE\"\n    VENDOR_URL = \"VENDOR_URL\"\n    VENDOR_VAT_NUMBER = \"VENDOR_VAT_NUMBER\"\n    ZIP_CODE = \"ZIP_CODE\"\n\n\nclass AnalyzeExpenseFieldsGroup(Enum):\n    RECEIVER = \"RECEIVER\"\n    RECEIVER_BILL_TO = \"RECEIVER_BILL_TO\"\n    RECEIVER_SHIP_TO = \"RECEIVER_SHIP_TO\"\n    RECEIVER_SOLD_TO = \"RECEIVER_SOLD_TO\"\n    VENDOR = \"VENDOR\"\n    VENDOR_REMIT_TO = \"VENDOR_REMIT_TO\"\n    VENDOR_SUPPLIER = \"VENDOR_SUPPLIER\"\n\n\nclass CLIPrint(Enum):\n    ALL = 0\n    TEXT = 1\n    TABLES = 2\n    FORMS = 3\n    QUERIES = 4\n    EXPENSES = 5\n    SIGNATURES = 6\n    IDS = 7\n    LAYOUTS = 8\n\nclass CLIOverlay(Enum):\n    ALL = 0\n    WORDS = 1\n    LINES = 2\n    TABLES = 3\n    FORMS = 4\n    QUERIES = 5\n    SIGNATURES = 6\n    LAYOUTS = 7\n",
    "textractor/entities/bbox.py": "\"\"\"BoundingBox class contains all the co-ordinate information for a :class:`DocumentEntity`. This class is mainly useful to locate the entity\non the image of the document page.\"\"\"\n\nfrom abc import ABC\nimport logging\nimport math\nfrom typing import Tuple, List\n\ntry:\n    import numpy as np\nexcept ImportError:\n    # Used in an export_as_numpy function which won't be called if the user doesn't have numpy.\n    pass\n\nfrom typing import Dict\nfrom dataclasses import dataclass\n\n\nclass SpatialObject(ABC):\n    \"\"\"\n    The :class:`SpatialObject` interface defines an object that has a width and height. This mostly used for :class:`BoundingBox` \\\n    reference to be able to provide normalized coordinates.\n    \"\"\"\n\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n\n@dataclass\nclass BoundingBox(SpatialObject):\n    \"\"\"\n    Represents the bounding box of an object in the format of a dataclass with (x, y, width, height). \\\n    By default :class:`BoundingBox` is set to work with denormalized co-ordinates: :math:`x \\\\in [0, docwidth]` and :math:`y \\\\in [0, docheight]`. \\\n    Use the as_normalized_dict function to obtain BoundingBox with normalized co-ordinates: :math:`x \\\\in [0, 1]` and :math:`y \\\\in [0, 1]`. \\\\\n\n    Create a BoundingBox like shown below: \\\\\n\n    * Directly:             :code:`bb = BoundingBox(x, y, width, height)` \\\\\n    * From dict:            :code:`bb = BoundingBox.from_dict(bb_dict)` where :code:`bb_dict = {'x': x, 'y': y, 'width': width, 'height': height}` \\\\\n\n    Use a BoundingBox like shown below: \\\\\n\n    * Directly:            :code:`print('The top left is: ' + str(bb.x) + ' ' + str(bb.y))` \\\\\n    * Convert to dict:     :code:`bb_dict = bb.as_dict()` returns :code:`{'x': x, 'y': y, 'width': width, 'height': height}`\n    \"\"\"\n\n    def __init__(\n        self, x: float, y: float, width: float, height: float, spatial_object=None\n    ):\n        super().__init__(width, height)\n        self.spatial_object = spatial_object\n        self.x = x\n        self.y = y\n\n    @classmethod\n    def from_normalized_dict(\n        cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject = None\n    ):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`. \\\n        The coordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized co-ordinates\n        :rtype: BoundingBox\n        \"\"\"\n        return cls._from_dict(bbox_dict, spatial_object)\n\n    @staticmethod\n    def _denormalize(\n        x: float,\n        y: float,\n        width: float,\n        height: float,\n        spatial_object: SpatialObject = None,\n    ) -> Tuple[float, float, float, float]:\n        \"\"\"\n        Denormalizes the coordinates according to spatial_object (used as a calibrator). \\\n        The SpatialObject is assumed to be a container for the bounding boxes (i.e: Page). \\\n        Any object with width, height attributes can be used as a SpatialObject.\n\n        :param x: Normalized co-ordinate x\n        :type x: float\n        :param y: Normalized co-ordinate y\n        :type y: float\n        :param width: Normalized width of BoundingBox\n        :type width: float\n        :param height: Normalized height of BoundingBox\n        :type height: float\n        :param spatial_object: Object with width and height attributes (i.e: Page).\n        :type spatial_object: SpatialObject\n\n        :return: Returns x, y, width, height as denormalized co-ordinates.\n        :rtype: Tuple[float, float, float, float]\n        \"\"\"\n\n        x = x * spatial_object.width\n        y = y * spatial_object.height\n        width = width * spatial_object.width\n        height = height * spatial_object.height\n\n        return x, y, width, height\n\n    @classmethod\n    def from_denormalized_xywh(\n        cls,\n        x: float,\n        y: float,\n        width: float,\n        height: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left, width and height properties.\n        The coordinates are assumed to be denormalized.\n        :param x: Left ~ [0, doc_width]\n        :param y: Top  ~ [0, doc_height]\n        :param width: Width ~ [0, doc_width]\n        :param height: Height  ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    @classmethod\n    def from_denormalized_corners(\n        cls,\n        x1: float,\n        y1: float,\n        x2: float,\n        y2: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        :param x1: Left  ~ [0, wdoc_idth]\n        :param y1: Top ~ [0, doc_height]\n        :param x2: Right  ~ [0, doc_width]\n        :param y2: Bottom ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = x1\n        y = y1\n        width = x2 - x1\n        height = y2 - y1\n        return BoundingBox(x, y, width, height, spatial_object=spatial_object)\n\n    @classmethod\n    def from_denormalized_borders(\n        cls,\n        left: float,\n        top: float,\n        right: float,\n        bottom: float,\n        spatial_object: SpatialObject = None,\n    ):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        If spatial_object is not None, the coordinates will be denormalized according to the spatial object.\n        :param left: ~ [0, doc_width]\n        :param top: ~ [0, doc_height]\n        :param right: ~ [0, doc_width]\n        :param bottom: ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return cls.from_denormalized_corners(left, top, right, bottom, spatial_object)\n\n    @classmethod\n    def from_denormalized_dict(cls, bbox_dict: Dict[str, float]):\n        \"\"\"\n        Builds an axis aligned bounding box from a dictionary of:\n        {'x': x, 'y': y, 'width': width, 'height': height}\n        The coordinates will be denormalized according to the spatial object.\n        :param bbox_dict: {'x': x, 'y': y, 'width': width, 'height': height} of [0, doc_height] x [0, doc_width]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = bbox_dict[\"x\"]\n        y = bbox_dict[\"y\"]\n        width = bbox_dict[\"width\"]\n        height = bbox_dict[\"height\"]\n        return BoundingBox(x, y, width, height)\n\n    @classmethod\n    def enclosing_bbox(cls, bboxes, spatial_object: SpatialObject = None):\n        \"\"\"\n        :param bboxes [BoundingBox]: list of bounding boxes\n        :param spatial_object SpatialObject: spatial object to be added to the returned bbox\n        :return:\n        \"\"\"\n        bboxes = [bbox for bbox in bboxes if bbox is not None]\n        if bboxes and not isinstance(bboxes[0], BoundingBox):\n            try:\n                bboxes = [bbox.bbox for bbox in bboxes]\n            except:\n                raise Exception(\n                    \"bboxes must be of type List[BoundingBox] or of type List[DocumentEntity]\"\n                )\n\n        x1, y1, x2, y2 = float(\"inf\"), float(\"inf\"), float(\"-inf\"), float(\"-inf\")\\\n        \n        # FIXME: This should not happen\n        if not any([bbox is not None for bbox in bboxes]):\n            logging.warning(\"At least one bounding box needs to be non-null\")\n            return BoundingBox(0, 0, 1, 1, spatial_object=spatial_object)            \n        \n        if spatial_object is None:\n            spatial_object = bboxes[0].spatial_object\n\n        for bbox in bboxes:\n            if bbox is not None:\n                x1 = min(x1, bbox.x)\n                x2 = max(x2, bbox.x + bbox.width)\n                y1 = min(y1, bbox.y)\n                y2 = max(y2, bbox.y + bbox.height)\n        return BoundingBox(x1, y1, x2 - x1, y2 - y1, spatial_object=spatial_object)\n\n    @classmethod\n    def is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if Bounding Box A is within Bounding Box B\n        \"\"\"\n        return (\n            bbox_a.x >= bbox_b.x and\n            (bbox_a.x + bbox_a.width) <= (bbox_b.x + bbox_b.width) and\n            bbox_a.y >= bbox_b.y and\n            (bbox_a.y + bbox_a.height) <= (bbox_b.y + bbox_b.height)\n        )\n\n    @classmethod\n    def center_is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if the center point of Bounding Box A is within Bounding Box B\n        \"\"\"\n        return (\n            (bbox_a.x + bbox_a.width / 2) >= bbox_b.x and\n            (bbox_a.x + bbox_a.width / 2) <= (bbox_b.x + bbox_b.width) and\n            (bbox_a.y + bbox_a.height / 2) >= bbox_b.y and\n            (bbox_a.y + bbox_a.height / 2) <= (bbox_b.y + bbox_b.height)\n        )\n\n    @property\n    def area(self):\n        \"\"\"\n        Returns the area of the bounding box, handles negative bboxes as 0-area\n\n        :return: Bounding box area\n        :rtype: float\n        \"\"\"\n        if self.width < 0 or self.height < 0:\n            return 0\n        else:\n            return self.width * self.height\n\n    @classmethod\n    def _from_dict(\n        cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject = None\n    ):\n        \"\"\"\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`. \\\n        The co-ordinates will be denormalized according to spatial_object.\n\n        :param bbox_dict: Dictionary of normalized co-ordinates.\n        :type bbox_dict: dict\n        :param spatial_object: Object with width and height attributes.\n        :type spatial_object: SpatialObject\n\n        :return: Object with denormalized coordinates\n        :rtype: BoundingBox\n        \"\"\"\n        x = bbox_dict[\"Left\"]\n        y = bbox_dict[\"Top\"]\n        width = bbox_dict[\"Width\"]\n        height = bbox_dict[\"Height\"]\n        # if spatial_object is not None:\n        #    x, y, width, height = cls._denormalize(x, y, width, height, spatial_object)\n        # else:\n        #    spatial_object = None\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    def as_denormalized_numpy(self):\n        \"\"\"\n        :return: Returns denormalized co-ordinates x, y and dimensions width, height as numpy array.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.x, self.y, self.width, self.height])\n\n    def get_intersection(self, bbox):\n        \"\"\"\n        Returns the intersection of this object's bbox and another BoundingBox\n        :return: a BoundingBox object\n        \"\"\"\n        assert isinstance(bbox, BoundingBox)\n        x1y1x2y2 = (\n            max(self.x, bbox.x),\n            max(self.y, bbox.y),\n            min(self.x + self.width, bbox.x + bbox.width),\n            min(self.y + self.height, bbox.y + bbox.height),\n        )\n        return BoundingBox.from_denormalized_corners(\n            *x1y1x2y2, spatial_object=self.spatial_object\n        )\n\n    def get_distance(self, bbox):\n        \"\"\"\n        Returns the distance between the center point of the bounding box and another bounding box\n\n        :return: Returns the distance as float\n        :rtype: float\n        \"\"\"\n        return math.sqrt(\n            ((self.x + self.width / 2) - (bbox.x + bbox.width / 2)) ** 2\n            + ((self.y + self.height / 2) - (bbox.y + bbox.height / 2)) ** 2\n        )\n\n    def __repr__(self):\n        return f\"x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height}\"\n",
    "textractor/entities/document_entity.py": "\"\"\":class:`DocumentEntity` is the class that all Document entities such as :class:`Word`, :class:`Line`, :class:`Table` etc. inherit from. This class provides methods \nuseful to all such entities.\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Tuple\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.data.markdown_linearization_config import MarkdownLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\nclass DocumentEntity(Linearizable, ABC):\n    \"\"\"\n    An interface for all document entities within the document body, composing the\n    hierarchy of the document object model.\n    The purpose of this class is to define properties common to all document entities\n    i.e. unique id and bounding box.\n    \"\"\"\n\n    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\n        child entities within a document entity.\n\n        :param entity_id: Unique identifier of the document entity.\n        :param bbox: Bounding box of the entity\n        \"\"\"\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}  # Holds optional information about the entity\n        self._children = []\n        self._children_type = None\n        self._raw_object = None\n\n    def add_children(self, children):\n        \"\"\"\n        Adds children to all entities that have parent-child relationships.\n\n        :param children: List of child entities.\n        :type children: list\n        \"\"\"\n        self._children.extend(children)\n\n    @property\n    def raw_object(self) -> Dict:\n        \"\"\"\n        :return: Returns the raw dictionary object that was used to create this Python object\n        :rtype: Dict\n        \"\"\"\n        return self._raw_object\n\n    @raw_object.setter\n    def raw_object(self, raw_object: Dict):\n        \"\"\"\n        Sets the raw object that was used to create this Python object\n        :param raw_object: raw object dictionary from the response\n        :type raw_object: Dict\n        \"\"\"\n        self._raw_object = raw_object\n\n    @property\n    def x(self) -> float:\n        \"\"\"\n        :return: Returns x coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.x\n\n    @x.setter\n    def x(self, x: float):\n        \"\"\"\n        Sets x coordinate for bounding box\n\n        :param x: x coordinate of the bounding box\n        :type x: float\n        \"\"\"\n        self._bbox.x = x\n\n    @property\n    def y(self) -> float:\n        \"\"\"\n        :return: Returns y coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.y\n\n    @y.setter\n    def y(self, y: float):\n        \"\"\"\n        Sets y coordinate for bounding box.\n\n        :param y: y coordinate of the bounding box\n        :type y: float\n        \"\"\"\n        self._bbox.y = y\n\n    @property\n    def width(self) -> float:\n        \"\"\"\n        :return: Returns width for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.width\n\n    @width.setter\n    def width(self, width: float):\n        \"\"\"\n        Sets width for bounding box.\n\n        :param width: width of the bounding box\n        :type width: float\n        \"\"\"\n        self._bbox.width = width\n\n    @property\n    def height(self) -> float:\n        \"\"\"\n        :return: Returns height for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.height\n\n    @height.setter\n    def height(self, height: float):\n        \"\"\"\n        Sets height for bounding box.\n\n        :param height: height of the bounding box\n        :type height: float\n        \"\"\"\n        self._bbox.height = height\n\n    @property\n    def bbox(self) -> BoundingBox:\n        \"\"\"\n        :return: Returns entire bounding box of entity\n        :rtype: BoundingBox\n        \"\"\"\n        return self._bbox\n\n    @bbox.setter\n    def bbox(self, bbox: BoundingBox):\n        self._bbox = bbox\n\n    @property\n    def children(self):\n        \"\"\"\n        :return: Returns children of entity\n        :rtype: list\n        \"\"\"\n        return self._children\n\n    @property\n    def confidence(self) -> float:\n        \"\"\"\n        Returns the object confidence as predicted by Textract. If the confidence is not available, returns None\n\n        :return: Prediction confidence for a document entity, between 0 and 1\n        :rtype: float\n        \"\"\"\n        \n        # Needed for backward compatibility\n        if hasattr(self, \"_confidence\"):\n            return self._confidence\n    \n        # Uses the raw response\n        if not hasattr(self, \"raw_object\"):\n            return None\n        confidence = self.raw_object.get(\"Confidence\")\n        if confidence is None:\n            return None            \n        return confidence / 100\n\n    def remove(self, entity):\n        \"\"\"\n        Recursively removes an entity from the child tree of a document entity and update its bounding box\n\n        :param entity: Entity\n        :type entity: DocumentEntity\n        \"\"\"\n\n        for c in self._children:\n            if entity == c:\n                # Element was found in children\n                break\n            if not c.__class__.__name__ == \"Word\" and c.remove(entity):\n                # Element was found and removed in grand-children\n                if not c.children:\n                    self._children.remove(c)\n                return True\n        else:\n            # Element was not found\n            return False\n        self._children.remove(c)\n        if self._children:\n            self.bbox = BoundingBox.enclosing_bbox(self._children)\n        return True\n\n    def visit(self, word_set):\n        for c in list(self._children):\n            if c.__class__.__name__ == \"Word\":\n                if c.id in word_set:\n                    self._children.remove(c)\n                else:\n                    word_set.add(c.id)\n            else:\n                c.visit(word_set)\n\n    def visualize(self, *args, **kwargs) -> EntityList:\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)\n",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities \\\nin a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\n\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\n\nfrom textractor.data.constants import (\n    TextractType,\n    TableFormat,\n    AnalyzeExpenseLineItemFields,\n    AnalyzeExpenseFields,\n)\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\n\nlogger = logging.getLogger(__name__)\n\npresent_path = os.path.abspath(os.path.dirname(__file__))\n\nT = TypeVar(\"T\")\n\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def __init__(self, objs=None):\n        super().__init__()\n\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n\n        self.extend(objs)\n\n    def visualize(\n        self,\n        with_text: bool = True,\n        with_words: bool = True,\n        with_confidence: bool = False,\n        font_size_ratio: float = 0.5,\n    ) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        # FIXME: This is inelegant\n        if len(self) > 0 and any(\n            [ent.__class__.__name__ == \"Document\" for ent in self]\n        ):\n            return EntityList(self[0].pages).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and any([ent.__class__.__name__ == \"Page\" for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (\n                    entity.__class__.__name__ == \"Word\"\n                    or entity.__class__.__name__ == \"Line\"\n                ):\n                    continue\n                if entity.__class__.__name__ == \"Page\":\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(\n                            new_entity_list, expense_document\n                        )\n                elif entity.__class__.__name__ == \"ExpenseDocument\":\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(\n                with_text=with_text,\n                with_words=with_words,\n                with_confidence=with_confidence,\n                font_size_ratio=font_size_ratio,\n            )\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException(\n                \"Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.\"\n            )\n\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            # FIXME: There should be a way to recurse through all entities\n            except AttributeError:\n                pass\n\n        for page in list(entities_pagewise.keys()):\n            # Deduplication\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(\n                entities_pagewise[page],\n                with_text,\n                with_confidence,\n                font_size_ratio,\n            )\n\n        images = [image.convert(\"RGB\") for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if (\n                        expense.type.text\n                        != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name\n                    ):\n                        entity_list.append(expense)\n        return entity_list\n\n    def pretty_print(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        with_page_number: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for each of the entities in the list according to its entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.WORDS,\n        )\n        result_value += self._get_text_string(\n            with_page_number=with_page_number,\n            with_confidence=with_confidence,\n            trim=trim,\n            textract_type=TextractType.LINES,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.KEY_VALUE_SET,\n        )\n        result_value += self._get_forms_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n            textract_type=TextractType.SELECTION_ELEMENT,\n        )\n        result_value += self._get_tables_string(\n            table_format=table_format,\n            with_confidence=with_confidence,\n            with_geo=with_geo,\n            trim=trim,\n        )\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value\n\n    def _get_text_string(\n        self,\n        with_page_number=False,\n        with_confidence=False,\n        trim=False,\n        textract_type=TextractType.WORDS,\n    ):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        result_value = \"\"\n\n        if textract_type == TextractType.WORDS:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Word\"],\n                key=lambda x: x.page,\n            )\n        else:\n            objects = sorted(\n                [obj for obj in self if obj.__class__.__name__ == \"Line\"],\n                key=lambda x: x.page,\n            )\n\n        current_page = -1\n\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f\"--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}\"\n                current_page = word.page\n            if trim:\n                result_value += f\"{word.text.strip()}\"\n            else:\n                result_value += f\"{word.text}\"\n\n            if with_confidence:\n                result_value += f\", {word.confidence}\"\n            result_value += os.linesep\n\n        return result_value\n\n    def _get_forms_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n        textract_type=TextractType.KEY_VALUE_SET,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n        result_value = \"\"\n\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and not obj.contains_checkbox\n            ]\n        else:\n            key_value_objects = [\n                obj\n                for obj in self\n                if obj.__class__.__name__ == \"KeyValue\" and obj.contains_checkbox\n            ]\n\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                result_value += (\n                    tabulate(forms_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            csv_output = StringIO()\n            csv_writer = csv.writer(\n                csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n            )\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(\n                    kv_dict[page],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=textract_type,\n                )\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(\n        self,\n        table_format: TableFormat = TableFormat.GITHUB,\n        with_confidence: bool = False,\n        with_geo: bool = False,\n        trim: bool = False,\n    ) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n\n        logger.debug(f\"table_format: {table_format}\")\n\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == \"Table\":\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == \"TableCell\":\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n\n        result_value = \"\"\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                result_value += (\n                    tabulate(table_list, tablefmt=table_format.name.lower())\n                    + os.linesep\n                    + os.linesep\n                )\n\n        if table_format == TableFormat.CSV:\n            logger.debug(f\"pretty print - csv\")\n            for table_id in tables.keys():\n                table_type = (\n                    TextractType.TABLES\n                    if tables[table_id].__class__.__name__ == \"Table\"\n                    else TextractType.TABLE_CELL\n                )\n                csv_output = StringIO()\n                csv_writer = csv.writer(\n                    csv_output, delimiter=\",\", quotechar='\"', quoting=csv.QUOTE_MINIMAL\n                )\n\n                table_list = _convert_table_to_list(\n                    tables[table_id],\n                    with_confidence=with_confidence,\n                    with_geo=with_geo,\n                    trim=trim,\n                    textract_type=table_type,\n                )\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = \"\"\n        queries = [obj for obj in self if obj.__class__.__name__ == \"Query\"]\n\n        for query in queries:\n            if query.result is not None:\n                result_value += f\"{query.query} => {query.result.answer}{os.linesep}\"\n            else:\n                result_value += f\"{query.query} => {os.linesep}\"\n\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = \"\"\n        expense_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"ExpenseDocument\"\n        ]\n\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f\"Expense Document {i+1}:{os.linesep}\"\n            result_value += f\"### Summary Fields:{os.linesep}\"\n            result_value += f\"{expense_document.summary_fields}{os.linesep}\"\n            result_value += f\"### Line Item Groups: {os.linesep}\"\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f\"{line_item_group}{os.linesep}\"\n\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = \"\"\n        id_documents = [\n            obj for obj in self if obj.__class__.__name__ == \"IdentityDocument\"\n        ]\n\n        for id_document in id_documents:\n            result_value += f\"{id_document}{os.linesep}\"\n\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig = TextLinearizationConfig()):\n        texts, words = [], []\n        separator = (\n            config.same_paragraph_separator\n            if all([entity.__class__.__name__ == \"Word\" for entity in self]) else\n            config.layout_element_separator\n        )\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return separator.join(texts), words\n\ndef _convert_form_to_list(\n    form_objects,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.KEY_VALUE_SET,\n) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n\n    rows_list = list()\n    rows_list.append([\"Key\", \"Value\"])\n    for field in form_objects:\n        t_key = \"\"\n        t_value = \"\"\n        if field.key:\n            text = \" \".join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + field.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({field.key.confidence:.1f})\"\n        if field.value:\n            text = (\n                field.value.words\n                if textract_type == TextractType.SELECTION_ELEMENT\n                else \" \".join([word.text for word in field.value.words])\n            )\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += \" {\" + field.value.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_value += f\" ({field.value.confidence:.1f})\"\n        rows_list.append([t_key, t_value])\n    return rows_list\n\n\ndef _convert_table_to_list(\n    table_object,\n    with_confidence: bool = False,\n    with_geo: bool = False,\n    trim: bool = False,\n    textract_type=TextractType.TABLES,\n) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split(\">\")[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += \" {\" + cell.bbox.__repr__() + \"} \"\n            if with_confidence:\n                t_key += f\" ({cell.confidence:.1f})\"\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\n\ndef _draw_bbox(\n    entities: List[Any],\n    with_text: bool = False,\n    with_confidence: bool = False,\n    font_size_ratio: float = 0.5,\n):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception(\"Could not find an entity with an associated image!\")\n    image = image.convert(\"RGBA\")\n    overlay = Image.new(\"RGBA\", image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, \"RGBA\")\n\n    text_locations = {}\n\n    # First drawing tables\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == \"Table\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.title:\n                drw.rectangle(\n                    (\n                        int(entity.title.bbox.x * width),\n                        int(entity.title.bbox.y * height),\n                        int((entity.title.bbox.x + entity.title.bbox.width) * width),\n                        int((entity.title.bbox.y + entity.title.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"red\") + (120,),\n                    width=2,\n                )\n\n            for footer in entity.footers:\n                drw.rectangle(\n                    (\n                        int(footer.bbox.x * width),\n                        int(footer.bbox.y * height),\n                        int((footer.bbox.x + footer.bbox.width) * width),\n                        int((footer.bbox.y + footer.bbox.height) * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=ImageColor.getrgb(\"cyan\") + (120,),\n                    width=2,\n                )\n\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(\n                        zip(\n                            *[\n                                (\n                                    c.bbox.x,\n                                    c.bbox.y,\n                                    c.bbox.x + c.bbox.width,\n                                    c.bbox.y + c.bbox.height,\n                                )\n                                for c in cell.siblings + [cell]\n                            ]\n                        )\n                    )\n                    min_x, min_y, max_x, max_y = (\n                        min(min_x),\n                        min(min_y),\n                        max(max_x),\n                        max(max_y),\n                    )\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (\n                        cell.bbox.x,\n                        cell.bbox.y,\n                        cell.bbox.x + cell.bbox.width,\n                        cell.bbox.y + cell.bbox.height,\n                    )\n\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb(\"blue\") + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb(\"red\") + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb(\"cyan\") + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb(\"yellow\") + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb(\"green\") + (120,)\n\n                drw.rectangle(\n                    (\n                        int(min_x * width),\n                        int(min_y * height),\n                        int(max_x * width),\n                        int(max_y * height),\n                    ),\n                    outline=overlayer_data[\"color\"],\n                    fill=fill_color,\n                    width=2,\n                )\n                for checkbox in cell.checkboxes:\n                    drw.rectangle(\n                        (\n                            int(checkbox.bbox.x * width),\n                            int(checkbox.bbox.y * height),\n                            int((checkbox.bbox.x + checkbox.bbox.width) * width),\n                            int((checkbox.bbox.y + checkbox.bbox.height) * height),\n                        ),\n                        outline=ImageColor.getrgb(\"lightgreen\")\n                        if checkbox.is_selected()\n                        else ImageColor.getrgb(\"indianred\"),\n                    )\n    # Second drawing bounding boxes\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == \"Query\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableTitle\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"TableFooter\":\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n        elif entity.__class__.__name__ == \"ExpenseField\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords_value\"],\n                outline=overlayer_data[\"color_value\"],\n                width=2,\n            )\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(\n                    xy=overlayer_data[\"coords_key\"],\n                    outline=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n                drw.line(\n                    [\n                        (\n                            (b1.x + b1.width / 2) * width,\n                            (b1.y + b1.height / 2) * height,\n                        ),\n                        (\n                            (b2.x + b2.width / 2) * width,\n                            (b2.y + b2.height / 2) * height,\n                        ),\n                    ],\n                    fill=overlayer_data[\"color_key\"],\n                    width=2,\n                )\n        elif entity.__class__.__name__ == \"ExpenseDocument\":\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            for coord, text in zip(\n                overlayer_data[\"coords_list\"], overlayer_data[\"coords_list\"]\n            ):\n                drw.rectangle(\n                    xy=coord, outline=overlayer_data[\"color_expense_group\"], width=2\n                )\n        elif entity.__class__.__name__.startswith(\"Layout\"):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=4\n            )\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(\n                xy=overlayer_data[\"coords\"], outline=overlayer_data[\"color\"], width=2\n            )\n            if entity.__class__.__name__ == \"KeyValue\":\n                drw.rectangle(\n                    xy=overlayer_data[\"value_bbox\"],\n                    outline=overlayer_data[\"color_value\"],\n                    width=2,\n                )\n                b1 = overlayer_data[\"value_bbox\"]\n                b2 = overlayer_data[\"coords\"]\n                drw.line(\n                    [\n                        ((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2),\n                        ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2),\n                    ],\n                    fill=overlayer_data[\"color_value\"],\n                    width=1,\n                )\n\n    # Second drawing, text\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == \"Word\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__ == \"KeyValue\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                # Key Text\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(\n                    int(0.03 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color\"],\n                )\n\n                # Value Text\n                final_txt = overlayer_data[\"value_text\"]\n\n                bbox_height = (\n                    overlayer_data[\"value_bbox\"][3] - overlayer_data[\"value_bbox\"][1]\n                )\n                text_height = min(\n                    int(0.01 * height), int(bbox_height * font_size_ratio)\n                )\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"value_conf\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"value_bbox\"][0],\n                        overlayer_data[\"value_bbox\"][3] + 1,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"color_value\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseField\":\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = overlayer_data[\"text\"]\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                if entity.key is not None:\n                    x = overlayer_data[\"coords_key\"][0] + 0.3 * (\n                        overlayer_data[\"coords_key\"][2]\n                        - overlayer_data[\"coords_key\"][0]\n                    )\n                    y = overlayer_data[\"coords_key\"][1] - text_height - 1\n                else:\n                    x = int(\n                        overlayer_data[\"coords\"][0]\n                        + 0.3\n                        * (overlayer_data[\"coords\"][2] - overlayer_data[\"coords\"][0])\n                    )\n                    y = overlayer_data[\"coords\"][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[(x, y)] != final_txt:\n                    y = y - text_height - 1\n                text_locations[(x, y)] = final_txt\n                drw.text(\n                    (x, y),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n            elif entity.__class__.__name__ == \"ExpenseDocument\":\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(\n                    overlayer_data[\"coords_list\"], overlayer_data[\"text_list\"]\n                ):\n                    drw.text(\n                        (coord[0], coord[3]),\n                        text,\n                        font=fnt,\n                        fill=overlayer_data[\"color_expense_group\"],\n                    )\n\n            elif entity.__class__.__name__ == \"Query\":\n                if entity.result is None:\n                    continue\n\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n\n                final_txt = entity.query + \" \" + overlayer_data[\"text\"]\n\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                if with_confidence:\n                    final_txt += \" (\" + str(entity.result.confidence)[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n\n            elif entity.__class__.__name__.startswith(\"Layout\"):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n\n                final_txt = \"\"\n                bbox_height = overlayer_data[\"coords\"][3] - overlayer_data[\"coords\"][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(\n                    os.path.join(present_path, \"arial.ttf\"), text_height\n                )\n\n                final_txt += overlayer_data[\"text\"]\n\n                if with_confidence:\n                    final_txt += \" (\" + str(overlayer_data[\"confidence\"])[:4] + \")\"\n\n                drw.text(\n                    (\n                        overlayer_data[\"coords\"][0],\n                        overlayer_data[\"coords\"][1] - text_height,\n                    ),\n                    final_txt,\n                    font=fnt,\n                    fill=overlayer_data[\"text_color\"],\n                )\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (\n        bbox.x * width,\n        bbox.y * height,\n        bbox.width * width,\n        bbox.height * height,\n    )\n    data[\"coords\"] = [x, y, x + w, y + h]\n    data[\"confidence\"] = (\n        entity.confidence\n        if entity.__class__.__name__\n        not in [\n            \"Table\",\n            \"ExpenseField\",\n            \"ExpenseDocument\",\n            \"LineItemRow\",\n            \"LineItemGroup\",\n        ]\n        else \"\"\n    )\n    data[\"color\"] = (0, 0, 0)\n    data[\"text_color\"] = (0, 0, 0)\n\n    if entity.__class__.__name__ == \"Word\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"blue\")\n\n    elif entity.__class__.__name__ == \"Line\":\n        data[\"text\"] = entity.text\n        data[\"color\"] = ImageColor.getrgb(\"lightgrey\")\n        data[\"coords\"] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == \"KeyValue\":\n        data[\"text\"] = entity.key.__repr__()\n        data[\"color\"] = ImageColor.getrgb(\"brown\")\n        data[\"value_text\"] = entity.value.__repr__()\n        data[\"coords\"] = [x - 2, y - 2, x + w + 2, y + h + 2]\n\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data[\"value_conf\"] = entity.children[0].confidence\n\n        else:\n            value_bbox = entity.value.bbox\n            data[\"value_conf\"] = entity.value.confidence\n\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        x, y, w, h = (\n            value_bbox.x * width - 2,\n            value_bbox.y * height - 2,\n            value_bbox.width * width + 2,\n            value_bbox.height * height + 2,\n        )\n        data[\"value_bbox\"] = [x, y, x + w, y + h]\n\n    elif entity.__class__.__name__ == \"Table\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableTitle\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n    elif entity.__class__.__name__ == \"TableFooter\":\n        data[\"color\"] = ImageColor.getrgb(\"green\")\n        data[\"text\"] = \"\"\n\n    elif entity.__class__.__name__ == \"TableCell\":\n        data[\"color\"] = ImageColor.getrgb(\"skyblue\")\n        data[\"text\"] = entity.__repr__().split(\">\")[-1][1:]\n\n    elif entity.__class__.__name__ == \"QueryResult\":\n        data[\"color\"] = ImageColor.getrgb(\"mediumturquoise\")\n        data[\"text\"] = entity.answer\n    elif entity.__class__.__name__ == \"Signature\":\n        data[\"color\"] = ImageColor.getrgb(\"coral\")\n    elif entity.__class__.__name__ == \"ExpenseField\":\n        data[\"text\"] = entity.type.text\n        data[\"text_color\"] = ImageColor.getrgb(\"brown\")\n        data[\"coords\"] = [x - 5, y - 5, x + w + 5, y + h + 5]\n\n        if entity.key:\n            data[\"color_key\"] = ImageColor.getrgb(\"brown\")\n            data[\"coords_key\"] = (\n                entity.key.bbox.x * width - 3,\n                entity.key.bbox.y * height - 3,\n                (entity.key.bbox.x + entity.key.bbox.width) * width + 3,\n                ((entity.key.bbox.y + entity.key.bbox.height)) * height + 3,\n            )\n        data[\"color_value\"] = ImageColor.getrgb(\"orange\")\n        data[\"coords_value\"] = (\n            entity.value.bbox.x * width - 3,\n            entity.value.bbox.y * height - 3,\n            (entity.value.bbox.x + entity.value.bbox.width) * width + 3,\n            ((entity.value.bbox.y + entity.value.bbox.height)) * height + 3,\n        )\n    elif entity.__class__.__name__ == \"Expense\":\n        data[\"text\"] = entity.text\n        data[\"coords\"] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == \"ExpenseDocument\":\n        data[\"color\"] = ImageColor.getrgb(\"beige\")\n        data[\"coords_list\"] = []\n        data[\"text_list\"] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data[\"coords_list\"].append(\n                    (\n                        bbox.x * width - 5,\n                        bbox.y * height - 5,\n                        (bbox.x + bbox.width) * width + 3,\n                        (bbox.y + bbox.height) * height + 3,\n                    )\n                )\n                data[\"text_list\"].append(group)\n        data[\"color_expense_group\"] = ImageColor.getrgb(\"coral\")\n\n    elif entity.__class__.__name__ == \"LineItemGroup\":\n        data[\"color\"] = ImageColor.getrgb(\"lightblue\")\n        data[\"coords\"] = [x - 10, y - 10, x + w + 10, y + h + 10]\n\n    elif entity.__class__.__name__ == \"LineItemRow\":\n        data[\"color\"] = ImageColor.getrgb(\"lightyellow\")\n        data[\"coords\"] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith(\"Layout\"):\n        data[\"color\"] = ImageColor.getrgb(\"teal\")\n        data[\"text\"] = f\"{entity.layout_type} - {entity.reading_order}\"\n    else:\n        pass\n    return data\n"
  },
  "GT_src_dict": {
    "textractor/entities/word.py": {
      "Word.__init__": {
        "code": "    def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):\n        \"\"\"Initializes a new instance of the :class:`Word` class, representing a single word entity within a document, encapsulating its text, bounding box, type, and detection confidence.\n\n:param entity_id: A unique identifier for the Word entity.\n:type entity_id: str\n:param bbox: The bounding box of the Word entity, represented by a :class:`BoundingBox` object.\n:type bbox: BoundingBox\n:param text: The transcription of the Word entity (default is an empty string).\n:type text: str\n:param text_type: Specifies the type of text (either PRINTED or HANDWRITING) using the :class:`TextTypes` enumeration (default is PRINTED).\n:type text_type: TextTypes\n:param confidence: The confidence level of the word detection, expressed as a float between 0 and 100 (this is normalized to a range of 0.0 to 1.0 internally).\n:type confidence: float\n:param is_clickable: Indicates whether the Word entity is clickable (default is False).\n:type is_clickable: bool\n:param is_structure: Indicates if the Word entity has structural significance (default is False).\n:type is_structure: bool\n\nAttributes initialized include:\n- `_text`: Stores the text of the word.\n- `_text_type`: Stores the type of text (PRINTED or HANDWRITING).\n- `_confidence`: Holds the normalized confidence value.\n- `_page`, `_page_id`, `line`, `cell_bbox`, `cell_id`, \n  `row_index`, `col_index`, `row_span`, `col_span`, \n  `key_bbox`, `value_bbox`, `key_id`, `value_id`, \n  `kv_id`, `kv_bbox`, `line_id`, `line_bbox`,\n  `table_id`, `table_bbox`, `layout_id`, \n  `layout_type`, and `layout_bbox`: Additional attributes for further context in the document layout.\"\"\"\n        super().__init__(entity_id, bbox)\n        self._text = text\n        self._text_type = text_type\n        self._confidence = confidence / 100\n        self.is_clickable = is_clickable\n        self.is_structure = is_structure\n        self._page = None\n        self._page_id = None\n        self.line = None\n        self.cell_bbox = None\n        self.cell_id = None\n        self.row_index = None\n        self.col_index = None\n        self.row_span = None\n        self.col_span = None\n        self.key_bbox = None\n        self.value_bbox = None\n        self.key_id = None\n        self.value_id = None\n        self.kv_id = None\n        self.kv_bbox = None\n        self.line_id = None\n        self.line_bbox = None\n        self.table_id = None\n        self.table_bbox = None\n        self.layout_id = None\n        self.layout_type = None\n        self.layout_bbox = None",
        "docstring": "Initializes a new instance of the :class:`Word` class, representing a single word entity within a document, encapsulating its text, bounding box, type, and detection confidence.\n\n:param entity_id: A unique identifier for the Word entity.\n:type entity_id: str\n:param bbox: The bounding box of the Word entity, represented by a :class:`BoundingBox` object.\n:type bbox: BoundingBox\n:param text: The transcription of the Word entity (default is an empty string).\n:type text: str\n:param text_type: Specifies the type of text (either PRINTED or HANDWRITING) using the :class:`TextTypes` enumeration (default is PRINTED).\n:type text_type: TextTypes\n:param confidence: The confidence level of the word detection, expressed as a float between 0 and 100 (this is normalized to a range of 0.0 to 1.0 internally).\n:type confidence: float\n:param is_clickable: Indicates whether the Word entity is clickable (default is False).\n:type is_clickable: bool\n:param is_structure: Indicates if the Word entity has structural significance (default is False).\n:type is_structure: bool\n\nAttributes initialized include:\n- `_text`: Stores the text of the word.\n- `_text_type`: Stores the type of text (PRINTED or HANDWRITING).\n- `_confidence`: Holds the normalized confidence value.\n- `_page`, `_page_id`, `line`, `cell_bbox`, `cell_id`, \n  `row_index`, `col_index`, `row_span`, `col_span`, \n  `key_bbox`, `value_bbox`, `key_id`, `value_id`, \n  `kv_id`, `kv_bbox`, `line_id`, `line_bbox`,\n  `table_id`, `table_bbox`, `layout_id`, \n  `layout_type`, and `layout_bbox`: Additional attributes for further context in the document layout.",
        "signature": "def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):",
        "type": "Method",
        "class_signature": "class Word(DocumentEntity):"
      },
      "Word.text": {
        "code": "    def text(self, text: str):\n        \"\"\"Sets the transcription of the :class:`Word` entity to the specified string.\n\n:param text: A string containing the transcription of the Word entity. This text represents the actual content detected for the Word object.\n:type text: str\n\nThis method updates the internal attribute `_text` of the Word instance, which is used to retrieve the text content via the `text` property. This property allows external access to the transcription of the Word, while the setter modifies it. There are no significant side effects, aside from changing the value of the text associated with the Word entity.\"\"\"\n        '\\n        Sets the transcription of the :class:`Word` entity.\\n\\n        :param text: String containing the text transcription of the Word entity.\\n        :type text: str\\n        '\n        self._text = text",
        "docstring": "Sets the transcription of the :class:`Word` entity to the specified string.\n\n:param text: A string containing the transcription of the Word entity. This text represents the actual content detected for the Word object.\n:type text: str\n\nThis method updates the internal attribute `_text` of the Word instance, which is used to retrieve the text content via the `text` property. This property allows external access to the transcription of the Word, while the setter modifies it. There are no significant side effects, aside from changing the value of the text associated with the Word entity.",
        "signature": "def text(self, text: str):",
        "type": "Method",
        "class_signature": "class Word(DocumentEntity):"
      },
      "Word.text_type": {
        "code": "    def text_type(self, text_type: TextTypes):\n        \"\"\"Sets the text type of the `Word` entity, which can represent either printed or handwritten text. This method takes a `text_type` parameter, which must be an instance of the `TextTypes` enum defined in the `textractor.data.constants` module, ensuring that only valid text types can be assigned. The method assigns the provided `text_type` to the `_text_type` attribute of the `Word` object.\n\nParameters:\n- text_type (TextTypes): An instance of the `TextTypes` enum indicating the type of text to be set for the `Word`. This can be either PRINTED or HANDWRITING.\n\nReturns:\n- None\n\nSide Effects:\n- Updates the internal state of the `Word` object by changing the `_text_type` attribute to the specified value.\"\"\"\n        '\\n        Sets the text type of the :class:`Word` entity.\\n\\n        :param text_type: Constant containing the type of text\\n        '\n        assert isinstance(text_type, TextTypes)\n        self._text_type = text_type",
        "docstring": "Sets the text type of the `Word` entity, which can represent either printed or handwritten text. This method takes a `text_type` parameter, which must be an instance of the `TextTypes` enum defined in the `textractor.data.constants` module, ensuring that only valid text types can be assigned. The method assigns the provided `text_type` to the `_text_type` attribute of the `Word` object.\n\nParameters:\n- text_type (TextTypes): An instance of the `TextTypes` enum indicating the type of text to be set for the `Word`. This can be either PRINTED or HANDWRITING.\n\nReturns:\n- None\n\nSide Effects:\n- Updates the internal state of the `Word` object by changing the `_text_type` attribute to the specified value.",
        "signature": "def text_type(self, text_type: TextTypes):",
        "type": "Method",
        "class_signature": "class Word(DocumentEntity):"
      }
    },
    "textractor/entities/value.py": {
      "Value.__init__": {
        "code": "    def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float=0):\n        \"\"\"Initializes a new instance of the `Value` class, which represents a value entity within a document, typically extracted from a Textract API response. \n\nParameters:\n- `entity_id` (str): A unique identifier for the Word entity.\n- `bbox` (BoundingBox): A `BoundingBox` object that defines the entity's location and dimensions on the page.\n- `confidence` (float, optional): The confidence score of the detection, expressed as a percentage (default is 0). This is converted to a value between 0 and 1 for internal processing.\n\nThis constructor initializes several internal attributes: \n- `_words` (List[Word]): Stores the words associated with this value entity.\n- `_key_id` (str): Holds the ID of the associated key (if applicable).\n- `_contains_checkbox` (bool): Indicates whether this value entity includes a checkbox.\n- `_confidence` (float): Converted confidence score stored as a float.\n- `_page` (int): The page number where the entity is located.\n- `_page_id` (str): The ID of the page associated with this entity.\n\nThe class relies on `BoundingBox`, `Word`, and `DocumentEntity` classes defined in the textractor library, utilizing them to manage spatial properties and encapsulate functionality related to the document entities.\"\"\"\n        super().__init__(entity_id, bbox)\n        self._words: List[Word] = []\n        self._key_id = None\n        self._contains_checkbox = False\n        self._confidence = confidence / 100\n        self._page = None\n        self._page_id = None",
        "docstring": "Initializes a new instance of the `Value` class, which represents a value entity within a document, typically extracted from a Textract API response. \n\nParameters:\n- `entity_id` (str): A unique identifier for the Word entity.\n- `bbox` (BoundingBox): A `BoundingBox` object that defines the entity's location and dimensions on the page.\n- `confidence` (float, optional): The confidence score of the detection, expressed as a percentage (default is 0). This is converted to a value between 0 and 1 for internal processing.\n\nThis constructor initializes several internal attributes: \n- `_words` (List[Word]): Stores the words associated with this value entity.\n- `_key_id` (str): Holds the ID of the associated key (if applicable).\n- `_contains_checkbox` (bool): Indicates whether this value entity includes a checkbox.\n- `_confidence` (float): Converted confidence score stored as a float.\n- `_page` (int): The page number where the entity is located.\n- `_page_id` (str): The ID of the page associated with this entity.\n\nThe class relies on `BoundingBox`, `Word`, and `DocumentEntity` classes defined in the textractor library, utilizing them to manage spatial properties and encapsulate functionality related to the document entities.",
        "signature": "def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float=0):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.words": {
        "code": "    def words(self, words: List[Word]):\n        \"\"\"Adds a list of `Word` objects to the `Value` entity, representing words within its field. The input list is sorted based on the bounding box coordinates of each `Word`, ensuring proper ordering for display or processing.\n\n:param words: List of `Word` objects to be added to the `Value` entity. Each `Word` represents a textual component of the value.\n:type words: List[Word]\n:raises TypeError: If the input is not of type List[Word].\n\nThis method interacts with the `_words` attribute, which stores the words internally. The sorting is performed using the bounding box properties, specifically the `x` and `y` coordinates, defined in the `BoundingBox` class imported from `textractor.entities.bbox`. The internal ordering ensures that subsequent processes, such as linearizing the text or generating visual representations, maintain a consistent layout.\"\"\"\n        '\\n        Add Word objects to the Value.\\n\\n        :param words: List of Word objects, each representing a word within the Value field.\\n        No specific ordering is assumed as is it is ordered internally.\\n        :type words: list\\n        '\n        self._words = sorted(words, key=lambda x: x.bbox.x + x.bbox.y)",
        "docstring": "Adds a list of `Word` objects to the `Value` entity, representing words within its field. The input list is sorted based on the bounding box coordinates of each `Word`, ensuring proper ordering for display or processing.\n\n:param words: List of `Word` objects to be added to the `Value` entity. Each `Word` represents a textual component of the value.\n:type words: List[Word]\n:raises TypeError: If the input is not of type List[Word].\n\nThis method interacts with the `_words` attribute, which stores the words internally. The sorting is performed using the bounding box properties, specifically the `x` and `y` coordinates, defined in the `BoundingBox` class imported from `textractor.entities.bbox`. The internal ordering ensures that subsequent processes, such as linearizing the text or generating visual representations, maintain a consistent layout.",
        "signature": "def words(self, words: List[Word]):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.key_id": {
        "code": "    def key_id(self, key_id: str):\n        \"\"\"Sets the unique identifier for the associated KeyValue entity of the Value object.\n\n:param key_id: A string representing the unique identifier for the KeyValue entity that this Value object is linked to.\n:type key_id: str\n:raises ValueError: If the provided key_id is empty or invalid.\n\nThis method is pivotal for managing associations between Value entities and their corresponding Key entities within the document structure, ensuring that interactions and relationships between different document elements are correctly handled.\"\"\"\n        '\\n        Sets the :class:`KeyValue` ID to which this Value object is associated.\\n\\n        :param key_id: Unique identifier for the KeyValue entity to which this Value is associated.\\n        :type key_id: str\\n        '\n        self._key_id = key_id",
        "docstring": "Sets the unique identifier for the associated KeyValue entity of the Value object.\n\n:param key_id: A string representing the unique identifier for the KeyValue entity that this Value object is linked to.\n:type key_id: str\n:raises ValueError: If the provided key_id is empty or invalid.\n\nThis method is pivotal for managing associations between Value entities and their corresponding Key entities within the document structure, ensuring that interactions and relationships between different document elements are correctly handled.",
        "signature": "def key_id(self, key_id: str):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.contains_checkbox": {
        "code": "    def contains_checkbox(self, checkbox_present: bool):\n        \"\"\"Sets the value of the `_contains_checkbox` attribute, indicating whether the `Value` entity contains a checkbox (represented as a `SelectionElement`). This method accepts a boolean parameter to specify the presence or absence of a checkbox. \n\nParameters:\n- checkbox_present (bool): A boolean value that determines if a checkbox is present within the `Value` entity. Set to `True` if a checkbox is included; otherwise, set to `False`.\n\nSide effects:\n- Updates the internal state of the `Value` object by modifying the `_contains_checkbox` attribute, which may influence how the entity's text and words are processed in other methods, particularly in methods that handle checkbox logic.\n\nThis method contributes to the overall functionality of the `Value` class by allowing dynamic updates regarding the presence of checkbox elements, which affect how the associated words and text are interpreted and represented.\"\"\"\n        '\\n        Sets the contains_checkbox field to True/False depending on the presence of a :class:`SelectionElement`.\\n\\n        :param checkbox_present: True or False depending on checkbox presence.\\n        :type checkbox_present: bool\\n        '\n        self._contains_checkbox = checkbox_present",
        "docstring": "Sets the value of the `_contains_checkbox` attribute, indicating whether the `Value` entity contains a checkbox (represented as a `SelectionElement`). This method accepts a boolean parameter to specify the presence or absence of a checkbox. \n\nParameters:\n- checkbox_present (bool): A boolean value that determines if a checkbox is present within the `Value` entity. Set to `True` if a checkbox is included; otherwise, set to `False`.\n\nSide effects:\n- Updates the internal state of the `Value` object by modifying the `_contains_checkbox` attribute, which may influence how the entity's text and words are processed in other methods, particularly in methods that handle checkbox logic.\n\nThis method contributes to the overall functionality of the `Value` class by allowing dynamic updates regarding the presence of checkbox elements, which affect how the associated words and text are interpreted and represented.",
        "signature": "def contains_checkbox(self, checkbox_present: bool):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.page": {
        "code": "    def page(self, page_num: int):\n        \"\"\"Sets the page number for the Value entity, indicating which page of a document this entity appears on.\n\n:param page_num: The page number where the Value entity exists, represented as an integer.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which tracks the page number for identification and retrieval purposes within the context of the associated document. There are no return values, but it influences the overall metadata stored with the Value instance and may interact with other methods needing page information, such as rendering or analyzing document layout.\"\"\"\n        '\\n        Sets the page number attribute of the Value entity.\\n\\n        :param page_num: Page number where the Value entity exists.\\n        :type page_num: int\\n        '\n        self._page = page_num",
        "docstring": "Sets the page number for the Value entity, indicating which page of a document this entity appears on.\n\n:param page_num: The page number where the Value entity exists, represented as an integer.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which tracks the page number for identification and retrieval purposes within the context of the associated document. There are no return values, but it influences the overall metadata stored with the Value instance and may interact with other methods needing page information, such as rendering or analyzing document layout.",
        "signature": "def page(self, page_num: int):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.page_id": {
        "code": "    def page_id(self, page_id: str):\n        \"\"\"Sets the Page ID attribute of the `Value` entity, which associates this entity with a specific page in a document. \n\n:param page_id: The unique identifier representing the page to which the `Value` entity belongs. This ID allows linking the `Value` entity back to the source document page for further processing or analysis.\n:type page_id: str\n\nThis method modifies the internal state of the `Value` object by setting the `_page_id` attribute. The `_page_id` is later used in other methods that may need to reference the specific page associated with the `Value`, ensuring proper contextual information is maintained for document interpretation and visualization.\"\"\"\n        '\\n        Sets the Page ID of the :class:`Value` entity.\\n\\n        :param page_id: Page ID of the page the entity belongs to.\\n        :type page_id: str\\n        '\n        self._page_id = page_id",
        "docstring": "Sets the Page ID attribute of the `Value` entity, which associates this entity with a specific page in a document. \n\n:param page_id: The unique identifier representing the page to which the `Value` entity belongs. This ID allows linking the `Value` entity back to the source document page for further processing or analysis.\n:type page_id: str\n\nThis method modifies the internal state of the `Value` object by setting the `_page_id` attribute. The `_page_id` is later used in other methods that may need to reference the specific page associated with the `Value`, ensuring proper contextual information is maintained for document interpretation and visualization.",
        "signature": "def page_id(self, page_id: str):",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.get_words_by_type": {
        "code": "    def get_words_by_type(self, text_type: str=TextTypes.PRINTED) -> List[Word]:\n        \"\"\"Returns a list of `Word` entities within the `Value` object that match the specified text type. The `text_type` parameter can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`, which are defined in `textractor.data.constants`. If the provided `text_type` is not an instance of `TextTypes`, an `InputError` is raised. The method filters the words contained in the `Value` entity based on the specified text type and returns them encapsulated in an `EntityList`.\n\nParameters:\n- text_type (str): The desired text type of the words to be returned, which may either be `TextTypes.PRINTED` or `TextTypes.HANDWRITING`.\n\nReturns:\n- List[Word]: A list of `Word` entities matching the specified text type wrapped in an `EntityList`.\n\nRaises:\n- InputError: If the `text_type` parameter is not an instance of `TextTypes`.\"\"\"\n        '\\n        Returns list of :class:`Word` entities that match the input text type.\\n\\n        :param text_type: TextTypes.PRINTED or TextTypes.HANDWRITING\\n        :type text_type: TextTypes\\n\\n        :return: Returns list of Word entities that match the input text type.\\n        :rtype: EntityList[Word]\\n        '\n        if not isinstance(text_type, TextTypes):\n            raise InputError('text_type parameter should be of TextTypes type. Find input choices from textractor.data.constants')\n        return EntityList([word for word in self.words if word.text_type == text_type])",
        "docstring": "Returns a list of `Word` entities within the `Value` object that match the specified text type. The `text_type` parameter can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`, which are defined in `textractor.data.constants`. If the provided `text_type` is not an instance of `TextTypes`, an `InputError` is raised. The method filters the words contained in the `Value` entity based on the specified text type and returns them encapsulated in an `EntityList`.\n\nParameters:\n- text_type (str): The desired text type of the words to be returned, which may either be `TextTypes.PRINTED` or `TextTypes.HANDWRITING`.\n\nReturns:\n- List[Word]: A list of `Word` entities matching the specified text type wrapped in an `EntityList`.\n\nRaises:\n- InputError: If the `text_type` parameter is not an instance of `TextTypes`.",
        "signature": "def get_words_by_type(self, text_type: str=TextTypes.PRINTED) -> List[Word]:",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      },
      "Value.__repr__": {
        "code": "    def __repr__(self) -> str:\n        \"\"\"Returns a string representation of the Value entity. If the Value contains a checkbox, the string representation is derived from the first child element, which is expected to represent the checkbox. If it does not contain a checkbox, the representation is constructed by joining the text of all Word entities associated with the Value. The `words` property retrieves the list of Word entities, while the `children` property is used to access the checkbox representation if present. This method is crucial for providing a human-readable format of the Value entity when printed or logged.\"\"\"\n        '\\n        :return: String representation of the Value entity.\\n        :rtype: str\\n        '\n        repr_string = ''\n        if self.contains_checkbox:\n            repr_string += f'{self.children[0].__repr__()}'\n        else:\n            words = ' '.join([word.text for word in self.words])\n            repr_string += f'{words}'\n        return repr_string",
        "docstring": "Returns a string representation of the Value entity. If the Value contains a checkbox, the string representation is derived from the first child element, which is expected to represent the checkbox. If it does not contain a checkbox, the representation is constructed by joining the text of all Word entities associated with the Value. The `words` property retrieves the list of Word entities, while the `children` property is used to access the checkbox representation if present. This method is crucial for providing a human-readable format of the Value entity when printed or logged.",
        "signature": "def __repr__(self) -> str:",
        "type": "Method",
        "class_signature": "class Value(DocumentEntity):"
      }
    },
    "textractor/data/constants.py": {},
    "textractor/entities/bbox.py": {
      "SpatialObject.__init__": {
        "code": "    def __init__(self, width: float, height: float):\n        \"\"\"Initializes a SpatialObject with specified width and height attributes. This class serves as a base interface for defining entities that occupy space, particularly used in conjunction with the BoundingBox class to provide normalized coordinates for spatial representations. \n\n    :param width: The width of the spatial object as a float. \n    :param height: The height of the spatial object as a float. \n\n    This method does not return any value. The values assigned to width and height are utilized by derived classes, such as BoundingBox, to perform operations related to spatial measurements and normalization.\"\"\"\n        self.width = width\n        self.height = height",
        "docstring": "Initializes a SpatialObject with specified width and height attributes. This class serves as a base interface for defining entities that occupy space, particularly used in conjunction with the BoundingBox class to provide normalized coordinates for spatial representations. \n\n:param width: The width of the spatial object as a float. \n:param height: The height of the spatial object as a float. \n\nThis method does not return any value. The values assigned to width and height are utilized by derived classes, such as BoundingBox, to perform operations related to spatial measurements and normalization.",
        "signature": "def __init__(self, width: float, height: float):",
        "type": "Method",
        "class_signature": "class SpatialObject(ABC):"
      },
      "BoundingBox.__init__": {
        "code": "    def __init__(self, x: float, y: float, width: float, height: float, spatial_object=None):\n        \"\"\"Initializes a BoundingBox object, which represents a rectangular area on a 2D plane based on its top-left corner coordinates, width, and height. This class is useful for locating document entities in an image. \n\nParameters:\n- x (float): The x-coordinate of the top-left corner of the bounding box.\n- y (float): The y-coordinate of the top-left corner of the bounding box.\n- width (float): The width of the bounding box.\n- height (float): The height of the bounding box.\n- spatial_object (SpatialObject, optional): An object with width and height attributes, used for normalizing bounding box coordinates if required.\n\nThis constructor calls the superclass (SpatialObject) initializer to set the width and height attributes. The spatial_object parameter allows associating the bounding box with a specific object (e.g., Document or Page) which may be relevant for denormalization purposes in other methods of the BoundingBox class.\"\"\"\n        super().__init__(width, height)\n        self.spatial_object = spatial_object\n        self.x = x\n        self.y = y",
        "docstring": "Initializes a BoundingBox object, which represents a rectangular area on a 2D plane based on its top-left corner coordinates, width, and height. This class is useful for locating document entities in an image. \n\nParameters:\n- x (float): The x-coordinate of the top-left corner of the bounding box.\n- y (float): The y-coordinate of the top-left corner of the bounding box.\n- width (float): The width of the bounding box.\n- height (float): The height of the bounding box.\n- spatial_object (SpatialObject, optional): An object with width and height attributes, used for normalizing bounding box coordinates if required.\n\nThis constructor calls the superclass (SpatialObject) initializer to set the width and height attributes. The spatial_object parameter allows associating the bounding box with a specific object (e.g., Document or Page) which may be relevant for denormalization purposes in other methods of the BoundingBox class.",
        "signature": "def __init__(self, x: float, y: float, width: float, height: float, spatial_object=None):",
        "type": "Method",
        "class_signature": "class BoundingBox(SpatialObject):"
      },
      "BoundingBox.from_normalized_dict": {
        "code": "    def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n        \"\"\"Builds a denormalized `BoundingBox` object from a dictionary containing normalized coordinates. The input dictionary should have the keys 'x', 'y', 'width', and 'height', which represent normalized coordinates relative to a `spatial_object`. If provided, `spatial_object` is used to denormalize these coordinates based on its width and height attributes. This method interacts with the `_from_dict` method to create the final `BoundingBox` instance.\n\nParameters:\n- `bbox_dict` (Dict[str, float]): A dictionary containing normalized coordinates and dimensions.\n- `spatial_object` (SpatialObject, optional): An object with width and height attributes to denormalize the coordinates.\n\nReturns:\n- `BoundingBox`: An instance of the `BoundingBox` class with denormalized coordinates based on the input dictionary, or raises an error if the dictionary doesn't contain the required keys.\"\"\"\n        \"\\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The coordinates will be denormalized according to spatial_object.\\n\\n        :param bbox_dict: Dictionary of normalized co-ordinates.\\n        :type bbox_dict: dict\\n        :param spatial_object: Object with width and height attributes.\\n        :type spatial_object: SpatialObject\\n\\n        :return: Object with denormalized co-ordinates\\n        :rtype: BoundingBox\\n        \"\n        return cls._from_dict(bbox_dict, spatial_object)",
        "docstring": "Builds a denormalized `BoundingBox` object from a dictionary containing normalized coordinates. The input dictionary should have the keys 'x', 'y', 'width', and 'height', which represent normalized coordinates relative to a `spatial_object`. If provided, `spatial_object` is used to denormalize these coordinates based on its width and height attributes. This method interacts with the `_from_dict` method to create the final `BoundingBox` instance.\n\nParameters:\n- `bbox_dict` (Dict[str, float]): A dictionary containing normalized coordinates and dimensions.\n- `spatial_object` (SpatialObject, optional): An object with width and height attributes to denormalize the coordinates.\n\nReturns:\n- `BoundingBox`: An instance of the `BoundingBox` class with denormalized coordinates based on the input dictionary, or raises an error if the dictionary doesn't contain the required keys.",
        "signature": "def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):",
        "type": "Method",
        "class_signature": "class BoundingBox(SpatialObject):"
      },
      "BoundingBox._from_dict": {
        "code": "    def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n        \"\"\"Builds a `BoundingBox` instance from a dictionary that specifies the bounding box coordinates. The dictionary should contain keys for 'Left', 'Top', 'Width', and 'Height', which represent the position and dimensions of the bounding box in denormalized coordinates. This method is designed for convenience when initializing a `BoundingBox` from structured data.\n\n:param bbox_dict: A dictionary containing the bounding box's properties:\n                  - 'Left': The x-coordinate of the top-left corner.\n                  - 'Top': The y-coordinate of the top-left corner.\n                  - 'Width': The width of the bounding box.\n                  - 'Height': The height of the bounding box.\n:type bbox_dict: Dict[str, float]\n:param spatial_object: An optional parameter that can be used to associate the bounding box with a `SpatialObject`, which may be useful for applications requiring context about dimensions.\n:type spatial_object: SpatialObject, optional\n:return: A `BoundingBox` object constructed from the provided dictionary.\n:rtype: BoundingBox\"\"\"\n        \"\\n        Builds an axis aligned BoundingBox from a dictionary like :code:`{'x': x, 'y': y, 'width': width, 'height': height}`.         The co-ordinates will be denormalized according to spatial_object.\\n\\n        :param bbox_dict: Dictionary of normalized co-ordinates.\\n        :type bbox_dict: dict\\n        :param spatial_object: Object with width and height attributes.\\n        :type spatial_object: SpatialObject\\n\\n        :return: Object with denormalized coordinates\\n        :rtype: BoundingBox\\n        \"\n        x = bbox_dict['Left']\n        y = bbox_dict['Top']\n        width = bbox_dict['Width']\n        height = bbox_dict['Height']\n        return BoundingBox(x, y, width, height, spatial_object)",
        "docstring": "Builds a `BoundingBox` instance from a dictionary that specifies the bounding box coordinates. The dictionary should contain keys for 'Left', 'Top', 'Width', and 'Height', which represent the position and dimensions of the bounding box in denormalized coordinates. This method is designed for convenience when initializing a `BoundingBox` from structured data.\n\n:param bbox_dict: A dictionary containing the bounding box's properties:\n                  - 'Left': The x-coordinate of the top-left corner.\n                  - 'Top': The y-coordinate of the top-left corner.\n                  - 'Width': The width of the bounding box.\n                  - 'Height': The height of the bounding box.\n:type bbox_dict: Dict[str, float]\n:param spatial_object: An optional parameter that can be used to associate the bounding box with a `SpatialObject`, which may be useful for applications requiring context about dimensions.\n:type spatial_object: SpatialObject, optional\n:return: A `BoundingBox` object constructed from the provided dictionary.\n:rtype: BoundingBox",
        "signature": "def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):",
        "type": "Method",
        "class_signature": "class BoundingBox(SpatialObject):"
      }
    },
    "textractor/entities/document_entity.py": {
      "DocumentEntity.__init__": {
        "code": "    def __init__(self, entity_id: str, bbox: BoundingBox):\n        \"\"\"Initialize a DocumentEntity instance, which serves as a base class for all document-related entities in the document object model. This constructor sets up common properties such as a unique identifier and a bounding box, and it initializes collections for child entities and metadata.\n\n:param entity_id: A string representing the unique identifier of the document entity.\n:param bbox: A BoundingBox object defining the spatial extent of the entity within the document.\n\nAttributes initialized include:\n- `id`: Stores the entity's unique identifier.\n- `_bbox`: The BoundingBox instance representing the entity's width, height, and position.\n- `metadata`: A dictionary for holding optional information about the entity.\n- `_children`: A list to store child entities linked to this DocumentEntity.\n- `_children_type`: Initially set to None, reserved for categorizing child types if necessary.\n- `_raw_object`: A placeholder for the raw data structure used during object creation for reference purposes.\"\"\"\n        '\\n        Initialize the common properties to DocumentEntities. Additionally, it contains information about\\n        child entities within a document entity.\\n\\n        :param entity_id: Unique identifier of the document entity.\\n        :param bbox: Bounding box of the entity\\n        '\n        self.id = entity_id\n        self._bbox: BoundingBox = bbox\n        self.metadata = {}\n        self._children = []\n        self._children_type = None\n        self._raw_object = None",
        "docstring": "Initialize a DocumentEntity instance, which serves as a base class for all document-related entities in the document object model. This constructor sets up common properties such as a unique identifier and a bounding box, and it initializes collections for child entities and metadata.\n\n:param entity_id: A string representing the unique identifier of the document entity.\n:param bbox: A BoundingBox object defining the spatial extent of the entity within the document.\n\nAttributes initialized include:\n- `id`: Stores the entity's unique identifier.\n- `_bbox`: The BoundingBox instance representing the entity's width, height, and position.\n- `metadata`: A dictionary for holding optional information about the entity.\n- `_children`: A list to store child entities linked to this DocumentEntity.\n- `_children_type`: Initially set to None, reserved for categorizing child types if necessary.\n- `_raw_object`: A placeholder for the raw data structure used during object creation for reference purposes.",
        "signature": "def __init__(self, entity_id: str, bbox: BoundingBox):",
        "type": "Method",
        "class_signature": "class DocumentEntity(Linearizable, ABC):"
      },
      "DocumentEntity.bbox": {
        "code": "    def bbox(self, bbox: BoundingBox):\n        \"\"\"Sets the bounding box for the document entity.\n\n:param bbox: A `BoundingBox` object representing the new bounding box for the entity.\n:type bbox: BoundingBox\n:raises ValueError: If the provided bbox is not an instance of `BoundingBox`.\n\nThis method updates the private attribute `_bbox` to the new bounding box provided, which is crucial for positioning and layout purposes of the entity within the document. The `BoundingBox` type must align with the expected structure and functionality as defined in the `textractor.entities.bbox` module.\"\"\"\n        self._bbox = bbox",
        "docstring": "Sets the bounding box for the document entity.\n\n:param bbox: A `BoundingBox` object representing the new bounding box for the entity.\n:type bbox: BoundingBox\n:raises ValueError: If the provided bbox is not an instance of `BoundingBox`.\n\nThis method updates the private attribute `_bbox` to the new bounding box provided, which is crucial for positioning and layout purposes of the entity within the document. The `BoundingBox` type must align with the expected structure and functionality as defined in the `textractor.entities.bbox` module.",
        "signature": "def bbox(self, bbox: BoundingBox):",
        "type": "Method",
        "class_signature": "class DocumentEntity(Linearizable, ABC):"
      }
    },
    "textractor/visualizers/entitylist.py": {
      "EntityList.__init__": {
        "code": "    def __init__(self, objs=None):\n        \"\"\"Initializes an `EntityList` object that extends Python's built-in list to manage a custom list of document entities.\n\nThis constructor can accept an optional parameter, `objs`, which can be a single object or a list of objects. If `objs` is not provided or is `None`, it initializes the list as empty. If `objs` is not a list, it wraps it in a list before extending the `EntityList` with these entities.\n\nParameters:\n- `objs` (optional): A list of entity objects to initialize the `EntityList`. If a single entity is provided, it is converted into a list.\n\nThe constructor also interacts with Python's built-in list methods, particularly `extend`, to populate the new `EntityList` instance. The expected output is a new `EntityList` instance containing the specified entities or being empty if no entities are provided.\"\"\"\n        super().__init__()\n        if objs is None:\n            objs = []\n        elif not isinstance(objs, list):\n            objs = [objs]\n        self.extend(objs)",
        "docstring": "Initializes an `EntityList` object that extends Python's built-in list to manage a custom list of document entities.\n\nThis constructor can accept an optional parameter, `objs`, which can be a single object or a list of objects. If `objs` is not provided or is `None`, it initializes the list as empty. If `objs` is not a list, it wraps it in a list before extending the `EntityList` with these entities.\n\nParameters:\n- `objs` (optional): A list of entity objects to initialize the `EntityList`. If a single entity is provided, it is converted into a list.\n\nThe constructor also interacts with Python's built-in list methods, particularly `extend`, to populate the new `EntityList` instance. The expected output is a new `EntityList` instance containing the specified entities or being empty if no entities are provided.",
        "signature": "def __init__(self, objs=None):",
        "type": "Method",
        "class_signature": "class EntityList(list, Generic[T], Linearizable):"
      }
    }
  },
  "dependency_dict": {
    "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {},
    "textractor/entities/bbox.py:BoundingBox:_from_dict": {},
    "textractor/entities/bbox.py:BoundingBox:__init__": {},
    "textractor/entities/word.py:Word:__init__": {},
    "textractor/entities/document_entity.py:DocumentEntity:__init__": {},
    "textractor/entities/value.py:Value:__init__": {},
    "textractor/entities/value.py:Value:words": {},
    "textractor/entities/document_entity.py:DocumentEntity:bbox": {},
    "textractor/entities/value.py:Value:get_words_by_type": {},
    "textractor/data/constants.py:TextTypes:TextTypes": {},
    "textractor/entities/word.py:Word:text_type": {},
    "textractor/visualizers/entitylist.py:EntityList:__init__": {},
    "textractor/entities/value.py:Value:__repr__": {},
    "textractor/entities/value.py:Value:contains_checkbox": {},
    "textractor/entities/word.py:Word:text": {}
  },
  "PRD": "# PROJECT NAME: amazon_textract_textractor-test_value\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 textractor/\n    \u251c\u2500\u2500 data/\n    \u2502   \u2514\u2500\u2500 constants.py\n    \u2502       \u2514\u2500\u2500 TextTypes.TextTypes\n    \u251c\u2500\u2500 entities/\n    \u2502   \u251c\u2500\u2500 bbox.py\n    \u2502   \u2502   \u251c\u2500\u2500 BoundingBox.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 BoundingBox._from_dict\n    \u2502   \u2502   \u251c\u2500\u2500 BoundingBox.from_normalized_dict\n    \u2502   \u2502   \u2514\u2500\u2500 SpatialObject.__init__\n    \u2502   \u251c\u2500\u2500 document_entity.py\n    \u2502   \u2502   \u251c\u2500\u2500 DocumentEntity.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 DocumentEntity.bbox\n    \u2502   \u251c\u2500\u2500 value.py\n    \u2502   \u2502   \u251c\u2500\u2500 Value.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 Value.__repr__\n    \u2502   \u2502   \u251c\u2500\u2500 Value.contains_checkbox\n    \u2502   \u2502   \u251c\u2500\u2500 Value.get_words_by_type\n    \u2502   \u2502   \u251c\u2500\u2500 Value.key_id\n    \u2502   \u2502   \u251c\u2500\u2500 Value.page\n    \u2502   \u2502   \u251c\u2500\u2500 Value.page_id\n    \u2502   \u2502   \u2514\u2500\u2500 Value.words\n    \u2502   \u2514\u2500\u2500 word.py\n    \u2502       \u251c\u2500\u2500 Word.__init__\n    \u2502       \u251c\u2500\u2500 Word.text\n    \u2502       \u2514\u2500\u2500 Word.text_type\n    \u2514\u2500\u2500 visualizers/\n        \u2514\u2500\u2500 entitylist.py\n            \u2514\u2500\u2500 EntityList.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and manage the functionality of key-value pair objects within text extraction workflows, specifically focusing on the integration of textual and positional data. It provides capabilities to associate, retrieve, and manipulate text elements (words) and their bounding box metadata for a given value entity, as well as access related attributes such as key identifiers, page assignments, and checkbox states. By enabling precise handling of structured and semi-structured text data, the module facilitates the processing of text extracted from documents, ensuring consistency and ease of interaction with spatial and textual relationships. This streamlines text recognition systems by simplifying the testing and verification of extracted data integrity and relationships.\n\n## FILE 1: textractor/entities/word.py\n\n- CLASS METHOD: Word.text_type\n  - CLASS SIGNATURE: class Word(DocumentEntity):\n  - SIGNATURE: def text_type(self, text_type: TextTypes):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the text type of the `Word` entity, which can represent either printed or handwritten text. This method takes a `text_type` parameter, which must be an instance of the `TextTypes` enum defined in the `textractor.data.constants` module, ensuring that only valid text types can be assigned. The method assigns the provided `text_type` to the `_text_type` attribute of the `Word` object.\n\nParameters:\n- text_type (TextTypes): An instance of the `TextTypes` enum indicating the type of text to be set for the `Word`. This can be either PRINTED or HANDWRITING.\n\nReturns:\n- None\n\nSide Effects:\n- Updates the internal state of the `Word` object by changing the `_text_type` attribute to the specified value.\n\"\"\"\n```\n\n- CLASS METHOD: Word.text\n  - CLASS SIGNATURE: class Word(DocumentEntity):\n  - SIGNATURE: def text(self, text: str):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the transcription of the :class:`Word` entity to the specified string.\n\n:param text: A string containing the transcription of the Word entity. This text represents the actual content detected for the Word object.\n:type text: str\n\nThis method updates the internal attribute `_text` of the Word instance, which is used to retrieve the text content via the `text` property. This property allows external access to the transcription of the Word, while the setter modifies it. There are no significant side effects, aside from changing the value of the text associated with the Word entity.\n\"\"\"\n```\n\n- CLASS METHOD: Word.__init__\n  - CLASS SIGNATURE: class Word(DocumentEntity):\n  - SIGNATURE: def __init__(self, entity_id: str, bbox: BoundingBox, text: str='', text_type: TextTypes=TextTypes.PRINTED, confidence: float=0, is_clickable: bool=False, is_structure: bool=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the :class:`Word` class, representing a single word entity within a document, encapsulating its text, bounding box, type, and detection confidence.\n\n:param entity_id: A unique identifier for the Word entity.\n:type entity_id: str\n:param bbox: The bounding box of the Word entity, represented by a :class:`BoundingBox` object.\n:type bbox: BoundingBox\n:param text: The transcription of the Word entity (default is an empty string).\n:type text: str\n:param text_type: Specifies the type of text (either PRINTED or HANDWRITING) using the :class:`TextTypes` enumeration (default is PRINTED).\n:type text_type: TextTypes\n:param confidence: The confidence level of the word detection, expressed as a float between 0 and 100 (this is normalized to a range of 0.0 to 1.0 internally).\n:type confidence: float\n:param is_clickable: Indicates whether the Word entity is clickable (default is False).\n:type is_clickable: bool\n:param is_structure: Indicates if the Word entity has structural significance (default is False).\n:type is_structure: bool\n\nAttributes initialized include:\n- `_text`: Stores the text of the word.\n- `_text_type`: Stores the type of text (PRINTED or HANDWRITING).\n- `_confidence`: Holds the normalized confidence value.\n- `_page`, `_page_id`, `line`, `cell_bbox`, `cell_id`, \n  `row_index`, `col_index`, `row_span`, `col_span`, \n  `key_bbox`, `value_bbox`, `key_id`, `value_id`, \n  `kv_id`, `kv_bbox`, `line_id`, `line_bbox`,\n  `table_id`, `table_bbox`, `layout_id`, \n  `layout_type`, and `layout_bbox`: Additional attributes for further context in the document layout.\n\"\"\"\n```\n\n## FILE 2: textractor/entities/value.py\n\n- CLASS METHOD: Value.page_id\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def page_id(self, page_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the Page ID attribute of the `Value` entity, which associates this entity with a specific page in a document. \n\n:param page_id: The unique identifier representing the page to which the `Value` entity belongs. This ID allows linking the `Value` entity back to the source document page for further processing or analysis.\n:type page_id: str\n\nThis method modifies the internal state of the `Value` object by setting the `_page_id` attribute. The `_page_id` is later used in other methods that may need to reference the specific page associated with the `Value`, ensuring proper contextual information is maintained for document interpretation and visualization.\n\"\"\"\n```\n\n- CLASS METHOD: Value.get_words_by_type\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def get_words_by_type(self, text_type: str=TextTypes.PRINTED) -> List[Word]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of `Word` entities within the `Value` object that match the specified text type. The `text_type` parameter can be either `TextTypes.PRINTED` or `TextTypes.HANDWRITING`, which are defined in `textractor.data.constants`. If the provided `text_type` is not an instance of `TextTypes`, an `InputError` is raised. The method filters the words contained in the `Value` entity based on the specified text type and returns them encapsulated in an `EntityList`.\n\nParameters:\n- text_type (str): The desired text type of the words to be returned, which may either be `TextTypes.PRINTED` or `TextTypes.HANDWRITING`.\n\nReturns:\n- List[Word]: A list of `Word` entities matching the specified text type wrapped in an `EntityList`.\n\nRaises:\n- InputError: If the `text_type` parameter is not an instance of `TextTypes`.\n\"\"\"\n```\n\n- CLASS METHOD: Value.contains_checkbox\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def contains_checkbox(self, checkbox_present: bool):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the value of the `_contains_checkbox` attribute, indicating whether the `Value` entity contains a checkbox (represented as a `SelectionElement`). This method accepts a boolean parameter to specify the presence or absence of a checkbox. \n\nParameters:\n- checkbox_present (bool): A boolean value that determines if a checkbox is present within the `Value` entity. Set to `True` if a checkbox is included; otherwise, set to `False`.\n\nSide effects:\n- Updates the internal state of the `Value` object by modifying the `_contains_checkbox` attribute, which may influence how the entity's text and words are processed in other methods, particularly in methods that handle checkbox logic.\n\nThis method contributes to the overall functionality of the `Value` class by allowing dynamic updates regarding the presence of checkbox elements, which affect how the associated words and text are interpreted and represented.\n\"\"\"\n```\n\n- CLASS METHOD: Value.words\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def words(self, words: List[Word]):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds a list of `Word` objects to the `Value` entity, representing words within its field. The input list is sorted based on the bounding box coordinates of each `Word`, ensuring proper ordering for display or processing.\n\n:param words: List of `Word` objects to be added to the `Value` entity. Each `Word` represents a textual component of the value.\n:type words: List[Word]\n:raises TypeError: If the input is not of type List[Word].\n\nThis method interacts with the `_words` attribute, which stores the words internally. The sorting is performed using the bounding box properties, specifically the `x` and `y` coordinates, defined in the `BoundingBox` class imported from `textractor.entities.bbox`. The internal ordering ensures that subsequent processes, such as linearizing the text or generating visual representations, maintain a consistent layout.\n\"\"\"\n```\n\n- CLASS METHOD: Value.__init__\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def __init__(self, entity_id: str, bbox: BoundingBox, confidence: float=0):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the `Value` class, which represents a value entity within a document, typically extracted from a Textract API response. \n\nParameters:\n- `entity_id` (str): A unique identifier for the Word entity.\n- `bbox` (BoundingBox): A `BoundingBox` object that defines the entity's location and dimensions on the page.\n- `confidence` (float, optional): The confidence score of the detection, expressed as a percentage (default is 0). This is converted to a value between 0 and 1 for internal processing.\n\nThis constructor initializes several internal attributes: \n- `_words` (List[Word]): Stores the words associated with this value entity.\n- `_key_id` (str): Holds the ID of the associated key (if applicable).\n- `_contains_checkbox` (bool): Indicates whether this value entity includes a checkbox.\n- `_confidence` (float): Converted confidence score stored as a float.\n- `_page` (int): The page number where the entity is located.\n- `_page_id` (str): The ID of the page associated with this entity.\n\nThe class relies on `BoundingBox`, `Word`, and `DocumentEntity` classes defined in the textractor library, utilizing them to manage spatial properties and encapsulate functionality related to the document entities.\n\"\"\"\n```\n\n- CLASS METHOD: Value.page\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def page(self, page_num: int):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the page number for the Value entity, indicating which page of a document this entity appears on.\n\n:param page_num: The page number where the Value entity exists, represented as an integer.\n:type page_num: int\n\nThis method updates the internal attribute `_page`, which tracks the page number for identification and retrieval purposes within the context of the associated document. There are no return values, but it influences the overall metadata stored with the Value instance and may interact with other methods needing page information, such as rendering or analyzing document layout.\n\"\"\"\n```\n\n- CLASS METHOD: Value.__repr__\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def __repr__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a string representation of the Value entity. If the Value contains a checkbox, the string representation is derived from the first child element, which is expected to represent the checkbox. If it does not contain a checkbox, the representation is constructed by joining the text of all Word entities associated with the Value. The `words` property retrieves the list of Word entities, while the `children` property is used to access the checkbox representation if present. This method is crucial for providing a human-readable format of the Value entity when printed or logged.\n\"\"\"\n```\n\n- CLASS METHOD: Value.key_id\n  - CLASS SIGNATURE: class Value(DocumentEntity):\n  - SIGNATURE: def key_id(self, key_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the unique identifier for the associated KeyValue entity of the Value object.\n\n:param key_id: A string representing the unique identifier for the KeyValue entity that this Value object is linked to.\n:type key_id: str\n:raises ValueError: If the provided key_id is empty or invalid.\n\nThis method is pivotal for managing associations between Value entities and their corresponding Key entities within the document structure, ensuring that interactions and relationships between different document elements are correctly handled.\n\"\"\"\n```\n\n## FILE 3: textractor/data/constants.py\n\n## FILE 4: textractor/entities/bbox.py\n\n- CLASS METHOD: BoundingBox._from_dict\n  - CLASS SIGNATURE: class BoundingBox(SpatialObject):\n  - SIGNATURE: def _from_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds a `BoundingBox` instance from a dictionary that specifies the bounding box coordinates. The dictionary should contain keys for 'Left', 'Top', 'Width', and 'Height', which represent the position and dimensions of the bounding box in denormalized coordinates. This method is designed for convenience when initializing a `BoundingBox` from structured data.\n\n:param bbox_dict: A dictionary containing the bounding box's properties:\n                  - 'Left': The x-coordinate of the top-left corner.\n                  - 'Top': The y-coordinate of the top-left corner.\n                  - 'Width': The width of the bounding box.\n                  - 'Height': The height of the bounding box.\n:type bbox_dict: Dict[str, float]\n:param spatial_object: An optional parameter that can be used to associate the bounding box with a `SpatialObject`, which may be useful for applications requiring context about dimensions.\n:type spatial_object: SpatialObject, optional\n:return: A `BoundingBox` object constructed from the provided dictionary.\n:rtype: BoundingBox\n\"\"\"\n```\n\n- CLASS METHOD: SpatialObject.__init__\n  - CLASS SIGNATURE: class SpatialObject(ABC):\n  - SIGNATURE: def __init__(self, width: float, height: float):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a SpatialObject with specified width and height attributes. This class serves as a base interface for defining entities that occupy space, particularly used in conjunction with the BoundingBox class to provide normalized coordinates for spatial representations. \n\n:param width: The width of the spatial object as a float. \n:param height: The height of the spatial object as a float. \n\nThis method does not return any value. The values assigned to width and height are utilized by derived classes, such as BoundingBox, to perform operations related to spatial measurements and normalization.\n\"\"\"\n```\n\n- CLASS METHOD: BoundingBox.from_normalized_dict\n  - CLASS SIGNATURE: class BoundingBox(SpatialObject):\n  - SIGNATURE: def from_normalized_dict(cls, bbox_dict: Dict[str, float], spatial_object: SpatialObject=None):\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds a denormalized `BoundingBox` object from a dictionary containing normalized coordinates. The input dictionary should have the keys 'x', 'y', 'width', and 'height', which represent normalized coordinates relative to a `spatial_object`. If provided, `spatial_object` is used to denormalize these coordinates based on its width and height attributes. This method interacts with the `_from_dict` method to create the final `BoundingBox` instance.\n\nParameters:\n- `bbox_dict` (Dict[str, float]): A dictionary containing normalized coordinates and dimensions.\n- `spatial_object` (SpatialObject, optional): An object with width and height attributes to denormalize the coordinates.\n\nReturns:\n- `BoundingBox`: An instance of the `BoundingBox` class with denormalized coordinates based on the input dictionary, or raises an error if the dictionary doesn't contain the required keys.\n\"\"\"\n```\n\n- CLASS METHOD: BoundingBox.__init__\n  - CLASS SIGNATURE: class BoundingBox(SpatialObject):\n  - SIGNATURE: def __init__(self, x: float, y: float, width: float, height: float, spatial_object=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a BoundingBox object, which represents a rectangular area on a 2D plane based on its top-left corner coordinates, width, and height. This class is useful for locating document entities in an image. \n\nParameters:\n- x (float): The x-coordinate of the top-left corner of the bounding box.\n- y (float): The y-coordinate of the top-left corner of the bounding box.\n- width (float): The width of the bounding box.\n- height (float): The height of the bounding box.\n- spatial_object (SpatialObject, optional): An object with width and height attributes, used for normalizing bounding box coordinates if required.\n\nThis constructor calls the superclass (SpatialObject) initializer to set the width and height attributes. The spatial_object parameter allows associating the bounding box with a specific object (e.g., Document or Page) which may be relevant for denormalization purposes in other methods of the BoundingBox class.\n\"\"\"\n```\n\n## FILE 5: textractor/entities/document_entity.py\n\n- CLASS METHOD: DocumentEntity.__init__\n  - CLASS SIGNATURE: class DocumentEntity(Linearizable, ABC):\n  - SIGNATURE: def __init__(self, entity_id: str, bbox: BoundingBox):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a DocumentEntity instance, which serves as a base class for all document-related entities in the document object model. This constructor sets up common properties such as a unique identifier and a bounding box, and it initializes collections for child entities and metadata.\n\n:param entity_id: A string representing the unique identifier of the document entity.\n:param bbox: A BoundingBox object defining the spatial extent of the entity within the document.\n\nAttributes initialized include:\n- `id`: Stores the entity's unique identifier.\n- `_bbox`: The BoundingBox instance representing the entity's width, height, and position.\n- `metadata`: A dictionary for holding optional information about the entity.\n- `_children`: A list to store child entities linked to this DocumentEntity.\n- `_children_type`: Initially set to None, reserved for categorizing child types if necessary.\n- `_raw_object`: A placeholder for the raw data structure used during object creation for reference purposes.\n\"\"\"\n```\n\n- CLASS METHOD: DocumentEntity.bbox\n  - CLASS SIGNATURE: class DocumentEntity(Linearizable, ABC):\n  - SIGNATURE: def bbox(self, bbox: BoundingBox):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the bounding box for the document entity.\n\n:param bbox: A `BoundingBox` object representing the new bounding box for the entity.\n:type bbox: BoundingBox\n:raises ValueError: If the provided bbox is not an instance of `BoundingBox`.\n\nThis method updates the private attribute `_bbox` to the new bounding box provided, which is crucial for positioning and layout purposes of the entity within the document. The `BoundingBox` type must align with the expected structure and functionality as defined in the `textractor.entities.bbox` module.\n\"\"\"\n```\n\n## FILE 6: textractor/visualizers/entitylist.py\n\n- CLASS METHOD: EntityList.__init__\n  - CLASS SIGNATURE: class EntityList(list, Generic[T], Linearizable):\n  - SIGNATURE: def __init__(self, objs=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an `EntityList` object that extends Python's built-in list to manage a custom list of document entities.\n\nThis constructor can accept an optional parameter, `objs`, which can be a single object or a list of objects. If `objs` is not provided or is `None`, it initializes the list as empty. If `objs` is not a list, it wraps it in a list before extending the `EntityList` with these entities.\n\nParameters:\n- `objs` (optional): A list of entity objects to initialize the `EntityList`. If a single entity is provided, it is converted into a list.\n\nThe constructor also interacts with Python's built-in list methods, particularly `extend`, to populate the new `EntityList` instance. The expected output is a new `EntityList` instance containing the specified entities or being empty if no entities are provided.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "textractor/entities/word.py": "\"\"\"\nRepresents a single :class:`Word` within the :class:`Document`.\nThis class contains the associated metadata with the :class:`Word` entity including the text transcription, \ntext type, bounding box information, page number, Page ID and confidence of detection.\n\"\"\"\nfrom textractor.data.constants import TextTypes\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.utils.html_utils import escape_text\n\nclass Word(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Word` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param text: Transcription of the Word object.\n    :type text: str\n    :param text_type: Enum value stating the type of text stored in the entity. Takes 2 values - PRINTED and HANDWRITING\n    :type text_type: TextTypes\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    @property\n    def page(self) -> int:\n        \"\"\"\n        :return: Returns the page number of the page the Word entity is present in.\n        :rtype: int\n        \"\"\"\n        return self._page\n\n    @page.setter\n    def page(self, page_num: int):\n        \"\"\"\n        Sets the page number attribute of the :class:`Word` entity.\n\n        :param page_num: Page number where the Word entity exists.\n        :type page_num: int\n        \"\"\"\n        self._page = page_num\n\n    @property\n    def page_id(self) -> str:\n        \"\"\"\n        :return: Returns the Page ID attribute of the page which the entity belongs to.\n        :rtype: str\n        \"\"\"\n        return self._page_id\n\n    @page_id.setter\n    def page_id(self, page_id: str):\n        \"\"\"\n        Sets the Page ID of the Word entity.\n\n        :param page_id: Page ID of the page the entity belongs to.\n        :type page_id: str\n        \"\"\"\n        self._page_id = page_id\n\n    @property\n    def words(self):\n        \"\"\"Returns itself\n\n        :rtype: Word\n        \"\"\"\n        return [self]\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        return (escape_text(self.text, config), [self])\n\n    def __repr__(self) -> str:\n        \"\"\"\n        :return: String representation of the Word entity.\n        :rtype: str\n        \"\"\"\n        return f'{self.text}'",
    "textractor/entities/value.py": "\"\"\"\nRepresents a single :class:`Value` Entity within the :class:`Document`. \nThe Textract API response returns groups of words as KEY_VALUE_SET BlockTypes. These may be of KEY\nor VALUE type which is indicated by the EntityType attribute in the JSON response. \n\nThis class contains the associated metadata with the :class:`Value` entity including the entity ID, \nbounding box information, child words, associated key ID, page number, Page ID, confidence of detection\nand if it's a checkbox.\n\"\"\"\nfrom typing import List\nimport uuid\nfrom textractor.entities.word import Word\nfrom textractor.exceptions import InputError\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.entities.document_entity import DocumentEntity\nfrom textractor.data.constants import PRINTED, HANDWRITING, TextTypes\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.utils.text_utils import linearize_children\nfrom textractor.utils.html_utils import add_id_to_html_tag\n\nclass Value(DocumentEntity):\n    \"\"\"\n    To create a new :class:`Value` object we need the following:\n\n    :param entity_id: Unique identifier of the Word entity.\n    :type entity_id: str\n    :param bbox: Bounding box of the Word entity.\n    :type bbox: BoundingBox\n    :param confidence: value storing the confidence of detection out of 100.\n    :type confidence: float\n    \"\"\"\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        if self.contains_checkbox:\n            text, words = self.children[0].get_text_and_words(config)\n        else:\n            text, words = linearize_children(self.words, config=config, no_new_lines=config.remove_new_lines_in_leaf_elements)\n        if config.add_prefixes_and_suffixes_in_text:\n            text = add_id_to_html_tag(config.value_prefix, self.id, config) + text + config.value_suffix\n        if config.add_prefixes_and_suffixes_as_words:\n            words = ([Word(str(uuid.uuid4()), self.bbox, add_id_to_html_tag(config.value_prefix, self.id, config), is_structure=True, is_clickable=bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected])] if config.value_prefix else []) + words + ([Word(str(uuid.uuid4()), self.bbox, config.value_suffix, is_structure=True, is_clickable=bool(words) and words[0] in [config.selection_element_selected, config.selection_element_not_selected])] if config.value_suffix else [])\n        for w in words:\n            w.value_id = str(self.id)\n            w.value_bbox = self.bbox\n        return (text, words)",
    "textractor/data/constants.py": "\"\"\"Multiple feature calls within the Textractor tool require the use of input parameters from fixed choices. They've been defined as :code:`Enum` within the data package.\"\"\"\nfrom enum import Enum\nfrom textractcaller.t_call import Textract_API\nfrom textractor.exceptions import InputError\nWORD = 'WORD'\nLINE = 'LINE'\nKEY_VALUE_SET = 'KEY_VALUE_SET'\nSELECTION_ELEMENT = 'SELECTION_ELEMENT'\nTABLE = 'TABLE'\nTABLE_TITLE = 'TABLE_TITLE'\nTABLE_FOOTER = 'TABLE_FOOTER'\nTABLE_SUMMARY = 'TABLE_SUMMARY'\nTABLE_SECTION_TITLE = 'TABLE_SECTION_TITLE'\nTABLE_COLUMN_HEADER = 'COLUMN_HEADER'\nTABLE_STRUCTURED = 'STRUCTURED_TABLE'\nTABLE_SEMI_STRUCTURED = 'SEMI_STRUCTURED_TABLE'\nCELL = 'CELL'\nPAGE = 'PAGE'\nMERGED_CELL = 'MERGED_CELL'\nQUERY = 'QUERY'\nQUERY_RESULT = 'QUERY_RESULT'\nSIGNATURE = 'SIGNATURE'\nLAYOUT = 'LAYOUT'\nLAYOUT_TEXT = 'LAYOUT_TEXT'\nLAYOUT_TITLE = 'LAYOUT_TITLE'\nLAYOUT_HEADER = 'LAYOUT_HEADER'\nLAYOUT_FOOTER = 'LAYOUT_FOOTER'\nLAYOUT_SECTION_HEADER = 'LAYOUT_SECTION_HEADER'\nLAYOUT_PAGE_NUMBER = 'LAYOUT_PAGE_NUMBER'\nLAYOUT_LIST = 'LAYOUT_LIST'\nLAYOUT_FIGURE = 'LAYOUT_FIGURE'\nLAYOUT_TABLE = 'LAYOUT_TABLE'\nLAYOUT_KEY_VALUE = 'LAYOUT_KEY_VALUE'\nLAYOUT_ENTITY = 'LAYOUT_ENTITY'\nIS_COLUMN_HEAD = 'isColumnHead'\nIS_SECTION_TITLE_CELL = 'isSectionTitleCell'\nIS_SUMMARY_CELL = 'isSummaryCell'\nIS_TITLE_CELL = 'isTitleCell'\nIS_FOOTER_CELL = 'isFooterCell'\nIS_MERGED_CELL = 'isMergedCell'\nHANDWRITING = 'HANDWRITING'\nPRINTED = 'PRINTED'\n\nclass TableTypes(Enum):\n    \"\"\"Types of tables recognized by Textract APIs.\"\"\"\n    UNKNOWN = 0\n    STRUCTURED = 1\n    SEMI_STRUCTURED = 2\n\nclass Direction(Enum):\n    \"\"\"Directions available for search using DirectionalFinder\"\"\"\n    ABOVE = 0\n    BELOW = 1\n    RIGHT = 2\n    LEFT = 3\n\nclass TextTypes(Enum):\n    \"\"\"Textract recognizes TextType of all words in the document to fall into one of these 2 categories.\"\"\"\n    HANDWRITING = 0\n    PRINTED = 1\nSELECTED = 'SELECTED'\nNOT_SELECTED = 'NOT_SELECTED'\n\nclass SelectionStatus(Enum):\n    \"\"\"These are the 2 categories defined for the SelectionStatus of a :class:`SelectionElement`.\"\"\"\n    SELECTED = 0\n    NOT_SELECTED = 1\nCOLUMN_HEADER = 'COLUMN_HEADER'\nSECTION_TITLE = 'SECTION_TITLE'\nFLOATING_FOOTER = 'FLOATING_FOOTER'\nFLOATING_TITLE = 'FLOATING_TITLE'\nSUMMARY_CELL = 'SUMMARY_CELL'\n\nclass CellTypes(Enum):\n    \"\"\"Special cells within the :class:`Table` belong to one of these categories.\"\"\"\n    COLUMN_HEADER = 0\n    SECTION_TITLE = 1\n    FLOATING_FOOTER = 2\n    FLOATING_TITLE = 3\n    SUMMARY_CELL = 4\nFORCE_SYNC = 'FORCE_SYNC'\nFORCE_ASYNC = 'FORCE_ASYNC'\nDEFAULT = 'DEFAULT'\nFORMS = 'FORMS'\nTABLES = 'TABLES'\nQUERIES = 'QUERIES'\nLAYOUT = 'LAYOUT'\n\nclass TextractFeatures(Enum):\n    \"\"\"Features to be used as parameter for AnalyzeDocument and StartDocumentAnalysis.\"\"\"\n    FORMS = 0\n    TABLES = 1\n    QUERIES = 2\n    SIGNATURES = 3\n    LAYOUT = 4\n\nclass TextractType(Enum):\n    \"\"\"Document Entity types recognized by Textract APIs.\"\"\"\n    WORDS = 0\n    LINES = 1\n    KEY_VALUE_SET = 2\n    SELECTION_ELEMENT = 3\n    TABLES = 4\n    TABLE_CELL = 5\n\nclass DirectionalFinderType(Enum):\n    \"\"\"Document Entity types recognized by Textract APIs.\"\"\"\n    KEY_VALUE_SET = 0\n    SELECTION_ELEMENT = 1\n\nclass TableFormat(Enum):\n    \"\"\"Various formats of printing :class:`Table` data with the tabulate package.\"\"\"\n    CSV = 0\n    PLAIN = 1\n    SIMPLE = 2\n    GITHUB = 3\n    GRID = 4\n    FANCY_GRID = 5\n    PIPE = 6\n    ORGTBL = 7\n    JIRA = 8\n    PRESTO = 9\n    PRETTY = 10\n    PSQL = 11\n    RST = 12\n    MEDIAWIKI = 13\n    MOINMOIN = 14\n    YOUTRACK = 15\n    HTML = 16\n    UNSAFEHTML = 17\n    LATEX = 18\n    LATEX_RAW = 19\n    LATEX_BOOKTABS = 20\n    LATEX_LONGTABLE = 21\n    TEXTILE = 22\n    TSV = 23\n\nclass SimilarityMetric(Enum):\n    \"\"\"\n    Similarity metrics for search queries on Document data\n\n    COSINE: Cosine similarity is a metric used to measure the similarity of two vectors. It measures the similarity in the direction or orientation of the vectors ignoring differences in their magnitude or scale.\n    EUCLIDEAN: Euclidean distance is calculated as the square root of the sum of the squared differences between the two vectors.\n    LEVENSHTEIN: The Levenshtein distance is a string metric for measuring difference between two sequences. It is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other.\n    \"\"\"\n    COSINE = 0\n    EUCLIDEAN = 1\n    LEVENSHTEIN = 2\n\nclass TextractAPI(Enum):\n    \"\"\"API types for asynchronous type fetching\"\"\"\n    DETECT_TEXT = 0\n    ANALYZE = 1\n    EXPENSE = 2\n\n    @classmethod\n    def TextractAPI_to_Textract_API(cls, api):\n        if api == TextractAPI.DETECT_TEXT:\n            return Textract_API.DETECT\n        elif api == TextractAPI.ANALYZE:\n            return Textract_API.ANALYZE\n        elif api == TextractAPI.EXPENSE:\n            return Textract_API.EXPENSE\n        else:\n            raise InputError()\n\n    @classmethod\n    def Textract_API_to_TextractAPI(cls, api: Textract_API):\n        if api == Textract_API.DETECT:\n            return TextractAPI.DETECT_TEXT\n        elif api == Textract_API.ANALYZE:\n            return TextractAPI.ANALYZE\n        elif api == Textract_API.EXPENSE:\n            return TextractAPI.EXPENSE\n        else:\n            raise InputError()\n\nclass AnalyzeIDFields(Enum):\n    \"\"\"Enum containing all the AnalyzeID keys\"\"\"\n    FIRST_NAME = 'FIRST_NAME'\n    LAST_NAME = 'LAST_NAME'\n    MIDDLE_NAME = 'MIDDLE_NAME'\n    SUFFIX = 'SUFFIX'\n    CITY_IN_ADDRESS = 'CITY_IN_ADDRESS'\n    ZIP_CODE_IN_ADDRESS = 'ZIP_CODE_IN_ADDRESS'\n    STATE_IN_ADDRESS = 'STATE_IN_ADDRESS'\n    COUNTY = 'COUNTY'\n    DOCUMENT_NUMBER = 'DOCUMENT_NUMBER'\n    EXPIRATION_DATE = 'EXPIRATION_DATE'\n    DATE_OF_BIRTH = 'DATE_OF_BIRTH'\n    STATE_NAME = 'STATE_NAME'\n    DATE_OF_ISSUE = 'DATE_OF_ISSUE'\n    CLASS = 'CLASS'\n    RESTRICTIONS = 'RESTRICTIONS'\n    ENDORSEMENTS = 'ENDORSEMENTS'\n    ID_TYPE = 'ID_TYPE'\n    VETERAN = 'VETERAN'\n    ADDRESS = 'ADDRESS'\n    PLACE_OF_BIRTH = 'PLACE_OF_BIRTH'\n\nclass AnalyzeExpenseLineItemFields(Enum):\n    ITEM = 'ITEM'\n    PRICE = 'PRICE'\n    PRODUCT_CODE = 'PRODUCT_CODE'\n    QUANTITY = 'QUANTITY'\n    UNIT_PRICE = 'UNIT_PRICE'\n    EXPENSE_ROW = 'EXPENSE_ROW'\n\nclass AnalyzeExpenseFields(Enum):\n    ACCOUNT_NUMBER = 'ACCOUNT_NUMBER'\n    ADDRESS = 'ADDRESS'\n    ADDRESS_BLOCK = 'ADDRESS_BLOCK'\n    AMOUNT_DUE = 'AMOUNT_DUE'\n    AMOUNT_PAID = 'AMOUNT_PAID'\n    CITY = 'CITY'\n    COUNTRY = 'COUNTRY'\n    CUSTOMER_NUMBER = 'CUSTOMER_NUMBER'\n    DELIVERY_DATE = 'DELIVERY_DATE'\n    DISCOUNT = 'DISCOUNT'\n    DUE_DATE = 'DUE_DATE'\n    GRATUITY = 'GRATUITY'\n    INVOICE_RECEIPT_DATE = 'INVOICE_RECEIPT_DATE'\n    INVOICE_RECEIPT_ID = 'INVOICE_RECEIPT_ID'\n    NAME = 'NAME'\n    ORDER_DATE = 'ORDER_DATE'\n    OTHER = 'OTHER'\n    PAYMENT_TERMS = 'PAYMENT_TERMS'\n    PO_NUMBER = 'PO_NUMBER'\n    PRIOR_BALANCE = 'PRIOR_BALANCE'\n    RECEIVER_ABN_NUMBER = 'RECEIVER_ABN_NUMBER'\n    RECEIVER_ADDRESS = 'RECEIVER_ADDRESS'\n    RECEIVER_GST_NUMBER = 'RECEIVER_GST_NUMBER'\n    RECEIVER_NAME = 'RECEIVER_NAME'\n    RECEIVER_PAN_NUMBER = 'RECEIVER_PAN_NUMBER'\n    RECEIVER_PHONE = 'RECEIVER_PHONE'\n    RECEIVER_VAT_NUMBER = 'RECEIVER_VAT_NUMBER'\n    SERVICE_CHARGE = 'SERVICE_CHARGE'\n    SHIPPING_HANDLING_CHARGE = 'SHIPPING_HANDLING_CHARGE'\n    STATE = 'STATE'\n    STREET = 'STREET'\n    SUBTOTAL = 'SUBTOTAL'\n    TAX = 'TAX'\n    TAX_PAYER_ID = 'TAX_PAYER_ID'\n    TOTAL = 'TOTAL'\n    VENDOR_ABN_NUMBER = 'VENDOR_ABN_NUMBER'\n    VENDOR_ADDRESS = 'VENDOR_ADDRESS'\n    VENDOR_GST_NUMBER = 'VENDOR_GST_NUMBER'\n    VENDOR_NAME = 'VENDOR_NAME'\n    VENDOR_PAN_NUMBER = 'VENDOR_PAN_NUMBER'\n    VENDOR_PHONE = 'VENDOR_PHONE'\n    VENDOR_URL = 'VENDOR_URL'\n    VENDOR_VAT_NUMBER = 'VENDOR_VAT_NUMBER'\n    ZIP_CODE = 'ZIP_CODE'\n\nclass AnalyzeExpenseFieldsGroup(Enum):\n    RECEIVER = 'RECEIVER'\n    RECEIVER_BILL_TO = 'RECEIVER_BILL_TO'\n    RECEIVER_SHIP_TO = 'RECEIVER_SHIP_TO'\n    RECEIVER_SOLD_TO = 'RECEIVER_SOLD_TO'\n    VENDOR = 'VENDOR'\n    VENDOR_REMIT_TO = 'VENDOR_REMIT_TO'\n    VENDOR_SUPPLIER = 'VENDOR_SUPPLIER'\n\nclass CLIPrint(Enum):\n    ALL = 0\n    TEXT = 1\n    TABLES = 2\n    FORMS = 3\n    QUERIES = 4\n    EXPENSES = 5\n    SIGNATURES = 6\n    IDS = 7\n    LAYOUTS = 8\n\nclass CLIOverlay(Enum):\n    ALL = 0\n    WORDS = 1\n    LINES = 2\n    TABLES = 3\n    FORMS = 4\n    QUERIES = 5\n    SIGNATURES = 6\n    LAYOUTS = 7",
    "textractor/entities/bbox.py": "\"\"\"BoundingBox class contains all the co-ordinate information for a :class:`DocumentEntity`. This class is mainly useful to locate the entity\non the image of the document page.\"\"\"\nfrom abc import ABC\nimport logging\nimport math\nfrom typing import Tuple, List\ntry:\n    import numpy as np\nexcept ImportError:\n    pass\nfrom typing import Dict\nfrom dataclasses import dataclass\n\nclass SpatialObject(ABC):\n    \"\"\"\n    The :class:`SpatialObject` interface defines an object that has a width and height. This mostly used for :class:`BoundingBox`     reference to be able to provide normalized coordinates.\n    \"\"\"\n\n@dataclass\nclass BoundingBox(SpatialObject):\n    \"\"\"\n    Represents the bounding box of an object in the format of a dataclass with (x, y, width, height).     By default :class:`BoundingBox` is set to work with denormalized co-ordinates: :math:`x \\\\in [0, docwidth]` and :math:`y \\\\in [0, docheight]`.     Use the as_normalized_dict function to obtain BoundingBox with normalized co-ordinates: :math:`x \\\\in [0, 1]` and :math:`y \\\\in [0, 1]`. \\\\\n\n    Create a BoundingBox like shown below: \\\\\n\n    * Directly:             :code:`bb = BoundingBox(x, y, width, height)` \\\\\n    * From dict:            :code:`bb = BoundingBox.from_dict(bb_dict)` where :code:`bb_dict = {'x': x, 'y': y, 'width': width, 'height': height}` \\\\\n\n    Use a BoundingBox like shown below: \\\\\n\n    * Directly:            :code:`print('The top left is: ' + str(bb.x) + ' ' + str(bb.y))` \\\\\n    * Convert to dict:     :code:`bb_dict = bb.as_dict()` returns :code:`{'x': x, 'y': y, 'width': width, 'height': height}`\n    \"\"\"\n\n    @staticmethod\n    def _denormalize(x: float, y: float, width: float, height: float, spatial_object: SpatialObject=None) -> Tuple[float, float, float, float]:\n        \"\"\"\n        Denormalizes the coordinates according to spatial_object (used as a calibrator).         The SpatialObject is assumed to be a container for the bounding boxes (i.e: Page).         Any object with width, height attributes can be used as a SpatialObject.\n\n        :param x: Normalized co-ordinate x\n        :type x: float\n        :param y: Normalized co-ordinate y\n        :type y: float\n        :param width: Normalized width of BoundingBox\n        :type width: float\n        :param height: Normalized height of BoundingBox\n        :type height: float\n        :param spatial_object: Object with width and height attributes (i.e: Page).\n        :type spatial_object: SpatialObject\n\n        :return: Returns x, y, width, height as denormalized co-ordinates.\n        :rtype: Tuple[float, float, float, float]\n        \"\"\"\n        x = x * spatial_object.width\n        y = y * spatial_object.height\n        width = width * spatial_object.width\n        height = height * spatial_object.height\n        return (x, y, width, height)\n\n    @classmethod\n    def from_denormalized_xywh(cls, x: float, y: float, width: float, height: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left, width and height properties.\n        The coordinates are assumed to be denormalized.\n        :param x: Left ~ [0, doc_width]\n        :param y: Top  ~ [0, doc_height]\n        :param width: Width ~ [0, doc_width]\n        :param height: Height  ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return BoundingBox(x, y, width, height, spatial_object)\n\n    @classmethod\n    def from_denormalized_corners(cls, x1: float, y1: float, x2: float, y2: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        :param x1: Left  ~ [0, wdoc_idth]\n        :param y1: Top ~ [0, doc_height]\n        :param x2: Right  ~ [0, doc_width]\n        :param y2: Bottom ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes (i.e: Document, ConvertibleImage).\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = x1\n        y = y1\n        width = x2 - x1\n        height = y2 - y1\n        return BoundingBox(x, y, width, height, spatial_object=spatial_object)\n\n    @classmethod\n    def from_denormalized_borders(cls, left: float, top: float, right: float, bottom: float, spatial_object: SpatialObject=None):\n        \"\"\"\n        Builds an axis aligned bounding box from top-left and bottom-right coordinates.\n        The coordinates are assumed to be denormalized.\n        If spatial_object is not None, the coordinates will be denormalized according to the spatial object.\n        :param left: ~ [0, doc_width]\n        :param top: ~ [0, doc_height]\n        :param right: ~ [0, doc_width]\n        :param bottom: ~ [0, doc_height]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        return cls.from_denormalized_corners(left, top, right, bottom, spatial_object)\n\n    @classmethod\n    def from_denormalized_dict(cls, bbox_dict: Dict[str, float]):\n        \"\"\"\n        Builds an axis aligned bounding box from a dictionary of:\n        {'x': x, 'y': y, 'width': width, 'height': height}\n        The coordinates will be denormalized according to the spatial object.\n        :param bbox_dict: {'x': x, 'y': y, 'width': width, 'height': height} of [0, doc_height] x [0, doc_width]\n        :param spatial_object: Some object with width and height attributes\n        :return: BoundingBox object in denormalized coordinates:  ~ [0, doc_height] x [0, doc_width]\n        \"\"\"\n        x = bbox_dict['x']\n        y = bbox_dict['y']\n        width = bbox_dict['width']\n        height = bbox_dict['height']\n        return BoundingBox(x, y, width, height)\n\n    @classmethod\n    def enclosing_bbox(cls, bboxes, spatial_object: SpatialObject=None):\n        \"\"\"\n        :param bboxes [BoundingBox]: list of bounding boxes\n        :param spatial_object SpatialObject: spatial object to be added to the returned bbox\n        :return:\n        \"\"\"\n        bboxes = [bbox for bbox in bboxes if bbox is not None]\n        if bboxes and (not isinstance(bboxes[0], BoundingBox)):\n            try:\n                bboxes = [bbox.bbox for bbox in bboxes]\n            except:\n                raise Exception('bboxes must be of type List[BoundingBox] or of type List[DocumentEntity]')\n        x1, y1, x2, y2 = (float('inf'), float('inf'), float('-inf'), float('-inf'))\n        if not any([bbox is not None for bbox in bboxes]):\n            logging.warning('At least one bounding box needs to be non-null')\n            return BoundingBox(0, 0, 1, 1, spatial_object=spatial_object)\n        if spatial_object is None:\n            spatial_object = bboxes[0].spatial_object\n        for bbox in bboxes:\n            if bbox is not None:\n                x1 = min(x1, bbox.x)\n                x2 = max(x2, bbox.x + bbox.width)\n                y1 = min(y1, bbox.y)\n                y2 = max(y2, bbox.y + bbox.height)\n        return BoundingBox(x1, y1, x2 - x1, y2 - y1, spatial_object=spatial_object)\n\n    @classmethod\n    def is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if Bounding Box A is within Bounding Box B\n        \"\"\"\n        return bbox_a.x >= bbox_b.x and bbox_a.x + bbox_a.width <= bbox_b.x + bbox_b.width and (bbox_a.y >= bbox_b.y) and (bbox_a.y + bbox_a.height <= bbox_b.y + bbox_b.height)\n\n    @classmethod\n    def center_is_inside(cls, bbox_a, bbox_b):\n        \"\"\"Returns true if the center point of Bounding Box A is within Bounding Box B\n        \"\"\"\n        return bbox_a.x + bbox_a.width / 2 >= bbox_b.x and bbox_a.x + bbox_a.width / 2 <= bbox_b.x + bbox_b.width and (bbox_a.y + bbox_a.height / 2 >= bbox_b.y) and (bbox_a.y + bbox_a.height / 2 <= bbox_b.y + bbox_b.height)\n\n    @property\n    def area(self):\n        \"\"\"\n        Returns the area of the bounding box, handles negative bboxes as 0-area\n\n        :return: Bounding box area\n        :rtype: float\n        \"\"\"\n        if self.width < 0 or self.height < 0:\n            return 0\n        else:\n            return self.width * self.height\n\n    def as_denormalized_numpy(self):\n        \"\"\"\n        :return: Returns denormalized co-ordinates x, y and dimensions width, height as numpy array.\n        :rtype: numpy.array\n        \"\"\"\n        return np.array([self.x, self.y, self.width, self.height])\n\n    def get_intersection(self, bbox):\n        \"\"\"\n        Returns the intersection of this object's bbox and another BoundingBox\n        :return: a BoundingBox object\n        \"\"\"\n        assert isinstance(bbox, BoundingBox)\n        x1y1x2y2 = (max(self.x, bbox.x), max(self.y, bbox.y), min(self.x + self.width, bbox.x + bbox.width), min(self.y + self.height, bbox.y + bbox.height))\n        return BoundingBox.from_denormalized_corners(*x1y1x2y2, spatial_object=self.spatial_object)\n\n    def get_distance(self, bbox):\n        \"\"\"\n        Returns the distance between the center point of the bounding box and another bounding box\n\n        :return: Returns the distance as float\n        :rtype: float\n        \"\"\"\n        return math.sqrt((self.x + self.width / 2 - (bbox.x + bbox.width / 2)) ** 2 + (self.y + self.height / 2 - (bbox.y + bbox.height / 2)) ** 2)\n\n    def __repr__(self):\n        return f'x: {self.x}, y: {self.y}, width: {self.width}, height: {self.height}'",
    "textractor/entities/document_entity.py": "\"\"\":class:`DocumentEntity` is the class that all Document entities such as :class:`Word`, :class:`Line`, :class:`Table` etc. inherit from. This class provides methods \nuseful to all such entities.\"\"\"\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Tuple\nfrom textractor.entities.bbox import BoundingBox\nfrom textractor.visualizers.entitylist import EntityList\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nfrom textractor.data.html_linearization_config import HTMLLinearizationConfig\nfrom textractor.data.markdown_linearization_config import MarkdownLinearizationConfig\nfrom textractor.entities.linearizable import Linearizable\n\nclass DocumentEntity(Linearizable, ABC):\n    \"\"\"\n    An interface for all document entities within the document body, composing the\n    hierarchy of the document object model.\n    The purpose of this class is to define properties common to all document entities\n    i.e. unique id and bounding box.\n    \"\"\"\n\n    def add_children(self, children):\n        \"\"\"\n        Adds children to all entities that have parent-child relationships.\n\n        :param children: List of child entities.\n        :type children: list\n        \"\"\"\n        self._children.extend(children)\n\n    @property\n    def raw_object(self) -> Dict:\n        \"\"\"\n        :return: Returns the raw dictionary object that was used to create this Python object\n        :rtype: Dict\n        \"\"\"\n        return self._raw_object\n\n    @raw_object.setter\n    def raw_object(self, raw_object: Dict):\n        \"\"\"\n        Sets the raw object that was used to create this Python object\n        :param raw_object: raw object dictionary from the response\n        :type raw_object: Dict\n        \"\"\"\n        self._raw_object = raw_object\n\n    @property\n    def x(self) -> float:\n        \"\"\"\n        :return: Returns x coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.x\n\n    @x.setter\n    def x(self, x: float):\n        \"\"\"\n        Sets x coordinate for bounding box\n\n        :param x: x coordinate of the bounding box\n        :type x: float\n        \"\"\"\n        self._bbox.x = x\n\n    @property\n    def y(self) -> float:\n        \"\"\"\n        :return: Returns y coordinate for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.y\n\n    @y.setter\n    def y(self, y: float):\n        \"\"\"\n        Sets y coordinate for bounding box.\n\n        :param y: y coordinate of the bounding box\n        :type y: float\n        \"\"\"\n        self._bbox.y = y\n\n    @property\n    def width(self) -> float:\n        \"\"\"\n        :return: Returns width for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.width\n\n    @width.setter\n    def width(self, width: float):\n        \"\"\"\n        Sets width for bounding box.\n\n        :param width: width of the bounding box\n        :type width: float\n        \"\"\"\n        self._bbox.width = width\n\n    @property\n    def height(self) -> float:\n        \"\"\"\n        :return: Returns height for bounding box\n        :rtype: float\n        \"\"\"\n        return self._bbox.height\n\n    @height.setter\n    def height(self, height: float):\n        \"\"\"\n        Sets height for bounding box.\n\n        :param height: height of the bounding box\n        :type height: float\n        \"\"\"\n        self._bbox.height = height\n\n    @property\n    def children(self):\n        \"\"\"\n        :return: Returns children of entity\n        :rtype: list\n        \"\"\"\n        return self._children\n\n    @property\n    def confidence(self) -> float:\n        \"\"\"\n        Returns the object confidence as predicted by Textract. If the confidence is not available, returns None\n\n        :return: Prediction confidence for a document entity, between 0 and 1\n        :rtype: float\n        \"\"\"\n        if hasattr(self, '_confidence'):\n            return self._confidence\n        if not hasattr(self, 'raw_object'):\n            return None\n        confidence = self.raw_object.get('Confidence')\n        if confidence is None:\n            return None\n        return confidence / 100\n\n    def remove(self, entity):\n        \"\"\"\n        Recursively removes an entity from the child tree of a document entity and update its bounding box\n\n        :param entity: Entity\n        :type entity: DocumentEntity\n        \"\"\"\n        for c in self._children:\n            if entity == c:\n                break\n            if not c.__class__.__name__ == 'Word' and c.remove(entity):\n                if not c.children:\n                    self._children.remove(c)\n                return True\n        else:\n            return False\n        self._children.remove(c)\n        if self._children:\n            self.bbox = BoundingBox.enclosing_bbox(self._children)\n        return True\n\n    def visit(self, word_set):\n        for c in list(self._children):\n            if c.__class__.__name__ == 'Word':\n                if c.id in word_set:\n                    self._children.remove(c)\n                else:\n                    word_set.add(c.id)\n            else:\n                c.visit(word_set)\n\n    def visualize(self, *args, **kwargs) -> EntityList:\n        \"\"\"\n        Returns the object's children in a visualization EntityList object\n\n        :return: Returns an EntityList object\n        :rtype: EntityList\n        \"\"\"\n        return EntityList(self).visualize(*args, **kwargs)",
    "textractor/visualizers/entitylist.py": "\"\"\"\nThe :class:`EntityList` is an extension of list type with custom functions to print document entities in a well formatted manner and visualize on top of the document page with their BoundingBox information. \n\nThe two main functions within this class are :code:`pretty_print()` and :code:`visualize()`.\nUse :code:`pretty_print()` to get a string formatted output of your custom list of entities.\nUse :code:`visualize()` to get the bounding box visualization of the entities on the document page images.\n\"\"\"\nimport os\nimport csv\nimport logging\nfrom enum import Enum\nfrom io import StringIO\nfrom tabulate import tabulate\nfrom typing import List, Optional, TypeVar, Generic, Any\nfrom collections import defaultdict\nfrom textractor.utils.geometry_util import get_indices\nfrom PIL import Image, ImageDraw, ImageColor, ImageFont\nfrom textractor.data.constants import TextractType, TableFormat, AnalyzeExpenseLineItemFields, AnalyzeExpenseFields\nfrom textractor.exceptions import EntityListCreationError, NoImageException\nfrom textractor.entities.linearizable import Linearizable\nfrom textractor.data.text_linearization_config import TextLinearizationConfig\nlogger = logging.getLogger(__name__)\npresent_path = os.path.abspath(os.path.dirname(__file__))\nT = TypeVar('T')\n\nclass EntityList(list, Generic[T], Linearizable):\n    \"\"\"\n    Creates a list type object, initially empty but extended with the list passed in objs.\n\n    :param objs: Custom list of objects that can be visualized with this class.\n    :type objs: list\n    \"\"\"\n\n    def visualize(self, with_text: bool=True, with_words: bool=True, with_confidence: bool=False, font_size_ratio: float=0.5) -> List:\n        \"\"\"\n        Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n\n        :param with_text: Flag to print the OCR output of Textract on top of the text bounding box.\n        :type with_text: bool\n        :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n        :type with_confidence: bool\n\n        :return: Returns list of PIL Images with bounding boxes drawn around the entities in the list.\n        :rtype: list\n        \"\"\"\n        if len(self) > 0 and any([ent.__class__.__name__ == 'Document' for ent in self]):\n            return EntityList(self[0].pages).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and any([ent.__class__.__name__ == 'Page' for ent in self]):\n            new_entity_list = []\n            for entity in self:\n                if not with_words and (entity.__class__.__name__ == 'Word' or entity.__class__.__name__ == 'Line'):\n                    continue\n                if entity.__class__.__name__ == 'Page':\n                    if with_words:\n                        new_entity_list.extend(entity.words)\n                        new_entity_list.extend(entity.lines)\n                    new_entity_list.extend(entity.tables)\n                    new_entity_list.extend(entity.key_values)\n                    new_entity_list.extend(entity.checkboxes)\n                    new_entity_list.extend(entity.layouts)\n                    for expense_document in entity.expense_documents:\n                        new_entity_list = self._add_expense_document_to_list(new_entity_list, expense_document)\n                elif entity.__class__.__name__ == 'ExpenseDocument':\n                    self._add_expense_document_to_list(new_entity_list, entity)\n                else:\n                    new_entity_list.append(entity)\n            return EntityList(list(dict.fromkeys(new_entity_list).keys())).visualize(with_text=with_text, with_words=with_words, with_confidence=with_confidence, font_size_ratio=font_size_ratio)\n        elif len(self) > 0 and self[0].bbox.spatial_object.image is None:\n            raise NoImageException('Image was not saved during the Textract API call. Set save_image=True when calling the Textractor methods to use the visualize() method.')\n        visualized_images = {}\n        entities_pagewise = defaultdict(list)\n        for obj in self:\n            entities_pagewise[obj.page].append(obj)\n            if obj.page is None:\n                print(obj.__class__.__name__)\n            try:\n                if with_words:\n                    entities_pagewise[obj.page].extend(obj.words)\n            except AttributeError:\n                pass\n        for page in list(entities_pagewise.keys()):\n            entities_pagewise[page] = list(dict.fromkeys(entities_pagewise[page]).keys())\n        for page in entities_pagewise.keys():\n            visualized_images[page] = _draw_bbox(entities_pagewise[page], with_text, with_confidence, font_size_ratio)\n        images = [image.convert('RGB') for image in visualized_images.values()]\n        images = images if len(images) != 1 else images[0]\n        return images\n\n    def _add_expense_document_to_list(self, entity_list, expense_document):\n        entity_list.append(expense_document)\n        for field in expense_document.summary_fields_list:\n            entity_list.append(field)\n        for line_item_group in expense_document.line_items_groups:\n            entity_list.append(line_item_group)\n            for row in line_item_group.rows:\n                entity_list.append(row)\n                for expense in row.expenses:\n                    if expense.type.text != AnalyzeExpenseLineItemFields.EXPENSE_ROW.name:\n                        entity_list.append(expense)\n        return entity_list\n\n    def pretty_print(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, with_page_number: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for each of the entities in the list according to its entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string. This is a predefined set of choices by the PyPI tabulate package. It is used only if there are KeyValues or Tables in the list of textractor.entities.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for each of the entities in the list according to its entity type.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.WORDS)\n        result_value += self._get_text_string(with_page_number=with_page_number, with_confidence=with_confidence, trim=trim, textract_type=TextractType.LINES)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.KEY_VALUE_SET)\n        result_value += self._get_forms_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=TextractType.SELECTION_ELEMENT)\n        result_value += self._get_tables_string(table_format=table_format, with_confidence=with_confidence, with_geo=with_geo, trim=trim)\n        result_value += self._get_queries_string()\n        result_value += self._get_expense_documents_string()\n        result_value += self._get_id_documents_string()\n        return result_value\n\n    def _get_text_string(self, with_page_number=False, with_confidence=False, trim=False, textract_type=TextractType.WORDS):\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.WORDS and TextractType.LINES.\n\n        :param with_page_number: Flag to add the page number to the entity string. default= False.\n        :type with_page_number: bool\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.WORDS / TextractType.LINES\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        result_value = ''\n        if textract_type == TextractType.WORDS:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Word'], key=lambda x: x.page)\n        else:\n            objects = sorted([obj for obj in self if obj.__class__.__name__ == 'Line'], key=lambda x: x.page)\n        current_page = -1\n        for word in objects:\n            if with_page_number and word.page != current_page:\n                result_value += f'--------- page number: {word.page} - page ID: {word.page_id} --------------{os.linesep}'\n                current_page = word.page\n            if trim:\n                result_value += f'{word.text.strip()}'\n            else:\n                result_value += f'{word.text}'\n            if with_confidence:\n                result_value += f', {word.confidence}'\n            result_value += os.linesep\n        return result_value\n\n    def _get_forms_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> str:\n        \"\"\"\n        Returns a formatted string output for the entity type stated in the textract_type param. This function is\n        specific to TextractType.KEY_VALUE_SET and TextractType.SELECTION_ELEMENT.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n        :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n        :type textract_type: TextractType\n\n        :return: Returns a formatted string output for the entity type stated in the textract_type param.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        result_value = ''\n        if textract_type == TextractType.KEY_VALUE_SET:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and (not obj.contains_checkbox)]\n        else:\n            key_value_objects = [obj for obj in self if obj.__class__.__name__ == 'KeyValue' and obj.contains_checkbox]\n        kv_dict = {obj.page: [] for obj in key_value_objects}\n        for obj in key_value_objects:\n            kv_dict[obj.page].append(obj)\n        if not table_format == TableFormat.CSV:\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                result_value += tabulate(forms_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            csv_output = StringIO()\n            csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n            for page in kv_dict.keys():\n                forms_list = _convert_form_to_list(kv_dict[page], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=textract_type)\n                csv_writer.writerows(forms_list)\n            csv_writer.writerow([])\n            result_value = csv_output.getvalue()\n        return result_value\n\n    def _get_tables_string(self, table_format: TableFormat=TableFormat.GITHUB, with_confidence: bool=False, with_geo: bool=False, trim: bool=False) -> str:\n        \"\"\"\n        Returns a formatted string output for the Table entity type.\n\n        :param table_format: Choose one of the defined TableFormat types to decorate the table output string.\n                             This is a predefined set of choices by the PyPI tabulate package.\n        :type table_format: TableFormat\n        :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n        :type with_confidence: bool\n        :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n        :type with_geo: bool\n        :param trim: Flag to trim text in the entity string. default= False.\n        :type trim: bool\n\n        :return: Returns a formatted string output for the Table entity type.\n        :rtype: str\n        \"\"\"\n        logger.debug(f'table_format: {table_format}')\n        tables = {}\n        for obj in self:\n            if obj.__class__.__name__ == 'Table':\n                tables[obj.id] = obj\n            elif obj.__class__.__name__ == 'TableCell':\n                if obj.table_id in tables.keys():\n                    tables[obj.table_id].append(obj)\n                else:\n                    tables[obj.table_id] = [obj]\n        result_value = ''\n        if not table_format == TableFormat.CSV:\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                result_value += tabulate(table_list, tablefmt=table_format.name.lower()) + os.linesep + os.linesep\n        if table_format == TableFormat.CSV:\n            logger.debug(f'pretty print - csv')\n            for table_id in tables.keys():\n                table_type = TextractType.TABLES if tables[table_id].__class__.__name__ == 'Table' else TextractType.TABLE_CELL\n                csv_output = StringIO()\n                csv_writer = csv.writer(csv_output, delimiter=',', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n                table_list = _convert_table_to_list(tables[table_id], with_confidence=with_confidence, with_geo=with_geo, trim=trim, textract_type=table_type)\n                csv_writer.writerows(table_list)\n                csv_writer.writerow([])\n                result_value += csv_output.getvalue()\n        return result_value\n\n    def _get_queries_string(self):\n        result_value = ''\n        queries = [obj for obj in self if obj.__class__.__name__ == 'Query']\n        for query in queries:\n            if query.result is not None:\n                result_value += f'{query.query} => {query.result.answer}{os.linesep}'\n            else:\n                result_value += f'{query.query} => {os.linesep}'\n        return result_value\n\n    def _get_expense_documents_string(self):\n        result_value = ''\n        expense_documents = [obj for obj in self if obj.__class__.__name__ == 'ExpenseDocument']\n        for i, expense_document in enumerate(expense_documents):\n            result_value += f'Expense Document {i + 1}:{os.linesep}'\n            result_value += f'### Summary Fields:{os.linesep}'\n            result_value += f'{expense_document.summary_fields}{os.linesep}'\n            result_value += f'### Line Item Groups: {os.linesep}'\n            for line_item_group in expense_document.line_items_groups:\n                result_value += f'{line_item_group}{os.linesep}'\n        return result_value\n\n    def _get_id_documents_string(self):\n        result_value = ''\n        id_documents = [obj for obj in self if obj.__class__.__name__ == 'IdentityDocument']\n        for id_document in id_documents:\n            result_value += f'{id_document}{os.linesep}'\n        return result_value\n\n    def __add__(self, list2):\n        return EntityList([*self, *list2])\n\n    def get_text_and_words(self, config: TextLinearizationConfig=TextLinearizationConfig()):\n        texts, words = ([], [])\n        separator = config.same_paragraph_separator if all([entity.__class__.__name__ == 'Word' for entity in self]) else config.layout_element_separator\n        for entity in self:\n            entity_text, entity_words = entity.get_text_and_words(config)\n            texts.append(entity_text)\n            words.extend(entity_words)\n        return (separator.join(texts), words)\n\ndef _convert_form_to_list(form_objects, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.KEY_VALUE_SET) -> List:\n    \"\"\"\n    Converts KeyValue objects (KEY_VALUE_SET in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param form_objects: KeyValue instances to be formatted into strings\n    :type form_objects: KeyValue\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.KEY_VALUE_SET / TextractType.SELECTION_ELEMENT\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a key-value pair.\n    :rtype: List[List[str]]\n    \"\"\"\n    rows_list = list()\n    rows_list.append(['Key', 'Value'])\n    for field in form_objects:\n        t_key = ''\n        t_value = ''\n        if field.key:\n            text = ' '.join([word.text for word in field.key])\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + field.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({field.key.confidence:.1f})'\n        if field.value:\n            text = field.value.words if textract_type == TextractType.SELECTION_ELEMENT else ' '.join([word.text for word in field.value.words])\n            if trim:\n                t_value = text.strip()\n            else:\n                t_value = text\n            if with_geo:\n                t_value += ' {' + field.value.bbox.__repr__() + '} '\n            if with_confidence:\n                t_value += f' ({field.value.confidence:.1f})'\n        rows_list.append([t_key, t_value])\n    return rows_list\n\ndef _convert_table_to_list(table_object, with_confidence: bool=False, with_geo: bool=False, trim: bool=False, textract_type=TextractType.TABLES) -> List:\n    \"\"\"\n    Converts Table objects (TABLE in JSON) to row-wise list format to pretty_print using the\n    PyPI tabulate package.\n\n    :param table_object: Table instance to be formatted into strings\n    :type table_object: Table\n    :param with_confidence: Flag to add the confidence of prediction to the entity string. default= False.\n    :type with_confidence: bool\n    :param with_geo: Flag to add the bounding box information to the entity string. default= False.\n    :type with_geo: bool\n    :param trim: Flag to trim text in the entity string. default= False.\n    :type trim: bool\n    :param textract_type: TextractType.TABLES / TextractType.TABLE_CELL\n    :type textract_type: TextractType\n\n    :return: Returns a list of lists, each inner list containing a row of table data.\n    :rtype: List[List]\n    \"\"\"\n    if textract_type == TextractType.TABLES:\n        rowwise_table = table_object._get_table_cells()\n    else:\n        rowwise_table = {cell.row_index: [] for cell in table_object}\n        for cell in table_object:\n            rowwise_table[cell.row_index].append(cell)\n    table_rows = []\n    for row in rowwise_table.keys():\n        row_data = []\n        for cell in rowwise_table[row]:\n            text = cell.__repr__().split('>')[-1][1:]\n            if trim:\n                t_key = text.strip()\n            else:\n                t_key = text\n            if with_geo:\n                t_key += ' {' + cell.bbox.__repr__() + '} '\n            if with_confidence:\n                t_key += f' ({cell.confidence:.1f})'\n            row_data.append(t_key)\n        table_rows.append(row_data)\n    return table_rows\n\ndef _draw_bbox(entities: List[Any], with_text: bool=False, with_confidence: bool=False, font_size_ratio: float=0.5):\n    \"\"\"\n    Function to draw bounding boxes on all objects in entities present in a particular page.\n\n    :param entities: List of entities to be visualized on top of the document page\n    :type entities: list, required\n    :param with_text: Flag to indicate if text is to be printed on top of the bounding box\n    :type with_text: bool, optional\n    :param with_word_text_only: Flag to print only the word-level OCR output of Textract on top of the text bounding box.\n    :type with_word_text_only: bool\n    :param with_confidence: Flag to print the confidence of prediction on top of the entity bounding box.\n    :type with_confidence: bool\n    :param with_word_confidence_only: Flag to print only the word-level confidence of Textract OCR.\n    :type with_word_confidence_only: bool\n\n    :return: Returns PIL.Image with bounding boxes drawn for the entities passed to the function\n    :rtype: PIL.Image\n    \"\"\"\n    image = entities[0].bbox.spatial_object.image\n    if image is None:\n        for e in entities:\n            if e.bbox.spatial_object.image is not None:\n                image = e.bbox.spatial_object.image\n                break\n        else:\n            raise Exception('Could not find an entity with an associated image!')\n    image = image.convert('RGBA')\n    overlay = Image.new('RGBA', image.size, (255, 255, 255, 0))\n    drw = ImageDraw.Draw(overlay, 'RGBA')\n    text_locations = {}\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        width, height = image.size\n        if entity.__class__.__name__ == 'Table':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.title:\n                drw.rectangle((int(entity.title.bbox.x * width), int(entity.title.bbox.y * height), int((entity.title.bbox.x + entity.title.bbox.width) * width), int((entity.title.bbox.y + entity.title.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('red') + (120,), width=2)\n            for footer in entity.footers:\n                drw.rectangle((int(footer.bbox.x * width), int(footer.bbox.y * height), int((footer.bbox.x + footer.bbox.width) * width), int((footer.bbox.y + footer.bbox.height) * height)), outline=overlayer_data['color'], fill=ImageColor.getrgb('cyan') + (120,), width=2)\n            processed_cells = set()\n            for cell in entity.table_cells:\n                if cell.id in processed_cells:\n                    continue\n                if cell.siblings:\n                    for c in cell.siblings:\n                        processed_cells.add(c.id)\n                    min_x, min_y, max_x, max_y = list(zip(*[(c.bbox.x, c.bbox.y, c.bbox.x + c.bbox.width, c.bbox.y + c.bbox.height) for c in cell.siblings + [cell]]))\n                    min_x, min_y, max_x, max_y = (min(min_x), min(min_y), max(max_x), max(max_y))\n                else:\n                    processed_cells.add(cell.id)\n                    min_x, min_y, max_x, max_y = (cell.bbox.x, cell.bbox.y, cell.bbox.x + cell.bbox.width, cell.bbox.y + cell.bbox.height)\n                fill_color = None\n                if cell.is_column_header:\n                    fill_color = ImageColor.getrgb('blue') + (120,)\n                if cell.is_title:\n                    fill_color = ImageColor.getrgb('red') + (120,)\n                if cell.is_footer:\n                    fill_color = ImageColor.getrgb('cyan') + (120,)\n                if cell.is_summary:\n                    fill_color = ImageColor.getrgb('yellow') + (120,)\n                if cell.is_section_title:\n                    fill_color = ImageColor.getrgb('green') + (120,)\n                drw.rectangle((int(min_x * width), int(min_y * height), int(max_x * width), int(max_y * height)), outline=overlayer_data['color'], fill=fill_color, width=2)\n                for checkbox in cell.checkboxes:\n                    drw.rectangle((int(checkbox.bbox.x * width), int(checkbox.bbox.y * height), int((checkbox.bbox.x + checkbox.bbox.width) * width), int((checkbox.bbox.y + checkbox.bbox.height) * height)), outline=ImageColor.getrgb('lightgreen') if checkbox.is_selected() else ImageColor.getrgb('indianred'))\n    for entity in entities:\n        if entity.bbox is None:\n            continue\n        if entity.__class__.__name__ == 'Query':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableTitle':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'TableFooter':\n            overlayer_data = _get_overlayer_data(entity.result, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseField':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords_value'], outline=overlayer_data['color_value'], width=2)\n            if entity.key is not None:\n                b1 = entity.key.bbox\n                b2 = entity.value.bbox\n                drw.rectangle(xy=overlayer_data['coords_key'], outline=overlayer_data['color_key'], width=2)\n                drw.line([((b1.x + b1.width / 2) * width, (b1.y + b1.height / 2) * height), ((b2.x + b2.width / 2) * width, (b2.y + b2.height / 2) * height)], fill=overlayer_data['color_key'], width=2)\n        elif entity.__class__.__name__ == 'ExpenseDocument':\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            for coord, text in zip(overlayer_data['coords_list'], overlayer_data['coords_list']):\n                drw.rectangle(xy=coord, outline=overlayer_data['color_expense_group'], width=2)\n        elif entity.__class__.__name__.startswith('Layout'):\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=4)\n        else:\n            overlayer_data = _get_overlayer_data(entity, width, height)\n            drw.rectangle(xy=overlayer_data['coords'], outline=overlayer_data['color'], width=2)\n            if entity.__class__.__name__ == 'KeyValue':\n                drw.rectangle(xy=overlayer_data['value_bbox'], outline=overlayer_data['color_value'], width=2)\n                b1 = overlayer_data['value_bbox']\n                b2 = overlayer_data['coords']\n                drw.line([((b1[0] + b1[2]) / 2, (b1[1] + b1[3]) / 2), ((b2[0] + b2[2]) / 2, (b2[1] + b2[3]) / 2)], fill=overlayer_data['color_value'], width=1)\n    if with_text:\n        for entity in entities:\n            if entity.bbox is None:\n                continue\n            if entity.__class__.__name__ == 'Word':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'KeyValue':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(int(0.03 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color'])\n                final_txt = overlayer_data['value_text']\n                bbox_height = overlayer_data['value_bbox'][3] - overlayer_data['value_bbox'][1]\n                text_height = min(int(0.01 * height), int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['value_conf'])[:4] + ')'\n                drw.text((overlayer_data['value_bbox'][0], overlayer_data['value_bbox'][3] + 1), final_txt, font=fnt, fill=overlayer_data['color_value'])\n            elif entity.__class__.__name__ == 'ExpenseField':\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = overlayer_data['text']\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if entity.key is not None:\n                    x = overlayer_data['coords_key'][0] + 0.3 * (overlayer_data['coords_key'][2] - overlayer_data['coords_key'][0])\n                    y = overlayer_data['coords_key'][1] - text_height - 1\n                else:\n                    x = int(overlayer_data['coords'][0] + 0.3 * (overlayer_data['coords'][2] - overlayer_data['coords'][0]))\n                    y = overlayer_data['coords'][1] - text_height - 1\n                while (x, y) in text_locations and text_locations[x, y] != final_txt:\n                    y = y - text_height - 1\n                text_locations[x, y] = final_txt\n                drw.text((x, y), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__ == 'ExpenseDocument':\n                width, height = image.size\n                text_height = int(0.018 * height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                for coord, text in zip(overlayer_data['coords_list'], overlayer_data['text_list']):\n                    drw.text((coord[0], coord[3]), text, font=fnt, fill=overlayer_data['color_expense_group'])\n            elif entity.__class__.__name__ == 'Query':\n                if entity.result is None:\n                    continue\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity.result, width, height)\n                final_txt = entity.query + ' ' + overlayer_data['text']\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = int(bbox_height * font_size_ratio)\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                if with_confidence:\n                    final_txt += ' (' + str(entity.result.confidence)[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n            elif entity.__class__.__name__.startswith('Layout'):\n                width, height = image.size\n                overlayer_data = _get_overlayer_data(entity, width, height)\n                final_txt = ''\n                bbox_height = overlayer_data['coords'][3] - overlayer_data['coords'][1]\n                text_height = min(20, int(bbox_height * font_size_ratio))\n                fnt = ImageFont.truetype(os.path.join(present_path, 'arial.ttf'), text_height)\n                final_txt += overlayer_data['text']\n                if with_confidence:\n                    final_txt += ' (' + str(overlayer_data['confidence'])[:4] + ')'\n                drw.text((overlayer_data['coords'][0], overlayer_data['coords'][1] - text_height), final_txt, font=fnt, fill=overlayer_data['text_color'])\n    del drw\n    image = Image.alpha_composite(image, overlay)\n    return image\n\ndef _get_overlayer_data(entity: Any, width: float, height: float) -> dict:\n    \"\"\"\n    Returns a dictionary with all the necessary details to draw a bounding box for an entity depending on the information\n    present in it. This includes the bounding box coordinates, color of bounding box, confidence of detection and OCR text.\n\n    :param entity: DocumentEntity object for which the data needs to be created\n    :type entity: DocumentEntity\n    :param width: width of the Page object the entity belongs to\n    :type width: float, required\n    :param height: height of the Page object the entity belongs to\n    :type height: float, required\n\n    :return: Dictionary containing all the information to draw the bounding box for a DocumentEntity.\n    :rtype: dict\n    \"\"\"\n    data = {}\n    bbox = entity.bbox\n    x, y, w, h = (bbox.x * width, bbox.y * height, bbox.width * width, bbox.height * height)\n    data['coords'] = [x, y, x + w, y + h]\n    data['confidence'] = entity.confidence if entity.__class__.__name__ not in ['Table', 'ExpenseField', 'ExpenseDocument', 'LineItemRow', 'LineItemGroup'] else ''\n    data['color'] = (0, 0, 0)\n    data['text_color'] = (0, 0, 0)\n    if entity.__class__.__name__ == 'Word':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('blue')\n    elif entity.__class__.__name__ == 'Line':\n        data['text'] = entity.text\n        data['color'] = ImageColor.getrgb('lightgrey')\n        data['coords'] = [x - 1, y - 1, x + w + 1, y + h + 1]\n    elif entity.__class__.__name__ == 'KeyValue':\n        data['text'] = entity.key.__repr__()\n        data['color'] = ImageColor.getrgb('brown')\n        data['value_text'] = entity.value.__repr__()\n        data['coords'] = [x - 2, y - 2, x + w + 2, y + h + 2]\n        if entity.contains_checkbox and entity.children:\n            value_bbox = entity.children[0].bbox\n            data['value_conf'] = entity.children[0].confidence\n        else:\n            value_bbox = entity.value.bbox\n            data['value_conf'] = entity.value.confidence\n        data['color_value'] = ImageColor.getrgb('orange')\n        x, y, w, h = (value_bbox.x * width - 2, value_bbox.y * height - 2, value_bbox.width * width + 2, value_bbox.height * height + 2)\n        data['value_bbox'] = [x, y, x + w, y + h]\n    elif entity.__class__.__name__ == 'Table':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableTitle':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableFooter':\n        data['color'] = ImageColor.getrgb('green')\n        data['text'] = ''\n    elif entity.__class__.__name__ == 'TableCell':\n        data['color'] = ImageColor.getrgb('skyblue')\n        data['text'] = entity.__repr__().split('>')[-1][1:]\n    elif entity.__class__.__name__ == 'QueryResult':\n        data['color'] = ImageColor.getrgb('mediumturquoise')\n        data['text'] = entity.answer\n    elif entity.__class__.__name__ == 'Signature':\n        data['color'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'ExpenseField':\n        data['text'] = entity.type.text\n        data['text_color'] = ImageColor.getrgb('brown')\n        data['coords'] = [x - 5, y - 5, x + w + 5, y + h + 5]\n        if entity.key:\n            data['color_key'] = ImageColor.getrgb('brown')\n            data['coords_key'] = (entity.key.bbox.x * width - 3, entity.key.bbox.y * height - 3, (entity.key.bbox.x + entity.key.bbox.width) * width + 3, (entity.key.bbox.y + entity.key.bbox.height) * height + 3)\n        data['color_value'] = ImageColor.getrgb('orange')\n        data['coords_value'] = (entity.value.bbox.x * width - 3, entity.value.bbox.y * height - 3, (entity.value.bbox.x + entity.value.bbox.width) * width + 3, (entity.value.bbox.y + entity.value.bbox.height) * height + 3)\n    elif entity.__class__.__name__ == 'Expense':\n        data['text'] = entity.text\n        data['coords'] = [x - 3, y - 3, x + w + 3, y + h + 3]\n    elif entity.__class__.__name__ == 'ExpenseDocument':\n        data['color'] = ImageColor.getrgb('beige')\n        data['coords_list'] = []\n        data['text_list'] = []\n        for group in entity.summary_groups:\n            bboxes = entity.summary_groups.get_group_bboxes(group)\n            for bbox in bboxes:\n                data['coords_list'].append((bbox.x * width - 5, bbox.y * height - 5, (bbox.x + bbox.width) * width + 3, (bbox.y + bbox.height) * height + 3))\n                data['text_list'].append(group)\n        data['color_expense_group'] = ImageColor.getrgb('coral')\n    elif entity.__class__.__name__ == 'LineItemGroup':\n        data['color'] = ImageColor.getrgb('lightblue')\n        data['coords'] = [x - 10, y - 10, x + w + 10, y + h + 10]\n    elif entity.__class__.__name__ == 'LineItemRow':\n        data['color'] = ImageColor.getrgb('lightyellow')\n        data['coords'] = [x - 7, y - 7, x + w + 7, y + h + 7]\n    elif entity.__class__.__name__.startswith('Layout'):\n        data['color'] = ImageColor.getrgb('teal')\n        data['text'] = f'{entity.layout_type} - {entity.reading_order}'\n    else:\n        pass\n    return data"
  },
  "call_tree": {
    "tests/test_value.py:TestValue:setUp": {
      "textractor/entities/bbox.py:BoundingBox:from_normalized_dict": {
        "textractor/entities/bbox.py:BoundingBox:_from_dict": {
          "textractor/entities/bbox.py:BoundingBox:__init__": {
            "textractor/entities/bbox.py:SpatialObject:__init__": {}
          }
        }
      },
      "textractor/entities/word.py:Word:__init__": {
        "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
      },
      "textractor/entities/value.py:Value:__init__": {
        "textractor/entities/document_entity.py:DocumentEntity:__init__": {}
      },
      "textractor/entities/value.py:Value:words": {
        "textractor/entities/document_entity.py:DocumentEntity:bbox": {}
      },
      "textractor/entities/value.py:Value:key_id": {},
      "textractor/entities/value.py:Value:contains_checkbox": {},
      "textractor/entities/value.py:Value:page": {},
      "textractor/entities/value.py:Value:page_id": {}
    },
    "tests/test_value.py:TestValue:test_contains_checkbox": {
      "textractor/entities/value.py:Value:contains_checkbox": {}
    },
    "tests/test_value.py:TestValue:test_get_words_by_type": {
      "textractor/entities/value.py:Value:get_words_by_type": {
        "textractor/data/constants.py:TextTypes:TextTypes": {},
        "textractor/entities/value.py:Value:words": {
          "textractor/entities/value.py:Value:contains_checkbox": {},
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        },
        "textractor/entities/word.py:Word:text_type": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/visualizers/entitylist.py:EntityList:__init__": {}
    },
    "tests/test_value.py:TestValue:test_key_id": {
      "textractor/entities/value.py:Value:key_id": {}
    },
    "tests/test_value.py:TestValue:test_repr": {
      "textractor/entities/value.py:Value:__repr__": {
        "textractor/entities/value.py:Value:contains_checkbox": {},
        "textractor/entities/value.py:Value:words": {
          "textractor/entities/value.py:Value:contains_checkbox": {},
          "textractor/visualizers/entitylist.py:EntityList:__init__": {}
        },
        "textractor/entities/word.py:Word:text": {}
      }
    },
    "tests/test_value.py:TestValue:test_set_page": {
      "textractor/entities/value.py:Value:page": {}
    },
    "tests/test_value.py:TestValue:test_set_page_id": {
      "textractor/entities/value.py:Value:page_id": {}
    },
    "tests/test_value.py:TestValue:test_words": {
      "textractor/entities/value.py:Value:words": {
        "textractor/entities/value.py:Value:contains_checkbox": {},
        "textractor/visualizers/entitylist.py:EntityList:__init__": {}
      },
      "textractor/visualizers/entitylist.py:EntityList:__init__": {}
    }
  }
}