{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_type_constant",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_type_constant.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass TestTypeConstant:\n    def setup_method(self) -> None:\n        self.result = TypeConstant(\"value\")\n\n    def test_init(self) -> None:\n        assert self.result.value == \"value\"\n        assert hash(self.result)\n\n    def test_render(self) -> None:\n        assert self.result.render() == \"'value'\"\n        assert TypeConstant(TypeConstant.Ellipsis).render() == \"...\"\n\n    def test_get_import_record(self) -> None:\n        assert len(self.result.get_import_records()) == 0\n\n    def test_copy(self) -> None:\n        assert self.result.copy().value == \"value\"\n\n    def test_is_type(self) -> None:\n        assert not self.result.is_dict()\n        assert not self.result.is_list()\n\n    def test_compare(self) -> None:\n        assert self.result == TypeConstant(\"value\")\n        assert self.result != TypeConstant(\"other\")\n        assert self.result > TypeConstant(\"aaa\")\n\n        with pytest.raises(BuildInternalError):\n            assert self.result == \"value\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\n\n\nValueType = str | int | float | EllipsisType | None\n\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n\n    Ellipsis: Final[EllipsisType] = EllipsisType()\n\n    def __init__(self, value: ValueType) -> None:\n        self.value: ValueType = value\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.value is self.Ellipsis:\n            return \"...\"\n\n        return repr(self.value)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.value)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the instance of the FakeAnnotation class based on its string representation. The method utilizes the get_sort_key() function, which is expected to return a string that uniquely represents the type annotation. This hash value can be used in hashing contexts, such as in sets or as keys in dictionaries, facilitating comparisons and storage of instances of FakeAnnotation and its subclasses.\"\"\"\n        '\\n        Calculate hash value based on string render.\\n        '\n        return hash(self.get_sort_key())",
        "docstring": "Calculate a hash value for the instance of the FakeAnnotation class based on its string representation. The method utilizes the get_sort_key() function, which is expected to return a string that uniquely represents the type annotation. This hash value can be used in hashing contexts, such as in sets or as keys in dictionaries, facilitating comparisons and storage of instances of FakeAnnotation and its subclasses.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determine equality between two type annotation instances.\n\nParameters:\n- other (object): The object to compare against the current instance. This should be an instance of FakeAnnotation.\n\nReturns:\n- bool: True if the two annotations are considered equal based on their sort keys; otherwise, False.\n\nRaises:\n- BuildInternalError: If the 'other' parameter is not an instance of FakeAnnotation, indicating an invalid comparison attempt.\n\nThis method relies on the get_sort_key() method to obtain a comparable string representation of each annotation, ensuring that equality is determined based on their rendered output. If 'other' is not a FakeAnnotation, it raises an exception, ensuring type safety for comparison.\"\"\"\n        '\\n        Whether two annotations are equal.\\n        '\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()",
        "docstring": "Determine equality between two type annotation instances.\n\nParameters:\n- other (object): The object to compare against the current instance. This should be an instance of FakeAnnotation.\n\nReturns:\n- bool: True if the two annotations are considered equal based on their sort keys; otherwise, False.\n\nRaises:\n- BuildInternalError: If the 'other' parameter is not an instance of FakeAnnotation, indicating an invalid comparison attempt.\n\nThis method relies on the get_sort_key() method to obtain a comparable string representation of each annotation, ensuring that equality is determined based on their rendered output. If 'other' is not a FakeAnnotation, it raises an exception, ensuring type safety for comparison.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.__gt__": {
        "code": "    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"Compare two instances of the FakeAnnotation class for sorting purposes.\n\nParameters:\n- other (FakeAnnotation): Another instance of FakeAnnotation to compare against.\n\nReturns:\n- bool: True if the sort key of the current instance is greater than the sort key of the other instance; otherwise, False.\n\nDependencies:\n- This method relies on the get_sort_key() method to obtain a string representation used for comparison. The comparison is based on the lexicographical order of these strings.\"\"\"\n        '\\n        Compare two annotations for sorting.\\n        '\n        return self.get_sort_key() > other.get_sort_key()",
        "docstring": "Compare two instances of the FakeAnnotation class for sorting purposes.\n\nParameters:\n- other (FakeAnnotation): Another instance of FakeAnnotation to compare against.\n\nReturns:\n- bool: True if the sort key of the current instance is greater than the sort key of the other instance; otherwise, False.\n\nDependencies:\n- This method relies on the get_sort_key() method to obtain a string representation used for comparison. The comparison is based on the lexicographical order of these strings.",
        "signature": "def __gt__(self: Self, other: 'FakeAnnotation') -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.get_sort_key": {
        "code": "    def get_sort_key(self) -> str:\n        \"\"\"Get a string representation of the annotation for sorting purposes.\n\nThis method returns the string representation of the instance, which is utilized\nin comparison operations for sorting annotations. It does not take any parameters\nand relies on the `__str__` method of the instance to generate the string.\n\nReturns:\n    str: A string used to sort the annotations based on their string representation.\"\"\"\n        '\\n        Get string to sort annotations.\\n        '\n        return str(self)",
        "docstring": "Get a string representation of the annotation for sorting purposes.\n\nThis method returns the string representation of the instance, which is utilized\nin comparison operations for sorting annotations. It does not take any parameters\nand relies on the `__str__` method of the instance to generate the string.\n\nReturns:\n    str: A string used to sort the annotations based on their string representation.",
        "signature": "def get_sort_key(self) -> str:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation._get_import_records": {
        "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get import records required for using the type annotation.\n\nThis method is intended to be overridden by subclasses to return a set of `ImportRecord` instances that represent the necessary imports for utilizing the given type annotation properly. The default implementation returns an empty set, meaning no imports are required.\n\nReturns:\n    set[ImportRecord]: A set containing `ImportRecord` instances required for the type annotation, or an empty set if no imports are needed.\n\nInteraction:\n    The method relies on the `ImportRecord` class, which is imported from the `mypy_boto3_builder.import_helpers.import_record` module. Subclasses should implement their alternative logic to accumulate and return relevant import records for the specific type they represent.\"\"\"\n        '\\n        Get import record required for using type annotation.\\n        '\n        return set()",
        "docstring": "Get import records required for using the type annotation.\n\nThis method is intended to be overridden by subclasses to return a set of `ImportRecord` instances that represent the necessary imports for utilizing the given type annotation properly. The default implementation returns an empty set, meaning no imports are required.\n\nReturns:\n    set[ImportRecord]: A set containing `ImportRecord` instances required for the type annotation, or an empty set if no imports are needed.\n\nInteraction:\n    The method relies on the `ImportRecord` class, which is imported from the `mypy_boto3_builder.import_helpers.import_record` module. Subclasses should implement their alternative logic to accumulate and return relevant import records for the specific type they represent.",
        "signature": "def _get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Retrieve a set of `ImportRecord` instances required for utilizing the type annotation represented by the `FakeAnnotation`. This method calls the private method `_get_import_records` to gather the necessary import records and filters out any records that originate from built-in sources, as determined by the `is_builtins()` method of the `source` attribute of the `ImportRecord`. The return value is a set of `ImportRecord` objects, which may be used to manage dependencies for type annotations in the broader context of the application.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
        "docstring": "Retrieve a set of `ImportRecord` instances required for utilizing the type annotation represented by the `FakeAnnotation`. This method calls the private method `_get_import_records` to gather the necessary import records and filters out any records that originate from built-in sources, as determined by the `is_builtins()` method of the `source` attribute of the `ImportRecord`. The return value is a set of `ImportRecord` objects, which may be used to manage dependencies for type annotations in the broader context of the application.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.is_dict": {
        "code": "    def is_dict(self) -> bool:\n        \"\"\"Determine if the type annotation represented by the instance is a dictionary type.\n\nThis method serves as an interface for subclasses to indicate if the particular type annotation corresponds to either `Dict` or `TypedDict`. By default, it returns `False`, implying that the type is not a dictionary.\n\nReturns:\n    bool: Returns `False` indicating that the annotation is not a dictionary type. Subclasses should override this method to return `True` if their type is indeed a dictionary representation.\n\nThis method is part of the `FakeAnnotation` class, which provides a common interface for all type annotation wrappers. It does not depend on any external constants or variables.\"\"\"\n        '\\n        Whether type annotation is `Dict` or `TypedDict`.\\n        '\n        return False",
        "docstring": "Determine if the type annotation represented by the instance is a dictionary type.\n\nThis method serves as an interface for subclasses to indicate if the particular type annotation corresponds to either `Dict` or `TypedDict`. By default, it returns `False`, implying that the type is not a dictionary.\n\nReturns:\n    bool: Returns `False` indicating that the annotation is not a dictionary type. Subclasses should override this method to return `True` if their type is indeed a dictionary representation.\n\nThis method is part of the `FakeAnnotation` class, which provides a common interface for all type annotation wrappers. It does not depend on any external constants or variables.",
        "signature": "def is_dict(self) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.is_list": {
        "code": "    def is_list(self) -> bool:\n        \"\"\"Indicates whether the type annotation represented by this instance is of type `List`. \n\nThis method does not take any parameters and returns a boolean value. By default, it returns `False`, implying that the instance is not identified as a `List`. Subclasses of `FakeAnnotation` should override this method to provide specific implementations that return `True` if they represent a list type annotation.\n\nThis method is used to help determine the nature of the type annotations, which can be useful in type checking and rendering for local usage.\"\"\"\n        '\\n        Whether type annotation is `List`.\\n        '\n        return False",
        "docstring": "Indicates whether the type annotation represented by this instance is of type `List`. \n\nThis method does not take any parameters and returns a boolean value. By default, it returns `False`, implying that the instance is not identified as a `List`. Subclasses of `FakeAnnotation` should override this method to provide specific implementations that return `True` if they represent a list type annotation.\n\nThis method is used to help determine the nature of the type annotations, which can be useful in type checking and rendering for local usage.",
        "signature": "def is_list(self) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a shallow copy of the current instance of the `FakeAnnotation` type wrapper. This method uses the `copy` module's `copy` function to generate the copy, allowing for the duplication of the annotation's state while preserving the original instance. The method does not take any parameters and returns a new instance of the same type (`Self`) representing the copied annotation.\n\nThis method is useful for scenarios where a distinct copy of the annotation is needed to avoid mutating the original instance. It interacts with the `copy` module, which is imported at the top of the file to facilitate the copying process.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a shallow copy of the current instance of the `FakeAnnotation` type wrapper. This method uses the `copy` module's `copy` function to generate the copy, allowing for the duplication of the annotation's state while preserving the original instance. The method does not take any parameters and returns a new instance of the same type (`Self`) representing the copied annotation.\n\nThis method is useful for scenarios where a distinct copy of the annotation is needed to avoid mutating the original instance. It interacts with the `copy` module, which is imported at the top of the file to facilitate the copying process.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_constant.py": {
      "TypeConstant.__init__": {
        "code": "    def __init__(self, value: ValueType) -> None:\n        \"\"\"Initialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None. This allows for flexibility in the type of constant being represented.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the TypeConstant instance.\n\nThis method is essential for creating instances of TypeConstant, enabling type annotations and interactions with other parts of the code, such as the render method that formats the constant for Python code output.\"\"\"\n        self.value: ValueType = value",
        "docstring": "Initialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None. This allows for flexibility in the type of constant being represented.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the TypeConstant instance.\n\nThis method is essential for creating instances of TypeConstant, enabling type annotations and interactions with other parts of the code, such as the render method that formats the constant for Python code output.",
        "signature": "def __init__(self, value: ValueType) -> None:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      },
      "TypeConstant.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the type annotation as a valid Python code string for local usage.\n\nThis method checks the value of the TypeConstant instance. If the value is the special Ellipsis constant (defined as `self.Ellipsis`), it returns the string `\"...\"`. Otherwise, it returns the string representation of the instance's value using `repr()`. The `Ellipsis` constant serves as a placeholder for the `...` syntax in Python, allowing for clear differentiation in type annotations.\n\nReturns:\n    str: A string representing the valid type annotation.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if self.value is self.Ellipsis:\n            return '...'\n        return repr(self.value)",
        "docstring": "Render the type annotation as a valid Python code string for local usage.\n\nThis method checks the value of the TypeConstant instance. If the value is the special Ellipsis constant (defined as `self.Ellipsis`), it returns the string `\"...\"`. Otherwise, it returns the string representation of the instance's value using `repr()`. The `Ellipsis` constant serves as a placeholder for the `...` syntax in Python, allowing for clear differentiation in type annotations.\n\nReturns:\n    str: A string representing the valid type annotation.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      },
      "TypeConstant.__copy__": {
        "code": "    def __copy__(self) -> Self:\n        \"\"\"Create and return a copy of the `TypeConstant` instance.\n\nThis method replicates the current instance of `TypeConstant`, including its `value` attribute. The `value` can be of various types defined in `ValueType`, which includes `str`, `int`, `float`, `EllipsisType`, or `None`. Notably, `EllipsisType` is a placeholder for the ellipsis object (`...`), which is defined as a class attribute. The method ensures that the new instance matches the original's state without affecting the original instance's state.\n\nReturns:\n    A new instance of `TypeConstant` containing the same `value` as the one being copied.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return self.__class__(self.value)",
        "docstring": "Create and return a copy of the `TypeConstant` instance.\n\nThis method replicates the current instance of `TypeConstant`, including its `value` attribute. The `value` can be of various types defined in `ValueType`, which includes `str`, `int`, `float`, `EllipsisType`, or `None`. Notably, `EllipsisType` is a placeholder for the ellipsis object (`...`), which is defined as a class attribute. The method ensures that the new instance matches the original's state without affecting the original instance's state.\n\nReturns:\n    A new instance of `TypeConstant` containing the same `value` as the one being copied.",
        "signature": "def __copy__(self) -> Self:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render annotation usage as a valid Python statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:_get_import_records": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {},
    "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__copy__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__gt__": {}
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_type_constant\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 fake_annotation.py\n        \u2502   \u251c\u2500\u2500 FakeAnnotation\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__eq__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__gt__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__hash__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation._get_import_records\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.copy\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.get_import_records\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.get_sort_key\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.is_dict\n        \u2502   \u2514\u2500\u2500 FakeAnnotation.is_list\n        \u2514\u2500\u2500 type_constant.py\n            \u251c\u2500\u2500 TypeConstant.__copy__\n            \u251c\u2500\u2500 TypeConstant.__init__\n            \u2514\u2500\u2500 TypeConstant.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and test the behavior of the `TypeConstant` class, which serves as a representation of constant type values in a type annotation system. It ensures that `TypeConstant` properly handles core functionality such as initialization, value comparison, string rendering, copying, and type determination. By providing a robust set of tests, the module verifies the correctness and reliability of this component, ensuring consistent handling of constant type representations within larger workflows. This helps developers identify and prevent internal errors, improving the stability of systems leveraging these type annotation constructs.\n\n## FILE 1: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.__hash__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the instance of the FakeAnnotation class based on its string representation. The method utilizes the get_sort_key() function, which is expected to return a string that uniquely represents the type annotation. This hash value can be used in hashing contexts, such as in sets or as keys in dictionaries, facilitating comparisons and storage of instances of FakeAnnotation and its subclasses.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.__gt__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two instances of the FakeAnnotation class for sorting purposes.\n\nParameters:\n- other (FakeAnnotation): Another instance of FakeAnnotation to compare against.\n\nReturns:\n- bool: True if the sort key of the current instance is greater than the sort key of the other instance; otherwise, False.\n\nDependencies:\n- This method relies on the get_sort_key() method to obtain a string representation used for comparison. The comparison is based on the lexicographical order of these strings.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.get_sort_key\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_sort_key(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a string representation of the annotation for sorting purposes.\n\nThis method returns the string representation of the instance, which is utilized\nin comparison operations for sorting annotations. It does not take any parameters\nand relies on the `__str__` method of the instance to generate the string.\n\nReturns:\n    str: A string used to sort the annotations based on their string representation.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.is_dict\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def is_dict(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the type annotation represented by the instance is a dictionary type.\n\nThis method serves as an interface for subclasses to indicate if the particular type annotation corresponds to either `Dict` or `TypedDict`. By default, it returns `False`, implying that the type is not a dictionary.\n\nReturns:\n    bool: Returns `False` indicating that the annotation is not a dictionary type. Subclasses should override this method to return `True` if their type is indeed a dictionary representation.\n\nThis method is part of the `FakeAnnotation` class, which provides a common interface for all type annotation wrappers. It does not depend on any external constants or variables.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.__eq__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine equality between two type annotation instances.\n\nParameters:\n- other (object): The object to compare against the current instance. This should be an instance of FakeAnnotation.\n\nReturns:\n- bool: True if the two annotations are considered equal based on their sort keys; otherwise, False.\n\nRaises:\n- BuildInternalError: If the 'other' parameter is not an instance of FakeAnnotation, indicating an invalid comparison attempt.\n\nThis method relies on the get_sort_key() method to obtain a comparable string representation of each annotation, ensuring that equality is determined based on their rendered output. If 'other' is not a FakeAnnotation, it raises an exception, ensuring type safety for comparison.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.is_list\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def is_list(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nIndicates whether the type annotation represented by this instance is of type `List`. \n\nThis method does not take any parameters and returns a boolean value. By default, it returns `False`, implying that the instance is not identified as a `List`. Subclasses of `FakeAnnotation` should override this method to provide specific implementations that return `True` if they represent a list type annotation.\n\nThis method is used to help determine the nature of the type annotations, which can be useful in type checking and rendering for local usage.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a shallow copy of the current instance of the `FakeAnnotation` type wrapper. This method uses the `copy` module's `copy` function to generate the copy, allowing for the duplication of the annotation's state while preserving the original instance. The method does not take any parameters and returns a new instance of the same type (`Self`) representing the copied annotation.\n\nThis method is useful for scenarios where a distinct copy of the annotation is needed to avoid mutating the original instance. It interacts with the `copy` module, which is imported at the top of the file to facilitate the copying process.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a set of `ImportRecord` instances required for utilizing the type annotation represented by the `FakeAnnotation`. This method calls the private method `_get_import_records` to gather the necessary import records and filters out any records that originate from built-in sources, as determined by the `is_builtins()` method of the `source` attribute of the `ImportRecord`. The return value is a set of `ImportRecord` objects, which may be used to manage dependencies for type annotations in the broader context of the application.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation._get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def _get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet import records required for using the type annotation.\n\nThis method is intended to be overridden by subclasses to return a set of `ImportRecord` instances that represent the necessary imports for utilizing the given type annotation properly. The default implementation returns an empty set, meaning no imports are required.\n\nReturns:\n    set[ImportRecord]: A set containing `ImportRecord` instances required for the type annotation, or an empty set if no imports are needed.\n\nInteraction:\n    The method relies on the `ImportRecord` class, which is imported from the `mypy_boto3_builder.import_helpers.import_record` module. Subclasses should implement their alternative logic to accumulate and return relevant import records for the specific type they represent.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/type_constant.py\n\n- CLASS METHOD: TypeConstant.__copy__\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def __copy__(self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate and return a copy of the `TypeConstant` instance.\n\nThis method replicates the current instance of `TypeConstant`, including its `value` attribute. The `value` can be of various types defined in `ValueType`, which includes `str`, `int`, `float`, `EllipsisType`, or `None`. Notably, `EllipsisType` is a placeholder for the ellipsis object (`...`), which is defined as a class attribute. The method ensures that the new instance matches the original's state without affecting the original instance's state.\n\nReturns:\n    A new instance of `TypeConstant` containing the same `value` as the one being copied.\n\"\"\"\n```\n\n- CLASS METHOD: TypeConstant.render\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation as a valid Python code string for local usage.\n\nThis method checks the value of the TypeConstant instance. If the value is the special Ellipsis constant (defined as `self.Ellipsis`), it returns the string `\"...\"`. Otherwise, it returns the string representation of the instance's value using `repr()`. The `Ellipsis` constant serves as a placeholder for the `...` syntax in Python, allowing for clear differentiation in type annotations.\n\nReturns:\n    str: A string representing the valid type annotation.\n\"\"\"\n```\n\n- CLASS METHOD: TypeConstant.__init__\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def __init__(self, value: ValueType) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeConstant instance with a specified constant value.\n\nParameters:\n    value (ValueType): The constant value to be wrapped, which can be of type str, int, float, EllipsisType, or None. This allows for flexibility in the type of constant being represented.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the TypeConstant instance.\n\nThis method is essential for creating instances of TypeConstant, enabling type annotations and interactions with other parts of the code, such as the render method that formats the constant for Python code output.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import Final, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\nValueType = str | int | float | EllipsisType | None\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n    Ellipsis: Final[EllipsisType] = EllipsisType()"
  },
  "call_tree": {
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:setup_method": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_init": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_render": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {},
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_get_import_record": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:_get_import_records": {}
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__copy__": {
          "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
        }
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_is_type": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:is_dict": {},
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:is_list": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_compare": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {},
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      },
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__gt__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      }
    }
  }
}