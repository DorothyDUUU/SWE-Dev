{
  "dir_path": "/app/dogpile_cache",
  "package_name": "dogpile_cache",
  "sample_name": "dogpile_cache-test_utils",
  "src_dir": "dogpile/",
  "test_dir": "tests/",
  "test_file": "tests/test_utils.py",
  "test_code": "from dogpile import util\nfrom dogpile.testing import eq_\n\n\nclass UtilsTest:\n\n    \"\"\"Test the relevant utils functionality.\"\"\"\n\n    def test_coerce_string_conf(self):\n        settings = {\"expiration_time\": \"-1\"}\n        coerced = util.coerce_string_conf(settings)\n        eq_(coerced[\"expiration_time\"], -1)\n\n        settings = {\"expiration_time\": \"+1\"}\n        coerced = util.coerce_string_conf(settings)\n        eq_(coerced[\"expiration_time\"], 1)\n        eq_(type(coerced[\"expiration_time\"]), int)\n\n        settings = {\"arguments.lock_sleep\": \"0.1\"}\n        coerced = util.coerce_string_conf(settings)\n        eq_(coerced[\"arguments.lock_sleep\"], 0.1)\n\n        settings = {\"arguments.lock_sleep\": \"-3.14e-10\"}\n        coerced = util.coerce_string_conf(settings)\n        eq_(coerced[\"arguments.lock_sleep\"], -3.14e-10)\n",
  "GT_file_code": {
    "dogpile/util/langhelpers.py": "import abc\nimport collections\nimport re\nimport threading\nfrom typing import MutableMapping\nfrom typing import MutableSet\n\nimport stevedore\n\n\ndef coerce_string_conf(d):\n    result = {}\n    for k, v in d.items():\n        if not isinstance(v, str):\n            result[k] = v\n            continue\n\n        v = v.strip()\n        if re.match(r\"^[-+]?\\d+$\", v):\n            result[k] = int(v)\n        elif re.match(r\"^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?$\", v):\n            result[k] = float(v)\n        elif v.lower() in (\"false\", \"true\"):\n            result[k] = v.lower() == \"true\"\n        elif v == \"None\":\n            result[k] = None\n        else:\n            result[k] = v\n    return result\n\n\nclass PluginLoader:\n    def __init__(self, group):\n        self.group = group\n        self.impls = {}  # loaded plugins\n        self._mgr = None  # lazily defined stevedore manager\n        self._unloaded = {}  # plugins registered but not loaded\n\n    def load(self, name):\n        if name in self._unloaded:\n            self.impls[name] = self._unloaded[name]()\n            return self.impls[name]\n        if name in self.impls:\n            return self.impls[name]\n        else:  # pragma NO COVERAGE\n            if self._mgr is None:\n                self._mgr = stevedore.ExtensionManager(self.group)\n            try:\n                self.impls[name] = self._mgr[name].plugin\n                return self.impls[name]\n            except KeyError:\n                raise self.NotFound(\n                    \"Can't load plugin %s %s\" % (self.group, name)\n                )\n\n    def register(self, name, modulepath, objname):\n        def load():\n            mod = __import__(modulepath, fromlist=[objname])\n            return getattr(mod, objname)\n\n        self._unloaded[name] = load\n\n    class NotFound(Exception):\n        \"\"\"The specified plugin could not be found.\"\"\"\n\n\nclass memoized_property:\n    \"\"\"A read-only @property that is only evaluated once.\"\"\"\n\n    def __init__(self, fget, doc=None):\n        self.fget = fget\n        self.__doc__ = doc or fget.__doc__\n        self.__name__ = fget.__name__\n\n    def __get__(self, obj, cls):\n        if obj is None:\n            return self\n        obj.__dict__[self.__name__] = result = self.fget(obj)\n        return result\n\n\ndef to_list(x, default=None):\n    \"\"\"Coerce to a list.\"\"\"\n    if x is None:\n        return default\n    if not isinstance(x, (list, tuple)):\n        return [x]\n    else:\n        return x\n\n\nclass Mutex(abc.ABC):\n    @abc.abstractmethod\n    def acquire(self, wait: bool = True) -> bool:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def release(self) -> None:\n        raise NotImplementedError()\n\n\nclass KeyReentrantMutex:\n    def __init__(\n        self,\n        key: str,\n        mutex: Mutex,\n        keys: MutableMapping[int, MutableSet[str]],\n    ):\n        self.key = key\n        self.mutex = mutex\n        self.keys = keys\n\n    @classmethod\n    def factory(cls, mutex):\n        # this collection holds zero or one\n        # thread idents as the key; a set of\n        # keynames held as the value.\n        keystore: MutableMapping[\n            int, MutableSet[str]\n        ] = collections.defaultdict(set)\n\n        def fac(key):\n            return KeyReentrantMutex(key, mutex, keystore)\n\n        return fac\n\n    def acquire(self, wait=True):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        if keys is not None and self.key not in keys:\n            # current lockholder, new key. add it in\n            keys.add(self.key)\n            return True\n        elif self.mutex.acquire(wait=wait):\n            # after acquire, create new set and add our key\n            self.keys[current_thread].add(self.key)\n            return True\n        else:\n            return False\n\n    def release(self):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        assert keys is not None, \"this thread didn't do the acquire\"\n        assert self.key in keys, \"No acquire held for key '%s'\" % self.key\n        keys.remove(self.key)\n        if not keys:\n            # when list of keys empty, remove\n            # the thread ident and unlock.\n            del self.keys[current_thread]\n            self.mutex.release()\n\n    def locked(self):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        if keys is None:\n            return False\n        return self.key in keys\n",
    "dogpile/testing/assertions.py": "import re\nimport sys\nimport time\n\n\ndef eq_(a, b, msg=None):\n    \"\"\"Assert a == b, with repr messaging on failure.\"\"\"\n    assert a == b, msg or \"%r != %r\" % (a, b)\n\n\ndef is_(a, b, msg=None):\n    \"\"\"Assert a is b, with repr messaging on failure.\"\"\"\n    assert a is b, msg or \"%r is not %r\" % (a, b)\n\n\ndef ne_(a, b, msg=None):\n    \"\"\"Assert a != b, with repr messaging on failure.\"\"\"\n    assert a != b, msg or \"%r == %r\" % (a, b)\n\n\ndef assert_raises_message(except_cls, msg, callable_, *args, **kwargs):\n    try:\n        callable_(*args, **kwargs)\n        assert False, \"Callable did not raise an exception\"\n    except except_cls as e:\n        assert re.search(msg, str(e)), \"%r !~ %s\" % (msg, e)\n\n\ndef winsleep():\n    # sleep a for an amount of time\n    # sufficient for windows time.time()\n    # to change\n    if sys.platform.startswith(\"win\"):\n        time.sleep(0.001)\n"
  },
  "GT_src_dict": {
    "dogpile/util/langhelpers.py": {
      "coerce_string_conf": {
        "code": "def coerce_string_conf(d):\n    \"\"\"Converts values in a dictionary from string representations to their appropriate Python types.\n\nParameters:\n    d (dict): A dictionary where values may be strings representing numbers, booleans, or None.\n\nReturns:\n    dict: A new dictionary where string values are converted to integers, floats, booleans, or None according to the following rules:\n        - Strings matching integer patterns (e.g., \"42\") are converted to integers.\n        - Strings matching float patterns (e.g., \"3.14\" or \"2.0e10\") are converted to floats.\n        - Strings \"true\" and \"false\" (case insensitive) are converted to their boolean forms.\n        - The string \"None\" is converted to Python's None type.\n        - Other strings remain unchanged.\n    \nDependencies:\n    The function uses the `re` module for regular expression matching to identify types of string values.\"\"\"\n    result = {}\n    for k, v in d.items():\n        if not isinstance(v, str):\n            result[k] = v\n            continue\n        v = v.strip()\n        if re.match('^[-+]?\\\\d+$', v):\n            result[k] = int(v)\n        elif re.match('^[-+]?(?:\\\\d+(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?$', v):\n            result[k] = float(v)\n        elif v.lower() in ('false', 'true'):\n            result[k] = v.lower() == 'true'\n        elif v == 'None':\n            result[k] = None\n        else:\n            result[k] = v\n    return result",
        "docstring": "Converts values in a dictionary from string representations to their appropriate Python types.\n\nParameters:\n    d (dict): A dictionary where values may be strings representing numbers, booleans, or None.\n\nReturns:\n    dict: A new dictionary where string values are converted to integers, floats, booleans, or None according to the following rules:\n        - Strings matching integer patterns (e.g., \"42\") are converted to integers.\n        - Strings matching float patterns (e.g., \"3.14\" or \"2.0e10\") are converted to floats.\n        - Strings \"true\" and \"false\" (case insensitive) are converted to their boolean forms.\n        - The string \"None\" is converted to Python's None type.\n        - Other strings remain unchanged.\n    \nDependencies:\n    The function uses the `re` module for regular expression matching to identify types of string values.",
        "signature": "def coerce_string_conf(d):",
        "type": "Function",
        "class_signature": null
      }
    },
    "dogpile/testing/assertions.py": {
      "eq_": {
        "code": "def eq_(a, b, msg=None):\n    \"\"\"Asserts that the two provided values, a and b, are equal (a == b). If the assertion fails, it raises an AssertionError with a custom message or a default error message that shows the string representations of both values. \n\nParameters:\n- a: The first value to be compared for equality.\n- b: The second value to be compared for equality.\n- msg: An optional custom message to display if the assertion fails.\n\nReturns:\n- None: This function does not return a value; it either passes the assertion or raises an exception.\n\nDependencies:\n- Utilizes the built-in assert statement to perform the comparison, thus it will halt execution if the condition is false. The function does not rely on any external constants or variables.\"\"\"\n    'Assert a == b, with repr messaging on failure.'\n    assert a == b, msg or '%r != %r' % (a, b)",
        "docstring": "Asserts that the two provided values, a and b, are equal (a == b). If the assertion fails, it raises an AssertionError with a custom message or a default error message that shows the string representations of both values. \n\nParameters:\n- a: The first value to be compared for equality.\n- b: The second value to be compared for equality.\n- msg: An optional custom message to display if the assertion fails.\n\nReturns:\n- None: This function does not return a value; it either passes the assertion or raises an exception.\n\nDependencies:\n- Utilizes the built-in assert statement to perform the comparison, thus it will halt execution if the condition is false. The function does not rely on any external constants or variables.",
        "signature": "def eq_(a, b, msg=None):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: dogpile_cache-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 dogpile/\n    \u251c\u2500\u2500 testing/\n    \u2502   \u2514\u2500\u2500 assertions.py\n    \u2502       \u2514\u2500\u2500 eq_\n    \u2514\u2500\u2500 util/\n        \u2514\u2500\u2500 langhelpers.py\n            \u2514\u2500\u2500 coerce_string_conf\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and transform configuration settings provided as strings into their appropriate data types for use within an application. Its primary functionality is to ensure that string-based configuration values, such as numbers with signs or floating-point representations, are accurately parsed into integers or floating-point numbers. This capability facilitates seamless handling of configuration inputs by developers, reducing the risk of misinterpretation or errors caused by improper data types in system settings. By automating the coercion of configuration values into their intended types, the module streamlines configuration management and enhances system reliability.\n\n## FILE 1: dogpile/util/langhelpers.py\n\n- FUNCTION NAME: coerce_string_conf\n  - SIGNATURE: def coerce_string_conf(d):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts values in a dictionary from string representations to their appropriate Python types.\n\nParameters:\n    d (dict): A dictionary where values may be strings representing numbers, booleans, or None.\n\nReturns:\n    dict: A new dictionary where string values are converted to integers, floats, booleans, or None according to the following rules:\n        - Strings matching integer patterns (e.g., \"42\") are converted to integers.\n        - Strings matching float patterns (e.g., \"3.14\" or \"2.0e10\") are converted to floats.\n        - Strings \"true\" and \"false\" (case insensitive) are converted to their boolean forms.\n        - The string \"None\" is converted to Python's None type.\n        - Other strings remain unchanged.\n    \nDependencies:\n    The function uses the `re` module for regular expression matching to identify types of string values.\n\"\"\"\n```\n\n## FILE 2: dogpile/testing/assertions.py\n\n- FUNCTION NAME: eq_\n  - SIGNATURE: def eq_(a, b, msg=None):\n  - DOCSTRING: \n```python\n\"\"\"\nAsserts that the two provided values, a and b, are equal (a == b). If the assertion fails, it raises an AssertionError with a custom message or a default error message that shows the string representations of both values. \n\nParameters:\n- a: The first value to be compared for equality.\n- b: The second value to be compared for equality.\n- msg: An optional custom message to display if the assertion fails.\n\nReturns:\n- None: This function does not return a value; it either passes the assertion or raises an exception.\n\nDependencies:\n- Utilizes the built-in assert statement to perform the comparison, thus it will halt execution if the condition is false. The function does not rely on any external constants or variables.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "dogpile/util/langhelpers.py": "import abc\nimport collections\nimport re\nimport threading\nfrom typing import MutableMapping\nfrom typing import MutableSet\nimport stevedore\n\nclass PluginLoader:\n\n    def __init__(self, group):\n        self.group = group\n        self.impls = {}\n        self._mgr = None\n        self._unloaded = {}\n\n    def load(self, name):\n        if name in self._unloaded:\n            self.impls[name] = self._unloaded[name]()\n            return self.impls[name]\n        if name in self.impls:\n            return self.impls[name]\n        else:\n            if self._mgr is None:\n                self._mgr = stevedore.ExtensionManager(self.group)\n            try:\n                self.impls[name] = self._mgr[name].plugin\n                return self.impls[name]\n            except KeyError:\n                raise self.NotFound(\"Can't load plugin %s %s\" % (self.group, name))\n\n    def register(self, name, modulepath, objname):\n\n        def load():\n            mod = __import__(modulepath, fromlist=[objname])\n            return getattr(mod, objname)\n        self._unloaded[name] = load\n\n    class NotFound(Exception):\n        \"\"\"The specified plugin could not be found.\"\"\"\n\nclass memoized_property:\n    \"\"\"A read-only @property that is only evaluated once.\"\"\"\n\n    def __init__(self, fget, doc=None):\n        self.fget = fget\n        self.__doc__ = doc or fget.__doc__\n        self.__name__ = fget.__name__\n\n    def __get__(self, obj, cls):\n        if obj is None:\n            return self\n        obj.__dict__[self.__name__] = result = self.fget(obj)\n        return result\n\ndef to_list(x, default=None):\n    \"\"\"Coerce to a list.\"\"\"\n    if x is None:\n        return default\n    if not isinstance(x, (list, tuple)):\n        return [x]\n    else:\n        return x\n\nclass Mutex(abc.ABC):\n\n    @abc.abstractmethod\n    def acquire(self, wait: bool=True) -> bool:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def release(self) -> None:\n        raise NotImplementedError()\n\nclass KeyReentrantMutex:\n\n    def __init__(self, key: str, mutex: Mutex, keys: MutableMapping[int, MutableSet[str]]):\n        self.key = key\n        self.mutex = mutex\n        self.keys = keys\n\n    @classmethod\n    def factory(cls, mutex):\n        keystore: MutableMapping[int, MutableSet[str]] = collections.defaultdict(set)\n\n        def fac(key):\n            return KeyReentrantMutex(key, mutex, keystore)\n        return fac\n\n    def acquire(self, wait=True):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        if keys is not None and self.key not in keys:\n            keys.add(self.key)\n            return True\n        elif self.mutex.acquire(wait=wait):\n            self.keys[current_thread].add(self.key)\n            return True\n        else:\n            return False\n\n    def release(self):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        assert keys is not None, \"this thread didn't do the acquire\"\n        assert self.key in keys, \"No acquire held for key '%s'\" % self.key\n        keys.remove(self.key)\n        if not keys:\n            del self.keys[current_thread]\n            self.mutex.release()\n\n    def locked(self):\n        current_thread = threading.get_ident()\n        keys = self.keys.get(current_thread)\n        if keys is None:\n            return False\n        return self.key in keys",
    "dogpile/testing/assertions.py": "import re\nimport sys\nimport time\n\ndef is_(a, b, msg=None):\n    \"\"\"Assert a is b, with repr messaging on failure.\"\"\"\n    assert a is b, msg or '%r is not %r' % (a, b)\n\ndef ne_(a, b, msg=None):\n    \"\"\"Assert a != b, with repr messaging on failure.\"\"\"\n    assert a != b, msg or '%r == %r' % (a, b)\n\ndef assert_raises_message(except_cls, msg, callable_, *args, **kwargs):\n    try:\n        callable_(*args, **kwargs)\n        assert False, 'Callable did not raise an exception'\n    except except_cls as e:\n        assert re.search(msg, str(e)), '%r !~ %s' % (msg, e)\n\ndef winsleep():\n    if sys.platform.startswith('win'):\n        time.sleep(0.001)"
  },
  "call_tree": {
    "tests/test_utils.py:UtilsTest:test_coerce_string_conf": {
      "dogpile/util/langhelpers.py:coerce_string_conf": {},
      "dogpile/testing/assertions.py:eq_": {}
    }
  }
}