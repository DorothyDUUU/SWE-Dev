{
  "dir_path": "/app/advertools",
  "package_name": "advertools",
  "sample_name": "advertools-test_crawl_or_not",
  "src_dir": "advertools/",
  "test_dir": "tests/",
  "test_file": "tests/test_crawl_or_not.py",
  "test_code": "import pytest\n\nfrom advertools.spider import _crawl_or_not\n\nurl = \"https://example.com\"\n\n\n@pytest.mark.parametrize(\n    \"urlpath\", [\"\", \"?one=1\", \"/one/two/three\", \"/one/two?hello=yes&1=2\"]\n)\ndef test_no_conditions(urlpath):\n    result = _crawl_or_not(url + urlpath)\n    assert result\n\n\ndef test_exclude_url_params_true():\n    result = _crawl_or_not(url + \"?1=1\", exclude_url_params=True)\n    assert not result\n\n\ndef test_reject_right_param():\n    result = _crawl_or_not(url + \"?one=1\", exclude_url_params=[\"one\", \"two\"])\n    assert not result\n\n\ndef test_dont_reject_param():\n    result = _crawl_or_not(url + \"?hello=1\", exclude_url_params=[\"one\", \"two\"])\n    assert result\n\n\ndef test_include_right_param():\n    result1 = _crawl_or_not(url + \"?one=1&two=2\", include_url_params=[\"one\"])\n    result2 = _crawl_or_not(url + \"?one=1&two=2\", include_url_params=[\"one\", \"two\"])\n    assert result1 and result2\n\n\ndef test_include_and_exclude():\n    result = _crawl_or_not(\n        url + \"?one=1&two=2&three=3\",\n        exclude_url_params=[\"hello\"],\n        include_url_params=[\"one\", \"four\"],\n    )\n    assert result\n\n\ndef test_exclude_simple_regex():\n    result = _crawl_or_not(url, exclude_url_regex=\"example\")\n    assert not result\n\n\ndef test_exclude_regex():\n    result = _crawl_or_not(url, exclude_url_regex=\"https:.*ple\")\n    assert not result\n\n\ndef test_include_simple_regex():\n    result = _crawl_or_not(url, include_url_regex=\"example\")\n    assert result\n\n\ndef test_include_regex():\n    result = _crawl_or_not(url, include_url_regex=\"https:.*ple\")\n    assert result\n\n\ndef test_multi_condition():\n    result = _crawl_or_not(url, exclude_url_params=True, include_url_regex=\"example\")\n    assert result\n",
  "GT_file_code": {
    "advertools/spider.py": "\"\"\"\n.. _crawl:\n\n\ud83d\udd77 Python SEO Crawler / Spider\n==============================\n\nA customizable crawler to analyze SEO and content of pages and websites.\n\nThis is provided by the :func:`crawl` function which is customized for SEO and\ncontent analysis usage, and is highly configurable. The crawler uses\n`Scrapy <https://scrapy.org/>`_ so you get all the power that it provides in\nterms of performance, speed, as well as flexibility and customization.\n\nThere are two main approaches to crawl:\n\n1. **Discovery (spider mode):** You know the website to crawl, so you provide a\n   ``url_list`` (one or more URLs), and you want the crawler to go through the whole\n   website(s) by following all available links.\n\n2. **Pre-determined (list mode):** You have a known set of URLs that you\n   want to crawl and analyze, without following links or discovering new URLs.\n\nDiscovery Crawling Approach\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe simplest way to use the function is to provide a list of one or more URLs\nand the crawler will go through all of the reachable pages.\n\n.. code-block:: python\n\n   >>> import advertools as adv\n   >>> adv.crawl('https://example.com', 'my_output_file.jl', follow_links=True)\n\nThat's it! To open the file:\n\n.. code-block:: python\n\n   >>> import pandas as pd\n   >>> crawl_df = pd.read_json('my_output_file.jl', lines=True)\n\n\nWhat this does:\n\n* Check the site's robots.txt file and get the crawl rules, which means that\n  your crawl will be affected by these rules and the user agent you are using.\n  Check the details below on how to change settings and user agents to control\n  this.\n* Starting with the provided URL(s) go through all links and parse pages.\n* For each URL extract the most important SEO elements.\n* Save them to ``my_output_file.jl``.\n* The column headers of the output file (once you import it as a DataFrame)\n  would be the names of the elements (title, h1, h2, etc.).\n\nJsonlines is the supported output format because of its flexibility in allowing\ndifferent values for different scraped pages, and appending indepentent items\nto the output files.\n\n.. note::\n\n    When the crawler parses pages it saves the data to the specified file by\n    appending, and not overwriting. Otherwise it would have to store all the\n    data in memory, which might crash your computer. A good practice is to have\n    a separate ``output_file`` for every crawl with a descriptive name\n    `sitename_crawl_YYYY_MM_DD.jl` for example. If you use the same file you\n    will probably get duplicate data in the same file.\n\nExtracted On-Page SEO Elements\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nThe names of these elements become the headers (column names) of the\n``output_file``.\n\n================= =============================================================\nElement           Remarks\n================= =============================================================\nurl               The response URL that was actually crawled. This might be different from the rquested URL in case of a redirect for example. Please check the ``redirect_*`` columns for more information.\ntitle             The <title> tag(s)\nviewport          The `viewport` meta tag if available\ncharset           The `charset` meta tag if available\nmeta_desc         Meta description\ncanonical         The canonical tag if available\nalt_href          The `href` attribute of rel=alternate tags\nalt_hreflang      The language codes of the alternate links\nog:*              Open Graph data\ntwitter:*         Twitter card data\njsonld_*          JSON-LD data if available. In case multiple snippets occur,\n                  the respective column names will include a number to\n                  distinguish them, `jsonld_1_{item_a}, jsonld_1_{item_b}`,\n                  etc. Note that the first snippet will not contain a number,\n                  so the numbering starts with \"1\", starting from the second\n                  snippet. The same applies to OG and Twitter cards.\nh1...h6           `<h1>` through `<h6>` tag(s), whichever is available\nlinks_url         The URLs of the links on the page\nlinks_text        The link text (anchor text)\nlinks_nofollow    Boolean, whether or not the link is a nofllow link. Note that\n                  this only tells if the link itself contains a rel=\"nofollow\"\n                  attribute. The page might indicate \"nofollow\" using meta\n                  robots or X-Robots-Tag, which you have to check separately.\nnav_links_text    The anchor text of all links in the `<nav>` tag if\n                  available\nnav_links_url     The links in the `<nav>` tag if available\nheader_links_text The anchor text of all links in the `<header>` tag if\n                  available\nheader_links_url  The links in the `<header>` tag if available\nfooter_links_text The anchor text of all links in the `<footer>` tag if\n                  available\nfooter_links_url  The links in the `<footer>` tag if available\nbody_text         The text in the <p>, <span>, and <li> tags within <body>\nsize              The page size in bytes\ndownload_latency  The amount of time it took to get the page HTML, in seconds.\ndownload_timout   The amount of time (in secs) that the downloader will wait\n                  before timing out. Defaults to 180.\nredirect_times    The number of times the pages was redirected if available\nredirect_ttl      The default maximum number of redirects the crawler allows\nredirect_urls     The chain of URLs from the requested URL to the one actually\n                  fetched\nredirect_reasons  The type of redirection(s) 301, 302, etc.\ndepth             The depth of the current URL, relative to the first URLs\n                  where crawling started. The first pages to be crawled have a\n                  depth of zero, pages linked from there, a depth of one, etc.\nstatus            Response status code (200, 404, etc.)\nimg_*             All available ``<img>`` tag attributes. 'alt', 'crossorigin',\n                  'height', 'ismap', 'loading', 'longdesc', 'referrerpolicy',\n                  'sizes', 'src', 'srcset', 'usemap',  and 'width' (excluding\n                  global HTML attributes like ``style`` and ``draggable``)\nip_address        IP address\ncrawl_time        Date and time the page was crawled\nresp_headers_*    All available response headers (last modified, server, etc.)\nrequest_headers_* All available request headers (user-agent, encoding, etc.)\n================= =============================================================\n\n.. note::\n\n    All elements that may appear multiple times on a page (like heading tags,\n    or images, for example), will be joined with two \"@\" signs `@@`. For\n    example, **\"first H2 tag@@second H2 tag@@third tag\"** and so on.\n    Once you open the file, you simply have to split by `@@` to get the\n    elements as a list.\n\nHere is a sample file of a crawl of this site (output truncated for\nreadability):\n\n.. code-block:: python\n\n    >>> import pandas as pd\n    >>> site_crawl = pd.read_json('path/to/file.jl', lines=True)\n    >>> site_crawl.head()\n                                   url                           title                       meta_desc                              h1                              h2                              h3                        body_text  size  download_timeout              download_slot  download_latency  redirect_times  redirect_ttl                   redirect_urls redirect_reasons  depth  status                      links_href                      links_text                         img_src                         img_alt    ip_address           crawl_time              resp_headers_date resp_headers_content-type     resp_headers_last-modified resp_headers_vary    resp_headers_x-ms-request-id resp_headers_x-ms-version resp_headers_x-ms-lease-status resp_headers_x-ms-blob-type resp_headers_access-control-allow-origin   resp_headers_x-served resp_headers_x-backend resp_headers_x-rtd-project resp_headers_x-rtd-version         resp_headers_x-rtd-path  resp_headers_x-rtd-domain resp_headers_x-rtd-version-method resp_headers_x-rtd-project-method resp_headers_strict-transport-security resp_headers_cf-cache-status  resp_headers_age           resp_headers_expires resp_headers_cache-control          resp_headers_expect-ct resp_headers_server   resp_headers_cf-ray      resp_headers_cf-request-id          request_headers_accept request_headers_accept-language      request_headers_user-agent request_headers_accept-encoding          request_headers_cookie\n    0   https://advertools.readthedocs            advertools \u2014  Python  Get productive as an online ma  advertools@@Indices and tables  Online marketing productivity                              NaN   Generate keywords for SEM camp   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN  https://advertools.readthedocs            [302]    NaN     NaN  #@@readme.html@@advertools.kw_  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:35  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  720a8581-501e-0043-01a2-2e77d2                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca7dbaa7e9e-BUD  02d86a3cea00007e9edb0cf2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    1   https://advertools.readthedocs            advertools \u2014  Python                             NaN                      advertools         Change Log - advertools  0.9.1 (2020-05-19)@@0.9.0 (202   Ability to specify robots.txt    NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  4f7bea3b-701e-0039-3f44-2f1d9f                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007h                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bcab7e9e-BUD  02d86a3e0e00007e9edb0d72000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    2   https://advertools.readthedocs            advertools \u2014  Python  Get productive as an online ma  advertools@@Indices and tables  Online marketing productivity                              NaN   Generate keywords for SEM camp   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  #@@readme.html@@advertools.kw_  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  98b729fa-e01e-00bf-24c3-2e494d                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bf26d423-BUD  02d86a3e150000d423322742000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    3   https://advertools.readthedocs    advertools package \u2014  Python                             NaN              advertools package     Submodules@@Module contents                             NaN   Top-level package for advertoo   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:25 GMT   Accept-Encoding  7a28ef3b-801e-00c2-24c3-2ed585                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web000079                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bddb7ec2-BUD  02d86a3e1300007ec2a808a2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    4   https://advertools.readthedocs   Python Module Index \u2014  Python                             NaN             Python Module Index                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@               _static/minus.png                               -  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  75911c9e-201e-00e6-34c3-2e4ccb                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007g                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9b91fd437-BUD  02d86a3e140000d437b81532000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    66  https://advertools.readthedocs  advertools.url_builders \u2014  Pyt                             NaN  Source code for advertools.url                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:38 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  d99f2368-c01e-006f-18c3-2ef5ef                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007a                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:38 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbbb8afd437-BUD  02d86a494f0000d437b828b2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    67  https://advertools.readthedocs  advertools.kw_generate \u2014  Pyth                             NaN  Source code for advertools.kw_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  85855c48-c01e-00ce-13c3-2e3b74                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007g                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd980bd423-BUD  02d86a4a7f0000d423323b42000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    68  https://advertools.readthedocs  advertools.ad_from_string \u2014  P                             NaN  Source code for advertools.ad_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  b0aef497-801e-004a-1647-2f6d5c                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007k                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd980cd423-BUD  02d86a4a7f0000d423209db2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    69  https://advertools.readthedocs  advertools.ad_create \u2014  Python                             NaN  Source code for advertools.ad_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  9dfdd38a-101e-00a1-7ec3-2e93a0                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd99847ec2-BUD  02d86a4a7f00007ec2a811f2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    70  https://advertools.readthedocs      advertools.emoji \u2014  Python                             NaN  Source code for advertools.emo                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:40  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  2ad504a1-101e-000b-03c3-2e454f                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web000079                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd9fb97e9e-BUD  02d86a4a7f00007e9edb13a2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n\nPre-Determined Crawling Approach (List Mode)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSometimes you might have a fixed set of URLs for which you want to scrape and\nanalyze SEO or content performance. Some ideas:\n\nSERP Data\n---------\nLet's say you just ran :ref:`serp_goog <serp>` and got a bunch of top-ranking\npages that you would like to analyze, and see how that relates to their SERP\nranking.\n\nYou simply provide the ``url_list`` parameter and again specify the\n``output_file``. This will only crawl the specified URLs, and will not follow\nany links.\n\nNow you have the SERP DataFrame, as well as the crawl output file. All you have\nto do is to merge them by the URL columns, and end up with a richer dataset\n\nNews Articles\n-------------\nYou want to follow the latest news of a certain publication, and you extract\ntheir latest news URLs from their news sitemap using\n:ref:`sitemap_to_df <sitemaps>` . You provide those URLs and crawl them only.\n\nGoogle Analytics / Google Search Console\n----------------------------------------\nSince they provide reports for URLs, you can also combine them with the ones\ncrawled and end up with a better perspective. You might be interested in\nknowing more about high bounce-rate pages, pages that convert well, pages that\nget less traffic than you think they should and so on. You can simply export\nthose URLs and crawl them.\n\nAny tool that has data about a set of URLs can be used.\n\nAgain running the function is as simple as providing a list of URLs, as well as\na filepath where you want the result saved.\n\n.. code-block:: python\n\n    >>> adv.crawl(url_list, 'output_file.jl', follow_links=False)\n\nThe difference between the two approaches, is the simple parameter\n``follow_links``. If you keep it as ``False`` (the default), the crawler\nwill only go through the provided URLs. Otherwise, it will discover pages by\nfollowing links on pages that it crawls. So how do you make sure that the\ncrawler doesn't try to crawl the whole web when ``follow_links`` is `True`?\nThe ``allowed_domains`` parameter gives you the ability to control this,\nalthough it is an optional parameter. If you don't specify it, then it will\ndefault to only the domains in the ``url_list`` and their sub-domains if any.\nIt's important to note that you have to set this parameter if you want to only\ncrawl certain sub-domains.\n\nCustom Extraction with CSS and XPath Selectors\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe above approaches are generic, and are useful for exploratory SEO audits\nand the output is helpful for most cases.\n\nBut what if you want to extract special elements that are not included in the\ndefault output? This is extremely important, as there are key elements on pages\nthat you need to additionally extract and analyze. Some examples might be tags,\nprices, social media shares, product price or availability, comments, and\npretty much any element on a page that might be of interest to you.\n\nFor this you can use two special parameters for CSS and/or XPath selectors. You\nsimply provide a dictionary `{'name_1': 'selector_1', 'name_2': 'selector_2'}`\nwhere the keys become the column names, and the values (selectors) will be\nused to extract the required elements.\n\nI mostly rely on `SlectorGadget <https://selectorgadget.com/>`_ which is a\nreally great tool for getting the CSS/XPath selecotrs of required elements.\nIn some pages it can get really tricky to figure that out. Other resources for\nlearning more about selectors:\n\n* `Scrapy's documentaion for selectors <https://docs.scrapy.org/en/latest/topics/selectors.html>`_\n* `CSS Selector Reference on W3C <https://www.w3schools.com/cssref/css_selectors.asp>`_\n* `XPath tutorial on W3C <https://www.w3schools.com/xml/xpath_intro.asp>`_\n\nOnce you have determined the elements that you want to extract and figured out\nwhat their names are going to be, you simply pass them as arguments to\n``css_selectors`` and/or ``xpath_selectors`` as dictionaries, as decribed\nabove.\n\nLet's say you want to extract the links in the sidebar of this page. By default\nyou would get all the links from the page, but you want to put those in the\nsidebar in a separate column. It seems that the CSS selector for them is\n`.toctree-l1 .internal`, and the XPath equivalent is\n`//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]`.\nNote that this selects the *element* (the whole link object), which is not\ntypically what you might be interested in.\n\nSo with CSS you need to append `::text` or `::attr(href)` if you want the text\nof the links or the `href` attribute respectively. Similarly with XPath, you\nwill need to append `/text()` or `/@href` to the selector to get the same.\n\n>>> adv.crawl(\n...     \"https://advertools.readthedocs.io/en/master/advertools.spider.html\",\n...     \"output_file.jl\",\n...     css_selectors={\n...         \"sidebar_links\": \".toctree-l1 .internal::text\",\n...         \"sidebar_links_url\": \".toctree-l1 .internal::attr(href)\",\n...     },\n... )\n\nOr, instead of ``css_selectors`` you can add a similar dictionary for the\n``xpath_selectors`` argument:\n\n>>> adv.crawl(\n...     \"https://advertools.readthedocs.io/en/master/advertools.spider.html\",\n...     \"output_file.jl\",\n...     xpath_selectors={\n...         \"sidebar_links\": '//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]/text()',\n...         \"sidebar_links_url\": '//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]/@href',\n...     },\n... )\n\nCustomizing the Crawling Behavior while Following Links\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you set ``follow_links=True`` you might want to restrict this option for a\nmore customized crawl. This means you can decide whether to include or exclude\ncertain links based on certain conditions based on URL parameters and/or URL\nregex patterns.\n\nURL Query Parameters\n--------------------\n\nTwo options are available for this:\n\n1. ``exclude_url_params``: By providing a list of URL parameters, any link that\ncontains any of the parameters will not be followed. For example if you set\nthis option to ['price', 'country'], and the page currently being crawled\ncontains three links:\n\n  * **/shoes/model_a?price=10&country=us**: Contains both parameters, will not be followed.\n  * **/shoes/model_a?price=10**: Contains one of the parameters, will not be followed.\n  * **/shoes/model_b?color=black**: Contains \"color\" which was not listed, will be followed\n\nTo make this efficient, and in case you want to skip all links that contain any\nparameter, you can set this option to ``True``, and any link that contains any\nURL parameter will not be followed ``exclude_url_params=True``\n\n\n2. ``include_url_params``: Similarly, you can choose the parameters that links\nshould contain in order for them to be followed. If a link contains any of the\nlisted parameters, that link will be followed. Even though this option is\nstraightforward, it might give you unexpected results. If you set the\nparameters to include as ['price'] for example, and you start crawling from a\npage that doesn't have any link containing that parameter, crawling will stop.\nYet, the website might have many links with that parameter. Please keep this in\nmind, and remember that reasoning about the exclude option is easier than the\ninclude option for this reason/example.\n\nURL Regex Patterns\n------------------\n\nYou might want even more granular control over which links to follow, and might\nbe interested in other URL properties than their query parameters. You have two\nsimple options to include/exclude links based on whether they match a certain\nregex pattern.\n\n1. ``exclude_url_regex``: Enter a regex, and the links will be checked if they\nmatch it. If they do, they will not be followed, if not they will.\n\n2. ``include_url_regex``: This is similar but tells the crawler which links to\nfollow, based on whether or not they match the regex. This option also has the\nsame potentially tricky behavior like the ``include_url_params`` option.\n\nHere is a simple example showing how you might control following links using\nall four options:\n\n.. code-block::\n\n    import advertools as adv\n    adv.crawl('https://example.com', 'output_file.jl', follow_links=True,\n\n              # don't follow links containing any of these parameters:\n              exclude_url_params=['price', 'region'],\n              # follow links containing any of these parameters:\n              include_url_params=['source'],\n              # don't follow links that contain the pattern \"/fr/\" or \"/de/\":\n              exclude_url_regex='/fr/|/de/',\n              # follow links that contain the pattern \"/shop/\":\n              include_url_regex='/shop/'\n              )\n\nSpider Custom Settings and Additional Functionality\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn addition to what you can control regarding the items you can extract, you\ncan also customize the behaviour of the spider and set rules for crawling so\nyou can control it even further.\n\nThis is provided by the ``custom_settings`` parameter. It is optional, and\ntakes a dictionary of settings and their values. Scrapy provides a very large\nnumber of settings, and they are all available through this parameter\n(assuming some conditions for some of the settings).\n\nHere are some examples that you might find interesting:\n\n* `CONCURRENT_REQUESTS_PER_DOMAIN` Defaults to 8, and controls the number of\n  simultaneous requests to be performed for each domain. You might want to\n  lower this if you don't want to put too much pressure on the website's\n  server, and you probably don't want to get blocked!\n* `DEFAULT_REQUEST_HEADERS` You can change this if you need to.\n* `DEPTH_LIMIT` How deep your crawl will be allowed. The default has no limit.\n* `DOWNLOAD_DELAY` Similar to the first option. Controls the amount of time in\n  seconds for the crawler to wait between consecutive pages of the same\n  website. It can also take fractions of a second (0.4, 0.75, etc.)\n* `LOG_FILE` If you want to save your crawl logs to a file, which is strongly\n  recommended, you can provide a path to it here.\n* `USER_AGENT` If you want to identify yourself differently while crawling.\n  This is affected by the robots.txt rules, so you would be potentially\n  allowed/disallowed from certain pages based on your user-agent.\n* `CLOSESPIDER_ERRORCOUNT`, `CLOSESPIDER_ITEMCOUNT`, `CLOSESPIDER_PAGECOUNT`,\n  `CLOSESPIDER_TIMEOUT` Stop crawling after that many errors, items, pages, or\n  seconds. These can be very useful to limit your crawling in certain cases.\n  I particularly like to use `CLOSESPIDER_PAGECOUNT` when exploring a new\n  website, and also to make sure that my selectors are working as expected. So\n  for your first few crawls you might set this to five hundred for example and\n  explore the crawled pages. Then when you are confident things are working\n  fine, you can remove this restriction. `CLOSESPIDER_ERRORCOUNT` can also be\n  very useful while exploring, just in case you get unexpected errors.\n\nThe next page contains a number of :ref:`strategies and recipes for crawling <crawl_strategies>`\nwith code examples and explanations.\n\n**Usage**\n\nA very simple dictionary to be added to your function call:\n\n>>> adv.crawl(\n...     \"http://exmaple.com\",\n...     \"outpuf_file.jl\",\n...     custom_settings={\n...         \"CLOSESPIDER_PAGECOUNT\": 100,\n...         \"CONCURRENT_REQUESTS_PER_DOMAIN\": 1,\n...         \"USER_AGENT\": \"custom-user-agent\",\n...     },\n... )\n\nPlease refer to the `spider settings documentation <https://docs.scrapy.org/en/latest/topics/settings.html>`_\nfor the full details.\n\n\"\"\"  # noqa: E501\n\nimport datetime\nimport json\nimport logging\nimport platform\nimport re\nimport runpy\nimport subprocess\nfrom urllib.parse import parse_qs, urlparse, urlsplit\n\nimport pandas as pd\nimport scrapy\nimport scrapy.logformatter as formatter\nfrom scrapy import Request\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import Spider\nfrom scrapy.utils.response import get_base_url\n\nimport advertools as adv\n\nif int(pd.__version__[0]) >= 1:\n    from pandas import json_normalize\nelse:\n    from pandas.io.json import json_normalize\n\nfrom advertools import __version__ as adv_version\n\nspider_path = adv.__path__[0] + \"/spider.py\"\n\nuser_agent = f\"advertools/{adv_version}\"\n\n# BODY_TEXT_SELECTOR = \"//body//span//text() | //body//p//text() | //body//li//text()\"\nBODY_TEXT_SELECTOR = \"//body//*[self::a or self::abbr or self::address or self::b or self::blockquote or self::cite or self::code or self::dd or self::del or self::div or self::dl or self::dt or self::em or self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6 or self::header or self::i or self::ins or self::kbd or self::li or self::mark or self::ol or self::p or self::pre or self::q or self::section or self::small or self::span or self::strong or self::sub or self::sup or self::time or self::u or self::ul][not(ancestor::area) and not(ancestor::aside) and not(ancestor::audio) and not(ancestor::button) and not(ancestor::caption) and not(ancestor::col) and not(ancestor::colgroup) and not(ancestor::datalist) and not(ancestor::details) and not(ancestor::embed) and not(ancestor::fieldset) and not(ancestor::footer) and not(ancestor::form) and not(ancestor::head) and not(ancestor::iframe) and not(ancestor::img) and not(ancestor::input) and not(ancestor::label) and not(ancestor::legend) and not(ancestor::link) and not(ancestor::map) and not(ancestor::meta) and not(ancestor::nav) and not(ancestor::noscript) and not(ancestor::object) and not(ancestor::optgroup) and not(ancestor::option) and not(ancestor::output) and not(ancestor::param) and not(ancestor::picture) and not(ancestor::script) and not(ancestor::select) and not(ancestor::source) and not(ancestor::style) and not(ancestor::svg) and not(ancestor::table) and not(ancestor::tbody) and not(ancestor::td) and not(ancestor::textarea) and not(ancestor::tfoot) and not(ancestor::th) and not(ancestor::thead) and not(ancestor::title) and not(ancestor::tr) and not(ancestor::track) and not(ancestor::video)]/text()\"  # noqa: E501\n\n_IMG_ATTRS = {\n    \"alt\",\n    \"crossorigin\",\n    \"decoding\",\n    \"fetchpriority\",\n    \"height\",\n    \"ismap\",\n    \"loading\",\n    \"referrerpolicy\",\n    \"sizes\",\n    \"src\",\n    \"srcset\",\n    \"usemap\",\n    \"width\",\n    # Depracated tags, also included for completeness and QA:\n    \"align\",\n    \"border\",\n    \"hspace\",\n    \"longdesc\",\n    \"name\",\n    \"vspace\",\n}\n\n\ndef _crawl_or_not(\n    url,\n    exclude_url_params=None,\n    include_url_params=None,\n    exclude_url_regex=None,\n    include_url_regex=None,\n):\n    qs = parse_qs(urlsplit(url).query)\n    supplied_conditions = []\n    if exclude_url_params is not None:\n        if exclude_url_params is True and qs:\n            return False\n        if exclude_url_params is True and not qs:\n            pass\n        else:\n            exclude_params_in_url = not bool(set(exclude_url_params).intersection(qs))\n            supplied_conditions.append(exclude_params_in_url)\n\n    if include_url_params is not None:\n        include_params_in_url = bool(set(include_url_params).intersection(qs))\n        supplied_conditions.append(include_params_in_url)\n\n    if exclude_url_regex is not None:\n        exclude_pattern_matched = not bool(re.findall(exclude_url_regex, url))\n        supplied_conditions.append(exclude_pattern_matched)\n\n    if include_url_regex is not None:\n        include_pattern_matched = bool(re.findall(include_url_regex, url))\n        supplied_conditions.append(include_pattern_matched)\n    return all(supplied_conditions)\n\n\ndef _extract_images(response):\n    page_has_images = response.xpath(\"//img\")\n    if page_has_images:\n        img_df = pd.DataFrame([x.attrib for x in response.xpath(\"//img\")])\n        if \"src\" in img_df:\n            img_df[\"src\"] = [\n                response.urljoin(url) if isinstance(url, str) else url\n                for url in img_df[\"src\"]\n            ]\n        img_df = img_df.apply(lambda col: col.fillna(\"\").str.cat(sep=\"@@\")).to_frame().T\n        img_df = img_df[img_df.columns.intersection(_IMG_ATTRS)]\n        img_df = img_df.add_prefix(\"img_\")\n        d = img_df.to_dict(\"records\")[0]\n        return d\n    return {}\n\n\ndef get_max_cmd_len():\n    system = platform.system()\n    cmd_dict = {\"Windows\": 7000, \"Linux\": 100000, \"Darwin\": 100000}\n    if system in cmd_dict:\n        return cmd_dict[system]\n    return 6000\n\n\nMAX_CMD_LENGTH = get_max_cmd_len()\n\nformatter.SCRAPEDMSG = \"Scraped from %(src)s\"\nformatter.DROPPEDMSG = \"Dropped: %(exception)s\"\nformatter.DOWNLOADERRORMSG_LONG = \"Error downloading %(request)s\"\n\n\nclass MyLinkExtractor(LinkExtractor):\n    def extract_links(self, response):\n        base_url = get_base_url(response)\n        if self.restrict_xpaths:\n            docs = [\n                subdoc for x in self.restrict_xpaths for subdoc in response.xpath(x)\n            ]\n        else:\n            docs = [response.selector]\n        all_links = []\n        for doc in docs:\n            links = self._extract_links(doc, response.url, response.encoding, base_url)\n            all_links.extend(self._process_links(links))\n        return all_links\n\n\nle = MyLinkExtractor(unique=False)\nle_nav = MyLinkExtractor(unique=False, restrict_xpaths=\"//nav\")\nle_header = MyLinkExtractor(unique=False, restrict_xpaths=\"//header\")\nle_footer = MyLinkExtractor(unique=False, restrict_xpaths=\"//footer\")\n\ncrawl_headers = {\n    \"url\",\n    \"title\",\n    \"meta_desc\",\n    \"viewport\",\n    \"charset\",\n    \"alt_href\",\n    \"alt_hreflang\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"canonical\",\n    \"body_text\",\n    \"size\",\n    \"download_timeout\",\n    \"download_slot\",\n    \"download_latency\",\n    \"redirect_times\",\n    \"redirect_ttl\",\n    \"redirect_urls\",\n    \"redirect_reasons\",\n    \"depth\",\n    \"status\",\n    \"links_url\",\n    \"links_text\",\n    \"links_nofollow\",\n    \"img_src\",\n    \"img_alt\",\n    \"ip_address\",\n    \"crawl_time\",\n    \"blocked_by_robotstxt\",\n    \"jsonld_errors\",\n    \"request_headers_accept\",\n    \"request_headers_accept-language\",\n    \"request_headers_user-agent\",\n    \"request_headers_accept-encoding\",\n    \"request_headers_cookie\",\n}\n\n\ndef _split_long_urllist(url_list, max_len=MAX_CMD_LENGTH):\n    \"\"\"Split url_list if their total length is greater than MAX_CMD_LENGTH.\"\"\"\n    split_list = [[]]\n\n    for u in url_list:\n        temp_len = sum(len(temp_u) for temp_u in split_list[-1])\n        if (temp_len < max_len) and (temp_len + len(u) < max_len):\n            split_list[-1].append(u)\n        else:\n            split_list.append([u])\n    return split_list\n\n\ndef _numbered_duplicates(items):\n    \"\"\"Append a number to all duplicated items starting at 1.\n\n    ['og:site', 'og:image', 'og:image', 'og:type', 'og:image']\n    becomes:\n    ['og:site', 'og:image_1', 'og:image_2', 'og:type', 'og:image_3']\n    \"\"\"\n    item_count = dict.fromkeys(items, 0)\n    numbered_items = []\n    for item in items:\n        numbered_items.append(item + \"_\" + str(item_count[item]))\n        item_count[item] += 1\n    for i, num_item in enumerate(numbered_items):\n        split_number = num_item.rsplit(\"_\", maxsplit=1)\n        if split_number[1] == \"0\":\n            numbered_items[i] = split_number[0]\n    return numbered_items\n\n\ndef _json_to_dict(jsonobj, i=None):\n    try:\n        df = json_normalize(jsonobj)\n        if i:\n            df = df.add_prefix(\"jsonld_{}_\".format(i))\n        else:\n            df = df.add_prefix(\"jsonld_\")\n        return dict(zip(df.columns, df.values[0]))\n    except Exception as e:\n        logger = logging.getLogger(__name__)\n        logger.error(msg=str(e))\n        return {}\n\n\ntags_xpaths = {\n    \"title\": \"//title/text()\",\n    \"meta_desc\": '//meta[@name=\"description\"]/@content',\n    \"viewport\": '//meta[@name=\"viewport\"]/@content',\n    \"charset\": \"//meta[@charset]/@charset\",\n    \"h1\": \"//h1\",\n    \"h2\": \"//h2\",\n    \"h3\": \"//h3\",\n    \"h4\": \"//h4\",\n    \"h5\": \"//h5\",\n    \"h6\": \"//h6\",\n    \"canonical\": '//link[@rel=\"canonical\"]/@href',\n    \"alt_href\": '//link[@rel=\"alternate\"]/@href',\n    \"alt_hreflang\": '//link[@rel=\"alternate\"]/@hreflang',\n}\n\n\ndef _extract_content(resp, **tags_xpaths):\n    d = {}\n    for tag, xpath in tags_xpaths.items():\n        if not tag.startswith(\"h\"):\n            value = \"@@\".join(resp.xpath(xpath).getall())\n            if value:\n                d.update({tag: value})\n        else:\n            value = \"@@\".join([h.root.text_content() for h in resp.xpath(xpath)])\n            if value:\n                d.update({tag: value})\n    return d\n\n\nclass SEOSitemapSpider(Spider):\n    name = \"seo_spider\"\n    follow_links = False\n    skip_url_params = False\n    css_selectors = {}\n    xpath_selectors = {}\n    custom_headers = {}\n    custom_settings = {\n        \"USER_AGENT\": user_agent,\n        \"ROBOTSTXT_OBEY\": True,\n        \"HTTPERROR_ALLOW_ALL\": True,\n    }\n\n    def __init__(\n        self,\n        url_list,\n        follow_links=False,\n        allowed_domains=None,\n        exclude_url_params=None,\n        include_url_params=None,\n        exclude_url_regex=None,\n        include_url_regex=None,\n        css_selectors=None,\n        xpath_selectors=None,\n        meta=None,\n        *args,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.start_urls = json.loads(json.dumps(url_list.split(\",\")))\n        self.allowed_domains = json.loads(json.dumps(allowed_domains.split(\",\")))\n        self.follow_links = eval(json.loads(json.dumps(follow_links)))\n        self.exclude_url_params = eval(json.loads(json.dumps(exclude_url_params)))\n        self.include_url_params = eval(json.loads(json.dumps(include_url_params)))\n        self.exclude_url_regex = str(json.loads(json.dumps(exclude_url_regex)))\n        if self.exclude_url_regex == \"None\":\n            self.exclude_url_regex = None\n        self.include_url_regex = str(json.loads(json.dumps(include_url_regex)))\n        if self.include_url_regex == \"None\":\n            self.include_url_regex = None\n        self.css_selectors = eval(json.loads(json.dumps(css_selectors)))\n        self.xpath_selectors = eval(json.loads(json.dumps(xpath_selectors)))\n        self.meta = eval(json.loads(json.dumps(meta)))\n\n    def get_custom_headers(self):\n        if self.meta:\n            custom_headers = self.meta.get(\"custom_headers\") or {}\n            if isinstance(custom_headers, str):\n                module = runpy.run_path(custom_headers)\n                custom_headers = module[\"custom_headers\"]\n        else:\n            custom_headers = {}\n        self.custom_headers = custom_headers\n\n    def start_requests(self):\n        self.get_custom_headers()\n        for url in self.start_urls:\n            try:\n                yield Request(\n                    url,\n                    callback=self.parse,\n                    errback=self.errback,\n                    meta=self.meta,\n                    headers=self.custom_headers.get(url),\n                )\n            except Exception as e:\n                self.logger.error(repr(e))\n\n    def errback(self, failure):\n        if not failure.check(scrapy.exceptions.IgnoreRequest):\n            self.logger.error(repr(failure))\n            yield {\n                \"url\": failure.request.url,\n                \"crawl_time\": datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"errors\": repr(failure),\n            }\n\n    def parse(self, response):\n        links = le.extract_links(response)\n        nav_links = le_nav.extract_links(response)\n        header_links = le_header.extract_links(response)\n        footer_links = le_footer.extract_links(response)\n        images = _extract_images(response)\n\n        if links:\n            parsed_links = dict(\n                links_url=\"@@\".join(link.url for link in links),\n                links_text=\"@@\".join(link.text for link in links),\n                links_nofollow=\"@@\".join(str(link.nofollow) for link in links),\n            )\n        else:\n            parsed_links = {}\n        if nav_links:\n            parsed_nav_links = dict(\n                nav_links_url=\"@@\".join(link.url for link in nav_links),\n                nav_links_text=\"@@\".join(link.text for link in nav_links),\n                nav_links_nofollow=\"@@\".join(str(link.nofollow) for link in nav_links),\n            )\n        else:\n            parsed_nav_links = {}\n        if header_links:\n            parsed_header_links = dict(\n                header_links_url=\"@@\".join(link.url for link in header_links),\n                header_links_text=\"@@\".join(link.text for link in header_links),\n                header_links_nofollow=\"@@\".join(\n                    str(link.nofollow) for link in header_links\n                ),\n            )\n        else:\n            parsed_header_links = {}\n        if footer_links:\n            parsed_footer_links = dict(\n                footer_links_url=\"@@\".join(link.url for link in footer_links),\n                footer_links_text=\"@@\".join(link.text for link in footer_links),\n                footer_links_nofollow=\"@@\".join(\n                    str(link.nofollow) for link in footer_links\n                ),\n            )\n        else:\n            parsed_footer_links = {}\n        if self.css_selectors:\n            css_selectors = {\n                key: \"@@\".join(response.css(\"{}\".format(val)).getall())\n                for key, val in self.css_selectors.items()\n            }\n            css_selectors = {k: v for k, v in css_selectors.items() if v}\n        else:\n            css_selectors = {}\n\n        if self.xpath_selectors:\n            xpath_selectors = {\n                key: \"@@\".join(response.xpath(\"{}\".format(val)).getall())\n                for key, val in self.xpath_selectors.items()\n            }\n            xpath_selectors = {k: v for k, v in xpath_selectors.items() if v}\n        else:\n            xpath_selectors = {}\n        canonical = {\n            \"canonical\": \"@@\".join(\n                response.css('link[rel=\"canonical\"]::attr(href)').getall()\n            )\n        }\n        canonical = canonical if canonical.get(\"canonical\") else {}\n        alt_href = {\n            \"alt_href\": \"@@\".join(\n                response.css(\"link[rel=alternate]::attr(href)\").getall()\n            )\n        }\n        alt_href = alt_href if alt_href.get(\"alt_href\") else {}\n        alt_hreflang = {\n            \"alt_hreflang\": \"@@\".join(\n                response.css(\"link[rel=alternate]::attr(hreflang)\").getall()\n            )\n        }\n        alt_hreflang = alt_hreflang if alt_hreflang.get(\"alt_hreflang\") else {}\n        og_props = response.xpath(\n            '//meta[starts-with(@property, \"og:\")]/@property'\n        ).getall()\n        og_content = response.xpath(\n            '//meta[starts-with(@property, \"og:\")]/@content'\n        ).getall()\n        if og_props and og_content:\n            og_props = _numbered_duplicates(og_props)\n            open_graph = dict(zip(og_props, og_content))\n        else:\n            open_graph = {}\n        twtr_names = response.xpath(\n            '//meta[starts-with(@name, \"twitter:\")]/@name'\n        ).getall()\n        twtr_content = response.xpath(\n            '//meta[starts-with(@name, \"twitter:\")]/@content'\n        ).getall()\n        if twtr_names and twtr_content:\n            twtr_card = dict(zip(twtr_names, twtr_content))\n        else:\n            twtr_card = {}\n        try:\n            ld = [\n                json.loads(s.replace(\"\\r\", \"\").replace(\"\\n\", \" \"))\n                for s in response.css(\n                    'script[type=\"application/ld+json\"]::text'\n                ).getall()\n            ]\n            if not ld:\n                jsonld = {}\n            else:\n                if len(ld) == 1:\n                    if isinstance(ld, list):\n                        ld = ld[0]\n                    jsonld = _json_to_dict(ld)\n                else:\n                    ld_norm = [_json_to_dict(x, i) for i, x in enumerate(ld)]\n                    jsonld = {}\n                    for norm in ld_norm:\n                        jsonld.update(**norm)\n        except Exception as e:\n            jsonld = {\"jsonld_errors\": str(e)}\n            self.logger.exception(\n                \" \".join([str(e), str(response.status), response.url])\n            )\n        page_content = _extract_content(response, **tags_xpaths)\n        yield dict(\n            url=response.request.url,\n            **page_content,\n            **open_graph,\n            **twtr_card,\n            **jsonld,\n            body_text=\" \".join(response.xpath(BODY_TEXT_SELECTOR).extract()),\n            size=len(response.body),\n            **css_selectors,\n            **xpath_selectors,\n            **{\n                k: \"@@\".join(str(val) for val in v) if isinstance(v, list) else v\n                for k, v in response.meta.items()\n                if k != \"custom_headers\"\n            },\n            status=response.status,\n            **parsed_links,\n            **parsed_nav_links,\n            **parsed_header_links,\n            **parsed_footer_links,\n            **images,\n            ip_address=str(response.ip_address),\n            crawl_time=datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            **{\n                \"resp_headers_\" + k: v\n                for k, v in response.headers.to_unicode_dict().items()\n            },\n            **{\n                \"request_headers_\" + k: v\n                for k, v in response.request.headers.to_unicode_dict().items()\n            },\n        )\n        if self.follow_links:\n            next_pages = [link.url for link in links]\n            if next_pages:\n                for page in next_pages:\n                    cond = _crawl_or_not(\n                        page,\n                        exclude_url_params=self.exclude_url_params,\n                        include_url_params=self.include_url_params,\n                        exclude_url_regex=self.exclude_url_regex,\n                        include_url_regex=self.include_url_regex,\n                    )\n                    if cond:\n                        yield Request(\n                            page,\n                            callback=self.parse,\n                            errback=self.errback,\n                            meta=self.meta,\n                            headers=self.custom_headers.get(page),\n                        )\n\n\ndef crawl(\n    url_list,\n    output_file,\n    follow_links=False,\n    allowed_domains=None,\n    exclude_url_params=None,\n    include_url_params=None,\n    exclude_url_regex=None,\n    include_url_regex=None,\n    css_selectors=None,\n    xpath_selectors=None,\n    custom_settings=None,\n    meta=None,\n):\n    \"\"\"\n    Crawl a website or a list of URLs based on the supplied options.\n\n    Parameters\n    ----------\n    url_list : url, list\n      One or more URLs to crawl. If ``follow_links`` is True, the crawler will start\n      with these URLs and follow all links on pages recursively.\n    output_file : str\n      The path to the output of the crawl. Jsonlines only is supported to allow for\n      dynamic values. Make sure your file ends with \".jl\", e.g. `output_file.jl`.\n    follow_links : bool\n      Defaults to False. Whether or not to follow links on crawled pages.\n    allowed_domains : list\n      A list of the allowed domains to crawl. This ensures that the crawler does not\n      attempt to crawl the whole web. If not specified, it defaults to the domains of\n      the URLs provided in ``url_list`` and all their sub-domains. You can also specify\n      a list of sub-domains, if you want to only crawl those.\n    exclude_url_params : list, bool\n      A list of URL parameters to exclude while following links. If a link contains any\n      of those parameters, don't follow it. Setting it to ``True`` will exclude links\n      containing any parameter.\n    include_url_params : list\n      A list of URL parameters to include while following links. If a link contains any\n      of those parameters, follow it. Having the same parmeters to include and exclude\n      raises an error.\n    exclude_url_regex : str\n      A regular expression of a URL pattern to exclude while following links. If a link\n      matches the regex don't follow it.\n    include_url_regex : str\n      A regular expression of a URL pattern to include while following links. If a link\n      matches the regex follow it.\n    css_selectors : dict\n      A dictionary mapping names to CSS selectors. The names will become column headers,\n      and the selectors will be used to extract the required data/content.\n    xpath_selectors : dict\n      A dictionary mapping names to XPath selectors. The names will become column\n      headers, and the selectors will be used to extract the required data/content.\n    custom_settings : dict\n      A dictionary of optional custom settings that you might want to add to the\n      spider's functionality. There are over 170 settings for all kinds of options. For\n      details please refer to the `spider settings <https://docs.scrapy.org/en/latest/topics/settings.html>`_\n      documentation.\n    meta : dict\n      Additional data to pass to the crawler; add arbitrary metadata, set custom request\n      headers per URL, and/or enable some third party plugins.\n    Examples\n    --------\n    Crawl a website and let the crawler discover as many pages as available\n\n    >>> import advertools as adv\n    >>> adv.crawl(\"http://example.com\", \"output_file.jl\", follow_links=True)\n    >>> import pandas as pd\n    >>> crawl_df = pd.read_json(\"output_file.jl\", lines=True)\n\n    Crawl a known set of pages (on a single or multiple sites) without\n    following links (just crawl the specified pages) or \"list mode\":\n\n    >>> adv.crawl(\n    ...     [\n    ...         \"http://exmaple.com/product\",\n    ...         \"http://exmaple.com/product2\",\n    ...         \"https://anotherexample.com\",\n    ...         \"https://anotherexmaple.com/hello\",\n    ...     ],\n    ...     \"output_file.jl\",\n    ...     follow_links=False,\n    ... )\n\n    Crawl a website, and in addition to standard SEO elements, also get the\n    required CSS selectors.\n    Here we will get three additional columns `price`, `author`, and\n    `author_url`. Note that you need to specify if you want the text attribute\n    or the `href` attribute if you are working with links (and all other\n    selectors).\n\n    >>> adv.crawl(\n    ...     \"http://example.com\",\n    ...     \"output_file.jl\",\n    ...     css_selectors={\n    ...         \"price\": \".a-color-price::text\",\n    ...         \"author\": \".contributorNameID::text\",\n    ...         \"author_url\": \".contributorNameID::attr(href)\",\n    ...     },\n    ... )\n\n    Using the ``meta`` parameter:\n\n    **Adding custom meta data** for the crawler using the `meta` parameter for\n    tracking/context purposes. If you supply {\"purpose\": \"pre-launch test\"}, then you\n    will get a column called \"purpose\", and all its values will be \"pre-launch test\" in\n    the crawl DataFrame.\n\n    >>> adv.crawl(\n    ...     \"https://example.com\",\n    ...     \"output_file.jl\",\n    ...     meta={\"purpose\": \"pre-launch test\"},\n    ... )\n\n    Or maybe mention which device(s) you crawled with, which is much easier than reading\n    the user-agent string:\n\n    >>> adv.crawl(\n    ...     \"https://example.com\",\n    ...     \"output.jsonl\",\n    ...     custom_settings={\n    ...         \"USER_AGENT\": \"Mozilla/5.0 (iPhone; CPUiPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1\"\n    ...     },\n    ...     meta={\"device\": \"Apple iPhone 12 Pro (Safari)\"},\n    ... )\n\n    Of course you can combine any such meta data however way you want:\n\n    >>> {\"device\": \"iphone\", \"purpose\": \"initial audit\", \"crawl_country\": \"us\", ...}\n\n    **Custom request headers**: Supply custom request headers per URL with the special\n    key ``custom_headers``. It's value is a dictionary where its keys are URLs, and\n    every URL's values is a dictionary, each with its own custom request headers.\n\n    >>> adv.crawl(\n    ...     URL_LIST,\n    ...     OUTPUT_FILE,\n    ...     meta={\n    ...         \"custom_headers\": {\n    ...             \"URL_A\": {\"HEADER_1\": \"VALUE_1\", \"HEADER_2\": \"VALUE_1\"},\n    ...             \"URL_B\": {\"HEADER_1\": \"VALUE_2\", \"HEADER_2\": \"VALUE_2\"},\n    ...             \"URL_C\": {\"HEADER_1\": \"VALUE_3\"},\n    ...         }\n    ...     },\n    ... )\n\n    OR:\n\n    >>> meta = {\n    ...     \"custom_headers\": {\n    ...         \"https://example.com/A\": {\"If-None-Match\": \"Etag A\"},\n    ...         \"https://example.com/B\": {\n    ...             \"If-None-Match\": \"Etag B\",\n    ...             \"User-Agent\": \"custom UA\",\n    ...         },\n    ...         \"https://example.com/C\": {\n    ...             \"If-None-Match\": \"Etag C\",\n    ...             \"If-Modified-Since\": \"Sat, 17 Oct 2024 16:24:00 GMT\",\n    ...         },\n    ...     }\n    ... }\n\n    **Long lists of requests headers:** In some cases you might have a very long list\n    and that might raise an `Argument list too long` error. In this case you can provide\n    the path of a Python script that contains a dictionary for the headers. Keep in\n    mind:\n\n    - The dictionary has to be named ``custom_headers`` with the same structure mentioned above\n    - The file has to be a Python script, having the extension \".py\"\n    - The script can generate the dictionary programmatically to make it easier to\n      incorporate in various workflows\n    - The path to the file can be absolute or relative to where the command is\n      run from.\n\n      >>> meta = {\"custom_headers\": \"my_custom_headers.py\"}\n\n      OR\n\n      >>> meta = {\"custom_headers\": \"/full/path/to/my_custom_headers.py\"}\n\n    **Use with third party plugins** like scrapy playwright. To enable it, set\n    ``{\"playwright\": True}`` together with other settings.\n    \"\"\"\n    if isinstance(url_list, str):\n        url_list = [url_list]\n    if isinstance(allowed_domains, str):\n        allowed_domains = [allowed_domains]\n    if output_file.rsplit(\".\")[-1] not in [\"jl\", \"jsonl\"]:\n        raise ValueError(\n            \"Please make sure your output_file ends with '.jl' or '.jsonl'.\\n\"\n            \"For example:\\n\"\n            \"{}.jl\".format(output_file.rsplit(\".\", maxsplit=1)[0])\n        )\n    if (xpath_selectors is not None) and (css_selectors is not None):\n        css_xpath = set(xpath_selectors).intersection(css_selectors)\n        if css_xpath:\n            raise ValueError(\n                \"Please make sure you don't set common keys for\"\n                \"`css_selectors` and `xpath_selectors`.\\n\"\n                \"Duplicated keys: {}\".format(css_xpath)\n            )\n    for selector in [xpath_selectors, css_selectors]:\n        if selector is not None and set(selector).intersection(crawl_headers):\n            raise ValueError(\n                \"Please make sure you don't use names of default \"\n                \"headers. Avoid using any of these as keys: \\n\"\n                \"{}\".format(sorted(crawl_headers))\n            )\n    if allowed_domains is None:\n        allowed_domains = {urlparse(url).netloc for url in url_list}\n    if exclude_url_params is not None and include_url_params is not None:\n        if exclude_url_params is True:\n            raise ValueError(\n                \"Please make sure you don't exclude and include \"\n                \"parameters at the same time.\"\n            )\n        common_params = set(exclude_url_params).intersection(include_url_params)\n        if common_params:\n            raise ValueError(\n                f\"Please make sure you don't include and exclude \"\n                f\"the same parameters.\\n\"\n                f\"Common parameters entered: \"\n                f\"{', '.join(common_params)}\"\n            )\n    if include_url_regex is not None and exclude_url_regex is not None:\n        if include_url_regex == exclude_url_regex:\n            raise ValueError(\n                f\"Please make sure you don't include and exclude \"\n                f\"the same regex pattern.\\n\"\n                f\"You entered '{include_url_regex}'.\"\n            )\n\n    settings_list = []\n    if custom_settings is not None:\n        for key, val in custom_settings.items():\n            if isinstance(val, (dict, list, set, tuple)):\n                setting = \"=\".join([key, json.dumps(val)])\n            else:\n                setting = \"=\".join([key, str(val)])\n            settings_list.extend([\"-s\", setting])\n\n    command = [\n        \"scrapy\",\n        \"runspider\",\n        spider_path,\n        \"-a\",\n        \"url_list=\" + \",\".join(url_list),\n        \"-a\",\n        \"allowed_domains=\" + \",\".join(allowed_domains),\n        \"-a\",\n        \"follow_links=\" + str(follow_links),\n        \"-a\",\n        \"exclude_url_params=\" + str(exclude_url_params),\n        \"-a\",\n        \"include_url_params=\" + str(include_url_params),\n        \"-a\",\n        \"exclude_url_regex=\" + str(exclude_url_regex),\n        \"-a\",\n        \"include_url_regex=\" + str(include_url_regex),\n        \"-a\",\n        \"css_selectors=\" + str(css_selectors),\n        \"-a\",\n        \"xpath_selectors=\" + str(xpath_selectors),\n        \"-a\",\n        \"meta=\" + str(meta),\n        \"-o\",\n        output_file,\n    ] + settings_list\n    if len(\",\".join(url_list)) > MAX_CMD_LENGTH:\n        split_urls = _split_long_urllist(url_list)\n\n        for u_list in split_urls:\n            command[4] = \"url_list=\" + \",\".join(u_list)\n            subprocess.run(command)\n    else:\n        subprocess.run(command)\n"
  },
  "GT_src_dict": {
    "advertools/spider.py": {
      "_crawl_or_not": {
        "code": "def _crawl_or_not(url, exclude_url_params=None, include_url_params=None, exclude_url_regex=None, include_url_regex=None):\n    \"\"\"Determine whether a URL should be crawled based on specified conditions.\n\nThis function evaluates a URL against various inclusion and exclusion criteria for URL parameters and regex patterns. It is used within the crawling process to control whether specific links should be followed or ignored based on user-defined rules.\n\nParameters\n----------\nurl : str\n    The URL to evaluate.\nexclude_url_params : list, optional\n    A list of URL parameters to exclude from crawling. If set to True, any URL with parameters will not be crawled.\ninclude_url_params : list, optional\n    A list of URL parameters to include for crawling. URLs containing any of these parameters will be followed.\nexclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will not be crawled.\ninclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will be crawled.\n\nReturns\n-------\nbool\n    True if the URL meets all the specified criteria for crawling; False otherwise.\n\nNotes\n-----\nUtilizes the `parse_qs` function from the `urllib.parse` module to parse query parameters from the URL, and the `re` module for regex matching against the URL. The evaluation of conditions is accumulated in a list and only returns True if all conditions are satisfied.\"\"\"\n    qs = parse_qs(urlsplit(url).query)\n    supplied_conditions = []\n    if exclude_url_params is not None:\n        if exclude_url_params is True and qs:\n            return False\n        if exclude_url_params is True and (not qs):\n            pass\n        else:\n            exclude_params_in_url = not bool(set(exclude_url_params).intersection(qs))\n            supplied_conditions.append(exclude_params_in_url)\n    if include_url_params is not None:\n        include_params_in_url = bool(set(include_url_params).intersection(qs))\n        supplied_conditions.append(include_params_in_url)\n    if exclude_url_regex is not None:\n        exclude_pattern_matched = not bool(re.findall(exclude_url_regex, url))\n        supplied_conditions.append(exclude_pattern_matched)\n    if include_url_regex is not None:\n        include_pattern_matched = bool(re.findall(include_url_regex, url))\n        supplied_conditions.append(include_pattern_matched)\n    return all(supplied_conditions)",
        "docstring": "Determine whether a URL should be crawled based on specified conditions.\n\nThis function evaluates a URL against various inclusion and exclusion criteria for URL parameters and regex patterns. It is used within the crawling process to control whether specific links should be followed or ignored based on user-defined rules.\n\nParameters\n----------\nurl : str\n    The URL to evaluate.\nexclude_url_params : list, optional\n    A list of URL parameters to exclude from crawling. If set to True, any URL with parameters will not be crawled.\ninclude_url_params : list, optional\n    A list of URL parameters to include for crawling. URLs containing any of these parameters will be followed.\nexclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will not be crawled.\ninclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will be crawled.\n\nReturns\n-------\nbool\n    True if the URL meets all the specified criteria for crawling; False otherwise.\n\nNotes\n-----\nUtilizes the `parse_qs` function from the `urllib.parse` module to parse query parameters from the URL, and the `re` module for regex matching against the URL. The evaluation of conditions is accumulated in a list and only returns True if all conditions are satisfied.",
        "signature": "def _crawl_or_not(url, exclude_url_params=None, include_url_params=None, exclude_url_regex=None, include_url_regex=None):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "tests/test_crawl_or_not.py:test_no_conditions": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_exclude_url_params_true": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_reject_right_param": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_dont_reject_param": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_include_right_param": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_include_and_exclude": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_exclude_simple_regex": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_exclude_regex": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_include_simple_regex": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_include_regex": {
      "advertools/spider.py:_crawl_or_not": {}
    },
    "tests/test_crawl_or_not.py:test_multi_condition": {
      "advertools/spider.py:_crawl_or_not": {}
    }
  },
  "PRD": "# PROJECT NAME: advertools-test_crawl_or_not\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 advertools/\n    \u2514\u2500\u2500 spider.py\n        \u2514\u2500\u2500 _crawl_or_not\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for validating and controlling the inclusion or exclusion of URLs based on pre-defined conditions, making it a critical component for web crawling or URL filtering workflows. It allows users to specify parameters or patterns for inclusion and exclusion, using URL parameters, regex patterns, or a combination of both, ensuring precision in URL selection. This module enables users or developers to streamline web crawling processes by programmatically enforcing rules that eliminate unwanted URLs or prioritize specific ones, enhancing efficiency and reducing irrelevant data retrieval. By offering flexible configuration options, it addresses the need for customizable and scalable URL filtering in web scraping and data collection scenarios.\n\n## FILE 1: advertools/spider.py\n\n- FUNCTION NAME: _crawl_or_not\n  - SIGNATURE: def _crawl_or_not(url, exclude_url_params=None, include_url_params=None, exclude_url_regex=None, include_url_regex=None):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine whether a URL should be crawled based on specified conditions.\n\nThis function evaluates a URL against various inclusion and exclusion criteria for URL parameters and regex patterns. It is used within the crawling process to control whether specific links should be followed or ignored based on user-defined rules.\n\nParameters\n----------\nurl : str\n    The URL to evaluate.\nexclude_url_params : list, optional\n    A list of URL parameters to exclude from crawling. If set to True, any URL with parameters will not be crawled.\ninclude_url_params : list, optional\n    A list of URL parameters to include for crawling. URLs containing any of these parameters will be followed.\nexclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will not be crawled.\ninclude_url_regex : str, optional\n    A regular expression pattern. URLs matching this regex will be crawled.\n\nReturns\n-------\nbool\n    True if the URL meets all the specified criteria for crawling; False otherwise.\n\nNotes\n-----\nUtilizes the `parse_qs` function from the `urllib.parse` module to parse query parameters from the URL, and the `re` module for regex matching against the URL. The evaluation of conditions is accumulated in a list and only returns True if all conditions are satisfied.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "advertools/spider.py": "\"\"\"\n.. _crawl:\n\n\ud83d\udd77 Python SEO Crawler / Spider\n==============================\n\nA customizable crawler to analyze SEO and content of pages and websites.\n\nThis is provided by the :func:`crawl` function which is customized for SEO and\ncontent analysis usage, and is highly configurable. The crawler uses\n`Scrapy <https://scrapy.org/>`_ so you get all the power that it provides in\nterms of performance, speed, as well as flexibility and customization.\n\nThere are two main approaches to crawl:\n\n1. **Discovery (spider mode):** You know the website to crawl, so you provide a\n   ``url_list`` (one or more URLs), and you want the crawler to go through the whole\n   website(s) by following all available links.\n\n2. **Pre-determined (list mode):** You have a known set of URLs that you\n   want to crawl and analyze, without following links or discovering new URLs.\n\nDiscovery Crawling Approach\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe simplest way to use the function is to provide a list of one or more URLs\nand the crawler will go through all of the reachable pages.\n\n.. code-block:: python\n\n   >>> import advertools as adv\n   >>> adv.crawl('https://example.com', 'my_output_file.jl', follow_links=True)\n\nThat's it! To open the file:\n\n.. code-block:: python\n\n   >>> import pandas as pd\n   >>> crawl_df = pd.read_json('my_output_file.jl', lines=True)\n\n\nWhat this does:\n\n* Check the site's robots.txt file and get the crawl rules, which means that\n  your crawl will be affected by these rules and the user agent you are using.\n  Check the details below on how to change settings and user agents to control\n  this.\n* Starting with the provided URL(s) go through all links and parse pages.\n* For each URL extract the most important SEO elements.\n* Save them to ``my_output_file.jl``.\n* The column headers of the output file (once you import it as a DataFrame)\n  would be the names of the elements (title, h1, h2, etc.).\n\nJsonlines is the supported output format because of its flexibility in allowing\ndifferent values for different scraped pages, and appending indepentent items\nto the output files.\n\n.. note::\n\n    When the crawler parses pages it saves the data to the specified file by\n    appending, and not overwriting. Otherwise it would have to store all the\n    data in memory, which might crash your computer. A good practice is to have\n    a separate ``output_file`` for every crawl with a descriptive name\n    `sitename_crawl_YYYY_MM_DD.jl` for example. If you use the same file you\n    will probably get duplicate data in the same file.\n\nExtracted On-Page SEO Elements\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nThe names of these elements become the headers (column names) of the\n``output_file``.\n\n================= =============================================================\nElement           Remarks\n================= =============================================================\nurl               The response URL that was actually crawled. This might be different from the rquested URL in case of a redirect for example. Please check the ``redirect_*`` columns for more information.\ntitle             The <title> tag(s)\nviewport          The `viewport` meta tag if available\ncharset           The `charset` meta tag if available\nmeta_desc         Meta description\ncanonical         The canonical tag if available\nalt_href          The `href` attribute of rel=alternate tags\nalt_hreflang      The language codes of the alternate links\nog:*              Open Graph data\ntwitter:*         Twitter card data\njsonld_*          JSON-LD data if available. In case multiple snippets occur,\n                  the respective column names will include a number to\n                  distinguish them, `jsonld_1_{item_a}, jsonld_1_{item_b}`,\n                  etc. Note that the first snippet will not contain a number,\n                  so the numbering starts with \"1\", starting from the second\n                  snippet. The same applies to OG and Twitter cards.\nh1...h6           `<h1>` through `<h6>` tag(s), whichever is available\nlinks_url         The URLs of the links on the page\nlinks_text        The link text (anchor text)\nlinks_nofollow    Boolean, whether or not the link is a nofllow link. Note that\n                  this only tells if the link itself contains a rel=\"nofollow\"\n                  attribute. The page might indicate \"nofollow\" using meta\n                  robots or X-Robots-Tag, which you have to check separately.\nnav_links_text    The anchor text of all links in the `<nav>` tag if\n                  available\nnav_links_url     The links in the `<nav>` tag if available\nheader_links_text The anchor text of all links in the `<header>` tag if\n                  available\nheader_links_url  The links in the `<header>` tag if available\nfooter_links_text The anchor text of all links in the `<footer>` tag if\n                  available\nfooter_links_url  The links in the `<footer>` tag if available\nbody_text         The text in the <p>, <span>, and <li> tags within <body>\nsize              The page size in bytes\ndownload_latency  The amount of time it took to get the page HTML, in seconds.\ndownload_timout   The amount of time (in secs) that the downloader will wait\n                  before timing out. Defaults to 180.\nredirect_times    The number of times the pages was redirected if available\nredirect_ttl      The default maximum number of redirects the crawler allows\nredirect_urls     The chain of URLs from the requested URL to the one actually\n                  fetched\nredirect_reasons  The type of redirection(s) 301, 302, etc.\ndepth             The depth of the current URL, relative to the first URLs\n                  where crawling started. The first pages to be crawled have a\n                  depth of zero, pages linked from there, a depth of one, etc.\nstatus            Response status code (200, 404, etc.)\nimg_*             All available ``<img>`` tag attributes. 'alt', 'crossorigin',\n                  'height', 'ismap', 'loading', 'longdesc', 'referrerpolicy',\n                  'sizes', 'src', 'srcset', 'usemap',  and 'width' (excluding\n                  global HTML attributes like ``style`` and ``draggable``)\nip_address        IP address\ncrawl_time        Date and time the page was crawled\nresp_headers_*    All available response headers (last modified, server, etc.)\nrequest_headers_* All available request headers (user-agent, encoding, etc.)\n================= =============================================================\n\n.. note::\n\n    All elements that may appear multiple times on a page (like heading tags,\n    or images, for example), will be joined with two \"@\" signs `@@`. For\n    example, **\"first H2 tag@@second H2 tag@@third tag\"** and so on.\n    Once you open the file, you simply have to split by `@@` to get the\n    elements as a list.\n\nHere is a sample file of a crawl of this site (output truncated for\nreadability):\n\n.. code-block:: python\n\n    >>> import pandas as pd\n    >>> site_crawl = pd.read_json('path/to/file.jl', lines=True)\n    >>> site_crawl.head()\n                                   url                           title                       meta_desc                              h1                              h2                              h3                        body_text  size  download_timeout              download_slot  download_latency  redirect_times  redirect_ttl                   redirect_urls redirect_reasons  depth  status                      links_href                      links_text                         img_src                         img_alt    ip_address           crawl_time              resp_headers_date resp_headers_content-type     resp_headers_last-modified resp_headers_vary    resp_headers_x-ms-request-id resp_headers_x-ms-version resp_headers_x-ms-lease-status resp_headers_x-ms-blob-type resp_headers_access-control-allow-origin   resp_headers_x-served resp_headers_x-backend resp_headers_x-rtd-project resp_headers_x-rtd-version         resp_headers_x-rtd-path  resp_headers_x-rtd-domain resp_headers_x-rtd-version-method resp_headers_x-rtd-project-method resp_headers_strict-transport-security resp_headers_cf-cache-status  resp_headers_age           resp_headers_expires resp_headers_cache-control          resp_headers_expect-ct resp_headers_server   resp_headers_cf-ray      resp_headers_cf-request-id          request_headers_accept request_headers_accept-language      request_headers_user-agent request_headers_accept-encoding          request_headers_cookie\n    0   https://advertools.readthedocs            advertools \u2014  Python  Get productive as an online ma  advertools@@Indices and tables  Online marketing productivity                              NaN   Generate keywords for SEM camp   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN  https://advertools.readthedocs            [302]    NaN     NaN  #@@readme.html@@advertools.kw_  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:35  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  720a8581-501e-0043-01a2-2e77d2                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca7dbaa7e9e-BUD  02d86a3cea00007e9edb0cf2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    1   https://advertools.readthedocs            advertools \u2014  Python                             NaN                      advertools         Change Log - advertools  0.9.1 (2020-05-19)@@0.9.0 (202   Ability to specify robots.txt    NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  4f7bea3b-701e-0039-3f44-2f1d9f                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007h                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bcab7e9e-BUD  02d86a3e0e00007e9edb0d72000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    2   https://advertools.readthedocs            advertools \u2014  Python  Get productive as an online ma  advertools@@Indices and tables  Online marketing productivity                              NaN   Generate keywords for SEM camp   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  #@@readme.html@@advertools.kw_  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  98b729fa-e01e-00bf-24c3-2e494d                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bf26d423-BUD  02d86a3e150000d423322742000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    3   https://advertools.readthedocs    advertools package \u2014  Python                             NaN              advertools package     Submodules@@Module contents                             NaN   Top-level package for advertoo   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:25 GMT   Accept-Encoding  7a28ef3b-801e-00c2-24c3-2ed585                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web000079                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9bddb7ec2-BUD  02d86a3e1300007ec2a808a2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    4   https://advertools.readthedocs   Python Module Index \u2014  Python                             NaN             Python Module Index                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  index.html@@readme.html@@adver  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@               _static/minus.png                               -  104.17.32.82  2020-05-21 10:39:36  Thu, 21 May 2020 10:39:35 GMT                 text/html  Wed, 20 May 2020 12:26:23 GMT   Accept-Encoding  75911c9e-201e-00e6-34c3-2e4ccb                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007g                 advertools                     master  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:35 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596daca9b91fd437-BUD  02d86a3e140000d437b81532000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    66  https://advertools.readthedocs  advertools.url_builders \u2014  Pyt                             NaN  Source code for advertools.url                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:38 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  d99f2368-c01e-006f-18c3-2ef5ef                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007a                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:38 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbbb8afd437-BUD  02d86a494f0000d437b828b2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    67  https://advertools.readthedocs  advertools.kw_generate \u2014  Pyth                             NaN  Source code for advertools.kw_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  85855c48-c01e-00ce-13c3-2e3b74                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007g                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd980bd423-BUD  02d86a4a7f0000d423323b42000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    68  https://advertools.readthedocs  advertools.ad_from_string \u2014  P                             NaN  Source code for advertools.ad_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  b0aef497-801e-004a-1647-2f6d5c                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007k                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd980cd423-BUD  02d86a4a7f0000d423209db2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    69  https://advertools.readthedocs  advertools.ad_create \u2014  Python                             NaN  Source code for advertools.ad_                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:39  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  9dfdd38a-101e-00a1-7ec3-2e93a0                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web00007c                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd99847ec2-BUD  02d86a4a7f00007ec2a811f2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n    70  https://advertools.readthedocs      advertools.emoji \u2014  Python                             NaN  Source code for advertools.emo                             NaN                             NaN            \u00a9 Copyright 2020, Eli   NaN               NaN  advertools.readthedocs.io               NaN             NaN           NaN                             NaN              NaN    NaN     NaN  ../../index.html@@../../readme  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                             NaN                             NaN  104.17.32.82  2020-05-21 10:39:40  Thu, 21 May 2020 10:39:39 GMT                 text/html  Wed, 20 May 2020 12:26:36 GMT   Accept-Encoding  2ad504a1-101e-000b-03c3-2e454f                2009-09-19                       unlocked                   BlockBlob                                        *  Nginx-Proxito-Sendfile              web000079                 advertools                     latest  /proxito/media/html/advertools  advertools.readthedocs.io                              path                         subdomain         max-age=31536000; includeSubDo                          HIT               NaN  Thu, 21 May 2020 11:39:39 GMT       public, max-age=3600  max-age=604800, report-uri=\"ht          cloudflare  596dacbd9fb97e9e-BUD  02d86a4a7f00007e9edb13a2000000  text/html,application/xhtml+xm                              en  Mozilla/5.0 (Windows NT 10.0;                    gzip, deflate  __cfduid=d76b68d148ddec1efd004\n\nPre-Determined Crawling Approach (List Mode)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nSometimes you might have a fixed set of URLs for which you want to scrape and\nanalyze SEO or content performance. Some ideas:\n\nSERP Data\n---------\nLet's say you just ran :ref:`serp_goog <serp>` and got a bunch of top-ranking\npages that you would like to analyze, and see how that relates to their SERP\nranking.\n\nYou simply provide the ``url_list`` parameter and again specify the\n``output_file``. This will only crawl the specified URLs, and will not follow\nany links.\n\nNow you have the SERP DataFrame, as well as the crawl output file. All you have\nto do is to merge them by the URL columns, and end up with a richer dataset\n\nNews Articles\n-------------\nYou want to follow the latest news of a certain publication, and you extract\ntheir latest news URLs from their news sitemap using\n:ref:`sitemap_to_df <sitemaps>` . You provide those URLs and crawl them only.\n\nGoogle Analytics / Google Search Console\n----------------------------------------\nSince they provide reports for URLs, you can also combine them with the ones\ncrawled and end up with a better perspective. You might be interested in\nknowing more about high bounce-rate pages, pages that convert well, pages that\nget less traffic than you think they should and so on. You can simply export\nthose URLs and crawl them.\n\nAny tool that has data about a set of URLs can be used.\n\nAgain running the function is as simple as providing a list of URLs, as well as\na filepath where you want the result saved.\n\n.. code-block:: python\n\n    >>> adv.crawl(url_list, 'output_file.jl', follow_links=False)\n\nThe difference between the two approaches, is the simple parameter\n``follow_links``. If you keep it as ``False`` (the default), the crawler\nwill only go through the provided URLs. Otherwise, it will discover pages by\nfollowing links on pages that it crawls. So how do you make sure that the\ncrawler doesn't try to crawl the whole web when ``follow_links`` is `True`?\nThe ``allowed_domains`` parameter gives you the ability to control this,\nalthough it is an optional parameter. If you don't specify it, then it will\ndefault to only the domains in the ``url_list`` and their sub-domains if any.\nIt's important to note that you have to set this parameter if you want to only\ncrawl certain sub-domains.\n\nCustom Extraction with CSS and XPath Selectors\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe above approaches are generic, and are useful for exploratory SEO audits\nand the output is helpful for most cases.\n\nBut what if you want to extract special elements that are not included in the\ndefault output? This is extremely important, as there are key elements on pages\nthat you need to additionally extract and analyze. Some examples might be tags,\nprices, social media shares, product price or availability, comments, and\npretty much any element on a page that might be of interest to you.\n\nFor this you can use two special parameters for CSS and/or XPath selectors. You\nsimply provide a dictionary `{'name_1': 'selector_1', 'name_2': 'selector_2'}`\nwhere the keys become the column names, and the values (selectors) will be\nused to extract the required elements.\n\nI mostly rely on `SlectorGadget <https://selectorgadget.com/>`_ which is a\nreally great tool for getting the CSS/XPath selecotrs of required elements.\nIn some pages it can get really tricky to figure that out. Other resources for\nlearning more about selectors:\n\n* `Scrapy's documentaion for selectors <https://docs.scrapy.org/en/latest/topics/selectors.html>`_\n* `CSS Selector Reference on W3C <https://www.w3schools.com/cssref/css_selectors.asp>`_\n* `XPath tutorial on W3C <https://www.w3schools.com/xml/xpath_intro.asp>`_\n\nOnce you have determined the elements that you want to extract and figured out\nwhat their names are going to be, you simply pass them as arguments to\n``css_selectors`` and/or ``xpath_selectors`` as dictionaries, as decribed\nabove.\n\nLet's say you want to extract the links in the sidebar of this page. By default\nyou would get all the links from the page, but you want to put those in the\nsidebar in a separate column. It seems that the CSS selector for them is\n`.toctree-l1 .internal`, and the XPath equivalent is\n`//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]`.\nNote that this selects the *element* (the whole link object), which is not\ntypically what you might be interested in.\n\nSo with CSS you need to append `::text` or `::attr(href)` if you want the text\nof the links or the `href` attribute respectively. Similarly with XPath, you\nwill need to append `/text()` or `/@href` to the selector to get the same.\n\n>>> adv.crawl(\n...     \"https://advertools.readthedocs.io/en/master/advertools.spider.html\",\n...     \"output_file.jl\",\n...     css_selectors={\n...         \"sidebar_links\": \".toctree-l1 .internal::text\",\n...         \"sidebar_links_url\": \".toctree-l1 .internal::attr(href)\",\n...     },\n... )\n\nOr, instead of ``css_selectors`` you can add a similar dictionary for the\n``xpath_selectors`` argument:\n\n>>> adv.crawl(\n...     \"https://advertools.readthedocs.io/en/master/advertools.spider.html\",\n...     \"output_file.jl\",\n...     xpath_selectors={\n...         \"sidebar_links\": '//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]/text()',\n...         \"sidebar_links_url\": '//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"toctree-l1\", \" \" ))]//*[contains(concat( \" \", @class, \" \" ), concat( \" \", \"internal\", \" \" ))]/@href',\n...     },\n... )\n\nCustomizing the Crawling Behavior while Following Links\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you set ``follow_links=True`` you might want to restrict this option for a\nmore customized crawl. This means you can decide whether to include or exclude\ncertain links based on certain conditions based on URL parameters and/or URL\nregex patterns.\n\nURL Query Parameters\n--------------------\n\nTwo options are available for this:\n\n1. ``exclude_url_params``: By providing a list of URL parameters, any link that\ncontains any of the parameters will not be followed. For example if you set\nthis option to ['price', 'country'], and the page currently being crawled\ncontains three links:\n\n  * **/shoes/model_a?price=10&country=us**: Contains both parameters, will not be followed.\n  * **/shoes/model_a?price=10**: Contains one of the parameters, will not be followed.\n  * **/shoes/model_b?color=black**: Contains \"color\" which was not listed, will be followed\n\nTo make this efficient, and in case you want to skip all links that contain any\nparameter, you can set this option to ``True``, and any link that contains any\nURL parameter will not be followed ``exclude_url_params=True``\n\n\n2. ``include_url_params``: Similarly, you can choose the parameters that links\nshould contain in order for them to be followed. If a link contains any of the\nlisted parameters, that link will be followed. Even though this option is\nstraightforward, it might give you unexpected results. If you set the\nparameters to include as ['price'] for example, and you start crawling from a\npage that doesn't have any link containing that parameter, crawling will stop.\nYet, the website might have many links with that parameter. Please keep this in\nmind, and remember that reasoning about the exclude option is easier than the\ninclude option for this reason/example.\n\nURL Regex Patterns\n------------------\n\nYou might want even more granular control over which links to follow, and might\nbe interested in other URL properties than their query parameters. You have two\nsimple options to include/exclude links based on whether they match a certain\nregex pattern.\n\n1. ``exclude_url_regex``: Enter a regex, and the links will be checked if they\nmatch it. If they do, they will not be followed, if not they will.\n\n2. ``include_url_regex``: This is similar but tells the crawler which links to\nfollow, based on whether or not they match the regex. This option also has the\nsame potentially tricky behavior like the ``include_url_params`` option.\n\nHere is a simple example showing how you might control following links using\nall four options:\n\n.. code-block::\n\n    import advertools as adv\n    adv.crawl('https://example.com', 'output_file.jl', follow_links=True,\n\n              # don't follow links containing any of these parameters:\n              exclude_url_params=['price', 'region'],\n              # follow links containing any of these parameters:\n              include_url_params=['source'],\n              # don't follow links that contain the pattern \"/fr/\" or \"/de/\":\n              exclude_url_regex='/fr/|/de/',\n              # follow links that contain the pattern \"/shop/\":\n              include_url_regex='/shop/'\n              )\n\nSpider Custom Settings and Additional Functionality\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn addition to what you can control regarding the items you can extract, you\ncan also customize the behaviour of the spider and set rules for crawling so\nyou can control it even further.\n\nThis is provided by the ``custom_settings`` parameter. It is optional, and\ntakes a dictionary of settings and their values. Scrapy provides a very large\nnumber of settings, and they are all available through this parameter\n(assuming some conditions for some of the settings).\n\nHere are some examples that you might find interesting:\n\n* `CONCURRENT_REQUESTS_PER_DOMAIN` Defaults to 8, and controls the number of\n  simultaneous requests to be performed for each domain. You might want to\n  lower this if you don't want to put too much pressure on the website's\n  server, and you probably don't want to get blocked!\n* `DEFAULT_REQUEST_HEADERS` You can change this if you need to.\n* `DEPTH_LIMIT` How deep your crawl will be allowed. The default has no limit.\n* `DOWNLOAD_DELAY` Similar to the first option. Controls the amount of time in\n  seconds for the crawler to wait between consecutive pages of the same\n  website. It can also take fractions of a second (0.4, 0.75, etc.)\n* `LOG_FILE` If you want to save your crawl logs to a file, which is strongly\n  recommended, you can provide a path to it here.\n* `USER_AGENT` If you want to identify yourself differently while crawling.\n  This is affected by the robots.txt rules, so you would be potentially\n  allowed/disallowed from certain pages based on your user-agent.\n* `CLOSESPIDER_ERRORCOUNT`, `CLOSESPIDER_ITEMCOUNT`, `CLOSESPIDER_PAGECOUNT`,\n  `CLOSESPIDER_TIMEOUT` Stop crawling after that many errors, items, pages, or\n  seconds. These can be very useful to limit your crawling in certain cases.\n  I particularly like to use `CLOSESPIDER_PAGECOUNT` when exploring a new\n  website, and also to make sure that my selectors are working as expected. So\n  for your first few crawls you might set this to five hundred for example and\n  explore the crawled pages. Then when you are confident things are working\n  fine, you can remove this restriction. `CLOSESPIDER_ERRORCOUNT` can also be\n  very useful while exploring, just in case you get unexpected errors.\n\nThe next page contains a number of :ref:`strategies and recipes for crawling <crawl_strategies>`\nwith code examples and explanations.\n\n**Usage**\n\nA very simple dictionary to be added to your function call:\n\n>>> adv.crawl(\n...     \"http://exmaple.com\",\n...     \"outpuf_file.jl\",\n...     custom_settings={\n...         \"CLOSESPIDER_PAGECOUNT\": 100,\n...         \"CONCURRENT_REQUESTS_PER_DOMAIN\": 1,\n...         \"USER_AGENT\": \"custom-user-agent\",\n...     },\n... )\n\nPlease refer to the `spider settings documentation <https://docs.scrapy.org/en/latest/topics/settings.html>`_\nfor the full details.\n\n\"\"\"\nimport datetime\nimport json\nimport logging\nimport platform\nimport re\nimport runpy\nimport subprocess\nfrom urllib.parse import parse_qs, urlparse, urlsplit\nimport pandas as pd\nimport scrapy\nimport scrapy.logformatter as formatter\nfrom scrapy import Request\nfrom scrapy.linkextractors import LinkExtractor\nfrom scrapy.spiders import Spider\nfrom scrapy.utils.response import get_base_url\nimport advertools as adv\nif int(pd.__version__[0]) >= 1:\n    from pandas import json_normalize\nelse:\n    from pandas.io.json import json_normalize\nfrom advertools import __version__ as adv_version\nspider_path = adv.__path__[0] + '/spider.py'\nuser_agent = f'advertools/{adv_version}'\nBODY_TEXT_SELECTOR = '//body//*[self::a or self::abbr or self::address or self::b or self::blockquote or self::cite or self::code or self::dd or self::del or self::div or self::dl or self::dt or self::em or self::h1 or self::h2 or self::h3 or self::h4 or self::h5 or self::h6 or self::header or self::i or self::ins or self::kbd or self::li or self::mark or self::ol or self::p or self::pre or self::q or self::section or self::small or self::span or self::strong or self::sub or self::sup or self::time or self::u or self::ul][not(ancestor::area) and not(ancestor::aside) and not(ancestor::audio) and not(ancestor::button) and not(ancestor::caption) and not(ancestor::col) and not(ancestor::colgroup) and not(ancestor::datalist) and not(ancestor::details) and not(ancestor::embed) and not(ancestor::fieldset) and not(ancestor::footer) and not(ancestor::form) and not(ancestor::head) and not(ancestor::iframe) and not(ancestor::img) and not(ancestor::input) and not(ancestor::label) and not(ancestor::legend) and not(ancestor::link) and not(ancestor::map) and not(ancestor::meta) and not(ancestor::nav) and not(ancestor::noscript) and not(ancestor::object) and not(ancestor::optgroup) and not(ancestor::option) and not(ancestor::output) and not(ancestor::param) and not(ancestor::picture) and not(ancestor::script) and not(ancestor::select) and not(ancestor::source) and not(ancestor::style) and not(ancestor::svg) and not(ancestor::table) and not(ancestor::tbody) and not(ancestor::td) and not(ancestor::textarea) and not(ancestor::tfoot) and not(ancestor::th) and not(ancestor::thead) and not(ancestor::title) and not(ancestor::tr) and not(ancestor::track) and not(ancestor::video)]/text()'\n_IMG_ATTRS = {'alt', 'crossorigin', 'decoding', 'fetchpriority', 'height', 'ismap', 'loading', 'referrerpolicy', 'sizes', 'src', 'srcset', 'usemap', 'width', 'align', 'border', 'hspace', 'longdesc', 'name', 'vspace'}\n\ndef _extract_images(response):\n    page_has_images = response.xpath('//img')\n    if page_has_images:\n        img_df = pd.DataFrame([x.attrib for x in response.xpath('//img')])\n        if 'src' in img_df:\n            img_df['src'] = [response.urljoin(url) if isinstance(url, str) else url for url in img_df['src']]\n        img_df = img_df.apply(lambda col: col.fillna('').str.cat(sep='@@')).to_frame().T\n        img_df = img_df[img_df.columns.intersection(_IMG_ATTRS)]\n        img_df = img_df.add_prefix('img_')\n        d = img_df.to_dict('records')[0]\n        return d\n    return {}\n\ndef get_max_cmd_len():\n    system = platform.system()\n    cmd_dict = {'Windows': 7000, 'Linux': 100000, 'Darwin': 100000}\n    if system in cmd_dict:\n        return cmd_dict[system]\n    return 6000\nMAX_CMD_LENGTH = get_max_cmd_len()\nformatter.SCRAPEDMSG = 'Scraped from %(src)s'\nformatter.DROPPEDMSG = 'Dropped: %(exception)s'\nformatter.DOWNLOADERRORMSG_LONG = 'Error downloading %(request)s'\n\nclass MyLinkExtractor(LinkExtractor):\n\n    def extract_links(self, response):\n        base_url = get_base_url(response)\n        if self.restrict_xpaths:\n            docs = [subdoc for x in self.restrict_xpaths for subdoc in response.xpath(x)]\n        else:\n            docs = [response.selector]\n        all_links = []\n        for doc in docs:\n            links = self._extract_links(doc, response.url, response.encoding, base_url)\n            all_links.extend(self._process_links(links))\n        return all_links\nle = MyLinkExtractor(unique=False)\nle_nav = MyLinkExtractor(unique=False, restrict_xpaths='//nav')\nle_header = MyLinkExtractor(unique=False, restrict_xpaths='//header')\nle_footer = MyLinkExtractor(unique=False, restrict_xpaths='//footer')\ncrawl_headers = {'url', 'title', 'meta_desc', 'viewport', 'charset', 'alt_href', 'alt_hreflang', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'canonical', 'body_text', 'size', 'download_timeout', 'download_slot', 'download_latency', 'redirect_times', 'redirect_ttl', 'redirect_urls', 'redirect_reasons', 'depth', 'status', 'links_url', 'links_text', 'links_nofollow', 'img_src', 'img_alt', 'ip_address', 'crawl_time', 'blocked_by_robotstxt', 'jsonld_errors', 'request_headers_accept', 'request_headers_accept-language', 'request_headers_user-agent', 'request_headers_accept-encoding', 'request_headers_cookie'}\n\ndef _split_long_urllist(url_list, max_len=MAX_CMD_LENGTH):\n    \"\"\"Split url_list if their total length is greater than MAX_CMD_LENGTH.\"\"\"\n    split_list = [[]]\n    for u in url_list:\n        temp_len = sum((len(temp_u) for temp_u in split_list[-1]))\n        if temp_len < max_len and temp_len + len(u) < max_len:\n            split_list[-1].append(u)\n        else:\n            split_list.append([u])\n    return split_list\n\ndef _numbered_duplicates(items):\n    \"\"\"Append a number to all duplicated items starting at 1.\n\n    ['og:site', 'og:image', 'og:image', 'og:type', 'og:image']\n    becomes:\n    ['og:site', 'og:image_1', 'og:image_2', 'og:type', 'og:image_3']\n    \"\"\"\n    item_count = dict.fromkeys(items, 0)\n    numbered_items = []\n    for item in items:\n        numbered_items.append(item + '_' + str(item_count[item]))\n        item_count[item] += 1\n    for i, num_item in enumerate(numbered_items):\n        split_number = num_item.rsplit('_', maxsplit=1)\n        if split_number[1] == '0':\n            numbered_items[i] = split_number[0]\n    return numbered_items\n\ndef _json_to_dict(jsonobj, i=None):\n    try:\n        df = json_normalize(jsonobj)\n        if i:\n            df = df.add_prefix('jsonld_{}_'.format(i))\n        else:\n            df = df.add_prefix('jsonld_')\n        return dict(zip(df.columns, df.values[0]))\n    except Exception as e:\n        logger = logging.getLogger(__name__)\n        logger.error(msg=str(e))\n        return {}\ntags_xpaths = {'title': '//title/text()', 'meta_desc': '//meta[@name=\"description\"]/@content', 'viewport': '//meta[@name=\"viewport\"]/@content', 'charset': '//meta[@charset]/@charset', 'h1': '//h1', 'h2': '//h2', 'h3': '//h3', 'h4': '//h4', 'h5': '//h5', 'h6': '//h6', 'canonical': '//link[@rel=\"canonical\"]/@href', 'alt_href': '//link[@rel=\"alternate\"]/@href', 'alt_hreflang': '//link[@rel=\"alternate\"]/@hreflang'}\n\ndef _extract_content(resp, **tags_xpaths):\n    d = {}\n    for tag, xpath in tags_xpaths.items():\n        if not tag.startswith('h'):\n            value = '@@'.join(resp.xpath(xpath).getall())\n            if value:\n                d.update({tag: value})\n        else:\n            value = '@@'.join([h.root.text_content() for h in resp.xpath(xpath)])\n            if value:\n                d.update({tag: value})\n    return d\n\nclass SEOSitemapSpider(Spider):\n    name = 'seo_spider'\n    follow_links = False\n    skip_url_params = False\n    css_selectors = {}\n    xpath_selectors = {}\n    custom_headers = {}\n    custom_settings = {'USER_AGENT': user_agent, 'ROBOTSTXT_OBEY': True, 'HTTPERROR_ALLOW_ALL': True}\n\n    def __init__(self, url_list, follow_links=False, allowed_domains=None, exclude_url_params=None, include_url_params=None, exclude_url_regex=None, include_url_regex=None, css_selectors=None, xpath_selectors=None, meta=None, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.start_urls = json.loads(json.dumps(url_list.split(',')))\n        self.allowed_domains = json.loads(json.dumps(allowed_domains.split(',')))\n        self.follow_links = eval(json.loads(json.dumps(follow_links)))\n        self.exclude_url_params = eval(json.loads(json.dumps(exclude_url_params)))\n        self.include_url_params = eval(json.loads(json.dumps(include_url_params)))\n        self.exclude_url_regex = str(json.loads(json.dumps(exclude_url_regex)))\n        if self.exclude_url_regex == 'None':\n            self.exclude_url_regex = None\n        self.include_url_regex = str(json.loads(json.dumps(include_url_regex)))\n        if self.include_url_regex == 'None':\n            self.include_url_regex = None\n        self.css_selectors = eval(json.loads(json.dumps(css_selectors)))\n        self.xpath_selectors = eval(json.loads(json.dumps(xpath_selectors)))\n        self.meta = eval(json.loads(json.dumps(meta)))\n\n    def get_custom_headers(self):\n        if self.meta:\n            custom_headers = self.meta.get('custom_headers') or {}\n            if isinstance(custom_headers, str):\n                module = runpy.run_path(custom_headers)\n                custom_headers = module['custom_headers']\n        else:\n            custom_headers = {}\n        self.custom_headers = custom_headers\n\n    def start_requests(self):\n        self.get_custom_headers()\n        for url in self.start_urls:\n            try:\n                yield Request(url, callback=self.parse, errback=self.errback, meta=self.meta, headers=self.custom_headers.get(url))\n            except Exception as e:\n                self.logger.error(repr(e))\n\n    def errback(self, failure):\n        if not failure.check(scrapy.exceptions.IgnoreRequest):\n            self.logger.error(repr(failure))\n            yield {'url': failure.request.url, 'crawl_time': datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), 'errors': repr(failure)}\n\n    def parse(self, response):\n        links = le.extract_links(response)\n        nav_links = le_nav.extract_links(response)\n        header_links = le_header.extract_links(response)\n        footer_links = le_footer.extract_links(response)\n        images = _extract_images(response)\n        if links:\n            parsed_links = dict(links_url='@@'.join((link.url for link in links)), links_text='@@'.join((link.text for link in links)), links_nofollow='@@'.join((str(link.nofollow) for link in links)))\n        else:\n            parsed_links = {}\n        if nav_links:\n            parsed_nav_links = dict(nav_links_url='@@'.join((link.url for link in nav_links)), nav_links_text='@@'.join((link.text for link in nav_links)), nav_links_nofollow='@@'.join((str(link.nofollow) for link in nav_links)))\n        else:\n            parsed_nav_links = {}\n        if header_links:\n            parsed_header_links = dict(header_links_url='@@'.join((link.url for link in header_links)), header_links_text='@@'.join((link.text for link in header_links)), header_links_nofollow='@@'.join((str(link.nofollow) for link in header_links)))\n        else:\n            parsed_header_links = {}\n        if footer_links:\n            parsed_footer_links = dict(footer_links_url='@@'.join((link.url for link in footer_links)), footer_links_text='@@'.join((link.text for link in footer_links)), footer_links_nofollow='@@'.join((str(link.nofollow) for link in footer_links)))\n        else:\n            parsed_footer_links = {}\n        if self.css_selectors:\n            css_selectors = {key: '@@'.join(response.css('{}'.format(val)).getall()) for key, val in self.css_selectors.items()}\n            css_selectors = {k: v for k, v in css_selectors.items() if v}\n        else:\n            css_selectors = {}\n        if self.xpath_selectors:\n            xpath_selectors = {key: '@@'.join(response.xpath('{}'.format(val)).getall()) for key, val in self.xpath_selectors.items()}\n            xpath_selectors = {k: v for k, v in xpath_selectors.items() if v}\n        else:\n            xpath_selectors = {}\n        canonical = {'canonical': '@@'.join(response.css('link[rel=\"canonical\"]::attr(href)').getall())}\n        canonical = canonical if canonical.get('canonical') else {}\n        alt_href = {'alt_href': '@@'.join(response.css('link[rel=alternate]::attr(href)').getall())}\n        alt_href = alt_href if alt_href.get('alt_href') else {}\n        alt_hreflang = {'alt_hreflang': '@@'.join(response.css('link[rel=alternate]::attr(hreflang)').getall())}\n        alt_hreflang = alt_hreflang if alt_hreflang.get('alt_hreflang') else {}\n        og_props = response.xpath('//meta[starts-with(@property, \"og:\")]/@property').getall()\n        og_content = response.xpath('//meta[starts-with(@property, \"og:\")]/@content').getall()\n        if og_props and og_content:\n            og_props = _numbered_duplicates(og_props)\n            open_graph = dict(zip(og_props, og_content))\n        else:\n            open_graph = {}\n        twtr_names = response.xpath('//meta[starts-with(@name, \"twitter:\")]/@name').getall()\n        twtr_content = response.xpath('//meta[starts-with(@name, \"twitter:\")]/@content').getall()\n        if twtr_names and twtr_content:\n            twtr_card = dict(zip(twtr_names, twtr_content))\n        else:\n            twtr_card = {}\n        try:\n            ld = [json.loads(s.replace('\\r', '').replace('\\n', ' ')) for s in response.css('script[type=\"application/ld+json\"]::text').getall()]\n            if not ld:\n                jsonld = {}\n            elif len(ld) == 1:\n                if isinstance(ld, list):\n                    ld = ld[0]\n                jsonld = _json_to_dict(ld)\n            else:\n                ld_norm = [_json_to_dict(x, i) for i, x in enumerate(ld)]\n                jsonld = {}\n                for norm in ld_norm:\n                    jsonld.update(**norm)\n        except Exception as e:\n            jsonld = {'jsonld_errors': str(e)}\n            self.logger.exception(' '.join([str(e), str(response.status), response.url]))\n        page_content = _extract_content(response, **tags_xpaths)\n        yield dict(url=response.request.url, **page_content, **open_graph, **twtr_card, **jsonld, body_text=' '.join(response.xpath(BODY_TEXT_SELECTOR).extract()), size=len(response.body), **css_selectors, **xpath_selectors, **{k: '@@'.join((str(val) for val in v)) if isinstance(v, list) else v for k, v in response.meta.items() if k != 'custom_headers'}, status=response.status, **parsed_links, **parsed_nav_links, **parsed_header_links, **parsed_footer_links, **images, ip_address=str(response.ip_address), crawl_time=datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'), **{'resp_headers_' + k: v for k, v in response.headers.to_unicode_dict().items()}, **{'request_headers_' + k: v for k, v in response.request.headers.to_unicode_dict().items()})\n        if self.follow_links:\n            next_pages = [link.url for link in links]\n            if next_pages:\n                for page in next_pages:\n                    cond = _crawl_or_not(page, exclude_url_params=self.exclude_url_params, include_url_params=self.include_url_params, exclude_url_regex=self.exclude_url_regex, include_url_regex=self.include_url_regex)\n                    if cond:\n                        yield Request(page, callback=self.parse, errback=self.errback, meta=self.meta, headers=self.custom_headers.get(page))\n\ndef crawl(url_list, output_file, follow_links=False, allowed_domains=None, exclude_url_params=None, include_url_params=None, exclude_url_regex=None, include_url_regex=None, css_selectors=None, xpath_selectors=None, custom_settings=None, meta=None):\n    \"\"\"\n    Crawl a website or a list of URLs based on the supplied options.\n\n    Parameters\n    ----------\n    url_list : url, list\n      One or more URLs to crawl. If ``follow_links`` is True, the crawler will start\n      with these URLs and follow all links on pages recursively.\n    output_file : str\n      The path to the output of the crawl. Jsonlines only is supported to allow for\n      dynamic values. Make sure your file ends with \".jl\", e.g. `output_file.jl`.\n    follow_links : bool\n      Defaults to False. Whether or not to follow links on crawled pages.\n    allowed_domains : list\n      A list of the allowed domains to crawl. This ensures that the crawler does not\n      attempt to crawl the whole web. If not specified, it defaults to the domains of\n      the URLs provided in ``url_list`` and all their sub-domains. You can also specify\n      a list of sub-domains, if you want to only crawl those.\n    exclude_url_params : list, bool\n      A list of URL parameters to exclude while following links. If a link contains any\n      of those parameters, don't follow it. Setting it to ``True`` will exclude links\n      containing any parameter.\n    include_url_params : list\n      A list of URL parameters to include while following links. If a link contains any\n      of those parameters, follow it. Having the same parmeters to include and exclude\n      raises an error.\n    exclude_url_regex : str\n      A regular expression of a URL pattern to exclude while following links. If a link\n      matches the regex don't follow it.\n    include_url_regex : str\n      A regular expression of a URL pattern to include while following links. If a link\n      matches the regex follow it.\n    css_selectors : dict\n      A dictionary mapping names to CSS selectors. The names will become column headers,\n      and the selectors will be used to extract the required data/content.\n    xpath_selectors : dict\n      A dictionary mapping names to XPath selectors. The names will become column\n      headers, and the selectors will be used to extract the required data/content.\n    custom_settings : dict\n      A dictionary of optional custom settings that you might want to add to the\n      spider's functionality. There are over 170 settings for all kinds of options. For\n      details please refer to the `spider settings <https://docs.scrapy.org/en/latest/topics/settings.html>`_\n      documentation.\n    meta : dict\n      Additional data to pass to the crawler; add arbitrary metadata, set custom request\n      headers per URL, and/or enable some third party plugins.\n    Examples\n    --------\n    Crawl a website and let the crawler discover as many pages as available\n\n    >>> import advertools as adv\n    >>> adv.crawl(\"http://example.com\", \"output_file.jl\", follow_links=True)\n    >>> import pandas as pd\n    >>> crawl_df = pd.read_json(\"output_file.jl\", lines=True)\n\n    Crawl a known set of pages (on a single or multiple sites) without\n    following links (just crawl the specified pages) or \"list mode\":\n\n    >>> adv.crawl(\n    ...     [\n    ...         \"http://exmaple.com/product\",\n    ...         \"http://exmaple.com/product2\",\n    ...         \"https://anotherexample.com\",\n    ...         \"https://anotherexmaple.com/hello\",\n    ...     ],\n    ...     \"output_file.jl\",\n    ...     follow_links=False,\n    ... )\n\n    Crawl a website, and in addition to standard SEO elements, also get the\n    required CSS selectors.\n    Here we will get three additional columns `price`, `author`, and\n    `author_url`. Note that you need to specify if you want the text attribute\n    or the `href` attribute if you are working with links (and all other\n    selectors).\n\n    >>> adv.crawl(\n    ...     \"http://example.com\",\n    ...     \"output_file.jl\",\n    ...     css_selectors={\n    ...         \"price\": \".a-color-price::text\",\n    ...         \"author\": \".contributorNameID::text\",\n    ...         \"author_url\": \".contributorNameID::attr(href)\",\n    ...     },\n    ... )\n\n    Using the ``meta`` parameter:\n\n    **Adding custom meta data** for the crawler using the `meta` parameter for\n    tracking/context purposes. If you supply {\"purpose\": \"pre-launch test\"}, then you\n    will get a column called \"purpose\", and all its values will be \"pre-launch test\" in\n    the crawl DataFrame.\n\n    >>> adv.crawl(\n    ...     \"https://example.com\",\n    ...     \"output_file.jl\",\n    ...     meta={\"purpose\": \"pre-launch test\"},\n    ... )\n\n    Or maybe mention which device(s) you crawled with, which is much easier than reading\n    the user-agent string:\n\n    >>> adv.crawl(\n    ...     \"https://example.com\",\n    ...     \"output.jsonl\",\n    ...     custom_settings={\n    ...         \"USER_AGENT\": \"Mozilla/5.0 (iPhone; CPUiPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1\"\n    ...     },\n    ...     meta={\"device\": \"Apple iPhone 12 Pro (Safari)\"},\n    ... )\n\n    Of course you can combine any such meta data however way you want:\n\n    >>> {\"device\": \"iphone\", \"purpose\": \"initial audit\", \"crawl_country\": \"us\", ...}\n\n    **Custom request headers**: Supply custom request headers per URL with the special\n    key ``custom_headers``. It's value is a dictionary where its keys are URLs, and\n    every URL's values is a dictionary, each with its own custom request headers.\n\n    >>> adv.crawl(\n    ...     URL_LIST,\n    ...     OUTPUT_FILE,\n    ...     meta={\n    ...         \"custom_headers\": {\n    ...             \"URL_A\": {\"HEADER_1\": \"VALUE_1\", \"HEADER_2\": \"VALUE_1\"},\n    ...             \"URL_B\": {\"HEADER_1\": \"VALUE_2\", \"HEADER_2\": \"VALUE_2\"},\n    ...             \"URL_C\": {\"HEADER_1\": \"VALUE_3\"},\n    ...         }\n    ...     },\n    ... )\n\n    OR:\n\n    >>> meta = {\n    ...     \"custom_headers\": {\n    ...         \"https://example.com/A\": {\"If-None-Match\": \"Etag A\"},\n    ...         \"https://example.com/B\": {\n    ...             \"If-None-Match\": \"Etag B\",\n    ...             \"User-Agent\": \"custom UA\",\n    ...         },\n    ...         \"https://example.com/C\": {\n    ...             \"If-None-Match\": \"Etag C\",\n    ...             \"If-Modified-Since\": \"Sat, 17 Oct 2024 16:24:00 GMT\",\n    ...         },\n    ...     }\n    ... }\n\n    **Long lists of requests headers:** In some cases you might have a very long list\n    and that might raise an `Argument list too long` error. In this case you can provide\n    the path of a Python script that contains a dictionary for the headers. Keep in\n    mind:\n\n    - The dictionary has to be named ``custom_headers`` with the same structure mentioned above\n    - The file has to be a Python script, having the extension \".py\"\n    - The script can generate the dictionary programmatically to make it easier to\n      incorporate in various workflows\n    - The path to the file can be absolute or relative to where the command is\n      run from.\n\n      >>> meta = {\"custom_headers\": \"my_custom_headers.py\"}\n\n      OR\n\n      >>> meta = {\"custom_headers\": \"/full/path/to/my_custom_headers.py\"}\n\n    **Use with third party plugins** like scrapy playwright. To enable it, set\n    ``{\"playwright\": True}`` together with other settings.\n    \"\"\"\n    if isinstance(url_list, str):\n        url_list = [url_list]\n    if isinstance(allowed_domains, str):\n        allowed_domains = [allowed_domains]\n    if output_file.rsplit('.')[-1] not in ['jl', 'jsonl']:\n        raise ValueError(\"Please make sure your output_file ends with '.jl' or '.jsonl'.\\nFor example:\\n{}.jl\".format(output_file.rsplit('.', maxsplit=1)[0]))\n    if xpath_selectors is not None and css_selectors is not None:\n        css_xpath = set(xpath_selectors).intersection(css_selectors)\n        if css_xpath:\n            raise ValueError(\"Please make sure you don't set common keys for`css_selectors` and `xpath_selectors`.\\nDuplicated keys: {}\".format(css_xpath))\n    for selector in [xpath_selectors, css_selectors]:\n        if selector is not None and set(selector).intersection(crawl_headers):\n            raise ValueError(\"Please make sure you don't use names of default headers. Avoid using any of these as keys: \\n{}\".format(sorted(crawl_headers)))\n    if allowed_domains is None:\n        allowed_domains = {urlparse(url).netloc for url in url_list}\n    if exclude_url_params is not None and include_url_params is not None:\n        if exclude_url_params is True:\n            raise ValueError(\"Please make sure you don't exclude and include parameters at the same time.\")\n        common_params = set(exclude_url_params).intersection(include_url_params)\n        if common_params:\n            raise ValueError(f\"Please make sure you don't include and exclude the same parameters.\\nCommon parameters entered: {', '.join(common_params)}\")\n    if include_url_regex is not None and exclude_url_regex is not None:\n        if include_url_regex == exclude_url_regex:\n            raise ValueError(f\"Please make sure you don't include and exclude the same regex pattern.\\nYou entered '{include_url_regex}'.\")\n    settings_list = []\n    if custom_settings is not None:\n        for key, val in custom_settings.items():\n            if isinstance(val, (dict, list, set, tuple)):\n                setting = '='.join([key, json.dumps(val)])\n            else:\n                setting = '='.join([key, str(val)])\n            settings_list.extend(['-s', setting])\n    command = ['scrapy', 'runspider', spider_path, '-a', 'url_list=' + ','.join(url_list), '-a', 'allowed_domains=' + ','.join(allowed_domains), '-a', 'follow_links=' + str(follow_links), '-a', 'exclude_url_params=' + str(exclude_url_params), '-a', 'include_url_params=' + str(include_url_params), '-a', 'exclude_url_regex=' + str(exclude_url_regex), '-a', 'include_url_regex=' + str(include_url_regex), '-a', 'css_selectors=' + str(css_selectors), '-a', 'xpath_selectors=' + str(xpath_selectors), '-a', 'meta=' + str(meta), '-o', output_file] + settings_list\n    if len(','.join(url_list)) > MAX_CMD_LENGTH:\n        split_urls = _split_long_urllist(url_list)\n        for u_list in split_urls:\n            command[4] = 'url_list=' + ','.join(u_list)\n            subprocess.run(command)\n    else:\n        subprocess.run(command)"
  }
}