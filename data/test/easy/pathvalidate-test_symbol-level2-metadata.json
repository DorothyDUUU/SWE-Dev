{
  "dir_path": "/app/pathvalidate",
  "package_name": "pathvalidate",
  "sample_name": "pathvalidate-test_symbol",
  "src_dir": "pathvalidate/",
  "test_dir": "test/",
  "test_file": "test/test_symbol.py",
  "test_code": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport itertools\n\nimport pytest\n\nfrom pathvalidate import (\n    ascii_symbols,\n    replace_symbol,\n    unprintable_ascii_chars,\n    validate_symbol,\n    validate_unprintable_char,\n)\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom ._common import alphanum_chars\n\n\nclass Test_validate_symbol:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = ascii_symbols\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_symbol(value)\n\n    @pytest.mark.parametrize([\"value\"], [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30b7\u30fc\u30c8\"]])\n    def test_normal_multibyte(self, value):\n        pytest.skip(\"TODO\")\n\n        validate_symbol(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [\n            [\"abc\" + invalid_char + \"hoge123\"]\n            for invalid_char in INVALID_CHARS + unprintable_ascii_chars\n        ],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_symbol(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n\nclass Test_replace_symbol:\n    TARGET_CHARS = ascii_symbols\n    NOT_TARGET_CHARS = alphanum_chars\n    REPLACE_TEXT_LIST = [\"\", \"_\"]\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"expected\"],\n        [\n            [\"A\" + c + \"B\", rep, \"A\" + rep + \"B\"]\n            for c, rep in itertools.product(TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [\"A\" + c + \"B\", rep, \"A\" + c + \"B\"]\n            for c, rep in itertools.product(NOT_TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [[\"\", \"\", \"\"]],\n    )\n    def test_normal(self, value, replace_text, expected):\n        assert replace_symbol(value, replace_text) == expected\n\n    @pytest.mark.parametrize(\n        [\"value\", \"exclude_symbols\", \"expected\"],\n        [\n            [\"/tmp/h!o|g$e.txt\", [\"/\", \".\"], \"/tmp/hoge.txt\"],\n            [\"/tmp/h!o|g$e.txt\", [], \"tmphogetxt\"],\n            [\"/tmp/h!o|g$e.txt\", [\"n\", \"o\", \"p\"], \"tmphogetxt\"],\n        ],\n    )\n    def test_normal_exclude_symbols(self, value, exclude_symbols, expected):\n        assert replace_symbol(value, exclude_symbols=exclude_symbols) == expected\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"is_replace_consecutive_chars\", \"is_strip\", \"expected\"],\n        [\n            [\"!a##b$$$c((((d]]]])\", \"_\", True, True, \"a_b_c_d\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", True, False, \"_a_b_c_d_\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", False, True, \"a__b___c____d\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", False, False, \"_a__b___c____d_____\"],\n        ],\n    )\n    def test_normal_consecutive(\n        self, value, replace_text, is_replace_consecutive_chars, is_strip, expected\n    ):\n        assert (\n            replace_symbol(\n                value,\n                replace_text,\n                is_replace_consecutive_chars=is_replace_consecutive_chars,\n                is_strip=is_strip,\n            )\n            == expected\n        )\n\n    @pytest.mark.parametrize(\n        [\"value\", \"expected\"],\n        [\n            [None, TypeError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_abnormal(self, value, expected):\n        with pytest.raises(expected):\n            replace_symbol(value)\n\n\nclass Test_validate_unprintable_char:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = unprintable_ascii_chars\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_unprintable_char(value)\n\n    @pytest.mark.parametrize([\"value\"], [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30b7\u30fc\u30c8\"]])\n    def test_normal_multibyte(self, value):\n        pytest.skip(\"TODO\")\n\n        validate_unprintable_char(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [\n            [\"abc\" + invalid_char + \"hoge123\"]\n            for invalid_char in INVALID_CHARS + unprintable_ascii_chars\n        ],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_unprintable_char(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n",
  "GT_file_code": {
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\n\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n\n\n_re_whitespaces = re.compile(r\"^[\\s]+$\")\n\n\ndef validate_pathtype(\n    text: PathType, allow_whitespaces: bool = False, error_msg: Optional[str] = None\n) -> None:\n    from .error import ErrorReason, ValidationError\n\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n\n    raise TypeError(f\"text must be a string: actual={type(text)}\")\n\n\ndef to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n\n    return name\n\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith(\"\\\\\\\\\"):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n\n    drive, _tail = ntpath.splitdrive(value)\n\n    return ntpath.isabs(value) and len(drive) > 0\n\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\n\n\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n\n    for i in range(128):\n        c = chr(i)\n\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n\n        symbol_list.append(c)\n\n    return symbol_list\n\n\nascii_symbols = tuple(_get_ascii_symbols())\n\n__RE_UNPRINTABLE_CHARS = re.compile(\n    \"[{}]\".format(re.escape(\"\".join(unprintable_ascii_chars))), re.UNICODE\n)\n__RE_ANSI_ESCAPE = re.compile(\n    r\"(?:\\x1B[@-Z\\\\-_]|[\\x80-\\x9A\\x9C-\\x9F]|(?:\\x1B\\[|\\x9B)[0-?]*[ -/]*[@-~])\"\n)\n\n\ndef validate_unprintable_char(text: str) -> None:\n    from .error import InvalidCharError\n\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f\"unprintable character found: {match_list}\")\n\n\ndef replace_unprintable_char(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef replace_ansi_escape(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n\n    if not name:\n        return Platform.UNIVERSAL\n\n    platform_str = name.strip().casefold()\n\n    if platform_str == \"posix\":\n        return Platform.POSIX\n\n    if platform_str == \"auto\":\n        platform_str = platform.system().casefold()\n\n    if platform_str in [\"linux\"]:\n        return Platform.LINUX\n\n    if platform_str and platform_str.startswith(\"win\"):\n        return Platform.WINDOWS\n\n    if platform_str in [\"mac\", \"macos\", \"darwin\"]:\n        return Platform.MACOS\n\n    return Platform.UNIVERSAL\n\n\ndef findall_to_str(match: List[Any]) -> str:\n    return \", \".join([repr(text) for text in match])\n\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    # last char might be malformed, ignore it\n    return str_bytes.decode(encoding, \"ignore\")\n",
    "pathvalidate/_symbol.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport re\nfrom typing import Sequence\n\nfrom ._common import ascii_symbols, to_str, unprintable_ascii_chars\nfrom .error import InvalidCharError\n\n\n__RE_SYMBOL = re.compile(\n    \"[{}]\".format(re.escape(\"\".join(ascii_symbols + unprintable_ascii_chars))), re.UNICODE\n)\n\n\ndef validate_symbol(text: str) -> None:\n    \"\"\"\n    Verifying whether symbol(s) included in the ``text`` or not.\n\n    Args:\n        text:\n            Input text to validate.\n\n    Raises:\n        ValidationError (ErrorReason.INVALID_CHARACTER):\n            If symbol(s) included in the ``text``.\n    \"\"\"\n\n    match_list = __RE_SYMBOL.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f\"invalid symbols found: {match_list}\")\n\n\ndef replace_symbol(\n    text: str,\n    replacement_text: str = \"\",\n    exclude_symbols: Sequence[str] = [],\n    is_replace_consecutive_chars: bool = False,\n    is_strip: bool = False,\n) -> str:\n    \"\"\"\n    Replace all of the symbols in the ``text``.\n\n    Args:\n        text:\n            Input text.\n        replacement_text:\n            Replacement text.\n        exclude_symbols:\n            Symbols that were excluded from the replacement.\n        is_replace_consecutive_chars:\n            If |True|, replace consecutive multiple ``replacement_text`` characters\n            to a single character.\n        is_strip:\n            If |True|, strip ``replacement_text`` from the beginning/end of the replacement text.\n\n    Returns:\n        A replacement string.\n\n    Example:\n\n        :ref:`example-sanitize-symbol`\n    \"\"\"\n\n    if exclude_symbols:\n        regexp = re.compile(\n            \"[{}]\".format(\n                re.escape(\n                    \"\".join(set(ascii_symbols + unprintable_ascii_chars) - set(exclude_symbols))\n                )\n            ),\n            re.UNICODE,\n        )\n    else:\n        regexp = __RE_SYMBOL\n\n    try:\n        new_text = regexp.sub(replacement_text, to_str(text))\n    except TypeError:\n        raise TypeError(\"text must be a string\")\n\n    if not replacement_text:\n        return new_text\n\n    if is_replace_consecutive_chars:\n        new_text = re.sub(f\"{re.escape(replacement_text)}+\", replacement_text, new_text)\n\n    if is_strip:\n        new_text = new_text.strip(replacement_text)\n\n    return new_text\n",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport enum\nfrom typing import Dict, Optional\n\nfrom ._const import Platform\n\n\ndef _to_error_code(code: int) -> str:\n    return f\"PV{code:04d}\"\n\n\nclass ErrorAttrKey:\n    BYTE_COUNT = \"byte_count\"\n    DESCRIPTION = \"description\"\n    FS_ENCODING = \"fs_encoding\"\n    PLATFORM = \"platform\"\n    REASON = \"reason\"\n    RESERVED_NAME = \"reserved_name\"\n    REUSABLE_NAME = \"reusable_name\"\n\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n\n    NULL_NAME = (_to_error_code(1001), \"NULL_NAME\", \"the value must not be an empty string\")\n    RESERVED_NAME = (\n        _to_error_code(1002),\n        \"RESERVED_NAME\",\n        \"found a reserved name by a platform\",\n    )\n    INVALID_CHARACTER = (\n        _to_error_code(1100),\n        \"INVALID_CHARACTER\",\n        \"invalid characters found\",\n    )\n    INVALID_LENGTH = (\n        _to_error_code(1101),\n        \"INVALID_LENGTH\",\n        \"found an invalid string length\",\n    )\n    FOUND_ABS_PATH = (\n        _to_error_code(1200),\n        \"FOUND_ABS_PATH\",\n        \"found an absolute path where must be a relative path\",\n    )\n    MALFORMED_ABS_PATH = (\n        _to_error_code(1201),\n        \"MALFORMED_ABS_PATH\",\n        \"found a malformed absolute path\",\n    )\n    INVALID_AFTER_SANITIZE = (\n        _to_error_code(2000),\n        \"INVALID_AFTER_SANITIZE\",\n        \"found invalid value after sanitizing\",\n    )\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f\"[{self.__code}] {self.__description}\"\n\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f\"{ErrorAttrKey.REASON} must be specified\")\n\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, \"\")\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n\n        slog: Dict[str, str] = {\n            \"code\": self.reason.code,\n            ErrorAttrKey.DESCRIPTION: self.reason.description,\n        }\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n\n        if self.platform:\n            item_list.append(f\"{ErrorAttrKey.PLATFORM}={self.platform.value}\")\n        if self.description:\n            item_list.append(f\"{ErrorAttrKey.DESCRIPTION}={self.description}\")\n        if self.__reusable_name is not None:\n            item_list.append(f\"{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}\")\n        if self.__fs_encoding:\n            item_list.append(f\"{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}\")\n        if self.__byte_count is not None:\n            item_list.append(f\"{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}\")\n\n        if item_list:\n            header += \": \"\n\n        return header + \", \".join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n\n        super().__init__(args, **kwargs)\n\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n\n        super().__init__(args, **kwargs)\n"
  },
  "GT_src_dict": {
    "pathvalidate/_common.py": {
      "to_str": {
        "code": "def to_str(name: PathType) -> str:\n    \"\"\"Converts a given name of type `PathType` to its string representation.\n\nParameters:\n- name (PathType): A value that can be a string or a `PurePath` instance. The function checks the type of the input and converts it accordingly.\n\nReturns:\n- str: The string representation of the input `name`. If `name` is a `PurePath`, it is converted to a string. If it is already a string, it is returned unchanged.\n\nDependencies:\n- `PathType`: A type alias for input values that can be either strings or `PurePath` instances, indicating the expected data types for the argument.\n- `PurePath`: A class from the `pathlib` module that represents filesystem paths. The function leverages this class to handle path-like objects correctly.\"\"\"\n    if isinstance(name, PurePath):\n        return str(name)\n    return name",
        "docstring": "Converts a given name of type `PathType` to its string representation.\n\nParameters:\n- name (PathType): A value that can be a string or a `PurePath` instance. The function checks the type of the input and converts it accordingly.\n\nReturns:\n- str: The string representation of the input `name`. If `name` is a `PurePath`, it is converted to a string. If it is already a string, it is returned unchanged.\n\nDependencies:\n- `PathType`: A type alias for input values that can be either strings or `PurePath` instances, indicating the expected data types for the argument.\n- `PurePath`: A class from the `pathlib` module that represents filesystem paths. The function leverages this class to handle path-like objects correctly.",
        "signature": "def to_str(name: PathType) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "validate_unprintable_char": {
        "code": "def validate_unprintable_char(text: str) -> None:\n    \"\"\"Raises an `InvalidCharError` if the input string contains unprintable ASCII characters.\n\nParameters:\n- text (str): The input string to be validated for unprintable characters.\n\nReturns:\n- None: This function does not return a value.\n\nRaises:\n- InvalidCharError: If unprintable characters are found in the input string, an exception is raised detailing the unprintable characters encountered.\n\nDependencies:\n- This function utilizes the constant `__RE_UNPRINTABLE_CHARS`, a regular expression pattern compiled from a list of unprintable ASCII characters. The list is generated by the function `_get_unprintable_ascii_chars()`, which includes non-printable ASCII characters based on their ASCII values (0-127).\n- It also uses the helper function `to_str` to ensure that the input is processed as a string.\"\"\"\n    from .error import InvalidCharError\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f'unprintable character found: {match_list}')",
        "docstring": "Raises an `InvalidCharError` if the input string contains unprintable ASCII characters.\n\nParameters:\n- text (str): The input string to be validated for unprintable characters.\n\nReturns:\n- None: This function does not return a value.\n\nRaises:\n- InvalidCharError: If unprintable characters are found in the input string, an exception is raised detailing the unprintable characters encountered.\n\nDependencies:\n- This function utilizes the constant `__RE_UNPRINTABLE_CHARS`, a regular expression pattern compiled from a list of unprintable ASCII characters. The list is generated by the function `_get_unprintable_ascii_chars()`, which includes non-printable ASCII characters based on their ASCII values (0-127).\n- It also uses the helper function `to_str` to ensure that the input is processed as a string.",
        "signature": "def validate_unprintable_char(text: str) -> None:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/_symbol.py": {
      "validate_symbol": {
        "code": "def validate_symbol(text: str) -> None:\n    \"\"\"Verifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for the presence of specified symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbols, as defined by the compiled regex pattern __RE_SYMBOL, are detected in the text.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression pattern that matches characters defined as invalid symbols, including those in the `ascii_symbols` and `unprintable_ascii_chars` collections.\n    - to_str: A utility function that ensures the input is converted to a string format, facilitating validation.\"\"\"\n    '\\n    Verifying whether symbol(s) included in the ``text`` or not.\\n\\n    Args:\\n        text:\\n            Input text to validate.\\n\\n    Raises:\\n        ValidationError (ErrorReason.INVALID_CHARACTER):\\n            If symbol(s) included in the ``text``.\\n    '\n    match_list = __RE_SYMBOL.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f'invalid symbols found: {match_list}')",
        "docstring": "Verifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for the presence of specified symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbols, as defined by the compiled regex pattern __RE_SYMBOL, are detected in the text.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression pattern that matches characters defined as invalid symbols, including those in the `ascii_symbols` and `unprintable_ascii_chars` collections.\n    - to_str: A utility function that ensures the input is converted to a string format, facilitating validation.",
        "signature": "def validate_symbol(text: str) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "replace_symbol": {
        "code": "def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:\n    \"\"\"Replace all symbols in the given `text` with a specified `replacement_text`, allowing for exclusions and modifications.\n\nArgs:\n    text (str): The input text where symbols will be replaced.\n    replacement_text (str, optional): The text to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols to be excluded from replacement.\n    is_replace_consecutive_chars (bool, optional): If set to True, replaces consecutive occurrences of `replacement_text` with a single instance.\n    is_strip (bool, optional): If True, removes leading and trailing occurrences of `replacement_text` from the result.\n\nReturns:\n    str: The modified string with symbols replaced according to the provided options.\n\nThis function utilizes the constant `__RE_SYMBOL`, which is a compiled regular expression for recognizing characters defined as `ascii_symbols` and `unprintable_ascii_chars`. It raises a `TypeError` if the provided `text` is not of string type. The function also makes use of the utility function `to_str` to ensure proper string formatting before processing.\"\"\"\n    '\\n    Replace all of the symbols in the ``text``.\\n\\n    Args:\\n        text:\\n            Input text.\\n        replacement_text:\\n            Replacement text.\\n        exclude_symbols:\\n            Symbols that were excluded from the replacement.\\n        is_replace_consecutive_chars:\\n            If |True|, replace consecutive multiple ``replacement_text`` characters\\n            to a single character.\\n        is_strip:\\n            If |True|, strip ``replacement_text`` from the beginning/end of the replacement text.\\n\\n    Returns:\\n        A replacement string.\\n\\n    Example:\\n\\n        :ref:`example-sanitize-symbol`\\n    '\n    if exclude_symbols:\n        regexp = re.compile('[{}]'.format(re.escape(''.join(set(ascii_symbols + unprintable_ascii_chars) - set(exclude_symbols)))), re.UNICODE)\n    else:\n        regexp = __RE_SYMBOL\n    try:\n        new_text = regexp.sub(replacement_text, to_str(text))\n    except TypeError:\n        raise TypeError('text must be a string')\n    if not replacement_text:\n        return new_text\n    if is_replace_consecutive_chars:\n        new_text = re.sub(f'{re.escape(replacement_text)}+', replacement_text, new_text)\n    if is_strip:\n        new_text = new_text.strip(replacement_text)\n    return new_text",
        "docstring": "Replace all symbols in the given `text` with a specified `replacement_text`, allowing for exclusions and modifications.\n\nArgs:\n    text (str): The input text where symbols will be replaced.\n    replacement_text (str, optional): The text to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols to be excluded from replacement.\n    is_replace_consecutive_chars (bool, optional): If set to True, replaces consecutive occurrences of `replacement_text` with a single instance.\n    is_strip (bool, optional): If True, removes leading and trailing occurrences of `replacement_text` from the result.\n\nReturns:\n    str: The modified string with symbols replaced according to the provided options.\n\nThis function utilizes the constant `__RE_SYMBOL`, which is a compiled regular expression for recognizing characters defined as `ascii_symbols` and `unprintable_ascii_chars`. It raises a `TypeError` if the provided `text` is not of string type. The function also makes use of the utility function `to_str` to ensure proper string formatting before processing.",
        "signature": "def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/error.py": {
      "ValidationError.reason": {
        "code": "    def reason(self) -> ErrorReason:\n        \"\"\"@property\ndef reason(self) -> ErrorReason:\"\"\"\n        '\\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\\n        '\n        return self.__reason",
        "docstring": "@property\ndef reason(self) -> ErrorReason:",
        "signature": "def reason(self) -> ErrorReason:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      },
      "InvalidCharError.__init__": {
        "code": "    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize an instance of the InvalidCharError exception.\n\nThis constructor sets the reason for the exception to indicate that an invalid\ncharacter was encountered. It also accepts standard exception arguments that\ncan be passed to the superclass constructor.\n\nArgs:\n    *args: Variable length argument list that can contain any positional\n        arguments meant for the superclass ValueError.\n    **kwargs: Keyword arguments that can contain additional context for the \n        error. Specifically, the reason for the error is set to \n        ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n        enum. \n\nSide Effects:\n    This initializes the ValidationError with the provided arguments, ensuring \n    that the exception instance correctly represents a validation error due to \n    the inclusion of invalid characters in a string.\"\"\"\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)",
        "docstring": "Initialize an instance of the InvalidCharError exception.\n\nThis constructor sets the reason for the exception to indicate that an invalid\ncharacter was encountered. It also accepts standard exception arguments that\ncan be passed to the superclass constructor.\n\nArgs:\n    *args: Variable length argument list that can contain any positional\n        arguments meant for the superclass ValueError.\n    **kwargs: Keyword arguments that can contain additional context for the \n        error. Specifically, the reason for the error is set to \n        ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n        enum. \n\nSide Effects:\n    This initializes the ValidationError with the provided arguments, ensuring \n    that the exception instance correctly represents a validation error due to \n    the inclusion of invalid characters in a string.",
        "signature": "def __init__(self, *args, **kwargs) -> None:",
        "type": "Method",
        "class_signature": "class InvalidCharError(ValidationError):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: pathvalidate-test_symbol\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pathvalidate/\n    \u251c\u2500\u2500 _common.py\n    \u2502   \u251c\u2500\u2500 to_str\n    \u2502   \u2514\u2500\u2500 validate_unprintable_char\n    \u251c\u2500\u2500 _symbol.py\n    \u2502   \u251c\u2500\u2500 replace_symbol\n    \u2502   \u2514\u2500\u2500 validate_symbol\n    \u2514\u2500\u2500 error.py\n        \u251c\u2500\u2500 InvalidCharError.__init__\n        \u2514\u2500\u2500 ValidationError.reason\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and sanitize strings by identifying and processing problematic characters, such as invalid symbols or unprintable ASCII characters, ensuring they conform to predefined standards. It provides functionality to validate the presence of these characters, replace them with specified alternatives, and customize exclusions or transformations based on user-defined rules. By automating string validation and replacement, the module addresses common challenges faced by developers in handling file paths, user input, or other strings requiring strict character constraints, ultimately enhancing data integrity and preventing errors in downstream systems.\n\n## FILE 1: pathvalidate/_common.py\n\n- FUNCTION NAME: to_str\n  - SIGNATURE: def to_str(name: PathType) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given name of type `PathType` to its string representation.\n\nParameters:\n- name (PathType): A value that can be a string or a `PurePath` instance. The function checks the type of the input and converts it accordingly.\n\nReturns:\n- str: The string representation of the input `name`. If `name` is a `PurePath`, it is converted to a string. If it is already a string, it is returned unchanged.\n\nDependencies:\n- `PathType`: A type alias for input values that can be either strings or `PurePath` instances, indicating the expected data types for the argument.\n- `PurePath`: A class from the `pathlib` module that represents filesystem paths. The function leverages this class to handle path-like objects correctly.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_symbol.py:replace_symbol\n    - pathvalidate/_common.py:validate_unprintable_char\n    - pathvalidate/_symbol.py:validate_symbol\n\n- FUNCTION NAME: validate_unprintable_char\n  - SIGNATURE: def validate_unprintable_char(text: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nRaises an `InvalidCharError` if the input string contains unprintable ASCII characters.\n\nParameters:\n- text (str): The input string to be validated for unprintable characters.\n\nReturns:\n- None: This function does not return a value.\n\nRaises:\n- InvalidCharError: If unprintable characters are found in the input string, an exception is raised detailing the unprintable characters encountered.\n\nDependencies:\n- This function utilizes the constant `__RE_UNPRINTABLE_CHARS`, a regular expression pattern compiled from a list of unprintable ASCII characters. The list is generated by the function `_get_unprintable_ascii_chars()`, which includes non-printable ASCII characters based on their ASCII values (0-127).\n- It also uses the helper function `to_str` to ensure that the input is processed as a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n\n## FILE 2: pathvalidate/_symbol.py\n\n- FUNCTION NAME: replace_symbol\n  - SIGNATURE: def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReplace all symbols in the given `text` with a specified `replacement_text`, allowing for exclusions and modifications.\n\nArgs:\n    text (str): The input text where symbols will be replaced.\n    replacement_text (str, optional): The text to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols to be excluded from replacement.\n    is_replace_consecutive_chars (bool, optional): If set to True, replaces consecutive occurrences of `replacement_text` with a single instance.\n    is_strip (bool, optional): If True, removes leading and trailing occurrences of `replacement_text` from the result.\n\nReturns:\n    str: The modified string with symbols replaced according to the provided options.\n\nThis function utilizes the constant `__RE_SYMBOL`, which is a compiled regular expression for recognizing characters defined as `ascii_symbols` and `unprintable_ascii_chars`. It raises a `TypeError` if the provided `text` is not of string type. The function also makes use of the utility function `to_str` to ensure proper string formatting before processing.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n\n- FUNCTION NAME: validate_symbol\n  - SIGNATURE: def validate_symbol(text: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for the presence of specified symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbols, as defined by the compiled regex pattern __RE_SYMBOL, are detected in the text.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression pattern that matches characters defined as invalid symbols, including those in the `ascii_symbols` and `unprintable_ascii_chars` collections.\n    - to_str: A utility function that ensures the input is converted to a string format, facilitating validation.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n\n## FILE 3: pathvalidate/error.py\n\n- CLASS METHOD: ValidationError.reason\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reason(self) -> ErrorReason:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reason(self) -> ErrorReason:\n\"\"\"\n```\n\n- CLASS METHOD: InvalidCharError.__init__\n  - CLASS SIGNATURE: class InvalidCharError(ValidationError):\n  - SIGNATURE: def __init__(self, *args, **kwargs) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the InvalidCharError exception.\n\nThis constructor sets the reason for the exception to indicate that an invalid\ncharacter was encountered. It also accepts standard exception arguments that\ncan be passed to the superclass constructor.\n\nArgs:\n    *args: Variable length argument list that can contain any positional\n        arguments meant for the superclass ValueError.\n    **kwargs: Keyword arguments that can contain additional context for the \n        error. Specifically, the reason for the error is set to \n        ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n        enum. \n\nSide Effects:\n    This initializes the ValidationError with the provided arguments, ensuring \n    that the exception instance correctly represents a validation error due to \n    the inclusion of invalid characters in a string.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n_re_whitespaces = re.compile('^[\\\\s]+$')\n\ndef validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:\n    from .error import ErrorReason, ValidationError\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n    raise TypeError(f'text must be a string: actual={type(text)}')\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith('\\\\\\\\'):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n    drive, _tail = ntpath.splitdrive(value)\n    return ntpath.isabs(value) and len(drive) > 0\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n    for i in range(128):\n        c = chr(i)\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n        symbol_list.append(c)\n    return symbol_list\nascii_symbols = tuple(_get_ascii_symbols())\n__RE_UNPRINTABLE_CHARS = re.compile('[{}]'.format(re.escape(''.join(unprintable_ascii_chars))), re.UNICODE)\n__RE_ANSI_ESCAPE = re.compile('(?:\\\\x1B[@-Z\\\\\\\\-_]|[\\\\x80-\\\\x9A\\\\x9C-\\\\x9F]|(?:\\\\x1B\\\\[|\\\\x9B)[0-?]*[ -/]*[@-~])')\n\ndef replace_unprintable_char(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef replace_ansi_escape(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n    if not name:\n        return Platform.UNIVERSAL\n    platform_str = name.strip().casefold()\n    if platform_str == 'posix':\n        return Platform.POSIX\n    if platform_str == 'auto':\n        platform_str = platform.system().casefold()\n    if platform_str in ['linux']:\n        return Platform.LINUX\n    if platform_str and platform_str.startswith('win'):\n        return Platform.WINDOWS\n    if platform_str in ['mac', 'macos', 'darwin']:\n        return Platform.MACOS\n    return Platform.UNIVERSAL\n\ndef findall_to_str(match: List[Any]) -> str:\n    return ', '.join([repr(text) for text in match])\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    return str_bytes.decode(encoding, 'ignore')",
    "pathvalidate/_symbol.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport re\nfrom typing import Sequence\nfrom ._common import ascii_symbols, to_str, unprintable_ascii_chars\nfrom .error import InvalidCharError\n__RE_SYMBOL = re.compile('[{}]'.format(re.escape(''.join(ascii_symbols + unprintable_ascii_chars))), re.UNICODE)",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport enum\nfrom typing import Dict, Optional\nfrom ._const import Platform\n\ndef _to_error_code(code: int) -> str:\n    return f'PV{code:04d}'\n\nclass ErrorAttrKey:\n    BYTE_COUNT = 'byte_count'\n    DESCRIPTION = 'description'\n    FS_ENCODING = 'fs_encoding'\n    PLATFORM = 'platform'\n    REASON = 'reason'\n    RESERVED_NAME = 'reserved_name'\n    REUSABLE_NAME = 'reusable_name'\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n    NULL_NAME = (_to_error_code(1001), 'NULL_NAME', 'the value must not be an empty string')\n    RESERVED_NAME = (_to_error_code(1002), 'RESERVED_NAME', 'found a reserved name by a platform')\n    INVALID_CHARACTER = (_to_error_code(1100), 'INVALID_CHARACTER', 'invalid characters found')\n    INVALID_LENGTH = (_to_error_code(1101), 'INVALID_LENGTH', 'found an invalid string length')\n    FOUND_ABS_PATH = (_to_error_code(1200), 'FOUND_ABS_PATH', 'found an absolute path where must be a relative path')\n    MALFORMED_ABS_PATH = (_to_error_code(1201), 'MALFORMED_ABS_PATH', 'found a malformed absolute path')\n    INVALID_AFTER_SANITIZE = (_to_error_code(2000), 'INVALID_AFTER_SANITIZE', 'found invalid value after sanitizing')\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f'[{self.__code}] {self.__description}'\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f'{ErrorAttrKey.REASON} must be specified')\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, '')\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n        slog: Dict[str, str] = {'code': self.reason.code, ErrorAttrKey.DESCRIPTION: self.reason.description}\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n        if self.platform:\n            item_list.append(f'{ErrorAttrKey.PLATFORM}={self.platform.value}')\n        if self.description:\n            item_list.append(f'{ErrorAttrKey.DESCRIPTION}={self.description}')\n        if self.__reusable_name is not None:\n            item_list.append(f'{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}')\n        if self.__fs_encoding:\n            item_list.append(f'{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}')\n        if self.__byte_count is not None:\n            item_list.append(f'{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}')\n        if item_list:\n            header += ': '\n        return header + ', '.join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n        super().__init__(args, **kwargs)\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n        super().__init__(args, **kwargs)\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n        super().__init__(args, **kwargs)\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n        super().__init__(args, **kwargs)"
  },
  "call_tree": {
    "test/test_symbol.py:Test_validate_symbol:test_normal": {
      "pathvalidate/_symbol.py:validate_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_symbol:test_exception_invalid_char": {
      "pathvalidate/_symbol.py:validate_symbol": {
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal_exclude_symbols": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal_consecutive": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_abnormal": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_unprintable_char:test_normal": {
      "pathvalidate/_common.py:validate_unprintable_char": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_unprintable_char:test_exception_invalid_char": {
      "pathvalidate/_common.py:validate_unprintable_char": {
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    }
  }
}