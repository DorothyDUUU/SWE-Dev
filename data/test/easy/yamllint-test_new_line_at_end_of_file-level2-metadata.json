{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_new_line_at_end_of_file",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/rules/test_new_line_at_end_of_file.py",
  "test_code": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom tests.common import RuleTestCase\n\n\nclass NewLineAtEndOfFileTestCase(RuleTestCase):\n    rule_id = 'new-line-at-end-of-file'\n\n    def test_disabled(self):\n        conf = ('new-line-at-end-of-file: disable\\n'\n                'empty-lines: disable\\n'\n                'document-start: disable\\n')\n        self.check('', conf)\n        self.check('\\n', conf)\n        self.check('word', conf)\n        self.check('Sentence.\\n', conf)\n\n    def test_enabled(self):\n        conf = ('new-line-at-end-of-file: enable\\n'\n                'empty-lines: disable\\n'\n                'document-start: disable\\n')\n        self.check('', conf)\n        self.check('\\n', conf)\n        self.check('word', conf, problem=(1, 5))\n        self.check('Sentence.\\n', conf)\n        self.check('---\\n'\n                   'yaml: document\\n'\n                   '...', conf, problem=(3, 4))\n",
  "GT_file_code": {
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem instance, which represents a linting issue found by the yamllint tool.\n\nParameters:\n- line (int): The line number (starting at 1) where the problem was detected.\n- column (int): The column number (starting at 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem, defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem, defaults to None.\n\nAttributes:\n- level (int or None): Represents the severity level of the linting problem, though it is initialized to None. This will be set later based on the rule that detected the problem.\n\nThis class interacts with the LintProblem's methods and may be used in functions such as get_cosmetic_problems and _run, where instances of LintProblem are created to store linting issues identified in YAML files.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem instance, which represents a linting issue found by the yamllint tool.\n\nParameters:\n- line (int): The line number (starting at 1) where the problem was detected.\n- column (int): The column number (starting at 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem, defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem, defaults to None.\n\nAttributes:\n- level (int or None): Represents the severity level of the linting problem, though it is initialized to None. This will be set later based on the rule that detected the problem.\n\nThis class interacts with the LintProblem's methods and may be used in functions such as get_cosmetic_problems and _run, where instances of LintProblem are created to store linting issues identified in YAML files.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two LintProblem instances.\n\nCompares the line number, column number, and rule identifier of the current instance with another LintProblem instance to determine if they represent the same linting issue. \n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if both LintProblem instances have the same line, column, and rule; otherwise, False.\n\nThis method is essential for managing collections of LintProblem instances where uniqueness matters.\"\"\"\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)",
        "docstring": "Checks for equality between two LintProblem instances.\n\nCompares the line number, column number, and rule identifier of the current instance with another LintProblem instance to determine if they represent the same linting issue. \n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if both LintProblem instances have the same line, column, and rule; otherwise, False.\n\nThis method is essential for managing collections of LintProblem instances where uniqueness matters.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "_run": {
        "code": "def _run(buffer, conf, filepath):\n    \"\"\"Runs the linting process on a given YAML source buffer, utilizing specified configuration settings.\n\nParameters:\n- buffer: A buffer-like object that supports indexing, expected to contain the YAML content for linting.\n- conf: A configuration object that provides linting rules and settings for the YAML content.\n- filepath: Optional string specifying the filename of the YAML being processed, used to check if the file is ignored by the configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the buffer.\n\nThe function first checks if the initial comment in the buffer contains a directive to disable file-wide linting. It then uses the `get_syntax_error` function to identify any syntax errors present and stores the result. The `get_cosmetic_problems` function is called to generate linting problems based on the configured rules. Any syntax errors are yielded at the correct position relative to the cosmetic problems. This function interacts with the `parser` to read the buffer and utilizes regular expressions from the `re` module to process directives correctly. If a syntax error occurs, it ensures that it is represented accurately in the output, potentially overriding cosmetic problems at the same location.\"\"\"\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
        "docstring": "Runs the linting process on a given YAML source buffer, utilizing specified configuration settings.\n\nParameters:\n- buffer: A buffer-like object that supports indexing, expected to contain the YAML content for linting.\n- conf: A configuration object that provides linting rules and settings for the YAML content.\n- filepath: Optional string specifying the filename of the YAML being processed, used to check if the file is ignored by the configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the buffer.\n\nThe function first checks if the initial comment in the buffer contains a directive to disable file-wide linting. It then uses the `get_syntax_error` function to identify any syntax errors present and stores the result. The `get_cosmetic_problems` function is called to generate linting problems based on the configured rules. Any syntax errors are yielded at the correct position relative to the cosmetic problems. This function interacts with the `parser` to read the buffer and utilizes regular expressions from the `re` module to process directives correctly. If a syntax error occurs, it ensures that it is represented accurately in the output, potentially overriding cosmetic problems at the same location.",
        "signature": "def _run(buffer, conf, filepath):",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source by checking it against specified rules and syntax.\n\nThis function returns a generator that yields `LintProblem` objects for any issues found in the provided YAML input. It checks whether the given file is ignored by the configuration and handles different input types, including strings, bytes, and file streams. Syntax errors are identified and yielded at their respective line positions. This function relies on the `_run` helper function to perform the linting logic.\n\nParameters:\n- input: The buffer, string, or stream to read from, representing the YAML content to be linted.\n- conf: The yamllint configuration object containing the rules and settings for linting.\n- filepath: An optional string representing the path of the file being linted, used to determine if the file is ignored in the configuration.\n\nReturns:\n- A generator of `LintProblem` objects, encapsulating any linting issues found.\n\nRaises:\n- TypeError: If the input is neither a string nor a stream.\n\nDependencies:\n- This function leverages the `_run` function which contains the detailed logic for linting, and it interacts with the `LintProblem` class to structure the output of linting errors.\n- The `PROBLEM_LEVELS` constant imported at the beginning is relevant for defining the severity levels of linting problems but is not directly used in this function.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source by checking it against specified rules and syntax.\n\nThis function returns a generator that yields `LintProblem` objects for any issues found in the provided YAML input. It checks whether the given file is ignored by the configuration and handles different input types, including strings, bytes, and file streams. Syntax errors are identified and yielded at their respective line positions. This function relies on the `_run` helper function to perform the linting logic.\n\nParameters:\n- input: The buffer, string, or stream to read from, representing the YAML content to be linted.\n- conf: The yamllint configuration object containing the rules and settings for linting.\n- filepath: An optional string representing the path of the file being linted, used to determine if the file is ignored in the configuration.\n\nReturns:\n- A generator of `LintProblem` objects, encapsulating any linting issues found.\n\nRaises:\n- TypeError: If the input is neither a string nor a stream.\n\nDependencies:\n- This function leverages the `_run` function which contains the detailed logic for linting, and it interacts with the `LintProblem` class to structure the output of linting errors.\n- The `PROBLEM_LEVELS` constant imported at the beginning is relevant for defining the severity levels of linting problems but is not directly used in this function.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:_run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      },
      "yamllint/parser.py": {
        "Line.content": {
          "code": "    def content(self):\n        return self.buffer[self.start:self.end]",
          "docstring": "",
          "signature": "def content(self):",
          "type": "Method",
          "class_signature": "class Line:"
        },
        "line_generator": {
          "code": "def line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))",
          "docstring": "",
          "signature": "def line_generator(buffer):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/linter.py": {
        "get_cosmetic_problems": {
          "code": "def get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []",
          "docstring": "",
          "signature": "def get_cosmetic_problems(buffer, conf, filepath):",
          "type": "Function",
          "class_signature": null
        },
        "get_syntax_error": {
          "code": "def get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
          "docstring": "",
          "signature": "def get_syntax_error(buffer):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/linter.py:LintProblem:__init__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__eq__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/rules/test_new_line_at_end_of_file.py:NewLineAtEndOfFileTestCase:test_disabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {
                "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
              }
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {},
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {},
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        }
      }
    },
    "modified_testcases/rules/test_new_line_at_end_of_file.py:NewLineAtEndOfFileTestCase:test_enabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_new_line_at_end_of_file/yamllint-test_new_line_at_end_of_file/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_new_line_at_end_of_file/yamllint-test_new_line_at_end_of_file/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_new_line_at_end_of_file\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__eq__\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 _run\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module enforces and validates a specific formatting rule within files: ensuring the presence or absence of a newline at the end of a file, depending on the configuration. It provides functionality to enable or disable this rule and identifies instances where the rule is violated, returning the line and column numbers of the issue. By automating the detection of newline-related formatting inconsistencies, the module supports developers in adhering to predefined coding standards, improving code maintainability and consistency across projects. This contributes to streamlined development workflows by reducing manual validation effort.\n\n## FILE 1: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source by checking it against specified rules and syntax.\n\nThis function returns a generator that yields `LintProblem` objects for any issues found in the provided YAML input. It checks whether the given file is ignored by the configuration and handles different input types, including strings, bytes, and file streams. Syntax errors are identified and yielded at their respective line positions. This function relies on the `_run` helper function to perform the linting logic.\n\nParameters:\n- input: The buffer, string, or stream to read from, representing the YAML content to be linted.\n- conf: The yamllint configuration object containing the rules and settings for linting.\n- filepath: An optional string representing the path of the file being linted, used to determine if the file is ignored in the configuration.\n\nReturns:\n- A generator of `LintProblem` objects, encapsulating any linting issues found.\n\nRaises:\n- TypeError: If the input is neither a string nor a stream.\n\nDependencies:\n- This function leverages the `_run` function which contains the detailed logic for linting, and it interacts with the `LintProblem` class to structure the output of linting errors.\n- The `PROBLEM_LEVELS` constant imported at the beginning is relevant for defining the severity levels of linting problems but is not directly used in this function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem instance, which represents a linting issue found by the yamllint tool.\n\nParameters:\n- line (int): The line number (starting at 1) where the problem was detected.\n- column (int): The column number (starting at 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem, defaults to '<no description>'.\n- rule (str, optional): The identifier of the rule that detected the problem, defaults to None.\n\nAttributes:\n- level (int or None): Represents the severity level of the linting problem, though it is initialized to None. This will be set later based on the rule that detected the problem.\n\nThis class interacts with the LintProblem's methods and may be used in functions such as get_cosmetic_problems and _run, where instances of LintProblem are created to store linting issues identified in YAML files.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__eq__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two LintProblem instances.\n\nCompares the line number, column number, and rule identifier of the current instance with another LintProblem instance to determine if they represent the same linting issue. \n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if both LintProblem instances have the same line, column, and rule; otherwise, False.\n\nThis method is essential for managing collections of LintProblem instances where uniqueness matters.\n\"\"\"\n```\n\n- FUNCTION NAME: _run\n  - SIGNATURE: def _run(buffer, conf, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nRuns the linting process on a given YAML source buffer, utilizing specified configuration settings.\n\nParameters:\n- buffer: A buffer-like object that supports indexing, expected to contain the YAML content for linting.\n- conf: A configuration object that provides linting rules and settings for the YAML content.\n- filepath: Optional string specifying the filename of the YAML being processed, used to check if the file is ignored by the configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the buffer.\n\nThe function first checks if the initial comment in the buffer contains a directive to disable file-wide linting. It then uses the `get_syntax_error` function to identify any syntax errors present and stores the result. The `get_cosmetic_problems` function is called to generate linting problems based on the configured rules. Any syntax errors are yielded at the correct position relative to the cosmetic problems. This function interacts with the `parser` to read the buffer and utilizes regular expressions from the `re` module to process directives correctly. If a syntax error occurs, it ensures that it is represented accurately in the output, potentially overriding cosmetic problems at the same location.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n    - yamllint/parser.py:Line:content\n    - yamllint/parser.py:line_generator\n    - yamllint/linter.py:get_cosmetic_problems\n    - yamllint/linter.py:get_syntax_error\n\n## FILE 2: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __lt__(self, other):\n        return self.line < other.line or (self.line == other.line and self.column < other.column)\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}