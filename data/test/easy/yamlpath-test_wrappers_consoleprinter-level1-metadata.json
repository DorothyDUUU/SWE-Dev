{
  "dir_path": "/app/yamlpath",
  "package_name": "yamlpath",
  "sample_name": "yamlpath-test_wrappers_consoleprinter",
  "src_dir": "yamlpath/",
  "test_dir": "tests/",
  "test_file": "tests/test_wrappers_consoleprinter.py",
  "test_code": "import pytest\n\nfrom types import SimpleNamespace\n\nfrom ruamel.yaml.comments import CommentedMap, CommentedSeq, CommentedSet, TaggedScalar\nfrom ruamel.yaml.scalarstring import PlainScalarString, FoldedScalarString\nfrom ruamel.yaml import version_info as ryversion\nif ryversion < (0, 17, 22):                   # pragma: no cover\n    from yamlpath.patches.timestamp import (\n        AnchoredTimeStamp,\n        AnchoredDate,\n    )  # type: ignore\nelse:                                         # pragma: no cover\n    # Temporarily fool MYPY into resolving the future-case imports\n    from ruamel.yaml.timestamp import TimeStamp as AnchoredTimeStamp\n    AnchoredDate = AnchoredTimeStamp\n    #from ruamel.yaml.timestamp import AnchoredTimeStamp\n    # From whence shall come AnchoredDate?\n\nfrom yamlpath.enums import PathSegmentTypes\nfrom yamlpath.wrappers import NodeCoords, ConsolePrinter\nfrom yamlpath import YAMLPath\n\nclass Test_wrappers_ConsolePrinter():\n    def test_info_noisy(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.info(\"Test\")\n        console = capsys.readouterr()\n        assert console.out == \"Test\\n\"\n\n    def test_info_quiet(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        logger.info(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_verbose_off(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.verbose(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_verbose_noisy(self, capsys):\n        args = SimpleNamespace(verbose=True, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.verbose(\"Test\")\n        console = capsys.readouterr()\n        assert console.out == \"Test\\n\"\n\n    def test_verbose_quiet(self, capsys):\n        args = SimpleNamespace(verbose=True, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        logger.verbose(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_debug_off(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.debug(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_debug_noisy(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=True)\n        logger = ConsolePrinter(args)\n        anchoredkey = PlainScalarString(\"TestKey\", anchor=\"KeyAnchor\")\n        anchoredval = PlainScalarString(\"TestVal\", anchor=\"Anchor\")\n        foldedstr = \"123456789 123456789 123456789\"\n        foldedstrfolds = [10, 20]\n        foldedval = FoldedScalarString(foldedstr)\n        foldedval.fold_pos = foldedstrfolds\n\n        logger.debug(anchoredval)\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  (&Anchor)TestVal\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug([\"test\", anchoredval])\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [0]test<class 'str'>\",\n            \"DEBUG:  [1](&Anchor)TestVal<class 'ruamel.yaml.scalarstring.PlainScalarString'>\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug({\"date\": AnchoredDate(2022, 9, 23), \"timestamp\": AnchoredTimeStamp(2022, 9, 25, 1, 2, 3, 40000)})\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [date]2022-09-23<class 'yamlpath.patches.timestamp.AnchoredDate'>\",\n            \"DEBUG:  [timestamp]2022-09-25T01:02:03.040000<class 'yamlpath.patches.timestamp.AnchoredTimeStamp'>\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug({\"ichi\": 1, anchoredkey: anchoredval})\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [ichi]1<class 'int'>\",\n            \"DEBUG:  [TestKey](&KeyAnchor,&Anchor)TestVal<class 'ruamel.yaml.scalarstring.PlainScalarString'>\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug({\"ichi\": 1, anchoredkey: \"non-anchored value\"})\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [ichi]1<class 'int'>\",\n            \"DEBUG:  [TestKey](&KeyAnchor,_)non-anchored value<class 'str'>\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug({\"ichi\": 1, \"non-anchored-key\": anchoredval})\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [ichi]1<class 'int'>\",\n            \"DEBUG:  [non-anchored-key](_,&Anchor)TestVal<class 'ruamel.yaml.scalarstring.PlainScalarString'>\",\n        ]) + \"\\n\" == console.out\n\n        tagged_value = \"value\"\n        tagged_value_node = TaggedScalar(tagged_value, tag=\"!tag\")\n        tagged_sequence = CommentedSeq([\"a\", \"b\"])\n        tagged_sequence.yaml_set_tag(\"!raz\")\n        selfref_value = \"self_referring\"\n        selfref_value_node = TaggedScalar(selfref_value, tag=\"!self_referring\")\n        logger.debug(\n            \"test_wrappers_consoleprinter:\",\n            prefix=\"test_debug_noisy:  \",\n            header=\"--- HEADER ---\",\n            footer=\"=== FOOTER ===\",\n            data_header=\"+++ DATA HEADER +++\",\n            data_footer=\"::: DATA FOOTER :::\",\n            data=CommentedMap({\n                \"key\": \"value\",\n                \"tagged\": tagged_value_node,\n                tagged_value_node: \"untagged value\",\n                selfref_value_node: selfref_value_node,\n                \"array\": [\"ichi\", \"ni\", \"san\"],\n                \"tagged_array\": tagged_sequence,\n                \"aoh\": [{\"id\": 1},{\"id\": 2},{\"id\": 3}],\n                \"aoa\": [[True, True], [True, False], [False, True]],\n                \"dod\": {\"a\": {\"b\": {\"c\": \"d\"}}},\n                \"set\": CommentedSet([\"one\", \"two\"]),\n            })\n        )\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  test_debug_noisy:  --- HEADER ---\",\n            \"DEBUG:  test_debug_noisy:  test_wrappers_consoleprinter:\",\n            \"DEBUG:  test_debug_noisy:  +++ DATA HEADER +++\",\n            \"DEBUG:  test_debug_noisy:  [key]value<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [tagged]<_,!tag>value<class 'ruamel.yaml.comments.TaggedScalar'>(<class 'str'>)\",\n            \"DEBUG:  test_debug_noisy:  [value]<!tag,_>untagged value<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [self_referring]<!self_referring,!self_referring>self_referring<class 'ruamel.yaml.comments.TaggedScalar'>(<class 'str'>)\",\n            \"DEBUG:  test_debug_noisy:  [array][0]ichi<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [array][1]ni<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [array][2]san<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [tagged_array]<_,!raz>[0]a<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [tagged_array]<_,!raz>[1]b<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [aoh][0][id]1<class 'int'>\",\n            \"DEBUG:  test_debug_noisy:  [aoh][1][id]2<class 'int'>\",\n            \"DEBUG:  test_debug_noisy:  [aoh][2][id]3<class 'int'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][0][0]True<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][0][1]True<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][1][0]True<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][1][1]False<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][2][0]False<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [aoa][2][1]True<class 'bool'>\",\n            \"DEBUG:  test_debug_noisy:  [dod][a][b][c]d<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [set]{one}<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  [set]{two}<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  ::: DATA FOOTER :::\",\n            \"DEBUG:  test_debug_noisy:  === FOOTER ===\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug(tagged_value_node)\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  <!tag>value<class 'ruamel.yaml.comments.TaggedScalar'>(<class 'str'>)\",\n        ])\n\n        logger.debug(tagged_sequence)\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  [tagged_array]<!raz>[0]a<class 'str'>\",\n            \"DEBUG:  [tagged_array]<!raz>[1]b<class 'str'>\",\n        ])\n\n        nc = NodeCoords(\n            \"value\",\n            dict(key=\"value\"),\n            \"key\",\n            YAMLPath(\"doc_root.key\"),\n            [   (dict(doc_root=dict(key=\"value\")), \"doc_root\"),\n                (dict(key=\"value\"), \"key\")],\n            (PathSegmentTypes.KEY, \"key\")\n        )\n        logger.debug(\n            \"A node coordinate:\", prefix=\"test_debug_noisy:  \", data=nc)\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  test_debug_noisy:  A node coordinate:\",\n            \"DEBUG:  test_debug_noisy:  (path)doc_root.key\",\n            \"DEBUG:  test_debug_noisy:  (segment)[0]PathSegmentTypes.KEY<enum 'PathSegmentTypes'>\",\n            \"DEBUG:  test_debug_noisy:  (segment)[1]key<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  (node)value\",\n            \"DEBUG:  test_debug_noisy:  (parent)[key]value<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  (parentref)key\",\n            \"DEBUG:  test_debug_noisy:  (ancestry)[0][0][doc_root][key]value<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  (ancestry)[0][1]doc_root<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  (ancestry)[1][0][key]value<class 'str'>\",\n            \"DEBUG:  test_debug_noisy:  (ancestry)[1][1]key<class 'str'>\",\n        ]) + \"\\n\" == console.out\n\n        logger.debug(foldedval)\n        console = capsys.readouterr()\n        assert \"\\n\".join([\n            \"DEBUG:  {}<class 'ruamel.yaml.scalarstring.FoldedScalarString'>,folded@{}\".format(foldedstr, foldedstrfolds)\n        ])\n\n    def test_debug_quiet(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=True)\n        logger = ConsolePrinter(args)\n        logger.debug(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_warning_noisy(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.warning(\"Test\")\n        console = capsys.readouterr()\n        assert console.out == \"WARNING:  Test\\n\"\n\n    def test_warning_quiet(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        logger.warning(\"Test\")\n        console = capsys.readouterr()\n        assert not console.out\n\n    def test_error_noisy_nonexit(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        logger.error(\"Test\")\n        console = capsys.readouterr()\n        assert console.err == \"ERROR:  Test\\n\"\n\n    def test_error_quiet_nonexit(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        logger.error(\"Test\")\n        console = capsys.readouterr()\n        assert console.err == \"ERROR:  Test\\n\"\n\n    def test_error_noisy_exit(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        with pytest.raises(SystemExit):\n            logger.error(\"Test\", 27)\n            console = capsys.readouterr()\n            assert console.err == \"ERROR:  Test\\n\"\n\n    def test_error_quiet_exit(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        with pytest.raises(SystemExit):\n            logger.error(\"Test\", 27)\n            console = capsys.readouterr()\n            assert console.err == \"ERROR:  Test\\n\"\n\n    def test_critical_noisy(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=False, debug=False)\n        logger = ConsolePrinter(args)\n        with pytest.raises(SystemExit):\n            logger.critical(\"Test\")\n            console = capsys.readouterr()\n            assert console.err == \"CRITICAL:  Test\\n\"\n\n    def test_critical_quiet(self, capsys):\n        args = SimpleNamespace(verbose=False, quiet=True, debug=False)\n        logger = ConsolePrinter(args)\n        with pytest.raises(SystemExit):\n            logger.critical(\"Test\")\n            console = capsys.readouterr()\n            assert console.err == \"CRITICAL:  Test\\n\"\n",
  "GT_file_code": {
    "yamlpath/wrappers/consoleprinter.py": "\"\"\"\nImplements a reusable console print facility for simple command-line scripts.\n\nOther implementations can easily wrap Python's standard logger/warning modules,\nbut this one does not because those are overkill for *simple* STDOUT/STDERR\nprinting (that must support squelching).\n\nRequires an object on init which has the following properties:\n  quiet:  <Boolean> suppresses all output except ConsolePrinter::error() and\n          ::critical().\n  verbose:  <Boolean> allows output from ConsolePrinter::verbose().\n  debug:  <Boolean> allows output from ConsolePrinter::debug().\n\nCopyright 2018, 2019, 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nimport sys\nfrom collections import deque\nfrom typing import Any, Deque, Dict, Generator, List, Set, Tuple, Union\n\nfrom ruamel.yaml.comments import (\n    CommentedBase,\n    CommentedMap,\n    CommentedSet,\n    TaggedScalar\n)\nfrom yamlpath.patches.timestamp import (\n    AnchoredTimeStamp,\n    AnchoredDate,\n)\n\nfrom yamlpath.wrappers.nodecoords import NodeCoords\n\n\nclass ConsolePrinter:\n    \"\"\"\n    Generally-useful console messager.\n\n    Writes INFO, VERBOSE, WARN, and DEBUG messages to STDOUT as well as ERROR\n    messages to STDERR with multi-lne formatting.\n    \"\"\"\n\n    def __init__(self, args):\n        \"\"\"\n        Instantiate a ConsolePrinter.\n\n        Positional Parameters:\n        1. args (object) An object representing log level settings with these\n           properties:\n            - debug (Boolean) true = write debugging informational messages\n            - verbose (Boolean) true = write verbose informational messages\n            - quiet (Boolean) true = write only error messages\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        self.args = args\n\n    def info(self, message):\n        \"\"\"\n        Write an informational message to STDOUT unless quiet mode is active.\n\n        Positional Parameters:\n        1. message (str) The message to print\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        if not self.args.quiet:\n            print(message)\n\n    def verbose(self, message):\n        \"\"\"\n        Write a verbose message to STDOUT.\n\n        Writes only when verbose mode is active unless quiet mode is active.\n\n        Positional Parameters:\n        1. message (str) The message to print\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        if not self.args.quiet and (self.args.verbose or self.args.debug):\n            print(message)\n\n    def warning(self, message):\n        \"\"\"\n        Write a warning message to STDOUT unless quiet mode is active.\n\n        Positional Parameters:\n        1. message (str) The message to print\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        if not self.args.quiet:\n            print(\"WARNING:  \" + str(message).replace(\"\\n\", \"\\nWARNING:  \"))\n\n    def error(self, message, exit_code=None):\n        \"\"\"\n        Write a recoverable error message to STDERR.\n\n        Optionally terminates the program, exiting with a specific error code.\n\n        Positional Parameters:\n        1. message (str) The message to print\n        2. exit_code (int) The exit code to terminate the program with;\n           default=None\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        print(\n            \"ERROR:  \" + str(message).replace(\"\\n\", \"\\nERROR:  \"),\n            file=sys.stderr\n        )\n        print(\"Please try --help for more information.\")\n        sys.stdout.flush()\n\n        # Optionally terminate program execution with a specified exit code\n        if exit_code is not None:\n            self.debug(\"Terminating with exit code, {}.\".format(exit_code))\n            sys.exit(exit_code)\n\n    def critical(self, message, exit_code=1):\n        \"\"\"\n        Write a critical, nonrecoverable failure message to STDERR and abend.\n\n        Terminates the program, exiting with a specific error code.\n\n        Positional Parameters:\n        1. message (str) The message to print\n        2. exit_code (int) The exit code to terminate the program with;\n           default=1\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        print(\n            \"CRITICAL:  \" + str(message).replace(\"\\n\", \"\\nCRITICAL:  \"),\n            file=sys.stderr\n        )\n        sys.stdout.flush()\n\n        # Terminate program execution with a specified exit code\n        self.debug(\"Terminating with exit code, {}.\".format(exit_code))\n        sys.exit(exit_code)\n\n    def debug(self, message, **kwargs):\n        \"\"\"\n        Write a debug message to STDOUT unless quiet mode is active.\n\n        Dumps all key-value pairs of a dictionary or all elements of a list,\n        when the message is either.\n\n        Positional Parameters:\n        1. message (str) The message to print\n\n        Keyword Arguments:\n        * data (Any) Data to recursively add to the DEBUG message\n        * header (str) Line printed before the body of the DEBUG message\n        * footer (str) Line printed after the body of the DEBUG message\n        * prefix (str) String prefixed to every DEBUG line comprising the\n          entirety of the DEBUG message, including any optional data\n        * data_header (str) Line printed before the optional data, if any\n        * data_footer (str) Line printed after the optional data, if any\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        if self.args.debug and not self.args.quiet:\n            header = kwargs.pop(\"header\", \"\")\n            footer = kwargs.pop(\"footer\", \"\")\n            prefix = kwargs.pop(\"prefix\", \"\")\n\n            if header:\n                print(ConsolePrinter._debug_prefix_lines(\n                    \"{}{}\".format(prefix, header)))\n\n            for line in ConsolePrinter._debug_dump(message, prefix=prefix):\n                print(line)\n\n            if \"data\" in kwargs:\n                data_header = kwargs.pop(\"data_header\", \"\")\n                data_footer = kwargs.pop(\"data_footer\", \"\")\n\n                if data_header:\n                    print(ConsolePrinter._debug_prefix_lines(\n                        \"{}{}\".format(prefix, data_header)))\n\n                for line in ConsolePrinter._debug_dump(\n                    kwargs.pop(\"data\"), prefix=prefix, print_type=True\n                ):\n                    print(line)\n\n                if data_footer:\n                    print(ConsolePrinter._debug_prefix_lines(\n                        \"{}{}\".format(prefix, data_footer)))\n\n            if footer:\n                print(ConsolePrinter._debug_prefix_lines(\n                    \"{}{}\".format(prefix, footer)))\n\n    @staticmethod\n    def _debug_prefix_lines(line: str) -> str:\n        return \"DEBUG:  {}\".format(str(line).replace(\"\\n\", \"\\nDEBUG:  \"))\n\n    @staticmethod\n    def _debug_get_anchor(data: Any) -> str:\n        return (\"&{}\".format(data.anchor.value)\n                if (hasattr(data, \"anchor\")\n                    and hasattr(data.anchor, \"value\")\n                    and data.anchor.value is not None)\n                else \"\")\n\n    @staticmethod\n    def _debug_get_tag(data: Any) -> str:\n        return str(data.tag.value\n                if (hasattr(data, \"tag\")\n                    and hasattr(data.tag, \"value\")\n                    and data.tag.value is not None)\n                else \"\")\n\n    @staticmethod\n    def _debug_dump(data: Any, **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop(\"prefix\", \"\")\n        if isinstance(data, dict):\n            for line in ConsolePrinter._debug_dict(\n                data, prefix=prefix, **kwargs\n            ):\n                yield line\n        elif isinstance(data, (list, tuple, deque)):\n            for line in ConsolePrinter._debug_list(\n                data, prefix=prefix, **kwargs\n            ):\n                yield line\n        elif isinstance(data, (set, CommentedSet)):\n            for line in ConsolePrinter._debug_set(\n                data, prefix=prefix, **kwargs\n            ):\n                yield line\n        elif isinstance(data, NodeCoords):\n            for line in ConsolePrinter._debug_node_coord(\n                data, prefix=prefix, **kwargs\n            ):\n                yield line\n        else:\n            yield ConsolePrinter._debug_scalar(data, prefix=prefix, **kwargs)\n\n    @staticmethod\n    def _debug_scalar(data: Any, **kwargs) -> str:\n        prefix = kwargs.pop(\"prefix\", \"\")\n        print_anchor = kwargs.pop(\"print_anchor\", True)\n        print_tag = kwargs.pop(\"print_tag\", True)\n        print_type = kwargs.pop(\"print_type\", False)\n        dtype: str = str(type(data)) if print_type else \"\"\n        anchor_prefix = \"\"\n        print_prefix = prefix\n\n        if print_anchor:\n            anchor = ConsolePrinter._debug_get_anchor(data)\n            if anchor:\n                anchor_prefix = \"({})\".format(anchor)\n\n        if print_tag:\n            if isinstance(data, TaggedScalar):\n                tag_prefix = \"{}{}<{}>\".format(\n                    print_prefix, anchor_prefix, data.tag.value)\n                return ConsolePrinter._debug_scalar(\n                        data.value, prefix=tag_prefix,\n                        print_anchor=False, print_tag=False, print_type=True)\n\n        # The \"true\" type of the value is nested in TaggedScalar.value\n        if isinstance(data, TaggedScalar):\n            dtype = \"{}({})\".format(dtype, type(data.value))\n\n        # Report fold points, if present\n        if hasattr(data, \"fold_pos\"):\n            dtype += \",folded@{}\".format(data.fold_pos)\n\n        print_prefix += anchor_prefix\n\n        if isinstance(data, AnchoredDate):\n            print_line = data.date().isoformat()\n        elif isinstance(data, AnchoredTimeStamp):\n            # Import loop occurs when this import is moved to the top because\n            # NodeCoords uses Nodes which uses NodeCoords\n            #pylint: disable=import-outside-toplevel\n            from yamlpath.common.nodes import Nodes\n            print_line = Nodes.get_timestamp_with_tzinfo(data).isoformat()\n        else:\n            print_line = str(data).replace(\"\\n\", \"\\n{}\".format(print_prefix))\n\n        return ConsolePrinter._debug_prefix_lines(\n            \"{}{}{}\".format(print_prefix, print_line, dtype))\n\n    @staticmethod\n    def _debug_node_coord(\n        data: NodeCoords, **kwargs\n    ) -> Generator[str, None, None]:\n        prefix = kwargs.pop(\"prefix\", \"\")\n        path_prefix = \"{}(path)\".format(prefix)\n        segment_prefix = \"{}(segment)\".format(prefix)\n        node_prefix = \"{}(node)\".format(prefix)\n        parent_prefix = \"{}(parent)\".format(prefix)\n        parentref_prefix = \"{}(parentref)\".format(prefix)\n        ancestry_prefix = \"{}(ancestry)\".format(prefix)\n\n        for line in ConsolePrinter._debug_dump(data.path, prefix=path_prefix):\n            yield line\n\n        for line in ConsolePrinter._debug_dump(\n            data.path_segment, prefix=segment_prefix\n        ):\n            yield line\n\n        for line in ConsolePrinter._debug_dump(data.node, prefix=node_prefix):\n            yield line\n\n        for line in ConsolePrinter._debug_dump(\n            data.parent, prefix=parent_prefix\n        ):\n            yield line\n\n        for line in ConsolePrinter._debug_dump(\n            data.parentref, prefix=parentref_prefix\n        ):\n            yield line\n\n        for line in ConsolePrinter._debug_dump(\n            data.ancestry, prefix=ancestry_prefix\n        ):\n            yield line\n\n    @staticmethod\n    def _debug_list(\n        data: Union[List[Any], Set[Any], Tuple[Any, ...], Deque[Any]], **kwargs\n    ) -> Generator[str, None, None]:\n        prefix = kwargs.pop(\"prefix\", \"\")\n        print_tag = kwargs.pop(\"print_tag\", True)\n\n        if (print_tag\n            and isinstance(data, (CommentedBase, CommentedSet))\n            and hasattr(data, \"tag\")\n            and data.tag.value\n        ):\n            prefix += \"<{}>\".format(data.tag.value)\n\n        for idx, ele in enumerate(data):\n            ele_prefix = \"{}[{}]\".format(prefix, idx)\n\n            # if (isinstance(data, (CommentedBase, CommentedSet))\n            #     and hasattr(ele, \"tag\")\n            #     and ele.tag.value\n            # ):\n            #     ele_prefix += \"<{}>\".format(ele.tag.value)\n\n            for line in ConsolePrinter._debug_dump(\n                ele, prefix=ele_prefix, print_anchor=True, print_tag=True,\n                print_type=True\n            ):\n                yield line\n\n    @staticmethod\n    def _debug_get_kv_anchors(key: Any, value: Any) -> str:\n        key_anchor = ConsolePrinter._debug_get_anchor(key)\n        val_anchor = ConsolePrinter._debug_get_anchor(value)\n        display_anchor = \"\"\n        if key_anchor and val_anchor:\n            display_anchor = \"({},{})\".format(key_anchor, val_anchor)\n        elif key_anchor:\n            display_anchor = \"({},_)\".format(key_anchor)\n        elif val_anchor:\n            display_anchor = \"(_,{})\".format(val_anchor)\n        return display_anchor\n\n    @staticmethod\n    def _debug_get_kv_tags(key: Any, value: Any) -> str:\n        key_tag = ConsolePrinter._debug_get_tag(key)\n        val_tag = ConsolePrinter._debug_get_tag(value)\n        display_tag = \"\"\n        if key_tag and val_tag:\n            display_tag = \"<{},{}>\".format(key_tag, val_tag)\n        elif key_tag:\n            display_tag = \"<{},_>\".format(key_tag)\n        elif val_tag:\n            display_tag = \"<_,{}>\".format(val_tag)\n        return display_tag\n\n    @staticmethod\n    def _debug_dict(\n        data: Union[Dict, CommentedMap], **kwargs\n    ) -> Generator[str, None, None]:\n        prefix = kwargs.pop(\"prefix\", \"\")\n\n        local_keys = []\n        if isinstance(data, CommentedMap):\n            for local_key, _ in data.non_merged_items():\n                local_keys.append(local_key)\n        else:\n            for key in data.keys():\n                local_keys.append(key)\n\n        for key, val in data.items():\n            display_key = (str(key)\n                           if key in local_keys\n                           else \"<<:{}:>>\".format(key))\n            display_anchor = ConsolePrinter._debug_get_kv_anchors(key, val)\n            display_tag = ConsolePrinter._debug_get_kv_tags(key, val)\n            kv_prefix = \"{}[{}]{}{}\".format(\n                prefix, display_key, display_anchor, display_tag)\n\n            for line in ConsolePrinter._debug_dump(\n                val, prefix=kv_prefix, print_type=True, print_tag=False,\n                print_anchor=False\n            ):\n                yield line\n\n    @staticmethod\n    def _debug_set(\n        data: Union[Set, CommentedSet], **kwargs\n    ) -> Generator[str, None, None]:\n        prefix = kwargs.pop(\"prefix\", \"\")\n\n        for key in data:\n            display_anchor = ConsolePrinter._debug_get_kv_anchors(key, None)\n            display_tag = ConsolePrinter._debug_get_kv_tags(key, None)\n            line = \"{{{}}}{}{}\".format(\n                key, display_anchor, display_tag)\n            yield ConsolePrinter._debug_prefix_lines(\n                \"{}{}{}\".format(prefix, line, type(key)))\n",
    "yamlpath/wrappers/nodecoords.py": "\"\"\"\nImplement NodeCoords.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom typing import Any, List, Optional, Type\n\nfrom yamlpath.types import AncestryEntry, PathSegment\nfrom yamlpath import YAMLPath\n\nclass NodeCoords:\n    \"\"\"\n    Wrap a node's data along with its relative coordinates within its DOM.\n\n    A node's \"coordinates\" includes these properties:\n    1. Reference to the node itself,\n    2. Immediate parent node of the wrapped node,\n    3. Index or Key of the node within its immediate parent\n\n    Additional, optional data can be wrapped along with the node's coordinates\n    to facilitate other specific operations upon the node/DOM.  See the\n    `__init__` method for details.\n    \"\"\"\n\n    # pylint: disable=locally-disabled,too-many-arguments\n    def __init__(\n        self, node: Any, parent: Any, parentref: Any,\n        path: Optional[YAMLPath] = None,\n        ancestry: Optional[List[AncestryEntry]] = None,\n        path_segment: Optional[PathSegment] = None\n    ) -> None:\n        \"\"\"\n        Initialize a new NodeCoords.\n\n        Positional Parameters:\n        1. node (Any) Reference to the ruamel.yaml DOM data element\n        2. parent (Any) Reference to `node`'s immediate DOM parent\n        3. parentref (Any) The `list` index or `dict` key which indicates where\n           within `parent` the `node` is located\n        4. path (YAMLPath) The YAML Path for this node, as reported by its\n           creator process\n        5. ancestry (List[AncestryEntry]) Stack of AncestryEntry (parent,\n           parentref) tracking the hierarchical ancestry of this node through\n           its parent document\n        6. path_segment (PathSegment) The YAML Path segment which most directly\n           caused the generation of this NodeCoords\n\n        Returns: N/A\n\n        Raises:  N/A\n        \"\"\"\n        self.node: Any = node\n        self.parent: Any = parent\n        self.parentref: Any = parentref\n        self.path: Optional[YAMLPath] = path\n        self.ancestry: List[AncestryEntry] = ([]\n                                              if ancestry is None\n                                              else ancestry)\n        self.path_segment: Optional[PathSegment] = path_segment\n\n    def __str__(self) -> str:\n        \"\"\"Get a String representation of this object.\"\"\"\n        return str(self.node)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Generate an eval()-safe representation of this object.\n\n        Assumes all of the ruamel.yaml components are similarly safe.\n        \"\"\"\n        return (\"{}('{}', '{}', '{}')\".format(\n            self.__class__.__name__, self.node, self.parent,\n            self.parentref))\n\n    def __gt__(self, rhs: \"NodeCoords\") -> Any:\n        \"\"\"Indicate whether this node's data is greater-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node > rhs.node\n\n    def __lt__(self, rhs: \"NodeCoords\") -> Any:\n        \"\"\"Indicate whether this node's data is less-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node < rhs.node\n\n    @property\n    def unwrapped_node(self) -> Any:\n        \"\"\"Unwrap the data, no matter how deeply nested it may be.\"\"\"\n        return NodeCoords.unwrap_node_coords(self)\n\n    @property\n    def deepest_node_coord(self) -> \"NodeCoords\":\n        \"\"\"Get the deepest wrapped NodeCoord contained within.\"\"\"\n        return NodeCoords._deepest_node_coord(self)\n\n    def wraps_a(self, compare_type: Type) -> bool:\n        \"\"\"Indicate whether the wrapped node is of a given data-type.\"\"\"\n        if compare_type is None:\n            return self.unwrapped_node is None\n        return isinstance(self.unwrapped_node, compare_type)\n\n    @staticmethod\n    def _deepest_node_coord(node: \"NodeCoords\") -> \"NodeCoords\":\n        \"\"\"Get the deepest nested NodeCoord.\"\"\"\n        if (not isinstance(node, NodeCoords)\n            or not isinstance(node.node, NodeCoords)\n        ):\n            return node\n\n        return NodeCoords._deepest_node_coord(node.node)\n\n    @staticmethod\n    def unwrap_node_coords(data: Any) -> Any:\n        \"\"\"\n        Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\n        Parameters:\n        1. data (Any) the source data to strip.\n\n        Returns:  (Any) the stripped data.\n        \"\"\"\n        if isinstance(data, NodeCoords):\n            return NodeCoords.unwrap_node_coords(data.node)\n\n        if isinstance(data, list):\n            stripped_nodes = []\n            for ele in data:\n                stripped_nodes.append(NodeCoords.unwrap_node_coords(ele))\n            return stripped_nodes\n\n        return data\n",
    "yamlpath/yamlpath.py": "#pylint: disable=too-many-lines\n\"\"\"\nImplement YAML Path.\n\nCopyright 2019, 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom collections import deque\nfrom typing import Deque, List, Optional, Union\n\nfrom yamlpath.types import PathAttributes, PathSegment\nfrom yamlpath.exceptions import (\n    YAMLPathException,\n    TypeMismatchYAMLPathException\n)\nfrom yamlpath.enums import (\n    PathSegmentTypes,\n    PathSearchKeywords,\n    PathSearchMethods,\n    PathSeparators,\n    CollectorOperators,\n)\nfrom yamlpath.path import SearchKeywordTerms, SearchTerms, CollectorTerms\n\n\nclass YAMLPath:\n    \"\"\"\n    Encapsulate a YAML Path and its parsing logic.\n\n    This will keep track of:\n      * the original, unparsed, and unmodified YAML Path;\n      * its segment separator (inferred or manually specified);\n      * the unescaped, parsed representation of the YAML Path; and\n      * the escaped, parsed representation of the YAML Path.\n\n    Parsing operations are lazy and property setting smartly tiggers re-parsing\n    only when necessary.\n    \"\"\"\n\n    def __init__(self, yaml_path: Union[\"YAMLPath\", str, None] = \"\",\n                 pathsep: PathSeparators = PathSeparators.AUTO) -> None:\n        \"\"\"\n        Instantiate this class into an object.\n\n        Parameters:\n        1. yaml_path (Union[\"YAMLPath\", str, None]) The YAML Path to parse or\n           copy\n        2. pathsep (PathSeparators) Forced YAML Path segment separator; set\n           only when automatic inference fails\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        self._separator: PathSeparators = pathsep\n        self._original: str = \"\"\n        self._unescaped: deque = deque()\n        self._escaped: deque = deque()\n        self._stringified: str = \"\"\n\n        if isinstance(yaml_path, YAMLPath):\n            self.original = yaml_path.original\n        else:\n            self.original = \"\" if yaml_path is None else yaml_path\n\n    def __str__(self) -> str:\n        \"\"\"Get a stringified version of this object.\"\"\"\n        if self._stringified:\n            return self._stringified\n\n        self._stringified = YAMLPath._stringify_yamlpath_segments(\n            self.unescaped, self.separator)\n        return self._stringified\n\n    def __repr__(self) -> str:\n        \"\"\"Generate an eval()-safe representation of this object.\"\"\"\n        return (\"{}('{}', '{}')\".format(self.__class__.__name__,\n                                        self.original, self.separator))\n\n    def __len__(self) -> int:\n        \"\"\"Indicate how many segments comprise this YAML Path.\"\"\"\n        return len(self.escaped)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Indicate equivalence of two YAMLPaths.\n\n        The path separator is ignored for this comparison.  This is deliberate\n        and allows \"some.path[1]\" == \"/some/path[1]\" because both forms of the\n        same path yield exactly the same data.\n\n        Parameters:\n        1. other (object) The other YAMLPath to compare against.\n\n        Returns:  (bool) true = Both are identical; false, otherwise\n        \"\"\"\n        if not isinstance(other, (YAMLPath, str)):\n            return False\n\n        equiv_this = YAMLPath(self)\n        equiv_this.separator = PathSeparators.FSLASH\n        cmp_this = str(equiv_this)\n\n        equiv_that = YAMLPath(other)\n        equiv_that.separator = PathSeparators.FSLASH\n        cmp_that = str(equiv_that)\n\n        return cmp_this == cmp_that\n\n    def __ne__(self, other: object) -> bool:\n        \"\"\"Indicate non-equivalence of two YAMLPaths.\"\"\"\n        return not self == other\n\n    def __add__(self, other: object) -> \"YAMLPath\":\n        \"\"\"Add a nonmutating -- pre-escaped -- path segment.\"\"\"\n        next_segment = str(other) if not isinstance(other, str) else other\n        return YAMLPath(self).append(next_segment)\n\n    def append(self, segment: str) -> \"YAMLPath\":\n        \"\"\"\n        Append a new -- pre-escaped -- segment to this YAML Path.\n\n        Parameters:\n        1. segment (str) The new -- pre-escaped -- segment to append to this\n           YAML Path.  Do NOT include any separator with this value; it will be\n           added for you.\n\n        Returns:  (YAMLPath) The adjusted YAMLPath\n        \"\"\"\n        separator = (\n            PathSeparators.FSLASH\n            if self.separator is PathSeparators.AUTO\n            else self.separator)\n        if len(self._original) < 1:\n            self.original = segment\n        else:\n            self.original += \"{}{}\".format(separator, segment)\n        return self\n\n    def pop(self) -> PathSegment:\n        \"\"\"\n        Pop the last segment off this YAML Path.\n\n        This mutates the YAML Path and returns the removed segment PathSegment.\n\n        Returns:  (PathSegment) The removed segment\n        \"\"\"\n        segments: Deque[PathSegment] = self.unescaped\n        if len(segments) < 1:\n            raise YAMLPathException(\n                \"Cannot pop when there are no segments to pop from\",\n                str(self))\n\n        popped_queue: Deque = deque()\n        popped_segment: PathSegment = segments.pop()\n        popped_queue.append(popped_segment)\n        removable_segment = YAMLPath._stringify_yamlpath_segments(\n            popped_queue, self.separator)\n        prefixed_segment = \"{}{}\".format(self.separator, removable_segment)\n        path_now = self.original\n\n        if path_now.endswith(prefixed_segment):\n            self.original = path_now[0:len(path_now) - len(prefixed_segment)]\n        elif path_now.endswith(removable_segment):\n            self.original = path_now[0:len(path_now) - len(removable_segment)]\n        elif (\n            self.separator == PathSeparators.FSLASH\n            and path_now.endswith(removable_segment[1:])\n        ):\n            self.original = path_now[\n                0:len(path_now) - len(removable_segment) + 1]\n\n        return popped_segment\n\n    @property\n    def is_root(self) -> bool:\n        \"\"\"Indicate whether this YAML Path points at the document root.\"\"\"\n        return len(self.escaped) == 0\n\n    @property\n    def original(self) -> str:\n        \"\"\"\n        Original YAML Path accessor.\n\n        Positional Parameters:  N/A\n\n        Returns:  (str) The original, unparsed, unmodified YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        return self._original\n\n    @original.setter\n    def original(self, value: str) -> None:\n        \"\"\"\n        Original YAML Path mutator.\n\n        Parameters:\n        1. value (str) A YAML Path in string form\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        str_val = str(value)\n\n        # Check for empty paths\n        if not str_val.strip():\n            str_val = \"\"\n\n        self._original = str_val\n        self._separator = PathSeparators.AUTO\n        self._unescaped = deque()\n        self._escaped = deque()\n        self._stringified = \"\"\n\n    @property\n    def separator(self) -> PathSeparators:\n        \"\"\"\n        Get the separator used to demarcate YAML Path segments.\n\n        Parameters:  N/A\n\n        Returns:  (PathSeparators) The segment demarcation symbol\n\n        Raises:  N/A\n        \"\"\"\n        if self._separator is PathSeparators.AUTO:\n            self._separator = PathSeparators.infer_separator(self._original)\n\n        return self._separator\n\n    @separator.setter\n    def separator(self, value: PathSeparators) -> None:\n        \"\"\"\n        Set the separator used to demarcate YAML Path segments.\n\n        This only affects __str__ and only when the new value differs from the\n        separator already inferred from the original YAML Path.\n\n        Parameters:\n        1. value (PathSeparators) The segment demarcation symbol\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        old_value: PathSeparators = self._separator\n\n        # This changes only the stringified representation\n        if not value == old_value:\n            self._stringified = YAMLPath._stringify_yamlpath_segments(\n                self.unescaped, value)\n            self._separator = value\n\n    @property\n    def seperator(self) -> PathSeparators:\n        \"\"\"\n        Get the separator used to demarcate YAML Path segments.\n\n        This is provided for compatibility with older versions,\n        before the spelling was updated to \"separator.\"\n\n        Parameters:  N/A\n\n        Returns:  (PathSeparators) The segment demarcation symbol\n\n        Raises:  N/A\n        \"\"\"\n        return self.separator\n\n    @seperator.setter\n    def seperator(self, value: PathSeparators) -> None:\n        \"\"\"\n        Set the separator used to demarcate YAML Path segments.\n\n        This only affects __str__ and only when the new value differs from the\n        separator already inferred from the original YAML Path.\n\n        This is provided for compatibility with older versions,\n        before the spelling was updated to \"separator.\"\n\n        Parameters:\n        1. value (PathSeparators) The segment demarcation symbol\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        self.separator = value\n\n    @property\n    def escaped(self) -> Deque[PathSegment]:\n        r\"\"\"\n        Get the escaped, parsed version of this YAML Path.\n\n        Any leading \\ symbols are stripped out.  This is the parsed YAML Path\n        used for processing YAML data.\n\n        Parameters:  N/A\n\n        Returns:  (deque) The escaped, parsed version of this YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        if not self._escaped:\n            self._escaped = self._parse_path(True)\n\n        return self._escaped.copy()\n\n    @property\n    def unescaped(self) -> Deque[PathSegment]:\n        r\"\"\"\n        Get the unescaped, parsed version of this YAML Path.\n\n        Any leading \\ symbols are preserved.  This is the print and log\n        friendly version of the parsed YAML Path.\n\n        Parameters:  N/A\n\n        Returns:  (deque) The unescaped, parsed version of this YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        if not self._unescaped:\n            self._unescaped = self._parse_path(False)\n\n        return self._unescaped.copy()\n\n    # pylint: disable=locally-disabled,too-many-locals,too-many-branches,too-many-statements\n    def _parse_path(self,\n                    strip_escapes: bool = True\n                   ) -> Deque[PathSegment]:\n        r\"\"\"\n        Parse the YAML Path into its component PathSegment tuples.\n\n        Breaks apart a stringified YAML Path into component segments, each\n        identified by its type.  See README.md for sample YAML Paths.\n\n        Parameters:\n        1. strip_escapes (bool) True = Remove leading \\ symbols, leaving\n           only the \"escaped\" symbol.  False = Leave all leading \\ symbols\n           intact.\n\n        Returns:  (Deque[PathSegment]) an empty queue or a queue of\n            PathSegments.\n\n        Raises:\n            - `YAMLPathException` when the YAML Path is invalid\n        \"\"\"\n        yaml_path: str = self.original\n        path_segments: deque = deque()\n        segment_id: str = \"\"\n        segment_type: Optional[PathSegmentTypes] = None\n        demarc_stack: List[str] = []\n        escape_next: bool = False\n        search_inverted: bool = False\n        search_method: Optional[PathSearchMethods] = None\n        search_attr: str = \"\"\n        search_keyword: Optional[PathSearchKeywords] = None\n        seeking_regex_delim: bool = False\n        capturing_regex: bool = False\n        pathsep: str = str(self.separator)\n        collector_level: int = 0\n        collector_operator: CollectorOperators = CollectorOperators.NONE\n        seeking_collector_operator: bool = False\n        next_char_must_be: Optional[str] = None\n\n        # Empty paths yield empty queues\n        if not yaml_path:\n            return path_segments\n\n        # Infer the first possible position for a top-level Anchor mark\n        first_anchor_pos = 0\n        if self.separator is PathSeparators.FSLASH and len(yaml_path) > 1:\n            first_anchor_pos = 1\n        seeking_anchor_mark = yaml_path[first_anchor_pos] == \"&\"\n\n        # Parse the YAML Path\n        # pylint: disable=locally-disabled,too-many-nested-blocks\n        for char_idx, char in enumerate(yaml_path):\n            demarc_count = len(demarc_stack)\n            if next_char_must_be and char == next_char_must_be:\n                next_char_must_be = None\n\n            if escape_next:\n                # Pass-through; capture this escaped character\n                escape_next = False\n\n            elif capturing_regex:\n                # Pass-through; capture everything that isn't the present\n                # RegEx delimiter.  This deliberately means users cannot\n                # escape the RegEx delimiter itself should it occur within\n                # the RegEx; thus, users must select a delimiter that won't\n                # appear within the RegEx (which is exactly why the user\n                # gets to choose the delimiter).\n                if char == demarc_stack[-1]:\n                    # Stop the RegEx capture\n                    capturing_regex = False\n                    demarc_stack.pop()\n                    continue\n\n            # The escape test MUST come AFTER the RegEx capture test so users\n            # won't be forced into \"The Backslash Plague\".\n            # (https://docs.python.org/3/howto/regex.html#the-backslash-plague)\n            elif char == \"\\\\\":\n                # Escape the next character\n                escape_next = True\n                if strip_escapes:\n                    continue\n\n            elif (\n                    char == \" \"\n                    and (demarc_count < 1\n                         or demarc_stack[-1] not in [\"'\", '\"'])\n            ):\n                # Ignore unescaped, non-demarcated whitespace\n                continue\n\n            elif seeking_regex_delim:\n                # This first non-space symbol is now the RegEx delimiter\n                seeking_regex_delim = False\n                capturing_regex = True\n                demarc_stack.append(char)\n                demarc_count += 1\n                continue\n\n            elif seeking_anchor_mark and char == \"&\":\n                # Found an expected (permissible) ANCHOR mark\n                seeking_anchor_mark = False\n                segment_type = PathSegmentTypes.ANCHOR\n                continue\n\n            elif seeking_collector_operator and char in ['+', '-', '&']:\n                seeking_collector_operator = False\n                next_char_must_be = '('\n                if char == '+':\n                    collector_operator = CollectorOperators.ADDITION\n                elif char == '-':\n                    collector_operator = CollectorOperators.SUBTRACTION\n                elif char == '&':\n                    collector_operator = CollectorOperators.INTERSECTION\n                continue\n\n            elif next_char_must_be and char != next_char_must_be:\n                raise YAMLPathException((\n                    \"Invalid YAML Path at character index {}, \\\"{}\\\", which\"\n                    \" must be \\\"{}\\\" in YAML Path\")\n                    .format(char_idx, char, next_char_must_be), yaml_path)\n\n            elif char in ['\"', \"'\"]:\n                # Found a string demarcation mark\n                if demarc_count > 0:\n                    # Already appending to an ongoing demarcated value\n                    if char == demarc_stack[-1]:\n                        # Close a matching pair\n                        demarc_stack.pop()\n                        demarc_count -= 1\n\n                        # Record the element_id when all pairs have closed\n                        # unless there is no element_id.\n                        if demarc_count < 1:\n                            if segment_id:\n                                # Unless the element has already been\n                                # identified as a special type, assume it is a\n                                # KEY.\n                                if segment_type is None:\n                                    segment_type = PathSegmentTypes.KEY\n                                path_segments.append(\n                                    (segment_type, segment_id))\n\n                            segment_id = \"\"\n                            segment_type = None\n                            continue\n                    else:\n                        # Embed a nested, demarcated component\n                        demarc_stack.append(char)\n                        demarc_count += 1\n                else:\n                    # Fresh demarcated value\n                    demarc_stack.append(char)\n                    demarc_count += 1\n                    continue\n\n            elif char == \"(\":\n                if (demarc_count == 1\n                    and demarc_stack[-1] == \"[\"\n                    and segment_id\n                ):\n                    if PathSearchKeywords.is_keyword(segment_id):\n                        demarc_stack.append(char)\n                        demarc_count += 1\n                        segment_type = PathSegmentTypes.KEYWORD_SEARCH\n                        search_keyword = PathSearchKeywords[segment_id.upper()]\n                        segment_id = \"\"\n                        continue\n\n                    raise YAMLPathException((\n                        \"Unknown Search Keyword at character index {},\"\n                        \" \\\"{}\\\"; allowed: {}.  Encountered in YAML Path\")\n                        .format(char_idx - len(segment_id), segment_id,\n                            ', '.join(PathSearchKeywords.get_keywords())\n                        )\n                        , yaml_path\n                    )\n\n                if collector_level == 0 and segment_id:\n                    # Record its predecessor element; unless it has already\n                    # been identified as a special type, assume it is a KEY.\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(\n                        yaml_path, segment_id, segment_type))\n                    segment_id = \"\"\n\n                seeking_collector_operator = False\n                collector_level += 1\n                demarc_stack.append(char)\n                demarc_count += 1\n                segment_type = PathSegmentTypes.COLLECTOR\n\n                # Preserve nested collectors\n                if collector_level == 1:\n                    continue\n\n            elif (\n                    demarc_count > 0\n                    and char == \")\"\n                    and segment_type is PathSegmentTypes.KEYWORD_SEARCH\n            ):\n                demarc_count -= 1\n                demarc_stack.pop()\n                next_char_must_be = \"]\"\n                seeking_collector_operator = False\n                continue\n\n            elif (\n                    demarc_count > 0\n                    and char == \")\"\n                    and demarc_stack[-1] == \"(\"\n                    and collector_level > 0\n            ):\n                collector_level -= 1\n                demarc_count -= 1\n                demarc_stack.pop()\n\n                if collector_level < 1:\n                    path_segments.append(\n                        (segment_type,\n                            CollectorTerms(segment_id, collector_operator)))\n                    segment_id = \"\"\n                    collector_operator = CollectorOperators.NONE\n                    seeking_collector_operator = True\n                    continue\n\n            elif demarc_count == 0 and char == \"[\":\n                # Array INDEX/SLICE or SEARCH\n                if segment_id:\n                    # Record its predecessor element; unless it has already\n                    # been identified as a special type, assume it is a KEY.\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(\n                        yaml_path, segment_id, segment_type))\n                    segment_id = \"\"\n\n                demarc_stack.append(char)\n                demarc_count += 1\n                segment_type = PathSegmentTypes.INDEX\n                seeking_collector_operator = False\n                seeking_anchor_mark = True\n                search_inverted = False\n                search_method = None\n                search_attr = \"\"\n                continue\n\n            elif (\n                    demarc_count == 1\n                    and demarc_stack[-1] == \"[\"\n                    and char in [\"=\", \"^\", \"$\", \"%\", \"!\", \">\", \"<\", \"~\"]\n            ):\n                # Hash attribute search\n                # pylint: disable=no-else-continue\n                if char == \"!\":\n                    if search_inverted:\n                        raise YAMLPathException((\n                            \"Double search inversion is meaningless at\"\n                            \" character index {}, {}\")\n                            .format(char_idx, char)\n                            , yaml_path\n                        )\n\n                    # Invert the search\n                    search_inverted = True\n                    continue\n\n                elif char == \"=\":\n                    # Exact value match OR >=|<=\n                    segment_type = PathSegmentTypes.SEARCH\n\n                    if search_method is PathSearchMethods.LESS_THAN:\n                        search_method = PathSearchMethods.LESS_THAN_OR_EQUAL\n                    elif search_method is PathSearchMethods.GREATER_THAN:\n                        search_method = PathSearchMethods.GREATER_THAN_OR_EQUAL\n                    elif search_method is PathSearchMethods.EQUALS:\n                        # Allow ==\n                        continue\n                    elif search_method is None:\n                        search_method = PathSearchMethods.EQUALS\n\n                        if segment_id:\n                            search_attr = segment_id\n                            segment_id = \"\"\n                        else:\n                            raise YAMLPathException((\n                                \"Missing search operand before operator at\"\n                                \" character index {}, \\\"{}\\\"\")\n                                .format(char_idx, char)\n                                , yaml_path\n                            )\n                    else:\n                        raise YAMLPathException((\n                            \"Unsupported search operator combination at\"\n                            \" character index {}, \\\"{}\\\"\")\n                            .format(char_idx, char)\n                            , yaml_path\n                        )\n\n                    continue  # pragma: no cover\n\n                elif char == \"~\":\n                    if search_method == PathSearchMethods.EQUALS:\n                        search_method = PathSearchMethods.REGEX\n                        seeking_regex_delim = True\n                    else:\n                        raise YAMLPathException((\n                            \"Unexpected use of \\\"{}\\\" operator at character\"\n                            \" index {}.  Please try =~ if you mean to search\"\n                            \" with a Regular Expression.\"\n                            ).format(char, char_idx)\n                            , yaml_path\n                        )\n\n                    continue  # pragma: no cover\n\n                elif not segment_id:\n                    # All tests beyond this point require an operand\n                    raise YAMLPathException((\n                        \"Missing search operand before operator, \\\"{}\\\" at\"\n                        \" character index, {}\")\n                        .format(char, char_idx)\n                        , yaml_path\n                    )\n\n                elif char == \"^\":\n                    # Value starts with\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.STARTS_WITH\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = \"\"\n                    continue\n\n                elif char == \"$\":\n                    # Value ends with\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.ENDS_WITH\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = \"\"\n                    continue\n\n                elif char == \"%\":\n                    # Value contains\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.CONTAINS\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = \"\"\n                    continue\n\n                elif char == \">\":\n                    # Value greater than\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.GREATER_THAN\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = \"\"\n                    continue\n\n                elif char == \"<\":\n                    # Value less than\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.LESS_THAN\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = \"\"\n                    continue\n\n            elif char == \"[\":\n                # Track bracket nesting\n                demarc_stack.append(char)\n                demarc_count += 1\n\n            elif (\n                    demarc_count == 1\n                    and char == \"]\"\n                    and demarc_stack[-1] == \"[\"\n            ):\n                # Store the INDEX, SLICE, SEARCH, or KEYWORD_SEARCH parameters\n                if (\n                        segment_type is PathSegmentTypes.INDEX\n                        and ':' not in segment_id\n                ):\n                    try:\n                        idx = int(segment_id)\n                    except ValueError as wrap_ex:\n                        raise TypeMismatchYAMLPathException((\n                            \"Not an integer index at character index {}:  {}\")\n                            .format(char_idx, segment_id)\n                            , yaml_path\n                            , segment_id\n                        ) from wrap_ex\n                    path_segments.append((segment_type, idx))\n                elif (\n                        segment_type is PathSegmentTypes.SEARCH\n                        and search_method is not None\n                ):\n                    # Undemarcate the search term, if it is so\n                    if segment_id and segment_id[0] in [\"'\", '\"']:\n                        leading_mark = segment_id[0]\n                        if segment_id[-1] == leading_mark:\n                            segment_id = segment_id[1:-1]\n\n                    path_segments.append((\n                        segment_type,\n                        SearchTerms(search_inverted, search_method,\n                                    search_attr, segment_id)\n                    ))\n                elif (\n                    segment_type is PathSegmentTypes.KEYWORD_SEARCH\n                    and search_keyword\n                ):\n                    path_segments.append((\n                        segment_type,\n                        SearchKeywordTerms(search_inverted, search_keyword,\n                                           segment_id)\n                    ))\n                else:\n                    path_segments.append((segment_type, segment_id))\n\n                segment_id = \"\"\n                segment_type = None\n                demarc_stack.pop()\n                demarc_count -= 1\n                search_method = None\n                search_inverted = False\n                search_keyword = None\n                continue\n\n            elif char == \"]\":\n                # Track bracket de-nesting\n                demarc_stack.pop()\n                demarc_count -= 1\n\n            elif demarc_count < 1 and char == pathsep:\n                # Do not store empty elements\n                if segment_id:\n                    # Unless its type has already been identified as a special\n                    # type, assume it is a KEY.\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(\n                        yaml_path, segment_id, segment_type))\n                    segment_id = \"\"\n\n                segment_type = None\n                seeking_anchor_mark = True\n                continue\n\n            segment_id += char\n            seeking_anchor_mark = False\n            seeking_collector_operator = False\n\n        # Check for unmatched subpath demarcations\n        if collector_level > 0:\n            raise YAMLPathException(\n                \"YAML Path contains an unmatched () collector pair\",\n                yaml_path\n            )\n\n        # Check for unterminated RegExes\n        if capturing_regex:\n            raise YAMLPathException(\n                \"YAML Path contains an unterminated Regular Expression\",\n                yaml_path\n            )\n\n        # Check for mismatched demarcations\n        if demarc_count > 0:\n            raise YAMLPathException((\n                \"YAML Path contains at least one unmatched demarcation mark\"\n                \" with remaining open marks, {} in\"\n                ).format(\", \".join(demarc_stack)),\n                yaml_path\n            )\n\n        # Store the final element_id, which must have been a KEY\n        if segment_id:\n            # Unless its type has already been identified as a special\n            # type, assume it is a KEY.\n            if segment_type is None:\n                segment_type = PathSegmentTypes.KEY\n            path_segments.append(self._expand_splats(\n                yaml_path, segment_id, segment_type))\n\n        return path_segments\n\n    @staticmethod\n    def _expand_splats(\n        yaml_path: str, segment_id: PathAttributes,\n        segment_type: PathSegmentTypes\n    ) -> PathSegment:\n        \"\"\"\n        Replace segment IDs with search operators when * is present.\n\n        Parameters:\n        1. yaml_path (str) The full YAML Path being processed.\n        2. segment_id (str) The segment identifier to parse.\n        3. segment_type (Optional[PathSegmentTypes]) Pending predetermined type\n           of the segment under evaluation.\n\n        Returns:  (PathSegment) Coallesced YAML Path segment.\n        \"\"\"\n        coal_type: PathSegmentTypes = segment_type\n        coal_value: PathAttributes = segment_id\n\n        if isinstance(segment_id, str) and  '*' in segment_id:\n            splat_count = segment_id.count(\"*\")\n            splat_pos = segment_id.index(\"*\")\n            segment_len = len(segment_id)\n            if splat_count == 1:\n                if segment_len == 1:\n                    # /*/ -> MATCH_ALL\n                    coal_type = PathSegmentTypes.MATCH_ALL\n                    coal_value = None\n                elif splat_pos == 0:\n                    # /*text/ -> [.$text]\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(\n                        False, PathSearchMethods.ENDS_WITH, \".\",\n                        segment_id[1:])\n                elif splat_pos == segment_len - 1:\n                    # /text*/ -> [.^text]\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(\n                        False, PathSearchMethods.STARTS_WITH, \".\",\n                        segment_id[0:splat_pos])\n                else:\n                    # /te*xt/ -> [.=~/^te.*xt$/]\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(\n                        False, PathSearchMethods.REGEX, \".\",\n                        \"^{}.*{}$\".format(\n                            segment_id[0:splat_pos],\n                            segment_id[splat_pos + 1:]))\n            elif splat_count == 2 and segment_len == 2:\n                # Traversal operator\n                coal_type = PathSegmentTypes.TRAVERSE\n                coal_value = None\n            elif splat_count > 1:\n                # Multi-wildcard search\n                search_term = \"^\"\n                was_splat = False\n                for char in segment_id:\n                    if char == \"*\":\n                        if was_splat:\n                            raise YAMLPathException(\n                                \"The ** traversal operator has no meaning when\"\n                                \" combined with other characters\", yaml_path,\n                                segment_id)\n                        was_splat = True\n                        search_term += \".*\"\n                    else:\n                        was_splat = False\n                        search_term += char\n                search_term += \"$\"\n\n                coal_type = PathSegmentTypes.SEARCH\n                coal_value = SearchTerms(\n                    False, PathSearchMethods.REGEX, \".\", search_term)\n\n        return (coal_type, coal_value)\n\n    @staticmethod\n    def _stringify_yamlpath_segments(\n        segments: Deque[PathSegment], separator: PathSeparators\n    ) -> str:\n        \"\"\"Stringify segments of a YAMLPath.\"\"\"\n        pathsep: str = str(separator)\n        add_sep: bool = False\n        ppath: str = \"\"\n\n        # FSLASH separator requires a path starting with a /\n        if separator is PathSeparators.FSLASH:\n            ppath = pathsep\n\n        for (segment_type, segment_attrs) in segments:\n            if segment_type == PathSegmentTypes.KEY:\n                if add_sep:\n                    ppath += pathsep\n\n                # Replace a subset of special characters to alert users to\n                # potentially unintentional demarcation.\n                ppath += YAMLPath.ensure_escaped(\n                    str(segment_attrs),\n                    pathsep,\n                    '(', ')', '[', ']', '^', '$', '%', ' ', \"'\", '\"'\n                )\n            elif segment_type == PathSegmentTypes.INDEX:\n                ppath += \"[{}]\".format(segment_attrs)\n            elif segment_type == PathSegmentTypes.MATCH_ALL:\n                if add_sep:\n                    ppath += pathsep\n                ppath += \"*\"\n            elif segment_type == PathSegmentTypes.ANCHOR:\n                if add_sep:\n                    ppath += \"[&{}]\".format(segment_attrs)\n                else:\n                    ppath += \"&{}\".format(segment_attrs)\n            elif segment_type == PathSegmentTypes.KEYWORD_SEARCH:\n                ppath += str(segment_attrs)\n            elif (segment_type == PathSegmentTypes.SEARCH\n                  and isinstance(segment_attrs, SearchTerms)):\n                ppath += str(segment_attrs)\n            elif segment_type == PathSegmentTypes.COLLECTOR:\n                ppath += str(segment_attrs)\n            elif segment_type == PathSegmentTypes.TRAVERSE:\n                if add_sep:\n                    ppath += pathsep\n                ppath += \"**\"\n\n            add_sep = True\n\n        return ppath\n\n    @staticmethod\n    def strip_path_prefix(path: \"YAMLPath\", prefix: \"YAMLPath\") -> \"YAMLPath\":\n        \"\"\"\n        Remove a prefix from a YAML Path.\n\n        Parameters:\n        1. path (YAMLPath) The path from which to remove the prefix.\n        2. prefix (YAMLPath) The prefix to remove (except \"/\").\n\n        Returns:  (YAMLPath) The trimmed YAML Path.\n        \"\"\"\n        if prefix is None:\n            return path\n\n        prefix.separator = PathSeparators.FSLASH\n        if str(prefix) == \"/\":\n            return path\n\n        path.separator = PathSeparators.FSLASH\n        prefix_str = str(prefix)\n        path_str = str(path)\n        if path_str.startswith(prefix_str):\n            path_str = path_str[len(prefix_str):]\n            return YAMLPath(path_str)\n\n        return path\n\n    @staticmethod\n    def ensure_escaped(value: str, *symbols: str) -> str:\n        r\"\"\"\n        Escape all instances of a symbol within a value.\n\n        Ensures all instances of a symbol are escaped (via \\) within a value.\n        Multiple symbols can be processed at once.\n\n        Parameters:\n        1. value (str) The String in which to escape special characters\n        2. *symbols (str) List of special characters to escape\n\n        Returns:  (str) `value` with all `symbols` escaped\n        \"\"\"\n        escaped: str = value\n        for symbol in symbols:\n            replace_term: str = \"\\\\{}\".format(symbol)\n            oparts: List[str] = str(escaped).split(replace_term)\n            eparts: List[str] = []\n            for opart in oparts:\n                eparts.append(opart.replace(symbol, replace_term))\n            escaped = replace_term.join(eparts)\n        return escaped\n\n    @staticmethod\n    def escape_path_section(section: str, pathsep: PathSeparators) -> str:\n        \"\"\"\n        Escape all special symbols present within a YAML Path segment.\n\n        Renders inert via escaping all symbols within a string which have\n        special meaning to YAML Path.  The resulting string can be consumed as\n        a YAML Path section without triggering unwanted additional processing.\n\n        Parameters:\n        1. section (str) The portion of a YAML Path segment to escape\n        2. pathsep (PathSeparators) The YAML Path segment separator symbol to\n           also escape, when present\n\n        Returns:  (str) `section` with all special symbols escaped\n        \"\"\"\n        return YAMLPath.ensure_escaped(\n            section,\n            '\\\\', str(pathsep), '(', ')', '[', ']', '^', '$', '%',\n            ' ', \"'\", '\"'\n        )\n",
    "yamlpath/patches/timestamp.py": "# pylint: skip-file\n\"\"\"\nFix missing anchors from timestamp and date nodes.\n\nThis must be removed once incorporated into ruamel.yaml, likely at version\n0.17.22.\n\nSource: https://sourceforge.net/p/ruamel-yaml/tickets/440/\nCopyright 2022 Anthon van der Neut, William W. Kimball Jr. MBA MSIS\n\"\"\"\nimport ruamel.yaml\nfrom ruamel.yaml.constructor import ConstructorError\nfrom ruamel.yaml.anchor import Anchor\nfrom ruamel.yaml.timestamp import TimeStamp\n\nfrom typing import Any, Dict, Union  # NOQA\nimport datetime\nimport copy\n\n\nclass AnchoredTimeStamp(TimeStamp):\n    \"\"\"Extend TimeStamp to track YAML Anchors.\"\"\"\n\n    def __init__(self, *args: Any, **kw: Any) -> None:\n        \"\"\"Initialize a new instance.\"\"\"\n        self._yaml: Dict[Any, Any] = dict(t=False, tz=None, delta=0)\n\n    def __new__(cls, *args: Any, **kw: Any) -> Any:  # datetime is immutable\n        \"\"\"Create a new, immutable instance.\"\"\"\n        anchor = kw.pop('anchor', None)\n        ts = TimeStamp.__new__(cls, *args, **kw)\n        if anchor is not None:\n            ts.yaml_set_anchor(anchor, always_dump=True)\n        return ts\n\n    def __deepcopy__(self, memo: Any) -> Any:\n        \"\"\"Deeply copy this instance to another.\"\"\"\n        ts = AnchoredTimeStamp(self.year, self.month, self.day, self.hour, self.minute, self.second)\n        ts._yaml = copy.deepcopy(self._yaml)\n        return ts\n\n    @property\n    def anchor(self) -> Any:\n        \"\"\"Access the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            setattr(self, Anchor.attrib, Anchor())\n        return getattr(self, Anchor.attrib)\n\n    def yaml_anchor(self, any: bool = False) -> Any:\n        \"\"\"Get the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            return None\n        if any or self.anchor.always_dump:\n            return self.anchor\n        return None\n\n    def yaml_set_anchor(self, value: Any, always_dump: bool = False) -> None:\n        \"\"\"Set the YAML Anchor.\"\"\"\n        self.anchor.value = value\n        self.anchor.always_dump = always_dump\n\n\nclass AnchoredDate(AnchoredTimeStamp):\n    \"\"\"Define AnchoredDate.\"\"\"\n\n    pass\n\n\ndef construct_anchored_timestamp(\n    self, node: Any, values: Any = None\n) -> Union[AnchoredTimeStamp, AnchoredDate]:\n    \"\"\"Construct an AnchoredTimeStamp.\"\"\"\n    try:\n        match = self.timestamp_regexp.match(node.value)\n    except TypeError:\n        match = None\n    if match is None:\n        raise ConstructorError(\n            None,\n            None,\n            f'failed to construct timestamp from \"{node.value}\"',\n            node.start_mark,\n        )\n    values = match.groupdict()\n    dd = ruamel.yaml.util.create_timestamp(**values)  # this has delta applied\n    delta = None\n    if values['tz_sign']:\n        tz_hour = int(values['tz_hour'])\n        minutes = values['tz_minute']\n        tz_minute = int(minutes) if minutes else 0\n        delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)\n        if values['tz_sign'] == '-':\n            delta = -delta\n    if isinstance(dd, datetime.datetime):\n        data = AnchoredTimeStamp(\n            dd.year, dd.month, dd.day, dd.hour, dd.minute, dd.second, dd.microsecond, anchor=node.anchor\n        )\n    else:\n        data = AnchoredDate(dd.year, dd.month, dd.day, 0, 0, 0, 0, anchor=node.anchor)\n        return data\n    if delta:\n        data._yaml['delta'] = delta\n        tz = values['tz_sign'] + values['tz_hour']\n        if values['tz_minute']:\n            tz += ':' + values['tz_minute']\n        data._yaml['tz'] = tz\n    else:\n        if values['tz']:  # no delta\n            data._yaml['tz'] = values['tz']\n    if values['t']:\n        data._yaml['t'] = True\n    return data\n\nruamel.yaml.constructor.RoundTripConstructor.add_constructor('tag:yaml.org,2002:timestamp', construct_anchored_timestamp)\n\ndef represent_anchored_timestamp(self, data: Any):\n    \"\"\"Render an AnchoredTimeStamp.\"\"\"\n    try:\n        anchor = data.yaml_anchor()\n    except AttributeError:\n        anchor = None\n    inter = 'T' if data._yaml['t'] else ' '\n    _yaml = data._yaml\n    if _yaml['delta']:\n        data += _yaml['delta']\n    if isinstance(data, AnchoredDate):\n        value = data.date().isoformat()\n    else:\n        value = data.isoformat(inter)\n    if _yaml['tz']:\n        value += _yaml['tz']\n    return self.represent_scalar('tag:yaml.org,2002:timestamp', value, anchor=anchor)\n\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredTimeStamp, represent_anchored_timestamp)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredDate, represent_anchored_timestamp)\n"
  },
  "GT_src_dict": {
    "yamlpath/wrappers/consoleprinter.py": {
      "ConsolePrinter.__init__": {
        "code": "    def __init__(self, args):\n        \"\"\"Instantiate a ConsolePrinter object for managing console output based on defined log level settings.\n\nParameters:\n- args (object): An object containing log level attributes:\n    - debug (bool): Enables output of debugging messages when set to True.\n    - verbose (bool): Enables output of verbose informational messages when set to True.\n    - quiet (bool): Suppresses all output except for error messages when set to True.\n\nReturns: None\n\nUsage: This constructor initializes the ConsolePrinter with the specified logging settings, allowing the subsequent use of methods like info(), verbose(), warning(), error(), critical(), and debug() for conditional message output. No exceptions are raised during this initialization process.\"\"\"\n        '\\n        Instantiate a ConsolePrinter.\\n\\n        Positional Parameters:\\n        1. args (object) An object representing log level settings with these\\n           properties:\\n            - debug (Boolean) true = write debugging informational messages\\n            - verbose (Boolean) true = write verbose informational messages\\n            - quiet (Boolean) true = write only error messages\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        self.args = args",
        "docstring": "Instantiate a ConsolePrinter object for managing console output based on defined log level settings.\n\nParameters:\n- args (object): An object containing log level attributes:\n    - debug (bool): Enables output of debugging messages when set to True.\n    - verbose (bool): Enables output of verbose informational messages when set to True.\n    - quiet (bool): Suppresses all output except for error messages when set to True.\n\nReturns: None\n\nUsage: This constructor initializes the ConsolePrinter with the specified logging settings, allowing the subsequent use of methods like info(), verbose(), warning(), error(), critical(), and debug() for conditional message output. No exceptions are raised during this initialization process.",
        "signature": "def __init__(self, args):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.info": {
        "code": "    def info(self, message):\n        \"\"\"Write an informational message to STDOUT unless quiet mode is active.\n\nParameters:\n- message (str): The informational message to be printed to the console.\n\nReturns:\n- None\n\nSide Effects:\n- If the 'quiet' attribute of the 'args' object (passed during initialization of the ConsolePrinter) is set to False, the message will be printed to the standard output. If 'quiet' is True, no output will be produced.\n\nDependencies:\n- The method relies on the 'args' attribute of the ConsolePrinter instance, which is an object containing settings for logging verbosity. The 'quiet' property is particularly significant as it controls whether any informational messages are displayed.\"\"\"\n        '\\n        Write an informational message to STDOUT unless quiet mode is active.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        if not self.args.quiet:\n            print(message)",
        "docstring": "Write an informational message to STDOUT unless quiet mode is active.\n\nParameters:\n- message (str): The informational message to be printed to the console.\n\nReturns:\n- None\n\nSide Effects:\n- If the 'quiet' attribute of the 'args' object (passed during initialization of the ConsolePrinter) is set to False, the message will be printed to the standard output. If 'quiet' is True, no output will be produced.\n\nDependencies:\n- The method relies on the 'args' attribute of the ConsolePrinter instance, which is an object containing settings for logging verbosity. The 'quiet' property is particularly significant as it controls whether any informational messages are displayed.",
        "signature": "def info(self, message):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.verbose": {
        "code": "    def verbose(self, message):\n        \"\"\"Write a verbose message to STDOUT when verbose mode is active and quiet mode is not enabled. The method checks the state of the `quiet`, `verbose`, and `debug` properties of the `args` object passed during the initialization of the `ConsolePrinter`. If `quiet` is set to `True`, no output will be printed. If `verbose` or `debug` is `True`, the provided message is printed to the console.\n\nParameters:\n- message (str): The message to print.\n\nReturns: \n- None\n\nRaises: \n- None\"\"\"\n        '\\n        Write a verbose message to STDOUT.\\n\\n        Writes only when verbose mode is active unless quiet mode is active.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        if not self.args.quiet and (self.args.verbose or self.args.debug):\n            print(message)",
        "docstring": "Write a verbose message to STDOUT when verbose mode is active and quiet mode is not enabled. The method checks the state of the `quiet`, `verbose`, and `debug` properties of the `args` object passed during the initialization of the `ConsolePrinter`. If `quiet` is set to `True`, no output will be printed. If `verbose` or `debug` is `True`, the provided message is printed to the console.\n\nParameters:\n- message (str): The message to print.\n\nReturns: \n- None\n\nRaises: \n- None",
        "signature": "def verbose(self, message):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.warning": {
        "code": "    def warning(self, message):\n        \"\"\"Write a warning message to STDOUT unless quiet mode is activated. The message will be prefixed with \"WARNING:  \" and any newlines within the message will also be prefixed with this label to maintain format. \n\nParameters:\n- message (str): The warning message to print to the console.\n\nReturns: None\n\nThis method utilizes the 'quiet' attribute from the 'args' object during initialization to determine whether to suppress output. It is designed to serve the purpose of conveying warning-level notifications in a user-friendly manner.\"\"\"\n        '\\n        Write a warning message to STDOUT unless quiet mode is active.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        if not self.args.quiet:\n            print('WARNING:  ' + str(message).replace('\\n', '\\nWARNING:  '))",
        "docstring": "Write a warning message to STDOUT unless quiet mode is activated. The message will be prefixed with \"WARNING:  \" and any newlines within the message will also be prefixed with this label to maintain format. \n\nParameters:\n- message (str): The warning message to print to the console.\n\nReturns: None\n\nThis method utilizes the 'quiet' attribute from the 'args' object during initialization to determine whether to suppress output. It is designed to serve the purpose of conveying warning-level notifications in a user-friendly manner.",
        "signature": "def warning(self, message):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.error": {
        "code": "    def error(self, message, exit_code=None):\n        \"\"\"Write a recoverable error message to STDERR using a standardized format. If provided, the method can terminate the program with an optional exit code.\n\nParameters:\n- message (str): The error message to print, which will be prefixed with \"ERROR: \".\n- exit_code (int, optional): The exit code to terminate the program with if specified; defaults to None.\n\nThe method interacts with `sys.stderr` to print the error message and `sys.stdout` to flush the output buffer. If an `exit_code` is given, it logs a debug message indicating the termination and calls `sys.exit(exit_code)` to exit the program.\"\"\"\n        '\\n        Write a recoverable error message to STDERR.\\n\\n        Optionally terminates the program, exiting with a specific error code.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n        2. exit_code (int) The exit code to terminate the program with;\\n           default=None\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        print('ERROR:  ' + str(message).replace('\\n', '\\nERROR:  '), file=sys.stderr)\n        print('Please try --help for more information.')\n        sys.stdout.flush()\n        if exit_code is not None:\n            self.debug('Terminating with exit code, {}.'.format(exit_code))\n            sys.exit(exit_code)",
        "docstring": "Write a recoverable error message to STDERR using a standardized format. If provided, the method can terminate the program with an optional exit code.\n\nParameters:\n- message (str): The error message to print, which will be prefixed with \"ERROR: \".\n- exit_code (int, optional): The exit code to terminate the program with if specified; defaults to None.\n\nThe method interacts with `sys.stderr` to print the error message and `sys.stdout` to flush the output buffer. If an `exit_code` is given, it logs a debug message indicating the termination and calls `sys.exit(exit_code)` to exit the program.",
        "signature": "def error(self, message, exit_code=None):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.critical": {
        "code": "    def critical(self, message, exit_code=1):\n        \"\"\"Writes a critical, non-recoverable failure message to STDERR and terminates the program.\n\nParameters:\n1. message (str): The message to print, which will indicate the critical failure.\n2. exit_code (int): The exit code to terminate the program with; defaults to 1.\n\nThis method formats the provided message prefixed with \"CRITICAL: \" and sends it to standard error output (STDERR). It also flushes standard output (STDOUT) to ensure all output is visible before exiting. If debugging is enabled, it logs a debug message about the termination with the specified exit code before invoking `sys.exit()` to stop the program. The default exit code signifies a general error unless specified otherwise.\"\"\"\n        '\\n        Write a critical, nonrecoverable failure message to STDERR and abend.\\n\\n        Terminates the program, exiting with a specific error code.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n        2. exit_code (int) The exit code to terminate the program with;\\n           default=1\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        print('CRITICAL:  ' + str(message).replace('\\n', '\\nCRITICAL:  '), file=sys.stderr)\n        sys.stdout.flush()\n        self.debug('Terminating with exit code, {}.'.format(exit_code))\n        sys.exit(exit_code)",
        "docstring": "Writes a critical, non-recoverable failure message to STDERR and terminates the program.\n\nParameters:\n1. message (str): The message to print, which will indicate the critical failure.\n2. exit_code (int): The exit code to terminate the program with; defaults to 1.\n\nThis method formats the provided message prefixed with \"CRITICAL: \" and sends it to standard error output (STDERR). It also flushes standard output (STDOUT) to ensure all output is visible before exiting. If debugging is enabled, it logs a debug message about the termination with the specified exit code before invoking `sys.exit()` to stop the program. The default exit code signifies a general error unless specified otherwise.",
        "signature": "def critical(self, message, exit_code=1):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      },
      "ConsolePrinter.debug": {
        "code": "    def debug(self, message, **kwargs):\n        \"\"\"Write a debug message to STDOUT if debugging is enabled and quiet mode is inactive. This method supports rich output by recursively printing key-value pairs from dictionaries and elements from lists or other collections.\n\nParameters:\n- message (str): The main message to display.\n- kwargs: Optional keyword arguments to customize output:\n  - data (Any): Additional data to dump alongside the main message.\n  - header (str): Text to display before the debug message body.\n  - footer (str): Text to display after the debug message body.\n  - prefix (str): A prefix added to each line of output.\n  - data_header (str): Text displayed before the optional data.\n  - data_footer (str): Text displayed after the optional data.\n\nThe method leverages the `args` attribute to check the debugging state: `self.args.debug` enables debugging output, while `self.args.quiet` suppresses output unless set to false. It also interacts with the `_debug_dump` static method to format and display the message and any associated data.\"\"\"\n        '\\n        Write a debug message to STDOUT unless quiet mode is active.\\n\\n        Dumps all key-value pairs of a dictionary or all elements of a list,\\n        when the message is either.\\n\\n        Positional Parameters:\\n        1. message (str) The message to print\\n\\n        Keyword Arguments:\\n        * data (Any) Data to recursively add to the DEBUG message\\n        * header (str) Line printed before the body of the DEBUG message\\n        * footer (str) Line printed after the body of the DEBUG message\\n        * prefix (str) String prefixed to every DEBUG line comprising the\\n          entirety of the DEBUG message, including any optional data\\n        * data_header (str) Line printed before the optional data, if any\\n        * data_footer (str) Line printed after the optional data, if any\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        if self.args.debug and (not self.args.quiet):\n            header = kwargs.pop('header', '')\n            footer = kwargs.pop('footer', '')\n            prefix = kwargs.pop('prefix', '')\n            if header:\n                print(ConsolePrinter._debug_prefix_lines('{}{}'.format(prefix, header)))\n            for line in ConsolePrinter._debug_dump(message, prefix=prefix):\n                print(line)\n            if 'data' in kwargs:\n                data_header = kwargs.pop('data_header', '')\n                data_footer = kwargs.pop('data_footer', '')\n                if data_header:\n                    print(ConsolePrinter._debug_prefix_lines('{}{}'.format(prefix, data_header)))\n                for line in ConsolePrinter._debug_dump(kwargs.pop('data'), prefix=prefix, print_type=True):\n                    print(line)\n                if data_footer:\n                    print(ConsolePrinter._debug_prefix_lines('{}{}'.format(prefix, data_footer)))\n            if footer:\n                print(ConsolePrinter._debug_prefix_lines('{}{}'.format(prefix, footer)))",
        "docstring": "Write a debug message to STDOUT if debugging is enabled and quiet mode is inactive. This method supports rich output by recursively printing key-value pairs from dictionaries and elements from lists or other collections.\n\nParameters:\n- message (str): The main message to display.\n- kwargs: Optional keyword arguments to customize output:\n  - data (Any): Additional data to dump alongside the main message.\n  - header (str): Text to display before the debug message body.\n  - footer (str): Text to display after the debug message body.\n  - prefix (str): A prefix added to each line of output.\n  - data_header (str): Text displayed before the optional data.\n  - data_footer (str): Text displayed after the optional data.\n\nThe method leverages the `args` attribute to check the debugging state: `self.args.debug` enables debugging output, while `self.args.quiet` suppresses output unless set to false. It also interacts with the `_debug_dump` static method to format and display the message and any associated data.",
        "signature": "def debug(self, message, **kwargs):",
        "type": "Method",
        "class_signature": "class ConsolePrinter:"
      }
    },
    "yamlpath/wrappers/nodecoords.py": {
      "NodeCoords.__init__": {
        "code": "    def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:\n        \"\"\"Initialize a new instance of NodeCoords, which wraps a node's data along with its relative coordinates within a Document Object Model (DOM). This includes references to the node itself, its immediate parent, and the key or index of the node within its parent. \n\nParameters:\n- node (Any): A reference to the ruamel.yaml DOM data element.\n- parent (Any): A reference to the immediate parent node of the `node`.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the position of `node` within `parent`.\n- path (Optional[YAMLPath]): The YAML Path corresponding to this node, used for tracking.\n- ancestry (Optional[List[AncestryEntry]]): A stack of AncestryEntry tracking the hierarchical ancestry of this node within the parent document.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that led to the creation of this NodeCoords.\n\nReturns:\nN/A\n\nRaises:\nN/A\n\nThis initializer interacts with other parts of the NodeCoords class, defining essential attributes like `self.path` and `self.ancestry`, which facilitate navigation and manipulation of the DOM structure.\"\"\"\n        \"\\n        Initialize a new NodeCoords.\\n\\n        Positional Parameters:\\n        1. node (Any) Reference to the ruamel.yaml DOM data element\\n        2. parent (Any) Reference to `node`'s immediate DOM parent\\n        3. parentref (Any) The `list` index or `dict` key which indicates where\\n           within `parent` the `node` is located\\n        4. path (YAMLPath) The YAML Path for this node, as reported by its\\n           creator process\\n        5. ancestry (List[AncestryEntry]) Stack of AncestryEntry (parent,\\n           parentref) tracking the hierarchical ancestry of this node through\\n           its parent document\\n        6. path_segment (PathSegment) The YAML Path segment which most directly\\n           caused the generation of this NodeCoords\\n\\n        Returns: N/A\\n\\n        Raises:  N/A\\n        \"\n        self.node: Any = node\n        self.parent: Any = parent\n        self.parentref: Any = parentref\n        self.path: Optional[YAMLPath] = path\n        self.ancestry: List[AncestryEntry] = [] if ancestry is None else ancestry\n        self.path_segment: Optional[PathSegment] = path_segment",
        "docstring": "Initialize a new instance of NodeCoords, which wraps a node's data along with its relative coordinates within a Document Object Model (DOM). This includes references to the node itself, its immediate parent, and the key or index of the node within its parent. \n\nParameters:\n- node (Any): A reference to the ruamel.yaml DOM data element.\n- parent (Any): A reference to the immediate parent node of the `node`.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the position of `node` within `parent`.\n- path (Optional[YAMLPath]): The YAML Path corresponding to this node, used for tracking.\n- ancestry (Optional[List[AncestryEntry]]): A stack of AncestryEntry tracking the hierarchical ancestry of this node within the parent document.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that led to the creation of this NodeCoords.\n\nReturns:\nN/A\n\nRaises:\nN/A\n\nThis initializer interacts with other parts of the NodeCoords class, defining essential attributes like `self.path` and `self.ancestry`, which facilitate navigation and manipulation of the DOM structure.",
        "signature": "def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      }
    },
    "yamlpath/yamlpath.py": {
      "YAMLPath.__init__": {
        "code": "    def __init__(self, yaml_path: Union['YAMLPath', str, None]='', pathsep: PathSeparators=PathSeparators.AUTO) -> None:\n        \"\"\"Initialize a YAMLPath object to manage and parse YAML Path strings.\n\nParameters:\n1. yaml_path (Union[\"YAMLPath\", str, None]): The YAML Path to parse or copy. If provided an existing YAMLPath instance, it copies its original path. If None, it initializes an empty path.\n2. pathsep (PathSeparators): Specifies the segment separator for the YAML Path. It defaults to PathSeparators.AUTO, which allows automatic inference of the separator from the given path.\n\nAttributes initialized:\n- _separator: Holds the segment separator, set to the provided `pathsep`.\n- _original: Stores the original unmodified YAML Path as a string.\n- _unescaped: A deque that will eventually hold a parsed representation of the YAML Path without escaped characters.\n- _escaped: A deque that will hold the escaped parsed representation of the YAML Path.\n- _stringified: A string representation of the YAML Path, initialized as empty.\n\nThis constructor sets up the data structure needed for subsequent parsing and operations of the YAML Path, ensuring that if an existing path is provided, its original string is retained for further processing.\"\"\"\n        '\\n        Instantiate this class into an object.\\n\\n        Parameters:\\n        1. yaml_path (Union[\"YAMLPath\", str, None]) The YAML Path to parse or\\n           copy\\n        2. pathsep (PathSeparators) Forced YAML Path segment separator; set\\n           only when automatic inference fails\\n\\n        Returns:  N/A\\n\\n        Raises:  N/A\\n        '\n        self._separator: PathSeparators = pathsep\n        self._original: str = ''\n        self._unescaped: deque = deque()\n        self._escaped: deque = deque()\n        self._stringified: str = ''\n        if isinstance(yaml_path, YAMLPath):\n            self.original = yaml_path.original\n        else:\n            self.original = '' if yaml_path is None else yaml_path",
        "docstring": "Initialize a YAMLPath object to manage and parse YAML Path strings.\n\nParameters:\n1. yaml_path (Union[\"YAMLPath\", str, None]): The YAML Path to parse or copy. If provided an existing YAMLPath instance, it copies its original path. If None, it initializes an empty path.\n2. pathsep (PathSeparators): Specifies the segment separator for the YAML Path. It defaults to PathSeparators.AUTO, which allows automatic inference of the separator from the given path.\n\nAttributes initialized:\n- _separator: Holds the segment separator, set to the provided `pathsep`.\n- _original: Stores the original unmodified YAML Path as a string.\n- _unescaped: A deque that will eventually hold a parsed representation of the YAML Path without escaped characters.\n- _escaped: A deque that will hold the escaped parsed representation of the YAML Path.\n- _stringified: A string representation of the YAML Path, initialized as empty.\n\nThis constructor sets up the data structure needed for subsequent parsing and operations of the YAML Path, ensuring that if an existing path is provided, its original string is retained for further processing.",
        "signature": "def __init__(self, yaml_path: Union['YAMLPath', str, None]='', pathsep: PathSeparators=PathSeparators.AUTO) -> None:",
        "type": "Method",
        "class_signature": "class YAMLPath:"
      }
    },
    "yamlpath/patches/timestamp.py": {
      "AnchoredTimeStamp.__init__": {
        "code": "    def __init__(self, *args: Any, **kw: Any) -> None:\n        \"\"\"Initialize a new instance of the AnchoredTimeStamp class, which extends the TimeStamp class from the ruamel.yaml library to track YAML anchors. This constructor accepts arbitrary positional and keyword arguments, which are forwarded to the parent TimeStamp class for initialization. Additionally, it initializes an internal dictionary attribute, `_yaml`, to store metadata related to the timestamp, including flags for `t` (a boolean indicating the presence of a timezone), `tz` (a string for timezone information), and `delta` (a datetime.timedelta object representing any time offset). This setup allows the AnchoredTimeStamp instances to be represented in YAML with both standard timestamp functionality and YAML anchor capabilities.\"\"\"\n        'Initialize a new instance.'\n        self._yaml: Dict[Any, Any] = dict(t=False, tz=None, delta=0)",
        "docstring": "Initialize a new instance of the AnchoredTimeStamp class, which extends the TimeStamp class from the ruamel.yaml library to track YAML anchors. This constructor accepts arbitrary positional and keyword arguments, which are forwarded to the parent TimeStamp class for initialization. Additionally, it initializes an internal dictionary attribute, `_yaml`, to store metadata related to the timestamp, including flags for `t` (a boolean indicating the presence of a timezone), `tz` (a string for timezone information), and `delta` (a datetime.timedelta object representing any time offset). This setup allows the AnchoredTimeStamp instances to be represented in YAML with both standard timestamp functionality and YAML anchor capabilities.",
        "signature": "def __init__(self, *args: Any, **kw: Any) -> None:",
        "type": "Method",
        "class_signature": "class AnchoredTimeStamp(TimeStamp):"
      },
      "AnchoredTimeStamp.__new__": {
        "code": "    def __new__(cls, *args: Any, **kw: Any) -> Any:\n        \"\"\"Create a new immutable instance of the AnchoredTimeStamp class. This method overrides the default __new__ behavior to handle YAML anchors, allowing the timestamp to be associated with an anchor attribute. It takes optional parameters that can specify an anchor, and if provided, it sets this anchor with the property always_dump set to True.\n\nParameters:\n- cls: The class being instantiated (AnchoredTimeStamp).\n- args: Positional arguments for constructing the TimeStamp instance (year, month, day, etc.).\n- kw: Keyword arguments that may include 'anchor', specifying the anchor's name.\n\nReturns:\n- An instance of AnchoredTimeStamp with the specified properties and anchor.\n\nSide Effects:\n- Sets a YAML anchor on the timestamp if the 'anchor' parameter is provided.\n\nDependencies:\n- This method relies on the TimeStamp class from the ruamel.yaml.timestamp module to create a new datetime object. The variable 'anchor' is defined in the method and is used to associate a YAML anchor, enabling better serialization in YAML context.\"\"\"\n        'Create a new, immutable instance.'\n        anchor = kw.pop('anchor', None)\n        ts = TimeStamp.__new__(cls, *args, **kw)\n        if anchor is not None:\n            ts.yaml_set_anchor(anchor, always_dump=True)\n        return ts",
        "docstring": "Create a new immutable instance of the AnchoredTimeStamp class. This method overrides the default __new__ behavior to handle YAML anchors, allowing the timestamp to be associated with an anchor attribute. It takes optional parameters that can specify an anchor, and if provided, it sets this anchor with the property always_dump set to True.\n\nParameters:\n- cls: The class being instantiated (AnchoredTimeStamp).\n- args: Positional arguments for constructing the TimeStamp instance (year, month, day, etc.).\n- kw: Keyword arguments that may include 'anchor', specifying the anchor's name.\n\nReturns:\n- An instance of AnchoredTimeStamp with the specified properties and anchor.\n\nSide Effects:\n- Sets a YAML anchor on the timestamp if the 'anchor' parameter is provided.\n\nDependencies:\n- This method relies on the TimeStamp class from the ruamel.yaml.timestamp module to create a new datetime object. The variable 'anchor' is defined in the method and is used to associate a YAML anchor, enabling better serialization in YAML context.",
        "signature": "def __new__(cls, *args: Any, **kw: Any) -> Any:",
        "type": "Method",
        "class_signature": "class AnchoredTimeStamp(TimeStamp):"
      }
    }
  },
  "dependency_dict": {
    "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {
      "yamlpath/wrappers/consoleprinter.py": {
        "ConsolePrinter._debug_prefix_lines": {
          "code": "    def _debug_prefix_lines(line: str) -> str:\n        return 'DEBUG:  {}'.format(str(line).replace('\\n', '\\nDEBUG:  '))",
          "docstring": "",
          "signature": "def _debug_prefix_lines(line: str) -> str:",
          "type": "Method",
          "class_signature": "class ConsolePrinter:"
        },
        "ConsolePrinter._debug_dump": {
          "code": "    def _debug_dump(data: Any, **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        if isinstance(data, dict):\n            for line in ConsolePrinter._debug_dict(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, (list, tuple, deque)):\n            for line in ConsolePrinter._debug_list(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, (set, CommentedSet)):\n            for line in ConsolePrinter._debug_set(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, NodeCoords):\n            for line in ConsolePrinter._debug_node_coord(data, prefix=prefix, **kwargs):\n                yield line\n        else:\n            yield ConsolePrinter._debug_scalar(data, prefix=prefix, **kwargs)",
          "docstring": "",
          "signature": "def _debug_dump(data: Any, **kwargs) -> Generator[str, None, None]:",
          "type": "Method",
          "class_signature": "class ConsolePrinter:"
        }
      }
    },
    "yamlpath/yamlpath.py:YAMLPath:__init__": {
      "yamlpath/yamlpath.py": {
        "YAMLPath.original": {
          "code": "    def original(self, value: str) -> None:\n        \"\"\"\n        Original YAML Path mutator.\n\n        Parameters:\n        1. value (str) A YAML Path in string form\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        str_val = str(value)\n        if not str_val.strip():\n            str_val = ''\n        self._original = str_val\n        self._separator = PathSeparators.AUTO\n        self._unescaped = deque()\n        self._escaped = deque()\n        self._stringified = ''",
          "docstring": "Original YAML Path mutator.\n\nParameters:\n1. value (str) A YAML Path in string form\n\nReturns:  N/A\n\nRaises:  N/A",
          "signature": "def original(self, value: str) -> None:",
          "type": "Method",
          "class_signature": "class YAMLPath:"
        }
      }
    },
    "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:error": {},
    "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:critical": {}
  },
  "call_tree": {
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_info_noisy": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:info": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_info_quiet": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:info": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_verbose_off": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:verbose": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_verbose_noisy": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:verbose": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_verbose_quiet": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:verbose": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_debug_off": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_debug_noisy": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_dump": {
          "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_scalar": {
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_get_anchor": {},
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_prefix_lines": {},
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_scalar": {
              "[ignored_or_cut_off]": "..."
            }
          },
          "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_list": {
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_dump": {
              "[ignored_or_cut_off]": "..."
            }
          },
          "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_dict": {
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_get_kv_anchors": {
              "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_get_anchor": {
                "yamlpath/patches/timestamp.py:AnchoredTimeStamp:anchor": {}
              }
            },
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_get_kv_tags": {
              "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_get_tag": {}
            },
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_dump": {
              "[ignored_or_cut_off]": "..."
            }
          },
          "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_node_coord": {
            "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_dump": {
              "[ignored_or_cut_off]": "..."
            }
          }
        },
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:_debug_prefix_lines": {}
      },
      "yamlpath/patches/timestamp.py:AnchoredTimeStamp:__new__": {},
      "yamlpath/patches/timestamp.py:AnchoredTimeStamp:__init__": {},
      "yamlpath/yamlpath.py:YAMLPath:__init__": {
        "yamlpath/yamlpath.py:YAMLPath:original": {}
      },
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_debug_quiet": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_warning_noisy": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:warning": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_warning_quiet": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:warning": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_error_noisy_nonexit": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:error": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_error_quiet_nonexit": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:error": {}
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_error_noisy_exit": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:error": {
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
      }
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_error_quiet_exit": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:error": {
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
      }
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_critical_noisy": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:critical": {
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
      }
    },
    "tests/test_wrappers_consoleprinter.py:Test_wrappers_ConsolePrinter:test_critical_quiet": {
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:__init__": {},
      "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:critical": {
        "yamlpath/wrappers/consoleprinter.py:ConsolePrinter:debug": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: yamlpath-test_wrappers_consoleprinter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamlpath/\n    \u251c\u2500\u2500 patches/\n    \u2502   \u2514\u2500\u2500 timestamp.py\n    \u2502       \u251c\u2500\u2500 AnchoredTimeStamp.__init__\n    \u2502       \u2514\u2500\u2500 AnchoredTimeStamp.__new__\n    \u251c\u2500\u2500 wrappers/\n    \u2502   \u251c\u2500\u2500 consoleprinter.py\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.critical\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.debug\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.error\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.info\n    \u2502   \u2502   \u251c\u2500\u2500 ConsolePrinter.verbose\n    \u2502   \u2502   \u2514\u2500\u2500 ConsolePrinter.warning\n    \u2502   \u2514\u2500\u2500 nodecoords.py\n    \u2502       \u2514\u2500\u2500 NodeCoords.__init__\n    \u2514\u2500\u2500 yamlpath.py\n        \u2514\u2500\u2500 YAMLPath.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a logging utility tailored for structured outputs and selective verbosity levels to manage messaging during application execution or testing. It supports capabilities such as conditional logging based on verbosity, quiet, or debug modes, and renders informational, warning, and error messages with varying levels of detail. Additionally, it enables developers to output complex YAML data structures, tagged elements, and nested node metadata in a clear, human-readable format. This solves the problem of effectively debugging YAML-based configurations and applications with detailed and context-aware logs, while maintaining flexibility in message visibility for different runtime environments or user preferences.\n\n## FILE 1: yamlpath/wrappers/consoleprinter.py\n\n- CLASS METHOD: ConsolePrinter.__init__\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def __init__(self, args):\n  - DOCSTRING: \n```python\n\"\"\"\nInstantiate a ConsolePrinter object for managing console output based on defined log level settings.\n\nParameters:\n- args (object): An object containing log level attributes:\n    - debug (bool): Enables output of debugging messages when set to True.\n    - verbose (bool): Enables output of verbose informational messages when set to True.\n    - quiet (bool): Suppresses all output except for error messages when set to True.\n\nReturns: None\n\nUsage: This constructor initializes the ConsolePrinter with the specified logging settings, allowing the subsequent use of methods like info(), verbose(), warning(), error(), critical(), and debug() for conditional message output. No exceptions are raised during this initialization process.\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.error\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def error(self, message, exit_code=None):\n  - DOCSTRING: \n```python\n\"\"\"\nWrite a recoverable error message to STDERR using a standardized format. If provided, the method can terminate the program with an optional exit code.\n\nParameters:\n- message (str): The error message to print, which will be prefixed with \"ERROR: \".\n- exit_code (int, optional): The exit code to terminate the program with if specified; defaults to None.\n\nThe method interacts with `sys.stderr` to print the error message and `sys.stdout` to flush the output buffer. If an `exit_code` is given, it logs a debug message indicating the termination and calls `sys.exit(exit_code)` to exit the program.\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.debug\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def debug(self, message, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nWrite a debug message to STDOUT if debugging is enabled and quiet mode is inactive. This method supports rich output by recursively printing key-value pairs from dictionaries and elements from lists or other collections.\n\nParameters:\n- message (str): The main message to display.\n- kwargs: Optional keyword arguments to customize output:\n  - data (Any): Additional data to dump alongside the main message.\n  - header (str): Text to display before the debug message body.\n  - footer (str): Text to display after the debug message body.\n  - prefix (str): A prefix added to each line of output.\n  - data_header (str): Text displayed before the optional data.\n  - data_footer (str): Text displayed after the optional data.\n\nThe method leverages the `args` attribute to check the debugging state: `self.args.debug` enables debugging output, while `self.args.quiet` suppresses output unless set to false. It also interacts with the `_debug_dump` static method to format and display the message and any associated data.\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.critical\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def critical(self, message, exit_code=1):\n  - DOCSTRING: \n```python\n\"\"\"\nWrites a critical, non-recoverable failure message to STDERR and terminates the program.\n\nParameters:\n1. message (str): The message to print, which will indicate the critical failure.\n2. exit_code (int): The exit code to terminate the program with; defaults to 1.\n\nThis method formats the provided message prefixed with \"CRITICAL: \" and sends it to standard error output (STDERR). It also flushes standard output (STDOUT) to ensure all output is visible before exiting. If debugging is enabled, it logs a debug message about the termination with the specified exit code before invoking `sys.exit()` to stop the program. The default exit code signifies a general error unless specified otherwise.\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.warning\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def warning(self, message):\n  - DOCSTRING: \n```python\n\"\"\"\nWrite a warning message to STDOUT unless quiet mode is activated. The message will be prefixed with \"WARNING:  \" and any newlines within the message will also be prefixed with this label to maintain format. \n\nParameters:\n- message (str): The warning message to print to the console.\n\nReturns: None\n\nThis method utilizes the 'quiet' attribute from the 'args' object during initialization to determine whether to suppress output. It is designed to serve the purpose of conveying warning-level notifications in a user-friendly manner.\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.verbose\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def verbose(self, message):\n  - DOCSTRING: \n```python\n\"\"\"\nWrite a verbose message to STDOUT when verbose mode is active and quiet mode is not enabled. The method checks the state of the `quiet`, `verbose`, and `debug` properties of the `args` object passed during the initialization of the `ConsolePrinter`. If `quiet` is set to `True`, no output will be printed. If `verbose` or `debug` is `True`, the provided message is printed to the console.\n\nParameters:\n- message (str): The message to print.\n\nReturns: \n- None\n\nRaises: \n- None\n\"\"\"\n```\n\n- CLASS METHOD: ConsolePrinter.info\n  - CLASS SIGNATURE: class ConsolePrinter:\n  - SIGNATURE: def info(self, message):\n  - DOCSTRING: \n```python\n\"\"\"\nWrite an informational message to STDOUT unless quiet mode is active.\n\nParameters:\n- message (str): The informational message to be printed to the console.\n\nReturns:\n- None\n\nSide Effects:\n- If the 'quiet' attribute of the 'args' object (passed during initialization of the ConsolePrinter) is set to False, the message will be printed to the standard output. If 'quiet' is True, no output will be produced.\n\nDependencies:\n- The method relies on the 'args' attribute of the ConsolePrinter instance, which is an object containing settings for logging verbosity. The 'quiet' property is particularly significant as it controls whether any informational messages are displayed.\n\"\"\"\n```\n\n## FILE 2: yamlpath/wrappers/nodecoords.py\n\n- CLASS METHOD: NodeCoords.__init__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new instance of NodeCoords, which wraps a node's data along with its relative coordinates within a Document Object Model (DOM). This includes references to the node itself, its immediate parent, and the key or index of the node within its parent. \n\nParameters:\n- node (Any): A reference to the ruamel.yaml DOM data element.\n- parent (Any): A reference to the immediate parent node of the `node`.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the position of `node` within `parent`.\n- path (Optional[YAMLPath]): The YAML Path corresponding to this node, used for tracking.\n- ancestry (Optional[List[AncestryEntry]]): A stack of AncestryEntry tracking the hierarchical ancestry of this node within the parent document.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that led to the creation of this NodeCoords.\n\nReturns:\nN/A\n\nRaises:\nN/A\n\nThis initializer interacts with other parts of the NodeCoords class, defining essential attributes like `self.path` and `self.ancestry`, which facilitate navigation and manipulation of the DOM structure.\n\"\"\"\n```\n\n## FILE 3: yamlpath/yamlpath.py\n\n- CLASS METHOD: YAMLPath.__init__\n  - CLASS SIGNATURE: class YAMLPath:\n  - SIGNATURE: def __init__(self, yaml_path: Union['YAMLPath', str, None]='', pathsep: PathSeparators=PathSeparators.AUTO) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a YAMLPath object to manage and parse YAML Path strings.\n\nParameters:\n1. yaml_path (Union[\"YAMLPath\", str, None]): The YAML Path to parse or copy. If provided an existing YAMLPath instance, it copies its original path. If None, it initializes an empty path.\n2. pathsep (PathSeparators): Specifies the segment separator for the YAML Path. It defaults to PathSeparators.AUTO, which allows automatic inference of the separator from the given path.\n\nAttributes initialized:\n- _separator: Holds the segment separator, set to the provided `pathsep`.\n- _original: Stores the original unmodified YAML Path as a string.\n- _unescaped: A deque that will eventually hold a parsed representation of the YAML Path without escaped characters.\n- _escaped: A deque that will hold the escaped parsed representation of the YAML Path.\n- _stringified: A string representation of the YAML Path, initialized as empty.\n\nThis constructor sets up the data structure needed for subsequent parsing and operations of the YAML Path, ensuring that if an existing path is provided, its original string is retained for further processing.\n\"\"\"\n```\n\n## FILE 4: yamlpath/patches/timestamp.py\n\n- CLASS METHOD: AnchoredTimeStamp.__new__\n  - CLASS SIGNATURE: class AnchoredTimeStamp(TimeStamp):\n  - SIGNATURE: def __new__(cls, *args: Any, **kw: Any) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new immutable instance of the AnchoredTimeStamp class. This method overrides the default __new__ behavior to handle YAML anchors, allowing the timestamp to be associated with an anchor attribute. It takes optional parameters that can specify an anchor, and if provided, it sets this anchor with the property always_dump set to True.\n\nParameters:\n- cls: The class being instantiated (AnchoredTimeStamp).\n- args: Positional arguments for constructing the TimeStamp instance (year, month, day, etc.).\n- kw: Keyword arguments that may include 'anchor', specifying the anchor's name.\n\nReturns:\n- An instance of AnchoredTimeStamp with the specified properties and anchor.\n\nSide Effects:\n- Sets a YAML anchor on the timestamp if the 'anchor' parameter is provided.\n\nDependencies:\n- This method relies on the TimeStamp class from the ruamel.yaml.timestamp module to create a new datetime object. The variable 'anchor' is defined in the method and is used to associate a YAML anchor, enabling better serialization in YAML context.\n\"\"\"\n```\n\n- CLASS METHOD: AnchoredTimeStamp.__init__\n  - CLASS SIGNATURE: class AnchoredTimeStamp(TimeStamp):\n  - SIGNATURE: def __init__(self, *args: Any, **kw: Any) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new instance of the AnchoredTimeStamp class, which extends the TimeStamp class from the ruamel.yaml library to track YAML anchors. This constructor accepts arbitrary positional and keyword arguments, which are forwarded to the parent TimeStamp class for initialization. Additionally, it initializes an internal dictionary attribute, `_yaml`, to store metadata related to the timestamp, including flags for `t` (a boolean indicating the presence of a timezone), `tz` (a string for timezone information), and `delta` (a datetime.timedelta object representing any time offset). This setup allows the AnchoredTimeStamp instances to be represented in YAML with both standard timestamp functionality and YAML anchor capabilities.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamlpath/wrappers/consoleprinter.py": "\"\"\"\nImplements a reusable console print facility for simple command-line scripts.\n\nOther implementations can easily wrap Python's standard logger/warning modules,\nbut this one does not because those are overkill for *simple* STDOUT/STDERR\nprinting (that must support squelching).\n\nRequires an object on init which has the following properties:\n  quiet:  <Boolean> suppresses all output except ConsolePrinter::error() and\n          ::critical().\n  verbose:  <Boolean> allows output from ConsolePrinter::verbose().\n  debug:  <Boolean> allows output from ConsolePrinter::debug().\n\nCopyright 2018, 2019, 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nimport sys\nfrom collections import deque\nfrom typing import Any, Deque, Dict, Generator, List, Set, Tuple, Union\nfrom ruamel.yaml.comments import CommentedBase, CommentedMap, CommentedSet, TaggedScalar\nfrom yamlpath.patches.timestamp import AnchoredTimeStamp, AnchoredDate\nfrom yamlpath.wrappers.nodecoords import NodeCoords\n\nclass ConsolePrinter:\n    \"\"\"\n    Generally-useful console messager.\n\n    Writes INFO, VERBOSE, WARN, and DEBUG messages to STDOUT as well as ERROR\n    messages to STDERR with multi-lne formatting.\n    \"\"\"\n\n    @staticmethod\n    def _debug_prefix_lines(line: str) -> str:\n        return 'DEBUG:  {}'.format(str(line).replace('\\n', '\\nDEBUG:  '))\n\n    @staticmethod\n    def _debug_get_anchor(data: Any) -> str:\n        return '&{}'.format(data.anchor.value) if hasattr(data, 'anchor') and hasattr(data.anchor, 'value') and (data.anchor.value is not None) else ''\n\n    @staticmethod\n    def _debug_get_tag(data: Any) -> str:\n        return str(data.tag.value if hasattr(data, 'tag') and hasattr(data.tag, 'value') and (data.tag.value is not None) else '')\n\n    @staticmethod\n    def _debug_dump(data: Any, **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        if isinstance(data, dict):\n            for line in ConsolePrinter._debug_dict(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, (list, tuple, deque)):\n            for line in ConsolePrinter._debug_list(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, (set, CommentedSet)):\n            for line in ConsolePrinter._debug_set(data, prefix=prefix, **kwargs):\n                yield line\n        elif isinstance(data, NodeCoords):\n            for line in ConsolePrinter._debug_node_coord(data, prefix=prefix, **kwargs):\n                yield line\n        else:\n            yield ConsolePrinter._debug_scalar(data, prefix=prefix, **kwargs)\n\n    @staticmethod\n    def _debug_scalar(data: Any, **kwargs) -> str:\n        prefix = kwargs.pop('prefix', '')\n        print_anchor = kwargs.pop('print_anchor', True)\n        print_tag = kwargs.pop('print_tag', True)\n        print_type = kwargs.pop('print_type', False)\n        dtype: str = str(type(data)) if print_type else ''\n        anchor_prefix = ''\n        print_prefix = prefix\n        if print_anchor:\n            anchor = ConsolePrinter._debug_get_anchor(data)\n            if anchor:\n                anchor_prefix = '({})'.format(anchor)\n        if print_tag:\n            if isinstance(data, TaggedScalar):\n                tag_prefix = '{}{}<{}>'.format(print_prefix, anchor_prefix, data.tag.value)\n                return ConsolePrinter._debug_scalar(data.value, prefix=tag_prefix, print_anchor=False, print_tag=False, print_type=True)\n        if isinstance(data, TaggedScalar):\n            dtype = '{}({})'.format(dtype, type(data.value))\n        if hasattr(data, 'fold_pos'):\n            dtype += ',folded@{}'.format(data.fold_pos)\n        print_prefix += anchor_prefix\n        if isinstance(data, AnchoredDate):\n            print_line = data.date().isoformat()\n        elif isinstance(data, AnchoredTimeStamp):\n            from yamlpath.common.nodes import Nodes\n            print_line = Nodes.get_timestamp_with_tzinfo(data).isoformat()\n        else:\n            print_line = str(data).replace('\\n', '\\n{}'.format(print_prefix))\n        return ConsolePrinter._debug_prefix_lines('{}{}{}'.format(print_prefix, print_line, dtype))\n\n    @staticmethod\n    def _debug_node_coord(data: NodeCoords, **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        path_prefix = '{}(path)'.format(prefix)\n        segment_prefix = '{}(segment)'.format(prefix)\n        node_prefix = '{}(node)'.format(prefix)\n        parent_prefix = '{}(parent)'.format(prefix)\n        parentref_prefix = '{}(parentref)'.format(prefix)\n        ancestry_prefix = '{}(ancestry)'.format(prefix)\n        for line in ConsolePrinter._debug_dump(data.path, prefix=path_prefix):\n            yield line\n        for line in ConsolePrinter._debug_dump(data.path_segment, prefix=segment_prefix):\n            yield line\n        for line in ConsolePrinter._debug_dump(data.node, prefix=node_prefix):\n            yield line\n        for line in ConsolePrinter._debug_dump(data.parent, prefix=parent_prefix):\n            yield line\n        for line in ConsolePrinter._debug_dump(data.parentref, prefix=parentref_prefix):\n            yield line\n        for line in ConsolePrinter._debug_dump(data.ancestry, prefix=ancestry_prefix):\n            yield line\n\n    @staticmethod\n    def _debug_list(data: Union[List[Any], Set[Any], Tuple[Any, ...], Deque[Any]], **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        print_tag = kwargs.pop('print_tag', True)\n        if print_tag and isinstance(data, (CommentedBase, CommentedSet)) and hasattr(data, 'tag') and data.tag.value:\n            prefix += '<{}>'.format(data.tag.value)\n        for idx, ele in enumerate(data):\n            ele_prefix = '{}[{}]'.format(prefix, idx)\n            for line in ConsolePrinter._debug_dump(ele, prefix=ele_prefix, print_anchor=True, print_tag=True, print_type=True):\n                yield line\n\n    @staticmethod\n    def _debug_get_kv_anchors(key: Any, value: Any) -> str:\n        key_anchor = ConsolePrinter._debug_get_anchor(key)\n        val_anchor = ConsolePrinter._debug_get_anchor(value)\n        display_anchor = ''\n        if key_anchor and val_anchor:\n            display_anchor = '({},{})'.format(key_anchor, val_anchor)\n        elif key_anchor:\n            display_anchor = '({},_)'.format(key_anchor)\n        elif val_anchor:\n            display_anchor = '(_,{})'.format(val_anchor)\n        return display_anchor\n\n    @staticmethod\n    def _debug_get_kv_tags(key: Any, value: Any) -> str:\n        key_tag = ConsolePrinter._debug_get_tag(key)\n        val_tag = ConsolePrinter._debug_get_tag(value)\n        display_tag = ''\n        if key_tag and val_tag:\n            display_tag = '<{},{}>'.format(key_tag, val_tag)\n        elif key_tag:\n            display_tag = '<{},_>'.format(key_tag)\n        elif val_tag:\n            display_tag = '<_,{}>'.format(val_tag)\n        return display_tag\n\n    @staticmethod\n    def _debug_dict(data: Union[Dict, CommentedMap], **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        local_keys = []\n        if isinstance(data, CommentedMap):\n            for local_key, _ in data.non_merged_items():\n                local_keys.append(local_key)\n        else:\n            for key in data.keys():\n                local_keys.append(key)\n        for key, val in data.items():\n            display_key = str(key) if key in local_keys else '<<:{}:>>'.format(key)\n            display_anchor = ConsolePrinter._debug_get_kv_anchors(key, val)\n            display_tag = ConsolePrinter._debug_get_kv_tags(key, val)\n            kv_prefix = '{}[{}]{}{}'.format(prefix, display_key, display_anchor, display_tag)\n            for line in ConsolePrinter._debug_dump(val, prefix=kv_prefix, print_type=True, print_tag=False, print_anchor=False):\n                yield line\n\n    @staticmethod\n    def _debug_set(data: Union[Set, CommentedSet], **kwargs) -> Generator[str, None, None]:\n        prefix = kwargs.pop('prefix', '')\n        for key in data:\n            display_anchor = ConsolePrinter._debug_get_kv_anchors(key, None)\n            display_tag = ConsolePrinter._debug_get_kv_tags(key, None)\n            line = '{{{}}}{}{}'.format(key, display_anchor, display_tag)\n            yield ConsolePrinter._debug_prefix_lines('{}{}{}'.format(prefix, line, type(key)))",
    "yamlpath/wrappers/nodecoords.py": "\"\"\"\nImplement NodeCoords.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom typing import Any, List, Optional, Type\nfrom yamlpath.types import AncestryEntry, PathSegment\nfrom yamlpath import YAMLPath\n\nclass NodeCoords:\n    \"\"\"\n    Wrap a node's data along with its relative coordinates within its DOM.\n\n    A node's \"coordinates\" includes these properties:\n    1. Reference to the node itself,\n    2. Immediate parent node of the wrapped node,\n    3. Index or Key of the node within its immediate parent\n\n    Additional, optional data can be wrapped along with the node's coordinates\n    to facilitate other specific operations upon the node/DOM.  See the\n    `__init__` method for details.\n    \"\"\"\n\n    def __str__(self) -> str:\n        \"\"\"Get a String representation of this object.\"\"\"\n        return str(self.node)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Generate an eval()-safe representation of this object.\n\n        Assumes all of the ruamel.yaml components are similarly safe.\n        \"\"\"\n        return \"{}('{}', '{}', '{}')\".format(self.__class__.__name__, self.node, self.parent, self.parentref)\n\n    def __gt__(self, rhs: 'NodeCoords') -> Any:\n        \"\"\"Indicate whether this node's data is greater-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node > rhs.node\n\n    def __lt__(self, rhs: 'NodeCoords') -> Any:\n        \"\"\"Indicate whether this node's data is less-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node < rhs.node\n\n    @property\n    def unwrapped_node(self) -> Any:\n        \"\"\"Unwrap the data, no matter how deeply nested it may be.\"\"\"\n        return NodeCoords.unwrap_node_coords(self)\n\n    @property\n    def deepest_node_coord(self) -> 'NodeCoords':\n        \"\"\"Get the deepest wrapped NodeCoord contained within.\"\"\"\n        return NodeCoords._deepest_node_coord(self)\n\n    def wraps_a(self, compare_type: Type) -> bool:\n        \"\"\"Indicate whether the wrapped node is of a given data-type.\"\"\"\n        if compare_type is None:\n            return self.unwrapped_node is None\n        return isinstance(self.unwrapped_node, compare_type)\n\n    @staticmethod\n    def _deepest_node_coord(node: 'NodeCoords') -> 'NodeCoords':\n        \"\"\"Get the deepest nested NodeCoord.\"\"\"\n        if not isinstance(node, NodeCoords) or not isinstance(node.node, NodeCoords):\n            return node\n        return NodeCoords._deepest_node_coord(node.node)\n\n    @staticmethod\n    def unwrap_node_coords(data: Any) -> Any:\n        \"\"\"\n        Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\n        Parameters:\n        1. data (Any) the source data to strip.\n\n        Returns:  (Any) the stripped data.\n        \"\"\"\n        if isinstance(data, NodeCoords):\n            return NodeCoords.unwrap_node_coords(data.node)\n        if isinstance(data, list):\n            stripped_nodes = []\n            for ele in data:\n                stripped_nodes.append(NodeCoords.unwrap_node_coords(ele))\n            return stripped_nodes\n        return data",
    "yamlpath/yamlpath.py": "\"\"\"\nImplement YAML Path.\n\nCopyright 2019, 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom collections import deque\nfrom typing import Deque, List, Optional, Union\nfrom yamlpath.types import PathAttributes, PathSegment\nfrom yamlpath.exceptions import YAMLPathException, TypeMismatchYAMLPathException\nfrom yamlpath.enums import PathSegmentTypes, PathSearchKeywords, PathSearchMethods, PathSeparators, CollectorOperators\nfrom yamlpath.path import SearchKeywordTerms, SearchTerms, CollectorTerms\n\nclass YAMLPath:\n    \"\"\"\n    Encapsulate a YAML Path and its parsing logic.\n\n    This will keep track of:\n      * the original, unparsed, and unmodified YAML Path;\n      * its segment separator (inferred or manually specified);\n      * the unescaped, parsed representation of the YAML Path; and\n      * the escaped, parsed representation of the YAML Path.\n\n    Parsing operations are lazy and property setting smartly tiggers re-parsing\n    only when necessary.\n    \"\"\"\n\n    def __str__(self) -> str:\n        \"\"\"Get a stringified version of this object.\"\"\"\n        if self._stringified:\n            return self._stringified\n        self._stringified = YAMLPath._stringify_yamlpath_segments(self.unescaped, self.separator)\n        return self._stringified\n\n    def __repr__(self) -> str:\n        \"\"\"Generate an eval()-safe representation of this object.\"\"\"\n        return \"{}('{}', '{}')\".format(self.__class__.__name__, self.original, self.separator)\n\n    def __len__(self) -> int:\n        \"\"\"Indicate how many segments comprise this YAML Path.\"\"\"\n        return len(self.escaped)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Indicate equivalence of two YAMLPaths.\n\n        The path separator is ignored for this comparison.  This is deliberate\n        and allows \"some.path[1]\" == \"/some/path[1]\" because both forms of the\n        same path yield exactly the same data.\n\n        Parameters:\n        1. other (object) The other YAMLPath to compare against.\n\n        Returns:  (bool) true = Both are identical; false, otherwise\n        \"\"\"\n        if not isinstance(other, (YAMLPath, str)):\n            return False\n        equiv_this = YAMLPath(self)\n        equiv_this.separator = PathSeparators.FSLASH\n        cmp_this = str(equiv_this)\n        equiv_that = YAMLPath(other)\n        equiv_that.separator = PathSeparators.FSLASH\n        cmp_that = str(equiv_that)\n        return cmp_this == cmp_that\n\n    def __ne__(self, other: object) -> bool:\n        \"\"\"Indicate non-equivalence of two YAMLPaths.\"\"\"\n        return not self == other\n\n    def __add__(self, other: object) -> 'YAMLPath':\n        \"\"\"Add a nonmutating -- pre-escaped -- path segment.\"\"\"\n        next_segment = str(other) if not isinstance(other, str) else other\n        return YAMLPath(self).append(next_segment)\n\n    def append(self, segment: str) -> 'YAMLPath':\n        \"\"\"\n        Append a new -- pre-escaped -- segment to this YAML Path.\n\n        Parameters:\n        1. segment (str) The new -- pre-escaped -- segment to append to this\n           YAML Path.  Do NOT include any separator with this value; it will be\n           added for you.\n\n        Returns:  (YAMLPath) The adjusted YAMLPath\n        \"\"\"\n        separator = PathSeparators.FSLASH if self.separator is PathSeparators.AUTO else self.separator\n        if len(self._original) < 1:\n            self.original = segment\n        else:\n            self.original += '{}{}'.format(separator, segment)\n        return self\n\n    def pop(self) -> PathSegment:\n        \"\"\"\n        Pop the last segment off this YAML Path.\n\n        This mutates the YAML Path and returns the removed segment PathSegment.\n\n        Returns:  (PathSegment) The removed segment\n        \"\"\"\n        segments: Deque[PathSegment] = self.unescaped\n        if len(segments) < 1:\n            raise YAMLPathException('Cannot pop when there are no segments to pop from', str(self))\n        popped_queue: Deque = deque()\n        popped_segment: PathSegment = segments.pop()\n        popped_queue.append(popped_segment)\n        removable_segment = YAMLPath._stringify_yamlpath_segments(popped_queue, self.separator)\n        prefixed_segment = '{}{}'.format(self.separator, removable_segment)\n        path_now = self.original\n        if path_now.endswith(prefixed_segment):\n            self.original = path_now[0:len(path_now) - len(prefixed_segment)]\n        elif path_now.endswith(removable_segment):\n            self.original = path_now[0:len(path_now) - len(removable_segment)]\n        elif self.separator == PathSeparators.FSLASH and path_now.endswith(removable_segment[1:]):\n            self.original = path_now[0:len(path_now) - len(removable_segment) + 1]\n        return popped_segment\n\n    @property\n    def is_root(self) -> bool:\n        \"\"\"Indicate whether this YAML Path points at the document root.\"\"\"\n        return len(self.escaped) == 0\n\n    @property\n    def original(self) -> str:\n        \"\"\"\n        Original YAML Path accessor.\n\n        Positional Parameters:  N/A\n\n        Returns:  (str) The original, unparsed, unmodified YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        return self._original\n\n    @original.setter\n    def original(self, value: str) -> None:\n        \"\"\"\n        Original YAML Path mutator.\n\n        Parameters:\n        1. value (str) A YAML Path in string form\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        str_val = str(value)\n        if not str_val.strip():\n            str_val = ''\n        self._original = str_val\n        self._separator = PathSeparators.AUTO\n        self._unescaped = deque()\n        self._escaped = deque()\n        self._stringified = ''\n\n    @property\n    def separator(self) -> PathSeparators:\n        \"\"\"\n        Get the separator used to demarcate YAML Path segments.\n\n        Parameters:  N/A\n\n        Returns:  (PathSeparators) The segment demarcation symbol\n\n        Raises:  N/A\n        \"\"\"\n        if self._separator is PathSeparators.AUTO:\n            self._separator = PathSeparators.infer_separator(self._original)\n        return self._separator\n\n    @separator.setter\n    def separator(self, value: PathSeparators) -> None:\n        \"\"\"\n        Set the separator used to demarcate YAML Path segments.\n\n        This only affects __str__ and only when the new value differs from the\n        separator already inferred from the original YAML Path.\n\n        Parameters:\n        1. value (PathSeparators) The segment demarcation symbol\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        old_value: PathSeparators = self._separator\n        if not value == old_value:\n            self._stringified = YAMLPath._stringify_yamlpath_segments(self.unescaped, value)\n            self._separator = value\n\n    @property\n    def seperator(self) -> PathSeparators:\n        \"\"\"\n        Get the separator used to demarcate YAML Path segments.\n\n        This is provided for compatibility with older versions,\n        before the spelling was updated to \"separator.\"\n\n        Parameters:  N/A\n\n        Returns:  (PathSeparators) The segment demarcation symbol\n\n        Raises:  N/A\n        \"\"\"\n        return self.separator\n\n    @seperator.setter\n    def seperator(self, value: PathSeparators) -> None:\n        \"\"\"\n        Set the separator used to demarcate YAML Path segments.\n\n        This only affects __str__ and only when the new value differs from the\n        separator already inferred from the original YAML Path.\n\n        This is provided for compatibility with older versions,\n        before the spelling was updated to \"separator.\"\n\n        Parameters:\n        1. value (PathSeparators) The segment demarcation symbol\n\n        Returns:  N/A\n\n        Raises:  N/A\n        \"\"\"\n        self.separator = value\n\n    @property\n    def escaped(self) -> Deque[PathSegment]:\n        \"\"\"\n        Get the escaped, parsed version of this YAML Path.\n\n        Any leading \\\\ symbols are stripped out.  This is the parsed YAML Path\n        used for processing YAML data.\n\n        Parameters:  N/A\n\n        Returns:  (deque) The escaped, parsed version of this YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        if not self._escaped:\n            self._escaped = self._parse_path(True)\n        return self._escaped.copy()\n\n    @property\n    def unescaped(self) -> Deque[PathSegment]:\n        \"\"\"\n        Get the unescaped, parsed version of this YAML Path.\n\n        Any leading \\\\ symbols are preserved.  This is the print and log\n        friendly version of the parsed YAML Path.\n\n        Parameters:  N/A\n\n        Returns:  (deque) The unescaped, parsed version of this YAML Path\n\n        Raises:  N/A\n        \"\"\"\n        if not self._unescaped:\n            self._unescaped = self._parse_path(False)\n        return self._unescaped.copy()\n\n    def _parse_path(self, strip_escapes: bool=True) -> Deque[PathSegment]:\n        \"\"\"\n        Parse the YAML Path into its component PathSegment tuples.\n\n        Breaks apart a stringified YAML Path into component segments, each\n        identified by its type.  See README.md for sample YAML Paths.\n\n        Parameters:\n        1. strip_escapes (bool) True = Remove leading \\\\ symbols, leaving\n           only the \"escaped\" symbol.  False = Leave all leading \\\\ symbols\n           intact.\n\n        Returns:  (Deque[PathSegment]) an empty queue or a queue of\n            PathSegments.\n\n        Raises:\n            - `YAMLPathException` when the YAML Path is invalid\n        \"\"\"\n        yaml_path: str = self.original\n        path_segments: deque = deque()\n        segment_id: str = ''\n        segment_type: Optional[PathSegmentTypes] = None\n        demarc_stack: List[str] = []\n        escape_next: bool = False\n        search_inverted: bool = False\n        search_method: Optional[PathSearchMethods] = None\n        search_attr: str = ''\n        search_keyword: Optional[PathSearchKeywords] = None\n        seeking_regex_delim: bool = False\n        capturing_regex: bool = False\n        pathsep: str = str(self.separator)\n        collector_level: int = 0\n        collector_operator: CollectorOperators = CollectorOperators.NONE\n        seeking_collector_operator: bool = False\n        next_char_must_be: Optional[str] = None\n        if not yaml_path:\n            return path_segments\n        first_anchor_pos = 0\n        if self.separator is PathSeparators.FSLASH and len(yaml_path) > 1:\n            first_anchor_pos = 1\n        seeking_anchor_mark = yaml_path[first_anchor_pos] == '&'\n        for char_idx, char in enumerate(yaml_path):\n            demarc_count = len(demarc_stack)\n            if next_char_must_be and char == next_char_must_be:\n                next_char_must_be = None\n            if escape_next:\n                escape_next = False\n            elif capturing_regex:\n                if char == demarc_stack[-1]:\n                    capturing_regex = False\n                    demarc_stack.pop()\n                    continue\n            elif char == '\\\\':\n                escape_next = True\n                if strip_escapes:\n                    continue\n            elif char == ' ' and (demarc_count < 1 or demarc_stack[-1] not in [\"'\", '\"']):\n                continue\n            elif seeking_regex_delim:\n                seeking_regex_delim = False\n                capturing_regex = True\n                demarc_stack.append(char)\n                demarc_count += 1\n                continue\n            elif seeking_anchor_mark and char == '&':\n                seeking_anchor_mark = False\n                segment_type = PathSegmentTypes.ANCHOR\n                continue\n            elif seeking_collector_operator and char in ['+', '-', '&']:\n                seeking_collector_operator = False\n                next_char_must_be = '('\n                if char == '+':\n                    collector_operator = CollectorOperators.ADDITION\n                elif char == '-':\n                    collector_operator = CollectorOperators.SUBTRACTION\n                elif char == '&':\n                    collector_operator = CollectorOperators.INTERSECTION\n                continue\n            elif next_char_must_be and char != next_char_must_be:\n                raise YAMLPathException('Invalid YAML Path at character index {}, \"{}\", which must be \"{}\" in YAML Path'.format(char_idx, char, next_char_must_be), yaml_path)\n            elif char in ['\"', \"'\"]:\n                if demarc_count > 0:\n                    if char == demarc_stack[-1]:\n                        demarc_stack.pop()\n                        demarc_count -= 1\n                        if demarc_count < 1:\n                            if segment_id:\n                                if segment_type is None:\n                                    segment_type = PathSegmentTypes.KEY\n                                path_segments.append((segment_type, segment_id))\n                            segment_id = ''\n                            segment_type = None\n                            continue\n                    else:\n                        demarc_stack.append(char)\n                        demarc_count += 1\n                else:\n                    demarc_stack.append(char)\n                    demarc_count += 1\n                    continue\n            elif char == '(':\n                if demarc_count == 1 and demarc_stack[-1] == '[' and segment_id:\n                    if PathSearchKeywords.is_keyword(segment_id):\n                        demarc_stack.append(char)\n                        demarc_count += 1\n                        segment_type = PathSegmentTypes.KEYWORD_SEARCH\n                        search_keyword = PathSearchKeywords[segment_id.upper()]\n                        segment_id = ''\n                        continue\n                    raise YAMLPathException('Unknown Search Keyword at character index {}, \"{}\"; allowed: {}.  Encountered in YAML Path'.format(char_idx - len(segment_id), segment_id, ', '.join(PathSearchKeywords.get_keywords())), yaml_path)\n                if collector_level == 0 and segment_id:\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(yaml_path, segment_id, segment_type))\n                    segment_id = ''\n                seeking_collector_operator = False\n                collector_level += 1\n                demarc_stack.append(char)\n                demarc_count += 1\n                segment_type = PathSegmentTypes.COLLECTOR\n                if collector_level == 1:\n                    continue\n            elif demarc_count > 0 and char == ')' and (segment_type is PathSegmentTypes.KEYWORD_SEARCH):\n                demarc_count -= 1\n                demarc_stack.pop()\n                next_char_must_be = ']'\n                seeking_collector_operator = False\n                continue\n            elif demarc_count > 0 and char == ')' and (demarc_stack[-1] == '(') and (collector_level > 0):\n                collector_level -= 1\n                demarc_count -= 1\n                demarc_stack.pop()\n                if collector_level < 1:\n                    path_segments.append((segment_type, CollectorTerms(segment_id, collector_operator)))\n                    segment_id = ''\n                    collector_operator = CollectorOperators.NONE\n                    seeking_collector_operator = True\n                    continue\n            elif demarc_count == 0 and char == '[':\n                if segment_id:\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(yaml_path, segment_id, segment_type))\n                    segment_id = ''\n                demarc_stack.append(char)\n                demarc_count += 1\n                segment_type = PathSegmentTypes.INDEX\n                seeking_collector_operator = False\n                seeking_anchor_mark = True\n                search_inverted = False\n                search_method = None\n                search_attr = ''\n                continue\n            elif demarc_count == 1 and demarc_stack[-1] == '[' and (char in ['=', '^', '$', '%', '!', '>', '<', '~']):\n                if char == '!':\n                    if search_inverted:\n                        raise YAMLPathException('Double search inversion is meaningless at character index {}, {}'.format(char_idx, char), yaml_path)\n                    search_inverted = True\n                    continue\n                elif char == '=':\n                    segment_type = PathSegmentTypes.SEARCH\n                    if search_method is PathSearchMethods.LESS_THAN:\n                        search_method = PathSearchMethods.LESS_THAN_OR_EQUAL\n                    elif search_method is PathSearchMethods.GREATER_THAN:\n                        search_method = PathSearchMethods.GREATER_THAN_OR_EQUAL\n                    elif search_method is PathSearchMethods.EQUALS:\n                        continue\n                    elif search_method is None:\n                        search_method = PathSearchMethods.EQUALS\n                        if segment_id:\n                            search_attr = segment_id\n                            segment_id = ''\n                        else:\n                            raise YAMLPathException('Missing search operand before operator at character index {}, \"{}\"'.format(char_idx, char), yaml_path)\n                    else:\n                        raise YAMLPathException('Unsupported search operator combination at character index {}, \"{}\"'.format(char_idx, char), yaml_path)\n                    continue\n                elif char == '~':\n                    if search_method == PathSearchMethods.EQUALS:\n                        search_method = PathSearchMethods.REGEX\n                        seeking_regex_delim = True\n                    else:\n                        raise YAMLPathException('Unexpected use of \"{}\" operator at character index {}.  Please try =~ if you mean to search with a Regular Expression.'.format(char, char_idx), yaml_path)\n                    continue\n                elif not segment_id:\n                    raise YAMLPathException('Missing search operand before operator, \"{}\" at character index, {}'.format(char, char_idx), yaml_path)\n                elif char == '^':\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.STARTS_WITH\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = ''\n                    continue\n                elif char == '$':\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.ENDS_WITH\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = ''\n                    continue\n                elif char == '%':\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.CONTAINS\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = ''\n                    continue\n                elif char == '>':\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.GREATER_THAN\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = ''\n                    continue\n                elif char == '<':\n                    segment_type = PathSegmentTypes.SEARCH\n                    search_method = PathSearchMethods.LESS_THAN\n                    if segment_id:\n                        search_attr = segment_id\n                        segment_id = ''\n                    continue\n            elif char == '[':\n                demarc_stack.append(char)\n                demarc_count += 1\n            elif demarc_count == 1 and char == ']' and (demarc_stack[-1] == '['):\n                if segment_type is PathSegmentTypes.INDEX and ':' not in segment_id:\n                    try:\n                        idx = int(segment_id)\n                    except ValueError as wrap_ex:\n                        raise TypeMismatchYAMLPathException('Not an integer index at character index {}:  {}'.format(char_idx, segment_id), yaml_path, segment_id) from wrap_ex\n                    path_segments.append((segment_type, idx))\n                elif segment_type is PathSegmentTypes.SEARCH and search_method is not None:\n                    if segment_id and segment_id[0] in [\"'\", '\"']:\n                        leading_mark = segment_id[0]\n                        if segment_id[-1] == leading_mark:\n                            segment_id = segment_id[1:-1]\n                    path_segments.append((segment_type, SearchTerms(search_inverted, search_method, search_attr, segment_id)))\n                elif segment_type is PathSegmentTypes.KEYWORD_SEARCH and search_keyword:\n                    path_segments.append((segment_type, SearchKeywordTerms(search_inverted, search_keyword, segment_id)))\n                else:\n                    path_segments.append((segment_type, segment_id))\n                segment_id = ''\n                segment_type = None\n                demarc_stack.pop()\n                demarc_count -= 1\n                search_method = None\n                search_inverted = False\n                search_keyword = None\n                continue\n            elif char == ']':\n                demarc_stack.pop()\n                demarc_count -= 1\n            elif demarc_count < 1 and char == pathsep:\n                if segment_id:\n                    if segment_type is None:\n                        segment_type = PathSegmentTypes.KEY\n                    path_segments.append(self._expand_splats(yaml_path, segment_id, segment_type))\n                    segment_id = ''\n                segment_type = None\n                seeking_anchor_mark = True\n                continue\n            segment_id += char\n            seeking_anchor_mark = False\n            seeking_collector_operator = False\n        if collector_level > 0:\n            raise YAMLPathException('YAML Path contains an unmatched () collector pair', yaml_path)\n        if capturing_regex:\n            raise YAMLPathException('YAML Path contains an unterminated Regular Expression', yaml_path)\n        if demarc_count > 0:\n            raise YAMLPathException('YAML Path contains at least one unmatched demarcation mark with remaining open marks, {} in'.format(', '.join(demarc_stack)), yaml_path)\n        if segment_id:\n            if segment_type is None:\n                segment_type = PathSegmentTypes.KEY\n            path_segments.append(self._expand_splats(yaml_path, segment_id, segment_type))\n        return path_segments\n\n    @staticmethod\n    def _expand_splats(yaml_path: str, segment_id: PathAttributes, segment_type: PathSegmentTypes) -> PathSegment:\n        \"\"\"\n        Replace segment IDs with search operators when * is present.\n\n        Parameters:\n        1. yaml_path (str) The full YAML Path being processed.\n        2. segment_id (str) The segment identifier to parse.\n        3. segment_type (Optional[PathSegmentTypes]) Pending predetermined type\n           of the segment under evaluation.\n\n        Returns:  (PathSegment) Coallesced YAML Path segment.\n        \"\"\"\n        coal_type: PathSegmentTypes = segment_type\n        coal_value: PathAttributes = segment_id\n        if isinstance(segment_id, str) and '*' in segment_id:\n            splat_count = segment_id.count('*')\n            splat_pos = segment_id.index('*')\n            segment_len = len(segment_id)\n            if splat_count == 1:\n                if segment_len == 1:\n                    coal_type = PathSegmentTypes.MATCH_ALL\n                    coal_value = None\n                elif splat_pos == 0:\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(False, PathSearchMethods.ENDS_WITH, '.', segment_id[1:])\n                elif splat_pos == segment_len - 1:\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(False, PathSearchMethods.STARTS_WITH, '.', segment_id[0:splat_pos])\n                else:\n                    coal_type = PathSegmentTypes.SEARCH\n                    coal_value = SearchTerms(False, PathSearchMethods.REGEX, '.', '^{}.*{}$'.format(segment_id[0:splat_pos], segment_id[splat_pos + 1:]))\n            elif splat_count == 2 and segment_len == 2:\n                coal_type = PathSegmentTypes.TRAVERSE\n                coal_value = None\n            elif splat_count > 1:\n                search_term = '^'\n                was_splat = False\n                for char in segment_id:\n                    if char == '*':\n                        if was_splat:\n                            raise YAMLPathException('The ** traversal operator has no meaning when combined with other characters', yaml_path, segment_id)\n                        was_splat = True\n                        search_term += '.*'\n                    else:\n                        was_splat = False\n                        search_term += char\n                search_term += '$'\n                coal_type = PathSegmentTypes.SEARCH\n                coal_value = SearchTerms(False, PathSearchMethods.REGEX, '.', search_term)\n        return (coal_type, coal_value)\n\n    @staticmethod\n    def _stringify_yamlpath_segments(segments: Deque[PathSegment], separator: PathSeparators) -> str:\n        \"\"\"Stringify segments of a YAMLPath.\"\"\"\n        pathsep: str = str(separator)\n        add_sep: bool = False\n        ppath: str = ''\n        if separator is PathSeparators.FSLASH:\n            ppath = pathsep\n        for segment_type, segment_attrs in segments:\n            if segment_type == PathSegmentTypes.KEY:\n                if add_sep:\n                    ppath += pathsep\n                ppath += YAMLPath.ensure_escaped(str(segment_attrs), pathsep, '(', ')', '[', ']', '^', '$', '%', ' ', \"'\", '\"')\n            elif segment_type == PathSegmentTypes.INDEX:\n                ppath += '[{}]'.format(segment_attrs)\n            elif segment_type == PathSegmentTypes.MATCH_ALL:\n                if add_sep:\n                    ppath += pathsep\n                ppath += '*'\n            elif segment_type == PathSegmentTypes.ANCHOR:\n                if add_sep:\n                    ppath += '[&{}]'.format(segment_attrs)\n                else:\n                    ppath += '&{}'.format(segment_attrs)\n            elif segment_type == PathSegmentTypes.KEYWORD_SEARCH:\n                ppath += str(segment_attrs)\n            elif segment_type == PathSegmentTypes.SEARCH and isinstance(segment_attrs, SearchTerms):\n                ppath += str(segment_attrs)\n            elif segment_type == PathSegmentTypes.COLLECTOR:\n                ppath += str(segment_attrs)\n            elif segment_type == PathSegmentTypes.TRAVERSE:\n                if add_sep:\n                    ppath += pathsep\n                ppath += '**'\n            add_sep = True\n        return ppath\n\n    @staticmethod\n    def strip_path_prefix(path: 'YAMLPath', prefix: 'YAMLPath') -> 'YAMLPath':\n        \"\"\"\n        Remove a prefix from a YAML Path.\n\n        Parameters:\n        1. path (YAMLPath) The path from which to remove the prefix.\n        2. prefix (YAMLPath) The prefix to remove (except \"/\").\n\n        Returns:  (YAMLPath) The trimmed YAML Path.\n        \"\"\"\n        if prefix is None:\n            return path\n        prefix.separator = PathSeparators.FSLASH\n        if str(prefix) == '/':\n            return path\n        path.separator = PathSeparators.FSLASH\n        prefix_str = str(prefix)\n        path_str = str(path)\n        if path_str.startswith(prefix_str):\n            path_str = path_str[len(prefix_str):]\n            return YAMLPath(path_str)\n        return path\n\n    @staticmethod\n    def ensure_escaped(value: str, *symbols: str) -> str:\n        \"\"\"\n        Escape all instances of a symbol within a value.\n\n        Ensures all instances of a symbol are escaped (via \\\\) within a value.\n        Multiple symbols can be processed at once.\n\n        Parameters:\n        1. value (str) The String in which to escape special characters\n        2. *symbols (str) List of special characters to escape\n\n        Returns:  (str) `value` with all `symbols` escaped\n        \"\"\"\n        escaped: str = value\n        for symbol in symbols:\n            replace_term: str = '\\\\{}'.format(symbol)\n            oparts: List[str] = str(escaped).split(replace_term)\n            eparts: List[str] = []\n            for opart in oparts:\n                eparts.append(opart.replace(symbol, replace_term))\n            escaped = replace_term.join(eparts)\n        return escaped\n\n    @staticmethod\n    def escape_path_section(section: str, pathsep: PathSeparators) -> str:\n        \"\"\"\n        Escape all special symbols present within a YAML Path segment.\n\n        Renders inert via escaping all symbols within a string which have\n        special meaning to YAML Path.  The resulting string can be consumed as\n        a YAML Path section without triggering unwanted additional processing.\n\n        Parameters:\n        1. section (str) The portion of a YAML Path segment to escape\n        2. pathsep (PathSeparators) The YAML Path segment separator symbol to\n           also escape, when present\n\n        Returns:  (str) `section` with all special symbols escaped\n        \"\"\"\n        return YAMLPath.ensure_escaped(section, '\\\\', str(pathsep), '(', ')', '[', ']', '^', '$', '%', ' ', \"'\", '\"')",
    "yamlpath/patches/timestamp.py": "\"\"\"\nFix missing anchors from timestamp and date nodes.\n\nThis must be removed once incorporated into ruamel.yaml, likely at version\n0.17.22.\n\nSource: https://sourceforge.net/p/ruamel-yaml/tickets/440/\nCopyright 2022 Anthon van der Neut, William W. Kimball Jr. MBA MSIS\n\"\"\"\nimport ruamel.yaml\nfrom ruamel.yaml.constructor import ConstructorError\nfrom ruamel.yaml.anchor import Anchor\nfrom ruamel.yaml.timestamp import TimeStamp\nfrom typing import Any, Dict, Union\nimport datetime\nimport copy\n\nclass AnchoredTimeStamp(TimeStamp):\n    \"\"\"Extend TimeStamp to track YAML Anchors.\"\"\"\n\n    def __deepcopy__(self, memo: Any) -> Any:\n        \"\"\"Deeply copy this instance to another.\"\"\"\n        ts = AnchoredTimeStamp(self.year, self.month, self.day, self.hour, self.minute, self.second)\n        ts._yaml = copy.deepcopy(self._yaml)\n        return ts\n\n    @property\n    def anchor(self) -> Any:\n        \"\"\"Access the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            setattr(self, Anchor.attrib, Anchor())\n        return getattr(self, Anchor.attrib)\n\n    def yaml_anchor(self, any: bool=False) -> Any:\n        \"\"\"Get the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            return None\n        if any or self.anchor.always_dump:\n            return self.anchor\n        return None\n\n    def yaml_set_anchor(self, value: Any, always_dump: bool=False) -> None:\n        \"\"\"Set the YAML Anchor.\"\"\"\n        self.anchor.value = value\n        self.anchor.always_dump = always_dump\n\nclass AnchoredDate(AnchoredTimeStamp):\n    \"\"\"Define AnchoredDate.\"\"\"\n    pass\n\ndef construct_anchored_timestamp(self, node: Any, values: Any=None) -> Union[AnchoredTimeStamp, AnchoredDate]:\n    \"\"\"Construct an AnchoredTimeStamp.\"\"\"\n    try:\n        match = self.timestamp_regexp.match(node.value)\n    except TypeError:\n        match = None\n    if match is None:\n        raise ConstructorError(None, None, f'failed to construct timestamp from \"{node.value}\"', node.start_mark)\n    values = match.groupdict()\n    dd = ruamel.yaml.util.create_timestamp(**values)\n    delta = None\n    if values['tz_sign']:\n        tz_hour = int(values['tz_hour'])\n        minutes = values['tz_minute']\n        tz_minute = int(minutes) if minutes else 0\n        delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)\n        if values['tz_sign'] == '-':\n            delta = -delta\n    if isinstance(dd, datetime.datetime):\n        data = AnchoredTimeStamp(dd.year, dd.month, dd.day, dd.hour, dd.minute, dd.second, dd.microsecond, anchor=node.anchor)\n    else:\n        data = AnchoredDate(dd.year, dd.month, dd.day, 0, 0, 0, 0, anchor=node.anchor)\n        return data\n    if delta:\n        data._yaml['delta'] = delta\n        tz = values['tz_sign'] + values['tz_hour']\n        if values['tz_minute']:\n            tz += ':' + values['tz_minute']\n        data._yaml['tz'] = tz\n    elif values['tz']:\n        data._yaml['tz'] = values['tz']\n    if values['t']:\n        data._yaml['t'] = True\n    return data\nruamel.yaml.constructor.RoundTripConstructor.add_constructor('tag:yaml.org,2002:timestamp', construct_anchored_timestamp)\n\ndef represent_anchored_timestamp(self, data: Any):\n    \"\"\"Render an AnchoredTimeStamp.\"\"\"\n    try:\n        anchor = data.yaml_anchor()\n    except AttributeError:\n        anchor = None\n    inter = 'T' if data._yaml['t'] else ' '\n    _yaml = data._yaml\n    if _yaml['delta']:\n        data += _yaml['delta']\n    if isinstance(data, AnchoredDate):\n        value = data.date().isoformat()\n    else:\n        value = data.isoformat(inter)\n    if _yaml['tz']:\n        value += _yaml['tz']\n    return self.represent_scalar('tag:yaml.org,2002:timestamp', value, anchor=anchor)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredTimeStamp, represent_anchored_timestamp)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredDate, represent_anchored_timestamp)"
  }
}