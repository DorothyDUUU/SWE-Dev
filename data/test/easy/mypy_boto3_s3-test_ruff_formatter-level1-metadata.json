{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_ruff_formatter",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/writers/test_ruff_formatter.py",
  "test_code": "import tempfile\nfrom pathlib import Path\n\nfrom mypy_boto3_builder.writers.ruff_formatter import RuffFormatter\n\n\nclass TestRuffFormatter:\n    def test_format(self) -> None:\n        formatter = RuffFormatter(\n            known_first_party=[\"local\"],\n            known_third_party=[\"extra\", \"local\"],\n        )\n        with tempfile.NamedTemporaryFile(\"+w\", encoding=\"utf-8\") as f:\n            f.write(\"import os\\n\")\n            f.write(\"import datetime\\n\")\n            f.write(\"import black\\n\")\n            f.write(\"import local\\n\")\n            f.write(\"import extra.new\\n\")\n            f.write(\"a   =datetime.datetime.now()\\n\")\n            f.flush()\n            formatter.format_python([Path(f.name)])\n            assert Path(f.name).read_text(encoding=\"utf-8\") == (\n                \"import datetime\\n\"\n                \"import os\\n\"\n                \"\\n\"\n                \"import black\\n\"\n                \"import extra.new\\n\"\n                \"\\n\"\n                \"import local\\n\"\n                \"\\n\"\n                \"a = datetime.datetime.now()\\n\"\n            )\n\n    def test_format_markdown(self) -> None:\n        formatter = RuffFormatter()\n        assert not formatter.format_markdown(\"\")\n        assert (\n            formatter.format_markdown(\"# a\\ntest\\n## b\\n## c\\ntest2\")\n            == \"# a\\ntest\\n## b\\n## c\\ntest2\"\n        )\n        assert formatter.format_markdown(\"# a\\n```python\\na=5\\n```\") == \"# a\\n```python\\na = 5\\n```\"\n        assert formatter.format_markdown(\"# a\\n```bash\\na=5\\n```\") == \"# a\\n```bash\\na=5\\n```\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/writers/ruff_formatter.py": "\"\"\"\nRuff formatter.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport json\nimport subprocess\nimport sys\nimport tempfile\nfrom collections.abc import Iterable, Sequence\nfrom pathlib import Path\n\nfrom mypy_boto3_builder.constants import LINE_LENGTH, SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.path import print_path\n\n\nclass RuffError(RuntimeError):\n    \"\"\"\n    Ruff error.\n    \"\"\"\n\n\nclass RuffFormatter:\n    \"\"\"\n    Ruff formatter.\n    \"\"\"\n\n    def __init__(\n        self,\n        known_first_party: Sequence[str] = (),\n        known_third_party: Sequence[str] = (),\n    ) -> None:\n        self.logger = get_logger()\n        self._target_version = self._get_target_version()\n        self._known_first_party = list(known_first_party)\n        self._known_third_party = [i for i in known_third_party if i not in self._known_first_party]\n\n    @staticmethod\n    def _get_target_version() -> str:\n        min_version = min(v for v in SUPPORTED_PY_VERSIONS if len(v) > 1)\n        return f\"py{min_version[0]}{min_version[1]}\"\n\n    def format_python(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python files with `ruff`.\n\n        Arguments:\n            path -- Target path.\n        \"\"\"\n        self.sort_imports(paths)\n        self.format_code(paths)\n\n    def _get_config_cli(self) -> list[str]:\n        overrides = [\n            f'target-version = \"{self._target_version}\"',\n            f\"line-length = {LINE_LENGTH}\",\n            'format.quote-style = \"double\"',\n            'format.line-ending = \"lf\"',\n            f\"lint.isort.known-first-party = {json.dumps(self._known_first_party)}\",\n            f\"lint.isort.known-third-party = {json.dumps(self._known_third_party)}\",\n        ]\n        result: list[str] = []\n        for option in overrides:\n            result.extend([\"--config\", option])\n\n        return result\n\n    def sort_imports(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Sort import lines with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output(\n                [\n                    sys.executable,\n                    \"-m\",\n                    \"ruff\",\n                    \"check\",\n                    \"--target-version\",\n                    self._target_version,\n                    *self._get_config_cli(),\n                    \"--select\",\n                    \"I\",\n                    \"--fix\",\n                    \"--isolated\",\n                    *(path.as_posix() for path in paths),\n                ],\n                stderr=subprocess.STDOUT,\n            )\n        except subprocess.CalledProcessError as e:\n            self.logger.warning(\n                f\"Sorting imports failed for paths {[print_path(path) for path in paths]}\",\n            )\n            self.logger.warning(e.output.decode())\n            raise RuffError(f\"Sorting imports failed with status {e.returncode}\") from None\n\n    def format_code(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python code with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output(\n                [\n                    sys.executable,\n                    \"-m\",\n                    \"ruff\",\n                    \"format\",\n                    \"--target-version\",\n                    self._target_version,\n                    *self._get_config_cli(),\n                    \"--isolated\",\n                    *(path.as_posix() for path in paths),\n                ],\n                stderr=subprocess.STDOUT,\n            )\n        except subprocess.CalledProcessError as e:\n            raise RuffError(f\"Formatting failed: {e.output}, paths: {paths}\") from None\n\n    def format_strings(self, codes: Iterable[str]) -> list[str]:\n        \"\"\"\n        Format python code as strings.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as dir_name:\n            paths: list[Path] = []\n            for index, code in enumerate(codes):\n                file_path = Path(dir_name) / f\"temp_{index}.py\"\n                file_path.write_text(code)\n                paths.append(file_path)\n\n            self.format_code(paths)\n            return [path.read_text().rstrip(\"\\n\") for path in paths]\n\n    def format_markdown(self, text: str) -> str:\n        \"\"\"\n        Format python codeblocks in markdown.\n        \"\"\"\n        blocks = text.split(\"\\n```\")\n        format_blocks: list[str] = []\n        format_block_indices: list[int] = []\n        for index, block in enumerate(blocks):\n            if block.startswith(\"python\"):\n                format_blocks.append(block)\n                format_block_indices.append(index)\n\n        if format_blocks:\n            for index, formatted_block in enumerate(self.format_strings(format_blocks)):\n                block_index = format_block_indices[index]\n                blocks[block_index] = formatted_block\n        return \"\\n```\".join(blocks)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/writers/ruff_formatter.py": {
      "RuffFormatter.__init__": {
        "code": "    def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:\n        \"\"\"Initialize a RuffFormatter instance for formatting Python code.\n\nParameters:\n    known_first_party (Sequence[str], optional): A sequence of strings representing known first-party packages. Defaults to an empty tuple.\n    known_third_party (Sequence[str], optional): A sequence of strings representing known third-party packages. Defaults to an empty tuple.\n\nAttributes:\n    logger (Logger): A logger instance for logging messages, obtained from the `get_logger` function.\n    _target_version (str): The target Python version, determined by the `_get_target_version` method, which uses the `SUPPORTED_PY_VERSIONS` constant.\n    _known_first_party (list[str]): A list containing the known first-party packages.\n    _known_third_party (list[str]): A list containing known third-party packages that are not in the known first-party list.\n\nThis constructor sets up the RuffFormatter with the provided package information and prepares it for subsequent formatting operations.\"\"\"\n        self.logger = get_logger()\n        self._target_version = self._get_target_version()\n        self._known_first_party = list(known_first_party)\n        self._known_third_party = [i for i in known_third_party if i not in self._known_first_party]",
        "docstring": "Initialize a RuffFormatter instance for formatting Python code.\n\nParameters:\n    known_first_party (Sequence[str], optional): A sequence of strings representing known first-party packages. Defaults to an empty tuple.\n    known_third_party (Sequence[str], optional): A sequence of strings representing known third-party packages. Defaults to an empty tuple.\n\nAttributes:\n    logger (Logger): A logger instance for logging messages, obtained from the `get_logger` function.\n    _target_version (str): The target Python version, determined by the `_get_target_version` method, which uses the `SUPPORTED_PY_VERSIONS` constant.\n    _known_first_party (list[str]): A list containing the known first-party packages.\n    _known_third_party (list[str]): A list containing known third-party packages that are not in the known first-party list.\n\nThis constructor sets up the RuffFormatter with the provided package information and prepares it for subsequent formatting operations.",
        "signature": "def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_python": {
        "code": "    def format_python(self, paths: Sequence[Path]) -> None:\n        \"\"\"Format Python files using the `ruff` tool by first sorting imports and then applying code formatting.\n\nArgs:\n    paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    - The method modifies the files specified in `paths` by sorting their imports and formatting their code in place, dependent on the configuration settings provided via `self._get_config_cli()`, which utilizes the constants `LINE_LENGTH` and `SUPPORTED_PY_VERSIONS`.\"\"\"\n        '\\n        Format python files with `ruff`.\\n\\n        Arguments:\\n            path -- Target path.\\n        '\n        self.sort_imports(paths)\n        self.format_code(paths)",
        "docstring": "Format Python files using the `ruff` tool by first sorting imports and then applying code formatting.\n\nArgs:\n    paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    - The method modifies the files specified in `paths` by sorting their imports and formatting their code in place, dependent on the configuration settings provided via `self._get_config_cli()`, which utilizes the constants `LINE_LENGTH` and `SUPPORTED_PY_VERSIONS`.",
        "signature": "def format_python(self, paths: Sequence[Path]) -> None:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      },
      "RuffFormatter.format_markdown": {
        "code": "    def format_markdown(self, text: str) -> str:\n        \"\"\"Format markdown text by processing and formatting Python code blocks within it.\n\nArguments:\n    text (str): A string containing markdown with potentially unformatted Python code blocks.\n\nReturns:\n    str: The input markdown text with Python code blocks formatted using the `ruff` formatter.\n\nThis method identifies sections of the provided markdown text that contain Python code blocks, formats them using the `format_strings` method, and replaces the original blocks with the formatted versions. It relies on the presence of code blocks delineated by the markdown syntax for code. The `format_strings` method is critical for this process as it takes a list of code snippets, formats them, and returns the formatted code. This method uses the `tempfile` module to create temporary files for formatting purposes, ensuring that code is cleanly processed without modifying the original markdown directly.\"\"\"\n        '\\n        Format python codeblocks in markdown.\\n        '\n        blocks = text.split('\\n```')\n        format_blocks: list[str] = []\n        format_block_indices: list[int] = []\n        for index, block in enumerate(blocks):\n            if block.startswith('python'):\n                format_blocks.append(block)\n                format_block_indices.append(index)\n        if format_blocks:\n            for index, formatted_block in enumerate(self.format_strings(format_blocks)):\n                block_index = format_block_indices[index]\n                blocks[block_index] = formatted_block\n        return '\\n```'.join(blocks)",
        "docstring": "Format markdown text by processing and formatting Python code blocks within it.\n\nArguments:\n    text (str): A string containing markdown with potentially unformatted Python code blocks.\n\nReturns:\n    str: The input markdown text with Python code blocks formatted using the `ruff` formatter.\n\nThis method identifies sections of the provided markdown text that contain Python code blocks, formats them using the `format_strings` method, and replaces the original blocks with the formatted versions. It relies on the presence of code blocks delineated by the markdown syntax for code. The `format_strings` method is critical for this process as it takes a list of code snippets, formats them, and returns the formatted code. This method uses the `tempfile` module to create temporary files for formatting purposes, ensuring that code is cleanly processed without modifying the original markdown directly.",
        "signature": "def format_markdown(self, text: str) -> str:",
        "type": "Method",
        "class_signature": "class RuffFormatter:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__": {
      "mypy_boto3_builder/writers/ruff_formatter.py": {
        "RuffFormatter._get_target_version": {
          "code": "    def _get_target_version() -> str:\n        min_version = min((v for v in SUPPORTED_PY_VERSIONS if len(v) > 1))\n        return f'py{min_version[0]}{min_version[1]}'",
          "docstring": "",
          "signature": "def _get_target_version() -> str:",
          "type": "Method",
          "class_signature": "class RuffFormatter:"
        }
      },
      "mypy_boto3_builder/logger.py": {
        "get_logger": {
          "code": "def get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger",
          "docstring": "Get Logger instance.\n\nArguments:\n    level -- Log level.\n\nReturns:\n    Overriden Logger.",
          "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_python": {
      "mypy_boto3_builder/writers/ruff_formatter.py": {
        "RuffFormatter.sort_imports": {
          "code": "    def sort_imports(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Sort import lines with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'check', '--target-version', self._target_version, *self._get_config_cli(), '--select', 'I', '--fix', '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            self.logger.warning(f'Sorting imports failed for paths {[print_path(path) for path in paths]}')\n            self.logger.warning(e.output.decode())\n            raise RuffError(f'Sorting imports failed with status {e.returncode}') from None",
          "docstring": "Sort import lines with `ruff`.",
          "signature": "def sort_imports(self, paths: Sequence[Path]) -> None:",
          "type": "Method",
          "class_signature": "class RuffFormatter:"
        },
        "RuffFormatter.format_code": {
          "code": "    def format_code(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python code with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'format', '--target-version', self._target_version, *self._get_config_cli(), '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            raise RuffError(f'Formatting failed: {e.output}, paths: {paths}') from None",
          "docstring": "Format python code with `ruff`.",
          "signature": "def format_code(self, paths: Sequence[Path]) -> None:",
          "type": "Method",
          "class_signature": "class RuffFormatter:"
        }
      }
    },
    "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_markdown": {
      "mypy_boto3_builder/writers/ruff_formatter.py": {
        "RuffFormatter.format_strings": {
          "code": "    def format_strings(self, codes: Iterable[str]) -> list[str]:\n        \"\"\"\n        Format python code as strings.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as dir_name:\n            paths: list[Path] = []\n            for index, code in enumerate(codes):\n                file_path = Path(dir_name) / f'temp_{index}.py'\n                file_path.write_text(code)\n                paths.append(file_path)\n            self.format_code(paths)\n            return [path.read_text().rstrip('\\n') for path in paths]",
          "docstring": "Format python code as strings.",
          "signature": "def format_strings(self, codes: Iterable[str]) -> list[str]:",
          "type": "Method",
          "class_signature": "class RuffFormatter:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_ruff_formatter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 writers/\n        \u2514\u2500\u2500 ruff_formatter.py\n            \u251c\u2500\u2500 RuffFormatter.__init__\n            \u251c\u2500\u2500 RuffFormatter.format_markdown\n            \u2514\u2500\u2500 RuffFormatter.format_python\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for formatting and organizing Python code and related content such as Markdown documentation. Its primary purpose is to ensure consistent code style by applying a defined structure to imports, spacing, and syntax, while also handling code embedded within Markdown files. The module enables developers to maintain cleaner, more readable codebases by programmatically enforcing formatting conventions, simplifying code reviews, and improving overall project organization. This reduces manual effort for developers and mitigates errors stemming from inconsistent formatting.\n\n## FILE 1: mypy_boto3_builder/writers/ruff_formatter.py\n\n- CLASS METHOD: RuffFormatter.__init__\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def __init__(self, known_first_party: Sequence[str]=(), known_third_party: Sequence[str]=()) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a RuffFormatter instance for formatting Python code.\n\nParameters:\n    known_first_party (Sequence[str], optional): A sequence of strings representing known first-party packages. Defaults to an empty tuple.\n    known_third_party (Sequence[str], optional): A sequence of strings representing known third-party packages. Defaults to an empty tuple.\n\nAttributes:\n    logger (Logger): A logger instance for logging messages, obtained from the `get_logger` function.\n    _target_version (str): The target Python version, determined by the `_get_target_version` method, which uses the `SUPPORTED_PY_VERSIONS` constant.\n    _known_first_party (list[str]): A list containing the known first-party packages.\n    _known_third_party (list[str]): A list containing known third-party packages that are not in the known first-party list.\n\nThis constructor sets up the RuffFormatter with the provided package information and prepares it for subsequent formatting operations.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_markdown\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_markdown(self, text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat markdown text by processing and formatting Python code blocks within it.\n\nArguments:\n    text (str): A string containing markdown with potentially unformatted Python code blocks.\n\nReturns:\n    str: The input markdown text with Python code blocks formatted using the `ruff` formatter.\n\nThis method identifies sections of the provided markdown text that contain Python code blocks, formats them using the `format_strings` method, and replaces the original blocks with the formatted versions. It relies on the presence of code blocks delineated by the markdown syntax for code. The `format_strings` method is critical for this process as it takes a list of code snippets, formats them, and returns the formatted code. This method uses the `tempfile` module to create temporary files for formatting purposes, ensuring that code is cleanly processed without modifying the original markdown directly.\n\"\"\"\n```\n\n- CLASS METHOD: RuffFormatter.format_python\n  - CLASS SIGNATURE: class RuffFormatter:\n  - SIGNATURE: def format_python(self, paths: Sequence[Path]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat Python files using the `ruff` tool by first sorting imports and then applying code formatting.\n\nArgs:\n    paths (Sequence[Path]): A sequence of Path objects representing the Python files to be formatted.\n\nReturns:\n    None: This method does not return any value.\n\nSide Effects:\n    - The method modifies the files specified in `paths` by sorting their imports and formatting their code in place, dependent on the configuration settings provided via `self._get_config_cli()`, which utilizes the constants `LINE_LENGTH` and `SUPPORTED_PY_VERSIONS`.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/writers/ruff_formatter.py": "\"\"\"\nRuff formatter.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport json\nimport subprocess\nimport sys\nimport tempfile\nfrom collections.abc import Iterable, Sequence\nfrom pathlib import Path\nfrom mypy_boto3_builder.constants import LINE_LENGTH, SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.utils.path import print_path\n\nclass RuffError(RuntimeError):\n    \"\"\"\n    Ruff error.\n    \"\"\"\n\nclass RuffFormatter:\n    \"\"\"\n    Ruff formatter.\n    \"\"\"\n\n    @staticmethod\n    def _get_target_version() -> str:\n        min_version = min((v for v in SUPPORTED_PY_VERSIONS if len(v) > 1))\n        return f'py{min_version[0]}{min_version[1]}'\n\n    def _get_config_cli(self) -> list[str]:\n        overrides = [f'target-version = \"{self._target_version}\"', f'line-length = {LINE_LENGTH}', 'format.quote-style = \"double\"', 'format.line-ending = \"lf\"', f'lint.isort.known-first-party = {json.dumps(self._known_first_party)}', f'lint.isort.known-third-party = {json.dumps(self._known_third_party)}']\n        result: list[str] = []\n        for option in overrides:\n            result.extend(['--config', option])\n        return result\n\n    def sort_imports(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Sort import lines with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'check', '--target-version', self._target_version, *self._get_config_cli(), '--select', 'I', '--fix', '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            self.logger.warning(f'Sorting imports failed for paths {[print_path(path) for path in paths]}')\n            self.logger.warning(e.output.decode())\n            raise RuffError(f'Sorting imports failed with status {e.returncode}') from None\n\n    def format_code(self, paths: Sequence[Path]) -> None:\n        \"\"\"\n        Format python code with `ruff`.\n        \"\"\"\n        try:\n            subprocess.check_output([sys.executable, '-m', 'ruff', 'format', '--target-version', self._target_version, *self._get_config_cli(), '--isolated', *(path.as_posix() for path in paths)], stderr=subprocess.STDOUT)\n        except subprocess.CalledProcessError as e:\n            raise RuffError(f'Formatting failed: {e.output}, paths: {paths}') from None\n\n    def format_strings(self, codes: Iterable[str]) -> list[str]:\n        \"\"\"\n        Format python code as strings.\n        \"\"\"\n        with tempfile.TemporaryDirectory() as dir_name:\n            paths: list[Path] = []\n            for index, code in enumerate(codes):\n                file_path = Path(dir_name) / f'temp_{index}.py'\n                file_path.write_text(code)\n                paths.append(file_path)\n            self.format_code(paths)\n            return [path.read_text().rstrip('\\n') for path in paths]"
  },
  "call_tree": {
    "tests/writers/test_ruff_formatter.py:TestRuffFormatter:test_format": {
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_target_version": {}
      },
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_python": {
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:sort_imports": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
        },
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_code": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
        }
      }
    },
    "tests/writers/test_ruff_formatter.py:TestRuffFormatter:test_format_markdown": {
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:__init__": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_target_version": {}
      },
      "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_markdown": {
        "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_strings": {
          "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:format_code": {
            "mypy_boto3_builder/writers/ruff_formatter.py:RuffFormatter:_get_config_cli": {}
          }
        }
      }
    }
  }
}