{
  "dir_path": "/app/questionary",
  "package_name": "questionary",
  "sample_name": "questionary-test_prompt",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_prompt.py",
  "test_code": "import unittest\nfrom questionary.prompt import prompt, PromptParameterException\nfrom tests.utils import patched_prompt\n\nclass TestPrompt(unittest.TestCase):\n\n    def test_missing_message(self):\n        with self.assertRaises(PromptParameterException):\n            prompt([{\"type\": \"confirm\", \"name\": \"continue\", \"default\": True}])\n\n    def test_missing_type(self):\n        with self.assertRaises(PromptParameterException):\n            prompt(\n                [\n                    {\n                        \"message\": \"Do you want to continue?\",\n                        \"name\": \"continue\",\n                        \"default\": True,\n                    }\n                ]\n            )\n\n    def test_missing_name(self):\n        with self.assertRaises(PromptParameterException):\n            prompt(\n                [\n                    {\n                        \"type\": \"confirm\",\n                        \"message\": \"Do you want to continue?\",\n                        \"default\": True,\n                    }\n                ]\n            )\n\n    def test_invalid_question_type(self):\n        with self.assertRaises(ValueError):\n            prompt(\n                [\n                    {\n                        \"type\": \"mytype\",\n                        \"message\": \"Do you want to continue?\",\n                        \"name\": \"continue\",\n                        \"default\": True,\n                    }\n                ]\n            )\n\n    def test_missing_print_message(self):\n        \"\"\"Test 'print' raises exception if missing 'message'\"\"\"\n        with self.assertRaises(PromptParameterException):\n            prompt(\n                [\n                    {\n                        \"name\": \"test\",\n                        \"type\": \"print\",\n                    }\n                ]\n            )\n\n    def test_print_no_name(self):\n        \"\"\"'print' type doesn't require a name so it\n        should not throw PromptParameterException\"\"\"\n        questions = [{\"type\": \"print\", \"message\": \"Hello World\"}]\n        result = patched_prompt(questions, \"\")\n        self.assertEqual(result, {})\n\n    def test_print_with_name(self):\n        \"\"\"'print' type should return {name: None} when name is provided\"\"\"\n        questions = [{\"name\": \"hello\", \"type\": \"print\", \"message\": \"Hello World\"}]\n        result = patched_prompt(questions, \"\")\n        self.assertEqual(result, {\"hello\": None})\n\nif __name__ == \"__main__\":\n    unittest.main()",
  "GT_file_code": {
    "questionary/prompt.py": "from typing import Any\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Union\n\nfrom prompt_toolkit.output import ColorDepth\n\nfrom questionary import utils\nfrom questionary.constants import DEFAULT_KBI_MESSAGE\nfrom questionary.prompts import AVAILABLE_PROMPTS\nfrom questionary.prompts import prompt_by_name\nfrom questionary.prompts.common import print_formatted_text\n\n\nclass PromptParameterException(ValueError):\n    \"\"\"Received a prompt with a missing parameter.\"\"\"\n\n    def __init__(self, message: str, errors: Optional[BaseException] = None) -> None:\n        # Call the base class constructor with the parameters it needs\n        super().__init__(f\"You must provide a `{message}` value\", errors)\n\n\ndef prompt(\n    questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]],\n    answers: Optional[Mapping[str, Any]] = None,\n    patch_stdout: bool = False,\n    true_color: bool = False,\n    kbi_msg: str = DEFAULT_KBI_MESSAGE,\n    **kwargs: Any,\n) -> Dict[str, Any]:\n    \"\"\"Prompt the user for input on all the questions.\n\n    Catches keyboard interrupts and prints a message.\n\n    See :func:`unsafe_prompt` for possible question configurations.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        kbi_msg: The message to be printed on a keyboard interrupt.\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n    \"\"\"\n\n    try:\n        return unsafe_prompt(questions, answers, patch_stdout, true_color, **kwargs)\n    except KeyboardInterrupt:\n        print(kbi_msg)\n        return {}\n\n\ndef unsafe_prompt(\n    questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]],\n    answers: Optional[Mapping[str, Any]] = None,\n    patch_stdout: bool = False,\n    true_color: bool = False,\n    **kwargs: Any,\n) -> Dict[str, Any]:\n    \"\"\"Prompt the user for input on all the questions.\n\n    Won't catch keyboard interrupts.\n\n    Args:\n        questions: A list of question configs representing questions to\n                   ask. A question config may have the following options:\n\n                   * type - The type of question.\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\n\n                   * when - Callable to conditionally show the question. This function\n                     takes a :obj:`dict` representing the current answers.\n\n                   * filter - Function that the answer is passed to. The return value of this\n                     function is saved as the answer.\n\n                   Additional options correspond to the parameter names for\n                   particular question types.\n\n        answers: Default answers.\n\n        patch_stdout: Ensure that the prompt renders correctly if other threads\n                      are printing to stdout.\n\n        true_color: Use true color output.\n\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\n                     value is ignored.\n\n        type: Default ``type`` value to use in question config.\n        filter: Default ``filter`` value to use in question config.\n        name: Default ``name`` value to use in question config.\n        when: Default ``when`` value to use in question config.\n        default: Default ``default`` value to use in question config.\n        kwargs: Additional options passed to every question.\n\n    Returns:\n        Dictionary of question answers.\n\n    Raises:\n        KeyboardInterrupt: raised on keyboard interrupt\n    \"\"\"\n\n    if isinstance(questions, dict):\n        questions = [questions]\n\n    answers = dict(answers or {})\n\n    for question_config in questions:\n        question_config = dict(question_config)\n        # import the question\n        if \"type\" not in question_config:\n            raise PromptParameterException(\"type\")\n        # every type except 'print' needs a name\n        if \"name\" not in question_config and question_config[\"type\"] != \"print\":\n            raise PromptParameterException(\"name\")\n\n        _kwargs = kwargs.copy()\n        _kwargs.update(question_config)\n\n        _type = _kwargs.pop(\"type\")\n        _filter = _kwargs.pop(\"filter\", None)\n        name = _kwargs.pop(\"name\", None) if _type == \"print\" else _kwargs.pop(\"name\")\n        when = _kwargs.pop(\"when\", None)\n\n        if true_color:\n            _kwargs[\"color_depth\"] = ColorDepth.TRUE_COLOR\n\n        if when:\n            # at least a little sanity check!\n            if callable(question_config[\"when\"]):\n                try:\n                    if not question_config[\"when\"](answers):\n                        continue\n                except Exception as exception:\n                    raise ValueError(\n                        f\"Problem in 'when' check of \" f\"{name} question: {exception}\"\n                    ) from exception\n            else:\n                raise ValueError(\n                    \"'when' needs to be function that accepts a dict argument\"\n                )\n\n        # handle 'print' type\n        if _type == \"print\":\n            try:\n                message = _kwargs.pop(\"message\")\n            except KeyError as e:\n                raise PromptParameterException(\"message\") from e\n\n            # questions can take 'input' arg but print_formatted_text does not\n            # Remove 'input', if present, to avoid breaking during tests\n            _kwargs.pop(\"input\", None)\n\n            print_formatted_text(message, **_kwargs)\n            if name:\n                answers[name] = None\n            continue\n\n        choices = question_config.get(\"choices\")\n        if choices is not None and callable(choices):\n            calculated_choices = choices(answers)\n            question_config[\"choices\"] = calculated_choices\n            kwargs[\"choices\"] = calculated_choices\n\n        if _filter:\n            # at least a little sanity check!\n            if not callable(_filter):\n                raise ValueError(\n                    \"'filter' needs to be function that accepts an argument\"\n                )\n\n        if callable(question_config.get(\"default\")):\n            _kwargs[\"default\"] = question_config[\"default\"](answers)\n\n        create_question_func = prompt_by_name(_type)\n\n        if not create_question_func:\n            raise ValueError(\n                f\"No question type '{_type}' found. \"\n                f\"Known question types are {', '.join(AVAILABLE_PROMPTS)}.\"\n            )\n\n        missing_args = list(utils.missing_arguments(create_question_func, _kwargs))\n        if missing_args:\n            raise PromptParameterException(missing_args[0])\n\n        question = create_question_func(**_kwargs)\n\n        answer = question.unsafe_ask(patch_stdout)\n\n        if answer is not None:\n            if _filter:\n                try:\n                    answer = _filter(answer)\n                except Exception as exception:\n                    raise ValueError(\n                        f\"Problem processing 'filter' of {name} \"\n                        f\"question: {exception}\"\n                    ) from exception\n            answers[name] = answer\n\n    return answers\n",
    "questionary/prompts/common.py": "import inspect\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\n\nfrom prompt_toolkit import PromptSession\nfrom prompt_toolkit.filters import Always\nfrom prompt_toolkit.filters import Condition\nfrom prompt_toolkit.filters import IsDone\nfrom prompt_toolkit.keys import Keys\nfrom prompt_toolkit.layout import ConditionalContainer\nfrom prompt_toolkit.layout import FormattedTextControl\nfrom prompt_toolkit.layout import HSplit\nfrom prompt_toolkit.layout import Layout\nfrom prompt_toolkit.layout import Window\nfrom prompt_toolkit.layout.dimension import LayoutDimension\nfrom prompt_toolkit.styles import Style\nfrom prompt_toolkit.validation import ValidationError\nfrom prompt_toolkit.validation import Validator\n\nfrom questionary.constants import DEFAULT_SELECTED_POINTER\nfrom questionary.constants import DEFAULT_STYLE\nfrom questionary.constants import INDICATOR_SELECTED\nfrom questionary.constants import INDICATOR_UNSELECTED\nfrom questionary.constants import INVALID_INPUT\n\n# This is a cut-down version of `prompt_toolkit.formatted_text.AnyFormattedText`\n# which does not exist in v2 of prompt_toolkit\nFormattedText = Union[\n    str,\n    List[Tuple[str, str]],\n    List[Tuple[str, str, Callable[[Any], None]]],\n    None,\n]\n\n\nclass Choice:\n    \"\"\"One choice in a :meth:`select`, :meth:`rawselect` or :meth:`checkbox`.\n\n    Args:\n        title: Text shown in the selection list.\n\n        value: Value returned, when the choice is selected. If this argument\n               is `None` or unset, then the value of `title` is used.\n\n        disabled: If set, the choice can not be selected by the user. The\n                  provided text is used to explain, why the selection is\n                  disabled.\n\n        checked: Preselect this choice when displaying the options.\n\n        shortcut_key: Key shortcut used to select this item.\n\n        description: Optional description of the item that can be displayed.\n    \"\"\"\n\n    title: FormattedText\n    \"\"\"Display string for the choice\"\"\"\n\n    value: Optional[Any]\n    \"\"\"Value of the choice\"\"\"\n\n    disabled: Optional[str]\n    \"\"\"Whether the choice can be selected\"\"\"\n\n    checked: Optional[bool]\n    \"\"\"Whether the choice is initially selected\"\"\"\n\n    __shortcut_key: Optional[Union[str, bool]]\n\n    description: Optional[str]\n    \"\"\"Choice description\"\"\"\n\n    def __init__(\n        self,\n        title: FormattedText,\n        value: Optional[Any] = None,\n        disabled: Optional[str] = None,\n        checked: Optional[bool] = False,\n        shortcut_key: Optional[Union[str, bool]] = True,\n        description: Optional[str] = None,\n    ) -> None:\n        self.disabled = disabled\n        self.title = title\n        self.shortcut_key = shortcut_key\n        # self.auto_shortcut is set by the self.shortcut_key setter\n        self.checked = checked if checked is not None else False\n        self.description = description\n\n        if value is not None:\n            self.value = value\n        elif isinstance(title, list):\n            self.value = \"\".join([token[1] for token in title])\n        else:\n            self.value = title\n\n    @staticmethod\n    def build(c: Union[str, \"Choice\", Dict[str, Any]]) -> \"Choice\":\n        \"\"\"Create a choice object from different representations.\n\n        Args:\n            c: Either a :obj:`str`, :class:`Choice` or :obj:`dict` with\n               ``name``, ``value``, ``disabled``, ``checked`` and\n               ``key`` properties.\n\n        Returns:\n            An instance of the :class:`Choice` object.\n        \"\"\"\n\n        if isinstance(c, Choice):\n            return c\n        elif isinstance(c, str):\n            return Choice(c, c)\n        else:\n            return Choice(\n                c.get(\"name\"),\n                c.get(\"value\"),\n                c.get(\"disabled\", None),\n                c.get(\"checked\"),\n                c.get(\"key\"),\n                c.get(\"description\", None),\n            )\n\n    @property\n    def shortcut_key(self) -> Optional[Union[str, bool]]:\n        \"\"\"A shortcut key for the choice\"\"\"\n        return self.__shortcut_key\n\n    @shortcut_key.setter\n    def shortcut_key(self, key: Optional[Union[str, bool]]):\n        if key is not None:\n            if isinstance(key, bool):\n                self.__auto_shortcut = key\n                self.__shortcut_key = None\n            else:\n                self.__shortcut_key = str(key)\n                self.__auto_shortcut = False\n        else:\n            self.__shortcut_key = None\n            self.__auto_shortcut = True\n\n    @shortcut_key.deleter\n    def shortcut_key(self):\n        self.__shortcut_key = None\n        self.__auto_shortcut = True\n\n    def get_shortcut_title(self):\n        if self.shortcut_key is None:\n            return \"-) \"\n        else:\n            return \"{}) \".format(self.shortcut_key)\n\n    @property\n    def auto_shortcut(self) -> bool:\n        \"\"\"Whether to assign a shortcut key to the choice\n\n        Keys are assigned starting with numbers and proceeding\n        through the ASCII alphabet.\n        \"\"\"\n        return self.__auto_shortcut\n\n    @auto_shortcut.setter\n    def auto_shortcut(self, should_assign: bool):\n        self.__auto_shortcut = should_assign\n        if self.__auto_shortcut:\n            self.__shortcut_key = None\n\n    @auto_shortcut.deleter\n    def auto_shortcut(self):\n        self.__auto_shortcut = False\n\n\nclass Separator(Choice):\n    \"\"\"Used to space/separate choices group.\"\"\"\n\n    default_separator: str = \"-\" * 15\n    \"\"\"The default separator used if none is specified\"\"\"\n\n    line: str\n    \"\"\"The string being used as a separator\"\"\"\n\n    def __init__(self, line: Optional[str] = None) -> None:\n        \"\"\"Create a separator in a list.\n\n        Args:\n            line: Text to be displayed in the list, by default uses ``---``.\n        \"\"\"\n\n        self.line = line or self.default_separator\n        super().__init__(self.line, None, \"-\")\n\n\nclass InquirerControl(FormattedTextControl):\n    SHORTCUT_KEYS = [\n        \"1\",\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\",\n        \"6\",\n        \"7\",\n        \"8\",\n        \"9\",\n        \"0\",\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"e\",\n        \"f\",\n        \"g\",\n        \"h\",\n        \"i\",\n        \"j\",\n        \"k\",\n        \"l\",\n        \"m\",\n        \"n\",\n        \"o\",\n        \"p\",\n        \"q\",\n        \"r\",\n        \"s\",\n        \"t\",\n        \"u\",\n        \"v\",\n        \"w\",\n        \"x\",\n        \"y\",\n        \"z\",\n    ]\n\n    choices: List[Choice]\n    default: Optional[Union[str, Choice, Dict[str, Any]]]\n    selected_options: List[Any]\n    search_filter: Union[str, None] = None\n    use_indicator: bool\n    use_shortcuts: bool\n    use_arrow_keys: bool\n    pointer: Optional[str]\n    pointed_at: int\n    is_answered: bool\n    show_description: bool\n\n    def __init__(\n        self,\n        choices: Sequence[Union[str, Choice, Dict[str, Any]]],\n        default: Optional[Union[str, Choice, Dict[str, Any]]] = None,\n        pointer: Optional[str] = DEFAULT_SELECTED_POINTER,\n        use_indicator: bool = True,\n        use_shortcuts: bool = False,\n        show_selected: bool = False,\n        show_description: bool = True,\n        use_arrow_keys: bool = True,\n        initial_choice: Optional[Union[str, Choice, Dict[str, Any]]] = None,\n        **kwargs: Any,\n    ):\n        self.use_indicator = use_indicator\n        self.use_shortcuts = use_shortcuts\n        self.show_selected = show_selected\n        self.show_description = show_description\n        self.use_arrow_keys = use_arrow_keys\n        self.default = default\n        self.pointer = pointer\n\n        if isinstance(default, Choice):\n            default = default.value\n\n        choices_values = [\n            choice.value for choice in choices if isinstance(choice, Choice)\n        ]\n\n        if (\n            default is not None\n            and default not in choices\n            and default not in choices_values\n        ):\n            raise ValueError(\n                f\"Invalid `default` value passed. The value (`{default}`) \"\n                f\"does not exist in the set of choices. Please make sure the \"\n                f\"default value is one of the available choices.\"\n            )\n\n        if initial_choice is None:\n            pointed_at = None\n        elif initial_choice in choices:\n            pointed_at = choices.index(initial_choice)\n        elif initial_choice in choices_values:\n            for k, choice in enumerate(choices):\n                if isinstance(choice, Choice):\n                    if choice.value == initial_choice:\n                        pointed_at = k\n                        break\n\n        else:\n            raise ValueError(\n                f\"Invalid `initial_choice` value passed. The value \"\n                f\"(`{initial_choice}`) does not exist in \"\n                f\"the set of choices. Please make sure the initial value is \"\n                f\"one of the available choices.\"\n            )\n\n        self.is_answered = False\n        self.choices = []\n        self.submission_attempted = False\n        self.error_message = None\n        self.selected_options = []\n        self.found_in_search = False\n\n        self._init_choices(choices, pointed_at)\n        self._assign_shortcut_keys()\n\n        super().__init__(self._get_choice_tokens, **kwargs)\n\n        if not self.is_selection_valid():\n            raise ValueError(\n                f\"Invalid 'initial_choice' value ('{initial_choice}'). \"\n                f\"It must be a selectable value.\"\n            )\n\n    def _is_selected(self, choice: Choice):\n        if isinstance(self.default, Choice):\n            compare_default = self.default == choice\n        else:\n            compare_default = self.default == choice.value\n        return choice.checked or compare_default and self.default is not None\n\n    def _assign_shortcut_keys(self):\n        available_shortcuts = self.SHORTCUT_KEYS[:]\n\n        # first, make sure we do not double assign a shortcut\n        for c in self.choices:\n            if c.shortcut_key is not None:\n                if c.shortcut_key in available_shortcuts:\n                    available_shortcuts.remove(c.shortcut_key)\n                else:\n                    raise ValueError(\n                        \"Invalid shortcut '{}'\"\n                        \"for choice '{}'. Shortcuts \"\n                        \"should be single characters or numbers. \"\n                        \"Make sure that all your shortcuts are \"\n                        \"unique.\".format(c.shortcut_key, c.title)\n                    )\n\n        shortcut_idx = 0\n        for c in self.choices:\n            if c.auto_shortcut and not c.disabled:\n                c.shortcut_key = available_shortcuts[shortcut_idx]\n                shortcut_idx += 1\n\n            if shortcut_idx == len(available_shortcuts):\n                break  # fail gracefully if we run out of shortcuts\n\n    def _init_choices(\n        self,\n        choices: Sequence[Union[str, Choice, Dict[str, Any]]],\n        pointed_at: Optional[int],\n    ):\n        # helper to convert from question format to internal format\n        self.choices = []\n\n        if pointed_at is not None:\n            self.pointed_at = pointed_at\n\n        for i, c in enumerate(choices):\n            choice = Choice.build(c)\n\n            if self._is_selected(choice):\n                self.selected_options.append(choice.value)\n\n            if pointed_at is None and not choice.disabled:\n                # find the first (available) choice\n                self.pointed_at = pointed_at = i\n\n            self.choices.append(choice)\n\n    @property\n    def filtered_choices(self):\n        if not self.search_filter:\n            return self.choices\n        filtered = [\n            c for c in self.choices if self.search_filter.lower() in c.title.lower()\n        ]\n        self.found_in_search = len(filtered) > 0\n        return filtered if self.found_in_search else self.choices\n\n    @property\n    def choice_count(self) -> int:\n        return len(self.filtered_choices)\n\n    def _get_choice_tokens(self):\n        tokens = []\n\n        def append(index: int, choice: Choice):\n            # use value to check if option has been selected\n            selected = choice.value in self.selected_options\n\n            if index == self.pointed_at:\n                if self.pointer is not None:\n                    tokens.append((\"class:pointer\", \" {} \".format(self.pointer)))\n                else:\n                    tokens.append((\"class:text\", \" \" * 3))\n\n                tokens.append((\"[SetCursorPosition]\", \"\"))\n            else:\n                pointer_length = len(self.pointer) if self.pointer is not None else 1\n                tokens.append((\"class:text\", \" \" * (2 + pointer_length)))\n\n            if isinstance(choice, Separator):\n                tokens.append((\"class:separator\", \"{}\".format(choice.title)))\n            elif choice.disabled:  # disabled\n                if isinstance(choice.title, list):\n                    tokens.append(\n                        (\"class:selected\" if selected else \"class:disabled\", \"- \")\n                    )\n                    tokens.extend(choice.title)\n                else:\n                    tokens.append(\n                        (\n                            \"class:selected\" if selected else \"class:disabled\",\n                            \"- {}\".format(choice.title),\n                        )\n                    )\n\n                tokens.append(\n                    (\n                        \"class:selected\" if selected else \"class:disabled\",\n                        \"{}\".format(\n                            \"\"\n                            if isinstance(choice.disabled, bool)\n                            else \" ({})\".format(choice.disabled)\n                        ),\n                    )\n                )\n            else:\n                shortcut = choice.get_shortcut_title() if self.use_shortcuts else \"\"\n\n                if selected:\n                    if self.use_indicator:\n                        indicator = INDICATOR_SELECTED + \" \"\n                    else:\n                        indicator = \"\"\n\n                    tokens.append((\"class:selected\", \"{}\".format(indicator)))\n                else:\n                    if self.use_indicator:\n                        indicator = INDICATOR_UNSELECTED + \" \"\n                    else:\n                        indicator = \"\"\n\n                    tokens.append((\"class:text\", \"{}\".format(indicator)))\n\n                if isinstance(choice.title, list):\n                    tokens.extend(choice.title)\n                elif selected:\n                    tokens.append(\n                        (\"class:selected\", \"{}{}\".format(shortcut, choice.title))\n                    )\n                elif index == self.pointed_at:\n                    tokens.append(\n                        (\"class:highlighted\", \"{}{}\".format(shortcut, choice.title))\n                    )\n                else:\n                    tokens.append((\"class:text\", \"{}{}\".format(shortcut, choice.title)))\n\n            tokens.append((\"\", \"\\n\"))\n\n        # prepare the select choices\n        for i, c in enumerate(self.filtered_choices):\n            append(i, c)\n\n        current = self.get_pointed_at()\n\n        if self.show_selected:\n            answer = current.get_shortcut_title() if self.use_shortcuts else \"\"\n\n            answer += (\n                current.title if isinstance(current.title, str) else current.title[0][1]\n            )\n\n            tokens.append((\"class:text\", \"  Answer: {}\".format(answer)))\n\n        show_description = self.show_description and current.description is not None\n        if show_description:\n            tokens.append(\n                (\"class:text\", \"  Description: {}\".format(current.description))\n            )\n\n        if not (self.show_selected or show_description):\n            tokens.pop()  # Remove last newline.\n\n        return tokens\n\n    def is_selection_a_separator(self) -> bool:\n        selected = self.choices[self.pointed_at]\n        return isinstance(selected, Separator)\n\n    def is_selection_disabled(self) -> Optional[str]:\n        return self.choices[self.pointed_at].disabled\n\n    def is_selection_valid(self) -> bool:\n        return not self.is_selection_disabled() and not self.is_selection_a_separator()\n\n    def select_previous(self) -> None:\n        self.pointed_at = (self.pointed_at - 1) % self.choice_count\n\n    def select_next(self) -> None:\n        self.pointed_at = (self.pointed_at + 1) % self.choice_count\n\n    def get_pointed_at(self) -> Choice:\n        return self.filtered_choices[self.pointed_at]\n\n    def get_selected_values(self) -> List[Choice]:\n        # get values not labels\n        return [\n            c\n            for c in self.choices\n            if (not isinstance(c, Separator) and c.value in self.selected_options)\n        ]\n\n    def add_search_character(self, char: Keys) -> None:\n        \"\"\"Adds a character to the search filter\"\"\"\n        if char == Keys.Backspace:\n            self.remove_search_character()\n        else:\n            if self.search_filter is None:\n                self.search_filter = str(char)\n            else:\n                self.search_filter += str(char)\n\n        # Make sure that the selection is in the bounds of the filtered list\n        self.pointed_at = 0\n\n    def remove_search_character(self) -> None:\n        if self.search_filter and len(self.search_filter) > 1:\n            self.search_filter = self.search_filter[:-1]\n        else:\n            self.search_filter = None\n\n    def get_search_string_tokens(self):\n        if self.search_filter is None:\n            return None\n\n        return [\n            (\"\", \"\\n\"),\n            (\"class:question-mark\", \"/ \"),\n            (\n                \"class:search_success\" if self.found_in_search else \"class:search_none\",\n                self.search_filter,\n            ),\n            (\"class:question-mark\", \"...\"),\n        ]\n\n\ndef build_validator(validate: Any) -> Optional[Validator]:\n    if validate:\n        if inspect.isclass(validate) and issubclass(validate, Validator):\n            return validate()\n        elif isinstance(validate, Validator):\n            return validate\n        elif callable(validate):\n\n            class _InputValidator(Validator):\n                def validate(self, document):\n                    verdict = validate(document.text)\n                    if verdict is not True:\n                        if verdict is False:\n                            verdict = INVALID_INPUT\n                        raise ValidationError(\n                            message=verdict, cursor_position=len(document.text)\n                        )\n\n            return _InputValidator()\n    return None\n\n\ndef _fix_unecessary_blank_lines(ps: PromptSession) -> None:\n    \"\"\"This is a fix for additional empty lines added by prompt toolkit.\n\n    This assumes the layout of the default session doesn't change, if it\n    does, this needs an update.\"\"\"\n\n    default_container = ps.layout.container\n\n    default_buffer_window = (\n        default_container.get_children()[0].content.get_children()[1].content  # type: ignore[attr-defined]\n    )\n\n    assert isinstance(default_buffer_window, Window)\n    # this forces the main window to stay as small as possible, avoiding\n    # empty lines in selections\n    default_buffer_window.dont_extend_height = Always()\n    default_buffer_window.always_hide_cursor = Always()\n\n\ndef create_inquirer_layout(\n    ic: InquirerControl,\n    get_prompt_tokens: Callable[[], List[Tuple[str, str]]],\n    **kwargs: Any,\n) -> Layout:\n    \"\"\"Create a layout combining question and inquirer selection.\"\"\"\n\n    ps: PromptSession = PromptSession(\n        get_prompt_tokens, reserve_space_for_menu=0, **kwargs\n    )\n    _fix_unecessary_blank_lines(ps)\n\n    @Condition\n    def has_search_string():\n        return ic.get_search_string_tokens() is not None\n\n    validation_prompt: PromptSession = PromptSession(\n        bottom_toolbar=lambda: ic.error_message, **kwargs\n    )\n\n    return Layout(\n        HSplit(\n            [\n                ps.layout.container,\n                ConditionalContainer(Window(ic), filter=~IsDone()),\n                ConditionalContainer(\n                    Window(\n                        height=LayoutDimension.exact(2),\n                        content=FormattedTextControl(ic.get_search_string_tokens),\n                    ),\n                    filter=has_search_string & ~IsDone(),\n                ),\n                ConditionalContainer(\n                    validation_prompt.layout.container,\n                    filter=Condition(lambda: ic.error_message is not None),\n                ),\n            ]\n        )\n    )\n\n\ndef print_formatted_text(text: str, style: Optional[str] = None, **kwargs: Any) -> None:\n    \"\"\"Print formatted text.\n\n    Sometimes you want to spice up your printed messages a bit,\n    :meth:`questionary.print` is a helper to do just that.\n\n    Example:\n\n        >>> import questionary\n        >>> questionary.print(\"Hello World \ud83e\udd84\", style=\"bold italic fg:darkred\")\n        Hello World \ud83e\udd84\n\n    .. image:: ../images/print.gif\n\n    Args:\n        text: Text to be printed.\n        style: Style used for printing. The style argument uses the\n            prompt :ref:`toolkit style strings <prompt_toolkit:styling>`.\n    \"\"\"\n    from prompt_toolkit import print_formatted_text as pt_print\n    from prompt_toolkit.formatted_text import FormattedText as FText\n\n    if style is not None:\n        text_style = Style([(\"text\", style)])\n    else:\n        text_style = DEFAULT_STYLE\n\n    pt_print(FText([(\"class:text\", text)]), style=text_style, **kwargs)\n",
    "questionary/utils.py": "import inspect\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\n\nACTIVATED_ASYNC_MODE = False\n\n\ndef is_prompt_toolkit_3() -> bool:\n    from prompt_toolkit import __version__ as ptk_version\n\n    return ptk_version.startswith(\"3.\")\n\n\ndef default_values_of(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return all parameter names of ``func`` with a default value.\"\"\"\n\n    signature = inspect.signature(func)\n    return [\n        k\n        for k, v in signature.parameters.items()\n        if v.default is not inspect.Parameter.empty\n        or v.kind != inspect.Parameter.POSITIONAL_OR_KEYWORD\n    ]\n\n\ndef arguments_of(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return the parameter names of the function ``func``.\"\"\"\n\n    return list(inspect.signature(func).parameters.keys())\n\n\ndef used_kwargs(kwargs: Dict[str, Any], func: Callable[..., Any]) -> Dict[str, Any]:\n    \"\"\"Returns only the kwargs which can be used by a function.\n\n    Args:\n        kwargs: All available kwargs.\n        func: The function which should be called.\n\n    Returns:\n        Subset of kwargs which are accepted by ``func``.\n    \"\"\"\n\n    possible_arguments = arguments_of(func)\n\n    return {k: v for k, v in kwargs.items() if k in possible_arguments}\n\n\ndef required_arguments(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return all arguments of a function that do not have a default value.\"\"\"\n    defaults = default_values_of(func)\n    args = arguments_of(func)\n\n    if defaults:\n        args = args[: -len(defaults)]\n    return args  # all args without default values\n\n\ndef missing_arguments(func: Callable[..., Any], argdict: Dict[str, Any]) -> Set[str]:\n    \"\"\"Return all arguments that are missing to call func.\"\"\"\n    return set(required_arguments(func)) - set(argdict.keys())\n\n\nasync def activate_prompt_toolkit_async_mode() -> None:\n    \"\"\"Configure prompt toolkit to use the asyncio event loop.\n\n    Needs to be async, so we use the right event loop in py 3.5\"\"\"\n    global ACTIVATED_ASYNC_MODE\n\n    if not is_prompt_toolkit_3():\n        # Tell prompt_toolkit to use asyncio for the event loop.\n        import prompt_toolkit as pt\n\n        pt.eventloop.use_asyncio_event_loop()  # type: ignore[attr-defined]\n\n    ACTIVATED_ASYNC_MODE = True\n",
    "questionary/prompts/__init__.py": "from questionary.prompts import autocomplete\nfrom questionary.prompts import checkbox\nfrom questionary.prompts import confirm\nfrom questionary.prompts import password\nfrom questionary.prompts import path\nfrom questionary.prompts import press_any_key_to_continue\nfrom questionary.prompts import rawselect\nfrom questionary.prompts import select\nfrom questionary.prompts import text\n\nAVAILABLE_PROMPTS = {\n    \"autocomplete\": autocomplete.autocomplete,\n    \"confirm\": confirm.confirm,\n    \"text\": text.text,\n    \"select\": select.select,\n    \"rawselect\": rawselect.rawselect,\n    \"password\": password.password,\n    \"checkbox\": checkbox.checkbox,\n    \"path\": path.path,\n    \"press_any_key_to_continue\": press_any_key_to_continue.press_any_key_to_continue,\n    # backwards compatible names\n    \"list\": select.select,\n    \"rawlist\": rawselect.rawselect,\n    \"input\": text.text,\n}\n\n\ndef prompt_by_name(name):\n    return AVAILABLE_PROMPTS.get(name)\n"
  },
  "GT_src_dict": {
    "questionary/prompt.py": {
      "PromptParameterException.__init__": {
        "code": "    def __init__(self, message: str, errors: Optional[BaseException]=None) -> None:\n        \"\"\"Initialize a PromptParameterException with a message and optional errors.\n\nArgs:\n    message (str): A description of the missing parameter, which will be included in the exception message.\n    errors (Optional[BaseException], optional): An optional base exception that can be linked to this exception for additional context.\n\nRaises:\n    ValueError: This exception is specifically for indicating missing parameters in prompt configurations when constructing the prompt questions.\n\nThe generated message will indicate that a specific value is required, helping users identify the source of the error in the context of prompting for input.\"\"\"\n        super().__init__(f'You must provide a `{message}` value', errors)",
        "docstring": "Initialize a PromptParameterException with a message and optional errors.\n\nArgs:\n    message (str): A description of the missing parameter, which will be included in the exception message.\n    errors (Optional[BaseException], optional): An optional base exception that can be linked to this exception for additional context.\n\nRaises:\n    ValueError: This exception is specifically for indicating missing parameters in prompt configurations when constructing the prompt questions.\n\nThe generated message will indicate that a specific value is required, helping users identify the source of the error in the context of prompting for input.",
        "signature": "def __init__(self, message: str, errors: Optional[BaseException]=None) -> None:",
        "type": "Method",
        "class_signature": "class PromptParameterException(ValueError):"
      },
      "prompt": {
        "code": "def prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, kbi_msg: str=DEFAULT_KBI_MESSAGE, **kwargs: Any) -> Dict[str, Any]:\n    \"\"\"Prompts the user for input based on a series of defined questions, handling keyboard interrupts gracefully.\n\nThis function processes a list or dictionary of question configurations, each specifying the type and parameters of the prompt to be displayed. It catches `KeyboardInterrupt` exceptions to allow for custom handling using the `kbi_msg` parameter, which defaults to a predefined message in `DEFAULT_KBI_MESSAGE` from `questionary.constants`. The function internally calls `unsafe_prompt`, which executes the prompting logic without exception handling for interrupts.\n\nParameters:\n- questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A list or dictionary of question configurations that define what and how to prompt the user. Each configuration can specify options such as 'type', 'name', 'when', and 'filter'.\n- answers (Optional[Mapping[str, Any]]): An optional mapping of default answers to pre-fill the prompts.\n- patch_stdout (bool): Enables rendering adjustments in the prompt for compatibility with other threads' output.\n- true_color (bool): When set to true, uses true color output for the prompts.\n- kbi_msg (str): The message to be displayed on keyboard interrupts; defaults to `DEFAULT_KBI_MESSAGE`.\n- **kwargs (Any): Additional parameters that may be passed to each prompt, such as 'color_depth', 'type', 'filter', 'name', 'when', and 'default'.\n\nReturns:\n- Dict[str, Any]: A dictionary mapping question names to their respective user answers.\n\nThe function is designed for interaction in command-line interfaces and relies on methods and constants from the `questionary` module for its functionality.\"\"\"\n    'Prompt the user for input on all the questions.\\n\\n    Catches keyboard interrupts and prints a message.\\n\\n    See :func:`unsafe_prompt` for possible question configurations.\\n\\n    Args:\\n        questions: A list of question configs representing questions to\\n                   ask. A question config may have the following options:\\n\\n                   * type - The type of question.\\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\\n\\n                   * when - Callable to conditionally show the question. This function\\n                     takes a :obj:`dict` representing the current answers.\\n\\n                   * filter - Function that the answer is passed to. The return value of this\\n                     function is saved as the answer.\\n\\n                   Additional options correspond to the parameter names for\\n                   particular question types.\\n\\n        answers: Default answers.\\n\\n        patch_stdout: Ensure that the prompt renders correctly if other threads\\n                      are printing to stdout.\\n\\n        kbi_msg: The message to be printed on a keyboard interrupt.\\n        true_color: Use true color output.\\n\\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\\n                     value is ignored.\\n\\n        type: Default ``type`` value to use in question config.\\n        filter: Default ``filter`` value to use in question config.\\n        name: Default ``name`` value to use in question config.\\n        when: Default ``when`` value to use in question config.\\n        default: Default ``default`` value to use in question config.\\n        kwargs: Additional options passed to every question.\\n\\n    Returns:\\n        Dictionary of question answers.\\n    '\n    try:\n        return unsafe_prompt(questions, answers, patch_stdout, true_color, **kwargs)\n    except KeyboardInterrupt:\n        print(kbi_msg)\n        return {}",
        "docstring": "Prompts the user for input based on a series of defined questions, handling keyboard interrupts gracefully.\n\nThis function processes a list or dictionary of question configurations, each specifying the type and parameters of the prompt to be displayed. It catches `KeyboardInterrupt` exceptions to allow for custom handling using the `kbi_msg` parameter, which defaults to a predefined message in `DEFAULT_KBI_MESSAGE` from `questionary.constants`. The function internally calls `unsafe_prompt`, which executes the prompting logic without exception handling for interrupts.\n\nParameters:\n- questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A list or dictionary of question configurations that define what and how to prompt the user. Each configuration can specify options such as 'type', 'name', 'when', and 'filter'.\n- answers (Optional[Mapping[str, Any]]): An optional mapping of default answers to pre-fill the prompts.\n- patch_stdout (bool): Enables rendering adjustments in the prompt for compatibility with other threads' output.\n- true_color (bool): When set to true, uses true color output for the prompts.\n- kbi_msg (str): The message to be displayed on keyboard interrupts; defaults to `DEFAULT_KBI_MESSAGE`.\n- **kwargs (Any): Additional parameters that may be passed to each prompt, such as 'color_depth', 'type', 'filter', 'name', 'when', and 'default'.\n\nReturns:\n- Dict[str, Any]: A dictionary mapping question names to their respective user answers.\n\nThe function is designed for interaction in command-line interfaces and relies on methods and constants from the `questionary` module for its functionality.",
        "signature": "def prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, kbi_msg: str=DEFAULT_KBI_MESSAGE, **kwargs: Any) -> Dict[str, Any]:",
        "type": "Function",
        "class_signature": null
      },
      "unsafe_prompt": {
        "code": "def unsafe_prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, **kwargs: Any) -> Dict[str, Any]:\n    \"\"\"Prompt the user for input on a series of questions without handling keyboard interrupts.\n\nArgs:\n    questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A single question configuration or a collection of question configurations. Each configuration should specify at least a 'type' and optionally a 'name', 'when' callable, 'filter' callable, and other parameters relevant to specific question types.\n    \n    answers (Optional[Mapping[str, Any]]): A dictionary of default answers to pre-populate the prompts.\n    \n    patch_stdout (bool): If True, ensures that the prompt renders correctly when other threads are printing to stdout.\n    \n    true_color (bool): If True, enables true color output; otherwise, it defaults to a limited color set.\n    \n    **kwargs (Any): Additional options that may be relevant to specific question types (e.g., 'default', 'filter', 'when').\n\nReturns:\n    Dict[str, Any]: A dictionary containing the user's answers to the prompts.\n\nRaises:\n    PromptParameterException: If a required prompt parameter ('type' or 'name') is missing from a question configuration.\n    ValueError: If an invalid callable is provided for 'when' or 'filter', or if a question type is unknown.\n\nDependencies:\n    This function relies on `prompt_by_name` from the `questionary.prompts` module to generate question instances and `utils.missing_arguments` from the `questionary` module to check for missing arguments required by the question creation functions. Constants like `ColorDepth` from `prompt_toolkit.output` are used for managing color output.\"\"\"\n    \"Prompt the user for input on all the questions.\\n\\n    Won't catch keyboard interrupts.\\n\\n    Args:\\n        questions: A list of question configs representing questions to\\n                   ask. A question config may have the following options:\\n\\n                   * type - The type of question.\\n                   * name - An ID for the question (to identify it in the answers :obj:`dict`).\\n\\n                   * when - Callable to conditionally show the question. This function\\n                     takes a :obj:`dict` representing the current answers.\\n\\n                   * filter - Function that the answer is passed to. The return value of this\\n                     function is saved as the answer.\\n\\n                   Additional options correspond to the parameter names for\\n                   particular question types.\\n\\n        answers: Default answers.\\n\\n        patch_stdout: Ensure that the prompt renders correctly if other threads\\n                      are printing to stdout.\\n\\n        true_color: Use true color output.\\n\\n        color_depth: Color depth to use. If ``true_color`` is set to true then this\\n                     value is ignored.\\n\\n        type: Default ``type`` value to use in question config.\\n        filter: Default ``filter`` value to use in question config.\\n        name: Default ``name`` value to use in question config.\\n        when: Default ``when`` value to use in question config.\\n        default: Default ``default`` value to use in question config.\\n        kwargs: Additional options passed to every question.\\n\\n    Returns:\\n        Dictionary of question answers.\\n\\n    Raises:\\n        KeyboardInterrupt: raised on keyboard interrupt\\n    \"\n    if isinstance(questions, dict):\n        questions = [questions]\n    answers = dict(answers or {})\n    for question_config in questions:\n        question_config = dict(question_config)\n        if 'type' not in question_config:\n            raise PromptParameterException('type')\n        if 'name' not in question_config and question_config['type'] != 'print':\n            raise PromptParameterException('name')\n        _kwargs = kwargs.copy()\n        _kwargs.update(question_config)\n        _type = _kwargs.pop('type')\n        _filter = _kwargs.pop('filter', None)\n        name = _kwargs.pop('name', None) if _type == 'print' else _kwargs.pop('name')\n        when = _kwargs.pop('when', None)\n        if true_color:\n            _kwargs['color_depth'] = ColorDepth.TRUE_COLOR\n        if when:\n            if callable(question_config['when']):\n                try:\n                    if not question_config['when'](answers):\n                        continue\n                except Exception as exception:\n                    raise ValueError(f\"Problem in 'when' check of {name} question: {exception}\") from exception\n            else:\n                raise ValueError(\"'when' needs to be function that accepts a dict argument\")\n        if _type == 'print':\n            try:\n                message = _kwargs.pop('message')\n            except KeyError as e:\n                raise PromptParameterException('message') from e\n            _kwargs.pop('input', None)\n            print_formatted_text(message, **_kwargs)\n            if name:\n                answers[name] = None\n            continue\n        choices = question_config.get('choices')\n        if choices is not None and callable(choices):\n            calculated_choices = choices(answers)\n            question_config['choices'] = calculated_choices\n            kwargs['choices'] = calculated_choices\n        if _filter:\n            if not callable(_filter):\n                raise ValueError(\"'filter' needs to be function that accepts an argument\")\n        if callable(question_config.get('default')):\n            _kwargs['default'] = question_config['default'](answers)\n        create_question_func = prompt_by_name(_type)\n        if not create_question_func:\n            raise ValueError(f\"No question type '{_type}' found. Known question types are {', '.join(AVAILABLE_PROMPTS)}.\")\n        missing_args = list(utils.missing_arguments(create_question_func, _kwargs))\n        if missing_args:\n            raise PromptParameterException(missing_args[0])\n        question = create_question_func(**_kwargs)\n        answer = question.unsafe_ask(patch_stdout)\n        if answer is not None:\n            if _filter:\n                try:\n                    answer = _filter(answer)\n                except Exception as exception:\n                    raise ValueError(f\"Problem processing 'filter' of {name} question: {exception}\") from exception\n            answers[name] = answer\n    return answers",
        "docstring": "Prompt the user for input on a series of questions without handling keyboard interrupts.\n\nArgs:\n    questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A single question configuration or a collection of question configurations. Each configuration should specify at least a 'type' and optionally a 'name', 'when' callable, 'filter' callable, and other parameters relevant to specific question types.\n    \n    answers (Optional[Mapping[str, Any]]): A dictionary of default answers to pre-populate the prompts.\n    \n    patch_stdout (bool): If True, ensures that the prompt renders correctly when other threads are printing to stdout.\n    \n    true_color (bool): If True, enables true color output; otherwise, it defaults to a limited color set.\n    \n    **kwargs (Any): Additional options that may be relevant to specific question types (e.g., 'default', 'filter', 'when').\n\nReturns:\n    Dict[str, Any]: A dictionary containing the user's answers to the prompts.\n\nRaises:\n    PromptParameterException: If a required prompt parameter ('type' or 'name') is missing from a question configuration.\n    ValueError: If an invalid callable is provided for 'when' or 'filter', or if a question type is unknown.\n\nDependencies:\n    This function relies on `prompt_by_name` from the `questionary.prompts` module to generate question instances and `utils.missing_arguments` from the `questionary` module to check for missing arguments required by the question creation functions. Constants like `ColorDepth` from `prompt_toolkit.output` are used for managing color output.",
        "signature": "def unsafe_prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, **kwargs: Any) -> Dict[str, Any]:",
        "type": "Function",
        "class_signature": null
      }
    },
    "questionary/prompts/common.py": {
      "print_formatted_text": {
        "code": "def print_formatted_text(text: str, style: Optional[str]=None, **kwargs: Any) -> None:\n    \"\"\"Print formatted text to the console with optional styling using the `prompt_toolkit` library.\n\nThis function enhances the visual presentation of printed messages by allowing the application of various styles, such as bold, italic, and color. The style argument utilizes the prompt toolkit's styling conventions and falls back to a default style if not provided.\n\nArgs:\n    text (str): The message to be printed in the console.\n    style (Optional[str]): A string specifying the styling to be applied. It utilizes the prompt toolkit-style strings for the desired visual effects. If None, the default style, defined as `DEFAULT_STYLE`, is used.\n    **kwargs: Additional keyword arguments passed to the formatting function.\n\nDependencies:\n    - Uses `print_formatted_text` from `prompt_toolkit` for actual text rendering.\n    - Uses `FormattedText` from `prompt_toolkit.formatted_text` to structure the text for printing.\n    - Relies on the `DEFAULT_STYLE` constant defined in the `questionary.constants` module, which specifies the default text styles applied when no custom style is provided.\"\"\"\n    'Print formatted text.\\n\\n    Sometimes you want to spice up your printed messages a bit,\\n    :meth:`questionary.print` is a helper to do just that.\\n\\n    Example:\\n\\n        >>> import questionary\\n        >>> questionary.print(\"Hello World \ud83e\udd84\", style=\"bold italic fg:darkred\")\\n        Hello World \ud83e\udd84\\n\\n    .. image:: ../images/print.gif\\n\\n    Args:\\n        text: Text to be printed.\\n        style: Style used for printing. The style argument uses the\\n            prompt :ref:`toolkit style strings <prompt_toolkit:styling>`.\\n    '\n    from prompt_toolkit import print_formatted_text as pt_print\n    from prompt_toolkit.formatted_text import FormattedText as FText\n    if style is not None:\n        text_style = Style([('text', style)])\n    else:\n        text_style = DEFAULT_STYLE\n    pt_print(FText([('class:text', text)]), style=text_style, **kwargs)",
        "docstring": "Print formatted text to the console with optional styling using the `prompt_toolkit` library.\n\nThis function enhances the visual presentation of printed messages by allowing the application of various styles, such as bold, italic, and color. The style argument utilizes the prompt toolkit's styling conventions and falls back to a default style if not provided.\n\nArgs:\n    text (str): The message to be printed in the console.\n    style (Optional[str]): A string specifying the styling to be applied. It utilizes the prompt toolkit-style strings for the desired visual effects. If None, the default style, defined as `DEFAULT_STYLE`, is used.\n    **kwargs: Additional keyword arguments passed to the formatting function.\n\nDependencies:\n    - Uses `print_formatted_text` from `prompt_toolkit` for actual text rendering.\n    - Uses `FormattedText` from `prompt_toolkit.formatted_text` to structure the text for printing.\n    - Relies on the `DEFAULT_STYLE` constant defined in the `questionary.constants` module, which specifies the default text styles applied when no custom style is provided.",
        "signature": "def print_formatted_text(text: str, style: Optional[str]=None, **kwargs: Any) -> None:",
        "type": "Function",
        "class_signature": null
      }
    },
    "questionary/utils.py": {
      "default_values_of": {
        "code": "def default_values_of(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return a list of parameter names from the given function `func` that have default values assigned.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be examined.\n\nReturns:\n- List[str]: A list containing the names of parameters that have a default value or are not of kind POSITIONAL_OR_KEYWORD.\n\nThis function utilizes the `inspect` module to analyze the function's signature, specifically its parameters. No constants or variables from outside the function are used directly in this function.\"\"\"\n    'Return all parameter names of ``func`` with a default value.'\n    signature = inspect.signature(func)\n    return [k for k, v in signature.parameters.items() if v.default is not inspect.Parameter.empty or v.kind != inspect.Parameter.POSITIONAL_OR_KEYWORD]",
        "docstring": "Return a list of parameter names from the given function `func` that have default values assigned.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be examined.\n\nReturns:\n- List[str]: A list containing the names of parameters that have a default value or are not of kind POSITIONAL_OR_KEYWORD.\n\nThis function utilizes the `inspect` module to analyze the function's signature, specifically its parameters. No constants or variables from outside the function are used directly in this function.",
        "signature": "def default_values_of(func: Callable[..., Any]) -> List[str]:",
        "type": "Function",
        "class_signature": null
      },
      "arguments_of": {
        "code": "def arguments_of(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return the parameter names of the function `func`.\n\nThis function takes a callable `func` as its argument and uses the `inspect` module to obtain the parameter names defined in the function's signature. It returns a list of these names, which can be useful for introspection and for dynamically generating function calls.\n\nParameters:\n- func (Callable[..., Any]): A callable object (e.g., a function) whose parameter names are to be retrieved.\n\nReturns:\n- List[str]: A list of parameter names as strings.\n\nDependencies:\n- The function relies on the `inspect` module to access function signatures.\"\"\"\n    'Return the parameter names of the function ``func``.'\n    return list(inspect.signature(func).parameters.keys())",
        "docstring": "Return the parameter names of the function `func`.\n\nThis function takes a callable `func` as its argument and uses the `inspect` module to obtain the parameter names defined in the function's signature. It returns a list of these names, which can be useful for introspection and for dynamically generating function calls.\n\nParameters:\n- func (Callable[..., Any]): A callable object (e.g., a function) whose parameter names are to be retrieved.\n\nReturns:\n- List[str]: A list of parameter names as strings.\n\nDependencies:\n- The function relies on the `inspect` module to access function signatures.",
        "signature": "def arguments_of(func: Callable[..., Any]) -> List[str]:",
        "type": "Function",
        "class_signature": null
      },
      "required_arguments": {
        "code": "def required_arguments(func: Callable[..., Any]) -> List[str]:\n    \"\"\"Return a list of parameter names for the given function ``func`` that do not have default values.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be analyzed.\n\nReturns:\n- List[str]: A list of the names of required parameters, i.e., those that must be provided in a function call as they lack default values.\n\nThis function relies on the `default_values_of` and `arguments_of` helper functions, which retrieve the parameters of the function and identify those with default values. It does not utilize any constants from the broader context.\"\"\"\n    'Return all arguments of a function that do not have a default value.'\n    defaults = default_values_of(func)\n    args = arguments_of(func)\n    if defaults:\n        args = args[:-len(defaults)]\n    return args",
        "docstring": "Return a list of parameter names for the given function ``func`` that do not have default values.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be analyzed.\n\nReturns:\n- List[str]: A list of the names of required parameters, i.e., those that must be provided in a function call as they lack default values.\n\nThis function relies on the `default_values_of` and `arguments_of` helper functions, which retrieve the parameters of the function and identify those with default values. It does not utilize any constants from the broader context.",
        "signature": "def required_arguments(func: Callable[..., Any]) -> List[str]:",
        "type": "Function",
        "class_signature": null
      },
      "missing_arguments": {
        "code": "def missing_arguments(func: Callable[..., Any], argdict: Dict[str, Any]) -> Set[str]:\n    \"\"\"Return a set of argument names that are required by the specified function `func` but are missing from the provided dictionary `argdict`.\n\nParameters:\n- func (Callable[..., Any]): The function whose required arguments are to be checked.\n- argdict (Dict[str, Any]): A dictionary of argument names and their corresponding values.\n\nReturns:\n- Set[str]: A set containing the names of the required arguments that are not present in `argdict`.\n\nThis function relies on the `required_arguments` function to determine which arguments are mandatory for `func`. It computes the difference between the required arguments of `func` and the keys of `argdict` to identify any missing arguments.\"\"\"\n    'Return all arguments that are missing to call func.'\n    return set(required_arguments(func)) - set(argdict.keys())",
        "docstring": "Return a set of argument names that are required by the specified function `func` but are missing from the provided dictionary `argdict`.\n\nParameters:\n- func (Callable[..., Any]): The function whose required arguments are to be checked.\n- argdict (Dict[str, Any]): A dictionary of argument names and their corresponding values.\n\nReturns:\n- Set[str]: A set containing the names of the required arguments that are not present in `argdict`.\n\nThis function relies on the `required_arguments` function to determine which arguments are mandatory for `func`. It computes the difference between the required arguments of `func` and the keys of `argdict` to identify any missing arguments.",
        "signature": "def missing_arguments(func: Callable[..., Any], argdict: Dict[str, Any]) -> Set[str]:",
        "type": "Function",
        "class_signature": null
      }
    },
    "questionary/prompts/__init__.py": {
      "prompt_by_name": {
        "code": "def prompt_by_name(name):\n    \"\"\"Retrieve a prompt function by its name.\n\nParameters:\n- name (str): The name of the prompt to retrieve, which should match one of the keys defined in the AVAILABLE_PROMPTS constant.\n\nReturns:\n- function: The corresponding prompt function from the AVAILABLE_PROMPTS dictionary, or None if the name is not found.\n\nDependencies:\n- The function relies on the AVAILABLE_PROMPTS constant defined at the module level, which maps string names to prompt functions from the Questionary library.\"\"\"\n    return AVAILABLE_PROMPTS.get(name)",
        "docstring": "Retrieve a prompt function by its name.\n\nParameters:\n- name (str): The name of the prompt to retrieve, which should match one of the keys defined in the AVAILABLE_PROMPTS constant.\n\nReturns:\n- function: The corresponding prompt function from the AVAILABLE_PROMPTS dictionary, or None if the name is not found.\n\nDependencies:\n- The function relies on the AVAILABLE_PROMPTS constant defined at the module level, which maps string names to prompt functions from the Questionary library.",
        "signature": "def prompt_by_name(name):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: questionary-test_prompt\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 questionary/\n    \u251c\u2500\u2500 prompt.py\n    \u2502   \u251c\u2500\u2500 PromptParameterException.__init__\n    \u2502   \u251c\u2500\u2500 prompt\n    \u2502   \u2514\u2500\u2500 unsafe_prompt\n    \u251c\u2500\u2500 prompts/\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 prompt_by_name\n    \u2502   \u2514\u2500\u2500 common.py\n    \u2502       \u2514\u2500\u2500 print_formatted_text\n    \u2514\u2500\u2500 utils.py\n        \u251c\u2500\u2500 arguments_of\n        \u251c\u2500\u2500 default_values_of\n        \u251c\u2500\u2500 missing_arguments\n        \u2514\u2500\u2500 required_arguments\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and test the behavior of functionality provided by the `questionary` library for handling user prompts, ensuring robust input handling and error management. Its primary purpose is to verify that prompts are correctly configured with required parameters such as message, type, and name, and to confirm that any misconfigurations raise appropriate exceptions. Additionally, it supports testing specialized prompt types, such as \"print,\" to ensure compatibility and expected output behavior in various scenarios. By automating these validations, the module helps developers identify configuration issues quickly and ensures the reliability of interactive user interfaces built with `questionary`.\n\n## FILE 1: questionary/prompt.py\n\n- FUNCTION NAME: prompt\n  - SIGNATURE: def prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, kbi_msg: str=DEFAULT_KBI_MESSAGE, **kwargs: Any) -> Dict[str, Any]:\n  - DOCSTRING: \n```python\n\"\"\"\nPrompts the user for input based on a series of defined questions, handling keyboard interrupts gracefully.\n\nThis function processes a list or dictionary of question configurations, each specifying the type and parameters of the prompt to be displayed. It catches `KeyboardInterrupt` exceptions to allow for custom handling using the `kbi_msg` parameter, which defaults to a predefined message in `DEFAULT_KBI_MESSAGE` from `questionary.constants`. The function internally calls `unsafe_prompt`, which executes the prompting logic without exception handling for interrupts.\n\nParameters:\n- questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A list or dictionary of question configurations that define what and how to prompt the user. Each configuration can specify options such as 'type', 'name', 'when', and 'filter'.\n- answers (Optional[Mapping[str, Any]]): An optional mapping of default answers to pre-fill the prompts.\n- patch_stdout (bool): Enables rendering adjustments in the prompt for compatibility with other threads' output.\n- true_color (bool): When set to true, uses true color output for the prompts.\n- kbi_msg (str): The message to be displayed on keyboard interrupts; defaults to `DEFAULT_KBI_MESSAGE`.\n- **kwargs (Any): Additional parameters that may be passed to each prompt, such as 'color_depth', 'type', 'filter', 'name', 'when', and 'default'.\n\nReturns:\n- Dict[str, Any]: A dictionary mapping question names to their respective user answers.\n\nThe function is designed for interaction in command-line interfaces and relies on methods and constants from the `questionary` module for its functionality.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - questionary/prompt.py:unsafe_prompt\n\n- CLASS METHOD: PromptParameterException.__init__\n  - CLASS SIGNATURE: class PromptParameterException(ValueError):\n  - SIGNATURE: def __init__(self, message: str, errors: Optional[BaseException]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a PromptParameterException with a message and optional errors.\n\nArgs:\n    message (str): A description of the missing parameter, which will be included in the exception message.\n    errors (Optional[BaseException], optional): An optional base exception that can be linked to this exception for additional context.\n\nRaises:\n    ValueError: This exception is specifically for indicating missing parameters in prompt configurations when constructing the prompt questions.\n\nThe generated message will indicate that a specific value is required, helping users identify the source of the error in the context of prompting for input.\n\"\"\"\n```\n\n- FUNCTION NAME: unsafe_prompt\n  - SIGNATURE: def unsafe_prompt(questions: Union[Dict[str, Any], Iterable[Mapping[str, Any]]], answers: Optional[Mapping[str, Any]]=None, patch_stdout: bool=False, true_color: bool=False, **kwargs: Any) -> Dict[str, Any]:\n  - DOCSTRING: \n```python\n\"\"\"\nPrompt the user for input on a series of questions without handling keyboard interrupts.\n\nArgs:\n    questions (Union[Dict[str, Any], Iterable[Mapping[str, Any]]]): A single question configuration or a collection of question configurations. Each configuration should specify at least a 'type' and optionally a 'name', 'when' callable, 'filter' callable, and other parameters relevant to specific question types.\n    \n    answers (Optional[Mapping[str, Any]]): A dictionary of default answers to pre-populate the prompts.\n    \n    patch_stdout (bool): If True, ensures that the prompt renders correctly when other threads are printing to stdout.\n    \n    true_color (bool): If True, enables true color output; otherwise, it defaults to a limited color set.\n    \n    **kwargs (Any): Additional options that may be relevant to specific question types (e.g., 'default', 'filter', 'when').\n\nReturns:\n    Dict[str, Any]: A dictionary containing the user's answers to the prompts.\n\nRaises:\n    PromptParameterException: If a required prompt parameter ('type' or 'name') is missing from a question configuration.\n    ValueError: If an invalid callable is provided for 'when' or 'filter', or if a question type is unknown.\n\nDependencies:\n    This function relies on `prompt_by_name` from the `questionary.prompts` module to generate question instances and `utils.missing_arguments` from the `questionary` module to check for missing arguments required by the question creation functions. Constants like `ColorDepth` from `prompt_toolkit.output` are used for managing color output.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - questionary/prompt.py:prompt\n    - questionary/prompts/common.py:print_formatted_text\n    - questionary/utils.py:missing_arguments\n    - questionary/prompt.py:PromptParameterException:__init__\n    - questionary/prompts/__init__.py:prompt_by_name\n\n## FILE 2: questionary/prompts/common.py\n\n- FUNCTION NAME: print_formatted_text\n  - SIGNATURE: def print_formatted_text(text: str, style: Optional[str]=None, **kwargs: Any) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nPrint formatted text to the console with optional styling using the `prompt_toolkit` library.\n\nThis function enhances the visual presentation of printed messages by allowing the application of various styles, such as bold, italic, and color. The style argument utilizes the prompt toolkit's styling conventions and falls back to a default style if not provided.\n\nArgs:\n    text (str): The message to be printed in the console.\n    style (Optional[str]): A string specifying the styling to be applied. It utilizes the prompt toolkit-style strings for the desired visual effects. If None, the default style, defined as `DEFAULT_STYLE`, is used.\n    **kwargs: Additional keyword arguments passed to the formatting function.\n\nDependencies:\n    - Uses `print_formatted_text` from `prompt_toolkit` for actual text rendering.\n    - Uses `FormattedText` from `prompt_toolkit.formatted_text` to structure the text for printing.\n    - Relies on the `DEFAULT_STYLE` constant defined in the `questionary.constants` module, which specifies the default text styles applied when no custom style is provided.\n\"\"\"\n```\n\n## FILE 3: questionary/utils.py\n\n- FUNCTION NAME: missing_arguments\n  - SIGNATURE: def missing_arguments(func: Callable[..., Any], argdict: Dict[str, Any]) -> Set[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a set of argument names that are required by the specified function `func` but are missing from the provided dictionary `argdict`.\n\nParameters:\n- func (Callable[..., Any]): The function whose required arguments are to be checked.\n- argdict (Dict[str, Any]): A dictionary of argument names and their corresponding values.\n\nReturns:\n- Set[str]: A set containing the names of the required arguments that are not present in `argdict`.\n\nThis function relies on the `required_arguments` function to determine which arguments are mandatory for `func`. It computes the difference between the required arguments of `func` and the keys of `argdict` to identify any missing arguments.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - questionary/utils.py:required_arguments\n\n- FUNCTION NAME: required_arguments\n  - SIGNATURE: def required_arguments(func: Callable[..., Any]) -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a list of parameter names for the given function ``func`` that do not have default values.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be analyzed.\n\nReturns:\n- List[str]: A list of the names of required parameters, i.e., those that must be provided in a function call as they lack default values.\n\nThis function relies on the `default_values_of` and `arguments_of` helper functions, which retrieve the parameters of the function and identify those with default values. It does not utilize any constants from the broader context.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - questionary/utils.py:arguments_of\n    - questionary/utils.py:default_values_of\n\n- FUNCTION NAME: arguments_of\n  - SIGNATURE: def arguments_of(func: Callable[..., Any]) -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn the parameter names of the function `func`.\n\nThis function takes a callable `func` as its argument and uses the `inspect` module to obtain the parameter names defined in the function's signature. It returns a list of these names, which can be useful for introspection and for dynamically generating function calls.\n\nParameters:\n- func (Callable[..., Any]): A callable object (e.g., a function) whose parameter names are to be retrieved.\n\nReturns:\n- List[str]: A list of parameter names as strings.\n\nDependencies:\n- The function relies on the `inspect` module to access function signatures.\n\"\"\"\n```\n\n- FUNCTION NAME: default_values_of\n  - SIGNATURE: def default_values_of(func: Callable[..., Any]) -> List[str]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a list of parameter names from the given function `func` that have default values assigned.\n\nParameters:\n- func (Callable[..., Any]): The function whose parameters are to be examined.\n\nReturns:\n- List[str]: A list containing the names of parameters that have a default value or are not of kind POSITIONAL_OR_KEYWORD.\n\nThis function utilizes the `inspect` module to analyze the function's signature, specifically its parameters. No constants or variables from outside the function are used directly in this function.\n\"\"\"\n```\n\n## FILE 4: questionary/prompts/__init__.py\n\n- FUNCTION NAME: prompt_by_name\n  - SIGNATURE: def prompt_by_name(name):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a prompt function by its name.\n\nParameters:\n- name (str): The name of the prompt to retrieve, which should match one of the keys defined in the AVAILABLE_PROMPTS constant.\n\nReturns:\n- function: The corresponding prompt function from the AVAILABLE_PROMPTS dictionary, or None if the name is not found.\n\nDependencies:\n- The function relies on the AVAILABLE_PROMPTS constant defined at the module level, which maps string names to prompt functions from the Questionary library.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "questionary/prompt.py": "from typing import Any\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Mapping\nfrom typing import Optional\nfrom typing import Union\nfrom prompt_toolkit.output import ColorDepth\nfrom questionary import utils\nfrom questionary.constants import DEFAULT_KBI_MESSAGE\nfrom questionary.prompts import AVAILABLE_PROMPTS\nfrom questionary.prompts import prompt_by_name\nfrom questionary.prompts.common import print_formatted_text\n\nclass PromptParameterException(ValueError):\n    \"\"\"Received a prompt with a missing parameter.\"\"\"",
    "questionary/prompts/common.py": "import inspect\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Optional\nfrom typing import Sequence\nfrom typing import Tuple\nfrom typing import Union\nfrom prompt_toolkit import PromptSession\nfrom prompt_toolkit.filters import Always\nfrom prompt_toolkit.filters import Condition\nfrom prompt_toolkit.filters import IsDone\nfrom prompt_toolkit.keys import Keys\nfrom prompt_toolkit.layout import ConditionalContainer\nfrom prompt_toolkit.layout import FormattedTextControl\nfrom prompt_toolkit.layout import HSplit\nfrom prompt_toolkit.layout import Layout\nfrom prompt_toolkit.layout import Window\nfrom prompt_toolkit.layout.dimension import LayoutDimension\nfrom prompt_toolkit.styles import Style\nfrom prompt_toolkit.validation import ValidationError\nfrom prompt_toolkit.validation import Validator\nfrom questionary.constants import DEFAULT_SELECTED_POINTER\nfrom questionary.constants import DEFAULT_STYLE\nfrom questionary.constants import INDICATOR_SELECTED\nfrom questionary.constants import INDICATOR_UNSELECTED\nfrom questionary.constants import INVALID_INPUT\nFormattedText = Union[str, List[Tuple[str, str]], List[Tuple[str, str, Callable[[Any], None]]], None]\n\nclass Choice:\n    \"\"\"One choice in a :meth:`select`, :meth:`rawselect` or :meth:`checkbox`.\n\n    Args:\n        title: Text shown in the selection list.\n\n        value: Value returned, when the choice is selected. If this argument\n               is `None` or unset, then the value of `title` is used.\n\n        disabled: If set, the choice can not be selected by the user. The\n                  provided text is used to explain, why the selection is\n                  disabled.\n\n        checked: Preselect this choice when displaying the options.\n\n        shortcut_key: Key shortcut used to select this item.\n\n        description: Optional description of the item that can be displayed.\n    \"\"\"\n    title: FormattedText\n    'Display string for the choice'\n    value: Optional[Any]\n    'Value of the choice'\n    disabled: Optional[str]\n    'Whether the choice can be selected'\n    checked: Optional[bool]\n    'Whether the choice is initially selected'\n    __shortcut_key: Optional[Union[str, bool]]\n    description: Optional[str]\n    'Choice description'\n\n    def __init__(self, title: FormattedText, value: Optional[Any]=None, disabled: Optional[str]=None, checked: Optional[bool]=False, shortcut_key: Optional[Union[str, bool]]=True, description: Optional[str]=None) -> None:\n        self.disabled = disabled\n        self.title = title\n        self.shortcut_key = shortcut_key\n        self.checked = checked if checked is not None else False\n        self.description = description\n        if value is not None:\n            self.value = value\n        elif isinstance(title, list):\n            self.value = ''.join([token[1] for token in title])\n        else:\n            self.value = title\n\n    @staticmethod\n    def build(c: Union[str, 'Choice', Dict[str, Any]]) -> 'Choice':\n        \"\"\"Create a choice object from different representations.\n\n        Args:\n            c: Either a :obj:`str`, :class:`Choice` or :obj:`dict` with\n               ``name``, ``value``, ``disabled``, ``checked`` and\n               ``key`` properties.\n\n        Returns:\n            An instance of the :class:`Choice` object.\n        \"\"\"\n        if isinstance(c, Choice):\n            return c\n        elif isinstance(c, str):\n            return Choice(c, c)\n        else:\n            return Choice(c.get('name'), c.get('value'), c.get('disabled', None), c.get('checked'), c.get('key'), c.get('description', None))\n\n    @property\n    def shortcut_key(self) -> Optional[Union[str, bool]]:\n        \"\"\"A shortcut key for the choice\"\"\"\n        return self.__shortcut_key\n\n    @shortcut_key.setter\n    def shortcut_key(self, key: Optional[Union[str, bool]]):\n        if key is not None:\n            if isinstance(key, bool):\n                self.__auto_shortcut = key\n                self.__shortcut_key = None\n            else:\n                self.__shortcut_key = str(key)\n                self.__auto_shortcut = False\n        else:\n            self.__shortcut_key = None\n            self.__auto_shortcut = True\n\n    @shortcut_key.deleter\n    def shortcut_key(self):\n        self.__shortcut_key = None\n        self.__auto_shortcut = True\n\n    def get_shortcut_title(self):\n        if self.shortcut_key is None:\n            return '-) '\n        else:\n            return '{}) '.format(self.shortcut_key)\n\n    @property\n    def auto_shortcut(self) -> bool:\n        \"\"\"Whether to assign a shortcut key to the choice\n\n        Keys are assigned starting with numbers and proceeding\n        through the ASCII alphabet.\n        \"\"\"\n        return self.__auto_shortcut\n\n    @auto_shortcut.setter\n    def auto_shortcut(self, should_assign: bool):\n        self.__auto_shortcut = should_assign\n        if self.__auto_shortcut:\n            self.__shortcut_key = None\n\n    @auto_shortcut.deleter\n    def auto_shortcut(self):\n        self.__auto_shortcut = False\n\nclass Separator(Choice):\n    \"\"\"Used to space/separate choices group.\"\"\"\n    default_separator: str = '-' * 15\n    'The default separator used if none is specified'\n    line: str\n    'The string being used as a separator'\n\n    def __init__(self, line: Optional[str]=None) -> None:\n        \"\"\"Create a separator in a list.\n\n        Args:\n            line: Text to be displayed in the list, by default uses ``---``.\n        \"\"\"\n        self.line = line or self.default_separator\n        super().__init__(self.line, None, '-')\n\nclass InquirerControl(FormattedTextControl):\n    SHORTCUT_KEYS = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    choices: List[Choice]\n    default: Optional[Union[str, Choice, Dict[str, Any]]]\n    selected_options: List[Any]\n    search_filter: Union[str, None] = None\n    use_indicator: bool\n    use_shortcuts: bool\n    use_arrow_keys: bool\n    pointer: Optional[str]\n    pointed_at: int\n    is_answered: bool\n    show_description: bool\n\n    def __init__(self, choices: Sequence[Union[str, Choice, Dict[str, Any]]], default: Optional[Union[str, Choice, Dict[str, Any]]]=None, pointer: Optional[str]=DEFAULT_SELECTED_POINTER, use_indicator: bool=True, use_shortcuts: bool=False, show_selected: bool=False, show_description: bool=True, use_arrow_keys: bool=True, initial_choice: Optional[Union[str, Choice, Dict[str, Any]]]=None, **kwargs: Any):\n        self.use_indicator = use_indicator\n        self.use_shortcuts = use_shortcuts\n        self.show_selected = show_selected\n        self.show_description = show_description\n        self.use_arrow_keys = use_arrow_keys\n        self.default = default\n        self.pointer = pointer\n        if isinstance(default, Choice):\n            default = default.value\n        choices_values = [choice.value for choice in choices if isinstance(choice, Choice)]\n        if default is not None and default not in choices and (default not in choices_values):\n            raise ValueError(f'Invalid `default` value passed. The value (`{default}`) does not exist in the set of choices. Please make sure the default value is one of the available choices.')\n        if initial_choice is None:\n            pointed_at = None\n        elif initial_choice in choices:\n            pointed_at = choices.index(initial_choice)\n        elif initial_choice in choices_values:\n            for k, choice in enumerate(choices):\n                if isinstance(choice, Choice):\n                    if choice.value == initial_choice:\n                        pointed_at = k\n                        break\n        else:\n            raise ValueError(f'Invalid `initial_choice` value passed. The value (`{initial_choice}`) does not exist in the set of choices. Please make sure the initial value is one of the available choices.')\n        self.is_answered = False\n        self.choices = []\n        self.submission_attempted = False\n        self.error_message = None\n        self.selected_options = []\n        self.found_in_search = False\n        self._init_choices(choices, pointed_at)\n        self._assign_shortcut_keys()\n        super().__init__(self._get_choice_tokens, **kwargs)\n        if not self.is_selection_valid():\n            raise ValueError(f\"Invalid 'initial_choice' value ('{initial_choice}'). It must be a selectable value.\")\n\n    def _is_selected(self, choice: Choice):\n        if isinstance(self.default, Choice):\n            compare_default = self.default == choice\n        else:\n            compare_default = self.default == choice.value\n        return choice.checked or (compare_default and self.default is not None)\n\n    def _assign_shortcut_keys(self):\n        available_shortcuts = self.SHORTCUT_KEYS[:]\n        for c in self.choices:\n            if c.shortcut_key is not None:\n                if c.shortcut_key in available_shortcuts:\n                    available_shortcuts.remove(c.shortcut_key)\n                else:\n                    raise ValueError(\"Invalid shortcut '{}'for choice '{}'. Shortcuts should be single characters or numbers. Make sure that all your shortcuts are unique.\".format(c.shortcut_key, c.title))\n        shortcut_idx = 0\n        for c in self.choices:\n            if c.auto_shortcut and (not c.disabled):\n                c.shortcut_key = available_shortcuts[shortcut_idx]\n                shortcut_idx += 1\n            if shortcut_idx == len(available_shortcuts):\n                break\n\n    def _init_choices(self, choices: Sequence[Union[str, Choice, Dict[str, Any]]], pointed_at: Optional[int]):\n        self.choices = []\n        if pointed_at is not None:\n            self.pointed_at = pointed_at\n        for i, c in enumerate(choices):\n            choice = Choice.build(c)\n            if self._is_selected(choice):\n                self.selected_options.append(choice.value)\n            if pointed_at is None and (not choice.disabled):\n                self.pointed_at = pointed_at = i\n            self.choices.append(choice)\n\n    @property\n    def filtered_choices(self):\n        if not self.search_filter:\n            return self.choices\n        filtered = [c for c in self.choices if self.search_filter.lower() in c.title.lower()]\n        self.found_in_search = len(filtered) > 0\n        return filtered if self.found_in_search else self.choices\n\n    @property\n    def choice_count(self) -> int:\n        return len(self.filtered_choices)\n\n    def _get_choice_tokens(self):\n        tokens = []\n\n        def append(index: int, choice: Choice):\n            selected = choice.value in self.selected_options\n            if index == self.pointed_at:\n                if self.pointer is not None:\n                    tokens.append(('class:pointer', ' {} '.format(self.pointer)))\n                else:\n                    tokens.append(('class:text', ' ' * 3))\n                tokens.append(('[SetCursorPosition]', ''))\n            else:\n                pointer_length = len(self.pointer) if self.pointer is not None else 1\n                tokens.append(('class:text', ' ' * (2 + pointer_length)))\n            if isinstance(choice, Separator):\n                tokens.append(('class:separator', '{}'.format(choice.title)))\n            elif choice.disabled:\n                if isinstance(choice.title, list):\n                    tokens.append(('class:selected' if selected else 'class:disabled', '- '))\n                    tokens.extend(choice.title)\n                else:\n                    tokens.append(('class:selected' if selected else 'class:disabled', '- {}'.format(choice.title)))\n                tokens.append(('class:selected' if selected else 'class:disabled', '{}'.format('' if isinstance(choice.disabled, bool) else ' ({})'.format(choice.disabled))))\n            else:\n                shortcut = choice.get_shortcut_title() if self.use_shortcuts else ''\n                if selected:\n                    if self.use_indicator:\n                        indicator = INDICATOR_SELECTED + ' '\n                    else:\n                        indicator = ''\n                    tokens.append(('class:selected', '{}'.format(indicator)))\n                else:\n                    if self.use_indicator:\n                        indicator = INDICATOR_UNSELECTED + ' '\n                    else:\n                        indicator = ''\n                    tokens.append(('class:text', '{}'.format(indicator)))\n                if isinstance(choice.title, list):\n                    tokens.extend(choice.title)\n                elif selected:\n                    tokens.append(('class:selected', '{}{}'.format(shortcut, choice.title)))\n                elif index == self.pointed_at:\n                    tokens.append(('class:highlighted', '{}{}'.format(shortcut, choice.title)))\n                else:\n                    tokens.append(('class:text', '{}{}'.format(shortcut, choice.title)))\n            tokens.append(('', '\\n'))\n        for i, c in enumerate(self.filtered_choices):\n            append(i, c)\n        current = self.get_pointed_at()\n        if self.show_selected:\n            answer = current.get_shortcut_title() if self.use_shortcuts else ''\n            answer += current.title if isinstance(current.title, str) else current.title[0][1]\n            tokens.append(('class:text', '  Answer: {}'.format(answer)))\n        show_description = self.show_description and current.description is not None\n        if show_description:\n            tokens.append(('class:text', '  Description: {}'.format(current.description)))\n        if not (self.show_selected or show_description):\n            tokens.pop()\n        return tokens\n\n    def is_selection_a_separator(self) -> bool:\n        selected = self.choices[self.pointed_at]\n        return isinstance(selected, Separator)\n\n    def is_selection_disabled(self) -> Optional[str]:\n        return self.choices[self.pointed_at].disabled\n\n    def is_selection_valid(self) -> bool:\n        return not self.is_selection_disabled() and (not self.is_selection_a_separator())\n\n    def select_previous(self) -> None:\n        self.pointed_at = (self.pointed_at - 1) % self.choice_count\n\n    def select_next(self) -> None:\n        self.pointed_at = (self.pointed_at + 1) % self.choice_count\n\n    def get_pointed_at(self) -> Choice:\n        return self.filtered_choices[self.pointed_at]\n\n    def get_selected_values(self) -> List[Choice]:\n        return [c for c in self.choices if not isinstance(c, Separator) and c.value in self.selected_options]\n\n    def add_search_character(self, char: Keys) -> None:\n        \"\"\"Adds a character to the search filter\"\"\"\n        if char == Keys.Backspace:\n            self.remove_search_character()\n        elif self.search_filter is None:\n            self.search_filter = str(char)\n        else:\n            self.search_filter += str(char)\n        self.pointed_at = 0\n\n    def remove_search_character(self) -> None:\n        if self.search_filter and len(self.search_filter) > 1:\n            self.search_filter = self.search_filter[:-1]\n        else:\n            self.search_filter = None\n\n    def get_search_string_tokens(self):\n        if self.search_filter is None:\n            return None\n        return [('', '\\n'), ('class:question-mark', '/ '), ('class:search_success' if self.found_in_search else 'class:search_none', self.search_filter), ('class:question-mark', '...')]\n\ndef build_validator(validate: Any) -> Optional[Validator]:\n    if validate:\n        if inspect.isclass(validate) and issubclass(validate, Validator):\n            return validate()\n        elif isinstance(validate, Validator):\n            return validate\n        elif callable(validate):\n\n            class _InputValidator(Validator):\n\n                def validate(self, document):\n                    verdict = validate(document.text)\n                    if verdict is not True:\n                        if verdict is False:\n                            verdict = INVALID_INPUT\n                        raise ValidationError(message=verdict, cursor_position=len(document.text))\n            return _InputValidator()\n    return None\n\ndef _fix_unecessary_blank_lines(ps: PromptSession) -> None:\n    \"\"\"This is a fix for additional empty lines added by prompt toolkit.\n\n    This assumes the layout of the default session doesn't change, if it\n    does, this needs an update.\"\"\"\n    default_container = ps.layout.container\n    default_buffer_window = default_container.get_children()[0].content.get_children()[1].content\n    assert isinstance(default_buffer_window, Window)\n    default_buffer_window.dont_extend_height = Always()\n    default_buffer_window.always_hide_cursor = Always()\n\ndef create_inquirer_layout(ic: InquirerControl, get_prompt_tokens: Callable[[], List[Tuple[str, str]]], **kwargs: Any) -> Layout:\n    \"\"\"Create a layout combining question and inquirer selection.\"\"\"\n    ps: PromptSession = PromptSession(get_prompt_tokens, reserve_space_for_menu=0, **kwargs)\n    _fix_unecessary_blank_lines(ps)\n\n    @Condition\n    def has_search_string():\n        return ic.get_search_string_tokens() is not None\n    validation_prompt: PromptSession = PromptSession(bottom_toolbar=lambda: ic.error_message, **kwargs)\n    return Layout(HSplit([ps.layout.container, ConditionalContainer(Window(ic), filter=~IsDone()), ConditionalContainer(Window(height=LayoutDimension.exact(2), content=FormattedTextControl(ic.get_search_string_tokens)), filter=has_search_string & ~IsDone()), ConditionalContainer(validation_prompt.layout.container, filter=Condition(lambda: ic.error_message is not None))]))",
    "questionary/utils.py": "import inspect\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Dict\nfrom typing import List\nfrom typing import Set\nACTIVATED_ASYNC_MODE = False\n\ndef is_prompt_toolkit_3() -> bool:\n    from prompt_toolkit import __version__ as ptk_version\n    return ptk_version.startswith('3.')\n\ndef used_kwargs(kwargs: Dict[str, Any], func: Callable[..., Any]) -> Dict[str, Any]:\n    \"\"\"Returns only the kwargs which can be used by a function.\n\n    Args:\n        kwargs: All available kwargs.\n        func: The function which should be called.\n\n    Returns:\n        Subset of kwargs which are accepted by ``func``.\n    \"\"\"\n    possible_arguments = arguments_of(func)\n    return {k: v for k, v in kwargs.items() if k in possible_arguments}\n\nasync def activate_prompt_toolkit_async_mode() -> None:\n    \"\"\"Configure prompt toolkit to use the asyncio event loop.\n\n    Needs to be async, so we use the right event loop in py 3.5\"\"\"\n    global ACTIVATED_ASYNC_MODE\n    if not is_prompt_toolkit_3():\n        import prompt_toolkit as pt\n        pt.eventloop.use_asyncio_event_loop()\n    ACTIVATED_ASYNC_MODE = True",
    "questionary/prompts/__init__.py": "from questionary.prompts import autocomplete\nfrom questionary.prompts import checkbox\nfrom questionary.prompts import confirm\nfrom questionary.prompts import password\nfrom questionary.prompts import path\nfrom questionary.prompts import press_any_key_to_continue\nfrom questionary.prompts import rawselect\nfrom questionary.prompts import select\nfrom questionary.prompts import text\nAVAILABLE_PROMPTS = {'autocomplete': autocomplete.autocomplete, 'confirm': confirm.confirm, 'text': text.text, 'select': select.select, 'rawselect': rawselect.rawselect, 'password': password.password, 'checkbox': checkbox.checkbox, 'path': path.path, 'press_any_key_to_continue': press_any_key_to_continue.press_any_key_to_continue, 'list': select.select, 'rawlist': rawselect.rawselect, 'input': text.text}"
  },
  "call_tree": {
    "modified_testcases/test_prompt.py:TestPrompt:test_invalid_question_type": {
      "questionary/prompt.py:prompt": {
        "questionary/prompt.py:unsafe_prompt": {
          "questionary/prompts/__init__.py:prompt_by_name": {}
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_missing_message": {
      "questionary/prompt.py:prompt": {
        "questionary/prompt.py:unsafe_prompt": {
          "questionary/prompts/__init__.py:prompt_by_name": {},
          "questionary/utils.py:missing_arguments": {
            "questionary/utils.py:required_arguments": {
              "questionary/utils.py:default_values_of": {},
              "questionary/utils.py:arguments_of": {}
            }
          },
          "questionary/prompt.py:PromptParameterException:__init__": {}
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_missing_name": {
      "questionary/prompt.py:prompt": {
        "questionary/prompt.py:unsafe_prompt": {
          "questionary/prompt.py:PromptParameterException:__init__": {}
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_missing_print_message": {
      "questionary/prompt.py:prompt": {
        "questionary/prompt.py:unsafe_prompt": {
          "questionary/prompt.py:PromptParameterException:__init__": {}
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_missing_type": {
      "questionary/prompt.py:prompt": {
        "questionary/prompt.py:unsafe_prompt": {
          "questionary/prompt.py:PromptParameterException:__init__": {}
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_print_no_name": {
      "tests/utils.py:patched_prompt": {
        "tests/utils.py:execute_with_input_pipe": {
          "tests/utils.py:run": {
            "questionary/prompt.py:prompt": {
              "questionary/prompt.py:unsafe_prompt": {
                "questionary/prompts/common.py:print_formatted_text": {}
              }
            }
          }
        }
      }
    },
    "modified_testcases/test_prompt.py:TestPrompt:test_print_with_name": {
      "tests/utils.py:patched_prompt": {
        "tests/utils.py:execute_with_input_pipe": {
          "tests/utils.py:run": {
            "questionary/prompt.py:prompt": {
              "questionary/prompt.py:unsafe_prompt": {
                "questionary/prompts/common.py:print_formatted_text": {}
              }
            }
          }
        }
      }
    }
  }
}