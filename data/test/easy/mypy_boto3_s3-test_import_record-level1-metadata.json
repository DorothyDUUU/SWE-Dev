{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_record",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_record.py",
  "test_code": "from mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportRecord:\n    def test_str(self) -> None:\n        source = ImportString(\"source\")\n        assert str(ImportRecord(source, \"name\", \"alias\")) == \"from source import name as alias\"\n        assert str(ImportRecord(source, alias=\"alias\")) == \"import source as alias\"\n        assert str(ImportRecord(source, \"name\")) == \"from source import name\"\n        assert str(ImportRecord(source)) == \"import source\"\n\n    def test_operations(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source, \"name\", \"alias\")\n        assert hash(ImportRecord(source, \"name\")) == hash(ImportRecord(source, \"name\"))\n        assert hash(ImportRecord(source, \"name\")) != hash(ImportRecord(source, \"name2\"))\n        assert ImportRecord(source, \"name\") == ImportRecord(source, \"name\")\n        assert ImportRecord(source, \"name\") != ImportRecord(source, \"name2\")\n        assert ImportRecord(source, \"name\") != \"test\"\n\n    def test_comparison(self) -> None:\n        local_source = ImportString(\"mypy_boto3_s3\")\n        third_party_source = ImportString(\"boto3\")\n        other_source = ImportString(\"other\")\n        assert ImportRecord(local_source, \"test\") > ImportRecord(local_source, \"name\")\n        assert ImportRecord(third_party_source, \"test\") < ImportRecord(local_source, \"name\")\n        assert ImportRecord(other_source, \"test\") < ImportRecord(third_party_source, \"name\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(third_party_source, \"test\")\n        assert ImportRecord(local_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(third_party_source, \"name\") > ImportRecord(other_source, \"test\")\n        assert ImportRecord(ImportString(\"zzz\")) > ImportRecord(ImportString(\"aaa\"))\n        assert ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n        ) > ImportRecord(local_source, \"name\")\n        assert not (\n            ImportRecord(local_source, \"name\")\n            > ImportRecord(local_source, \"test\", fallback=ImportRecord(local_source, \"test2\"))\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            third_party_source,\n            \"test\",\n            fallback=ImportRecord(third_party_source, \"test2\"),\n        )\n        assert ImportRecord(\n            local_source,\n            \"name\",\n            fallback=ImportRecord(local_source, \"name2\"),\n            min_version=(3, 9),\n        ) > ImportRecord(\n            local_source,\n            \"test\",\n            fallback=ImportRecord(local_source, \"test2\"),\n            min_version=(2, 11),\n        )\n\n    def test_get_local_name(self) -> None:\n        source = ImportString(\"source\")\n        assert ImportRecord(source).get_local_name() == \"source\"\n        assert ImportRecord(source, \"name\").get_local_name() == \"name\"\n        assert ImportRecord(source, \"name\", \"alias\").get_local_name() == \"alias\"\n        assert ImportRecord(source, alias=\"alias\").get_local_name() == \"alias\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initializes an instance of the ImportString class, which is a wrapper for Python import strings.\n\nParameters:\n- parent (str): The primary module name. Must be non-empty.\n- *parts (str): Additional parts of the import string. These must not include a '.' character. Ensure no non-empty part follows an empty part.\n\nRaises:\n- StructureError: If both parent and parts are empty, if any part contains a '.', or if there are empty parts following non-empty parts in the import structure.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing all non-empty parts of the import string for further processing. This is finalized as a tuple to prevent modification after initialization.\n\nDependencies:\n- StructureError: Imported from mypy_boto3_builder.exceptions to handle initialization errors related to the structure of the import string.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initializes an instance of the ImportString class, which is a wrapper for Python import strings.\n\nParameters:\n- parent (str): The primary module name. Must be non-empty.\n- *parts (str): Additional parts of the import string. These must not include a '.' character. Ensure no non-empty part follows an empty part.\n\nRaises:\n- StructureError: If both parent and parts are empty, if any part contains a '.', or if there are empty parts following non-empty parts in the import structure.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing all non-empty parts of the import string for further processing. This is finalized as a tuple to prevent modification after initialization.\n\nDependencies:\n- StructureError: Imported from mypy_boto3_builder.exceptions to handle initialization errors related to the structure of the import string.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        \"\"\"Initialize an ImportRecord object to represent a Python import statement.\n\nParameters:\n- source (ImportString): The source module or package from which to import.\n- name (str, optional): The specific name of the item being imported. Defaults to an empty string.\n- alias (str, optional): A local alias for the imported item. Defaults to an empty string.\n- min_version (tuple[int, ...], optional): The minimum Python version required for the import, used for compatibility checks. Defaults to None.\n- fallback (Self, optional): An alternative ImportRecord to use if the primary import fails or is not supported, allowing for graceful handling of compatibility issues. Defaults to None.\n\nThis constructor sets up the ImportRecord with its attributes, facilitating rendering of import statements and comparisons between different import records. It communicates with the `ImportString` type for the source and utilizes the StructureError exception to signal issues related to missing names in imports.\"\"\"\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback",
        "docstring": "Initialize an ImportRecord object to represent a Python import statement.\n\nParameters:\n- source (ImportString): The source module or package from which to import.\n- name (str, optional): The specific name of the item being imported. Defaults to an empty string.\n- alias (str, optional): A local alias for the imported item. Defaults to an empty string.\n- min_version (tuple[int, ...], optional): The minimum Python version required for the import, used for compatibility checks. Defaults to None.\n- fallback (Self, optional): An alternative ImportRecord to use if the primary import fails or is not supported, allowing for graceful handling of compatibility issues. Defaults to None.\n\nThis constructor sets up the ImportRecord with its attributes, facilitating rendering of import statements and comparisons between different import records. It communicates with the `ImportString` type for the source and utilizes the StructureError exception to signal issues related to missing names in imports.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Render the ImportRecord instance as a valid Python import statement. \n\nThis method overrides the built-in string representation method (`__str__`) to provide a formatted string output that reflects how the import would be structured in Python code, utilizing the `render()` method of the class. The output depends on the attributes `source`, `name`, and `alias` of the instance, ensuring that a correct import statement is generated based on the provided values. This method does not take any parameters and returns a string representation of the import statement.\n\nDependencies:\n- Relies on the `render()` method to construct the import statement.\n- The `source` attribute, which is an instance of `ImportString`, defines the module or package from which the import is made.\n\nExpected Output:\n- A string formatted as a valid import statement, which may vary based on the `source`, `name`, and `alias` attributes of the ImportRecord instance.\"\"\"\n        '\\n        Render as a valid Python import statement.\\n        '\n        return self.render()",
        "docstring": "Render the ImportRecord instance as a valid Python import statement. \n\nThis method overrides the built-in string representation method (`__str__`) to provide a formatted string output that reflects how the import would be structured in Python code, utilizing the `render()` method of the class. The output depends on the attributes `source`, `name`, and `alias` of the instance, ensuring that a correct import statement is generated based on the provided values. This method does not take any parameters and returns a string representation of the import statement.\n\nDependencies:\n- Relies on the `render()` method to construct the import statement.\n- The `source` attribute, which is an instance of `ImportString`, defines the module or package from which the import is made.\n\nExpected Output:\n- A string formatted as a valid import statement, which may vary based on the `source`, `name`, and `alias` attributes of the ImportRecord instance.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the ImportRecord instance, which is derived from its attributes: `source`, `name`, `alias`, `min_version`, and `fallback`. This method returns an integer, which is the result of Python's built-in `hash()` function applied to a tuple of these attributes. The purpose of this hash is to facilitate the use of ImportRecord instances in hash-based collections, such as sets or as dictionary keys. No parameters are taken, and it interacts with the attributes already defined in the __init__ method of the ImportRecord class.\"\"\"\n        '\\n        Calculate hash value based on source, name and alias.\\n        '\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))",
        "docstring": "Calculate the hash value for the ImportRecord instance, which is derived from its attributes: `source`, `name`, `alias`, `min_version`, and `fallback`. This method returns an integer, which is the result of Python's built-in `hash()` function applied to a tuple of these attributes. The purpose of this hash is to facilitate the use of ImportRecord instances in hash-based collections, such as sets or as dictionary keys. No parameters are taken, and it interacts with the attributes already defined in the __init__ method of the ImportRecord class.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Checks for equality between two ImportRecord instances by comparing their rendered string representations.\n\nParameters:\n- other (object): The object to compare against. It should be an instance of ImportRecord for a valid comparison.\n\nReturns:\n- bool: True if both ImportRecord instances produce the same rendered string; otherwise, False.\n\nThis method relies on the __str__ method to obtain the rendered string representation of the ImportRecord. If the 'other' object is not an instance of ImportRecord, the method immediately returns False.\"\"\"\n        '\\n        Whether two import records produce the same render.\\n        '\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)",
        "docstring": "Checks for equality between two ImportRecord instances by comparing their rendered string representations.\n\nParameters:\n- other (object): The object to compare against. It should be an instance of ImportRecord for a valid comparison.\n\nReturns:\n- bool: True if both ImportRecord instances produce the same rendered string; otherwise, False.\n\nThis method relies on the __str__ method to obtain the rendered string representation of the ImportRecord. If the 'other' object is not an instance of ImportRecord, the method immediately returns False.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.__gt__": {
        "code": "    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"Compare two instances of ImportRecord for sorting purposes, emulating the logic used in the `isort` tool. The method evaluates records based on their minimum version requirements, fallback availability, source, and name, ordering them in a way that prioritizes compatibility. \n\nParameters:\n- other (Self): The ImportRecord instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the defined comparison criteria; otherwise, False.\n\nDependencies:\n- self.min_version: Represents the minimum Python version required for the import, defined in the class constructor. It is compared to determine sorting order.\n- self.fallback: Indicates if a fallback ImportRecord exists, impacting the comparison logic.\n- self.source: The import source (an instance of ImportString), which is used as a criterion for sorting.\n- self.name: The name associated with the import which also impacts the sorting if other criteria are equal.\"\"\"\n        '\\n        Compare two import records for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name",
        "docstring": "Compare two instances of ImportRecord for sorting purposes, emulating the logic used in the `isort` tool. The method evaluates records based on their minimum version requirements, fallback availability, source, and name, ordering them in a way that prioritizes compatibility. \n\nParameters:\n- other (Self): The ImportRecord instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the defined comparison criteria; otherwise, False.\n\nDependencies:\n- self.min_version: Represents the minimum Python version required for the import, defined in the class constructor. It is compared to determine sorting order.\n- self.fallback: Indicates if a fallback ImportRecord exists, impacting the comparison logic.\n- self.source: The import source (an instance of ImportString), which is used as a criterion for sorting.\n- self.name: The name associated with the import which also impacts the sorting if other criteria are equal.",
        "signature": "def __gt__(self: Self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      },
      "ImportRecord.get_local_name": {
        "code": "    def get_local_name(self) -> str:\n        \"\"\"Get the local name of the import.\n\nThis method returns the local name used for the import, prioritizing the `alias` attribute. If no alias is set, it falls back to the `name`. If both are absent, it retrieves the rendered representation from the `source` (an instance of `ImportString`) using its `render` method. \n\nReturns:\n    str: The local import name, which can be the alias, name, or source representation, depending on availability.\"\"\"\n        '\\n        Get local import name.\\n        '\n        return self.alias or self.name or self.source.render()",
        "docstring": "Get the local name of the import.\n\nThis method returns the local name used for the import, prioritizing the `alias` attribute. If no alias is set, it falls back to the `name`. If both are absent, it retrieves the rendered representation from the `source` (an instance of `ImportString`) using its `render` method. \n\nReturns:\n    str: The local import name, which can be the alias, name, or source representation, depending on availability.",
        "signature": "def get_local_name(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.render": {
          "code": "    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
          "docstring": "Get rendered string.",
          "signature": "def render(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__eq__": {
          "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
          "docstring": "Whether import strings produce the same render.",
          "signature": "def __eq__(self, other: object) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        },
        "ImportString.__gt__": {
          "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
          "docstring": "Compare import strings for sorting.\n\nEmulates `isort` logic.",
          "signature": "def __gt__(self, other: Self) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.render": {
          "code": "    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return '.'.join(self.parts)",
          "docstring": "Render to string.\n\nReturns:\n    Ready to use import string.",
          "signature": "def render(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    }
  },
  "call_tree": {
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord": {},
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__gt__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
                "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
              },
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
            }
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
          },
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
          }
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__eq__": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__str__": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
          }
        }
      }
    },
    "tests/import_helpers/test_import_record.py:TestImportRecord:test_get_local_name": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {},
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_record\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u251c\u2500\u2500 import_record.py\n        \u2502   \u251c\u2500\u2500 ImportRecord.__eq__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__gt__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__hash__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__init__\n        \u2502   \u251c\u2500\u2500 ImportRecord.__str__\n        \u2502   \u2514\u2500\u2500 ImportRecord.get_local_name\n        \u2514\u2500\u2500 import_string.py\n            \u2514\u2500\u2500 ImportString.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for managing and manipulating Python import statements in a structured and dynamic manner. It facilitates the representation, formatting, and comparison of import statements, supporting features such as setting aliases, defining fallback imports, and specifying minimum version constraints for compatibility. By enabling consistent handling of imports and resolving complexities related to naming and module dependencies, this module helps developers ensure clarity, correctness, and maintainability in codebases that rely on dynamic or extensive imports. It addresses a common need for programmatically handling imports in tools or frameworks that generate Python code, optimizing workflows by abstracting import management logic.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the ImportString class, which is a wrapper for Python import strings.\n\nParameters:\n- parent (str): The primary module name. Must be non-empty.\n- *parts (str): Additional parts of the import string. These must not include a '.' character. Ensure no non-empty part follows an empty part.\n\nRaises:\n- StructureError: If both parent and parts are empty, if any part contains a '.', or if there are empty parts following non-empty parts in the import structure.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing all non-empty parts of the import string for further processing. This is finalized as a tuple to prevent modification after initialization.\n\nDependencies:\n- StructureError: Imported from mypy_boto3_builder.exceptions to handle initialization errors related to the structure of the import string.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.__hash__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the ImportRecord instance, which is derived from its attributes: `source`, `name`, `alias`, `min_version`, and `fallback`. This method returns an integer, which is the result of Python's built-in `hash()` function applied to a tuple of these attributes. The purpose of this hash is to facilitate the use of ImportRecord instances in hash-based collections, such as sets or as dictionary keys. No parameters are taken, and it interacts with the attributes already defined in the __init__ method of the ImportRecord class.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.get_local_name\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def get_local_name(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local name of the import.\n\nThis method returns the local name used for the import, prioritizing the `alias` attribute. If no alias is set, it falls back to the `name`. If both are absent, it retrieves the rendered representation from the `source` (an instance of `ImportString`) using its `render` method. \n\nReturns:\n    str: The local import name, which can be the alias, name, or source representation, depending on availability.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__init__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportRecord object to represent a Python import statement.\n\nParameters:\n- source (ImportString): The source module or package from which to import.\n- name (str, optional): The specific name of the item being imported. Defaults to an empty string.\n- alias (str, optional): A local alias for the imported item. Defaults to an empty string.\n- min_version (tuple[int, ...], optional): The minimum Python version required for the import, used for compatibility checks. Defaults to None.\n- fallback (Self, optional): An alternative ImportRecord to use if the primary import fails or is not supported, allowing for graceful handling of compatibility issues. Defaults to None.\n\nThis constructor sets up the ImportRecord with its attributes, facilitating rendering of import statements and comparisons between different import records. It communicates with the `ImportString` type for the source and utilizes the StructureError exception to signal issues related to missing names in imports.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__gt__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __gt__(self: Self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two instances of ImportRecord for sorting purposes, emulating the logic used in the `isort` tool. The method evaluates records based on their minimum version requirements, fallback availability, source, and name, ordering them in a way that prioritizes compatibility. \n\nParameters:\n- other (Self): The ImportRecord instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the defined comparison criteria; otherwise, False.\n\nDependencies:\n- self.min_version: Represents the minimum Python version required for the import, defined in the class constructor. It is compared to determine sorting order.\n- self.fallback: Indicates if a fallback ImportRecord exists, impacting the comparison logic.\n- self.source: The import source (an instance of ImportString), which is used as a criterion for sorting.\n- self.name: The name associated with the import which also impacts the sorting if other criteria are equal.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__str__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the ImportRecord instance as a valid Python import statement. \n\nThis method overrides the built-in string representation method (`__str__`) to provide a formatted string output that reflects how the import would be structured in Python code, utilizing the `render()` method of the class. The output depends on the attributes `source`, `name`, and `alias` of the instance, ensuring that a correct import statement is generated based on the provided values. This method does not take any parameters and returns a string representation of the import statement.\n\nDependencies:\n- Relies on the `render()` method to construct the import statement.\n- The `source` attribute, which is an instance of `ImportString`, defines the module or package from which the import is made.\n\nExpected Output:\n- A string formatted as a valid import statement, which may vary based on the `source`, `name`, and `alias` attributes of the ImportRecord instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportRecord.__eq__\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two ImportRecord instances by comparing their rendered string representations.\n\nParameters:\n- other (object): The object to compare against. It should be an instance of ImportRecord for a valid comparison.\n\nReturns:\n- bool: True if both ImportRecord instances produce the same rendered string; otherwise, False.\n\nThis method relies on the __str__ method to obtain the rendered string representation of the ImportRecord. If the 'other' object is not an instance of ImportRecord, the method immediately returns False.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return '.'.join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)"
  }
}