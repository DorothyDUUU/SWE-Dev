{
  "dir_path": "/app/vulture",
  "package_name": "vulture",
  "sample_name": "vulture-test_conditions",
  "src_dir": "vulture/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_conditions.py",
  "test_code": "import ast\n\nfrom vulture import utils\n\nfrom . import check_unreachable\nfrom . import v\n\nassert v  # Silence pyflakes\n\n\ndef check_condition(code, result):\n    condition = ast.parse(code, mode=\"eval\").body\n    if result:\n        assert utils.condition_is_always_true(condition)\n    else:\n        assert utils.condition_is_always_false(condition)\n\n\ndef test_false():\n    check_condition(\"False\", False)\n    check_condition(\"None\", False)\n    check_condition(\"0\", False)\n\n\ndef test_empty():\n    check_condition(\"''\", False)\n    check_condition(\"[]\", False)\n    check_condition(\"{}\", False)\n\n\ndef test_true():\n    check_condition(\"True\", True)\n    check_condition(\"2\", True)\n    check_condition(\"'s'\", True)\n    check_condition(\"['foo', 'bar']\", True)\n    check_condition(\"{'a': 1, 'b': 2}\", True)\n\n\ndef test_complex_conditions():\n    conditions = [\n        (\"foo and False\", True, False),\n        (\"foo or False\", False, False),\n        (\"foo and True\", False, False),\n        (\"foo or True\", False, True),\n        (\"False and foo\", True, False),\n        (\"False and 1\", True, False),\n        (\"not False\", False, True),\n        (\"not True\", True, False),\n        (\"not foo\", False, False),\n        (\"foo and (False or [])\", True, False),\n        ('(foo and bar) or {\"a\": 1}', False, True),\n    ]\n    for condition, always_false, always_true in conditions:\n        condition = ast.parse(condition, mode=\"eval\").body\n        assert not (always_false and always_true)\n        assert utils.condition_is_always_false(condition) == always_false\n        assert utils.condition_is_always_true(condition) == always_true\n\n\ndef test_errors():\n    conditions = [\n        \"foo\",\n        '__name__ == \"__main__\"',\n        \"chr(-1)\",\n        'getattr(True, \"foo\")',\n        'hasattr(str, \"foo\")',\n        \"isinstance(True, True)\",\n        \"globals()\",\n        \"locals()\",\n        \"().__class__\",\n    ]\n    for condition in conditions:\n        condition = ast.parse(condition, mode=\"eval\").body\n        assert not utils.condition_is_always_false(condition)\n        assert not utils.condition_is_always_true(condition)\n\n\ndef test_while(v):\n    v.scan(\n        \"\"\"\\\nwhile False:\n    pass\n\"\"\"\n    )\n    check_unreachable(v, 1, 2, \"while\")\n\n\ndef test_while_nested(v):\n    v.scan(\n        \"\"\"\\\nwhile True:\n    while False:\n        pass\n\"\"\"\n    )\n    check_unreachable(v, 2, 2, \"while\")\n\n\ndef test_if_false(v):\n    v.scan(\n        \"\"\"\\\nif False:\n    pass\n\"\"\"\n    )\n    check_unreachable(v, 1, 2, \"if\")\n\n\ndef test_elif_false(v):\n    v.scan(\n        \"\"\"\\\nif bar():\n    pass\nelif False:\n    print(\"Unreachable\")\n\"\"\"\n    )\n    check_unreachable(v, 3, 2, \"if\")\n\n\ndef test_nested_if_statements_false(v):\n    v.scan(\n        \"\"\"\\\nif foo():\n    if bar():\n        pass\n    elif False:\n        print(\"Unreachable\")\n        pass\n    elif something():\n        print(\"Reachable\")\n    else:\n        pass\nelse:\n    pass\n\"\"\"\n    )\n    check_unreachable(v, 4, 3, \"if\")\n\n\ndef test_if_false_same_line(v):\n    v.scan(\n        \"\"\"\\\nif False: a = 1\nelse: c = 3\n\"\"\"\n    )\n    check_unreachable(v, 1, 1, \"if\")\n\n\ndef test_if_true(v):\n    v.scan(\n        \"\"\"\\\nif True:\n    a = 1\n    b = 2\nelse:\n    c = 3\n    d = 3\n\"\"\"\n    )\n    # For simplicity, we don't report the \"else\" line as dead code.\n    check_unreachable(v, 5, 2, \"else\")\n\n\ndef test_if_true_same_line(v):\n    v.scan(\n        \"\"\"\\\nif True:\n    a = 1\n    b = 2\nelse: c = 3\nd = 3\n\"\"\"\n    )\n    check_unreachable(v, 4, 1, \"else\")\n\n\ndef test_nested_if_statements_true(v):\n    v.scan(\n        \"\"\"\\\nif foo():\n    if bar():\n        pass\n    elif True:\n        if something():\n            pass\n        else:\n            pass\n    elif something_else():\n        print(\"foo\")\n    else:\n        print(\"bar\")\nelse:\n    pass\n\"\"\"\n    )\n    check_unreachable(v, 9, 4, \"else\")\n\n\ndef test_redundant_if(v):\n    v.scan(\n        \"\"\"\\\nif [5]:\n    pass\n\"\"\"\n    )\n    print(v.unreachable_code[0].size)\n    check_unreachable(v, 1, 2, \"if\")\n\n\ndef test_if_exp_true(v):\n    v.scan(\"foo if True else bar\")\n    check_unreachable(v, 1, 1, \"ternary\")\n\n\ndef test_if_exp_false(v):\n    v.scan(\"foo if False else bar\")\n    check_unreachable(v, 1, 1, \"ternary\")\n",
  "GT_file_code": {
    "vulture/core.py": "import ast\nfrom fnmatch import fnmatch, fnmatchcase\nfrom pathlib import Path\nimport pkgutil\nimport re\nimport string\nimport sys\nfrom typing import List\n\nfrom vulture import lines\nfrom vulture import noqa\nfrom vulture import utils\nfrom vulture.config import InputError, make_config\nfrom vulture.utils import ExitCode\n\n\nDEFAULT_CONFIDENCE = 60\n\nIGNORED_VARIABLE_NAMES = {\"object\", \"self\"}\nPYTEST_FUNCTION_NAMES = {\n    \"setup_module\",\n    \"teardown_module\",\n    \"setup_function\",\n    \"teardown_function\",\n}\nPYTEST_METHOD_NAMES = {\n    \"setup_class\",\n    \"teardown_class\",\n    \"setup_method\",\n    \"teardown_method\",\n}\n\nERROR_CODES = {\n    \"attribute\": \"V101\",\n    \"class\": \"V102\",\n    \"function\": \"V103\",\n    \"import\": \"V104\",\n    \"method\": \"V105\",\n    \"property\": \"V106\",\n    \"variable\": \"V107\",\n    \"unreachable_code\": \"V201\",\n}\n\n\ndef _get_unused_items(defined_items, used_names):\n    unused_items = [\n        item for item in set(defined_items) if item.name not in used_names\n    ]\n    unused_items.sort(key=lambda item: item.name.lower())\n    return unused_items\n\n\ndef _is_special_name(name):\n    return name.startswith(\"__\") and name.endswith(\"__\")\n\n\ndef _match(name, patterns, case=True):\n    func = fnmatchcase if case else fnmatch\n    return any(func(name, pattern) for pattern in patterns)\n\n\ndef _is_test_file(filename):\n    return _match(\n        filename.resolve(),\n        [\"*/test/*\", \"*/tests/*\", \"*/test*.py\", \"*[-_]test.py\"],\n        case=False,\n    )\n\n\ndef _assigns_special_variable__all__(node):\n    assert isinstance(node, ast.Assign)\n    return isinstance(node.value, (ast.List, ast.Tuple)) and any(\n        target.id == \"__all__\"\n        for target in node.targets\n        if isinstance(target, ast.Name)\n    )\n\n\ndef _ignore_class(filename, class_name):\n    return _is_test_file(filename) and \"Test\" in class_name\n\n\ndef _ignore_import(filename, import_name):\n    \"\"\"\n    Ignore star-imported names since we can't detect whether they are used.\n    Ignore imports from __init__.py files since they're commonly used to\n    collect objects from a package.\n    \"\"\"\n    return filename.name == \"__init__.py\" or import_name == \"*\"\n\n\ndef _ignore_function(filename, function_name):\n    return (\n        function_name in PYTEST_FUNCTION_NAMES\n        or function_name.startswith(\"test_\")\n    ) and _is_test_file(filename)\n\n\ndef _ignore_method(filename, method_name):\n    return _is_special_name(method_name) or (\n        (method_name in PYTEST_METHOD_NAMES or method_name.startswith(\"test_\"))\n        and _is_test_file(filename)\n    )\n\n\ndef _ignore_variable(filename, varname):\n    \"\"\"\n    Ignore _ (Python idiom), _x (pylint convention) and\n    __x__ (special variable or method), but not __x.\n    \"\"\"\n    return (\n        varname in IGNORED_VARIABLE_NAMES\n        or (varname.startswith(\"_\") and not varname.startswith(\"__\"))\n        or _is_special_name(varname)\n    )\n\n\nclass Item:\n    \"\"\"\n    Hold the name, type and location of defined code.\n    \"\"\"\n\n    __slots__ = (\n        \"name\",\n        \"typ\",\n        \"filename\",\n        \"first_lineno\",\n        \"last_lineno\",\n        \"message\",\n        \"confidence\",\n    )\n\n    def __init__(\n        self,\n        name,\n        typ,\n        filename,\n        first_lineno,\n        last_lineno,\n        message=\"\",\n        confidence=DEFAULT_CONFIDENCE,\n    ):\n        self.name: str = name\n        self.typ: str = typ\n        self.filename: Path = filename\n        self.first_lineno: int = first_lineno\n        self.last_lineno: int = last_lineno\n        self.message: str = message or f\"unused {typ} '{name}'\"\n        self.confidence: int = confidence\n\n    @property\n    def size(self):\n        assert self.last_lineno >= self.first_lineno\n        return self.last_lineno - self.first_lineno + 1\n\n    def get_report(self, add_size=False):\n        if add_size:\n            line_format = \"line\" if self.size == 1 else \"lines\"\n            size_report = f\", {self.size:d} {line_format}\"\n        else:\n            size_report = \"\"\n        return \"{}:{:d}: {} ({}% confidence{})\".format(\n            utils.format_path(self.filename),\n            self.first_lineno,\n            self.message,\n            self.confidence,\n            size_report,\n        )\n\n    def get_whitelist_string(self):\n        filename = utils.format_path(self.filename)\n        if self.typ == \"unreachable_code\":\n            return f\"# {self.message} ({filename}:{self.first_lineno})\"\n        else:\n            prefix = \"\"\n            if self.typ in [\"attribute\", \"method\", \"property\"]:\n                prefix = \"_.\"\n            return \"{}{}  # unused {} ({}:{:d})\".format(\n                prefix, self.name, self.typ, filename, self.first_lineno\n            )\n\n    def _tuple(self):\n        return (self.filename, self.first_lineno, self.name)\n\n    def __repr__(self):\n        return repr(self.name)\n\n    def __eq__(self, other):\n        return self._tuple() == other._tuple()\n\n    def __hash__(self):\n        return hash(self._tuple())\n\n\nclass Vulture(ast.NodeVisitor):\n    \"\"\"Find dead code.\"\"\"\n\n    def __init__(\n        self, verbose=False, ignore_names=None, ignore_decorators=None\n    ):\n        self.verbose = verbose\n\n        def get_list(typ):\n            return utils.LoggingList(typ, self.verbose)\n\n        self.defined_attrs = get_list(\"attribute\")\n        self.defined_classes = get_list(\"class\")\n        self.defined_funcs = get_list(\"function\")\n        self.defined_imports = get_list(\"import\")\n        self.defined_methods = get_list(\"method\")\n        self.defined_props = get_list(\"property\")\n        self.defined_vars = get_list(\"variable\")\n        self.unreachable_code = get_list(\"unreachable_code\")\n\n        self.used_names = utils.LoggingSet(\"name\", self.verbose)\n\n        self.ignore_names = ignore_names or []\n        self.ignore_decorators = ignore_decorators or []\n\n        self.filename = Path()\n        self.code = []\n        self.exit_code = ExitCode.NoDeadCode\n        self.noqa_lines = {}\n\n    def scan(self, code, filename=\"\"):\n        filename = Path(filename)\n        self.code = code.splitlines()\n        self.noqa_lines = noqa.parse_noqa(self.code)\n        self.filename = filename\n\n        def handle_syntax_error(e):\n            text = f' at \"{e.text.strip()}\"' if e.text else \"\"\n            self._log(\n                f\"{utils.format_path(filename)}:{e.lineno}: {e.msg}{text}\",\n                file=sys.stderr,\n                force=True,\n            )\n            self.exit_code = ExitCode.InvalidInput\n\n        try:\n            node = ast.parse(\n                code, filename=str(self.filename), type_comments=True\n            )\n        except SyntaxError as err:\n            handle_syntax_error(err)\n        except ValueError as err:\n            # ValueError is raised if source contains null bytes.\n            self._log(\n                f'{utils.format_path(filename)}: invalid source code \"{err}\"',\n                file=sys.stderr,\n                force=True,\n            )\n            self.exit_code = ExitCode.InvalidInput\n        else:\n            # When parsing type comments, visiting can throw SyntaxError.\n            try:\n                self.visit(node)\n            except SyntaxError as err:\n                handle_syntax_error(err)\n\n    def scavenge(self, paths, exclude=None):\n        def prepare_pattern(pattern):\n            if not any(char in pattern for char in \"*?[\"):\n                pattern = f\"*{pattern}*\"\n            return pattern\n\n        exclude = [prepare_pattern(pattern) for pattern in (exclude or [])]\n\n        def exclude_path(path):\n            return _match(path, exclude, case=False)\n\n        paths = [Path(path) for path in paths]\n\n        for module in utils.get_modules(paths):\n            if exclude_path(module):\n                self._log(\"Excluded:\", module)\n                continue\n\n            self._log(\"Scanning:\", module)\n            try:\n                module_string = utils.read_file(module)\n            except utils.VultureInputException as err:  # noqa: F841\n                self._log(\n                    f\"Error: Could not read file {module} - {err}\\n\"\n                    f\"Try to change the encoding to UTF-8.\",\n                    file=sys.stderr,\n                    force=True,\n                )\n                self.exit_code = ExitCode.InvalidInput\n            else:\n                self.scan(module_string, filename=module)\n\n        unique_imports = {item.name for item in self.defined_imports}\n        for import_name in unique_imports:\n            path = Path(\"whitelists\") / (import_name + \"_whitelist.py\")\n            if exclude_path(path):\n                self._log(\"Excluded whitelist:\", path)\n            else:\n                try:\n                    module_data = pkgutil.get_data(\"vulture\", str(path))\n                    self._log(\"Included whitelist:\", path)\n                except OSError:\n                    # Most imported modules don't have a whitelist.\n                    continue\n                assert module_data is not None\n                module_string = module_data.decode(\"utf-8\")\n                self.scan(module_string, filename=path)\n\n    def get_unused_code(\n        self, min_confidence=0, sort_by_size=False\n    ) -> List[Item]:\n        \"\"\"\n        Return ordered list of unused Item objects.\n        \"\"\"\n        if not 0 <= min_confidence <= 100:\n            raise ValueError(\"min_confidence must be between 0 and 100.\")\n\n        def by_name(item):\n            return (str(item.filename).lower(), item.first_lineno)\n\n        def by_size(item):\n            return (item.size,) + by_name(item)\n\n        unused_code = (\n            self.unused_attrs\n            + self.unused_classes\n            + self.unused_funcs\n            + self.unused_imports\n            + self.unused_methods\n            + self.unused_props\n            + self.unused_vars\n            + self.unreachable_code\n        )\n\n        confidently_unused = [\n            obj for obj in unused_code if obj.confidence >= min_confidence\n        ]\n\n        return sorted(\n            confidently_unused, key=by_size if sort_by_size else by_name\n        )\n\n    def report(\n        self, min_confidence=0, sort_by_size=False, make_whitelist=False\n    ):\n        \"\"\"\n        Print ordered list of Item objects to stdout.\n        \"\"\"\n        for item in self.get_unused_code(\n            min_confidence=min_confidence, sort_by_size=sort_by_size\n        ):\n            self._log(\n                item.get_whitelist_string()\n                if make_whitelist\n                else item.get_report(add_size=sort_by_size),\n                force=True,\n            )\n            self.exit_code = ExitCode.DeadCode\n        return self.exit_code\n\n    @property\n    def unused_classes(self):\n        return _get_unused_items(self.defined_classes, self.used_names)\n\n    @property\n    def unused_funcs(self):\n        return _get_unused_items(self.defined_funcs, self.used_names)\n\n    @property\n    def unused_imports(self):\n        return _get_unused_items(self.defined_imports, self.used_names)\n\n    @property\n    def unused_methods(self):\n        return _get_unused_items(self.defined_methods, self.used_names)\n\n    @property\n    def unused_props(self):\n        return _get_unused_items(self.defined_props, self.used_names)\n\n    @property\n    def unused_vars(self):\n        return _get_unused_items(self.defined_vars, self.used_names)\n\n    @property\n    def unused_attrs(self):\n        return _get_unused_items(self.defined_attrs, self.used_names)\n\n    def _log(self, *args, file=None, force=False):\n        if self.verbose or force:\n            file = file or sys.stdout\n            try:\n                print(*args, file=file)\n            except UnicodeEncodeError:\n                # Some terminals can't print Unicode symbols.\n                x = \" \".join(map(str, args))\n                print(x.encode(), file=file)\n\n    def _add_aliases(self, node):\n        \"\"\"\n        We delegate to this method instead of using visit_alias() to have\n        access to line numbers and to filter imports from __future__.\n        \"\"\"\n        assert isinstance(node, (ast.Import, ast.ImportFrom))\n        for name_and_alias in node.names:\n            # Store only top-level module name (\"os.path\" -> \"os\").\n            # We can't easily detect when \"os.path\" is used.\n            name = name_and_alias.name.partition(\".\")[0]\n            alias = name_and_alias.asname\n            self._define(\n                self.defined_imports,\n                alias or name,\n                node,\n                confidence=90,\n                ignore=_ignore_import,\n            )\n            if alias is not None:\n                self.used_names.add(name_and_alias.name)\n\n    def _handle_conditional_node(self, node, name):\n        if utils.condition_is_always_false(node.test):\n            self._define(\n                self.unreachable_code,\n                name,\n                node,\n                last_node=node.body\n                if isinstance(node, ast.IfExp)\n                else node.body[-1],\n                message=f\"unsatisfiable '{name}' condition\",\n                confidence=100,\n            )\n        elif utils.condition_is_always_true(node.test):\n            else_body = node.orelse\n            if name == \"ternary\":\n                self._define(\n                    self.unreachable_code,\n                    name,\n                    else_body,\n                    message=\"unreachable 'else' expression\",\n                    confidence=100,\n                )\n            elif else_body:\n                self._define(\n                    self.unreachable_code,\n                    \"else\",\n                    else_body[0],\n                    last_node=else_body[-1],\n                    message=\"unreachable 'else' block\",\n                    confidence=100,\n                )\n            elif name == \"if\":\n                # Redundant if-condition without else block.\n                self._define(\n                    self.unreachable_code,\n                    name,\n                    node,\n                    message=\"redundant if-condition\",\n                    confidence=100,\n                )\n\n    def _define(\n        self,\n        collection,\n        name,\n        first_node,\n        last_node=None,\n        message=\"\",\n        confidence=DEFAULT_CONFIDENCE,\n        ignore=None,\n    ):\n        def ignored(lineno):\n            return (\n                (ignore and ignore(self.filename, name))\n                or _match(name, self.ignore_names)\n                or noqa.ignore_line(self.noqa_lines, lineno, ERROR_CODES[typ])\n            )\n\n        last_node = last_node or first_node\n        typ = collection.typ\n        first_lineno = lines.get_first_line_number(first_node)\n\n        if ignored(first_lineno):\n            self._log(f'Ignoring {typ} \"{name}\"')\n        else:\n            collection.append(\n                Item(\n                    name,\n                    typ,\n                    self.filename,\n                    first_lineno,\n                    lines.get_last_line_number(last_node),\n                    message=message,\n                    confidence=confidence,\n                )\n            )\n\n    def _define_variable(self, name, node, confidence=DEFAULT_CONFIDENCE):\n        self._define(\n            self.defined_vars,\n            name,\n            node,\n            confidence=confidence,\n            ignore=_ignore_variable,\n        )\n\n    def visit_arg(self, node):\n        \"\"\"Function argument\"\"\"\n        self._define_variable(node.arg, node, confidence=100)\n\n    def visit_AsyncFunctionDef(self, node):\n        return self.visit_FunctionDef(node)\n\n    def visit_Attribute(self, node):\n        if isinstance(node.ctx, ast.Store):\n            self._define(self.defined_attrs, node.attr, node)\n        elif isinstance(node.ctx, ast.Load):\n            self.used_names.add(node.attr)\n\n    def visit_BinOp(self, node):\n        \"\"\"\n        Parse variable names in old format strings:\n\n        \"%(my_var)s\" % locals()\n        \"\"\"\n        if (\n            utils.is_ast_string(node.left)\n            and isinstance(node.op, ast.Mod)\n            and self._is_locals_call(node.right)\n        ):\n            self.used_names |= set(re.findall(r\"%\\((\\w+)\\)\", node.left.value))\n\n    def visit_Call(self, node):\n        # Count getattr/hasattr(x, \"some_attr\", ...) as usage of some_attr.\n        if isinstance(node.func, ast.Name) and (\n            (node.func.id == \"getattr\" and 2 <= len(node.args) <= 3)\n            or (node.func.id == \"hasattr\" and len(node.args) == 2)\n        ):\n            attr_name_arg = node.args[1]\n            if utils.is_ast_string(attr_name_arg):\n                self.used_names.add(attr_name_arg.value)\n\n        # Parse variable names in new format strings:\n        # \"{my_var}\".format(**locals())\n        if (\n            isinstance(node.func, ast.Attribute)\n            and utils.is_ast_string(node.func.value)\n            and node.func.attr == \"format\"\n            and any(\n                kw.arg is None and self._is_locals_call(kw.value)\n                for kw in node.keywords\n            )\n        ):\n            self._handle_new_format_string(node.func.value.value)\n\n    def _handle_new_format_string(self, s):\n        def is_identifier(name):\n            return bool(re.match(r\"[a-zA-Z_][a-zA-Z0-9_]*\", name))\n\n        parser = string.Formatter()\n        try:\n            names = [name for _, name, _, _ in parser.parse(s) if name]\n        except ValueError:\n            # Invalid format string.\n            names = []\n\n        for field_name in names:\n            # Remove brackets and their contents: \"a[0][b].c[d].e\" -> \"a.c.e\",\n            # then split the resulting string: \"a.b.c\" -> [\"a\", \"b\", \"c\"]\n            vars = re.sub(r\"\\[\\w*\\]\", \"\", field_name).split(\".\")\n            for var in vars:\n                if is_identifier(var):\n                    self.used_names.add(var)\n\n    @staticmethod\n    def _is_locals_call(node):\n        \"\"\"Return True if the node is `locals()`.\"\"\"\n        return (\n            isinstance(node, ast.Call)\n            and isinstance(node.func, ast.Name)\n            and node.func.id == \"locals\"\n            and not node.args\n            and not node.keywords\n        )\n\n    def visit_ClassDef(self, node):\n        for decorator in node.decorator_list:\n            if _match(\n                utils.get_decorator_name(decorator), self.ignore_decorators\n            ):\n                self._log(\n                    f'Ignoring class \"{node.name}\" (decorator whitelisted)'\n                )\n                break\n        else:\n            self._define(\n                self.defined_classes, node.name, node, ignore=_ignore_class\n            )\n\n    def visit_FunctionDef(self, node):\n        decorator_names = [\n            utils.get_decorator_name(decorator)\n            for decorator in node.decorator_list\n        ]\n\n        first_arg = node.args.args[0].arg if node.args.args else None\n\n        if \"@property\" in decorator_names:\n            typ = \"property\"\n        elif (\n            \"@staticmethod\" in decorator_names\n            or \"@classmethod\" in decorator_names\n            or first_arg == \"self\"\n        ):\n            typ = \"method\"\n        else:\n            typ = \"function\"\n\n        if any(\n            _match(name, self.ignore_decorators) for name in decorator_names\n        ):\n            self._log(f'Ignoring {typ} \"{node.name}\" (decorator whitelisted)')\n        elif typ == \"property\":\n            self._define(self.defined_props, node.name, node)\n        elif typ == \"method\":\n            self._define(\n                self.defined_methods, node.name, node, ignore=_ignore_method\n            )\n        else:\n            self._define(\n                self.defined_funcs, node.name, node, ignore=_ignore_function\n            )\n\n    def visit_If(self, node):\n        self._handle_conditional_node(node, \"if\")\n\n    def visit_IfExp(self, node):\n        self._handle_conditional_node(node, \"ternary\")\n\n    def visit_Import(self, node):\n        self._add_aliases(node)\n\n    def visit_ImportFrom(self, node):\n        if node.module != \"__future__\":\n            self._add_aliases(node)\n\n    def visit_Name(self, node):\n        if (\n            isinstance(node.ctx, (ast.Load, ast.Del))\n            and node.id not in IGNORED_VARIABLE_NAMES\n        ):\n            self.used_names.add(node.id)\n        elif isinstance(node.ctx, (ast.Param, ast.Store)):\n            self._define_variable(node.id, node)\n\n    def visit_Assign(self, node):\n        if _assigns_special_variable__all__(node):\n            assert isinstance(node.value, (ast.List, ast.Tuple))\n            for elt in node.value.elts:\n                if utils.is_ast_string(elt):\n                    self.used_names.add(elt.value)\n\n    def visit_While(self, node):\n        self._handle_conditional_node(node, \"while\")\n\n    def visit_MatchClass(self, node):\n        for kwd_attr in node.kwd_attrs:\n            self.used_names.add(kwd_attr)\n\n    def visit(self, node):\n        method = \"visit_\" + node.__class__.__name__\n        visitor = getattr(self, method, None)\n        if self.verbose:\n            lineno = getattr(node, \"lineno\", 1)\n            line = self.code[lineno - 1] if self.code else \"\"\n            self._log(lineno, ast.dump(node), line)\n        if visitor:\n            visitor(node)\n\n        # There isn't a clean subset of node types that might have type\n        # comments, so just check all of them.\n        type_comment = getattr(node, \"type_comment\", None)\n        if type_comment is not None:\n            mode = (\n                \"func_type\"\n                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef))\n                else \"eval\"\n            )\n            self.visit(\n                ast.parse(type_comment, filename=\"<type_comment>\", mode=mode)\n            )\n\n        return self.generic_visit(node)\n\n    def _handle_ast_list(self, ast_list):\n        \"\"\"\n        Find unreachable nodes in the given sequence of ast nodes.\n        \"\"\"\n        for index, node in enumerate(ast_list):\n            if isinstance(\n                node, (ast.Break, ast.Continue, ast.Raise, ast.Return)\n            ):\n                try:\n                    first_unreachable_node = ast_list[index + 1]\n                except IndexError:\n                    continue\n                class_name = node.__class__.__name__.lower()\n                self._define(\n                    self.unreachable_code,\n                    class_name,\n                    first_unreachable_node,\n                    last_node=ast_list[-1],\n                    message=f\"unreachable code after '{class_name}'\",\n                    confidence=100,\n                )\n                return\n\n    def generic_visit(self, node):\n        \"\"\"Called if no explicit visitor function exists for a node.\"\"\"\n        for _, value in ast.iter_fields(node):\n            if isinstance(value, list):\n                self._handle_ast_list(value)\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        self.visit(item)\n            elif isinstance(value, ast.AST):\n                self.visit(value)\n\n\ndef main():\n    try:\n        config = make_config()\n    except InputError as e:\n        print(e, file=sys.stderr)\n        sys.exit(ExitCode.InvalidCmdlineArguments)\n\n    vulture = Vulture(\n        verbose=config[\"verbose\"],\n        ignore_names=config[\"ignore_names\"],\n        ignore_decorators=config[\"ignore_decorators\"],\n    )\n    vulture.scavenge(config[\"paths\"], exclude=config[\"exclude\"])\n    sys.exit(\n        vulture.report(\n            min_confidence=config[\"min_confidence\"],\n            sort_by_size=config[\"sort_by_size\"],\n            make_whitelist=config[\"make_whitelist\"],\n        )\n    )\n",
    "vulture/utils.py": "import ast\nfrom enum import IntEnum\nimport pathlib\nimport sys\nimport tokenize\n\n\nclass VultureInputException(Exception):\n    pass\n\n\nclass ExitCode(IntEnum):\n    NoDeadCode = 0\n    InvalidInput = 1\n    InvalidCmdlineArguments = 2\n    DeadCode = 3\n\n\ndef _safe_eval(node, default):\n    \"\"\"\n    Safely evaluate the Boolean expression under the given AST node.\n\n    Substitute `default` for all sub-expressions that cannot be\n    evaluated (because variables or functions are undefined).\n\n    We could use eval() to evaluate more sub-expressions. However, this\n    function is not safe for arbitrary Python code. Even after\n    overwriting the \"__builtins__\" dictionary, the original dictionary\n    can be restored\n    (https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).\n\n    \"\"\"\n    if isinstance(node, ast.BoolOp):\n        results = [_safe_eval(value, default) for value in node.values]\n        if isinstance(node.op, ast.And):\n            return all(results)\n        else:\n            return any(results)\n    elif isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.Not):\n        return not _safe_eval(node.operand, not default)\n    else:\n        try:\n            return ast.literal_eval(node)\n        except ValueError:\n            return default\n\n\ndef condition_is_always_false(condition):\n    return not _safe_eval(condition, True)\n\n\ndef condition_is_always_true(condition):\n    return _safe_eval(condition, False)\n\n\ndef is_ast_string(node):\n    return isinstance(node, ast.Constant) and isinstance(node.value, str)\n\n\ndef format_path(path):\n    try:\n        return path.relative_to(pathlib.Path.cwd())\n    except ValueError:\n        # Path is not below the current directory.\n        return path\n\n\ndef get_decorator_name(decorator):\n    if isinstance(decorator, ast.Call):\n        decorator = decorator.func\n    try:\n        parts = []\n        while isinstance(decorator, ast.Attribute):\n            parts.append(decorator.attr)\n            decorator = decorator.value\n        parts.append(decorator.id)\n    except AttributeError:\n        parts = []\n    return \"@\" + \".\".join(reversed(parts))\n\n\ndef get_modules(paths):\n    \"\"\"Retrieve Python files to check.\n\n    Loop over all given paths, abort if any ends with .pyc, add the other given\n    files (even those not ending with .py) and collect all .py files under the\n    given directories.\n\n    \"\"\"\n    modules = []\n    for path in paths:\n        path = path.resolve()\n        if path.is_file():\n            if path.suffix == \".pyc\":\n                sys.exit(f\"Error: *.pyc files are not supported: {path}\")\n            else:\n                modules.append(path)\n        elif path.is_dir():\n            modules.extend(path.rglob(\"*.py\"))\n        else:\n            sys.exit(f\"Error: {path} could not be found.\")\n    return modules\n\n\ndef read_file(filename):\n    try:\n        # Use encoding detected by tokenize.detect_encoding().\n        with tokenize.open(filename) as f:\n            return f.read()\n    except (SyntaxError, UnicodeDecodeError) as err:\n        raise VultureInputException from err\n\n\nclass LoggingList(list):\n    def __init__(self, typ, verbose):\n        self.typ = typ\n        self._verbose = verbose\n        return super().__init__()\n\n    def append(self, item):\n        if self._verbose:\n            print(f'define {self.typ} \"{item.name}\"')\n        super().append(item)\n\n\nclass LoggingSet(set):\n    def __init__(self, typ, verbose):\n        self.typ = typ\n        self._verbose = verbose\n        return super().__init__()\n\n    def add(self, name):\n        if self._verbose:\n            print(f'use {self.typ} \"{name}\"')\n        super().add(name)\n",
    "modified_testcases/__init__.py": "import pathlib\nimport subprocess\nimport sys\n\nimport pytest\n\nfrom vulture import core\n\nREPO = pathlib.Path(__file__).resolve().parents[1]\nWHITELISTS = [\n    str(path)\n    for path in (REPO / \"vulture\" / \"whitelists\").glob(\"*.py\")\n    # Pint is incompatible with Python 3.13 (https://github.com/hgrecco/pint/issues/1969).\n    if sys.version_info < (3, 13) or path.name != \"pint_whitelist.py\"\n]\n\n\ndef call_vulture(args, **kwargs):\n    return subprocess.call(\n        [sys.executable, \"-m\", \"vulture\"] + args, cwd=REPO, **kwargs\n    )\n\n\ndef check(items_or_names, expected_names):\n    \"\"\"items_or_names must be a collection of Items or a set of strings.\"\"\"\n    try:\n        assert sorted(item.name for item in items_or_names) == sorted(\n            expected_names\n        )\n    except AttributeError:\n        assert items_or_names == set(expected_names)\n\n\ndef check_unreachable(v, lineno, size, name):\n    assert len(v.unreachable_code) == 1\n    item = v.unreachable_code[0]\n    assert item.first_lineno == lineno\n    assert item.size == size\n    assert item.name == name\n\n\n@pytest.fixture\ndef v():\n    return core.Vulture(verbose=True)\n"
  },
  "GT_src_dict": {
    "vulture/core.py": {
      "Item.size": {
        "code": "    def size(self):\n        \"\"\"Calculate the size of the code item in terms of the number of lines.\n\nThis property computes the size as the difference between the last and first line numbers, adding one to ensure the correct count of lines. It asserts that `last_lineno` is greater than or equal to `first_lineno` to prevent any logical errors in size computation. This size is relevant for reporting unused code and is utilized in the `get_report` method of the `Item` class.\n\nAttributes:\n- `first_lineno`: The line number where the code item starts, defined during initialization.\n- `last_lineno`: The line number where the code item ends, also defined during initialization.\"\"\"\n        assert self.last_lineno >= self.first_lineno\n        return self.last_lineno - self.first_lineno + 1",
        "docstring": "Calculate the size of the code item in terms of the number of lines.\n\nThis property computes the size as the difference between the last and first line numbers, adding one to ensure the correct count of lines. It asserts that `last_lineno` is greater than or equal to `first_lineno` to prevent any logical errors in size computation. This size is relevant for reporting unused code and is utilized in the `get_report` method of the `Item` class.\n\nAttributes:\n- `first_lineno`: The line number where the code item starts, defined during initialization.\n- `last_lineno`: The line number where the code item ends, also defined during initialization.",
        "signature": "def size(self):",
        "type": "Method",
        "class_signature": "class Item:"
      },
      "Vulture.__init__": {
        "code": "    def __init__(self, verbose=False, ignore_names=None, ignore_decorators=None):\n        \"\"\"Initialize a Vulture instance to analyze Python code for unused elements.\n\nParameters:\n- verbose (bool, optional): A flag to enable verbose logging. Defaults to False.\n- ignore_names (list of str, optional): A list of names to ignore during the analysis. Defaults to None.\n- ignore_decorators (list of str, optional): A list of decorators to ignore during the analysis. Defaults to None.\n\nAttributes:\n- defined_attrs (LoggingList): Tracks defined attributes in the analyzed code.\n- defined_classes (LoggingList): Tracks defined classes in the analyzed code.\n- defined_funcs (LoggingList): Tracks defined functions in the analyzed code.\n- defined_imports (LoggingList): Tracks defined imports in the analyzed code.\n- defined_methods (LoggingList): Tracks defined methods in the analyzed code.\n- defined_props (LoggingList): Tracks defined properties in the analyzed code.\n- defined_vars (LoggingList): Tracks defined variables in the analyzed code.\n- unreachable_code (LoggingList): Records unreachable code snippets.\n- used_names (LoggingSet): Keeps track of names that are used in the analyzed code.\n- filename (Path): Stores the current file path being analyzed.\n- code (list of str): Contains the lines of code from the current file.\n- exit_code (ExitCode): Holds the exit code for the analysis process, initialized to NoDeadCode.\n- noqa_lines (dict): Stores lines that are marked to be excluded from analysis.\n\nConstants used:\n- ExitCode: Provides different exit code statuses for the analysis outcome.\n- LoggingList and LoggingSet: Utility classes from the utils module that facilitate tracking and logging during analysis. Their verbosity is linked to the `verbose` parameter to control the amount of logging output.\"\"\"\n        self.verbose = verbose\n\n        def get_list(typ):\n            return utils.LoggingList(typ, self.verbose)\n        self.defined_attrs = get_list('attribute')\n        self.defined_classes = get_list('class')\n        self.defined_funcs = get_list('function')\n        self.defined_imports = get_list('import')\n        self.defined_methods = get_list('method')\n        self.defined_props = get_list('property')\n        self.defined_vars = get_list('variable')\n        self.unreachable_code = get_list('unreachable_code')\n        self.used_names = utils.LoggingSet('name', self.verbose)\n        self.ignore_names = ignore_names or []\n        self.ignore_decorators = ignore_decorators or []\n        self.filename = Path()\n        self.code = []\n        self.exit_code = ExitCode.NoDeadCode\n        self.noqa_lines = {}",
        "docstring": "Initialize a Vulture instance to analyze Python code for unused elements.\n\nParameters:\n- verbose (bool, optional): A flag to enable verbose logging. Defaults to False.\n- ignore_names (list of str, optional): A list of names to ignore during the analysis. Defaults to None.\n- ignore_decorators (list of str, optional): A list of decorators to ignore during the analysis. Defaults to None.\n\nAttributes:\n- defined_attrs (LoggingList): Tracks defined attributes in the analyzed code.\n- defined_classes (LoggingList): Tracks defined classes in the analyzed code.\n- defined_funcs (LoggingList): Tracks defined functions in the analyzed code.\n- defined_imports (LoggingList): Tracks defined imports in the analyzed code.\n- defined_methods (LoggingList): Tracks defined methods in the analyzed code.\n- defined_props (LoggingList): Tracks defined properties in the analyzed code.\n- defined_vars (LoggingList): Tracks defined variables in the analyzed code.\n- unreachable_code (LoggingList): Records unreachable code snippets.\n- used_names (LoggingSet): Keeps track of names that are used in the analyzed code.\n- filename (Path): Stores the current file path being analyzed.\n- code (list of str): Contains the lines of code from the current file.\n- exit_code (ExitCode): Holds the exit code for the analysis process, initialized to NoDeadCode.\n- noqa_lines (dict): Stores lines that are marked to be excluded from analysis.\n\nConstants used:\n- ExitCode: Provides different exit code statuses for the analysis outcome.\n- LoggingList and LoggingSet: Utility classes from the utils module that facilitate tracking and logging during analysis. Their verbosity is linked to the `verbose` parameter to control the amount of logging output.",
        "signature": "def __init__(self, verbose=False, ignore_names=None, ignore_decorators=None):",
        "type": "Method",
        "class_signature": "class Vulture(ast.NodeVisitor):"
      },
      "Vulture.scan": {
        "code": "    def scan(self, code, filename=''):\n        \"\"\"Scan the provided Python code for unused code elements and potential errors.\n\nParameters:\n- code (str): The source code to be scanned, provided as a string.\n- filename (str): The name of the file containing the code, defaulting to an empty string. This is used for logging and error reporting.\n\nThis method parses the provided source code into an Abstract Syntax Tree (AST) using the `ast.parse` function. It handles potential syntax errors gracefully by logging them with the relevant line number and error message. The method also processes `noqa` directives to determine lines of code that should be ignored during the scan. Additionally, if the scanning process encounters any `SyntaxError` while visiting nodes, it logs the error accordingly.\n\nDependencies:\n- Utilizes the `noqa` module for parsing ignore comments.\n- Makes use of utility functions from the `utils` module for formatting log messages and for handling errors.\n- Interacts with other methods of the Vulture class to analyze the scanned nodes to identify dead code.\n\nConstants:\n- `self.exit_code`: Updated in case of any errors during the parsing process, indicating the status of the scan operation defined in the ExitCode enumeration.\"\"\"\n        filename = Path(filename)\n        self.code = code.splitlines()\n        self.noqa_lines = noqa.parse_noqa(self.code)\n        self.filename = filename\n\n        def handle_syntax_error(e):\n            text = f' at \"{e.text.strip()}\"' if e.text else ''\n            self._log(f'{utils.format_path(filename)}:{e.lineno}: {e.msg}{text}', file=sys.stderr, force=True)\n            self.exit_code = ExitCode.InvalidInput\n        try:\n            node = ast.parse(code, filename=str(self.filename), type_comments=True)\n        except SyntaxError as err:\n            handle_syntax_error(err)\n        except ValueError as err:\n            self._log(f'{utils.format_path(filename)}: invalid source code \"{err}\"', file=sys.stderr, force=True)\n            self.exit_code = ExitCode.InvalidInput\n        else:\n            try:\n                self.visit(node)\n            except SyntaxError as err:\n                handle_syntax_error(err)",
        "docstring": "Scan the provided Python code for unused code elements and potential errors.\n\nParameters:\n- code (str): The source code to be scanned, provided as a string.\n- filename (str): The name of the file containing the code, defaulting to an empty string. This is used for logging and error reporting.\n\nThis method parses the provided source code into an Abstract Syntax Tree (AST) using the `ast.parse` function. It handles potential syntax errors gracefully by logging them with the relevant line number and error message. The method also processes `noqa` directives to determine lines of code that should be ignored during the scan. Additionally, if the scanning process encounters any `SyntaxError` while visiting nodes, it logs the error accordingly.\n\nDependencies:\n- Utilizes the `noqa` module for parsing ignore comments.\n- Makes use of utility functions from the `utils` module for formatting log messages and for handling errors.\n- Interacts with other methods of the Vulture class to analyze the scanned nodes to identify dead code.\n\nConstants:\n- `self.exit_code`: Updated in case of any errors during the parsing process, indicating the status of the scan operation defined in the ExitCode enumeration.",
        "signature": "def scan(self, code, filename=''):",
        "type": "Method",
        "class_signature": "class Vulture(ast.NodeVisitor):"
      }
    },
    "vulture/utils.py": {
      "condition_is_always_false": {
        "code": "def condition_is_always_false(condition):\n    \"\"\"Determine if a given condition represented as an Abstract Syntax Tree (AST) node is always false.\n\nParameters:\n- condition (ast.AST): An AST node representing a boolean expression to be evaluated.\n\nReturns:\n- bool: True if the condition is always false, otherwise False.\n\nThis function relies on the `_safe_eval` utility to evaluate the condition safely, substituting for undefined variables or functions with a `True` value. The decision on whether the input condition is always false is based on the negation of the result from `_safe_eval`.\"\"\"\n    return not _safe_eval(condition, True)",
        "docstring": "Determine if a given condition represented as an Abstract Syntax Tree (AST) node is always false.\n\nParameters:\n- condition (ast.AST): An AST node representing a boolean expression to be evaluated.\n\nReturns:\n- bool: True if the condition is always false, otherwise False.\n\nThis function relies on the `_safe_eval` utility to evaluate the condition safely, substituting for undefined variables or functions with a `True` value. The decision on whether the input condition is always false is based on the negation of the result from `_safe_eval`.",
        "signature": "def condition_is_always_false(condition):",
        "type": "Function",
        "class_signature": null
      },
      "condition_is_always_true": {
        "code": "def condition_is_always_true(condition):\n    \"\"\"Determine if a given condition always evaluates to True.\n\nParameters:\n- condition (ast.AST): An abstract syntax tree (AST) node representing a Boolean expression.\n\nReturns:\n- bool: True if the condition evaluates to True for all possible inputs, otherwise False.\n\nThis function utilizes the _safe_eval function to evaluate the condition while defaulting to False for any undefined variables or functions. The significance of this is to assess the reliability of the condition in various execution contexts without executing arbitrary code.\"\"\"\n    return _safe_eval(condition, False)",
        "docstring": "Determine if a given condition always evaluates to True.\n\nParameters:\n- condition (ast.AST): An abstract syntax tree (AST) node representing a Boolean expression.\n\nReturns:\n- bool: True if the condition evaluates to True for all possible inputs, otherwise False.\n\nThis function utilizes the _safe_eval function to evaluate the condition while defaulting to False for any undefined variables or functions. The significance of this is to assess the reliability of the condition in various execution contexts without executing arbitrary code.",
        "signature": "def condition_is_always_true(condition):",
        "type": "Function",
        "class_signature": null
      }
    },
    "modified_testcases/__init__.py": {
      "check_unreachable": {
        "code": "def check_unreachable(v, lineno, size, name):\n    \"\"\"Checks that a single unreachable code item in a Vulture instance matches expected attributes.\n\nParameters:\n- v (core.Vulture): An instance of the Vulture class, which analyzes code for unused functions and variables.\n- lineno (int): The expected line number where the unreachable code starts.\n- size (int): The expected size of the unreachable code item.\n- name (str): The expected name of the unreachable code item.\n\nThis function asserts that the Vulture instance has exactly one unreachable code item in its `unreachable_code` attribute, and checks that this item's first line number, size, and name match the provided expected values.\"\"\"\n    assert len(v.unreachable_code) == 1\n    item = v.unreachable_code[0]\n    assert item.first_lineno == lineno\n    assert item.size == size\n    assert item.name == name",
        "docstring": "Checks that a single unreachable code item in a Vulture instance matches expected attributes.\n\nParameters:\n- v (core.Vulture): An instance of the Vulture class, which analyzes code for unused functions and variables.\n- lineno (int): The expected line number where the unreachable code starts.\n- size (int): The expected size of the unreachable code item.\n- name (str): The expected name of the unreachable code item.\n\nThis function asserts that the Vulture instance has exactly one unreachable code item in its `unreachable_code` attribute, and checks that this item's first line number, size, and name match the provided expected values.",
        "signature": "def check_unreachable(v, lineno, size, name):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "vulture/utils.py:condition_is_always_false": {
      "vulture/utils.py": {
        "_safe_eval": {
          "code": "def _safe_eval(node, default):\n    \"\"\"\n    Safely evaluate the Boolean expression under the given AST node.\n\n    Substitute `default` for all sub-expressions that cannot be\n    evaluated (because variables or functions are undefined).\n\n    We could use eval() to evaluate more sub-expressions. However, this\n    function is not safe for arbitrary Python code. Even after\n    overwriting the \"__builtins__\" dictionary, the original dictionary\n    can be restored\n    (https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).\n\n    \"\"\"\n    if isinstance(node, ast.BoolOp):\n        results = [_safe_eval(value, default) for value in node.values]\n        if isinstance(node.op, ast.And):\n            return all(results)\n        else:\n            return any(results)\n    elif isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.Not):\n        return not _safe_eval(node.operand, not default)\n    else:\n        try:\n            return ast.literal_eval(node)\n        except ValueError:\n            return default",
          "docstring": "Safely evaluate the Boolean expression under the given AST node.\n\nSubstitute `default` for all sub-expressions that cannot be\nevaluated (because variables or functions are undefined).\n\nWe could use eval() to evaluate more sub-expressions. However, this\nfunction is not safe for arbitrary Python code. Even after\noverwriting the \"__builtins__\" dictionary, the original dictionary\ncan be restored\n(https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).",
          "signature": "def _safe_eval(node, default):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "vulture/utils.py:condition_is_always_true": {
      "vulture/utils.py": {
        "_safe_eval": {
          "code": "def _safe_eval(node, default):\n    \"\"\"\n    Safely evaluate the Boolean expression under the given AST node.\n\n    Substitute `default` for all sub-expressions that cannot be\n    evaluated (because variables or functions are undefined).\n\n    We could use eval() to evaluate more sub-expressions. However, this\n    function is not safe for arbitrary Python code. Even after\n    overwriting the \"__builtins__\" dictionary, the original dictionary\n    can be restored\n    (https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).\n\n    \"\"\"\n    if isinstance(node, ast.BoolOp):\n        results = [_safe_eval(value, default) for value in node.values]\n        if isinstance(node.op, ast.And):\n            return all(results)\n        else:\n            return any(results)\n    elif isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.Not):\n        return not _safe_eval(node.operand, not default)\n    else:\n        try:\n            return ast.literal_eval(node)\n        except ValueError:\n            return default",
          "docstring": "Safely evaluate the Boolean expression under the given AST node.\n\nSubstitute `default` for all sub-expressions that cannot be\nevaluated (because variables or functions are undefined).\n\nWe could use eval() to evaluate more sub-expressions. However, this\nfunction is not safe for arbitrary Python code. Even after\noverwriting the \"__builtins__\" dictionary, the original dictionary\ncan be restored\n(https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).",
          "signature": "def _safe_eval(node, default):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "vulture/core.py:Vulture:__init__": {
      "vulture/utils.py": {
        "LoggingSet.__init__": {
          "code": "    def __init__(self, typ, verbose):\n        self.typ = typ\n        self._verbose = verbose\n        return super().__init__()",
          "docstring": "",
          "signature": "def __init__(self, typ, verbose):",
          "type": "Method",
          "class_signature": "class LoggingSet(set):"
        }
      }
    },
    "vulture/core.py:Vulture:scan": {
      "vulture/noqa.py": {
        "parse_noqa": {
          "code": "def parse_noqa(code):\n    noqa_lines = defaultdict(set)\n    for lineno, line in enumerate(code, start=1):\n        match = NOQA_REGEXP.search(line)\n        if match:\n            for error_code in _parse_error_codes(match):\n                error_code = NOQA_CODE_MAP.get(error_code, error_code)\n                noqa_lines[error_code].add(lineno)\n    return noqa_lines",
          "docstring": "",
          "signature": "def parse_noqa(code):",
          "type": "Function",
          "class_signature": null
        }
      },
      "vulture/core.py": {
        "Vulture.visit": {
          "code": "    def visit(self, node):\n        method = 'visit_' + node.__class__.__name__\n        visitor = getattr(self, method, None)\n        if self.verbose:\n            lineno = getattr(node, 'lineno', 1)\n            line = self.code[lineno - 1] if self.code else ''\n            self._log(lineno, ast.dump(node), line)\n        if visitor:\n            visitor(node)\n        type_comment = getattr(node, 'type_comment', None)\n        if type_comment is not None:\n            mode = 'func_type' if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) else 'eval'\n            self.visit(ast.parse(type_comment, filename='<type_comment>', mode=mode))\n        return self.generic_visit(node)",
          "docstring": "",
          "signature": "def visit(self, node):",
          "type": "Method",
          "class_signature": "class Vulture(ast.NodeVisitor):"
        }
      }
    },
    "modified_testcases/__init__.py:check_unreachable": {}
  },
  "call_tree": {
    "modified_testcases/test_conditions.py:test_false": {
      "modified_testcases/test_conditions.py:check_condition": {
        "vulture/utils.py:condition_is_always_false": {
          "vulture/utils.py:_safe_eval": {}
        }
      }
    },
    "modified_testcases/test_conditions.py:test_empty": {
      "modified_testcases/test_conditions.py:check_condition": {
        "vulture/utils.py:condition_is_always_false": {
          "vulture/utils.py:_safe_eval": {}
        }
      }
    },
    "modified_testcases/test_conditions.py:test_true": {
      "modified_testcases/test_conditions.py:check_condition": {
        "vulture/utils.py:condition_is_always_true": {
          "vulture/utils.py:_safe_eval": {}
        }
      }
    },
    "modified_testcases/test_conditions.py:test_complex_conditions": {
      "vulture/utils.py:condition_is_always_false": {
        "vulture/utils.py:_safe_eval": {
          "vulture/utils.py:_safe_eval": {
            "[ignored_or_cut_off]": "..."
          }
        }
      },
      "vulture/utils.py:condition_is_always_true": {
        "vulture/utils.py:_safe_eval": {
          "vulture/utils.py:_safe_eval": {
            "[ignored_or_cut_off]": "..."
          }
        }
      }
    },
    "modified_testcases/test_conditions.py:test_errors": {
      "vulture/utils.py:condition_is_always_false": {
        "vulture/utils.py:_safe_eval": {}
      },
      "vulture/utils.py:condition_is_always_true": {
        "vulture/utils.py:_safe_eval": {}
      }
    },
    "modified_testcases/__init__.py:v": {
      "vulture/core.py:Vulture:__init__": {
        "vulture/core.py:Vulture:get_list": {
          "vulture/utils.py:LoggingList:__init__": {}
        },
        "vulture/utils.py:LoggingSet:__init__": {}
      }
    },
    "modified_testcases/test_conditions.py:test_while": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_while_nested": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_false": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_elif_false": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_nested_if_statements_false": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_false_same_line": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_true": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_true_same_line": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_nested_if_statements_true": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_redundant_if": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "vulture/core.py:Item:size": {},
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_exp_true": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    },
    "modified_testcases/test_conditions.py:test_if_exp_false": {
      "vulture/core.py:Vulture:scan": {
        "vulture/noqa.py:parse_noqa": {},
        "vulture/core.py:Vulture:visit": {
          "vulture/core.py:Vulture:_log": {},
          "vulture/core.py:Vulture:generic_visit": {
            "vulture/core.py:Vulture:_handle_ast_list": {},
            "vulture/core.py:Vulture:visit": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      },
      "modified_testcases/__init__.py:check_unreachable": {
        "vulture/core.py:Item:size": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: vulture-test_conditions\n\n# FOLDER STRUCTURE:\n```\n..\n\u251c\u2500\u2500 modified_testcases/\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 check_unreachable\n\u2514\u2500\u2500 vulture/\n    \u251c\u2500\u2500 core.py\n    \u2502   \u251c\u2500\u2500 Item.size\n    \u2502   \u251c\u2500\u2500 Vulture.__init__\n    \u2502   \u2514\u2500\u2500 Vulture.scan\n    \u2514\u2500\u2500 utils.py\n        \u251c\u2500\u2500 condition_is_always_false\n        \u2514\u2500\u2500 condition_is_always_true\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to analyze and validate the logical structure of Python code by identifying unreachable or redundant code patterns, such as dead branches in conditionals or loops that will never be executed. It provides functionality to evaluate the truthfulness of conditions, determine whether certain conditional expressions are always true or false, and flag code that cannot be reached due to logical impossibilities. This helps developers identify and eliminate unnecessary or redundant code, improving code quality, maintainability, and runtime efficiency. By automating the detection of unreachable paths and logical inconsistencies, the module solves the problem of manually inspecting code for these issues, saving time and reducing the likelihood of human error.\n\n## FILE 1: vulture/core.py\n\n- CLASS METHOD: Vulture.scan\n  - CLASS SIGNATURE: class Vulture(ast.NodeVisitor):\n  - SIGNATURE: def scan(self, code, filename=''):\n  - DOCSTRING: \n```python\n\"\"\"\nScan the provided Python code for unused code elements and potential errors.\n\nParameters:\n- code (str): The source code to be scanned, provided as a string.\n- filename (str): The name of the file containing the code, defaulting to an empty string. This is used for logging and error reporting.\n\nThis method parses the provided source code into an Abstract Syntax Tree (AST) using the `ast.parse` function. It handles potential syntax errors gracefully by logging them with the relevant line number and error message. The method also processes `noqa` directives to determine lines of code that should be ignored during the scan. Additionally, if the scanning process encounters any `SyntaxError` while visiting nodes, it logs the error accordingly.\n\nDependencies:\n- Utilizes the `noqa` module for parsing ignore comments.\n- Makes use of utility functions from the `utils` module for formatting log messages and for handling errors.\n- Interacts with other methods of the Vulture class to analyze the scanned nodes to identify dead code.\n\nConstants:\n- `self.exit_code`: Updated in case of any errors during the parsing process, indicating the status of the scan operation defined in the ExitCode enumeration.\n\"\"\"\n```\n\n- CLASS METHOD: Item.size\n  - CLASS SIGNATURE: class Item:\n  - SIGNATURE: def size(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the size of the code item in terms of the number of lines.\n\nThis property computes the size as the difference between the last and first line numbers, adding one to ensure the correct count of lines. It asserts that `last_lineno` is greater than or equal to `first_lineno` to prevent any logical errors in size computation. This size is relevant for reporting unused code and is utilized in the `get_report` method of the `Item` class.\n\nAttributes:\n- `first_lineno`: The line number where the code item starts, defined during initialization.\n- `last_lineno`: The line number where the code item ends, also defined during initialization.\n\"\"\"\n```\n\n- CLASS METHOD: Vulture.__init__\n  - CLASS SIGNATURE: class Vulture(ast.NodeVisitor):\n  - SIGNATURE: def __init__(self, verbose=False, ignore_names=None, ignore_decorators=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Vulture instance to analyze Python code for unused elements.\n\nParameters:\n- verbose (bool, optional): A flag to enable verbose logging. Defaults to False.\n- ignore_names (list of str, optional): A list of names to ignore during the analysis. Defaults to None.\n- ignore_decorators (list of str, optional): A list of decorators to ignore during the analysis. Defaults to None.\n\nAttributes:\n- defined_attrs (LoggingList): Tracks defined attributes in the analyzed code.\n- defined_classes (LoggingList): Tracks defined classes in the analyzed code.\n- defined_funcs (LoggingList): Tracks defined functions in the analyzed code.\n- defined_imports (LoggingList): Tracks defined imports in the analyzed code.\n- defined_methods (LoggingList): Tracks defined methods in the analyzed code.\n- defined_props (LoggingList): Tracks defined properties in the analyzed code.\n- defined_vars (LoggingList): Tracks defined variables in the analyzed code.\n- unreachable_code (LoggingList): Records unreachable code snippets.\n- used_names (LoggingSet): Keeps track of names that are used in the analyzed code.\n- filename (Path): Stores the current file path being analyzed.\n- code (list of str): Contains the lines of code from the current file.\n- exit_code (ExitCode): Holds the exit code for the analysis process, initialized to NoDeadCode.\n- noqa_lines (dict): Stores lines that are marked to be excluded from analysis.\n\nConstants used:\n- ExitCode: Provides different exit code statuses for the analysis outcome.\n- LoggingList and LoggingSet: Utility classes from the utils module that facilitate tracking and logging during analysis. Their verbosity is linked to the `verbose` parameter to control the amount of logging output.\n\"\"\"\n```\n\n## FILE 2: vulture/utils.py\n\n- FUNCTION NAME: condition_is_always_true\n  - SIGNATURE: def condition_is_always_true(condition):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if a given condition always evaluates to True.\n\nParameters:\n- condition (ast.AST): An abstract syntax tree (AST) node representing a Boolean expression.\n\nReturns:\n- bool: True if the condition evaluates to True for all possible inputs, otherwise False.\n\nThis function utilizes the _safe_eval function to evaluate the condition while defaulting to False for any undefined variables or functions. The significance of this is to assess the reliability of the condition in various execution contexts without executing arbitrary code.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/utils.py:_safe_eval\n\n- FUNCTION NAME: condition_is_always_false\n  - SIGNATURE: def condition_is_always_false(condition):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if a given condition represented as an Abstract Syntax Tree (AST) node is always false.\n\nParameters:\n- condition (ast.AST): An AST node representing a boolean expression to be evaluated.\n\nReturns:\n- bool: True if the condition is always false, otherwise False.\n\nThis function relies on the `_safe_eval` utility to evaluate the condition safely, substituting for undefined variables or functions with a `True` value. The decision on whether the input condition is always false is based on the negation of the result from `_safe_eval`.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/utils.py:_safe_eval\n\n## FILE 3: modified_testcases/__init__.py\n\n- FUNCTION NAME: check_unreachable\n  - SIGNATURE: def check_unreachable(v, lineno, size, name):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks that a single unreachable code item in a Vulture instance matches expected attributes.\n\nParameters:\n- v (core.Vulture): An instance of the Vulture class, which analyzes code for unused functions and variables.\n- lineno (int): The expected line number where the unreachable code starts.\n- size (int): The expected size of the unreachable code item.\n- name (str): The expected name of the unreachable code item.\n\nThis function asserts that the Vulture instance has exactly one unreachable code item in its `unreachable_code` attribute, and checks that this item's first line number, size, and name match the provided expected values.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - vulture/core.py:Item:size\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "vulture/core.py": "import ast\nfrom fnmatch import fnmatch, fnmatchcase\nfrom pathlib import Path\nimport pkgutil\nimport re\nimport string\nimport sys\nfrom typing import List\nfrom vulture import lines\nfrom vulture import noqa\nfrom vulture import utils\nfrom vulture.config import InputError, make_config\nfrom vulture.utils import ExitCode\nDEFAULT_CONFIDENCE = 60\nIGNORED_VARIABLE_NAMES = {'object', 'self'}\nPYTEST_FUNCTION_NAMES = {'setup_module', 'teardown_module', 'setup_function', 'teardown_function'}\nPYTEST_METHOD_NAMES = {'setup_class', 'teardown_class', 'setup_method', 'teardown_method'}\nERROR_CODES = {'attribute': 'V101', 'class': 'V102', 'function': 'V103', 'import': 'V104', 'method': 'V105', 'property': 'V106', 'variable': 'V107', 'unreachable_code': 'V201'}\n\ndef _get_unused_items(defined_items, used_names):\n    unused_items = [item for item in set(defined_items) if item.name not in used_names]\n    unused_items.sort(key=lambda item: item.name.lower())\n    return unused_items\n\ndef _is_special_name(name):\n    return name.startswith('__') and name.endswith('__')\n\ndef _match(name, patterns, case=True):\n    func = fnmatchcase if case else fnmatch\n    return any((func(name, pattern) for pattern in patterns))\n\ndef _is_test_file(filename):\n    return _match(filename.resolve(), ['*/test/*', '*/tests/*', '*/test*.py', '*[-_]test.py'], case=False)\n\ndef _assigns_special_variable__all__(node):\n    assert isinstance(node, ast.Assign)\n    return isinstance(node.value, (ast.List, ast.Tuple)) and any((target.id == '__all__' for target in node.targets if isinstance(target, ast.Name)))\n\ndef _ignore_class(filename, class_name):\n    return _is_test_file(filename) and 'Test' in class_name\n\ndef _ignore_import(filename, import_name):\n    \"\"\"\n    Ignore star-imported names since we can't detect whether they are used.\n    Ignore imports from __init__.py files since they're commonly used to\n    collect objects from a package.\n    \"\"\"\n    return filename.name == '__init__.py' or import_name == '*'\n\ndef _ignore_function(filename, function_name):\n    return (function_name in PYTEST_FUNCTION_NAMES or function_name.startswith('test_')) and _is_test_file(filename)\n\ndef _ignore_method(filename, method_name):\n    return _is_special_name(method_name) or ((method_name in PYTEST_METHOD_NAMES or method_name.startswith('test_')) and _is_test_file(filename))\n\ndef _ignore_variable(filename, varname):\n    \"\"\"\n    Ignore _ (Python idiom), _x (pylint convention) and\n    __x__ (special variable or method), but not __x.\n    \"\"\"\n    return varname in IGNORED_VARIABLE_NAMES or (varname.startswith('_') and (not varname.startswith('__'))) or _is_special_name(varname)\n\nclass Item:\n    \"\"\"\n    Hold the name, type and location of defined code.\n    \"\"\"\n    __slots__ = ('name', 'typ', 'filename', 'first_lineno', 'last_lineno', 'message', 'confidence')\n\n    def __init__(self, name, typ, filename, first_lineno, last_lineno, message='', confidence=DEFAULT_CONFIDENCE):\n        self.name: str = name\n        self.typ: str = typ\n        self.filename: Path = filename\n        self.first_lineno: int = first_lineno\n        self.last_lineno: int = last_lineno\n        self.message: str = message or f\"unused {typ} '{name}'\"\n        self.confidence: int = confidence\n\n    def get_report(self, add_size=False):\n        if add_size:\n            line_format = 'line' if self.size == 1 else 'lines'\n            size_report = f', {self.size:d} {line_format}'\n        else:\n            size_report = ''\n        return '{}:{:d}: {} ({}% confidence{})'.format(utils.format_path(self.filename), self.first_lineno, self.message, self.confidence, size_report)\n\n    def get_whitelist_string(self):\n        filename = utils.format_path(self.filename)\n        if self.typ == 'unreachable_code':\n            return f'# {self.message} ({filename}:{self.first_lineno})'\n        else:\n            prefix = ''\n            if self.typ in ['attribute', 'method', 'property']:\n                prefix = '_.'\n            return '{}{}  # unused {} ({}:{:d})'.format(prefix, self.name, self.typ, filename, self.first_lineno)\n\n    def _tuple(self):\n        return (self.filename, self.first_lineno, self.name)\n\n    def __repr__(self):\n        return repr(self.name)\n\n    def __eq__(self, other):\n        return self._tuple() == other._tuple()\n\n    def __hash__(self):\n        return hash(self._tuple())\n\nclass Vulture(ast.NodeVisitor):\n    \"\"\"Find dead code.\"\"\"\n\n    def scavenge(self, paths, exclude=None):\n\n        def prepare_pattern(pattern):\n            if not any((char in pattern for char in '*?[')):\n                pattern = f'*{pattern}*'\n            return pattern\n        exclude = [prepare_pattern(pattern) for pattern in exclude or []]\n\n        def exclude_path(path):\n            return _match(path, exclude, case=False)\n        paths = [Path(path) for path in paths]\n        for module in utils.get_modules(paths):\n            if exclude_path(module):\n                self._log('Excluded:', module)\n                continue\n            self._log('Scanning:', module)\n            try:\n                module_string = utils.read_file(module)\n            except utils.VultureInputException as err:\n                self._log(f'Error: Could not read file {module} - {err}\\nTry to change the encoding to UTF-8.', file=sys.stderr, force=True)\n                self.exit_code = ExitCode.InvalidInput\n            else:\n                self.scan(module_string, filename=module)\n        unique_imports = {item.name for item in self.defined_imports}\n        for import_name in unique_imports:\n            path = Path('whitelists') / (import_name + '_whitelist.py')\n            if exclude_path(path):\n                self._log('Excluded whitelist:', path)\n            else:\n                try:\n                    module_data = pkgutil.get_data('vulture', str(path))\n                    self._log('Included whitelist:', path)\n                except OSError:\n                    continue\n                assert module_data is not None\n                module_string = module_data.decode('utf-8')\n                self.scan(module_string, filename=path)\n\n    def get_unused_code(self, min_confidence=0, sort_by_size=False) -> List[Item]:\n        \"\"\"\n        Return ordered list of unused Item objects.\n        \"\"\"\n        if not 0 <= min_confidence <= 100:\n            raise ValueError('min_confidence must be between 0 and 100.')\n\n        def by_name(item):\n            return (str(item.filename).lower(), item.first_lineno)\n\n        def by_size(item):\n            return (item.size,) + by_name(item)\n        unused_code = self.unused_attrs + self.unused_classes + self.unused_funcs + self.unused_imports + self.unused_methods + self.unused_props + self.unused_vars + self.unreachable_code\n        confidently_unused = [obj for obj in unused_code if obj.confidence >= min_confidence]\n        return sorted(confidently_unused, key=by_size if sort_by_size else by_name)\n\n    def report(self, min_confidence=0, sort_by_size=False, make_whitelist=False):\n        \"\"\"\n        Print ordered list of Item objects to stdout.\n        \"\"\"\n        for item in self.get_unused_code(min_confidence=min_confidence, sort_by_size=sort_by_size):\n            self._log(item.get_whitelist_string() if make_whitelist else item.get_report(add_size=sort_by_size), force=True)\n            self.exit_code = ExitCode.DeadCode\n        return self.exit_code\n\n    @property\n    def unused_classes(self):\n        return _get_unused_items(self.defined_classes, self.used_names)\n\n    @property\n    def unused_funcs(self):\n        return _get_unused_items(self.defined_funcs, self.used_names)\n\n    @property\n    def unused_imports(self):\n        return _get_unused_items(self.defined_imports, self.used_names)\n\n    @property\n    def unused_methods(self):\n        return _get_unused_items(self.defined_methods, self.used_names)\n\n    @property\n    def unused_props(self):\n        return _get_unused_items(self.defined_props, self.used_names)\n\n    @property\n    def unused_vars(self):\n        return _get_unused_items(self.defined_vars, self.used_names)\n\n    @property\n    def unused_attrs(self):\n        return _get_unused_items(self.defined_attrs, self.used_names)\n\n    def _log(self, *args, file=None, force=False):\n        if self.verbose or force:\n            file = file or sys.stdout\n            try:\n                print(*args, file=file)\n            except UnicodeEncodeError:\n                x = ' '.join(map(str, args))\n                print(x.encode(), file=file)\n\n    def _add_aliases(self, node):\n        \"\"\"\n        We delegate to this method instead of using visit_alias() to have\n        access to line numbers and to filter imports from __future__.\n        \"\"\"\n        assert isinstance(node, (ast.Import, ast.ImportFrom))\n        for name_and_alias in node.names:\n            name = name_and_alias.name.partition('.')[0]\n            alias = name_and_alias.asname\n            self._define(self.defined_imports, alias or name, node, confidence=90, ignore=_ignore_import)\n            if alias is not None:\n                self.used_names.add(name_and_alias.name)\n\n    def _handle_conditional_node(self, node, name):\n        if utils.condition_is_always_false(node.test):\n            self._define(self.unreachable_code, name, node, last_node=node.body if isinstance(node, ast.IfExp) else node.body[-1], message=f\"unsatisfiable '{name}' condition\", confidence=100)\n        elif utils.condition_is_always_true(node.test):\n            else_body = node.orelse\n            if name == 'ternary':\n                self._define(self.unreachable_code, name, else_body, message=\"unreachable 'else' expression\", confidence=100)\n            elif else_body:\n                self._define(self.unreachable_code, 'else', else_body[0], last_node=else_body[-1], message=\"unreachable 'else' block\", confidence=100)\n            elif name == 'if':\n                self._define(self.unreachable_code, name, node, message='redundant if-condition', confidence=100)\n\n    def _define(self, collection, name, first_node, last_node=None, message='', confidence=DEFAULT_CONFIDENCE, ignore=None):\n\n        def ignored(lineno):\n            return ignore and ignore(self.filename, name) or _match(name, self.ignore_names) or noqa.ignore_line(self.noqa_lines, lineno, ERROR_CODES[typ])\n        last_node = last_node or first_node\n        typ = collection.typ\n        first_lineno = lines.get_first_line_number(first_node)\n        if ignored(first_lineno):\n            self._log(f'Ignoring {typ} \"{name}\"')\n        else:\n            collection.append(Item(name, typ, self.filename, first_lineno, lines.get_last_line_number(last_node), message=message, confidence=confidence))\n\n    def _define_variable(self, name, node, confidence=DEFAULT_CONFIDENCE):\n        self._define(self.defined_vars, name, node, confidence=confidence, ignore=_ignore_variable)\n\n    def visit_arg(self, node):\n        \"\"\"Function argument\"\"\"\n        self._define_variable(node.arg, node, confidence=100)\n\n    def visit_AsyncFunctionDef(self, node):\n        return self.visit_FunctionDef(node)\n\n    def visit_Attribute(self, node):\n        if isinstance(node.ctx, ast.Store):\n            self._define(self.defined_attrs, node.attr, node)\n        elif isinstance(node.ctx, ast.Load):\n            self.used_names.add(node.attr)\n\n    def visit_BinOp(self, node):\n        \"\"\"\n        Parse variable names in old format strings:\n\n        \"%(my_var)s\" % locals()\n        \"\"\"\n        if utils.is_ast_string(node.left) and isinstance(node.op, ast.Mod) and self._is_locals_call(node.right):\n            self.used_names |= set(re.findall('%\\\\((\\\\w+)\\\\)', node.left.value))\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name) and (node.func.id == 'getattr' and 2 <= len(node.args) <= 3 or (node.func.id == 'hasattr' and len(node.args) == 2)):\n            attr_name_arg = node.args[1]\n            if utils.is_ast_string(attr_name_arg):\n                self.used_names.add(attr_name_arg.value)\n        if isinstance(node.func, ast.Attribute) and utils.is_ast_string(node.func.value) and (node.func.attr == 'format') and any((kw.arg is None and self._is_locals_call(kw.value) for kw in node.keywords)):\n            self._handle_new_format_string(node.func.value.value)\n\n    def _handle_new_format_string(self, s):\n\n        def is_identifier(name):\n            return bool(re.match('[a-zA-Z_][a-zA-Z0-9_]*', name))\n        parser = string.Formatter()\n        try:\n            names = [name for _, name, _, _ in parser.parse(s) if name]\n        except ValueError:\n            names = []\n        for field_name in names:\n            vars = re.sub('\\\\[\\\\w*\\\\]', '', field_name).split('.')\n            for var in vars:\n                if is_identifier(var):\n                    self.used_names.add(var)\n\n    @staticmethod\n    def _is_locals_call(node):\n        \"\"\"Return True if the node is `locals()`.\"\"\"\n        return isinstance(node, ast.Call) and isinstance(node.func, ast.Name) and (node.func.id == 'locals') and (not node.args) and (not node.keywords)\n\n    def visit_ClassDef(self, node):\n        for decorator in node.decorator_list:\n            if _match(utils.get_decorator_name(decorator), self.ignore_decorators):\n                self._log(f'Ignoring class \"{node.name}\" (decorator whitelisted)')\n                break\n        else:\n            self._define(self.defined_classes, node.name, node, ignore=_ignore_class)\n\n    def visit_FunctionDef(self, node):\n        decorator_names = [utils.get_decorator_name(decorator) for decorator in node.decorator_list]\n        first_arg = node.args.args[0].arg if node.args.args else None\n        if '@property' in decorator_names:\n            typ = 'property'\n        elif '@staticmethod' in decorator_names or '@classmethod' in decorator_names or first_arg == 'self':\n            typ = 'method'\n        else:\n            typ = 'function'\n        if any((_match(name, self.ignore_decorators) for name in decorator_names)):\n            self._log(f'Ignoring {typ} \"{node.name}\" (decorator whitelisted)')\n        elif typ == 'property':\n            self._define(self.defined_props, node.name, node)\n        elif typ == 'method':\n            self._define(self.defined_methods, node.name, node, ignore=_ignore_method)\n        else:\n            self._define(self.defined_funcs, node.name, node, ignore=_ignore_function)\n\n    def visit_If(self, node):\n        self._handle_conditional_node(node, 'if')\n\n    def visit_IfExp(self, node):\n        self._handle_conditional_node(node, 'ternary')\n\n    def visit_Import(self, node):\n        self._add_aliases(node)\n\n    def visit_ImportFrom(self, node):\n        if node.module != '__future__':\n            self._add_aliases(node)\n\n    def visit_Name(self, node):\n        if isinstance(node.ctx, (ast.Load, ast.Del)) and node.id not in IGNORED_VARIABLE_NAMES:\n            self.used_names.add(node.id)\n        elif isinstance(node.ctx, (ast.Param, ast.Store)):\n            self._define_variable(node.id, node)\n\n    def visit_Assign(self, node):\n        if _assigns_special_variable__all__(node):\n            assert isinstance(node.value, (ast.List, ast.Tuple))\n            for elt in node.value.elts:\n                if utils.is_ast_string(elt):\n                    self.used_names.add(elt.value)\n\n    def visit_While(self, node):\n        self._handle_conditional_node(node, 'while')\n\n    def visit_MatchClass(self, node):\n        for kwd_attr in node.kwd_attrs:\n            self.used_names.add(kwd_attr)\n\n    def visit(self, node):\n        method = 'visit_' + node.__class__.__name__\n        visitor = getattr(self, method, None)\n        if self.verbose:\n            lineno = getattr(node, 'lineno', 1)\n            line = self.code[lineno - 1] if self.code else ''\n            self._log(lineno, ast.dump(node), line)\n        if visitor:\n            visitor(node)\n        type_comment = getattr(node, 'type_comment', None)\n        if type_comment is not None:\n            mode = 'func_type' if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)) else 'eval'\n            self.visit(ast.parse(type_comment, filename='<type_comment>', mode=mode))\n        return self.generic_visit(node)\n\n    def _handle_ast_list(self, ast_list):\n        \"\"\"\n        Find unreachable nodes in the given sequence of ast nodes.\n        \"\"\"\n        for index, node in enumerate(ast_list):\n            if isinstance(node, (ast.Break, ast.Continue, ast.Raise, ast.Return)):\n                try:\n                    first_unreachable_node = ast_list[index + 1]\n                except IndexError:\n                    continue\n                class_name = node.__class__.__name__.lower()\n                self._define(self.unreachable_code, class_name, first_unreachable_node, last_node=ast_list[-1], message=f\"unreachable code after '{class_name}'\", confidence=100)\n                return\n\n    def generic_visit(self, node):\n        \"\"\"Called if no explicit visitor function exists for a node.\"\"\"\n        for _, value in ast.iter_fields(node):\n            if isinstance(value, list):\n                self._handle_ast_list(value)\n                for item in value:\n                    if isinstance(item, ast.AST):\n                        self.visit(item)\n            elif isinstance(value, ast.AST):\n                self.visit(value)\n\ndef main():\n    try:\n        config = make_config()\n    except InputError as e:\n        print(e, file=sys.stderr)\n        sys.exit(ExitCode.InvalidCmdlineArguments)\n    vulture = Vulture(verbose=config['verbose'], ignore_names=config['ignore_names'], ignore_decorators=config['ignore_decorators'])\n    vulture.scavenge(config['paths'], exclude=config['exclude'])\n    sys.exit(vulture.report(min_confidence=config['min_confidence'], sort_by_size=config['sort_by_size'], make_whitelist=config['make_whitelist']))",
    "vulture/utils.py": "import ast\nfrom enum import IntEnum\nimport pathlib\nimport sys\nimport tokenize\n\nclass VultureInputException(Exception):\n    pass\n\nclass ExitCode(IntEnum):\n    NoDeadCode = 0\n    InvalidInput = 1\n    InvalidCmdlineArguments = 2\n    DeadCode = 3\n\ndef _safe_eval(node, default):\n    \"\"\"\n    Safely evaluate the Boolean expression under the given AST node.\n\n    Substitute `default` for all sub-expressions that cannot be\n    evaluated (because variables or functions are undefined).\n\n    We could use eval() to evaluate more sub-expressions. However, this\n    function is not safe for arbitrary Python code. Even after\n    overwriting the \"__builtins__\" dictionary, the original dictionary\n    can be restored\n    (https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html).\n\n    \"\"\"\n    if isinstance(node, ast.BoolOp):\n        results = [_safe_eval(value, default) for value in node.values]\n        if isinstance(node.op, ast.And):\n            return all(results)\n        else:\n            return any(results)\n    elif isinstance(node, ast.UnaryOp) and isinstance(node.op, ast.Not):\n        return not _safe_eval(node.operand, not default)\n    else:\n        try:\n            return ast.literal_eval(node)\n        except ValueError:\n            return default\n\ndef is_ast_string(node):\n    return isinstance(node, ast.Constant) and isinstance(node.value, str)\n\ndef format_path(path):\n    try:\n        return path.relative_to(pathlib.Path.cwd())\n    except ValueError:\n        return path\n\ndef get_decorator_name(decorator):\n    if isinstance(decorator, ast.Call):\n        decorator = decorator.func\n    try:\n        parts = []\n        while isinstance(decorator, ast.Attribute):\n            parts.append(decorator.attr)\n            decorator = decorator.value\n        parts.append(decorator.id)\n    except AttributeError:\n        parts = []\n    return '@' + '.'.join(reversed(parts))\n\ndef get_modules(paths):\n    \"\"\"Retrieve Python files to check.\n\n    Loop over all given paths, abort if any ends with .pyc, add the other given\n    files (even those not ending with .py) and collect all .py files under the\n    given directories.\n\n    \"\"\"\n    modules = []\n    for path in paths:\n        path = path.resolve()\n        if path.is_file():\n            if path.suffix == '.pyc':\n                sys.exit(f'Error: *.pyc files are not supported: {path}')\n            else:\n                modules.append(path)\n        elif path.is_dir():\n            modules.extend(path.rglob('*.py'))\n        else:\n            sys.exit(f'Error: {path} could not be found.')\n    return modules\n\ndef read_file(filename):\n    try:\n        with tokenize.open(filename) as f:\n            return f.read()\n    except (SyntaxError, UnicodeDecodeError) as err:\n        raise VultureInputException from err\n\nclass LoggingList(list):\n\n    def __init__(self, typ, verbose):\n        self.typ = typ\n        self._verbose = verbose\n        return super().__init__()\n\n    def append(self, item):\n        if self._verbose:\n            print(f'define {self.typ} \"{item.name}\"')\n        super().append(item)\n\nclass LoggingSet(set):\n\n    def __init__(self, typ, verbose):\n        self.typ = typ\n        self._verbose = verbose\n        return super().__init__()\n\n    def add(self, name):\n        if self._verbose:\n            print(f'use {self.typ} \"{name}\"')\n        super().add(name)",
    "modified_testcases/__init__.py": "import pathlib\nimport subprocess\nimport sys\nimport pytest\nfrom vulture import core\nREPO = pathlib.Path(__file__).resolve().parents[1]\nWHITELISTS = [str(path) for path in (REPO / 'vulture' / 'whitelists').glob('*.py') if sys.version_info < (3, 13) or path.name != 'pint_whitelist.py']\n\ndef call_vulture(args, **kwargs):\n    return subprocess.call([sys.executable, '-m', 'vulture'] + args, cwd=REPO, **kwargs)\n\ndef check(items_or_names, expected_names):\n    \"\"\"items_or_names must be a collection of Items or a set of strings.\"\"\"\n    try:\n        assert sorted((item.name for item in items_or_names)) == sorted(expected_names)\n    except AttributeError:\n        assert items_or_names == set(expected_names)\n\n@pytest.fixture\ndef v():\n    return core.Vulture(verbose=True)"
  }
}