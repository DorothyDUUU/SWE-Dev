{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_document_end",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/rules/test_document_end.py",
  "test_code": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom tests.common import RuleTestCase\n\n\nclass DocumentEndTestCase(RuleTestCase):\n    rule_id = 'document-end'\n\n    def test_disabled(self):\n        conf = 'document-end: disable'\n        self.check('---\\n'\n                   'with:\\n'\n                   '  document: end\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   'without:\\n'\n                   '  document: end\\n', conf)\n\n    def test_required(self):\n        conf = 'document-end: {present: true}'\n        self.check('', conf)\n        self.check('\\n', conf)\n        self.check('---\\n'\n                   'with:\\n'\n                   '  document: end\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   'without:\\n'\n                   '  document: end\\n', conf, problem=(3, 1))\n\n    def test_forbidden(self):\n        conf = 'document-end: {present: false}'\n        self.check('---\\n'\n                   'with:\\n'\n                   '  document: end\\n'\n                   '...\\n', conf, problem=(4, 1))\n        self.check('---\\n'\n                   'without:\\n'\n                   '  document: end\\n', conf)\n\n    def test_multiple_documents(self):\n        conf = ('document-end: {present: true}\\n'\n                'document-start: disable\\n')\n        self.check('---\\n'\n                   'first: document\\n'\n                   '...\\n'\n                   '---\\n'\n                   'second: document\\n'\n                   '...\\n'\n                   '---\\n'\n                   'third: document\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   'first: document\\n'\n                   '...\\n'\n                   '---\\n'\n                   'second: document\\n'\n                   '---\\n'\n                   'third: document\\n'\n                   '...\\n', conf, problem=(6, 1))\n\n    def test_directives(self):\n        conf = 'document-end: {present: true}'\n        self.check('%YAML 1.2\\n'\n                   '---\\n'\n                   'document: end\\n'\n                   '...\\n', conf)\n        self.check('%YAML 1.2\\n'\n                   '%TAG ! tag:clarkevans.com,2002:\\n'\n                   '---\\n'\n                   'document: end\\n'\n                   '...\\n', conf)\n        self.check('---\\n'\n                   'first: document\\n'\n                   '...\\n'\n                   '%YAML 1.2\\n'\n                   '---\\n'\n                   'second: document\\n'\n                   '...\\n', conf)\n",
  "GT_file_code": {
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem instance, representing a linting issue found during YAML analysis.\n\nParameters:\n- line (int): The line number where the problem was detected (starting at 1).\n- column (int): The column number where the problem was located (starting at 1).\n- desc (str, optional): A human-readable description of the problem (defaults to '<no description>').\n- rule (str, optional): The identifier of the rule that detected the problem (defaults to None).\n\nAttributes:\n- line: Stores the line number of the problem.\n- column: Stores the column number of the problem.\n- desc: Stores the description of the problem.\n- rule: Stores the identifier of the rule that found the problem.\n- level: Initially set to None; will later hold the severity level of the problem (defined by the conf parameter in functions interacting with this class).\n\nThis constructor is part of the LintProblem class, which provides functionality to encapsulate information about linting issues detected by the yamllint tool, interacting with other parts of the code, especially during problem detection and reporting in the YAML linting process.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem instance, representing a linting issue found during YAML analysis.\n\nParameters:\n- line (int): The line number where the problem was detected (starting at 1).\n- column (int): The column number where the problem was located (starting at 1).\n- desc (str, optional): A human-readable description of the problem (defaults to '<no description>').\n- rule (str, optional): The identifier of the rule that detected the problem (defaults to None).\n\nAttributes:\n- line: Stores the line number of the problem.\n- column: Stores the column number of the problem.\n- desc: Stores the description of the problem.\n- rule: Stores the identifier of the rule that found the problem.\n- level: Initially set to None; will later hold the severity level of the problem (defined by the conf parameter in functions interacting with this class).\n\nThis constructor is part of the LintProblem class, which provides functionality to encapsulate information about linting issues detected by the yamllint tool, interacting with other parts of the code, especially during problem detection and reporting in the YAML linting process.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): The instance to compare against the current instance.\n\nReturns:\n- bool: True if both instances have the same line number, column number, and associated rule; otherwise, False.\n\nThis method relies on the attributes `line`, `column`, and `rule`, which are defined in the LintProblem class's `__init__` method. It is used to determine if two linting problems are identical, which can help in filtering or aggregating problems identified during YAML linting.\"\"\"\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)",
        "docstring": "Checks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): The instance to compare against the current instance.\n\nReturns:\n- bool: True if both instances have the same line number, column number, and associated rule; otherwise, False.\n\nThis method relies on the attributes `line`, `column`, and `rule`, which are defined in the LintProblem class's `__init__` method. It is used to determine if two linting problems are identical, which can help in filtering or aggregating problems identified during YAML linting.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "_run": {
        "code": "def _run(buffer, conf, filepath):\n    \"\"\"Run the linter on a YAML input buffer, processing any syntax errors and cosmetic problems found.\n\nParameters:\n- buffer: A string or buffered input representing the YAML content to be linted.\n- conf: A configuration object that contains linting rules and settings.\n- filepath: An optional string indicating the file path, used for ignoring specific files based on configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the YAML content, including both semantic issues and syntax errors.\n\nThe function first checks if the input `buffer` has the appropriate structure and then verifies whether linting should be skipped for the file based on the configuration. It uses the `get_syntax_error` function to identify any syntax errors in the YAML input, then passes the buffer to `get_cosmetic_problems` to yield cosmetic linting issues while appropriately handling directives for enabling and disabling rules. The function ensures that syntax errors are yielded in the correct order relative to other problems, avoiding redundancy in reports.\"\"\"\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
        "docstring": "Run the linter on a YAML input buffer, processing any syntax errors and cosmetic problems found.\n\nParameters:\n- buffer: A string or buffered input representing the YAML content to be linted.\n- conf: A configuration object that contains linting rules and settings.\n- filepath: An optional string indicating the file path, used for ignoring specific files based on configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the YAML content, including both semantic issues and syntax errors.\n\nThe function first checks if the input `buffer` has the appropriate structure and then verifies whether linting should be skipped for the file based on the configuration. It uses the `get_syntax_error` function to identify any syntax errors in the YAML input, then passes the buffer to `get_cosmetic_problems` to yield cosmetic linting issues while appropriately handling directives for enabling and disabling rules. The function ensures that syntax errors are yielded in the correct order relative to other problems, avoiding redundancy in reports.",
        "signature": "def _run(buffer, conf, filepath):",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source input and returns a generator of LintProblem objects, which represent any issues found during the linting process.\n\nParameters:\n- input (str, bytes, or io.IOBase): The YAML source to be linted, which can be a string, bytes, or a stream.\n- conf: A yamllint configuration object that defines rules for linting the input.\n- filepath (str, optional): The path of the YAML file being linted; used to check if the file is ignored by the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects representing the detected linting issues. If the file is ignored by the configuration or a syntax error is found, appropriate handling occurs.\n\nThis function leverages the `_run` helper function to process the input and validate against linting rules. Notably, it uses the `PROBLEM_LEVELS` constant in conjunction with the linting rules managed by the `conf` object. Additionally, it employs the `parser` module to tokenize and analyze the input or stream efficiently.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source input and returns a generator of LintProblem objects, which represent any issues found during the linting process.\n\nParameters:\n- input (str, bytes, or io.IOBase): The YAML source to be linted, which can be a string, bytes, or a stream.\n- conf: A yamllint configuration object that defines rules for linting the input.\n- filepath (str, optional): The path of the YAML file being linted; used to check if the file is ignored by the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects representing the detected linting issues. If the file is ignored by the configuration or a syntax error is found, appropriate handling occurs.\n\nThis function leverages the `_run` helper function to process the input and validate against linting rules. Notably, it uses the `PROBLEM_LEVELS` constant in conjunction with the linting rules managed by the `conf` object. Additionally, it employs the `parser` module to tokenize and analyze the input or stream efficiently.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:_run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      },
      "yamllint/parser.py": {
        "Line.content": {
          "code": "    def content(self):\n        return self.buffer[self.start:self.end]",
          "docstring": "",
          "signature": "def content(self):",
          "type": "Method",
          "class_signature": "class Line:"
        },
        "line_generator": {
          "code": "def line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))",
          "docstring": "",
          "signature": "def line_generator(buffer):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/linter.py": {
        "get_cosmetic_problems": {
          "code": "def get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []",
          "docstring": "",
          "signature": "def get_cosmetic_problems(buffer, conf, filepath):",
          "type": "Function",
          "class_signature": null
        },
        "get_syntax_error": {
          "code": "def get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
          "docstring": "",
          "signature": "def get_syntax_error(buffer):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/linter.py:LintProblem:__init__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__eq__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/rules/test_document_end.py:DocumentEndTestCase:test_directives": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {
                "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
              }
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_end.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        }
      }
    },
    "modified_testcases/rules/test_document_end.py:DocumentEndTestCase:test_disabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        }
      }
    },
    "modified_testcases/rules/test_document_end.py:DocumentEndTestCase:test_forbidden": {
      "tests/common.py:RuleTestCase:check": {
        "yamllint/linter.py:LintProblem:__init__": {},
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_end.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_document_end.py:DocumentEndTestCase:test_multiple_documents": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_end.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_document_end.py:DocumentEndTestCase:test_required": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_end.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_document_end/yamllint-test_document_end/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_document_end/yamllint-test_document_end/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_document_end\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__eq__\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 _run\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate the presence and configuration of document end markers in YAML files, ensuring adherence to specified formatting rules. It provides functionality to enable or disable validations related to document terminators, enforce requirements for their presence, prohibit their use, and verify compliance across YAML content, including scenarios with multiple documents and directives. By defining and enforcing rules for the structural integrity of YAML documents, the module addresses the need for consistent and rule-compliant tagging, reducing errors and ambiguities for developers and systems interacting with YAML data. This ensures better reliability and compatibility in applications that rely on well-formed YAML documents.\n\n## FILE 1: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source input and returns a generator of LintProblem objects, which represent any issues found during the linting process.\n\nParameters:\n- input (str, bytes, or io.IOBase): The YAML source to be linted, which can be a string, bytes, or a stream.\n- conf: A yamllint configuration object that defines rules for linting the input.\n- filepath (str, optional): The path of the YAML file being linted; used to check if the file is ignored by the configuration.\n\nReturns:\n- generator: A generator yielding LintProblem objects representing the detected linting issues. If the file is ignored by the configuration or a syntax error is found, appropriate handling occurs.\n\nThis function leverages the `_run` helper function to process the input and validate against linting rules. Notably, it uses the `PROBLEM_LEVELS` constant in conjunction with the linting rules managed by the `conf` object. Additionally, it employs the `parser` module to tokenize and analyze the input or stream efficiently.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem instance, representing a linting issue found during YAML analysis.\n\nParameters:\n- line (int): The line number where the problem was detected (starting at 1).\n- column (int): The column number where the problem was located (starting at 1).\n- desc (str, optional): A human-readable description of the problem (defaults to '<no description>').\n- rule (str, optional): The identifier of the rule that detected the problem (defaults to None).\n\nAttributes:\n- line: Stores the line number of the problem.\n- column: Stores the column number of the problem.\n- desc: Stores the description of the problem.\n- rule: Stores the identifier of the rule that found the problem.\n- level: Initially set to None; will later hold the severity level of the problem (defined by the conf parameter in functions interacting with this class).\n\nThis constructor is part of the LintProblem class, which provides functionality to encapsulate information about linting issues detected by the yamllint tool, interacting with other parts of the code, especially during problem detection and reporting in the YAML linting process.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__eq__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two LintProblem instances.\n\nParameters:\n- other (LintProblem): The instance to compare against the current instance.\n\nReturns:\n- bool: True if both instances have the same line number, column number, and associated rule; otherwise, False.\n\nThis method relies on the attributes `line`, `column`, and `rule`, which are defined in the LintProblem class's `__init__` method. It is used to determine if two linting problems are identical, which can help in filtering or aggregating problems identified during YAML linting.\n\"\"\"\n```\n\n- FUNCTION NAME: _run\n  - SIGNATURE: def _run(buffer, conf, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nRun the linter on a YAML input buffer, processing any syntax errors and cosmetic problems found.\n\nParameters:\n- buffer: A string or buffered input representing the YAML content to be linted.\n- conf: A configuration object that contains linting rules and settings.\n- filepath: An optional string indicating the file path, used for ignoring specific files based on configuration.\n\nReturns:\nA generator yielding LintProblem objects that represent linting issues found in the YAML content, including both semantic issues and syntax errors.\n\nThe function first checks if the input `buffer` has the appropriate structure and then verifies whether linting should be skipped for the file based on the configuration. It uses the `get_syntax_error` function to identify any syntax errors in the YAML input, then passes the buffer to `get_cosmetic_problems` to yield cosmetic linting issues while appropriately handling directives for enabling and disabling rules. The function ensures that syntax errors are yielded in the correct order relative to other problems, avoiding redundancy in reports.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n    - yamllint/parser.py:Line:content\n    - yamllint/parser.py:line_generator\n    - yamllint/linter.py:get_cosmetic_problems\n    - yamllint/linter.py:get_syntax_error\n\n## FILE 2: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __lt__(self, other):\n        return self.line < other.line or (self.line == other.line and self.column < other.column)\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}