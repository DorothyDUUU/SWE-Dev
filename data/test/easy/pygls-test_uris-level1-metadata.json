{
  "dir_path": "/app/pygls",
  "package_name": "pygls",
  "sample_name": "pygls-test_uris",
  "src_dir": "pygls/",
  "test_dir": "tests/",
  "test_file": "tests/test_uris.py",
  "test_code": "############################################################################\n# Original work Copyright 2018 Palantir Technologies, Inc.                 #\n# Original work licensed under the MIT License.                            #\n# See ThirdPartyNotices.txt in the project root for license information.   #\n# All modifications Copyright (c) Open Law Library. All rights reserved.   #\n#                                                                          #\n# Licensed under the Apache License, Version 2.0 (the \"License\")           #\n# you may not use this file except in compliance with the License.         #\n# You may obtain a copy of the License at                                  #\n#                                                                          #\n#     http: // www.apache.org/licenses/LICENSE-2.0                         #\n#                                                                          #\n# Unless required by applicable law or agreed to in writing, software      #\n# distributed under the License is distributed on an \"AS IS\" BASIS,        #\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #\n# See the License for the specific language governing permissions and      #\n# limitations under the License.                                           #\n############################################################################\nimport pytest\n\nfrom pygls import uris\nfrom . import unix_only, windows_only\n\n\n@unix_only\n@pytest.mark.parametrize(\n    \"path,uri\",\n    [\n        (\"/foo/bar\", \"file:///foo/bar\"),\n        (\"/foo/space ?bar\", \"file:///foo/space%20%3Fbar\"),\n    ],\n)\ndef test_from_fs_path(path, uri):\n    assert uris.from_fs_path(path) == uri\n\n\n@unix_only\n@pytest.mark.parametrize(\n    \"uri,path\",\n    [\n        (\"file:///foo/bar#frag\", \"/foo/bar\"),\n        (\"file:/foo/bar#frag\", \"/foo/bar\"),\n        (\"file:/foo/space%20%3Fbar#frag\", \"/foo/space ?bar\"),\n    ],\n)\ndef test_to_fs_path(uri, path):\n    assert uris.to_fs_path(uri) == path\n\n\n@pytest.mark.parametrize(\n    \"uri,kwargs,new_uri\",\n    [\n        (\"file:///foo/bar\", {\"path\": \"/baz/boo\"}, \"file:///baz/boo\"),\n        (\n            \"file:///D:/hello%20world.py\",\n            {\"path\": \"D:/hello universe.py\"},\n            \"file:///d:/hello%20universe.py\",\n        ),\n    ],\n)\ndef test_uri_with(uri, kwargs, new_uri):\n    assert uris.uri_with(uri, **kwargs) == new_uri\n\n\n@windows_only\n@pytest.mark.parametrize(\n    \"path,uri\",\n    [\n        (\"c:\\\\far\\\\boo\", \"file:///c:/far/boo\"),\n        (\"C:\\\\far\\\\space ?boo\", \"file:///c:/far/space%20%3Fboo\"),\n    ],\n)\ndef test_win_from_fs_path(path, uri):\n    assert uris.from_fs_path(path) == uri\n\n\n@windows_only\n@pytest.mark.parametrize(\n    \"uri,path\",\n    [\n        (\"file:///c:/far/boo\", \"c:\\\\far\\\\boo\"),\n        (\"file:///C:/far/boo\", \"c:\\\\far\\\\boo\"),\n        (\"file:///C:/far/space%20%3Fboo\", \"c:\\\\far\\\\space ?boo\"),\n    ],\n)\ndef test_win_to_fs_path(uri, path):\n    assert uris.to_fs_path(uri) == path\n",
  "GT_file_code": {
    "pygls/uris.py": "############################################################################\n# Original work Copyright 2017 Palantir Technologies, Inc.                 #\n# Original work licensed under the MIT License.                            #\n# See ThirdPartyNotices.txt in the project root for license information.   #\n# All modifications Copyright (c) Open Law Library. All rights reserved.   #\n#                                                                          #\n# Licensed under the Apache License, Version 2.0 (the \"License\")           #\n# you may not use this file except in compliance with the License.         #\n# You may obtain a copy of the License at                                  #\n#                                                                          #\n#     http: // www.apache.org/licenses/LICENSE-2.0                         #\n#                                                                          #\n# Unless required by applicable law or agreed to in writing, software      #\n# distributed under the License is distributed on an \"AS IS\" BASIS,        #\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. #\n# See the License for the specific language governing permissions and      #\n# limitations under the License.                                           #\n############################################################################\n\"\"\"\nA collection of URI utilities with logic built on the VSCode URI library.\n\nhttps://github.com/Microsoft/vscode-uri/blob/e59cab84f5df6265aed18ae5f43552d3eef13bb9/lib/index.ts\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import Optional, Tuple\n\nimport re\nfrom urllib import parse\n\nfrom pygls import IS_WIN\n\nRE_DRIVE_LETTER_PATH = re.compile(r\"^\\/[a-zA-Z]:\")\n\nURLParts = Tuple[str, str, str, str, str, str]\n\n\ndef _normalize_win_path(path: str):\n    netloc = \"\"\n\n    # normalize to fwd-slashes on windows,\n    # on other systems bwd-slashes are valid\n    # filename character, eg /f\\oo/ba\\r.txt\n    if IS_WIN:\n        path = path.replace(\"\\\\\", \"/\")\n\n    # check for authority as used in UNC shares\n    # or use the path as given\n    if path[:2] == \"//\":\n        idx = path.index(\"/\", 2)\n        if idx == -1:\n            netloc = path[2:]\n        else:\n            netloc = path[2:idx]\n            path = path[idx:]\n\n    # Ensure that path starts with a slash\n    # or that it is at least a slash\n    if not path.startswith(\"/\"):\n        path = \"/\" + path\n\n    # Normalize drive paths to lower case\n    if RE_DRIVE_LETTER_PATH.match(path):\n        path = path[0] + path[1].lower() + path[2:]\n\n    return path, netloc\n\n\ndef from_fs_path(path: str):\n    \"\"\"Returns a URI for the given filesystem path.\"\"\"\n    try:\n        scheme = \"file\"\n        params, query, fragment = \"\", \"\", \"\"\n        path, netloc = _normalize_win_path(path)\n        return urlunparse((scheme, netloc, path, params, query, fragment))\n    except (AttributeError, TypeError):\n        return None\n\n\ndef to_fs_path(uri: str) -> str | None:\n    \"\"\"\n    Returns the filesystem path of the given URI.\n\n    Will handle UNC paths and normalize windows drive letters to lower-case.\n    Also uses the platform specific path separator. Will *not* validate the\n    path for invalid characters and semantics.\n    \"\"\"\n    try:\n        # scheme://netloc/path;parameters?query#fragment\n        scheme, netloc, path, _, _, _ = urlparse(uri)\n\n        if scheme != \"file\":\n            return None\n\n        if netloc and path:\n            # unc path: file://shares/c$/far/boo\n            value = f\"//{netloc}{path}\"\n\n        elif RE_DRIVE_LETTER_PATH.match(path):\n            # windows drive letter: file:///C:/far/boo\n            value = path[1].lower() + path[2:]\n\n        else:\n            # Other path\n            value = path\n\n        if IS_WIN:\n            value = value.replace(\"/\", \"\\\\\")\n\n        return value\n    except TypeError:\n        return None\n\n\ndef uri_scheme(uri: str):\n    try:\n        return urlparse(uri)[0]\n    except (TypeError, IndexError):\n        return None\n\n\n# TODO: Use `URLParts` type\ndef uri_with(\n    uri: str,\n    scheme: Optional[str] = None,\n    netloc: Optional[str] = None,\n    path: Optional[str] = None,\n    params: Optional[str] = None,\n    query: Optional[str] = None,\n    fragment: Optional[str] = None,\n):\n    \"\"\"\n    Return a URI with the given part(s) replaced.\n    Parts are decoded / encoded.\n    \"\"\"\n    old_scheme, old_netloc, old_path, old_params, old_query, old_fragment = urlparse(\n        uri\n    )\n\n    if path is None:\n        raise Exception(\"`path` must not be None\")\n\n    path, _ = _normalize_win_path(path)\n    return urlunparse(\n        (\n            scheme or old_scheme,\n            netloc or old_netloc,\n            path or old_path,\n            params or old_params,\n            query or old_query,\n            fragment or old_fragment,\n        )\n    )\n\n\ndef urlparse(uri: str):\n    \"\"\"Parse and decode the parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parse.urlparse(uri)\n    return (\n        parse.unquote(scheme),\n        parse.unquote(netloc),\n        parse.unquote(path),\n        parse.unquote(params),\n        parse.unquote(query),\n        parse.unquote(fragment),\n    )\n\n\ndef urlunparse(parts: URLParts) -> str:\n    \"\"\"Unparse and encode parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parts\n\n    # Avoid encoding the windows drive letter colon\n    if RE_DRIVE_LETTER_PATH.match(path):\n        quoted_path = path[:3] + parse.quote(path[3:])\n    else:\n        quoted_path = parse.quote(path)\n\n    return parse.urlunparse(\n        (\n            parse.quote(scheme),\n            parse.quote(netloc),\n            quoted_path,\n            parse.quote(params),\n            parse.quote(query),\n            parse.quote(fragment),\n        )\n    )\n"
  },
  "GT_src_dict": {
    "pygls/uris.py": {
      "from_fs_path": {
        "code": "def from_fs_path(path: str):\n    \"\"\"Converts a given filesystem path into a URI format. The function normalizes the path for Windows systems, handling forward slashes and UNC paths. It constructs the URI with the scheme set to \"file\" and leaves the parameters, query, and fragment empty.\n\nParameters:\n- path (str): The filesystem path to be converted into a URI.\n\nReturns:\n- str: The URI representation of the filesystem path. Returns None if an error occurs during processing, such as an invalid input type.\n\nDependencies:\n- Calls the helper function `_normalize_win_path` to format the path according to Windows conventions.\n- Utilizes the `urlunparse` function to construct the final URI, ensuring it follows the correct structure for URIs.\"\"\"\n    'Returns a URI for the given filesystem path.'\n    try:\n        scheme = 'file'\n        params, query, fragment = ('', '', '')\n        path, netloc = _normalize_win_path(path)\n        return urlunparse((scheme, netloc, path, params, query, fragment))\n    except (AttributeError, TypeError):\n        return None",
        "docstring": "Converts a given filesystem path into a URI format. The function normalizes the path for Windows systems, handling forward slashes and UNC paths. It constructs the URI with the scheme set to \"file\" and leaves the parameters, query, and fragment empty.\n\nParameters:\n- path (str): The filesystem path to be converted into a URI.\n\nReturns:\n- str: The URI representation of the filesystem path. Returns None if an error occurs during processing, such as an invalid input type.\n\nDependencies:\n- Calls the helper function `_normalize_win_path` to format the path according to Windows conventions.\n- Utilizes the `urlunparse` function to construct the final URI, ensuring it follows the correct structure for URIs.",
        "signature": "def from_fs_path(path: str):",
        "type": "Function",
        "class_signature": null
      },
      "to_fs_path": {
        "code": "def to_fs_path(uri: str) -> str | None:\n    \"\"\"Returns the filesystem path corresponding to the given URI.\n\nThis function interprets URIs formatted according to the 'file' scheme, converting them into filesystem paths usable in the local environment. It handles UNC paths (e.g., `file://shares/c$/far/boo`) and normalizes Windows drive letters to lower-case. The output path will use the platform-specific separator (e.g., backslashes on Windows). Note that this function does not perform validation on the path for invalid characters.\n\nParameters:\n- uri (str): The URI to be converted to a filesystem path.\n\nReturns:\n- str | None: The filesystem path derived from the URI, or None if the URI scheme is not 'file' or if a TypeError occurs during processing.\n\nDependencies:\n- Utilizes the `urlparse` function to decompose the URI into its components.\n- Relies on the constant `IS_WIN` to determine the current operating system and format the path accordingly.\n- Uses the regular expression `RE_DRIVE_LETTER_PATH` to identify Windows drive letter structures in the URI path.\"\"\"\n    '\\n    Returns the filesystem path of the given URI.\\n\\n    Will handle UNC paths and normalize windows drive letters to lower-case.\\n    Also uses the platform specific path separator. Will *not* validate the\\n    path for invalid characters and semantics.\\n    '\n    try:\n        scheme, netloc, path, _, _, _ = urlparse(uri)\n        if scheme != 'file':\n            return None\n        if netloc and path:\n            value = f'//{netloc}{path}'\n        elif RE_DRIVE_LETTER_PATH.match(path):\n            value = path[1].lower() + path[2:]\n        else:\n            value = path\n        if IS_WIN:\n            value = value.replace('/', '\\\\')\n        return value\n    except TypeError:\n        return None",
        "docstring": "Returns the filesystem path corresponding to the given URI.\n\nThis function interprets URIs formatted according to the 'file' scheme, converting them into filesystem paths usable in the local environment. It handles UNC paths (e.g., `file://shares/c$/far/boo`) and normalizes Windows drive letters to lower-case. The output path will use the platform-specific separator (e.g., backslashes on Windows). Note that this function does not perform validation on the path for invalid characters.\n\nParameters:\n- uri (str): The URI to be converted to a filesystem path.\n\nReturns:\n- str | None: The filesystem path derived from the URI, or None if the URI scheme is not 'file' or if a TypeError occurs during processing.\n\nDependencies:\n- Utilizes the `urlparse` function to decompose the URI into its components.\n- Relies on the constant `IS_WIN` to determine the current operating system and format the path accordingly.\n- Uses the regular expression `RE_DRIVE_LETTER_PATH` to identify Windows drive letter structures in the URI path.",
        "signature": "def to_fs_path(uri: str) -> str | None:",
        "type": "Function",
        "class_signature": null
      },
      "uri_with": {
        "code": "def uri_with(uri: str, scheme: Optional[str]=None, netloc: Optional[str]=None, path: Optional[str]=None, params: Optional[str]=None, query: Optional[str]=None, fragment: Optional[str]=None):\n    \"\"\"Return a modified URI with specified components replaced.\n\nThis function accepts a URI and allows for selective replacement of its components such as scheme, netloc, path, parameters, query, and fragment. It leverages the `urlparse` function to break down the URI into its constituent parts and the `urlunparse` function to reconstruct it after substitutions. The `_normalize_win_path` function is used to ensure the path adheres to correct formatting for Windows paths.\n\nParameters:\n- uri (str): The original URI to be modified.\n- scheme (Optional[str]): New scheme to replace the existing one, or retain the old scheme if None.\n- netloc (Optional[str]): New network location to replace the existing one, or retain the old netloc if None.\n- path (Optional[str]): New path component; must not be None.\n- params (Optional[str]): New parameters to replace the existing ones, or retain the old params if None.\n- query (Optional[str]): New query to replace the existing one, or retain the old query if None.\n- fragment (Optional[str]): New fragment to replace the existing one, or retain the old fragment if None.\n\nReturns:\n- str: The modified URI with the specified components replaced.\n\nRaises:\n- Exception: If the `path` parameter is None, an exception will be raised to enforce the requirement for a valid path.\"\"\"\n    '\\n    Return a URI with the given part(s) replaced.\\n    Parts are decoded / encoded.\\n    '\n    old_scheme, old_netloc, old_path, old_params, old_query, old_fragment = urlparse(uri)\n    if path is None:\n        raise Exception('`path` must not be None')\n    path, _ = _normalize_win_path(path)\n    return urlunparse((scheme or old_scheme, netloc or old_netloc, path or old_path, params or old_params, query or old_query, fragment or old_fragment))",
        "docstring": "Return a modified URI with specified components replaced.\n\nThis function accepts a URI and allows for selective replacement of its components such as scheme, netloc, path, parameters, query, and fragment. It leverages the `urlparse` function to break down the URI into its constituent parts and the `urlunparse` function to reconstruct it after substitutions. The `_normalize_win_path` function is used to ensure the path adheres to correct formatting for Windows paths.\n\nParameters:\n- uri (str): The original URI to be modified.\n- scheme (Optional[str]): New scheme to replace the existing one, or retain the old scheme if None.\n- netloc (Optional[str]): New network location to replace the existing one, or retain the old netloc if None.\n- path (Optional[str]): New path component; must not be None.\n- params (Optional[str]): New parameters to replace the existing ones, or retain the old params if None.\n- query (Optional[str]): New query to replace the existing one, or retain the old query if None.\n- fragment (Optional[str]): New fragment to replace the existing one, or retain the old fragment if None.\n\nReturns:\n- str: The modified URI with the specified components replaced.\n\nRaises:\n- Exception: If the `path` parameter is None, an exception will be raised to enforce the requirement for a valid path.",
        "signature": "def uri_with(uri: str, scheme: Optional[str]=None, netloc: Optional[str]=None, path: Optional[str]=None, params: Optional[str]=None, query: Optional[str]=None, fragment: Optional[str]=None):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "pygls/uris.py:from_fs_path": {
      "pygls/uris.py": {
        "_normalize_win_path": {
          "code": "def _normalize_win_path(path: str):\n    netloc = ''\n    if IS_WIN:\n        path = path.replace('\\\\', '/')\n    if path[:2] == '//':\n        idx = path.index('/', 2)\n        if idx == -1:\n            netloc = path[2:]\n        else:\n            netloc = path[2:idx]\n            path = path[idx:]\n    if not path.startswith('/'):\n        path = '/' + path\n    if RE_DRIVE_LETTER_PATH.match(path):\n        path = path[0] + path[1].lower() + path[2:]\n    return (path, netloc)",
          "docstring": "",
          "signature": "def _normalize_win_path(path: str):",
          "type": "Function",
          "class_signature": null
        },
        "urlunparse": {
          "code": "def urlunparse(parts: URLParts) -> str:\n    \"\"\"Unparse and encode parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parts\n    if RE_DRIVE_LETTER_PATH.match(path):\n        quoted_path = path[:3] + parse.quote(path[3:])\n    else:\n        quoted_path = parse.quote(path)\n    return parse.urlunparse((parse.quote(scheme), parse.quote(netloc), quoted_path, parse.quote(params), parse.quote(query), parse.quote(fragment)))",
          "docstring": "Unparse and encode parts of a URI.",
          "signature": "def urlunparse(parts: URLParts) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pygls/uris.py:to_fs_path": {
      "pygls/uris.py": {
        "urlparse": {
          "code": "def urlparse(uri: str):\n    \"\"\"Parse and decode the parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parse.urlparse(uri)\n    return (parse.unquote(scheme), parse.unquote(netloc), parse.unquote(path), parse.unquote(params), parse.unquote(query), parse.unquote(fragment))",
          "docstring": "Parse and decode the parts of a URI.",
          "signature": "def urlparse(uri: str):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pygls/uris.py:uri_with": {
      "pygls/uris.py": {
        "_normalize_win_path": {
          "code": "def _normalize_win_path(path: str):\n    netloc = ''\n    if IS_WIN:\n        path = path.replace('\\\\', '/')\n    if path[:2] == '//':\n        idx = path.index('/', 2)\n        if idx == -1:\n            netloc = path[2:]\n        else:\n            netloc = path[2:idx]\n            path = path[idx:]\n    if not path.startswith('/'):\n        path = '/' + path\n    if RE_DRIVE_LETTER_PATH.match(path):\n        path = path[0] + path[1].lower() + path[2:]\n    return (path, netloc)",
          "docstring": "",
          "signature": "def _normalize_win_path(path: str):",
          "type": "Function",
          "class_signature": null
        },
        "urlparse": {
          "code": "def urlparse(uri: str):\n    \"\"\"Parse and decode the parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parse.urlparse(uri)\n    return (parse.unquote(scheme), parse.unquote(netloc), parse.unquote(path), parse.unquote(params), parse.unquote(query), parse.unquote(fragment))",
          "docstring": "Parse and decode the parts of a URI.",
          "signature": "def urlparse(uri: str):",
          "type": "Function",
          "class_signature": null
        },
        "urlunparse": {
          "code": "def urlunparse(parts: URLParts) -> str:\n    \"\"\"Unparse and encode parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parts\n    if RE_DRIVE_LETTER_PATH.match(path):\n        quoted_path = path[:3] + parse.quote(path[3:])\n    else:\n        quoted_path = parse.quote(path)\n    return parse.urlunparse((parse.quote(scheme), parse.quote(netloc), quoted_path, parse.quote(params), parse.quote(query), parse.quote(fragment)))",
          "docstring": "Unparse and encode parts of a URI.",
          "signature": "def urlunparse(parts: URLParts) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pygls-test_uris\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pygls/\n    \u2514\u2500\u2500 uris.py\n        \u251c\u2500\u2500 from_fs_path\n        \u251c\u2500\u2500 to_fs_path\n        \u2514\u2500\u2500 uri_with\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates seamless bidirectional translation between file paths and URIs, ensuring compatibility across different operating systems, including Unix-based and Windows environments. It provides capabilities to convert file system paths into standardized URI formats and vice versa, handling special characters, spaces, and platform-specific nuances. Additionally, it enables modification of URI components, such as updating paths within an existing URI, to meet dynamic requirements. This module addresses the complexity of working with file paths and URIs in a cross-platform context, simplifying operations for developers and enhancing interoperability in file and resource handling workflows.\n\n## FILE 1: pygls/uris.py\n\n- FUNCTION NAME: from_fs_path\n  - SIGNATURE: def from_fs_path(path: str):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given filesystem path into a URI format. The function normalizes the path for Windows systems, handling forward slashes and UNC paths. It constructs the URI with the scheme set to \"file\" and leaves the parameters, query, and fragment empty.\n\nParameters:\n- path (str): The filesystem path to be converted into a URI.\n\nReturns:\n- str: The URI representation of the filesystem path. Returns None if an error occurs during processing, such as an invalid input type.\n\nDependencies:\n- Calls the helper function `_normalize_win_path` to format the path according to Windows conventions.\n- Utilizes the `urlunparse` function to construct the final URI, ensuring it follows the correct structure for URIs.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pygls/uris.py:urlunparse\n    - pygls/uris.py:_normalize_win_path\n\n- FUNCTION NAME: uri_with\n  - SIGNATURE: def uri_with(uri: str, scheme: Optional[str]=None, netloc: Optional[str]=None, path: Optional[str]=None, params: Optional[str]=None, query: Optional[str]=None, fragment: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a modified URI with specified components replaced.\n\nThis function accepts a URI and allows for selective replacement of its components such as scheme, netloc, path, parameters, query, and fragment. It leverages the `urlparse` function to break down the URI into its constituent parts and the `urlunparse` function to reconstruct it after substitutions. The `_normalize_win_path` function is used to ensure the path adheres to correct formatting for Windows paths.\n\nParameters:\n- uri (str): The original URI to be modified.\n- scheme (Optional[str]): New scheme to replace the existing one, or retain the old scheme if None.\n- netloc (Optional[str]): New network location to replace the existing one, or retain the old netloc if None.\n- path (Optional[str]): New path component; must not be None.\n- params (Optional[str]): New parameters to replace the existing ones, or retain the old params if None.\n- query (Optional[str]): New query to replace the existing one, or retain the old query if None.\n- fragment (Optional[str]): New fragment to replace the existing one, or retain the old fragment if None.\n\nReturns:\n- str: The modified URI with the specified components replaced.\n\nRaises:\n- Exception: If the `path` parameter is None, an exception will be raised to enforce the requirement for a valid path.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pygls/uris.py:urlunparse\n    - pygls/uris.py:_normalize_win_path\n    - pygls/uris.py:urlparse\n\n- FUNCTION NAME: to_fs_path\n  - SIGNATURE: def to_fs_path(uri: str) -> str | None:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the filesystem path corresponding to the given URI.\n\nThis function interprets URIs formatted according to the 'file' scheme, converting them into filesystem paths usable in the local environment. It handles UNC paths (e.g., `file://shares/c$/far/boo`) and normalizes Windows drive letters to lower-case. The output path will use the platform-specific separator (e.g., backslashes on Windows). Note that this function does not perform validation on the path for invalid characters.\n\nParameters:\n- uri (str): The URI to be converted to a filesystem path.\n\nReturns:\n- str | None: The filesystem path derived from the URI, or None if the URI scheme is not 'file' or if a TypeError occurs during processing.\n\nDependencies:\n- Utilizes the `urlparse` function to decompose the URI into its components.\n- Relies on the constant `IS_WIN` to determine the current operating system and format the path accordingly.\n- Uses the regular expression `RE_DRIVE_LETTER_PATH` to identify Windows drive letter structures in the URI path.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pygls/uris.py:urlparse\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pygls/uris.py": "\"\"\"\nA collection of URI utilities with logic built on the VSCode URI library.\n\nhttps://github.com/Microsoft/vscode-uri/blob/e59cab84f5df6265aed18ae5f43552d3eef13bb9/lib/index.ts\n\"\"\"\nfrom __future__ import annotations\nfrom typing import Optional, Tuple\nimport re\nfrom urllib import parse\nfrom pygls import IS_WIN\nRE_DRIVE_LETTER_PATH = re.compile('^\\\\/[a-zA-Z]:')\nURLParts = Tuple[str, str, str, str, str, str]\n\ndef _normalize_win_path(path: str):\n    netloc = ''\n    if IS_WIN:\n        path = path.replace('\\\\', '/')\n    if path[:2] == '//':\n        idx = path.index('/', 2)\n        if idx == -1:\n            netloc = path[2:]\n        else:\n            netloc = path[2:idx]\n            path = path[idx:]\n    if not path.startswith('/'):\n        path = '/' + path\n    if RE_DRIVE_LETTER_PATH.match(path):\n        path = path[0] + path[1].lower() + path[2:]\n    return (path, netloc)\n\ndef uri_scheme(uri: str):\n    try:\n        return urlparse(uri)[0]\n    except (TypeError, IndexError):\n        return None\n\ndef urlparse(uri: str):\n    \"\"\"Parse and decode the parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parse.urlparse(uri)\n    return (parse.unquote(scheme), parse.unquote(netloc), parse.unquote(path), parse.unquote(params), parse.unquote(query), parse.unquote(fragment))\n\ndef urlunparse(parts: URLParts) -> str:\n    \"\"\"Unparse and encode parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parts\n    if RE_DRIVE_LETTER_PATH.match(path):\n        quoted_path = path[:3] + parse.quote(path[3:])\n    else:\n        quoted_path = parse.quote(path)\n    return parse.urlunparse((parse.quote(scheme), parse.quote(netloc), quoted_path, parse.quote(params), parse.quote(query), parse.quote(fragment)))"
  },
  "call_tree": {
    "tests/test_uris.py:test_from_fs_path": {
      "pygls/uris.py:from_fs_path": {
        "pygls/uris.py:_normalize_win_path": {},
        "pygls/uris.py:urlunparse": {}
      }
    },
    "tests/test_uris.py:test_to_fs_path": {
      "pygls/uris.py:to_fs_path": {
        "pygls/uris.py:urlparse": {}
      }
    },
    "tests/test_uris.py:test_uri_with": {
      "pygls/uris.py:uri_with": {
        "pygls/uris.py:urlparse": {},
        "pygls/uris.py:_normalize_win_path": {},
        "pygls/uris.py:urlunparse": {}
      }
    }
  }
}