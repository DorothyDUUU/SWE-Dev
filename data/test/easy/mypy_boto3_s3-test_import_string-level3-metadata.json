{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_string",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_string.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportString:\n    def test_init(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n        assert ImportString(\"my\").render() == \"my\"\n\n        assert ImportString(\"\", \"\").render() == \".\"\n        assert ImportString(\"\", \"test\", \"my\").render() == \".test.my\"\n        assert ImportString(\"\", \"\", \"test\", \"my\").render() == \"..test.my\"\n\n        with pytest.raises(StructureError):\n            ImportString(\"\")\n        with pytest.raises(StructureError):\n            ImportString(\"test\", \"another.module\")\n        with pytest.raises(StructureError):\n            ImportString(\"my\", \"\", \"test\")\n\n    def test_from_str(self) -> None:\n        assert ImportString.from_str(\"my.module.path\").render() == \"my.module.path\"\n        assert ImportString.from_str(\".test\").render() == \".test\"\n        with pytest.raises(StructureError):\n            assert ImportString.from_str(\"\").render()\n\n    def test_operations(self) -> None:\n        assert ImportString(\"my\") < ImportString(\"test\")\n        assert ImportString(\"my\", \"test\")\n        assert hash(ImportString(\"my\")) != hash(ImportString(\"test\"))\n\n        with pytest.raises(BuildInternalError):\n            assert ImportString(\"my\") + ImportString(\"test\") == \"my.test\"\n\n    def test_render(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n\n    def test_parent(self) -> None:\n        assert ImportString(\"my\", \"module\").parent == \"my\"\n        assert not ImportString(\"\", \"\").parent\n\n    def test_is_builtins(self) -> None:\n        assert ImportString(\"builtins\").is_builtins()\n        assert ImportString(\"builtins\", \"type\").is_builtins()\n        assert not ImportString(\"other\").is_builtins()\n        assert not ImportString(\"type_defs\").is_builtins()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_type_defs(self) -> None:\n        assert ImportString(\"type_defs\").is_type_defs()\n        assert ImportString(\"service\", \"type_defs\").is_type_defs()\n        assert not ImportString(\"builtins\").is_type_defs()\n        assert not ImportString(\"other\").is_type_defs()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_third_party(self) -> None:\n        assert not ImportString(\"type_defs\").is_third_party()\n        assert not ImportString(\"builtins\").is_third_party()\n        assert not ImportString(\"other\").is_third_party()\n        assert ImportString(\"boto3\").is_third_party()\n        assert ImportString(\"boto3\", \"test\").is_third_party()\n        assert ImportString(\"botocore\").is_third_party()\n        assert ImportString(\"botocore\", \"test\").is_third_party()\n\n    def test_is_local(self) -> None:\n        assert not ImportString(\"\", \"\").is_local()\n        assert ImportString(\"mypy_boto3\", \"test\").is_local()\n        assert ImportString(\"type_defs\").is_local()\n        assert not ImportString(\"other\").is_local()\n\n    def test_comparison(self) -> None:\n        # third party\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"boto3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"asdf\")\n        assert ImportString(\"aiobotocore\", \"extra\") < ImportString(\"boto3\", \"extra\")\n\n        # local\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"mypy_boto3_s3\", \"asd\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"asdf\")\n\n        # other\n        assert ImportString(\"asdf\", \"test\") > ImportString(\"asd\", \"test\")\n        assert ImportString(\"asdf\", \"test\") < ImportString(\"asdf\", \"test2\")\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initialize an ImportString instance representing a Python import string.\n\nThe constructor accepts a parent module name and optional additional parts, ensuring \nthat the import structure is valid by raising a StructureError for any incorrect formats. \n\nParameters:\n    parent (str): The master module name (must not be empty).\n    *parts (str): Additional import parts (must not contain empty strings \n                  or dots).\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains \n                    a dot, or if there are empty parts following non-empty \n                    parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of all import string parts, ensuring an \n                             immutable and valid representation of the import string.\nThere's no return value as this method initializes the instance.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initialize an ImportString instance representing a Python import string.\n\nThe constructor accepts a parent module name and optional additional parts, ensuring \nthat the import structure is valid by raising a StructureError for any incorrect formats. \n\nParameters:\n    parent (str): The master module name (must not be empty).\n    *parts (str): Additional import parts (must not contain empty strings \n                  or dots).\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains \n                    a dot, or if there are empty parts following non-empty \n                    parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of all import string parts, ensuring an \n                             immutable and valid representation of the import string.\nThere's no return value as this method initializes the instance.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.from_str": {
        "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"Create an ImportString instance from a dot-separated string.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of ImportString created from the provided string.\n\nThis method leverages the constructor of the ImportString class to parse the input string and initialize the object's internal representation. It splits the input string at each dot ('.') to separate the module's name and its parts, ensuring a valid structure for Python import paths.\"\"\"\n        '\\n        Create from string.\\n        '\n        return cls(*import_string.split('.'))",
        "docstring": "Create an ImportString instance from a dot-separated string.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of ImportString created from the provided string.\n\nThis method leverages the constructor of the ImportString class to parse the input string and initialize the object's internal representation. It splits the input string at each dot ('.') to separate the module's name and its parts, ensuring a valid structure for Python import paths.",
        "signature": "def from_str(cls, import_string: str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the ImportString instance based on its components.\n\nThis method uses Python's built-in `hash` function on the `parts` attribute of the ImportString instance, which is a tuple containing the master module name and any additional import parts provided during initialization. This allows the ImportString instances to be used in hash-based collections, such as sets and dictionaries.\n\nReturns:\n    int: The hash value for the ImportString instance.\n\nNo parameters are required for this method, and it does not have any side effects. It relies on the `parts` attribute, which is defined in the class constructor and is a Final tuple of strings.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate the hash value for the ImportString instance based on its components.\n\nThis method uses Python's built-in `hash` function on the `parts` attribute of the ImportString instance, which is a tuple containing the master module name and any additional import parts provided during initialization. This allows the ImportString instances to be used in hash-based collections, such as sets and dictionaries.\n\nReturns:\n    int: The hash value for the ImportString instance.\n\nNo parameters are required for this method, and it does not have any side effects. It relies on the `parts` attribute, which is defined in the class constructor and is a Final tuple of strings.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Checks for equality between two ImportString instances based on their rendered output. The method compares the `parts` attribute of the current instance with that of another `ImportString` instance. If the other object is not an instance of ImportString, it raises a `BuildInternalError`. The `parts` attribute is a tuple containing the components of the import string, ensuring correct structure and integrity when determining equality.\"\"\"\n        '\\n        Whether import strings produce the same render.\\n        '\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
        "docstring": "Checks for equality between two ImportString instances based on their rendered output. The method compares the `parts` attribute of the current instance with that of another `ImportString` instance. If the other object is not an instance of ImportString, it raises a `BuildInternalError`. The `parts` attribute is a tuple containing the components of the import string, ensuring correct structure and integrity when determining equality.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__gt__": {
        "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"Compare import strings for sorting based on a specified logic that emulates the behavior of the `isort` library. The method takes another `ImportString` instance as a parameter and determines the ordering of the current instance relative to it.\n\nParameters:\n- other (Self): The `ImportString` instance to compare against.\n\nReturns:\n- bool: Returns `True` if the current instance should be ordered greater than the `other` instance based on the criteria defined in the method. Returns `False` if they are equal.\n\nThe comparison prioritizes whether the imports are local modules, third-party modules, and finally sorts by the full import path (parts). It uses the methods `is_local` and `is_third_party` to check the type of import. The constants `_THIRD_PARTY` define what constitutes third-party imports.\"\"\"\n        '\\n        Compare import strings for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
        "docstring": "Compare import strings for sorting based on a specified logic that emulates the behavior of the `isort` library. The method takes another `ImportString` instance as a parameter and determines the ordering of the current instance relative to it.\n\nParameters:\n- other (Self): The `ImportString` instance to compare against.\n\nReturns:\n- bool: Returns `True` if the current instance should be ordered greater than the `other` instance based on the criteria defined in the method. Returns `False` if they are equal.\n\nThe comparison prioritizes whether the imports are local modules, third-party modules, and finally sorts by the full import path (parts). It uses the methods `is_local` and `is_third_party` to check the type of import. The constants `_THIRD_PARTY` define what constitutes third-party imports.",
        "signature": "def __gt__(self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__add__": {
        "code": "    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"Create a new ImportString instance by appending the parts of another ImportString or string to the current instance. \n\nParameters:\n- other (Self | str): An ImportString instance or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new ImportString object that includes the parts of the current instance followed by those of the appended instance.\n\nThis method leverages the __class__ property to ensure the new instance is of the same type as the current instance, maintaining the integrity of the ImportString structure defined in the constructor.\"\"\"\n        '\\n        Create a new import string by adding another import string parts to the end.\\n        '\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)",
        "docstring": "Create a new ImportString instance by appending the parts of another ImportString or string to the current instance. \n\nParameters:\n- other (Self | str): An ImportString instance or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new ImportString object that includes the parts of the current instance followed by those of the appended instance.\n\nThis method leverages the __class__ property to ensure the new instance is of the same type as the current instance, maintaining the integrity of the ImportString structure defined in the constructor.",
        "signature": "def __add__(self: Self, other: Self | str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string to its proper string representation.\n\nReturns:\n    str: A dot-separated string representing the complete import path formed by combining all parts of the ImportString instance.\n\nThis method utilizes the `self.parts` attribute, which is a tuple that holds all components of the import path as defined during the initialization of the ImportString instance. The join operation consolidates these parts into a single string, suitable for use in Python import statements.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string to its proper string representation.\n\nReturns:\n    str: A dot-separated string representing the complete import path formed by combining all parts of the ImportString instance.\n\nThis method utilizes the `self.parts` attribute, which is a tuple that holds all components of the import path as defined during the initialization of the ImportString instance. The join operation consolidates these parts into a single string, suitable for use in Python import statements.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.parent": {
        "code": "    def parent(self) -> str:\n        \"\"\"Get the first part of the import string, representing the parent module.\n\nThis property returns the initial component of the import string, which is stored in the `parts` attribute of the `ImportString` instance. If the `parent` is an empty string, it defaults to the `builtins` module, as defined by the `BUILTINS` constant in the `ImportString` class. This is crucial for identifying whether the import is from a standard library or a custom module.\n\nReturns:\n    str: The first part of the import string or 'builtins' if it's empty.\"\"\"\n        '\\n        Get first import string part or `builtins`.\\n        '\n        return self.parts[0]",
        "docstring": "Get the first part of the import string, representing the parent module.\n\nThis property returns the initial component of the import string, which is stored in the `parts` attribute of the `ImportString` instance. If the `parent` is an empty string, it defaults to the `builtins` module, as defined by the `BUILTINS` constant in the `ImportString` class. This is crucial for identifying whether the import is from a standard library or a custom module.\n\nReturns:\n    str: The first part of the import string or 'builtins' if it's empty.",
        "signature": "def parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_local": {
        "code": "    def is_local(self) -> bool:\n        \"\"\"Determine if the import string corresponds to a local module.\n\nThis method checks whether the parent part of the import string starts with prefixes defined in the importing context, specifically `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. If neither of those conditions is met, it further checks if the import string represents type definitions by calling the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import is from a local module; otherwise, False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that defines the service prefix for Boto3 stubs, used to identify local import strings.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that defines the service prefix for AioBotocore types, also used to identify local import strings.\n- `is_type_defs()`: A method that checks if the last part of the import string corresponds to type definitions.\"\"\"\n        '\\n        Whether import is from local module.\\n        '\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()",
        "docstring": "Determine if the import string corresponds to a local module.\n\nThis method checks whether the parent part of the import string starts with prefixes defined in the importing context, specifically `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. If neither of those conditions is met, it further checks if the import string represents type definitions by calling the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import is from a local module; otherwise, False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that defines the service prefix for Boto3 stubs, used to identify local import strings.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that defines the service prefix for AioBotocore types, also used to identify local import strings.\n- `is_type_defs()`: A method that checks if the last part of the import string corresponds to type definitions.",
        "signature": "def is_local(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_builtins": {
        "code": "    def is_builtins(self) -> bool:\n        \"\"\"Determine if the import string originates from the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, matches the `BUILTINS` constant, which is set to \"builtins\". It returns `True` if the import string is from the builtins module and `False` otherwise.\n\nNo input parameters are required. The return value is a boolean indicating the source of the import string relative to the builtins module. \n\nThe `BUILTINS` constant is defined within the `ImportString` class and serves as a reference point for comparison to identify built-in modules in Python.\"\"\"\n        '\\n        Whether import is from Python `builtins` module.\\n        '\n        return self.parent == self.BUILTINS",
        "docstring": "Determine if the import string originates from the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, matches the `BUILTINS` constant, which is set to \"builtins\". It returns `True` if the import string is from the builtins module and `False` otherwise.\n\nNo input parameters are required. The return value is a boolean indicating the source of the import string relative to the builtins module. \n\nThe `BUILTINS` constant is defined within the `ImportString` class and serves as a reference point for comparison to identify built-in modules in Python.",
        "signature": "def is_builtins(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_type_defs": {
        "code": "    def is_type_defs(self) -> bool:\n        \"\"\"Determines if the import string represents a module that is defined as a `type_defs` module.\n\nThis method checks if the last part of the import string matches the value associated with `ServiceModuleName.type_defs`, which is an enumeration representing the name of the `type_defs` module. It helps to identify whether the import is coming from a specific category of modules used in the application.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, False otherwise.\n\nDependencies:\n    - ServiceModuleName: An enumeration imported from `mypy_boto3_builder.enums.service_module_name`, which contains the value used to identify the `type_defs` module.\"\"\"\n        '\\n        Whether import is from `type_defs` module.\\n        '\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value",
        "docstring": "Determines if the import string represents a module that is defined as a `type_defs` module.\n\nThis method checks if the last part of the import string matches the value associated with `ServiceModuleName.type_defs`, which is an enumeration representing the name of the `type_defs` module. It helps to identify whether the import is coming from a specific category of modules used in the application.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, False otherwise.\n\nDependencies:\n    - ServiceModuleName: An enumeration imported from `mypy_boto3_builder.enums.service_module_name`, which contains the value used to identify the `type_defs` module.",
        "signature": "def is_type_defs(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_third_party": {
        "code": "    def is_third_party(self) -> bool:\n        \"\"\"Determine if the import string represents a third-party module.\n\nReturns:\n    bool: True if the parent module is one of the predefined third-party modules, \n          which are stored in the constant _THIRD_PARTY. Otherwise, returns False.\n\nDependencies:\n    The method relies on the instance attribute `parent`, which is the first part of the import string. \n    It checks if this `parent` exists in the _THIRD_PARTY set, which includes common third-party libraries \n    such as \"boto3\", \"botocore\", \"aioboto3\", etc., defined as a class-level constant within the ImportString class.\"\"\"\n        '\\n        Whether import is from 3rd party module.\\n        '\n        return self.parent in self._THIRD_PARTY",
        "docstring": "Determine if the import string represents a third-party module.\n\nReturns:\n    bool: True if the parent module is one of the predefined third-party modules, \n          which are stored in the constant _THIRD_PARTY. Otherwise, returns False.\n\nDependencies:\n    The method relies on the instance attribute `parent`, which is the first part of the import string. \n    It checks if this `parent` exists in the _THIRD_PARTY set, which includes common third-party libraries \n    such as \"boto3\", \"botocore\", \"aioboto3\", etc., defined as a class-level constant within the ImportString class.",
        "signature": "def is_third_party(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
  },
  "call_tree": {
    "tests/import_helpers/test_import_string.py:TestImportString:test_init": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_from_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_render": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_parent": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_builtins": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_type_defs": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_third_party": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_local": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_string\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u2514\u2500\u2500 import_string.py\n            \u251c\u2500\u2500 ImportString\n            \u251c\u2500\u2500 ImportString.__add__\n            \u251c\u2500\u2500 ImportString.__eq__\n            \u251c\u2500\u2500 ImportString.__gt__\n            \u251c\u2500\u2500 ImportString.__hash__\n            \u251c\u2500\u2500 ImportString.__init__\n            \u251c\u2500\u2500 ImportString.from_str\n            \u251c\u2500\u2500 ImportString.is_builtins\n            \u251c\u2500\u2500 ImportString.is_local\n            \u251c\u2500\u2500 ImportString.is_third_party\n            \u251c\u2500\u2500 ImportString.is_type_defs\n            \u251c\u2500\u2500 ImportString.parent\n            \u2514\u2500\u2500 ImportString.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate, manipulate, and classify Python import strings, providing functionality for generating, comparing, and identifying hierarchical structures within import paths. It supports rendering import strings into fully qualified module paths, checking their context (e.g., whether they belong to built-ins, third-party libraries, local modules, or type definitions), and determining parent-child relationships within the path structure. By offering these capabilities, the module ensures consistency and correctness in handling import statements, reducing errors in structured codebases and simplifying interactions with dynamically constructed imports in complex Python projects, such as those leveraging boto3 or type hints. This utility solves the challenge of programmatically managing imports and their categorization, making it particularly useful for developers working on tools that require precise control and validation of Python module dependencies.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportString instance representing a Python import string.\n\nThe constructor accepts a parent module name and optional additional parts, ensuring \nthat the import structure is valid by raising a StructureError for any incorrect formats. \n\nParameters:\n    parent (str): The master module name (must not be empty).\n    *parts (str): Additional import parts (must not contain empty strings \n                  or dots).\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains \n                    a dot, or if there are empty parts following non-empty \n                    parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple of all import string parts, ensuring an \n                             immutable and valid representation of the import string.\nThere's no return value as this method initializes the instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__add__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __add__(self: Self, other: Self | str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new ImportString instance by appending the parts of another ImportString or string to the current instance. \n\nParameters:\n- other (Self | str): An ImportString instance or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new ImportString object that includes the parts of the current instance followed by those of the appended instance.\n\nThis method leverages the __class__ property to ensure the new instance is of the same type as the current instance, maintaining the integrity of the ImportString structure defined in the constructor.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__gt__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __gt__(self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare import strings for sorting based on a specified logic that emulates the behavior of the `isort` library. The method takes another `ImportString` instance as a parameter and determines the ordering of the current instance relative to it.\n\nParameters:\n- other (Self): The `ImportString` instance to compare against.\n\nReturns:\n- bool: Returns `True` if the current instance should be ordered greater than the `other` instance based on the criteria defined in the method. Returns `False` if they are equal.\n\nThe comparison prioritizes whether the imports are local modules, third-party modules, and finally sorts by the full import path (parts). It uses the methods `is_local` and `is_third_party` to check the type of import. The constants `_THIRD_PARTY` define what constitutes third-party imports.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_local\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_local(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string corresponds to a local module.\n\nThis method checks whether the parent part of the import string starts with prefixes defined in the importing context, specifically `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. If neither of those conditions is met, it further checks if the import string represents type definitions by calling the `is_type_defs()` method.\n\nReturns:\n    bool: True if the import is from a local module; otherwise, False.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that defines the service prefix for Boto3 stubs, used to identify local import strings.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that defines the service prefix for AioBotocore types, also used to identify local import strings.\n- `is_type_defs()`: A method that checks if the last part of the import string corresponds to type definitions.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.from_str\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def from_str(cls, import_string: str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an ImportString instance from a dot-separated string.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of ImportString created from the provided string.\n\nThis method leverages the constructor of the ImportString class to parse the input string and initialize the object's internal representation. It splits the input string at each dot ('.') to separate the module's name and its parts, ensuring a valid structure for Python import paths.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_third_party\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_third_party(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string represents a third-party module.\n\nReturns:\n    bool: True if the parent module is one of the predefined third-party modules, \n          which are stored in the constant _THIRD_PARTY. Otherwise, returns False.\n\nDependencies:\n    The method relies on the instance attribute `parent`, which is the first part of the import string. \n    It checks if this `parent` exists in the _THIRD_PARTY set, which includes common third-party libraries \n    such as \"boto3\", \"botocore\", \"aioboto3\", etc., defined as a class-level constant within the ImportString class.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string to its proper string representation.\n\nReturns:\n    str: A dot-separated string representing the complete import path formed by combining all parts of the ImportString instance.\n\nThis method utilizes the `self.parts` attribute, which is a tuple that holds all components of the import path as defined during the initialization of the ImportString instance. The join operation consolidates these parts into a single string, suitable for use in Python import statements.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.parent\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the first part of the import string, representing the parent module.\n\nThis property returns the initial component of the import string, which is stored in the `parts` attribute of the `ImportString` instance. If the `parent` is an empty string, it defaults to the `builtins` module, as defined by the `BUILTINS` constant in the `ImportString` class. This is crucial for identifying whether the import is from a standard library or a custom module.\n\nReturns:\n    str: The first part of the import string or 'builtins' if it's empty.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the ImportString instance based on its components.\n\nThis method uses Python's built-in `hash` function on the `parts` attribute of the ImportString instance, which is a tuple containing the master module name and any additional import parts provided during initialization. This allows the ImportString instances to be used in hash-based collections, such as sets and dictionaries.\n\nReturns:\n    int: The hash value for the ImportString instance.\n\nNo parameters are required for this method, and it does not have any side effects. It relies on the `parts` attribute, which is defined in the class constructor and is a Final tuple of strings.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_type_defs\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_type_defs(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the import string represents a module that is defined as a `type_defs` module.\n\nThis method checks if the last part of the import string matches the value associated with `ServiceModuleName.type_defs`, which is an enumeration representing the name of the `type_defs` module. It helps to identify whether the import is coming from a specific category of modules used in the application.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, False otherwise.\n\nDependencies:\n    - ServiceModuleName: An enumeration imported from `mypy_boto3_builder.enums.service_module_name`, which contains the value used to identify the `type_defs` module.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_builtins\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_builtins(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string originates from the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, matches the `BUILTINS` constant, which is set to \"builtins\". It returns `True` if the import string is from the builtins module and `False` otherwise.\n\nNo input parameters are required. The return value is a boolean indicating the source of the import string relative to the builtins module. \n\nThe `BUILTINS` constant is defined within the `ImportString` class and serves as a reference point for comparison to identify built-in modules in Python.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__eq__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two ImportString instances based on their rendered output. The method compares the `parts` attribute of the current instance with that of another `ImportString` instance. If the other object is not an instance of ImportString, it raises a `BuildInternalError`. The `parts` attribute is a tuple containing the components of the import string, ensuring correct structure and integrity when determining equality.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()"
  }
}