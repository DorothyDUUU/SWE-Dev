{
  "dir_path": "/app/py_healthcheck",
  "package_name": "py_healthcheck",
  "sample_name": "py_healthcheck-environmentdump_test",
  "src_dir": "healthcheck/",
  "test_dir": "tests/",
  "test_file": "tests/unit/environmentdump_test.py",
  "test_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport os\nimport unittest\n\nfrom healthcheck import EnvironmentDump\n\ntry:\n    from collections.abc import Mapping  # only works on python 3.3+\nexcept ImportError:\n    from collections import Mapping  # type: ignore[attr-defined, no-redef]\n\n\nclass BasicEnvironmentDumpTest(unittest.TestCase):\n\n    def test_basic_check(self):\n        def custom_section():\n            return 'My custom section'\n\n        ed = EnvironmentDump()\n\n        ed.add_section('custom_section', custom_section)\n\n        message, status, headers = ed.run()\n\n        jr = json.loads(message)\n        self.assertEqual('My custom section', jr['custom_section'])\n\n    def test_custom_section_signature(self):\n        def custom_section():\n            return 'My custom section'\n\n        ed = EnvironmentDump(custom_section=custom_section)\n\n        message, status, headers = ed.run()\n\n        jr = json.loads(message)\n        self.assertEqual('My custom section', jr['custom_section'])\n\n\nclass TestEnvironmentDumpSafeDump(unittest.TestCase):\n\n    def test_should_return_safe_environment_vars(self):\n        os.environ['SOME_KEY'] = 'fake-key'\n\n        ed = EnvironmentDump()\n        message, status, headers = ed.run()\n\n        jr = json.loads(message)\n        self.assertIsInstance(jr['process']['environ'], Mapping)\n        self.assertEqual('********', jr['process']['environ']['SOME_KEY'])\n\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "GT_file_code": {
    "healthcheck/environmentdump.py": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport os\nimport platform\nimport sys\ntry:\n    from typing import Dict, Any, Tuple, Callable\nexcept ImportError:\n    # for python2\n    pass\nimport six\n\nfrom .security import safe_dict\n\n\nclass EnvironmentDump:\n    def __init__(self,\n                 include_os=True,\n                 include_python=True,\n                 include_process=True,\n                 **kwargs):\n        self.functions = {}\n        if include_os:\n            self.functions['os'] = self.get_os\n        if include_python:\n            self.functions['python'] = self.get_python\n        if include_process:\n            self.functions['process'] = self.get_process\n\n        # ads custom_sections on signature\n        for k, v in kwargs.items():\n            if k not in self.functions:\n                self.add_section(k, v)\n\n    def add_section(self, name, func):  # type: (Any, Callable) -> None\n        if name in self.functions:\n            raise Exception('The name \"{}\" is already taken.'.format(name))\n        if not hasattr(func, '__call__'):\n            self.functions[name] = lambda: func\n            return\n        self.functions[name] = func\n\n    def run(self):  # type: () -> Tuple[str, int, Dict[str, str]]\n        data = {}\n        for (name, func) in six.iteritems(self.functions):\n            data[name] = func()\n\n        return json.dumps(data, default=str), 200, {'Content-Type': 'application/json'}\n\n    def get_os(self):  # type: () -> Dict[str, Any]\n        return {'platform': sys.platform,\n                'name': os.name,\n                'uname': platform.uname()}\n\n    def get_python(self):  # type: () -> Dict[str, Any]\n        result = {'version': sys.version,\n                  'executable': sys.executable,\n                  'pythonpath': sys.path,\n                  'version_info': {'major': sys.version_info.major,\n                                   'minor': sys.version_info.minor,\n                                   'micro': sys.version_info.micro,\n                                   'releaselevel': sys.version_info.releaselevel,\n                                   'serial': sys.version_info.serial}}\n        try:\n            import pip\n            packages = {p.project_name: p.version\n                        for p in pip.get_installed_distributions()}  # type:ignore[attr-defined]\n            result['packages'] = packages\n        except AttributeError:\n            pass\n\n        return result\n\n    def get_login(self):  # type: () -> str\n        # Based on https://github.com/gitpython-developers/GitPython/pull/43/\n        # Fix for 'Inappopropirate ioctl for device' on posix systems.\n        if os.name == 'posix':\n            import pwd\n            username = pwd.getpwuid(os.geteuid()).pw_name  # type:ignore[attr-defined]\n        else:\n            username = os.environ.get('USER', os.environ.get('USERNAME', 'UNKNOWN'))\n            if username == 'UNKNOWN' and hasattr(os, 'getlogin'):\n                username = os.getlogin()\n        return username\n\n    def get_process(self):  # type:() -> Dict[str, Any]\n        return {'argv': sys.argv,\n                'cwd': os.getcwd(),\n                'user': self.get_login(),\n                'pid': os.getpid(),\n                'environ': safe_dict(os.environ)}\n"
  },
  "GT_src_dict": {
    "healthcheck/environmentdump.py": {
      "EnvironmentDump.__init__": {
        "code": "    def __init__(self, include_os=True, include_python=True, include_process=True, **kwargs):\n        \"\"\"Initializes an instance of the EnvironmentDump class, which collects environment-related information about the operating system, Python interpreter, and process details.\n\nParameters:\n- include_os (bool): If True, includes operating system information. Defaults to True.\n- include_python (bool): If True, includes Python version and package details. Defaults to True.\n- include_process (bool): If True, includes details about the current process. Defaults to True.\n- **kwargs: Additional sections can be added, where the key is the name of the section and the value is a function that returns the relevant data.\n\nThis constructor sets up the `functions` dictionary to store the methods used for gathering different environment data. If the custom section names provided in `kwargs` don't conflict with the default sections, they are added using the `add_section` method. The class depends on the `get_os`, `get_python`, and `get_process` methods to retrieve specific system information and the `safe_dict` function for handling environment variables safely.\"\"\"\n        self.functions = {}\n        if include_os:\n            self.functions['os'] = self.get_os\n        if include_python:\n            self.functions['python'] = self.get_python\n        if include_process:\n            self.functions['process'] = self.get_process\n        for k, v in kwargs.items():\n            if k not in self.functions:\n                self.add_section(k, v)",
        "docstring": "Initializes an instance of the EnvironmentDump class, which collects environment-related information about the operating system, Python interpreter, and process details.\n\nParameters:\n- include_os (bool): If True, includes operating system information. Defaults to True.\n- include_python (bool): If True, includes Python version and package details. Defaults to True.\n- include_process (bool): If True, includes details about the current process. Defaults to True.\n- **kwargs: Additional sections can be added, where the key is the name of the section and the value is a function that returns the relevant data.\n\nThis constructor sets up the `functions` dictionary to store the methods used for gathering different environment data. If the custom section names provided in `kwargs` don't conflict with the default sections, they are added using the `add_section` method. The class depends on the `get_os`, `get_python`, and `get_process` methods to retrieve specific system information and the `safe_dict` function for handling environment variables safely.",
        "signature": "def __init__(self, include_os=True, include_python=True, include_process=True, **kwargs):",
        "type": "Method",
        "class_signature": "class EnvironmentDump:"
      },
      "EnvironmentDump.add_section": {
        "code": "    def add_section(self, name, func):\n        \"\"\"Adds a custom section to the EnvironmentDump instance, associating a name with a callable function.\n\nParameters:\n- name (Any): The name of the custom section to be added. It must be unique and not already present in the instance's functions.\n- func (Callable): A callable that will be executed to retrieve information for the custom section. If func is not callable, a lambda that returns the value of func will be assigned.\n\nRaises:\n- Exception: If the provided name is already taken by an existing section in the functions dictionary.\n\nThis method interacts with the `self.functions` dictionary, which maintains a mapping of section names to their associated functions. If the name is new, it is added to `self.functions`; if it's already taken, an exception is raised to prevent overwriting existing sections.\"\"\"\n        if name in self.functions:\n            raise Exception('The name \"{}\" is already taken.'.format(name))\n        if not hasattr(func, '__call__'):\n            self.functions[name] = lambda: func\n            return\n        self.functions[name] = func",
        "docstring": "Adds a custom section to the EnvironmentDump instance, associating a name with a callable function.\n\nParameters:\n- name (Any): The name of the custom section to be added. It must be unique and not already present in the instance's functions.\n- func (Callable): A callable that will be executed to retrieve information for the custom section. If func is not callable, a lambda that returns the value of func will be assigned.\n\nRaises:\n- Exception: If the provided name is already taken by an existing section in the functions dictionary.\n\nThis method interacts with the `self.functions` dictionary, which maintains a mapping of section names to their associated functions. If the name is new, it is added to `self.functions`; if it's already taken, an exception is raised to prevent overwriting existing sections.",
        "signature": "def add_section(self, name, func):",
        "type": "Method",
        "class_signature": "class EnvironmentDump:"
      },
      "EnvironmentDump.run": {
        "code": "    def run(self):\n        \"\"\"Generates a JSON representation of the environment information by executing registered functions.\n\nThe `run` method iterates through the `functions` dictionary, executing each associated callable to gather information about the operating system, Python environment, processes, and any custom sections added by user-defined functions. The results are serialized into a JSON string.\n\nReturns:\n    Tuple[str, int, Dict[str, str]]:\n        A tuple containing:\n        - A JSON-formatted string of the collected data.\n        - An HTTP status code (200).\n        - A dictionary representing the content type, set to 'application/json'.\n\nDependencies:\n    - `six`: Used to ensure compatibility for iterating over dictionaries in a Python 2/3 compatible way.\n    - `json`: Provides functionality for converting Python objects to JSON strings.\"\"\"\n        data = {}\n        for name, func in six.iteritems(self.functions):\n            data[name] = func()\n        return (json.dumps(data, default=str), 200, {'Content-Type': 'application/json'})",
        "docstring": "Generates a JSON representation of the environment information by executing registered functions.\n\nThe `run` method iterates through the `functions` dictionary, executing each associated callable to gather information about the operating system, Python environment, processes, and any custom sections added by user-defined functions. The results are serialized into a JSON string.\n\nReturns:\n    Tuple[str, int, Dict[str, str]]:\n        A tuple containing:\n        - A JSON-formatted string of the collected data.\n        - An HTTP status code (200).\n        - A dictionary representing the content type, set to 'application/json'.\n\nDependencies:\n    - `six`: Used to ensure compatibility for iterating over dictionaries in a Python 2/3 compatible way.\n    - `json`: Provides functionality for converting Python objects to JSON strings.",
        "signature": "def run(self):",
        "type": "Method",
        "class_signature": "class EnvironmentDump:"
      }
    }
  },
  "dependency_dict": {
    "healthcheck/environmentdump.py:EnvironmentDump:run": {
      "healthcheck/environmentdump.py": {
        "EnvironmentDump.get_os": {
          "code": "    def get_os(self):\n        return {'platform': sys.platform, 'name': os.name, 'uname': platform.uname()}",
          "docstring": "",
          "signature": "def get_os(self):",
          "type": "Method",
          "class_signature": "class EnvironmentDump:"
        },
        "EnvironmentDump.get_python": {
          "code": "    def get_python(self):\n        result = {'version': sys.version, 'executable': sys.executable, 'pythonpath': sys.path, 'version_info': {'major': sys.version_info.major, 'minor': sys.version_info.minor, 'micro': sys.version_info.micro, 'releaselevel': sys.version_info.releaselevel, 'serial': sys.version_info.serial}}\n        try:\n            import pip\n            packages = {p.project_name: p.version for p in pip.get_installed_distributions()}\n            result['packages'] = packages\n        except AttributeError:\n            pass\n        return result",
          "docstring": "",
          "signature": "def get_python(self):",
          "type": "Method",
          "class_signature": "class EnvironmentDump:"
        },
        "EnvironmentDump.get_process": {
          "code": "    def get_process(self):\n        return {'argv': sys.argv, 'cwd': os.getcwd(), 'user': self.get_login(), 'pid': os.getpid(), 'environ': safe_dict(os.environ)}",
          "docstring": "",
          "signature": "def get_process(self):",
          "type": "Method",
          "class_signature": "class EnvironmentDump:"
        }
      }
    },
    "healthcheck/environmentdump.py:EnvironmentDump:__init__": {}
  },
  "PRD": "# PROJECT NAME: py_healthcheck-environmentdump_test\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 healthcheck/\n    \u2514\u2500\u2500 environmentdump.py\n        \u251c\u2500\u2500 EnvironmentDump.__init__\n        \u251c\u2500\u2500 EnvironmentDump.add_section\n        \u2514\u2500\u2500 EnvironmentDump.run\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to facilitate the creation and validation of environment dumps for system diagnostics and debugging. It provides functionality to aggregate and expose custom diagnostic information, as well as safely display environment variables while masking sensitive data. By allowing users or developers to define custom sections and integrate specific data into the dump output, the module supports enhanced flexibility and thorough system introspection. This ensures a secure and standardized way to gather critical runtime details, simplifying system monitoring and aiding in the identification and resolution of configuration or operational issues.\n\n## FILE 1: healthcheck/environmentdump.py\n\n- CLASS METHOD: EnvironmentDump.run\n  - CLASS SIGNATURE: class EnvironmentDump:\n  - SIGNATURE: def run(self):\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a JSON representation of the environment information by executing registered functions.\n\nThe `run` method iterates through the `functions` dictionary, executing each associated callable to gather information about the operating system, Python environment, processes, and any custom sections added by user-defined functions. The results are serialized into a JSON string.\n\nReturns:\n    Tuple[str, int, Dict[str, str]]:\n        A tuple containing:\n        - A JSON-formatted string of the collected data.\n        - An HTTP status code (200).\n        - A dictionary representing the content type, set to 'application/json'.\n\nDependencies:\n    - `six`: Used to ensure compatibility for iterating over dictionaries in a Python 2/3 compatible way.\n    - `json`: Provides functionality for converting Python objects to JSON strings.\n\"\"\"\n```\n\n- CLASS METHOD: EnvironmentDump.add_section\n  - CLASS SIGNATURE: class EnvironmentDump:\n  - SIGNATURE: def add_section(self, name, func):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds a custom section to the EnvironmentDump instance, associating a name with a callable function.\n\nParameters:\n- name (Any): The name of the custom section to be added. It must be unique and not already present in the instance's functions.\n- func (Callable): A callable that will be executed to retrieve information for the custom section. If func is not callable, a lambda that returns the value of func will be assigned.\n\nRaises:\n- Exception: If the provided name is already taken by an existing section in the functions dictionary.\n\nThis method interacts with the `self.functions` dictionary, which maintains a mapping of section names to their associated functions. If the name is new, it is added to `self.functions`; if it's already taken, an exception is raised to prevent overwriting existing sections.\n\"\"\"\n```\n\n- CLASS METHOD: EnvironmentDump.__init__\n  - CLASS SIGNATURE: class EnvironmentDump:\n  - SIGNATURE: def __init__(self, include_os=True, include_python=True, include_process=True, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the EnvironmentDump class, which collects environment-related information about the operating system, Python interpreter, and process details.\n\nParameters:\n- include_os (bool): If True, includes operating system information. Defaults to True.\n- include_python (bool): If True, includes Python version and package details. Defaults to True.\n- include_process (bool): If True, includes details about the current process. Defaults to True.\n- **kwargs: Additional sections can be added, where the key is the name of the section and the value is a function that returns the relevant data.\n\nThis constructor sets up the `functions` dictionary to store the methods used for gathering different environment data. If the custom section names provided in `kwargs` don't conflict with the default sections, they are added using the `add_section` method. The class depends on the `get_os`, `get_python`, and `get_process` methods to retrieve specific system information and the `safe_dict` function for handling environment variables safely.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "healthcheck/environmentdump.py": "import json\nimport os\nimport platform\nimport sys\ntry:\n    from typing import Dict, Any, Tuple, Callable\nexcept ImportError:\n    pass\nimport six\nfrom .security import safe_dict\n\nclass EnvironmentDump:\n\n    def get_os(self):\n        return {'platform': sys.platform, 'name': os.name, 'uname': platform.uname()}\n\n    def get_python(self):\n        result = {'version': sys.version, 'executable': sys.executable, 'pythonpath': sys.path, 'version_info': {'major': sys.version_info.major, 'minor': sys.version_info.minor, 'micro': sys.version_info.micro, 'releaselevel': sys.version_info.releaselevel, 'serial': sys.version_info.serial}}\n        try:\n            import pip\n            packages = {p.project_name: p.version for p in pip.get_installed_distributions()}\n            result['packages'] = packages\n        except AttributeError:\n            pass\n        return result\n\n    def get_login(self):\n        if os.name == 'posix':\n            import pwd\n            username = pwd.getpwuid(os.geteuid()).pw_name\n        else:\n            username = os.environ.get('USER', os.environ.get('USERNAME', 'UNKNOWN'))\n            if username == 'UNKNOWN' and hasattr(os, 'getlogin'):\n                username = os.getlogin()\n        return username\n\n    def get_process(self):\n        return {'argv': sys.argv, 'cwd': os.getcwd(), 'user': self.get_login(), 'pid': os.getpid(), 'environ': safe_dict(os.environ)}"
  },
  "call_tree": {
    "tests/unit/environmentdump_test.py:BasicEnvironmentDumpTest:test_basic_check": {
      "healthcheck/environmentdump.py:EnvironmentDump:__init__": {},
      "healthcheck/environmentdump.py:EnvironmentDump:add_section": {},
      "healthcheck/environmentdump.py:EnvironmentDump:run": {
        "healthcheck/environmentdump.py:EnvironmentDump:get_os": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_python": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_process": {
          "healthcheck/environmentdump.py:EnvironmentDump:get_login": {},
          "healthcheck/security.py:safe_dict": {}
        },
        "tests/unit/environmentdump_test.py:BasicEnvironmentDumpTest:custom_section": {}
      }
    },
    "tests/unit/environmentdump_test.py:BasicEnvironmentDumpTest:test_custom_section_signature": {
      "healthcheck/environmentdump.py:EnvironmentDump:__init__": {
        "healthcheck/environmentdump.py:EnvironmentDump:add_section": {}
      },
      "healthcheck/environmentdump.py:EnvironmentDump:run": {
        "healthcheck/environmentdump.py:EnvironmentDump:get_os": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_python": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_process": {
          "healthcheck/environmentdump.py:EnvironmentDump:get_login": {},
          "healthcheck/security.py:safe_dict": {}
        },
        "tests/unit/environmentdump_test.py:BasicEnvironmentDumpTest:custom_section": {}
      }
    },
    "tests/unit/environmentdump_test.py:TestEnvironmentDumpSafeDump:test_should_return_safe_environment_vars": {
      "healthcheck/environmentdump.py:EnvironmentDump:__init__": {},
      "healthcheck/environmentdump.py:EnvironmentDump:run": {
        "healthcheck/environmentdump.py:EnvironmentDump:get_os": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_python": {},
        "healthcheck/environmentdump.py:EnvironmentDump:get_process": {
          "healthcheck/environmentdump.py:EnvironmentDump:get_login": {},
          "healthcheck/security.py:safe_dict": {}
        }
      }
    }
  }
}