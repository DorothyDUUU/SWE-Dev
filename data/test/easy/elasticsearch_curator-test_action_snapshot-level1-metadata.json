{
  "dir_path": "/app/elasticsearch_curator",
  "package_name": "elasticsearch_curator",
  "sample_name": "elasticsearch_curator-test_action_snapshot",
  "src_dir": "curator/",
  "test_dir": "tests/",
  "test_file": "tests/unit/test_action_snapshot.py",
  "test_code": "\"\"\"test_action_snapshot\"\"\"\n# pylint: disable=missing-function-docstring, missing-class-docstring, line-too-long, protected-access, attribute-defined-outside-init\nfrom unittest import TestCase\nfrom unittest.mock import Mock\nfrom curator.actions import Snapshot\nfrom curator.exceptions import ActionError, CuratorException, FailedExecution, FailedSnapshot, MissingArgument, SnapshotInProgress\nfrom curator import IndexList\n# Get test variables and constants from a single source\nfrom . import testvars\n\nclass TestActionSnapshot(TestCase):\n    VERSION = {'version': {'number': '8.0.0'} }\n    def builder(self):\n        self.client = Mock()\n        self.client.info.return_value = self.VERSION\n        self.client.cat.indices.return_value = testvars.state_one\n        self.client.indices.get_settings.return_value = testvars.settings_one\n        self.client.indices.stats.return_value = testvars.stats_one\n        self.client.indices.exists_alias.return_value = False\n        self.client.snapshot.get_repository.return_value = testvars.test_repo\n        self.client.snapshot.get.return_value = testvars.snapshots\n        self.client.tasks.get.return_value = testvars.no_snap_tasks\n        self.ilo = IndexList(self.client)\n    def test_init_raise_bad_index_list(self):\n        self.assertRaises(TypeError, Snapshot, 'invalid')\n    def test_init_no_repo_arg_exception(self):\n        self.builder()\n        self.assertRaises(MissingArgument, Snapshot, self.ilo)\n    def test_init_no_repo_exception(self):\n        self.builder()\n        self.client.snapshot.get_repository.return_value = {'repo':{'foo':'bar'}}\n        self.assertRaises(ActionError, Snapshot, self.ilo, repository='notfound')\n    def test_init_no_name_exception(self):\n        self.builder()\n        self.assertRaises(MissingArgument, Snapshot, self.ilo, repository=testvars.repo_name)\n    def test_init_success(self):\n        self.builder()\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertEqual(testvars.repo_name, sso.repository)\n        self.assertIsNone(sso.state)\n    def test_get_state_success(self):\n        self.builder()\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        sso.get_state()\n        self.assertEqual('SUCCESS', sso.state)\n    def test_get_state_fail(self):\n        self.builder()\n        self.client.snapshot.get.return_value = {'snapshots':[]}\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertRaises(CuratorException, sso.get_state)\n    def test_report_state_success(self):\n        self.builder()\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        sso.report_state()\n        self.assertEqual('SUCCESS', sso.state)\n    def test_report_state_other(self):\n        self.builder()\n        self.client.snapshot.get.return_value = testvars.highly_unlikely\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertRaises(FailedSnapshot, sso.report_state)\n    def test_do_dry_run(self):\n        self.builder()\n        self.client.snapshot.create.return_value = None\n        self.client.snapshot.status.return_value = testvars.nosnap_running\n        self.client.snapshot.verify_repository.return_value = testvars.verified_nodes\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertIsNone(sso.do_dry_run())\n    def test_do_action_success(self):\n        self.builder()\n        self.client.snapshot.create.return_value = testvars.generic_task\n        self.client.tasks.get.return_value = testvars.completed_task\n        self.client.snapshot.status.return_value = testvars.nosnap_running\n        self.client.snapshot.verify_repository.return_value = testvars.verified_nodes\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertIsNone(sso.do_action())\n    def test_do_action_raise_snap_in_progress(self):\n        self.builder()\n        self.client.snapshot.create.return_value = None\n        self.client.snapshot.status.return_value = testvars.snap_running\n        self.client.snapshot.verify_repository.return_value = testvars.verified_nodes\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertRaises(SnapshotInProgress, sso.do_action)\n    def test_do_action_no_wait_for_completion(self):\n        self.builder()\n        self.client.snapshot.create.return_value = testvars.generic_task\n        self.client.snapshot.status.return_value = testvars.nosnap_running\n        self.client.snapshot.verify_repository.return_value = testvars.verified_nodes\n        sso = Snapshot(self.ilo, repository=testvars.repo_name,\n            name=testvars.snap_name, wait_for_completion=False)\n        self.assertIsNone(sso.do_action())\n    def test_do_action_raise_on_failure(self):\n        self.builder()\n        self.client.snapshot.create.return_value = None\n        self.client.snapshot.create.side_effect = testvars.fake_fail\n        self.client.snapshot.status.return_value = testvars.nosnap_running\n        self.client.snapshot.verify_repository.return_value = testvars.verified_nodes\n        sso = Snapshot(self.ilo, repository=testvars.repo_name, name=testvars.snap_name)\n        self.assertRaises(FailedExecution, sso.do_action)\n",
  "GT_file_code": {
    "curator/actions/snapshot.py": "\"\"\"Snapshot and Restore action classes\"\"\"\nimport logging\nimport re\nfrom es_client.helpers.utils import ensure_list\nfrom curator.helpers.date_ops import parse_datemath, parse_date_pattern\nfrom curator.helpers.getters import get_indices\nfrom curator.helpers.testers import (\n    repository_exists, snapshot_running, verify_index_list, verify_repository, verify_snapshot_list\n)\nfrom curator.helpers.utils import report_failure, to_csv\nfrom curator.helpers.waiters import wait_for_it\n# pylint: disable=broad-except\nfrom curator.exceptions import (\n        ActionError, CuratorException, FailedRestore, FailedSnapshot, MissingArgument,\n        SnapshotInProgress\n    )\n\nclass Snapshot(object):\n    \"\"\"Snapshot Action Class\n\n    Read more about identically named settings at:\n    :py:meth:`elasticsearch.client.SnapshotClient.create`\n    \"\"\"\n    def __init__(self, ilo, repository=None, name=None, ignore_unavailable=False,\n        include_global_state=True, partial=False, wait_for_completion=True, wait_interval=9,\n        max_wait=-1, skip_repo_fs_check=True\n    ):\n        \"\"\"\n        :param ilo: An IndexList Object\n        :param repository: Repository name.\n        :param name: Snapshot name.\n        :param ignore_unavailable: Ignore unavailable shards/indices.\n        :param include_global_state: Store cluster global state with snapshot.\n        :param partial: Do not fail if primary shard is unavailable.\n        :param wait_for_completion: Wait for completion before returning.\n        :param wait_interval: Seconds to wait between completion checks.\n        :param max_wait: Maximum number of seconds to ``wait_for_completion``\n        :param skip_repo_fs_check: Do not validate write access to repository on all cluster nodes\n            before proceeding. Useful for shared filesystems where intermittent timeouts can affect\n            validation, but won't likely affect snapshot success. (Default: ``True``)\n\n        :type ilo: :py:class:`~.curator.indexlist.IndexList`\n        :type repository: str\n        :type name: str\n        :type ignore_unavailable: bool\n        :type include_global_state: bool\n        :type partial: bool\n        :type wait_for_completion: bool\n        :type wait_interval: int\n        :type max_wait: int\n        :type skip_repo_fs_check: bool\n        \"\"\"\n        verify_index_list(ilo)\n        # Check here and don't bother with the rest of this if there are no\n        # indices in the index list.\n        ilo.empty_list_check()\n        if not repository_exists(ilo.client, repository=repository):\n            raise ActionError(\n                f'Cannot snapshot indices to missing repository: {repository}')\n        if not name:\n            raise MissingArgument('No value for \"name\" provided.')\n        #: The :py:class:`~.curator.indexlist.IndexList` object passed from param ``ilo``\n        self.index_list = ilo\n        #: The :py:class:`~.elasticsearch.Elasticsearch` client object derived from\n        #: :py:attr:`index_list`\n        self.client = ilo.client\n        #: The :py:func:`~.curator.helpers.date_ops.parse_date_pattern` rendered\n        #: version of what was passed by param ``name``.\n        self.name = parse_datemath(self.client, parse_date_pattern(name))\n        #: Object attribute that gets the value of param ``repository``.\n        self.repository = repository\n        #: Object attribute that gets the value of param ``wait_for_completion``.\n        self.wait_for_completion = wait_for_completion\n        #: Object attribute that gets the value of param ``wait_interval``.\n        self.wait_interval = wait_interval\n        #: Object attribute that gets the value of param ``max_wait``.\n        self.max_wait = max_wait\n        #: Object attribute that gets the value of param ``skip_repo_fs_check``.\n        self.skip_repo_fs_check = skip_repo_fs_check\n        #: Object attribute that tracks the snapshot state.\n        self.state = None\n        #: Object attribute that contains the :py:func:`~.curator.helpers.utils.to_csv` output of\n        #: the indices in :py:attr:`index_list`.\n        self.indices = to_csv(ilo.indices)\n        #: Object attribute that gets the value of param ``ignore_unavailable``.\n        self.ignore_unavailable = ignore_unavailable\n        #: Object attribute that gets the value of param ``include_global_state``.\n        self.include_global_state = include_global_state\n        #: Object attribute that gets the value of param ``partial``.\n        self.partial = partial\n        #: Object attribute dictionary compiled from :py:attr:`indices`,\n        #: :py:attr:`ignore_unavailable`, :py:attr:`include_global_state`, and :py:attr:`partial`\n        self.settings = {\n            'indices': ilo.indices,\n            'ignore_unavailable': self.ignore_unavailable,\n            'include_global_state': self.include_global_state,\n            'partial': self.partial\n        }\n\n        self.loggit = logging.getLogger('curator.actions.snapshot')\n\n    def get_state(self):\n        \"\"\"Get the state of the snapshot and set :py:attr:`state`\"\"\"\n        try:\n            self.state = self.client.snapshot.get(\n                repository=self.repository, snapshot=self.name)['snapshots'][0]['state']\n            return self.state\n        except IndexError as exc:\n            raise CuratorException(\n                f'Snapshot \"{self.name}\" not found in repository \"{self.repository}\"') from exc\n\n    def report_state(self):\n        \"\"\"\n        Log the :py:attr:`state` of the snapshot and raise :py:exc:`FailedSnapshot` if\n        :py:attr:`state` is not ``SUCCESS``\n        \"\"\"\n        self.get_state()\n        if self.state == 'SUCCESS':\n            self.loggit.info('Snapshot %s successfully completed.', self.name)\n        else:\n            msg = f'Snapshot {self.name} completed with state: {self.state}'\n            self.loggit.error(msg)\n            raise FailedSnapshot(msg)\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        msg = (\n            f'DRY-RUN: snapshot: {self.name} in repository {self.repository} '\n            f'with arguments: {self.settings}'\n        )\n        self.loggit.info(msg)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`elasticsearch.client.SnapshotClient.create` a snapshot of :py:attr:`indices`,\n        with passed parameters.\n        \"\"\"\n        if not self.skip_repo_fs_check:\n            verify_repository(self.client, self.repository)\n        if snapshot_running(self.client):\n            raise SnapshotInProgress('Snapshot already in progress.')\n        try:\n            self.loggit.info(\n                'Creating snapshot \"%s\" from indices: %s', self.name, self.index_list.indices)\n            # Always set wait_for_completion to False. Let 'wait_for_it' do its\n            # thing if wait_for_completion is set to True. Report the task_id\n            # either way.\n            self.client.snapshot.create(\n                repository=self.repository,\n                snapshot=self.name,\n                ignore_unavailable=self.ignore_unavailable,\n                include_global_state=self.include_global_state,\n                indices=self.indices,\n                partial=self.partial,\n                wait_for_completion=False\n            )\n            if self.wait_for_completion:\n                wait_for_it(\n                    self.client, 'snapshot', snapshot=self.name,\n                    repository=self.repository,\n                    wait_interval=self.wait_interval, max_wait=self.max_wait\n                )\n                self.report_state()\n            else:\n                msg = (\n                    f'\"wait_for_completion\" set to {self.wait_for_completion}. '\n                    f'Remember to check for successful completion manually.'\n                )\n                self.loggit.warning(msg)\n        except Exception as err:\n            report_failure(err)\n\nclass DeleteSnapshots:\n    \"\"\"Delete Snapshots Action Class\"\"\"\n    def __init__(self, slo, retry_interval=120, retry_count=3):\n        \"\"\"\n        :param slo: A SnapshotList object\n        :type slo: :py:class:`~.curator.snapshotlist.SnapshotList`\n        :param retry_interval: Seconds to delay betwen retries. (Default: ``120``)\n        :type retry_interval: int\n        :param retry_count: Number of attempts to make. (Default: ``3``)\n        :type retry_count: int\n        \"\"\"\n        verify_snapshot_list(slo)\n        #: The :py:class:`~.curator.snapshotlist.SnapshotList` object passed from param ``slo``\n        self.snapshot_list = slo\n        #: The :py:class:`~.elasticsearch.Elasticsearch` client object derived from\n        #: :py:attr:`snapshot_list`\n        self.client = slo.client\n        #: Object attribute that gets the value of param ``retry_interval``.\n        self.retry_interval = retry_interval\n        #: Object attribute that gets the value of param ``retry_count``.\n        self.retry_count = retry_count\n        #: Object attribute that gets its value from :py:attr:`snapshot_list`.\n        self.repository = slo.repository\n        self.loggit = logging.getLogger('curator.actions.delete_snapshots')\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        mykwargs = {\n            'repository' : self.repository,\n            'retry_interval' : self.retry_interval,\n            'retry_count' : self.retry_count,\n        }\n        for snap in self.snapshot_list.snapshots:\n            self.loggit.info('DRY-RUN: delete_snapshot: %s with arguments: %s', snap, mykwargs)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.SnapshotClient.delete` snapshots in\n        :py:attr:`snapshot_list`. Retry up to :py:attr:`retry_count` times, pausing\n        :py:attr:`retry_interval` seconds between retries.\n        \"\"\"\n        self.snapshot_list.empty_list_check()\n        msg = (\n            f'Deleting {len(self.snapshot_list.snapshots)} '\n            f'selected snapshots: {self.snapshot_list.snapshots}'\n        )\n        self.loggit.info(msg)\n        try:\n            for snap in self.snapshot_list.snapshots:\n                self.loggit.info('Deleting snapshot %s...', snap)\n                self.client.snapshot.delete(repository=self.repository, snapshot=snap)\n        # pylint: disable=broad-except\n        except Exception as err:\n            report_failure(err)\n\nclass Restore(object):\n    \"\"\"Restore Action Class\n\n    Read more about identically named settings at:\n    :py:meth:`elasticsearch.client.SnapshotClient.restore`\n    \"\"\"\n    def __init__(\n            self, slo, name=None, indices=None, include_aliases=False, ignore_unavailable=False,\n            include_global_state=False, partial=False, rename_pattern=None,\n            rename_replacement=None, extra_settings=None, wait_for_completion=True, wait_interval=9,\n            max_wait=-1, skip_repo_fs_check=True\n    ):\n        \"\"\"\n        :param slo: A SnapshotList object\n        :param name: Name of the snapshot to restore.  If ``None``, use the most recent snapshot.\n        :param indices: Indices to restore.  If ``None``, all in the snapshot will be restored.\n        :param include_aliases: Restore aliases with the indices.\n        :param ignore_unavailable: Ignore unavailable shards/indices.\n        :param include_global_state: Restore cluster global state with snapshot.\n        :param partial: Do not fail if primary shard is unavailable.\n        :param rename_pattern: A regular expression pattern with one or more captures, e.g.\n            ``index_(.+)``\n        :param rename_replacement: A target index name pattern with `$#` numbered references to the\n            captures in ``rename_pattern``, e.g. ``restored_index_$1``\n        :param extra_settings: Index settings to apply to restored indices.\n        :param wait_for_completion: Wait for completion before returning.\n        :param wait_interval: Seconds to wait between completion checks.\n        :param max_wait: Maximum number of seconds to ``wait_for_completion``\n        :param skip_repo_fs_check: Do not validate write access to repository on all cluster nodes\n            before proceeding. Useful for shared filesystems where intermittent timeouts can affect\n            validation, but won't likely affect snapshot success. (Default: ``True``)\n\n        :type slo: :py:class:`~.curator.snapshotlist.SnapshotList`\n        :type name: str\n        :type indices: list\n        :type include_aliases: bool\n        :type ignore_unavailable: bool\n        :type include_global_state: bool\n        :type partial: bool\n        :type rename_pattern: str\n        :type rename_replacement: str\n        :type extra_settings: dict\n        :type wait_for_completion: bool\n        :type wait_interval: int\n        :type max_wait: int\n        :type skip_repo_fs_check: bool\n        \"\"\"\n        if extra_settings is None:\n            extra_settings = {}\n        self.loggit = logging.getLogger('curator.actions.snapshot')\n        verify_snapshot_list(slo)\n        # Get the most recent snapshot.\n        most_recent = slo.most_recent()\n        self.loggit.debug('\"most_recent\" snapshot: %s', most_recent)\n        #: Object attribute that gets the value of param ``name`` if not ``None``, or the output\n        #: from :py:meth:`~.curator.SnapshotList.most_recent`.\n        self.name = name if name else most_recent\n        # Stop here now, if it's not a successful snapshot.\n        if slo.snapshot_info[self.name]['state'] == 'PARTIAL' and partial:\n            self.loggit.warning('Performing restore of snapshot in state PARTIAL.')\n        elif slo.snapshot_info[self.name]['state'] != 'SUCCESS':\n            raise CuratorException(\n                'Restore operation can only be performed on snapshots with '\n                'state \"SUCCESS\", or \"PARTIAL\" if partial=True.'\n            )\n\n        #: Internal reference to `slo`\n        self.snapshot_list = slo\n        #: The :py:class:`~.elasticsearch.Elasticsearch` client object derived from\n        #: :py:attr:`snapshot_list`\n        self.client = slo.client\n        #: Object attribute that gets the value of ``repository`` from :py:attr:`snapshot_list`.\n        self.repository = slo.repository\n\n        if indices:\n            self.indices = ensure_list(indices)\n        else:\n            self.indices = slo.snapshot_info[self.name]['indices']\n        #: Object attribute that gets the value of param ``wait_for_completion``.\n        self.wfc = wait_for_completion\n        #: Object attribute that gets the value of param ``wait_interval``.\n        self.wait_interval = wait_interval\n        #: Object attribute that gets the value of param ``max_wait``.\n        self.max_wait = max_wait\n        #: Object attribute that gets the value of param ``rename_pattern``. Empty :py:class:`str`\n        #: if ``None``\n        self.rename_pattern = rename_pattern if rename_replacement is not None \\\n            else ''\n        #: Object attribute that gets the value of param ``rename_replacement``. Empty\n        #: :py:class:`str` if ``None``\n        self.rename_replacement = rename_replacement if rename_replacement \\\n            is not None else ''\n        #: Object attribute derived from :py:attr:`rename_replacement`. but with Java regex group\n        #: designations of ``$#`` converted to Python's ``\\\\#`` style.\n        self.py_rename_replacement = self.rename_replacement.replace('$', '\\\\')\n        #: Object attribute that gets the value of param ``max_wait``.\n        self.skip_repo_fs_check = skip_repo_fs_check\n\n        #: Object attribute that gets populated from other params/attributes. Deprecated, but not\n        #: removed. Lazy way to keep from updating :py:meth:`do_dry_run`. Will fix later.\n        self.body = {\n            'indices' : self.indices,\n            'include_aliases' : include_aliases,\n            'ignore_unavailable' : ignore_unavailable,\n            'include_global_state' : include_global_state,\n            'partial' : partial,\n            'rename_pattern' : self.rename_pattern,\n            'rename_replacement' : self.rename_replacement,\n        }\n        #: Object attribute that gets the value of param ``include_aliases``.\n        self.include_aliases = include_aliases\n        #: Object attribute that gets the value of param ``ignore_unavailable``.\n        self.ignore_unavailable = ignore_unavailable\n        #: Object attribute that gets the value of param ``include_global_state``.\n        self.include_global_state = include_global_state\n        #: Object attribute that gets the value of param ``include_aliases``.\n        self.include_aliases = include_aliases\n        #: Object attribute that gets the value of param ``partial``.\n        self.partial = partial\n        #: Object attribute that gets the value of param ``extra_settings``.\n        self.index_settings = None\n\n        if extra_settings:\n            self.loggit.debug('Adding extra_settings to restore body: %s',extra_settings)\n            self.index_settings = extra_settings\n            try:\n                self.body.update(extra_settings)\n            except Exception:\n                self.loggit.error('Unable to apply extra settings to restore body')\n        self.loggit.debug('REPOSITORY: %s', self.repository)\n        self.loggit.debug('WAIT_FOR_COMPLETION: %s', self.wfc)\n        self.loggit.debug('SKIP_REPO_FS_CHECK: %s', self.skip_repo_fs_check)\n        self.loggit.debug('BODY: %s', self.body)\n        # Populate the expected output index list.\n        self._get_expected_output()\n\n    def _get_expected_output(self):\n        if not self.rename_pattern and not self.rename_replacement:\n            self.expected_output = self.indices\n            return # Don't stick around if we're not replacing anything\n        self.expected_output = []\n        for index in self.indices:\n            self.expected_output.append(\n                re.sub(self.rename_pattern, self.py_rename_replacement, index)\n            )\n            msg = f'index: {index} replacement: {self.expected_output[-1]}'\n            self.loggit.debug(msg)\n\n    def report_state(self):\n        \"\"\"\n        Log the state of the restore. This should only be done if ``wait_for_completion`` is\n        ``True``, and only after completing the restore.\n        \"\"\"\n        all_indices = get_indices(self.client)\n        found_count = 0\n        missing = []\n        for index in self.expected_output:\n            if index in all_indices:\n                found_count += 1\n                self.loggit.info('Found restored index %s', index)\n            else:\n                missing.append(index)\n        if found_count == len(self.expected_output):\n            self.loggit.info('All indices appear to have been restored.')\n        else:\n            msg = f'Some of the indices do not appear to have been restored. Missing: {missing}'\n            self.loggit.error(msg)\n            raise FailedRestore(msg)\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        args = {'wait_for_completion' : self.wfc, 'body' : self.body}\n        msg = (\n            f'DRY-RUN: restore: Repository: {self.repository} '\n            f'Snapshot name: {self.name} Arguments: {args}'\n        )\n        self.loggit.info(msg)\n\n        for index in self.indices:\n            if self.rename_pattern and self.rename_replacement:\n                rmsg = f'as {re.sub(self.rename_pattern, self.py_rename_replacement, index)}'\n            else:\n                rmsg = ''\n            self.loggit.info('DRY-RUN: restore: Index %s %s', index, rmsg)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.SnapshotClient.restore` :py:attr:`indices` from\n        :py:attr:`name` with passed params.\n        \"\"\"\n        if not self.skip_repo_fs_check:\n            verify_repository(self.client, self.repository)\n        if snapshot_running(self.client):\n            raise SnapshotInProgress('Cannot restore while a snapshot is in progress.')\n        try:\n            self.loggit.info('Restoring indices \"%s\" from snapshot: %s', self.indices, self.name)\n            # Always set wait_for_completion to False. Let 'wait_for_it' do its\n            # thing if wait_for_completion is set to True. Report the task_id\n            # either way.\n            self.client.snapshot.restore(\n                repository=self.repository,\n                snapshot=self.name,\n                ignore_index_settings=None,\n                ignore_unavailable=self.ignore_unavailable,\n                include_aliases=self.include_aliases,\n                include_global_state=self.include_global_state,\n                index_settings=self.index_settings,\n                indices=self.indices,\n                partial=self.partial,\n                rename_pattern=self.rename_pattern,\n                rename_replacement=self.rename_replacement,\n                wait_for_completion=False\n            )\n            if self.wfc:\n                wait_for_it(\n                    self.client, 'restore', index_list=self.expected_output,\n                    wait_interval=self.wait_interval, max_wait=self.max_wait\n                )\n                self.report_state()\n            else:\n                msg = (\n                    f'\"wait_for_completion\" set to {self.wfc}. '\n                    f'Remember to check for successful completion manually.'\n                )\n                self.loggit.warning(msg)\n        except Exception as err:\n            report_failure(err)\n",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\"\n",
    "curator/indexlist.py": "\"\"\"Index List Class\"\"\"\n\nimport re\nimport itertools\nimport logging\nfrom elasticsearch8.exceptions import NotFoundError, TransportError\nfrom es_client.helpers.schemacheck import SchemaCheck\nfrom es_client.helpers.utils import ensure_list\nfrom curator.defaults import settings\nfrom curator.exceptions import (\n    ActionError,\n    ConfigurationError,\n    MissingArgument,\n    NoIndices,\n)\nfrom curator.helpers.date_ops import (\n    absolute_date_range,\n    date_range,\n    fix_epoch,\n    get_date_regex,\n    get_point_of_reference,\n    get_unit_count_from_name,\n    TimestringSearch,\n)\nfrom curator.helpers.getters import byte_size, get_indices\nfrom curator.helpers.testers import verify_client_object\nfrom curator.helpers.utils import chunk_index_list, report_failure, to_csv\nfrom curator.validators.filter_functions import filterstructure\n\n\nclass IndexList:\n    \"\"\"IndexList class\"\"\"\n\n    def __init__(self, client, search_pattern='_all'):\n        verify_client_object(client)\n        self.loggit = logging.getLogger('curator.indexlist')\n        #: An :py:class:`~.elasticsearch.Elasticsearch` client object passed from\n        #: param ``client``\n        self.client = client\n        #: Information extracted from indices, such as segment count, age, etc.\n        #: Populated at instance creation time by private helper methods.\n        #: **Type:** :py:class:`dict`\n        self.index_info = {}\n        #: The running list of indices which will be used by one of the\n        #: :py:mod:`~.curator.actions` classes. Populated at instance creation\n        #: time by private helper methods. **Type:** :py:class:`list`\n        self.indices = []\n        #: All indices in the cluster at instance creation time.\n        #: **Type:** :py:class:`list`\n        self.all_indices = []\n        self.__get_indices(search_pattern)\n        self.age_keyfield = None\n\n    def __actionable(self, idx):\n        self.loggit.debug('Index %s is actionable and remains in the list.', idx)\n\n    def __not_actionable(self, idx):\n        self.loggit.debug('Index %s is not actionable, removing from list.', idx)\n        self.indices.remove(idx)\n\n    def __excludify(self, condition, exclude, index, msg=None):\n        if condition is True:\n            if exclude:\n                text = \"Removed from actionable list\"\n                self.__not_actionable(index)\n            else:\n                text = \"Remains in actionable list\"\n                self.__actionable(index)\n        else:\n            if exclude:\n                text = \"Remains in actionable list\"\n                self.__actionable(index)\n            else:\n                text = \"Removed from actionable list\"\n                self.__not_actionable(index)\n        if msg:\n            self.loggit.debug('%s: %s', text, msg)\n\n    def __get_indices(self, pattern):\n        \"\"\"\n        Pull all indices into ``all_indices``, then populate ``indices`` and\n        ``index_info``\n        \"\"\"\n        self.loggit.debug('Getting indices matching search_pattern: \"%s\"', pattern)\n        self.all_indices = get_indices(self.client, search_pattern=pattern)\n        self.indices = self.all_indices[:]\n        # if self.indices:\n        #     for index in self.indices:\n        #         self.__build_index_info(index)\n\n    def __build_index_info(self, index):\n        \"\"\"\n        Ensure that ``index`` is a key in ``index_info``. If not, create a\n        sub-dictionary structure under that key.\n        \"\"\"\n        self.loggit.debug('Building preliminary index metadata for %s', index)\n        if index not in self.index_info:\n            self.index_info[index] = self.__zero_values()\n\n    def __map_method(self, ftype):\n        methods = {\n            'alias': self.filter_by_alias,\n            'age': self.filter_by_age,\n            'allocated': self.filter_allocated,\n            'closed': self.filter_closed,\n            'count': self.filter_by_count,\n            'empty': self.filter_empty,\n            'forcemerged': self.filter_forceMerged,\n            'ilm': self.filter_ilm,\n            'kibana': self.filter_kibana,\n            'none': self.filter_none,\n            'opened': self.filter_opened,\n            'period': self.filter_period,\n            'pattern': self.filter_by_regex,\n            'space': self.filter_by_space,\n            'shards': self.filter_by_shards,\n            'size': self.filter_by_size,\n        }\n        return methods[ftype]\n\n    def __remove_missing(self, err):\n        \"\"\"\n        Remove missing index found in ``err`` from self.indices and return that name\n        \"\"\"\n        missing = err.info['error']['index']\n        self.loggit.warning('Index was initiallly present, but now is not: %s', missing)\n        self.loggit.debug('Removing %s from active IndexList', missing)\n        self.indices.remove(missing)\n        return missing\n\n    def __zero_values(self):\n        \"\"\"The default values for index metadata\"\"\"\n        return {\n            'age': {'creation_date': 0, 'name': 0},\n            'docs': 0,\n            'number_of_replicas': 0,\n            'number_of_shards': 0,\n            'primary_size_in_bytes': 0,\n            'routing': {},\n            'segments': 0,\n            'size_in_bytes': 0,\n            'state': '',\n        }\n\n    def _get_indices_segments(self, data):\n        return self.client.indices.segments(index=to_csv(data))['indices'].copy()\n\n    def _get_indices_settings(self, data):\n        return self.client.indices.get_settings(index=to_csv(data))\n\n    def _get_indices_stats(self, data):\n        return self.client.indices.stats(index=to_csv(data), metric='store,docs')[\n            'indices'\n        ]\n\n    def _bulk_queries(self, data, exec_func):\n        slice_number = 10\n        query_result = {}\n        loop_number = (\n            round(len(data) / slice_number)\n            if round(len(data) / slice_number) > 0\n            else 1\n        )\n        self.loggit.debug(\"Bulk Queries - number requests created: %s\", loop_number)\n        for num in range(0, loop_number):\n            if num == (loop_number - 1):\n                data_sliced = data[num * slice_number :]\n            else:\n                data_sliced = data[num * slice_number : (num + 1) * slice_number]\n            query_result.update(exec_func(data_sliced))\n        return query_result\n\n    def mitigate_alias(self, index):\n        \"\"\"\n        Mitigate when an alias is detected instead of an index name\n\n        :param index: The index name that is showing up *instead* of what was expected\n\n        :type index: str\n\n        :returns: No return value:\n        :rtype: None\n        \"\"\"\n        self.loggit.debug('BEGIN mitigate_alias')\n        self.loggit.debug(\n            'Correcting an instance where an alias name points to index \"%s\"', index\n        )\n        data = self.client.indices.get(index=index)\n        aliases = list(data[index]['aliases'])\n        if aliases:\n            for alias in aliases:\n                if alias in self.indices:\n                    self.loggit.warning(\n                        'Removing alias \"%s\" from IndexList.indices', alias\n                    )\n                    self.indices.remove(alias)\n                if alias in list(self.index_info):\n                    self.loggit.warning(\n                        'Removing alias \"%s\" from IndexList.index_info', alias\n                    )\n                    del self.index_info[alias]\n        self.loggit.debug('Adding \"%s\" to IndexList.indices', index)\n        self.indices.append(index)\n        self.loggit.debug(\n            'Adding preliminary metadata for \"%s\" to IndexList.index_info', index\n        )\n        self.__build_index_info(index)\n        self.loggit.debug('END mitigate_alias')\n\n    def alias_index_check(self, data):\n        \"\"\"\n        Check each index in data to see if it's an alias.\n        \"\"\"\n        # self.loggit.debug('BEGIN alias_index_check')\n        working_list = data[:]\n        for entry in working_list:\n            if self.client.indices.exists_alias(name=entry):\n                index = list(self.client.indices.get_alias(name=entry).keys())[0]\n                self.loggit.warning(\n                    '\"%s\" is actually an alias for index \"%s\"', entry, index\n                )\n                self.mitigate_alias(index)\n                # The mitigate_alias step ensures that the class ivars are handled\n                # properly. The following ensure that we pass back a modified list\n                data.remove(entry)\n                data.append(index)\n        # self.loggit.debug('END alias_index_check')\n        return data\n\n    def indices_exist(self, data, exec_func):\n        \"\"\"Check if indices exist. If one doesn't, remove it. Loop until all exist\"\"\"\n        self.loggit.debug('BEGIN indices_exist')\n        checking = True\n        working_list = {}\n        verified_data = self.alias_index_check(data)\n        while checking:\n            try:\n                working_list.update(exec_func(verified_data))\n            except NotFoundError as err:\n                data.remove(self.__remove_missing(err))\n                continue\n            except TransportError as err:\n                if '413' in err.errors:\n                    msg = (\n                        'Huge Payload 413 Err - Trying to get information via '\n                        'multiple requests'\n                    )\n                    self.loggit.debug(msg)\n                    working_list.update(self._bulk_queries(verified_data, exec_func))\n            checking = False\n        # self.loggit.debug('END indices_exist')\n        return working_list\n\n    def data_getter(self, data, exec_func):\n        \"\"\"\n        Function that prevents unnecessary code repetition for different data\n        getter methods\n        \"\"\"\n        self.loggit.debug('BEGIN data_getter')\n        checking = True\n        while checking:\n            working_list = self.indices_exist(data, exec_func)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        sii = self.index_info[index]\n                    except KeyError:\n                        self.loggit.warning(\n                            'Index %s was not present at IndexList initialization, '\n                            ' and may be behind an alias',\n                            index,\n                        )\n                        self.mitigate_alias(index)\n                        sii = self.index_info[index]\n                        working_list = {}\n                        try:\n                            working_list.update(self._bulk_queries(data, exec_func))\n                        except NotFoundError as err:\n                            data.remove(self.__remove_missing(err))\n                            continue\n                    yield sii, working_list[index], index\n            checking = False\n        # self.loggit.debug('END data_getter')\n\n    def population_check(self, index, key):\n        \"\"\"Verify that key is in self.index_info[index], and that it is populated\"\"\"\n        retval = True\n        # self.loggit.debug('BEGIN population_check')\n        # self.loggit.debug('population_check: %s, %s', index, key)\n        if index not in self.index_info:\n            # This is just in case the index was somehow not populated\n            self.__build_index_info(index)\n        if key not in self.index_info[index]:\n            self.index_info[index][key] = self.__zero_values()[key]\n        if self.index_info[index][key] == self.__zero_values()[key]:\n            retval = False\n        # self.loggit.debug('END population_check')\n        return retval\n\n    def needs_data(self, indices, fields):\n        \"\"\"Check for data population in self.index_info\"\"\"\n        self.loggit.debug('Indices: %s, Fields: %s', indices, fields)\n        needful = []\n        working_list = self.indices_exist(indices, self._get_indices_settings)\n        for idx in working_list:\n            count = 0\n            for field in fields:\n                # If the return value is True for this field, it means it's populated\n                if self.population_check(idx, field):\n                    count += 1\n            if count == 0:\n                # All values are the default/zero\n                needful.append(idx)\n        if fields == ['state']:\n            self.loggit.debug('Always check open/close for all passed indices')\n            needful = list(working_list.keys())\n        self.loggit.debug('These indices need data in index_info: %s', needful)\n        return needful\n\n    def get_index_settings(self):\n        \"\"\"\n        For each index in self.indices, populate ``index_info`` with:\n            creation_date\n            number_of_replicas\n            number_of_shards\n            routing information (if present)\n        \"\"\"\n        self.loggit.debug('Getting index settings -- BEGIN')\n        self.empty_list_check()\n        fields = ['age', 'number_of_replicas', 'number_of_shards', 'routing']\n        for lst in chunk_index_list(self.indices):\n            # This portion here is to ensure that we're not polling for data\n            # unless we must\n            needful = self.needs_data(lst, fields)\n            if not needful:\n                # All indices are populated with some data, so we can skip\n                # data collection\n                continue\n            # Now we only need to run on the 'needful'\n            for sii, wli, _ in self.data_getter(needful, self._get_indices_settings):\n                sii['age']['creation_date'] = fix_epoch(\n                    wli['settings']['index']['creation_date']\n                )\n                sii['number_of_replicas'] = wli['settings']['index'][\n                    'number_of_replicas'\n                ]\n                sii['number_of_shards'] = wli['settings']['index']['number_of_shards']\n                if 'routing' in wli['settings']['index']:\n                    sii['routing'] = wli['settings']['index']['routing']\n        self.loggit.debug('Getting index settings -- END')\n\n    def get_index_state(self):\n        \"\"\"\n        For each index in self.indices, populate ``index_info`` with:\n\n            state (open or closed)\n\n        from the cat API\n        \"\"\"\n        self.loggit.debug('Getting index state -- BEGIN')\n        self.empty_list_check()\n        fields = ['state']\n        for lst in chunk_index_list(self.indices):\n            # This portion here is to ensure that we're not polling for data\n            # unless we must\n            needful = self.needs_data(lst, fields)\n            # Checking state is _always_ needful.\n            resp = self.client.cat.indices(\n                index=to_csv(needful), format='json', h='index,status'\n            )\n            for entry in resp:\n                try:\n                    self.index_info[entry['index']]['state'] = entry['status']\n                except KeyError:\n                    self.loggit.warning(\n                        'Index %s was not present at IndexList initialization, '\n                        'and may be behind an alias',\n                        entry['index'],\n                    )\n                    self.mitigate_alias(entry['index'])\n                    self.index_info[entry['index']]['state'] = entry['status']\n        # self.loggit.debug('Getting index state -- END')\n\n    def get_index_stats(self):\n        \"\"\"\n        Populate ``index_info`` with index ``size_in_bytes``,\n        ``primary_size_in_bytes`` and doc count information for each index.\n        \"\"\"\n        self.loggit.debug('Getting index stats -- BEGIN')\n        self.empty_list_check()\n        fields = ['size_in_bytes', 'docs', 'primary_size_in_bytes']\n        # This ensures that the index state is populated\n        self.get_index_state()\n        # Don't populate working_list until after the get_index state as it\n        # can and will remove missing indices\n        working_list = self.working_list()\n        for index in self.working_list():\n            if self.index_info[index]['state'] == 'close':\n                working_list.remove(index)\n        if working_list:\n            index_lists = chunk_index_list(working_list)\n            for lst in index_lists:\n                # This portion here is to ensure that we're not polling for data\n                # unless we must\n                needful = self.needs_data(lst, fields)\n                if not needful:\n                    # All indices are populated with some data, so we can skip\n                    # data collection\n                    continue\n                # Now we only need to run on the 'needful'\n                for sii, wli, index in self.data_getter(\n                    needful, self._get_indices_stats\n                ):\n                    try:\n                        size = wli['total']['store']['size_in_bytes']\n                        docs = wli['total']['docs']['count']\n                        primary_size = wli['primaries']['store']['size_in_bytes']\n                        msg = (\n                            f'Index: {index}  Size: {byte_size(size)}  Docs: {docs} '\n                            f'PrimarySize: {byte_size(primary_size)}'\n                        )\n                        self.loggit.debug(msg)\n                        sii['size_in_bytes'] = size\n                        sii['docs'] = docs\n                        sii['primary_size_in_bytes'] = primary_size\n                    except KeyError:\n                        msg = f'Index stats missing for \"{index}\" -- might be closed'\n                        self.loggit.warning(msg)\n        # self.loggit.debug('Getting index stats -- END')\n\n    def get_segment_counts(self):\n        \"\"\"\n        Populate ``index_info`` with segment information for each index.\n        \"\"\"\n        self.loggit.debug('Getting index segment counts')\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            for sii, wli, _ in self.data_getter(lst, self._get_indices_segments):\n                shards = wli['shards']\n                segmentcount = 0\n                for shardnum in shards:\n                    for shard in range(0, len(shards[shardnum])):\n                        segmentcount += shards[shardnum][shard]['num_search_segments']\n                sii['segments'] = segmentcount\n\n    def empty_list_check(self):\n        \"\"\"Raise :py:exc:`~.curator.exceptions.NoIndices` if ``indices`` is empty\"\"\"\n        self.loggit.debug('Checking for empty list')\n        if not self.indices:\n            raise NoIndices('index_list object is empty.')\n\n    def working_list(self):\n        \"\"\"\n        Return the current value of ``indices`` as copy-by-value to prevent list\n        stomping during iterations\n        \"\"\"\n        # Copy by value, rather than reference to prevent list stomping during\n        # iterations\n        self.loggit.debug('Generating working list of indices')\n        return self.indices[:]\n\n    def _get_name_based_ages(self, timestring):\n        \"\"\"\n        Add indices to ``index_info`` based on the age as indicated by the index\n        name pattern, if it matches ``timestring``\n\n        :param timestring: An :py:func:`time.strftime` pattern\n        \"\"\"\n        # Check for empty list before proceeding here to prevent non-iterable condition\n        self.loggit.debug('Getting ages of indices by \"name\"')\n        self.empty_list_check()\n        tstr = TimestringSearch(timestring)\n        for index in self.working_list():\n            epoch = tstr.get_epoch(index)\n            if isinstance(epoch, int):\n                self.index_info[index]['age']['name'] = epoch\n            else:\n                msg = (\n                    f'Timestring {timestring} was not found in index {index}. '\n                    f'Removing from actionable list'\n                )\n                self.loggit.debug(msg)\n                self.indices.remove(index)\n\n    def _get_field_stats_dates(self, field='@timestamp'):\n        \"\"\"\n        Add indices to ``index_info`` based on the values the queries return, as\n        determined by the min and max aggregated values of ``field``\n\n        :param field: The field with the date value.  The field must be mapped in\n            elasticsearch as a date datatype. Default: ``@timestamp``\n        \"\"\"\n        self.loggit.debug('Cannot query closed indices. Omitting any closed indices.')\n        self.filter_closed()\n        self.loggit.debug(\n            'Cannot use field_stats with empty indices. Omitting any empty indices.'\n        )\n        self.filter_empty()\n        self.loggit.debug(\n            'Getting index date by querying indices for min & max value of %s field',\n            field,\n        )\n        self.empty_list_check()\n        index_lists = chunk_index_list(self.indices)\n        for lst in index_lists:\n            for index in lst:\n                aggs = {\n                    'min': {'min': {'field': field}},\n                    'max': {'max': {'field': field}},\n                }\n                response = self.client.search(index=index, size=0, aggs=aggs)\n                self.loggit.debug('RESPONSE: %s', response)\n                if response:\n                    try:\n                        res = response['aggregations']\n                        self.loggit.debug('res: %s', res)\n                        data = self.index_info[index]['age']\n                        data['min_value'] = fix_epoch(res['min']['value'])\n                        data['max_value'] = fix_epoch(res['max']['value'])\n                        self.loggit.debug('data: %s', data)\n                    except KeyError as exc:\n                        raise ActionError(\n                            f'Field \"{field}\" not found in index \"{index}\"'\n                        ) from exc\n\n    def _calculate_ages(\n        self, source=None, timestring=None, field=None, stats_result=None\n    ):\n        \"\"\"\n        This method initiates index age calculation based on the given parameters.\n        Exceptions are raised when they are improperly configured.\n\n        Set instance variable ``age_keyfield`` for use later, if needed.\n\n        :param source: Source of index age. Can be: ``name``, ``creation_date``,\n            or ``field_stats``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used\n            in conjunction with ``source=field_stats`` to choose whether to reference\n            the min or max result value.\n        \"\"\"\n        self.age_keyfield = source\n        if source == 'name':\n            if not timestring:\n                raise MissingArgument(\n                    'source \"name\" requires the \"timestring\" keyword argument'\n                )\n            self._get_name_based_ages(timestring)\n        elif source == 'creation_date':\n            # Nothing to do here as this comes from `get_settings` in __init__\n            pass\n        elif source == 'field_stats':\n            if not field:\n                raise MissingArgument(\n                    'source \"field_stats\" requires the \"field\" keyword argument'\n                )\n            if stats_result not in ['min_value', 'max_value']:\n                raise ValueError(f'Invalid value for \"stats_result\": {stats_result}')\n            self.age_keyfield = stats_result\n            self._get_field_stats_dates(field=field)\n        else:\n            raise ValueError(\n                f'Invalid source: {source}. Must be one of \"name\", \"creation_date\", '\n                f'\"field_stats\".'\n            )\n\n    def _sort_by_age(self, index_list, reverse=True):\n        \"\"\"\n        Take a list of indices and sort them by date.\n\n        By default, the youngest are first with ``reverse=True``, but the oldest\n        can be first by setting ``reverse=False``\n        \"\"\"\n        # Do the age-based sorting here.\n        # Build an temporary dictionary with just index and age as the key and\n        # value, respectively\n        temp = {}\n        for index in index_list:\n            try:\n                if self.index_info[index]['age'][self.age_keyfield]:\n                    temp[index] = self.index_info[index]['age'][self.age_keyfield]\n                else:\n                    msg = (\n                        f'No date for \"{index}\" in IndexList metadata. '\n                        f'Possible timestring mismatch. Excluding index \"{index}\".'\n                    )\n                    self.__excludify(True, True, index, msg)\n            except KeyError:\n                msg = (\n                    f'{index} does not have key \"{self.age_keyfield}\" in IndexList '\n                    f'metadata'\n                )\n                self.__excludify(True, True, index, msg)\n        # Sort alphabetically prior to age sort to keep sorting consistent\n        temp_tuple = sorted(temp.items(), key=lambda k: k[0], reverse=reverse)\n        # If reverse is True, this will sort so the youngest indices are first.\n        # However, if you want oldest first, set reverse to False.\n        # Effectively, this should set us up to act on everything older than\n        # meets the other set criteria. It starts as a tuple, but then becomes a list.\n        sorted_tuple = sorted(temp_tuple, key=lambda k: k[1], reverse=reverse)\n        return [x[0] for x in sorted_tuple]\n\n    def filter_by_regex(self, kind=None, value=None, exclude=False):\n        \"\"\"\n        Match indices by regular expression (pattern).\n\n        :param kind: Can be one of: ``suffix``, ``prefix``, ``regex``, or\n            ``timestring``. This option defines what ``kind`` of filter you will\n            be building.\n        :param value: Depends on ``kind``. It is the :py:func:`time.strftime` string if\n            ``kind`` is ``timestring``. It's used to build the regular expression\n            for other kinds.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by regex')\n        if kind not in ['regex', 'prefix', 'suffix', 'timestring']:\n            raise ValueError(f'{kind}: Invalid value for kind')\n        # Stop here if None or empty value, but zero is okay\n        if value == 0:\n            pass\n        elif not value:\n            raise ValueError(\n                'Invalid None value for \"value\". Cannot be \"None\" type, empty, or False'\n            )\n        if kind == 'timestring':\n            regex = settings.regex_map()[kind].format(get_date_regex(value))\n        else:\n            regex = settings.regex_map()[kind].format(value)\n        self.empty_list_check()\n        pattern = re.compile(regex)\n        for index in self.working_list():\n            self.loggit.debug('Filter by regex: Index: %s', index)\n            match = pattern.search(index)\n            if match:\n                self.__excludify(True, exclude, index)\n            else:\n                self.__excludify(False, exclude, index)\n\n    def filter_by_age(\n        self,\n        source='name',\n        direction=None,\n        timestring=None,\n        unit=None,\n        unit_count=None,\n        field=None,\n        stats_result='min_value',\n        epoch=None,\n        exclude=False,\n        unit_count_pattern=False,\n    ):\n        \"\"\"\n        Match indices by relative age calculations.\n\n        :param source: Source of index age. Can be one of ``name``, ``creation_date``,\n            or ``field_stats``\n        :param direction: Time to filter, either ``older`` or ``younger``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param unit: One of ``seconds``, ``minutes``, ``hours``, ``days``, ``weeks``,\n            ``months``, or ``years``.\n        :param unit_count: The count of ``unit``. ``unit_count`` * ``unit`` will\n            be calculated out to the relative number of seconds.\n        :param unit_count_pattern: A regular expression whose capture group identifies\n            the value for ``unit_count``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used\n            in conjunction with ``source=field_stats`` to choose whether to reference\n            the minimum or maximum result value.\n        :param epoch: An epoch timestamp used in conjunction with ``unit`` and\n            ``unit_count`` to establish a point of reference for calculations.\n            If not provided, the current time will be used.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude`` is `False`, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by age')\n        # Get timestamp point of reference, por\n        por = get_point_of_reference(unit, unit_count, epoch)\n        if not direction:\n            raise MissingArgument('Must provide a value for \"direction\"')\n        if direction not in ['older', 'younger']:\n            raise ValueError(f'Invalid value for \"direction\": {direction}')\n        # This filter requires index settings.\n        self.get_index_settings()\n        self._calculate_ages(\n            source=source, timestring=timestring, field=field, stats_result=stats_result\n        )\n        if unit_count_pattern:\n            try:\n                unit_count_matcher = re.compile(unit_count_pattern)\n            # pylint: disable=broad-except\n            except Exception as exc:\n                # We got an illegal regex, so won't be able to match anything\n                self.loggit.error(\n                    'Regular expression failure. Will not match unit count. Error: %s',\n                    exc,\n                )\n                unit_count_matcher = None\n        for index in self.working_list():\n            try:\n                remove_this_index = False\n                age = int(self.index_info[index]['age'][self.age_keyfield])\n                # if age == 0:\n                #     msg = (\n                #         f'Evaluating {index} resulted in an epoch timestamp of '\n                #         f'0, meaning there is no associated date. Removing from '\n                #         f'the actionable list.'\n                #     )\n                #     self.loggit.debug(msg)\n                #     self.indices.remove(index)\n                #     continue\n                msg = (\n                    f'Index \"{index}\" age ({age}), direction: \"{direction}\", point of '\n                    f'reference, ({por})'\n                )\n                # Because time adds to epoch, smaller numbers are actually older\n                # timestamps.\n                if unit_count_pattern:\n                    msg = (\n                        f'unit_count_pattern is set, trying to match pattern to '\n                        f'index \"{index}\"'\n                    )\n                    self.loggit.debug(msg)\n                    unit_count_from_index = get_unit_count_from_name(\n                        index, unit_count_matcher\n                    )\n                    if unit_count_from_index:\n                        self.loggit.debug(\n                            'Pattern matched, applying unit_count of  \"%s\"',\n                            unit_count_from_index,\n                        )\n                        adjustedpor = get_point_of_reference(\n                            unit, unit_count_from_index, epoch\n                        )\n                        msg = (\n                            f'Adjusting point of reference from {por} to {adjustedpor} '\n                            f'based on unit_count of {unit_count_from_index} from '\n                            f'index name'\n                        )\n                        self.loggit.debug(msg)\n                    elif unit_count == -1:\n                        # Unable to match pattern and unit_count is -1, meaning no\n                        # fallback, so this index is removed from the list\n                        msg = (\n                            f'Unable to match pattern and no fallback value set. '\n                            f'Removing index \"{index}\" from actionable list'\n                        )\n                        self.loggit.debug(msg)\n                        remove_this_index = True\n                        adjustedpor = por\n                        # necessary to avoid exception if the first index is excluded\n                    else:\n                        # Unable to match the pattern and unit_count is set, so\n                        # fall back to using unit_count for determining whether\n                        # to keep this index in the list\n                        self.loggit.debug(\n                            'Unable to match pattern using fallback value of \"%s\"',\n                            unit_count,\n                        )\n                        adjustedpor = por\n                else:\n                    adjustedpor = por\n                if direction == 'older':\n                    agetest = age < adjustedpor\n                else:\n                    agetest = age > adjustedpor\n                self.__excludify(agetest and not remove_this_index, exclude, index, msg)\n            except KeyError:\n                msg = (\n                    f'Index \"{index}\" does not meet provided criteria. '\n                    f'Removing from list.'\n                )\n                self.loggit.debug(msg)\n                self.indices.remove(index)\n\n    def filter_by_space(\n        self,\n        disk_space=None,\n        reverse=True,\n        use_age=False,\n        source='creation_date',\n        timestring=None,\n        field=None,\n        stats_result='min_value',\n        exclude=False,\n        threshold_behavior='greater_than',\n    ):\n        \"\"\"\n        Remove indices from the actionable list based on space consumed, sorted\n        reverse-alphabetically by default.  If you set ``reverse`` to ``False``,\n        it will be sorted alphabetically.\n\n        The default is usually what you will want. If only one kind of index is\n        provided--for example, indices matching ``logstash-%Y.%m.%d`` --then\n        reverse alphabetical sorting will mean the oldest will remain in the list,\n        because lower numbers in the dates mean older indices.\n\n        By setting ``reverse`` to ``False``, then ``index3`` will be deleted before\n        ``index2``, which will be deleted before ``index1``\n\n        ``use_age`` allows ordering indices by age. Age is determined by the\n        index creation date by default, but you can specify an ``source`` of\n        ``name``, ``max_value``, or ``min_value``. The ``name`` ``source`` requires\n        the timestring argument.\n\n        ``threshold_behavior``, when set to ``greater_than`` (default), includes\n        if it the index tests to be larger than ``disk_space``. When set to\n        ``less_than``, it includes if the index is smaller than ``disk_space``\n\n        :param disk_space: Filter indices over *n* gigabytes\n        :param threshold_behavior: Size to filter, either ``greater_than`` or\n            ``less_than``. Defaults to ``greater_than`` to preserve backwards\n            compatability.\n        :param reverse: The filtering direction. (default: ``True``).  Ignored if\n            ``use_age`` is ``True``\n        :param use_age: Sort indices by age.  ``source`` is required in this case.\n        :param source: Source of index age. Can be one of ``name``, ``creation_date``,\n            or ``field_stats``. Default: ``creation_date``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used if ``source=name`` is selected.\n        :param field: A timestamp field name.  Only used if ``source=field_stats``\n            is selected.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used if\n            ``source=field_stats`` is selected. It determines whether to reference\n            the minimum or maximum value of `field` in each index.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by disk space')\n        # Ensure that disk_space is a float\n        if not disk_space:\n            raise MissingArgument('No value for \"disk_space\" provided')\n        if threshold_behavior not in ['greater_than', 'less_than']:\n            raise ValueError(\n                f'Invalid value for \"threshold_behavior\": {threshold_behavior}'\n            )\n        # This filter requires both index stats and index settings\n        self.get_index_stats()\n        self.get_index_settings()\n        disk_space = float(disk_space)\n        disk_usage = 0.0\n        disk_limit = disk_space * 2**30\n        msg = (\n            'Cannot get disk usage info from closed indices. Omitting any '\n            'closed indices.'\n        )\n        self.loggit.debug(msg)\n        self.filter_closed()\n        if use_age:\n            self._calculate_ages(\n                source=source,\n                timestring=timestring,\n                field=field,\n                stats_result=stats_result,\n            )\n            # Using default value of reverse=True in self._sort_by_age()\n            self.loggit.debug('SORTING BY AGE')\n            sorted_indices = self._sort_by_age(self.working_list())\n        else:\n            # Default to sorting by index name\n            sorted_indices = sorted(self.working_list(), reverse=reverse)\n        for index in sorted_indices:\n            disk_usage += self.index_info[index]['size_in_bytes']\n            msg = (\n                f'{index}, summed disk usage is {byte_size(disk_usage)} and disk limit '\n                f'is {byte_size(disk_limit)}.'\n            )\n            if threshold_behavior == 'greater_than':\n                self.__excludify((disk_usage > disk_limit), exclude, index, msg)\n            elif threshold_behavior == 'less_than':\n                self.__excludify((disk_usage < disk_limit), exclude, index, msg)\n\n    def filter_kibana(self, exclude=True):\n        \"\"\"\n        Match any index named ``.kibana*`` in ``indices``. Older releases addressed\n        index names that no longer exist.\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering kibana indices')\n        self.empty_list_check()\n        for index in self.working_list():\n            pattern = re.compile(r'^\\.kibana.*$')\n            if pattern.match(index):\n                self.__excludify(True, exclude, index)\n            else:\n                self.__excludify(False, exclude, index)\n\n    def filter_forceMerged(self, max_num_segments=None, exclude=True):\n        \"\"\"\n        Match any index which has ``max_num_segments`` per shard or fewer in the\n        actionable list.\n\n        :param max_num_segments: Cutoff number of segments per shard.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering forceMerged indices')\n        if not max_num_segments:\n            raise MissingArgument('Missing value for \"max_num_segments\"')\n        self.loggit.debug(\n            'Cannot get segment count of closed indices. Omitting any closed indices.'\n        )\n        # This filter requires the index state (open/close), and index settings.\n        self.get_index_state()\n        self.get_index_settings()\n        self.filter_closed()\n        self.get_segment_counts()\n        for index in self.working_list():\n            # Do this to reduce long lines and make it more readable...\n            shards = int(self.index_info[index]['number_of_shards'])\n            replicas = int(self.index_info[index]['number_of_replicas'])\n            segments = int(self.index_info[index]['segments'])\n            msg = (\n                f'{index} has {shards} shard(s) + {replicas} replica(s) '\n                f'with a sum total of {segments} segments.'\n            )\n            expected_count = (shards + (shards * replicas)) * max_num_segments\n            self.__excludify((segments <= expected_count), exclude, index, msg)\n\n    def filter_closed(self, exclude=True):\n        \"\"\"\n        Filter out closed indices from ``indices``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering closed indices')\n        # This filter requires index state (open/close)\n        self.get_index_state()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['state'] == 'close'\n            self.loggit.debug(\n                'Index %s state: %s', index, self.index_info[index]['state']\n            )\n            self.__excludify(condition, exclude, index)\n\n    def filter_empty(self, exclude=True):\n        \"\"\"\n        Filter indices with a document count of zero. Indices that are closed\n        are automatically excluded from consideration due to closed indices reporting\n        a document count of zero.\n\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering empty indices')\n        # This index requires index state (open/close) and index stats\n        self.get_index_state()\n        self.get_index_stats()\n        self.filter_closed()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['docs'] == 0\n            self.loggit.debug(\n                'Index %s doc count: %s', index, self.index_info[index]['docs']\n            )\n            self.__excludify(condition, exclude, index)\n\n    def filter_opened(self, exclude=True):\n        \"\"\"\n        Filter out opened indices from ``indices``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering open indices')\n        # This filter requires index state (open/close)\n        self.get_index_state()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['state'] == 'open'\n            self.loggit.debug(\n                'Index %s state: %s', index, self.index_info[index]['state']\n            )\n            self.__excludify(condition, exclude, index)\n\n    def filter_allocated(\n        self, key=None, value=None, allocation_type='require', exclude=True\n    ):\n        \"\"\"\n        Match indices that have the routing allocation rule of ``key=value`` from\n        ``indices``\n\n        :param key: The allocation attribute to check for\n        :param value: The value to check for\n        :param allocation_type: Type of allocation to apply\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is `T`rue`\n        \"\"\"\n        self.loggit.debug('Filtering indices with shard routing allocation rules')\n        if not key:\n            raise MissingArgument('No value for \"key\" provided')\n        if not value:\n            raise MissingArgument('No value for \"value\" provided')\n        if allocation_type not in ['include', 'exclude', 'require']:\n            raise ValueError(f'Invalid \"allocation_type\": {allocation_type}')\n        # This filter requires index settings\n        self.get_index_settings()\n        self.get_index_state()\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            working_list = self._get_indices_settings(lst)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        has_routing = (\n                            working_list[index]['settings']['index']['routing'][\n                                'allocation'\n                            ][allocation_type][key]\n                            == value\n                        )\n                    except KeyError:\n                        has_routing = False\n                    # if has_routing:\n                    msg = (\n                        f'{index}: Routing (mis)match: '\n                        f'index.routing.allocation.{allocation_type}.{key}={value}.'\n                    )\n                    self.__excludify(has_routing, exclude, index, msg)\n\n    def filter_none(self):\n        \"\"\"The legendary NULL filter\"\"\"\n        self.loggit.debug('\"None\" filter selected.  No filtering will be done.')\n\n    def filter_by_alias(self, aliases=None, exclude=False):\n        \"\"\"\n        Match indices which are associated with the alias or list of aliases\n        identified by ``aliases``. Indices must appear in all aliases in list\n        ``aliases`` or a 404 error will result, leading to no indices being matched.\n\n        :param aliases: A list of alias names.\n        :type aliases: list\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices matching aliases: \"%s\"', aliases)\n        if not aliases:\n            raise MissingArgument('No value for \"aliases\" provided')\n        aliases = ensure_list(aliases)\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            try:\n                # get_alias will either return {} or a NotFoundError.\n                has_alias = list(\n                    self.client.indices.get_alias(\n                        index=to_csv(lst), name=to_csv(aliases)\n                    ).keys()\n                )\n                self.loggit.debug('has_alias: %s', has_alias)\n            except NotFoundError:\n                # if we see the NotFoundError, we need to set working_list to {}\n                has_alias = []\n            for index in lst:\n                if index in has_alias:\n                    isness = 'is'\n                    condition = True\n                else:\n                    isness = 'is not'\n                    condition = False\n                msg = f'{index} {isness} associated with aliases: {aliases}'\n                self.__excludify(condition, exclude, index, msg)\n\n    def filter_by_count(\n        self,\n        count=None,\n        reverse=True,\n        use_age=False,\n        pattern=None,\n        source='creation_date',\n        timestring=None,\n        field=None,\n        stats_result='min_value',\n        exclude=True,\n    ):\n        \"\"\"\n        Remove indices from the actionable list beyond the number ``count``, sorted\n        reverse-alphabetically by default.  If you set ``reverse=False``, it will\n        be sorted alphabetically.\n\n        The default is usually what you will want. If only one kind of index is\n        provided--for example, indices matching ``logstash-%Y.%m.%d`` -- then\n        reverse alphabetical sorting will mean the oldest will remain in the list,\n        because lower numbers in the dates mean older indices.\n\n        By setting ``reverse=False``, then ``index3`` will be deleted before\n        ``index2``, which will be deleted before ``index1``\n\n        ``use_age`` allows ordering indices by age. Age is determined by the index\n        creation date by default, but you can specify an ``source`` of ``name``,\n        ``max_value``, or ``min_value``. The ``name`` `source` requires the\n        timestring argument.\n\n        :param count: Filter indices beyond ``count``.\n        :param reverse: The filtering direction. (default: ``True``).\n        :param use_age: Sort indices by age.  ``source`` is required in this case.\n        :param pattern: Select indices to count from a regular expression pattern.\n            This pattern must have one and only one capture group. This can allow\n            a single ``count`` filter instance to operate against any number of\n            matching patterns, and keep ``count`` of each index in that group.\n            For example, given a ``pattern`` of ``'^(.*)-\\\\d{6}$'``, it will match\n            both ``rollover-000001`` and ``index-999990``, but not\n            ``logstash-2017.10.12``. Following the same example, if my cluster\n            also had ``rollover-000002`` through ``rollover-000010`` and\n            ``index-888888`` through ``index-999999``, it will process both groups\n            of indices, and include or exclude the ``count`` of each.\n        :param source: Source of index age. Can be one of ``name``,\n            ``creation_date``, or ``field_stats``. Default: ``creation_date``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used if ``source=name``.\n        :param field: A timestamp field name.  Only used if ``source=field_stats``.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used if\n            ``source=field_stats``. It determines whether to reference the minimum\n            or maximum value of ``field`` in each index.\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering indices by count')\n        if not count:\n            raise MissingArgument('No value for \"count\" provided')\n        # This filter requires index state (open/close) and index settings\n        self.get_index_state()\n        self.get_index_settings()\n        # Create a copy-by-value working list\n        working_list = self.working_list()\n        if pattern:\n            try:\n                regex = re.compile(pattern)\n                if regex.groups < 1:\n                    raise ConfigurationError(\n                        f'No regular expression group found in {pattern}'\n                    )\n                if regex.groups > 1:\n                    raise ConfigurationError(\n                        f'More than 1 regular expression group found in {pattern}'\n                    )\n                # Prune indices not matching the regular expression the object\n                # (And filtered_indices) We do not want to act on them by accident.\n                prune_these = list(\n                    filter(lambda x: regex.match(x) is None, working_list)\n                )\n                filtered_indices = working_list\n                for index in prune_these:\n                    msg = '{index} does not match regular expression {pattern}.'\n                    condition = True\n                    exclude = True\n                    self.__excludify(condition, exclude, index, msg)\n                    # also remove it from filtered_indices\n                    filtered_indices.remove(index)\n                # Presort these filtered_indices using the lambda\n                presorted = sorted(\n                    filtered_indices, key=lambda x: regex.match(x).group(1)\n                )\n            except Exception as exc:\n                raise ActionError(\n                    f'Unable to process pattern: \"{pattern}\". Error: {exc}'\n                ) from exc\n            # Initialize groups here\n            groups = []\n            # We have to pull keys k this way, but we don't need to keep them\n            # We only need g for groups\n            for _, g in itertools.groupby(\n                presorted, key=lambda x: regex.match(x).group(1)\n            ):\n                groups.append(list(g))\n        else:\n            # Since pattern will create a list of lists, and we iterate over that,\n            # we need to put our single list inside a list\n            groups = [working_list]\n        for group in groups:\n            if use_age:\n                if source != 'name':\n                    self.loggit.warning(\n                        'Cannot get age information from closed indices unless '\n                        'source=\"name\".  Omitting any closed indices.'\n                    )\n                    self.filter_closed()\n                self._calculate_ages(\n                    source=source,\n                    timestring=timestring,\n                    field=field,\n                    stats_result=stats_result,\n                )\n                # Using default value of reverse=True in self._sort_by_age()\n                sorted_indices = self._sort_by_age(group, reverse=reverse)\n            else:\n                # Default to sorting by index name\n                sorted_indices = sorted(group, reverse=reverse)\n            idx = 1\n            for index in sorted_indices:\n                msg = f'{index} is {idx} of specified count of {count}.'\n                condition = True if idx <= count else False\n                self.__excludify(condition, exclude, index, msg)\n                idx += 1\n\n    def filter_by_shards(\n        self, number_of_shards=None, shard_filter_behavior='greater_than', exclude=False\n    ):\n        \"\"\"\n        Match ``indices`` with a given shard count.\n\n        Selects all indices with a shard count ``greater_than`` ``number_of_shards``\n        by default. Use ``shard_filter_behavior`` to select indices with shard\n        count ``greater_than``, ``greater_than_or_equal``, ``less_than``,\n        ``less_than_or_equal``, or ``equal`` to ``number_of_shards``.\n\n        :param number_of_shards: shard threshold\n        :param shard_filter_behavior: Do you want to filter on ``greater_than``,\n            ``greater_than_or_equal``, ``less_than``, ``less_than_or_equal``,\n            or ``equal``?\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug(\"Filtering indices by number of shards\")\n        if not number_of_shards:\n            raise MissingArgument('No value for \"number_of_shards\" provided')\n        if shard_filter_behavior not in [\n            'greater_than',\n            'less_than',\n            'greater_than_or_equal',\n            'less_than_or_equal',\n            'equal',\n        ]:\n            raise ValueError(\n                f'Invalid value for \"shard_filter_behavior\": {shard_filter_behavior}'\n            )\n        if number_of_shards < 1 or (\n            shard_filter_behavior == 'less_than' and number_of_shards == 1\n        ):\n            raise ValueError(\n                f'Unacceptable value: {number_of_shards} -- \"number_of_shards\" cannot '\n                f'be less than 1. A valid index will have at least one shard.'\n            )\n        # This filter requires index_settings to count shards\n        self.get_index_settings()\n        self.empty_list_check()\n        for index in self.working_list():\n            self.loggit.debug('Filter by number of shards: Index: %s', index)\n            if shard_filter_behavior == 'greater_than':\n                condition = (\n                    int(self.index_info[index]['number_of_shards']) > number_of_shards\n                )\n            elif shard_filter_behavior == 'less_than':\n                condition = (\n                    int(self.index_info[index]['number_of_shards']) < number_of_shards\n                )\n            elif shard_filter_behavior == 'greater_than_or_equal':\n                condition = (\n                    int(self.index_info[index]['number_of_shards']) >= number_of_shards\n                )\n            elif shard_filter_behavior == 'less_than_or_equal':\n                condition = (\n                    int(self.index_info[index]['number_of_shards']) <= number_of_shards\n                )\n            else:\n                condition = (\n                    int(self.index_info[index]['number_of_shards']) == number_of_shards\n                )\n            self.__excludify(condition, exclude, index)\n\n    def filter_period(\n        self,\n        period_type='relative',\n        source='name',\n        range_from=None,\n        range_to=None,\n        date_from=None,\n        date_to=None,\n        date_from_format=None,\n        date_to_format=None,\n        timestring=None,\n        unit=None,\n        field=None,\n        stats_result='min_value',\n        intersect=False,\n        week_starts_on='sunday',\n        epoch=None,\n        exclude=False,\n    ):\n        \"\"\"\n        Match ``indices`` with ages within a given period.\n\n        :param period_type: Can be either ``absolute`` or ``relative``.  Default\n            is ``relative``. ``date_from`` and ``date_to`` are required when using\n            ``period_type='absolute'``. ``range_from`` and ``range_to`` are required\n            with ``period_type='relative'``.\n        :param source: Source of index age. Can be ``name``, ``creation_date``,\n            or ``field_stats``\n        :param range_from: How many ``unit`` (s) in the past/future is the origin?\n        :param range_to: How many ``unit`` (s) in the past/future is the end point?\n        :param date_from: The simplified date for the start of the range\n        :param date_to: The simplified date for the end of the range.  If this\n            value is the same as ``date_from``, the full value of ``unit`` will be\n            extrapolated for the range.  For example, if ``unit=months``, and\n            ``date_from`` and ``date_to`` are both ``2017.01``, then the entire\n            month of January 2017 will be the absolute date range.\n        :param date_from_format: The :py:func:`time.strftime` string used to\n            parse ``date_from``\n        :param date_to_format: The :py:func:`time.strftime` string used to\n            parse ``date_to``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param unit: One of ``hours``, ``days``, ``weeks``, ``months``, or ``years``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used in\n            conjunction with ``source='field_stats'`` to choose whether to reference\n            the min or max result value.\n        :param intersect: Only used when ``source='field_stats'``. If ``True``,\n            only indices where both ``min_value`` and ``max_value`` are within the\n            period will be selected. If ``False``, it will use whichever you specified.\n            Default is ``False`` to preserve expected behavior.\n        :param week_starts_on: Either ``sunday`` or ``monday``. Default is ``sunday``\n        :param epoch: An epoch timestamp used to establish a point of reference for\n            calculations. If not provided, the current time will be used.\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by period')\n        if period_type not in ['absolute', 'relative']:\n            raise ValueError(\n                f'Unacceptable value: {period_type} -- \"period_type\" must be either '\n                f'\"absolute\" or \"relative\".'\n            )\n        if period_type == 'relative':\n            func = date_range\n            args = [unit, range_from, range_to, epoch]\n            kwgs = {'week_starts_on': week_starts_on}\n            if (not isinstance(range_from, int)) or (not isinstance(range_to, int)):\n                raise ConfigurationError(\n                    '\"range_from\" and \"range_to\" must be integer values'\n                )\n        else:\n            func = absolute_date_range\n            args = [unit, date_from, date_to]\n            kwgs = {\n                'date_from_format': date_from_format,\n                'date_to_format': date_to_format,\n            }\n            for reqd in [date_from, date_to, date_from_format, date_to_format]:\n                if not reqd:\n                    raise ConfigurationError(\n                        'Must provide \"date_from\", \"date_to\", \"date_from_format\", and '\n                        '\"date_to_format\" with absolute period_type'\n                    )\n        # This filter requires index settings\n        self.get_index_settings()\n        try:\n            start, end = func(*args, **kwgs)\n        # pylint: disable=broad-except\n        except Exception as exc:\n            report_failure(exc)\n        self._calculate_ages(\n            source=source, timestring=timestring, field=field, stats_result=stats_result\n        )\n        for index in self.working_list():\n            try:\n                if source == 'field_stats' and intersect:\n                    min_age = int(self.index_info[index]['age']['min_value'])\n                    max_age = int(self.index_info[index]['age']['max_value'])\n                    msg = (\n                        f'Index \"{index}\", timestamp field \"{field}\", min_value '\n                        f'({min_age}), max_value ({max_age}), period start: '\n                        f'\"{start}\", period end, \"{end}\"'\n                    )\n                    # Because time adds to epoch, smaller numbers are actually older\n                    # timestamps.\n                    inrange = (min_age >= start) and (max_age <= end)\n                else:\n                    age = int(self.index_info[index]['age'][self.age_keyfield])\n                    msg = (\n                        f'Index \"{index}\" age ({age}), period start: \"{start}\", period '\n                        f'end, \"{end}\"'\n                    )\n                    # Because time adds to epoch, smaller numbers are actually older\n                    # timestamps.\n                    inrange = (age >= start) and (age <= end)\n                self.__excludify(inrange, exclude, index, msg)\n            except KeyError:\n                self.loggit.debug(\n                    'Index \"%s\" does not meet provided criteria. Removing from list.',\n                    index,\n                )\n                self.indices.remove(index)\n\n    def filter_ilm(self, exclude=True):\n        \"\"\"\n        Match indices that have the setting ``index.lifecycle.name``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            ``indices``. If ``exclude=False``, then only matching indices will be\n            kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering indices with index.lifecycle.name')\n        index_lists = chunk_index_list(self.indices)\n        if index_lists == [['']]:\n            self.loggit.debug('Empty working list. No ILM indices to filter.')\n            return\n        for lst in index_lists:\n            working_list = self._get_indices_settings(lst)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        subvalue = working_list[index]['settings']['index']['lifecycle']\n                        has_ilm = 'name' in subvalue\n                        msg = f\"{index} has index.lifecycle.name {subvalue['name']}\"\n                    except KeyError:\n                        has_ilm = False\n                        msg = f'index.lifecycle.name is not set for index {index}'\n                    self.__excludify(has_ilm, exclude, index, msg)\n\n    def iterate_filters(self, filter_dict):\n        \"\"\"\n        Iterate over the filters defined in ``config`` and execute them.\n\n        :param filter_dict: The configuration dictionary\n\n        .. note:: ``filter_dict`` should be a dictionary with the following form:\n        .. code-block:: python\n\n                { 'filters' : [\n                        {\n                            'filtertype': 'the_filter_type',\n                            'key1' : 'value1',\n                            ...\n                            'keyN' : 'valueN'\n                        }\n                    ]\n                }\n\n        \"\"\"\n        self.loggit.debug('Iterating over a list of filters')\n        # Make sure we actually _have_ filters to act on\n        if 'filters' not in filter_dict or len(filter_dict['filters']) < 1:\n            self.loggit.info('No filters in config.  Returning unaltered object.')\n            return\n        self.loggit.debug('All filters: %s', filter_dict['filters'])\n        for fil in filter_dict['filters']:\n            self.loggit.debug('Top of the loop: %s', self.indices)\n            self.loggit.debug('Un-parsed filter args: %s', fil)\n            # Make sure we got at least this much in the configuration\n            chk = SchemaCheck(\n                fil, filterstructure(), 'filter', 'IndexList.iterate_filters'\n            ).result()\n            msg = f'Parsed filter args: {chk}'\n            self.loggit.debug(msg)\n            method = self.__map_method(fil['filtertype'])\n            del fil['filtertype']\n            # If it's a filtertype with arguments, update the defaults with the\n            # provided settings.\n            if fil:\n                self.loggit.debug('Filter args: %s', fil)\n                self.loggit.debug('Pre-instance: %s', self.indices)\n                method(**fil)\n                self.loggit.debug('Post-instance: %s', self.indices)\n            else:\n                # Otherwise, it's a settingless filter.\n                method()\n\n    def filter_by_size(\n        self,\n        size_threshold=None,\n        threshold_behavior='greater_than',\n        exclude=False,\n        size_behavior='primary',\n    ):\n        \"\"\"\n        Remove indices from the actionable list based on index size.\n\n        ``threshold_behavior``, when set to ``greater_than`` (default), includes\n        if it the index tests to be larger than ``size_threshold``. When set to\n        ``less_than``, it includes if the index is smaller than ``size_threshold``\n\n        :param size_threshold: Filter indices over *n* gigabytes\n        :param threshold_behavior: Size to filter, either ``greater_than`` or\n            ``less_than``. Defaults to ``greater_than`` to preserve backwards\n            compatability.\n        :param size_behavior: Size that used to filter, either ``primary`` or\n            ``total``. Defaults to ``primary``\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by index size')\n        # Ensure that disk_space is a float\n        if not size_threshold:\n            raise MissingArgument('No value for \"size_threshold\" provided')\n        if size_behavior not in ['primary', 'total']:\n            raise ValueError(f'Invalid value for \"size_behavior\": {size_behavior}')\n        if threshold_behavior not in ['greater_than', 'less_than']:\n            raise ValueError(\n                f'Invalid value for \"threshold_behavior\": {threshold_behavior}'\n            )\n        index_size_limit = float(size_threshold) * 2**30\n        msg = (\n            'Cannot get disk usage info from closed indices. '\n            'Omitting any closed indices.'\n        )\n        self.loggit.debug(msg)\n        # This filter requires index state (open/close) and index stats\n        self.get_index_state()\n        self.get_index_stats()\n        self.filter_closed()\n        # Create a copy-by-value working list\n        working_list = self.working_list()\n        for index in working_list:\n            if size_behavior == 'primary':\n                index_size = self.index_info[index]['primary_size_in_bytes']\n            else:\n                index_size = self.index_info[index]['size_in_bytes']\n            msg = (\n                f'{index}, index size is {byte_size(index_size)} and '\n                f'size limit is {byte_size(index_size_limit)}.'\n            )\n            if threshold_behavior == 'greater_than':\n                self.__excludify((index_size > index_size_limit), exclude, index, msg)\n            elif threshold_behavior == 'less_than':\n                self.__excludify((index_size < index_size_limit), exclude, index, msg)\n"
  },
  "GT_src_dict": {
    "curator/actions/snapshot.py": {
      "Snapshot.__init__": {
        "code": "    def __init__(self, ilo, repository=None, name=None, ignore_unavailable=False, include_global_state=True, partial=False, wait_for_completion=True, wait_interval=9, max_wait=-1, skip_repo_fs_check=True):\n        \"\"\"Initializes the Snapshot action class for creating snapshots of Elasticsearch indices.\n\n    :param ilo: An IndexList object containing the indices to be snaphotted.\n    :param repository: (Optional) Repository name where the snapshot will be stored.\n    :param name: (Optional) Name of the snapshot. Must be provided if not using date pattern.\n    :param ignore_unavailable: (Optional) If True, unavailable shards/indices will be ignored.\n    :param include_global_state: (Optional) If True, the global state of the cluster will be included in the snapshot.\n    :param partial: (Optional) If True, the snapshot will not fail if primary shards are unavailable.\n    :param wait_for_completion: (Optional) If True, the method will wait for the snapshot creation to complete.\n    :param wait_interval: (Optional) Number of seconds to wait between completion checks.\n    :param max_wait: (Optional) Maximum time to wait for snapshot completion (in seconds).\n    :param skip_repo_fs_check: (Optional) If True, skips validation of write access to the repository on cluster nodes.\n\n    The constructor verifies the provided IndexList object and checks for the existence of the specified repository \n    before initializing instance attributes. Key attributes include `index_list`, `client`, `name`, `repository`, \n    and `settings`, which are derived from the input parameters and assist in the snapshotting process. If \n    `name` is not provided, an exception is raised. The method also logs messages related to the snapshot action \n    using the configured logger.\n\n    It interacts with utility functions from the `curator.helpers` module to validate inputs and parse date patterns.\"\"\"\n        \"\\n        :param ilo: An IndexList Object\\n        :param repository: Repository name.\\n        :param name: Snapshot name.\\n        :param ignore_unavailable: Ignore unavailable shards/indices.\\n        :param include_global_state: Store cluster global state with snapshot.\\n        :param partial: Do not fail if primary shard is unavailable.\\n        :param wait_for_completion: Wait for completion before returning.\\n        :param wait_interval: Seconds to wait between completion checks.\\n        :param max_wait: Maximum number of seconds to ``wait_for_completion``\\n        :param skip_repo_fs_check: Do not validate write access to repository on all cluster nodes\\n            before proceeding. Useful for shared filesystems where intermittent timeouts can affect\\n            validation, but won't likely affect snapshot success. (Default: ``True``)\\n\\n        :type ilo: :py:class:`~.curator.indexlist.IndexList`\\n        :type repository: str\\n        :type name: str\\n        :type ignore_unavailable: bool\\n        :type include_global_state: bool\\n        :type partial: bool\\n        :type wait_for_completion: bool\\n        :type wait_interval: int\\n        :type max_wait: int\\n        :type skip_repo_fs_check: bool\\n        \"\n        verify_index_list(ilo)\n        ilo.empty_list_check()\n        if not repository_exists(ilo.client, repository=repository):\n            raise ActionError(f'Cannot snapshot indices to missing repository: {repository}')\n        if not name:\n            raise MissingArgument('No value for \"name\" provided.')\n        self.index_list = ilo\n        self.client = ilo.client\n        self.name = parse_datemath(self.client, parse_date_pattern(name))\n        self.repository = repository\n        self.wait_for_completion = wait_for_completion\n        self.wait_interval = wait_interval\n        self.max_wait = max_wait\n        self.skip_repo_fs_check = skip_repo_fs_check\n        self.state = None\n        self.indices = to_csv(ilo.indices)\n        self.ignore_unavailable = ignore_unavailable\n        self.include_global_state = include_global_state\n        self.partial = partial\n        self.settings = {'indices': ilo.indices, 'ignore_unavailable': self.ignore_unavailable, 'include_global_state': self.include_global_state, 'partial': self.partial}\n        self.loggit = logging.getLogger('curator.actions.snapshot')",
        "docstring": "Initializes the Snapshot action class for creating snapshots of Elasticsearch indices.\n\n:param ilo: An IndexList object containing the indices to be snaphotted.\n:param repository: (Optional) Repository name where the snapshot will be stored.\n:param name: (Optional) Name of the snapshot. Must be provided if not using date pattern.\n:param ignore_unavailable: (Optional) If True, unavailable shards/indices will be ignored.\n:param include_global_state: (Optional) If True, the global state of the cluster will be included in the snapshot.\n:param partial: (Optional) If True, the snapshot will not fail if primary shards are unavailable.\n:param wait_for_completion: (Optional) If True, the method will wait for the snapshot creation to complete.\n:param wait_interval: (Optional) Number of seconds to wait between completion checks.\n:param max_wait: (Optional) Maximum time to wait for snapshot completion (in seconds).\n:param skip_repo_fs_check: (Optional) If True, skips validation of write access to the repository on cluster nodes.\n\nThe constructor verifies the provided IndexList object and checks for the existence of the specified repository \nbefore initializing instance attributes. Key attributes include `index_list`, `client`, `name`, `repository`, \nand `settings`, which are derived from the input parameters and assist in the snapshotting process. If \n`name` is not provided, an exception is raised. The method also logs messages related to the snapshot action \nusing the configured logger.\n\nIt interacts with utility functions from the `curator.helpers` module to validate inputs and parse date patterns.",
        "signature": "def __init__(self, ilo, repository=None, name=None, ignore_unavailable=False, include_global_state=True, partial=False, wait_for_completion=True, wait_interval=9, max_wait=-1, skip_repo_fs_check=True):",
        "type": "Method",
        "class_signature": "class Snapshot(object):"
      },
      "Snapshot.get_state": {
        "code": "    def get_state(self):\n        \"\"\"Get the state of a specific snapshot from the snapshot repository.\n\nThis method retrieves the status of the snapshot identified by `self.name` in the specified `self.repository`. If the snapshot exists, its state is stored in the `self.state` attribute and returned. If the snapshot cannot be found, a `CuratorException` is raised with a descriptive error message.\n\nReturns:\n    str: The state of the snapshot, e.g., 'SUCCESS', 'FAILED', etc.\n\nRaises:\n    CuratorException: If the specified snapshot is not found in the repository.\n\nDependencies:\n- `self.client`: An instance of `Elasticsearch` client used to communicate with the Elasticsearch service.\n- `self.repository`: A string representing the name of the snapshot repository.\n- `self.name`: A string representing the name of the snapshot to check.\"\"\"\n        'Get the state of the snapshot and set :py:attr:`state`'\n        try:\n            self.state = self.client.snapshot.get(repository=self.repository, snapshot=self.name)['snapshots'][0]['state']\n            return self.state\n        except IndexError as exc:\n            raise CuratorException(f'Snapshot \"{self.name}\" not found in repository \"{self.repository}\"') from exc",
        "docstring": "Get the state of a specific snapshot from the snapshot repository.\n\nThis method retrieves the status of the snapshot identified by `self.name` in the specified `self.repository`. If the snapshot exists, its state is stored in the `self.state` attribute and returned. If the snapshot cannot be found, a `CuratorException` is raised with a descriptive error message.\n\nReturns:\n    str: The state of the snapshot, e.g., 'SUCCESS', 'FAILED', etc.\n\nRaises:\n    CuratorException: If the specified snapshot is not found in the repository.\n\nDependencies:\n- `self.client`: An instance of `Elasticsearch` client used to communicate with the Elasticsearch service.\n- `self.repository`: A string representing the name of the snapshot repository.\n- `self.name`: A string representing the name of the snapshot to check.",
        "signature": "def get_state(self):",
        "type": "Method",
        "class_signature": "class Snapshot(object):"
      },
      "Snapshot.report_state": {
        "code": "    def report_state(self):\n        \"\"\"Log the state of the snapshot and raise a `FailedSnapshot` exception if the state is not `SUCCESS`.\n\nThis method invokes `get_state()` to retrieve the current state of the snapshot using the Elasticsearch client, checking it against the defined `self.state`. If the state is `SUCCESS`, it logs a success message; otherwise, it logs an error message indicating the snapshot's completion state and raises a `FailedSnapshot` exception with the detailed message.\n\nInteraction with other parts of the code:\n- The method relies on `self.client` and `self.name` (defined during the initialization of the `Snapshot` class) to communicate with the Elasticsearch service.\n- It also interacts with the `loggit` logger instance for logging purposes.\n\nImportant constants:\n- `self.state`: Holds the current state of the snapshot. This is retrieved using `get_state()` and indicates if the snapshot succeeded or failed.\"\"\"\n        '\\n        Log the :py:attr:`state` of the snapshot and raise :py:exc:`FailedSnapshot` if\\n        :py:attr:`state` is not ``SUCCESS``\\n        '\n        self.get_state()\n        if self.state == 'SUCCESS':\n            self.loggit.info('Snapshot %s successfully completed.', self.name)\n        else:\n            msg = f'Snapshot {self.name} completed with state: {self.state}'\n            self.loggit.error(msg)\n            raise FailedSnapshot(msg)",
        "docstring": "Log the state of the snapshot and raise a `FailedSnapshot` exception if the state is not `SUCCESS`.\n\nThis method invokes `get_state()` to retrieve the current state of the snapshot using the Elasticsearch client, checking it against the defined `self.state`. If the state is `SUCCESS`, it logs a success message; otherwise, it logs an error message indicating the snapshot's completion state and raises a `FailedSnapshot` exception with the detailed message.\n\nInteraction with other parts of the code:\n- The method relies on `self.client` and `self.name` (defined during the initialization of the `Snapshot` class) to communicate with the Elasticsearch service.\n- It also interacts with the `loggit` logger instance for logging purposes.\n\nImportant constants:\n- `self.state`: Holds the current state of the snapshot. This is retrieved using `get_state()` and indicates if the snapshot succeeded or failed.",
        "signature": "def report_state(self):",
        "type": "Method",
        "class_signature": "class Snapshot(object):"
      },
      "Snapshot.do_dry_run": {
        "code": "    def do_dry_run(self):\n        \"\"\"Log the intended action for creating a snapshot without executing it. This method is useful for previewing what the snapshot operation would entail, displaying the snapshot name, repository, and relevant settings without making any changes to the system.\n\nNo parameters are required, and the method does not return any values. Instead, it outputs log messages indicating that the operation is in DRY-RUN mode and detailing the settings that would be used if the action were performed.\n\nThe method utilizes the `loggit` attribute, which is a logger for tracking events related to the snapshot operations. The `name` and `repository` attributes represent the snapshot's designated name and the repository it will utilize, respectively. The `settings` attribute is a dictionary containing the parameters configured for the snapshot operation.\"\"\"\n        'Log what the output would be, but take no action.'\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        msg = f'DRY-RUN: snapshot: {self.name} in repository {self.repository} with arguments: {self.settings}'\n        self.loggit.info(msg)",
        "docstring": "Log the intended action for creating a snapshot without executing it. This method is useful for previewing what the snapshot operation would entail, displaying the snapshot name, repository, and relevant settings without making any changes to the system.\n\nNo parameters are required, and the method does not return any values. Instead, it outputs log messages indicating that the operation is in DRY-RUN mode and detailing the settings that would be used if the action were performed.\n\nThe method utilizes the `loggit` attribute, which is a logger for tracking events related to the snapshot operations. The `name` and `repository` attributes represent the snapshot's designated name and the repository it will utilize, respectively. The `settings` attribute is a dictionary containing the parameters configured for the snapshot operation.",
        "signature": "def do_dry_run(self):",
        "type": "Method",
        "class_signature": "class Snapshot(object):"
      },
      "Snapshot.do_action": {
        "code": "    def do_action(self):\n        \"\"\"Perform the action of creating a snapshot of specified indices in Elasticsearch.\n\nThis method verifies if the repository for storing the snapshot exists and \nchecks if a snapshot is already in progress. It uses the `SnapshotClient.create` method \nto initiate the snapshot creation process with the provided parameters, including options \nfor ignoring unavailable shards, including global state, and snapshot indexing settings.\n\nParameters:\n- `self`: The current instance of the Snapshot class, which contains attributes such as \n  `repository`, `name`, `ignore_unavailable`, `include_global_state`, `indices`, \n  `partial`, `wait_for_completion`, `wait_interval`, and `max_wait`. These control \n  various aspects of the snapshot creation process.\n  \nReturns:\n- None\n\nRaises:\n- `SnapshotInProgress`: If a snapshot is already being created when this method is called.\n- `ActionError`: Raised if the snapshot cannot be created for any reason related to the repository \n  or index list.\n\nSide Effects:\n- Initiates the creation of a snapshot which is logged using the `loggit` logger.\n- If `wait_for_completion` is set to True, it blocks further execution until the snapshot creation \n  is complete, checking for completion using the `wait_for_it` function.\n\nDependencies:\n- Utilizes helper functions such as `verify_repository`, `snapshot_running`, and `report_failure` \n  from the `curator.helpers` module to ensure valid operations throughout the snapshot creation process.\"\"\"\n        '\\n        :py:meth:`elasticsearch.client.SnapshotClient.create` a snapshot of :py:attr:`indices`,\\n        with passed parameters.\\n        '\n        if not self.skip_repo_fs_check:\n            verify_repository(self.client, self.repository)\n        if snapshot_running(self.client):\n            raise SnapshotInProgress('Snapshot already in progress.')\n        try:\n            self.loggit.info('Creating snapshot \"%s\" from indices: %s', self.name, self.index_list.indices)\n            self.client.snapshot.create(repository=self.repository, snapshot=self.name, ignore_unavailable=self.ignore_unavailable, include_global_state=self.include_global_state, indices=self.indices, partial=self.partial, wait_for_completion=False)\n            if self.wait_for_completion:\n                wait_for_it(self.client, 'snapshot', snapshot=self.name, repository=self.repository, wait_interval=self.wait_interval, max_wait=self.max_wait)\n                self.report_state()\n            else:\n                msg = f'\"wait_for_completion\" set to {self.wait_for_completion}. Remember to check for successful completion manually.'\n                self.loggit.warning(msg)\n        except Exception as err:\n            report_failure(err)",
        "docstring": "Perform the action of creating a snapshot of specified indices in Elasticsearch.\n\nThis method verifies if the repository for storing the snapshot exists and \nchecks if a snapshot is already in progress. It uses the `SnapshotClient.create` method \nto initiate the snapshot creation process with the provided parameters, including options \nfor ignoring unavailable shards, including global state, and snapshot indexing settings.\n\nParameters:\n- `self`: The current instance of the Snapshot class, which contains attributes such as \n  `repository`, `name`, `ignore_unavailable`, `include_global_state`, `indices`, \n  `partial`, `wait_for_completion`, `wait_interval`, and `max_wait`. These control \n  various aspects of the snapshot creation process.\n  \nReturns:\n- None\n\nRaises:\n- `SnapshotInProgress`: If a snapshot is already being created when this method is called.\n- `ActionError`: Raised if the snapshot cannot be created for any reason related to the repository \n  or index list.\n\nSide Effects:\n- Initiates the creation of a snapshot which is logged using the `loggit` logger.\n- If `wait_for_completion` is set to True, it blocks further execution until the snapshot creation \n  is complete, checking for completion using the `wait_for_it` function.\n\nDependencies:\n- Utilizes helper functions such as `verify_repository`, `snapshot_running`, and `report_failure` \n  from the `curator.helpers` module to ensure valid operations throughout the snapshot creation process.",
        "signature": "def do_action(self):",
        "type": "Method",
        "class_signature": "class Snapshot(object):"
      }
    },
    "curator/exceptions.py": {},
    "curator/indexlist.py": {
      "IndexList.__init__": {
        "code": "    def __init__(self, client, search_pattern='_all'):\n        \"\"\"Initialize an IndexList instance.\n\nThis constructor initializes the IndexList object used for managing and filtering Elasticsearch indices. It requires an Elasticsearch client object to interact with the Elasticsearch cluster, and it populates the initial index list based on the provided search pattern.\n\nParameters:\n- client (Elasticsearch): An instance of an Elasticsearch client used for querying index data.\n- search_pattern (str): A string pattern to match indices, defaults to '_all', which targets all indices.\n\nThis method invokes `verify_client_object` to ensure the client is valid, and it initializes several attributes:\n- `self.client`: Stores the Elasticsearch client object.\n- `self.index_info`: A dictionary to hold metadata about the indices.\n- `self.indices`: A list for working with actionable indices.\n- `self.all_indices`: A list of all indices in the cluster at the time of initialization.\n- `self.age_keyfield`: Initialized to None, to potentially hold a key field for age calculations later.\n\nThe method calls `__get_indices` to populate `self.all_indices` and `self.indices` based on the search pattern.\"\"\"\n        verify_client_object(client)\n        self.loggit = logging.getLogger('curator.indexlist')\n        self.client = client\n        self.index_info = {}\n        self.indices = []\n        self.all_indices = []\n        self.__get_indices(search_pattern)\n        self.age_keyfield = None",
        "docstring": "Initialize an IndexList instance.\n\nThis constructor initializes the IndexList object used for managing and filtering Elasticsearch indices. It requires an Elasticsearch client object to interact with the Elasticsearch cluster, and it populates the initial index list based on the provided search pattern.\n\nParameters:\n- client (Elasticsearch): An instance of an Elasticsearch client used for querying index data.\n- search_pattern (str): A string pattern to match indices, defaults to '_all', which targets all indices.\n\nThis method invokes `verify_client_object` to ensure the client is valid, and it initializes several attributes:\n- `self.client`: Stores the Elasticsearch client object.\n- `self.index_info`: A dictionary to hold metadata about the indices.\n- `self.indices`: A list for working with actionable indices.\n- `self.all_indices`: A list of all indices in the cluster at the time of initialization.\n- `self.age_keyfield`: Initialized to None, to potentially hold a key field for age calculations later.\n\nThe method calls `__get_indices` to populate `self.all_indices` and `self.indices` based on the search pattern.",
        "signature": "def __init__(self, client, search_pattern='_all'):",
        "type": "Method",
        "class_signature": "class IndexList:"
      }
    }
  },
  "dependency_dict": {
    "curator/indexlist.py:IndexList:__init__": {
      "curator/indexlist.py": {
        "IndexList.__get_indices": {
          "code": "    def __get_indices(self, pattern):\n        \"\"\"\n        Pull all indices into ``all_indices``, then populate ``indices`` and\n        ``index_info``\n        \"\"\"\n        self.loggit.debug('Getting indices matching search_pattern: \"%s\"', pattern)\n        self.all_indices = get_indices(self.client, search_pattern=pattern)\n        self.indices = self.all_indices[:]",
          "docstring": "Pull all indices into ``all_indices``, then populate ``indices`` and\n``index_info``",
          "signature": "def __get_indices(self, pattern):",
          "type": "Method",
          "class_signature": "class IndexList:"
        }
      },
      "curator/helpers/testers.py": {
        "verify_client_object": {
          "code": "def verify_client_object(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.elasticsearch.Elasticsearch`\n\n    :returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\n        client object and raise a :py:exc:`TypeError` exception if it is not.\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    # Ignore mock type for testing\n    if str(type(test)) == \"<class 'unittest.mock.Mock'>\":\n        pass\n    elif not isinstance(test, Elasticsearch):\n        msg = f'Not a valid client object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)",
          "docstring": ":param test: The variable or object to test\n\n:type test: :py:class:`~.elasticsearch.Elasticsearch`\n\n:returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\n    client object and raise a :py:exc:`TypeError` exception if it is not.\n:rtype: bool",
          "signature": "def verify_client_object(test):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "curator/actions/snapshot.py:Snapshot:__init__": {
      "curator/helpers/testers.py": {
        "repository_exists": {
          "code": "def repository_exists(client, repository=None):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n    :param client: A client connection object\n    :param repository: The Elasticsearch snapshot repository to use\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type repository: str\n\n    :returns: ``True`` if ``repository`` exists, else ``False``\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    if not repository:\n        raise MissingArgument('No value for \"repository\" provided')\n    try:\n        test_result = get_repository(client, repository)\n        if repository in test_result:\n            logger.debug(\"Repository %s exists.\", repository)\n            response = True\n        else:\n            logger.debug(\"Repository %s not found...\", repository)\n            response = False\n    # pylint: disable=broad-except\n    except Exception as err:\n        logger.debug('Unable to find repository \"%s\": Error: %s', repository, err)\n        response = False\n    return response",
          "docstring": "Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n:param client: A client connection object\n:param repository: The Elasticsearch snapshot repository to use\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n:type repository: str\n\n:returns: ``True`` if ``repository`` exists, else ``False``\n:rtype: bool",
          "signature": "def repository_exists(client, repository=None):",
          "type": "Function",
          "class_signature": null
        },
        "verify_index_list": {
          "code": "def verify_index_list(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.curator.IndexList`\n\n    :returns: ``None`` if ``test`` is a proper :py:class:`~.curator.indexlist.IndexList`\n        object, else raise a :py:class:`TypeError` exception.\n    :rtype: None\n    \"\"\"\n    # It breaks if this import isn't local to this function:\n    # ImportError: cannot import name 'IndexList' from partially initialized module\n    # 'curator.indexlist' (most likely due to a circular import)\n    # pylint: disable=import-outside-toplevel\n    from curator.indexlist import IndexList\n\n    logger = logging.getLogger(__name__)\n    if not isinstance(test, IndexList):\n        msg = f'Not a valid IndexList object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)",
          "docstring": ":param test: The variable or object to test\n\n:type test: :py:class:`~.curator.IndexList`\n\n:returns: ``None`` if ``test`` is a proper :py:class:`~.curator.indexlist.IndexList`\n    object, else raise a :py:class:`TypeError` exception.\n:rtype: None",
          "signature": "def verify_index_list(test):",
          "type": "Function",
          "class_signature": null
        }
      },
      "curator/helpers/utils.py": {
        "to_csv": {
          "code": "def to_csv(indices):\n    \"\"\"\n    :param indices: A list of indices to act on, or a single value, which could be\n        in the format of a csv string already.\n\n    :type indices: list\n\n    :returns: A csv string from a list of indices, or a single value if only one value is present\n    :rtype: str\n    \"\"\"\n    indices = ensure_list(indices) # in case of a single value passed\n    if indices:\n        return ','.join(sorted(indices))\n    return None",
          "docstring": ":param indices: A list of indices to act on, or a single value, which could be\n    in the format of a csv string already.\n\n:type indices: list\n\n:returns: A csv string from a list of indices, or a single value if only one value is present\n:rtype: str",
          "signature": "def to_csv(indices):",
          "type": "Function",
          "class_signature": null
        }
      },
      "curator/helpers/date_ops.py": {
        "parse_date_pattern": {
          "code": "def parse_date_pattern(name):\n    \"\"\"\n    Scan and parse ``name`` for :py:func:`~.time.strftime` strings, replacing them with\n    the associated value when found, but otherwise returning lowercase values, as\n    uppercase snapshot names are not allowed. It will detect if the first character is\n    a ``<``, which would indicate ``name`` is going to be using Elasticsearch date math\n    syntax, and skip accordingly.\n\n    The :py:func:`~.time.strftime` identifiers that Curator currently recognizes as\n    acceptable include:\n\n    * ``Y``: A 4 digit year\n    * ``y``: A 2 digit year\n    * ``m``: The 2 digit month\n    * ``W``: The 2 digit week of the year\n    * ``d``: The 2 digit day of the month\n    * ``H``: The 2 digit hour of the day, in 24 hour notation\n    * ``M``: The 2 digit minute of the hour\n    * ``S``: The 2 digit number of second of the minute\n    * ``j``: The 3 digit day of the year\n\n    :param name: A name, which can contain :py:func:`~.time.strftime` strings\n    :type name: str\n\n    :returns: The parsed date pattern\n    :rtype: str\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    prev, rendered = ('', '')\n    logger.debug('Provided index name: %s', name)\n    for idx, char in enumerate(name):\n        logger.debug('Current character in provided name: %s, position: %s', char, idx)\n        if char == '<':\n            logger.info('\"%s\" is probably using Elasticsearch date math.', name)\n            rendered = name\n            break\n        if char == '%':\n            pass\n        elif char in date_regex() and prev == '%':\n            rendered += str(datetime.now(timezone.utc).strftime(f'%{char}'))\n        else:\n            rendered += char\n        logger.debug('Partially rendered name: %s', rendered)\n        prev = char\n    logger.debug('Fully rendered name: %s', rendered)\n    return rendered",
          "docstring": "Scan and parse ``name`` for :py:func:`~.time.strftime` strings, replacing them with\nthe associated value when found, but otherwise returning lowercase values, as\nuppercase snapshot names are not allowed. It will detect if the first character is\na ``<``, which would indicate ``name`` is going to be using Elasticsearch date math\nsyntax, and skip accordingly.\n\nThe :py:func:`~.time.strftime` identifiers that Curator currently recognizes as\nacceptable include:\n\n* ``Y``: A 4 digit year\n* ``y``: A 2 digit year\n* ``m``: The 2 digit month\n* ``W``: The 2 digit week of the year\n* ``d``: The 2 digit day of the month\n* ``H``: The 2 digit hour of the day, in 24 hour notation\n* ``M``: The 2 digit minute of the hour\n* ``S``: The 2 digit number of second of the minute\n* ``j``: The 3 digit day of the year\n\n:param name: A name, which can contain :py:func:`~.time.strftime` strings\n:type name: str\n\n:returns: The parsed date pattern\n:rtype: str",
          "signature": "def parse_date_pattern(name):",
          "type": "Function",
          "class_signature": null
        },
        "parse_datemath": {
          "code": "def parse_datemath(client, value):\n    \"\"\"\n    Validate that ``value`` looks like proper datemath. If it passes this test, then\n    try to ship it to Elasticsearch for real. It may yet fail this test, and if it\n    does, it will raise a :py:exc:`~.curator.exceptions.ConfigurationError` exception.\n    If it passes, return the fully parsed string.\n\n    :param client: A client connection object\n    :param value: A string to check for datemath\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type value: str\n\n    :returns: A datemath indexname, fully rendered by Elasticsearch\n    :rtype: str\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    if not isdatemath(value):\n        return value\n    # if we didn't return here, we can continue, no 'else' needed.\n    logger.debug('Properly encapsulated, proceeding to next evaluation...')\n    # Our pattern has 4 capture groups.\n    # 1. Everything after the initial '<' up to the first '{', which we call ``prefix``\n    # 2. Everything between the outermost '{' and '}', which we call ``datemath``\n    # 3. An optional inner '{' and '}' containing a date formatter and potentially a\n    #    timezone. Not captured.\n    # 4. Everything after the last '}' up to the closing '>'\n    pattern = r'^<([^\\{\\}]*)?(\\{.*(\\{.*\\})?\\})([^\\{\\}]*)?>$'\n    regex = re.compile(pattern)\n    try:\n        prefix = regex.match(value).group(1) or ''\n        datemath = regex.match(value).group(2)\n        # formatter = regex.match(value).group(3) or '' (not captured, but counted)\n        suffix = regex.match(value).group(4) or ''\n    except AttributeError as exc:\n        raise ConfigurationError(\n            f'Value \"{value}\" does not contain a valid datemath pattern.'\n        ) from exc\n\n    return f'{prefix}{get_datemath(client, datemath)}{suffix}'",
          "docstring": "Validate that ``value`` looks like proper datemath. If it passes this test, then\ntry to ship it to Elasticsearch for real. It may yet fail this test, and if it\ndoes, it will raise a :py:exc:`~.curator.exceptions.ConfigurationError` exception.\nIf it passes, return the fully parsed string.\n\n:param client: A client connection object\n:param value: A string to check for datemath\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n:type value: str\n\n:returns: A datemath indexname, fully rendered by Elasticsearch\n:rtype: str",
          "signature": "def parse_datemath(client, value):",
          "type": "Function",
          "class_signature": null
        }
      },
      "curator/indexlist.py": {
        "IndexList.empty_list_check": {
          "code": "    def empty_list_check(self):\n        \"\"\"Raise :py:exc:`~.curator.exceptions.NoIndices` if ``indices`` is empty\"\"\"\n        self.loggit.debug('Checking for empty list')\n        if not self.indices:\n            raise NoIndices('index_list object is empty.')",
          "docstring": "Raise :py:exc:`~.curator.exceptions.NoIndices` if ``indices`` is empty",
          "signature": "def empty_list_check(self):",
          "type": "Method",
          "class_signature": "class IndexList:"
        }
      }
    },
    "curator/actions/snapshot.py:Snapshot:do_action": {
      "curator/helpers/utils.py": {
        "report_failure": {
          "code": "def report_failure(exception):\n    \"\"\"\n    Raise a :py:exc:`~.curator.exceptions.FailedExecution` exception and include the original error\n    message.\n\n    :param exception: The upstream exception.\n\n    :type exception: :py:exc:Exception\n\n    :rtype: None\n    \"\"\"\n    raise FailedExecution(\n        f'Exception encountered.  Rerun with loglevel DEBUG and/or check Elasticsearch logs for'\n        f'more information. Exception: {exception}'\n    )",
          "docstring": "Raise a :py:exc:`~.curator.exceptions.FailedExecution` exception and include the original error\nmessage.\n\n:param exception: The upstream exception.\n\n:type exception: :py:exc:Exception\n\n:rtype: None",
          "signature": "def report_failure(exception):",
          "type": "Function",
          "class_signature": null
        }
      },
      "curator/helpers/testers.py": {
        "snapshot_running": {
          "code": "def snapshot_running(client):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\n    Return ``True`` if a snapshot is in progress, and ``False`` if not\n\n    :param client: A client connection object\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n    :rtype: bool\n    \"\"\"\n    try:\n        status = client.snapshot.status()['snapshots']\n    # pylint: disable=broad-except\n    except Exception as exc:\n        report_failure(exc)\n    # We will only accept a positively identified False.  Anything else is\n    # suspect. That's why this statement, rather than just ``return status``\n    # pylint: disable=simplifiable-if-expression\n    return False if not status else True",
          "docstring": "Calls :py:meth:`~.elasticsearch.client.SnapshotClient.get_repository`\n\nReturn ``True`` if a snapshot is in progress, and ``False`` if not\n\n:param client: A client connection object\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n\n:rtype: bool",
          "signature": "def snapshot_running(client):",
          "type": "Function",
          "class_signature": null
        }
      },
      "curator/helpers/waiters.py": {
        "wait_for_it": {
          "code": "def wait_for_it(\n        client, action, task_id=None, snapshot=None, repository=None, index=None, index_list=None,\n        wait_interval=9, max_wait=-1\n    ):\n    \"\"\"\n    This function becomes one place to do all ``wait_for_completion`` type behaviors\n\n    :param client: A client connection object\n    :param action: The action name that will identify how to wait\n    :param task_id: If the action provided a task_id, this is where it must be declared.\n    :param snapshot: The name of the snapshot.\n    :param repository: The Elasticsearch snapshot repository to use\n    :param wait_interval: Seconds to wait between completion checks.\n    :param max_wait: Maximum number of seconds to ``wait_for_completion``\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type action: str\n    :type task_id: str\n    :type snapshot: str\n    :type repository: str\n    :type wait_interval: int\n    :type max_wait: int\n    :rtype: None\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    action_map = {\n        'allocation':{'function': health_check, 'args': {'relocating_shards':0}},\n        'replicas':{'function': health_check, 'args': {'status':'green'}},\n        'cluster_routing':{'function': health_check, 'args': {'relocating_shards':0}},\n        'snapshot':{\n            'function':snapshot_check, 'args':{'snapshot':snapshot, 'repository':repository}},\n        'restore':{'function':restore_check, 'args':{'index_list':index_list}},\n        'reindex':{'function':task_check, 'args':{'task_id':task_id}},\n        'shrink':{'function': health_check, 'args': {'status':'green'}},\n        'relocate':{'function': relocate_check, 'args': {'index':index}},\n    }\n    wait_actions = list(action_map.keys())\n\n    if action not in wait_actions:\n        raise ConfigurationError(f'\"action\" must be one of {wait_actions}')\n    if action == 'reindex' and task_id is None:\n        raise MissingArgument(f'A task_id must accompany \"action\" {action}')\n    if action == 'snapshot' and ((snapshot is None) or (repository is None)):\n        raise MissingArgument(\n            f'A snapshot and repository must accompany \"action\" {action}. snapshot: '\n            f'{snapshot}, repository: {repository}'\n        )\n    if action == 'restore' and index_list is None:\n        raise MissingArgument(f'An index_list must accompany \"action\" {action}')\n    if action == 'reindex':\n        try:\n            _ = client.tasks.get(task_id=task_id)\n        except Exception as err:\n            # This exception should only exist in API usage. It should never\n            # occur in regular Curator usage.\n            raise CuratorException(f'Unable to find task_id {task_id}. Exception: {err}') from err\n\n    # Now with this mapped, we can perform the wait as indicated.\n    start_time = datetime.now()\n    result = False\n    while True:\n        elapsed = int((datetime.now() - start_time).total_seconds())\n        logger.debug('Elapsed time: %s seconds', elapsed)\n        response = action_map[action]['function'](client, **action_map[action]['args'])\n        logger.debug('Response: %s', response)\n        # Success\n        if response:\n            logger.debug(\n                'Action \"%s\" finished executing (may or may not have been successful)', action)\n            result = True\n            break\n        # Not success, and reached maximum wait (if defined)\n        if (max_wait != -1) and (elapsed >= max_wait):\n            msg = f'Unable to complete action \"{action}\" within max_wait ({max_wait}) seconds.'\n            logger.error(msg)\n            break\n        # Not success, so we wait.\n        msg = (\n            f'Action \"{action}\" not yet complete, {elapsed} total seconds elapsed. '\n            f'Waiting {wait_interval} seconds before checking again.'\n        )\n        logger.debug(msg)\n        sleep(wait_interval)\n\n    logger.debug('Result: %s', result)\n    if not result:\n        raise ActionTimeout(\n            f'Action \"{action}\" failed to complete in the max_wait period of {max_wait} seconds'\n        )",
          "docstring": "This function becomes one place to do all ``wait_for_completion`` type behaviors\n\n:param client: A client connection object\n:param action: The action name that will identify how to wait\n:param task_id: If the action provided a task_id, this is where it must be declared.\n:param snapshot: The name of the snapshot.\n:param repository: The Elasticsearch snapshot repository to use\n:param wait_interval: Seconds to wait between completion checks.\n:param max_wait: Maximum number of seconds to ``wait_for_completion``\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n:type action: str\n:type task_id: str\n:type snapshot: str\n:type repository: str\n:type wait_interval: int\n:type max_wait: int\n:rtype: None",
          "signature": "def wait_for_it(client, action, task_id=None, snapshot=None, repository=None, index=None, index_list=None, wait_interval=9, max_wait=-1):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "curator/actions/snapshot.py:Snapshot:report_state": {}
  },
  "call_tree": {
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_do_action_no_wait_for_completion": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {
          "curator/indexlist.py:IndexList:IndexList": {}
        },
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:do_action": {
        "curator/helpers/testers.py:snapshot_running": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_do_action_raise_on_failure": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:do_action": {
        "curator/helpers/testers.py:snapshot_running": {},
        "curator/helpers/utils.py:report_failure": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_do_action_raise_snap_in_progress": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:do_action": {
        "curator/helpers/testers.py:snapshot_running": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_do_action_success": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:do_action": {
        "curator/helpers/testers.py:snapshot_running": {},
        "curator/helpers/waiters.py:wait_for_it": {
          "curator/helpers/waiters.py:snapshot_check": {}
        },
        "curator/actions/snapshot.py:Snapshot:report_state": {
          "curator/actions/snapshot.py:Snapshot:get_state": {}
        }
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_do_dry_run": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:do_dry_run": {}
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_get_state_fail": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:get_state": {}
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_get_state_success": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:get_state": {}
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_init_no_name_exception": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        }
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_init_no_repo_arg_exception": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_init_no_repo_exception": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        }
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_init_raise_bad_index_list": {
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_init_success": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_report_state_other": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:report_state": {
        "curator/actions/snapshot.py:Snapshot:get_state": {}
      }
    },
    "tests/unit/test_action_snapshot.py:TestActionSnapshot:test_report_state_success": {
      "tests/unit/test_action_snapshot.py:TestActionSnapshot:builder": {
        "curator/indexlist.py:IndexList:__init__": {
          "curator/helpers/testers.py:verify_client_object": {},
          "curator/indexlist.py:IndexList:__get_indices": {
            "curator/helpers/getters.py:get_indices": {}
          }
        }
      },
      "curator/actions/snapshot.py:Snapshot:__init__": {
        "curator/helpers/testers.py:verify_index_list": {},
        "curator/indexlist.py:IndexList:empty_list_check": {},
        "curator/helpers/testers.py:repository_exists": {
          "curator/helpers/getters.py:get_repository": {}
        },
        "curator/helpers/date_ops.py:parse_date_pattern": {
          "curator/defaults/settings.py:date_regex": {}
        },
        "curator/helpers/date_ops.py:parse_datemath": {
          "curator/helpers/date_ops.py:isdatemath": {}
        },
        "curator/helpers/utils.py:to_csv": {}
      },
      "curator/actions/snapshot.py:Snapshot:report_state": {
        "curator/actions/snapshot.py:Snapshot:get_state": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_snapshot/elasticsearch_curator-test_action_snapshot/tests/integration/test_cli.py:TestCLIMethods:test_action_is_none": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_snapshot/elasticsearch_curator-test_action_snapshot/tests/integration/test_cli.py:TestCLIMethods:test_no_action": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_snapshot/elasticsearch_curator-test_action_snapshot/tests/integration/test_integrations.py:TestFilters:test_filter_by_alias_bad_aliases": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    }
  },
  "PRD": "# PROJECT NAME: elasticsearch_curator-test_action_snapshot\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 curator/\n    \u251c\u2500\u2500 actions/\n    \u2502   \u2514\u2500\u2500 snapshot.py\n    \u2502       \u251c\u2500\u2500 Snapshot.__init__\n    \u2502       \u251c\u2500\u2500 Snapshot.do_action\n    \u2502       \u251c\u2500\u2500 Snapshot.do_dry_run\n    \u2502       \u251c\u2500\u2500 Snapshot.get_state\n    \u2502       \u2514\u2500\u2500 Snapshot.report_state\n    \u251c\u2500\u2500 exceptions.py\n    \u2502   \u2514\u2500\u2500 ConfigurationError.ConfigurationError\n    \u2514\u2500\u2500 indexlist.py\n        \u2514\u2500\u2500 IndexList.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe Snapshot Test Module validates the functionality, reliability, and exception handling of the snapshot creation process within the Elasticsearch management framework. Its primary purpose is to ensure the correct initialization, execution, and state reporting of snapshot actions, verifying compliance with expected behaviors when interacting with index data and repositories. The module provides capabilities such as validating input arguments, detecting and handling errors like repository misconfigurations or ongoing snapshot processes, and confirming successful or failed snapshot operations. By simulating various scenarios, this module improves the robustness of snapshot functionality, reducing potential issues for developers and ensuring smooth and predictable integration with Elasticsearch infrastructure.\n\n## FILE 1: curator/actions/snapshot.py\n\n- CLASS METHOD: Snapshot.get_state\n  - CLASS SIGNATURE: class Snapshot(object):\n  - SIGNATURE: def get_state(self):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the state of a specific snapshot from the snapshot repository.\n\nThis method retrieves the status of the snapshot identified by `self.name` in the specified `self.repository`. If the snapshot exists, its state is stored in the `self.state` attribute and returned. If the snapshot cannot be found, a `CuratorException` is raised with a descriptive error message.\n\nReturns:\n    str: The state of the snapshot, e.g., 'SUCCESS', 'FAILED', etc.\n\nRaises:\n    CuratorException: If the specified snapshot is not found in the repository.\n\nDependencies:\n- `self.client`: An instance of `Elasticsearch` client used to communicate with the Elasticsearch service.\n- `self.repository`: A string representing the name of the snapshot repository.\n- `self.name`: A string representing the name of the snapshot to check.\n\"\"\"\n```\n\n- CLASS METHOD: Snapshot.do_action\n  - CLASS SIGNATURE: class Snapshot(object):\n  - SIGNATURE: def do_action(self):\n  - DOCSTRING: \n```python\n\"\"\"\nPerform the action of creating a snapshot of specified indices in Elasticsearch.\n\nThis method verifies if the repository for storing the snapshot exists and \nchecks if a snapshot is already in progress. It uses the `SnapshotClient.create` method \nto initiate the snapshot creation process with the provided parameters, including options \nfor ignoring unavailable shards, including global state, and snapshot indexing settings.\n\nParameters:\n- `self`: The current instance of the Snapshot class, which contains attributes such as \n  `repository`, `name`, `ignore_unavailable`, `include_global_state`, `indices`, \n  `partial`, `wait_for_completion`, `wait_interval`, and `max_wait`. These control \n  various aspects of the snapshot creation process.\n  \nReturns:\n- None\n\nRaises:\n- `SnapshotInProgress`: If a snapshot is already being created when this method is called.\n- `ActionError`: Raised if the snapshot cannot be created for any reason related to the repository \n  or index list.\n\nSide Effects:\n- Initiates the creation of a snapshot which is logged using the `loggit` logger.\n- If `wait_for_completion` is set to True, it blocks further execution until the snapshot creation \n  is complete, checking for completion using the `wait_for_it` function.\n\nDependencies:\n- Utilizes helper functions such as `verify_repository`, `snapshot_running`, and `report_failure` \n  from the `curator.helpers` module to ensure valid operations throughout the snapshot creation process.\n\"\"\"\n```\n\n- CLASS METHOD: Snapshot.report_state\n  - CLASS SIGNATURE: class Snapshot(object):\n  - SIGNATURE: def report_state(self):\n  - DOCSTRING: \n```python\n\"\"\"\nLog the state of the snapshot and raise a `FailedSnapshot` exception if the state is not `SUCCESS`.\n\nThis method invokes `get_state()` to retrieve the current state of the snapshot using the Elasticsearch client, checking it against the defined `self.state`. If the state is `SUCCESS`, it logs a success message; otherwise, it logs an error message indicating the snapshot's completion state and raises a `FailedSnapshot` exception with the detailed message.\n\nInteraction with other parts of the code:\n- The method relies on `self.client` and `self.name` (defined during the initialization of the `Snapshot` class) to communicate with the Elasticsearch service.\n- It also interacts with the `loggit` logger instance for logging purposes.\n\nImportant constants:\n- `self.state`: Holds the current state of the snapshot. This is retrieved using `get_state()` and indicates if the snapshot succeeded or failed.\n\"\"\"\n```\n\n- CLASS METHOD: Snapshot.do_dry_run\n  - CLASS SIGNATURE: class Snapshot(object):\n  - SIGNATURE: def do_dry_run(self):\n  - DOCSTRING: \n```python\n\"\"\"\nLog the intended action for creating a snapshot without executing it. This method is useful for previewing what the snapshot operation would entail, displaying the snapshot name, repository, and relevant settings without making any changes to the system.\n\nNo parameters are required, and the method does not return any values. Instead, it outputs log messages indicating that the operation is in DRY-RUN mode and detailing the settings that would be used if the action were performed.\n\nThe method utilizes the `loggit` attribute, which is a logger for tracking events related to the snapshot operations. The `name` and `repository` attributes represent the snapshot's designated name and the repository it will utilize, respectively. The `settings` attribute is a dictionary containing the parameters configured for the snapshot operation.\n\"\"\"\n```\n\n- CLASS METHOD: Snapshot.__init__\n  - CLASS SIGNATURE: class Snapshot(object):\n  - SIGNATURE: def __init__(self, ilo, repository=None, name=None, ignore_unavailable=False, include_global_state=True, partial=False, wait_for_completion=True, wait_interval=9, max_wait=-1, skip_repo_fs_check=True):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes the Snapshot action class for creating snapshots of Elasticsearch indices.\n\n:param ilo: An IndexList object containing the indices to be snaphotted.\n:param repository: (Optional) Repository name where the snapshot will be stored.\n:param name: (Optional) Name of the snapshot. Must be provided if not using date pattern.\n:param ignore_unavailable: (Optional) If True, unavailable shards/indices will be ignored.\n:param include_global_state: (Optional) If True, the global state of the cluster will be included in the snapshot.\n:param partial: (Optional) If True, the snapshot will not fail if primary shards are unavailable.\n:param wait_for_completion: (Optional) If True, the method will wait for the snapshot creation to complete.\n:param wait_interval: (Optional) Number of seconds to wait between completion checks.\n:param max_wait: (Optional) Maximum time to wait for snapshot completion (in seconds).\n:param skip_repo_fs_check: (Optional) If True, skips validation of write access to the repository on cluster nodes.\n\nThe constructor verifies the provided IndexList object and checks for the existence of the specified repository \nbefore initializing instance attributes. Key attributes include `index_list`, `client`, `name`, `repository`, \nand `settings`, which are derived from the input parameters and assist in the snapshotting process. If \n`name` is not provided, an exception is raised. The method also logs messages related to the snapshot action \nusing the configured logger.\n\nIt interacts with utility functions from the `curator.helpers` module to validate inputs and parse date patterns.\n\"\"\"\n```\n\n## FILE 2: curator/exceptions.py\n\n## FILE 3: curator/indexlist.py\n\n- CLASS METHOD: IndexList.__init__\n  - CLASS SIGNATURE: class IndexList:\n  - SIGNATURE: def __init__(self, client, search_pattern='_all'):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an IndexList instance.\n\nThis constructor initializes the IndexList object used for managing and filtering Elasticsearch indices. It requires an Elasticsearch client object to interact with the Elasticsearch cluster, and it populates the initial index list based on the provided search pattern.\n\nParameters:\n- client (Elasticsearch): An instance of an Elasticsearch client used for querying index data.\n- search_pattern (str): A string pattern to match indices, defaults to '_all', which targets all indices.\n\nThis method invokes `verify_client_object` to ensure the client is valid, and it initializes several attributes:\n- `self.client`: Stores the Elasticsearch client object.\n- `self.index_info`: A dictionary to hold metadata about the indices.\n- `self.indices`: A list for working with actionable indices.\n- `self.all_indices`: A list of all indices in the cluster at the time of initialization.\n- `self.age_keyfield`: Initialized to None, to potentially hold a key field for age calculations later.\n\nThe method calls `__get_indices` to populate `self.all_indices` and `self.indices` based on the search pattern.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "curator/actions/snapshot.py": "\"\"\"Snapshot and Restore action classes\"\"\"\nimport logging\nimport re\nfrom es_client.helpers.utils import ensure_list\nfrom curator.helpers.date_ops import parse_datemath, parse_date_pattern\nfrom curator.helpers.getters import get_indices\nfrom curator.helpers.testers import repository_exists, snapshot_running, verify_index_list, verify_repository, verify_snapshot_list\nfrom curator.helpers.utils import report_failure, to_csv\nfrom curator.helpers.waiters import wait_for_it\nfrom curator.exceptions import ActionError, CuratorException, FailedRestore, FailedSnapshot, MissingArgument, SnapshotInProgress\n\nclass Snapshot(object):\n    \"\"\"Snapshot Action Class\n\n    Read more about identically named settings at:\n    :py:meth:`elasticsearch.client.SnapshotClient.create`\n    \"\"\"\n\nclass DeleteSnapshots:\n    \"\"\"Delete Snapshots Action Class\"\"\"\n\n    def __init__(self, slo, retry_interval=120, retry_count=3):\n        \"\"\"\n        :param slo: A SnapshotList object\n        :type slo: :py:class:`~.curator.snapshotlist.SnapshotList`\n        :param retry_interval: Seconds to delay betwen retries. (Default: ``120``)\n        :type retry_interval: int\n        :param retry_count: Number of attempts to make. (Default: ``3``)\n        :type retry_count: int\n        \"\"\"\n        verify_snapshot_list(slo)\n        self.snapshot_list = slo\n        self.client = slo.client\n        self.retry_interval = retry_interval\n        self.retry_count = retry_count\n        self.repository = slo.repository\n        self.loggit = logging.getLogger('curator.actions.delete_snapshots')\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        mykwargs = {'repository': self.repository, 'retry_interval': self.retry_interval, 'retry_count': self.retry_count}\n        for snap in self.snapshot_list.snapshots:\n            self.loggit.info('DRY-RUN: delete_snapshot: %s with arguments: %s', snap, mykwargs)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.SnapshotClient.delete` snapshots in\n        :py:attr:`snapshot_list`. Retry up to :py:attr:`retry_count` times, pausing\n        :py:attr:`retry_interval` seconds between retries.\n        \"\"\"\n        self.snapshot_list.empty_list_check()\n        msg = f'Deleting {len(self.snapshot_list.snapshots)} selected snapshots: {self.snapshot_list.snapshots}'\n        self.loggit.info(msg)\n        try:\n            for snap in self.snapshot_list.snapshots:\n                self.loggit.info('Deleting snapshot %s...', snap)\n                self.client.snapshot.delete(repository=self.repository, snapshot=snap)\n        except Exception as err:\n            report_failure(err)\n\nclass Restore(object):\n    \"\"\"Restore Action Class\n\n    Read more about identically named settings at:\n    :py:meth:`elasticsearch.client.SnapshotClient.restore`\n    \"\"\"\n\n    def __init__(self, slo, name=None, indices=None, include_aliases=False, ignore_unavailable=False, include_global_state=False, partial=False, rename_pattern=None, rename_replacement=None, extra_settings=None, wait_for_completion=True, wait_interval=9, max_wait=-1, skip_repo_fs_check=True):\n        \"\"\"\n        :param slo: A SnapshotList object\n        :param name: Name of the snapshot to restore.  If ``None``, use the most recent snapshot.\n        :param indices: Indices to restore.  If ``None``, all in the snapshot will be restored.\n        :param include_aliases: Restore aliases with the indices.\n        :param ignore_unavailable: Ignore unavailable shards/indices.\n        :param include_global_state: Restore cluster global state with snapshot.\n        :param partial: Do not fail if primary shard is unavailable.\n        :param rename_pattern: A regular expression pattern with one or more captures, e.g.\n            ``index_(.+)``\n        :param rename_replacement: A target index name pattern with `$#` numbered references to the\n            captures in ``rename_pattern``, e.g. ``restored_index_$1``\n        :param extra_settings: Index settings to apply to restored indices.\n        :param wait_for_completion: Wait for completion before returning.\n        :param wait_interval: Seconds to wait between completion checks.\n        :param max_wait: Maximum number of seconds to ``wait_for_completion``\n        :param skip_repo_fs_check: Do not validate write access to repository on all cluster nodes\n            before proceeding. Useful for shared filesystems where intermittent timeouts can affect\n            validation, but won't likely affect snapshot success. (Default: ``True``)\n\n        :type slo: :py:class:`~.curator.snapshotlist.SnapshotList`\n        :type name: str\n        :type indices: list\n        :type include_aliases: bool\n        :type ignore_unavailable: bool\n        :type include_global_state: bool\n        :type partial: bool\n        :type rename_pattern: str\n        :type rename_replacement: str\n        :type extra_settings: dict\n        :type wait_for_completion: bool\n        :type wait_interval: int\n        :type max_wait: int\n        :type skip_repo_fs_check: bool\n        \"\"\"\n        if extra_settings is None:\n            extra_settings = {}\n        self.loggit = logging.getLogger('curator.actions.snapshot')\n        verify_snapshot_list(slo)\n        most_recent = slo.most_recent()\n        self.loggit.debug('\"most_recent\" snapshot: %s', most_recent)\n        self.name = name if name else most_recent\n        if slo.snapshot_info[self.name]['state'] == 'PARTIAL' and partial:\n            self.loggit.warning('Performing restore of snapshot in state PARTIAL.')\n        elif slo.snapshot_info[self.name]['state'] != 'SUCCESS':\n            raise CuratorException('Restore operation can only be performed on snapshots with state \"SUCCESS\", or \"PARTIAL\" if partial=True.')\n        self.snapshot_list = slo\n        self.client = slo.client\n        self.repository = slo.repository\n        if indices:\n            self.indices = ensure_list(indices)\n        else:\n            self.indices = slo.snapshot_info[self.name]['indices']\n        self.wfc = wait_for_completion\n        self.wait_interval = wait_interval\n        self.max_wait = max_wait\n        self.rename_pattern = rename_pattern if rename_replacement is not None else ''\n        self.rename_replacement = rename_replacement if rename_replacement is not None else ''\n        self.py_rename_replacement = self.rename_replacement.replace('$', '\\\\')\n        self.skip_repo_fs_check = skip_repo_fs_check\n        self.body = {'indices': self.indices, 'include_aliases': include_aliases, 'ignore_unavailable': ignore_unavailable, 'include_global_state': include_global_state, 'partial': partial, 'rename_pattern': self.rename_pattern, 'rename_replacement': self.rename_replacement}\n        self.include_aliases = include_aliases\n        self.ignore_unavailable = ignore_unavailable\n        self.include_global_state = include_global_state\n        self.include_aliases = include_aliases\n        self.partial = partial\n        self.index_settings = None\n        if extra_settings:\n            self.loggit.debug('Adding extra_settings to restore body: %s', extra_settings)\n            self.index_settings = extra_settings\n            try:\n                self.body.update(extra_settings)\n            except Exception:\n                self.loggit.error('Unable to apply extra settings to restore body')\n        self.loggit.debug('REPOSITORY: %s', self.repository)\n        self.loggit.debug('WAIT_FOR_COMPLETION: %s', self.wfc)\n        self.loggit.debug('SKIP_REPO_FS_CHECK: %s', self.skip_repo_fs_check)\n        self.loggit.debug('BODY: %s', self.body)\n        self._get_expected_output()\n\n    def _get_expected_output(self):\n        if not self.rename_pattern and (not self.rename_replacement):\n            self.expected_output = self.indices\n            return\n        self.expected_output = []\n        for index in self.indices:\n            self.expected_output.append(re.sub(self.rename_pattern, self.py_rename_replacement, index))\n            msg = f'index: {index} replacement: {self.expected_output[-1]}'\n            self.loggit.debug(msg)\n\n    def report_state(self):\n        \"\"\"\n        Log the state of the restore. This should only be done if ``wait_for_completion`` is\n        ``True``, and only after completing the restore.\n        \"\"\"\n        all_indices = get_indices(self.client)\n        found_count = 0\n        missing = []\n        for index in self.expected_output:\n            if index in all_indices:\n                found_count += 1\n                self.loggit.info('Found restored index %s', index)\n            else:\n                missing.append(index)\n        if found_count == len(self.expected_output):\n            self.loggit.info('All indices appear to have been restored.')\n        else:\n            msg = f'Some of the indices do not appear to have been restored. Missing: {missing}'\n            self.loggit.error(msg)\n            raise FailedRestore(msg)\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        args = {'wait_for_completion': self.wfc, 'body': self.body}\n        msg = f'DRY-RUN: restore: Repository: {self.repository} Snapshot name: {self.name} Arguments: {args}'\n        self.loggit.info(msg)\n        for index in self.indices:\n            if self.rename_pattern and self.rename_replacement:\n                rmsg = f'as {re.sub(self.rename_pattern, self.py_rename_replacement, index)}'\n            else:\n                rmsg = ''\n            self.loggit.info('DRY-RUN: restore: Index %s %s', index, rmsg)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.SnapshotClient.restore` :py:attr:`indices` from\n        :py:attr:`name` with passed params.\n        \"\"\"\n        if not self.skip_repo_fs_check:\n            verify_repository(self.client, self.repository)\n        if snapshot_running(self.client):\n            raise SnapshotInProgress('Cannot restore while a snapshot is in progress.')\n        try:\n            self.loggit.info('Restoring indices \"%s\" from snapshot: %s', self.indices, self.name)\n            self.client.snapshot.restore(repository=self.repository, snapshot=self.name, ignore_index_settings=None, ignore_unavailable=self.ignore_unavailable, include_aliases=self.include_aliases, include_global_state=self.include_global_state, index_settings=self.index_settings, indices=self.indices, partial=self.partial, rename_pattern=self.rename_pattern, rename_replacement=self.rename_replacement, wait_for_completion=False)\n            if self.wfc:\n                wait_for_it(self.client, 'restore', index_list=self.expected_output, wait_interval=self.wait_interval, max_wait=self.max_wait)\n                self.report_state()\n            else:\n                msg = f'\"wait_for_completion\" set to {self.wfc}. Remember to check for successful completion manually.'\n                self.loggit.warning(msg)\n        except Exception as err:\n            report_failure(err)",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\n\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\"",
    "curator/indexlist.py": "\"\"\"Index List Class\"\"\"\nimport re\nimport itertools\nimport logging\nfrom elasticsearch8.exceptions import NotFoundError, TransportError\nfrom es_client.helpers.schemacheck import SchemaCheck\nfrom es_client.helpers.utils import ensure_list\nfrom curator.defaults import settings\nfrom curator.exceptions import ActionError, ConfigurationError, MissingArgument, NoIndices\nfrom curator.helpers.date_ops import absolute_date_range, date_range, fix_epoch, get_date_regex, get_point_of_reference, get_unit_count_from_name, TimestringSearch\nfrom curator.helpers.getters import byte_size, get_indices\nfrom curator.helpers.testers import verify_client_object\nfrom curator.helpers.utils import chunk_index_list, report_failure, to_csv\nfrom curator.validators.filter_functions import filterstructure\n\nclass IndexList:\n    \"\"\"IndexList class\"\"\"\n\n    def __actionable(self, idx):\n        self.loggit.debug('Index %s is actionable and remains in the list.', idx)\n\n    def __not_actionable(self, idx):\n        self.loggit.debug('Index %s is not actionable, removing from list.', idx)\n        self.indices.remove(idx)\n\n    def __excludify(self, condition, exclude, index, msg=None):\n        if condition is True:\n            if exclude:\n                text = 'Removed from actionable list'\n                self.__not_actionable(index)\n            else:\n                text = 'Remains in actionable list'\n                self.__actionable(index)\n        elif exclude:\n            text = 'Remains in actionable list'\n            self.__actionable(index)\n        else:\n            text = 'Removed from actionable list'\n            self.__not_actionable(index)\n        if msg:\n            self.loggit.debug('%s: %s', text, msg)\n\n    def __get_indices(self, pattern):\n        \"\"\"\n        Pull all indices into ``all_indices``, then populate ``indices`` and\n        ``index_info``\n        \"\"\"\n        self.loggit.debug('Getting indices matching search_pattern: \"%s\"', pattern)\n        self.all_indices = get_indices(self.client, search_pattern=pattern)\n        self.indices = self.all_indices[:]\n\n    def __build_index_info(self, index):\n        \"\"\"\n        Ensure that ``index`` is a key in ``index_info``. If not, create a\n        sub-dictionary structure under that key.\n        \"\"\"\n        self.loggit.debug('Building preliminary index metadata for %s', index)\n        if index not in self.index_info:\n            self.index_info[index] = self.__zero_values()\n\n    def __map_method(self, ftype):\n        methods = {'alias': self.filter_by_alias, 'age': self.filter_by_age, 'allocated': self.filter_allocated, 'closed': self.filter_closed, 'count': self.filter_by_count, 'empty': self.filter_empty, 'forcemerged': self.filter_forceMerged, 'ilm': self.filter_ilm, 'kibana': self.filter_kibana, 'none': self.filter_none, 'opened': self.filter_opened, 'period': self.filter_period, 'pattern': self.filter_by_regex, 'space': self.filter_by_space, 'shards': self.filter_by_shards, 'size': self.filter_by_size}\n        return methods[ftype]\n\n    def __remove_missing(self, err):\n        \"\"\"\n        Remove missing index found in ``err`` from self.indices and return that name\n        \"\"\"\n        missing = err.info['error']['index']\n        self.loggit.warning('Index was initiallly present, but now is not: %s', missing)\n        self.loggit.debug('Removing %s from active IndexList', missing)\n        self.indices.remove(missing)\n        return missing\n\n    def __zero_values(self):\n        \"\"\"The default values for index metadata\"\"\"\n        return {'age': {'creation_date': 0, 'name': 0}, 'docs': 0, 'number_of_replicas': 0, 'number_of_shards': 0, 'primary_size_in_bytes': 0, 'routing': {}, 'segments': 0, 'size_in_bytes': 0, 'state': ''}\n\n    def _get_indices_segments(self, data):\n        return self.client.indices.segments(index=to_csv(data))['indices'].copy()\n\n    def _get_indices_settings(self, data):\n        return self.client.indices.get_settings(index=to_csv(data))\n\n    def _get_indices_stats(self, data):\n        return self.client.indices.stats(index=to_csv(data), metric='store,docs')['indices']\n\n    def _bulk_queries(self, data, exec_func):\n        slice_number = 10\n        query_result = {}\n        loop_number = round(len(data) / slice_number) if round(len(data) / slice_number) > 0 else 1\n        self.loggit.debug('Bulk Queries - number requests created: %s', loop_number)\n        for num in range(0, loop_number):\n            if num == loop_number - 1:\n                data_sliced = data[num * slice_number:]\n            else:\n                data_sliced = data[num * slice_number:(num + 1) * slice_number]\n            query_result.update(exec_func(data_sliced))\n        return query_result\n\n    def mitigate_alias(self, index):\n        \"\"\"\n        Mitigate when an alias is detected instead of an index name\n\n        :param index: The index name that is showing up *instead* of what was expected\n\n        :type index: str\n\n        :returns: No return value:\n        :rtype: None\n        \"\"\"\n        self.loggit.debug('BEGIN mitigate_alias')\n        self.loggit.debug('Correcting an instance where an alias name points to index \"%s\"', index)\n        data = self.client.indices.get(index=index)\n        aliases = list(data[index]['aliases'])\n        if aliases:\n            for alias in aliases:\n                if alias in self.indices:\n                    self.loggit.warning('Removing alias \"%s\" from IndexList.indices', alias)\n                    self.indices.remove(alias)\n                if alias in list(self.index_info):\n                    self.loggit.warning('Removing alias \"%s\" from IndexList.index_info', alias)\n                    del self.index_info[alias]\n        self.loggit.debug('Adding \"%s\" to IndexList.indices', index)\n        self.indices.append(index)\n        self.loggit.debug('Adding preliminary metadata for \"%s\" to IndexList.index_info', index)\n        self.__build_index_info(index)\n        self.loggit.debug('END mitigate_alias')\n\n    def alias_index_check(self, data):\n        \"\"\"\n        Check each index in data to see if it's an alias.\n        \"\"\"\n        working_list = data[:]\n        for entry in working_list:\n            if self.client.indices.exists_alias(name=entry):\n                index = list(self.client.indices.get_alias(name=entry).keys())[0]\n                self.loggit.warning('\"%s\" is actually an alias for index \"%s\"', entry, index)\n                self.mitigate_alias(index)\n                data.remove(entry)\n                data.append(index)\n        return data\n\n    def indices_exist(self, data, exec_func):\n        \"\"\"Check if indices exist. If one doesn't, remove it. Loop until all exist\"\"\"\n        self.loggit.debug('BEGIN indices_exist')\n        checking = True\n        working_list = {}\n        verified_data = self.alias_index_check(data)\n        while checking:\n            try:\n                working_list.update(exec_func(verified_data))\n            except NotFoundError as err:\n                data.remove(self.__remove_missing(err))\n                continue\n            except TransportError as err:\n                if '413' in err.errors:\n                    msg = 'Huge Payload 413 Err - Trying to get information via multiple requests'\n                    self.loggit.debug(msg)\n                    working_list.update(self._bulk_queries(verified_data, exec_func))\n            checking = False\n        return working_list\n\n    def data_getter(self, data, exec_func):\n        \"\"\"\n        Function that prevents unnecessary code repetition for different data\n        getter methods\n        \"\"\"\n        self.loggit.debug('BEGIN data_getter')\n        checking = True\n        while checking:\n            working_list = self.indices_exist(data, exec_func)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        sii = self.index_info[index]\n                    except KeyError:\n                        self.loggit.warning('Index %s was not present at IndexList initialization,  and may be behind an alias', index)\n                        self.mitigate_alias(index)\n                        sii = self.index_info[index]\n                        working_list = {}\n                        try:\n                            working_list.update(self._bulk_queries(data, exec_func))\n                        except NotFoundError as err:\n                            data.remove(self.__remove_missing(err))\n                            continue\n                    yield (sii, working_list[index], index)\n            checking = False\n\n    def population_check(self, index, key):\n        \"\"\"Verify that key is in self.index_info[index], and that it is populated\"\"\"\n        retval = True\n        if index not in self.index_info:\n            self.__build_index_info(index)\n        if key not in self.index_info[index]:\n            self.index_info[index][key] = self.__zero_values()[key]\n        if self.index_info[index][key] == self.__zero_values()[key]:\n            retval = False\n        return retval\n\n    def needs_data(self, indices, fields):\n        \"\"\"Check for data population in self.index_info\"\"\"\n        self.loggit.debug('Indices: %s, Fields: %s', indices, fields)\n        needful = []\n        working_list = self.indices_exist(indices, self._get_indices_settings)\n        for idx in working_list:\n            count = 0\n            for field in fields:\n                if self.population_check(idx, field):\n                    count += 1\n            if count == 0:\n                needful.append(idx)\n        if fields == ['state']:\n            self.loggit.debug('Always check open/close for all passed indices')\n            needful = list(working_list.keys())\n        self.loggit.debug('These indices need data in index_info: %s', needful)\n        return needful\n\n    def get_index_settings(self):\n        \"\"\"\n        For each index in self.indices, populate ``index_info`` with:\n            creation_date\n            number_of_replicas\n            number_of_shards\n            routing information (if present)\n        \"\"\"\n        self.loggit.debug('Getting index settings -- BEGIN')\n        self.empty_list_check()\n        fields = ['age', 'number_of_replicas', 'number_of_shards', 'routing']\n        for lst in chunk_index_list(self.indices):\n            needful = self.needs_data(lst, fields)\n            if not needful:\n                continue\n            for sii, wli, _ in self.data_getter(needful, self._get_indices_settings):\n                sii['age']['creation_date'] = fix_epoch(wli['settings']['index']['creation_date'])\n                sii['number_of_replicas'] = wli['settings']['index']['number_of_replicas']\n                sii['number_of_shards'] = wli['settings']['index']['number_of_shards']\n                if 'routing' in wli['settings']['index']:\n                    sii['routing'] = wli['settings']['index']['routing']\n        self.loggit.debug('Getting index settings -- END')\n\n    def get_index_state(self):\n        \"\"\"\n        For each index in self.indices, populate ``index_info`` with:\n\n            state (open or closed)\n\n        from the cat API\n        \"\"\"\n        self.loggit.debug('Getting index state -- BEGIN')\n        self.empty_list_check()\n        fields = ['state']\n        for lst in chunk_index_list(self.indices):\n            needful = self.needs_data(lst, fields)\n            resp = self.client.cat.indices(index=to_csv(needful), format='json', h='index,status')\n            for entry in resp:\n                try:\n                    self.index_info[entry['index']]['state'] = entry['status']\n                except KeyError:\n                    self.loggit.warning('Index %s was not present at IndexList initialization, and may be behind an alias', entry['index'])\n                    self.mitigate_alias(entry['index'])\n                    self.index_info[entry['index']]['state'] = entry['status']\n\n    def get_index_stats(self):\n        \"\"\"\n        Populate ``index_info`` with index ``size_in_bytes``,\n        ``primary_size_in_bytes`` and doc count information for each index.\n        \"\"\"\n        self.loggit.debug('Getting index stats -- BEGIN')\n        self.empty_list_check()\n        fields = ['size_in_bytes', 'docs', 'primary_size_in_bytes']\n        self.get_index_state()\n        working_list = self.working_list()\n        for index in self.working_list():\n            if self.index_info[index]['state'] == 'close':\n                working_list.remove(index)\n        if working_list:\n            index_lists = chunk_index_list(working_list)\n            for lst in index_lists:\n                needful = self.needs_data(lst, fields)\n                if not needful:\n                    continue\n                for sii, wli, index in self.data_getter(needful, self._get_indices_stats):\n                    try:\n                        size = wli['total']['store']['size_in_bytes']\n                        docs = wli['total']['docs']['count']\n                        primary_size = wli['primaries']['store']['size_in_bytes']\n                        msg = f'Index: {index}  Size: {byte_size(size)}  Docs: {docs} PrimarySize: {byte_size(primary_size)}'\n                        self.loggit.debug(msg)\n                        sii['size_in_bytes'] = size\n                        sii['docs'] = docs\n                        sii['primary_size_in_bytes'] = primary_size\n                    except KeyError:\n                        msg = f'Index stats missing for \"{index}\" -- might be closed'\n                        self.loggit.warning(msg)\n\n    def get_segment_counts(self):\n        \"\"\"\n        Populate ``index_info`` with segment information for each index.\n        \"\"\"\n        self.loggit.debug('Getting index segment counts')\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            for sii, wli, _ in self.data_getter(lst, self._get_indices_segments):\n                shards = wli['shards']\n                segmentcount = 0\n                for shardnum in shards:\n                    for shard in range(0, len(shards[shardnum])):\n                        segmentcount += shards[shardnum][shard]['num_search_segments']\n                sii['segments'] = segmentcount\n\n    def empty_list_check(self):\n        \"\"\"Raise :py:exc:`~.curator.exceptions.NoIndices` if ``indices`` is empty\"\"\"\n        self.loggit.debug('Checking for empty list')\n        if not self.indices:\n            raise NoIndices('index_list object is empty.')\n\n    def working_list(self):\n        \"\"\"\n        Return the current value of ``indices`` as copy-by-value to prevent list\n        stomping during iterations\n        \"\"\"\n        self.loggit.debug('Generating working list of indices')\n        return self.indices[:]\n\n    def _get_name_based_ages(self, timestring):\n        \"\"\"\n        Add indices to ``index_info`` based on the age as indicated by the index\n        name pattern, if it matches ``timestring``\n\n        :param timestring: An :py:func:`time.strftime` pattern\n        \"\"\"\n        self.loggit.debug('Getting ages of indices by \"name\"')\n        self.empty_list_check()\n        tstr = TimestringSearch(timestring)\n        for index in self.working_list():\n            epoch = tstr.get_epoch(index)\n            if isinstance(epoch, int):\n                self.index_info[index]['age']['name'] = epoch\n            else:\n                msg = f'Timestring {timestring} was not found in index {index}. Removing from actionable list'\n                self.loggit.debug(msg)\n                self.indices.remove(index)\n\n    def _get_field_stats_dates(self, field='@timestamp'):\n        \"\"\"\n        Add indices to ``index_info`` based on the values the queries return, as\n        determined by the min and max aggregated values of ``field``\n\n        :param field: The field with the date value.  The field must be mapped in\n            elasticsearch as a date datatype. Default: ``@timestamp``\n        \"\"\"\n        self.loggit.debug('Cannot query closed indices. Omitting any closed indices.')\n        self.filter_closed()\n        self.loggit.debug('Cannot use field_stats with empty indices. Omitting any empty indices.')\n        self.filter_empty()\n        self.loggit.debug('Getting index date by querying indices for min & max value of %s field', field)\n        self.empty_list_check()\n        index_lists = chunk_index_list(self.indices)\n        for lst in index_lists:\n            for index in lst:\n                aggs = {'min': {'min': {'field': field}}, 'max': {'max': {'field': field}}}\n                response = self.client.search(index=index, size=0, aggs=aggs)\n                self.loggit.debug('RESPONSE: %s', response)\n                if response:\n                    try:\n                        res = response['aggregations']\n                        self.loggit.debug('res: %s', res)\n                        data = self.index_info[index]['age']\n                        data['min_value'] = fix_epoch(res['min']['value'])\n                        data['max_value'] = fix_epoch(res['max']['value'])\n                        self.loggit.debug('data: %s', data)\n                    except KeyError as exc:\n                        raise ActionError(f'Field \"{field}\" not found in index \"{index}\"') from exc\n\n    def _calculate_ages(self, source=None, timestring=None, field=None, stats_result=None):\n        \"\"\"\n        This method initiates index age calculation based on the given parameters.\n        Exceptions are raised when they are improperly configured.\n\n        Set instance variable ``age_keyfield`` for use later, if needed.\n\n        :param source: Source of index age. Can be: ``name``, ``creation_date``,\n            or ``field_stats``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used\n            in conjunction with ``source=field_stats`` to choose whether to reference\n            the min or max result value.\n        \"\"\"\n        self.age_keyfield = source\n        if source == 'name':\n            if not timestring:\n                raise MissingArgument('source \"name\" requires the \"timestring\" keyword argument')\n            self._get_name_based_ages(timestring)\n        elif source == 'creation_date':\n            pass\n        elif source == 'field_stats':\n            if not field:\n                raise MissingArgument('source \"field_stats\" requires the \"field\" keyword argument')\n            if stats_result not in ['min_value', 'max_value']:\n                raise ValueError(f'Invalid value for \"stats_result\": {stats_result}')\n            self.age_keyfield = stats_result\n            self._get_field_stats_dates(field=field)\n        else:\n            raise ValueError(f'Invalid source: {source}. Must be one of \"name\", \"creation_date\", \"field_stats\".')\n\n    def _sort_by_age(self, index_list, reverse=True):\n        \"\"\"\n        Take a list of indices and sort them by date.\n\n        By default, the youngest are first with ``reverse=True``, but the oldest\n        can be first by setting ``reverse=False``\n        \"\"\"\n        temp = {}\n        for index in index_list:\n            try:\n                if self.index_info[index]['age'][self.age_keyfield]:\n                    temp[index] = self.index_info[index]['age'][self.age_keyfield]\n                else:\n                    msg = f'No date for \"{index}\" in IndexList metadata. Possible timestring mismatch. Excluding index \"{index}\".'\n                    self.__excludify(True, True, index, msg)\n            except KeyError:\n                msg = f'{index} does not have key \"{self.age_keyfield}\" in IndexList metadata'\n                self.__excludify(True, True, index, msg)\n        temp_tuple = sorted(temp.items(), key=lambda k: k[0], reverse=reverse)\n        sorted_tuple = sorted(temp_tuple, key=lambda k: k[1], reverse=reverse)\n        return [x[0] for x in sorted_tuple]\n\n    def filter_by_regex(self, kind=None, value=None, exclude=False):\n        \"\"\"\n        Match indices by regular expression (pattern).\n\n        :param kind: Can be one of: ``suffix``, ``prefix``, ``regex``, or\n            ``timestring``. This option defines what ``kind`` of filter you will\n            be building.\n        :param value: Depends on ``kind``. It is the :py:func:`time.strftime` string if\n            ``kind`` is ``timestring``. It's used to build the regular expression\n            for other kinds.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by regex')\n        if kind not in ['regex', 'prefix', 'suffix', 'timestring']:\n            raise ValueError(f'{kind}: Invalid value for kind')\n        if value == 0:\n            pass\n        elif not value:\n            raise ValueError('Invalid None value for \"value\". Cannot be \"None\" type, empty, or False')\n        if kind == 'timestring':\n            regex = settings.regex_map()[kind].format(get_date_regex(value))\n        else:\n            regex = settings.regex_map()[kind].format(value)\n        self.empty_list_check()\n        pattern = re.compile(regex)\n        for index in self.working_list():\n            self.loggit.debug('Filter by regex: Index: %s', index)\n            match = pattern.search(index)\n            if match:\n                self.__excludify(True, exclude, index)\n            else:\n                self.__excludify(False, exclude, index)\n\n    def filter_by_age(self, source='name', direction=None, timestring=None, unit=None, unit_count=None, field=None, stats_result='min_value', epoch=None, exclude=False, unit_count_pattern=False):\n        \"\"\"\n        Match indices by relative age calculations.\n\n        :param source: Source of index age. Can be one of ``name``, ``creation_date``,\n            or ``field_stats``\n        :param direction: Time to filter, either ``older`` or ``younger``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param unit: One of ``seconds``, ``minutes``, ``hours``, ``days``, ``weeks``,\n            ``months``, or ``years``.\n        :param unit_count: The count of ``unit``. ``unit_count`` * ``unit`` will\n            be calculated out to the relative number of seconds.\n        :param unit_count_pattern: A regular expression whose capture group identifies\n            the value for ``unit_count``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used\n            in conjunction with ``source=field_stats`` to choose whether to reference\n            the minimum or maximum result value.\n        :param epoch: An epoch timestamp used in conjunction with ``unit`` and\n            ``unit_count`` to establish a point of reference for calculations.\n            If not provided, the current time will be used.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude`` is `False`, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by age')\n        por = get_point_of_reference(unit, unit_count, epoch)\n        if not direction:\n            raise MissingArgument('Must provide a value for \"direction\"')\n        if direction not in ['older', 'younger']:\n            raise ValueError(f'Invalid value for \"direction\": {direction}')\n        self.get_index_settings()\n        self._calculate_ages(source=source, timestring=timestring, field=field, stats_result=stats_result)\n        if unit_count_pattern:\n            try:\n                unit_count_matcher = re.compile(unit_count_pattern)\n            except Exception as exc:\n                self.loggit.error('Regular expression failure. Will not match unit count. Error: %s', exc)\n                unit_count_matcher = None\n        for index in self.working_list():\n            try:\n                remove_this_index = False\n                age = int(self.index_info[index]['age'][self.age_keyfield])\n                msg = f'Index \"{index}\" age ({age}), direction: \"{direction}\", point of reference, ({por})'\n                if unit_count_pattern:\n                    msg = f'unit_count_pattern is set, trying to match pattern to index \"{index}\"'\n                    self.loggit.debug(msg)\n                    unit_count_from_index = get_unit_count_from_name(index, unit_count_matcher)\n                    if unit_count_from_index:\n                        self.loggit.debug('Pattern matched, applying unit_count of  \"%s\"', unit_count_from_index)\n                        adjustedpor = get_point_of_reference(unit, unit_count_from_index, epoch)\n                        msg = f'Adjusting point of reference from {por} to {adjustedpor} based on unit_count of {unit_count_from_index} from index name'\n                        self.loggit.debug(msg)\n                    elif unit_count == -1:\n                        msg = f'Unable to match pattern and no fallback value set. Removing index \"{index}\" from actionable list'\n                        self.loggit.debug(msg)\n                        remove_this_index = True\n                        adjustedpor = por\n                    else:\n                        self.loggit.debug('Unable to match pattern using fallback value of \"%s\"', unit_count)\n                        adjustedpor = por\n                else:\n                    adjustedpor = por\n                if direction == 'older':\n                    agetest = age < adjustedpor\n                else:\n                    agetest = age > adjustedpor\n                self.__excludify(agetest and (not remove_this_index), exclude, index, msg)\n            except KeyError:\n                msg = f'Index \"{index}\" does not meet provided criteria. Removing from list.'\n                self.loggit.debug(msg)\n                self.indices.remove(index)\n\n    def filter_by_space(self, disk_space=None, reverse=True, use_age=False, source='creation_date', timestring=None, field=None, stats_result='min_value', exclude=False, threshold_behavior='greater_than'):\n        \"\"\"\n        Remove indices from the actionable list based on space consumed, sorted\n        reverse-alphabetically by default.  If you set ``reverse`` to ``False``,\n        it will be sorted alphabetically.\n\n        The default is usually what you will want. If only one kind of index is\n        provided--for example, indices matching ``logstash-%Y.%m.%d`` --then\n        reverse alphabetical sorting will mean the oldest will remain in the list,\n        because lower numbers in the dates mean older indices.\n\n        By setting ``reverse`` to ``False``, then ``index3`` will be deleted before\n        ``index2``, which will be deleted before ``index1``\n\n        ``use_age`` allows ordering indices by age. Age is determined by the\n        index creation date by default, but you can specify an ``source`` of\n        ``name``, ``max_value``, or ``min_value``. The ``name`` ``source`` requires\n        the timestring argument.\n\n        ``threshold_behavior``, when set to ``greater_than`` (default), includes\n        if it the index tests to be larger than ``disk_space``. When set to\n        ``less_than``, it includes if the index is smaller than ``disk_space``\n\n        :param disk_space: Filter indices over *n* gigabytes\n        :param threshold_behavior: Size to filter, either ``greater_than`` or\n            ``less_than``. Defaults to ``greater_than`` to preserve backwards\n            compatability.\n        :param reverse: The filtering direction. (default: ``True``).  Ignored if\n            ``use_age`` is ``True``\n        :param use_age: Sort indices by age.  ``source`` is required in this case.\n        :param source: Source of index age. Can be one of ``name``, ``creation_date``,\n            or ``field_stats``. Default: ``creation_date``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used if ``source=name`` is selected.\n        :param field: A timestamp field name.  Only used if ``source=field_stats``\n            is selected.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used if\n            ``source=field_stats`` is selected. It determines whether to reference\n            the minimum or maximum value of `field` in each index.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by disk space')\n        if not disk_space:\n            raise MissingArgument('No value for \"disk_space\" provided')\n        if threshold_behavior not in ['greater_than', 'less_than']:\n            raise ValueError(f'Invalid value for \"threshold_behavior\": {threshold_behavior}')\n        self.get_index_stats()\n        self.get_index_settings()\n        disk_space = float(disk_space)\n        disk_usage = 0.0\n        disk_limit = disk_space * 2 ** 30\n        msg = 'Cannot get disk usage info from closed indices. Omitting any closed indices.'\n        self.loggit.debug(msg)\n        self.filter_closed()\n        if use_age:\n            self._calculate_ages(source=source, timestring=timestring, field=field, stats_result=stats_result)\n            self.loggit.debug('SORTING BY AGE')\n            sorted_indices = self._sort_by_age(self.working_list())\n        else:\n            sorted_indices = sorted(self.working_list(), reverse=reverse)\n        for index in sorted_indices:\n            disk_usage += self.index_info[index]['size_in_bytes']\n            msg = f'{index}, summed disk usage is {byte_size(disk_usage)} and disk limit is {byte_size(disk_limit)}.'\n            if threshold_behavior == 'greater_than':\n                self.__excludify(disk_usage > disk_limit, exclude, index, msg)\n            elif threshold_behavior == 'less_than':\n                self.__excludify(disk_usage < disk_limit, exclude, index, msg)\n\n    def filter_kibana(self, exclude=True):\n        \"\"\"\n        Match any index named ``.kibana*`` in ``indices``. Older releases addressed\n        index names that no longer exist.\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering kibana indices')\n        self.empty_list_check()\n        for index in self.working_list():\n            pattern = re.compile('^\\\\.kibana.*$')\n            if pattern.match(index):\n                self.__excludify(True, exclude, index)\n            else:\n                self.__excludify(False, exclude, index)\n\n    def filter_forceMerged(self, max_num_segments=None, exclude=True):\n        \"\"\"\n        Match any index which has ``max_num_segments`` per shard or fewer in the\n        actionable list.\n\n        :param max_num_segments: Cutoff number of segments per shard.\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering forceMerged indices')\n        if not max_num_segments:\n            raise MissingArgument('Missing value for \"max_num_segments\"')\n        self.loggit.debug('Cannot get segment count of closed indices. Omitting any closed indices.')\n        self.get_index_state()\n        self.get_index_settings()\n        self.filter_closed()\n        self.get_segment_counts()\n        for index in self.working_list():\n            shards = int(self.index_info[index]['number_of_shards'])\n            replicas = int(self.index_info[index]['number_of_replicas'])\n            segments = int(self.index_info[index]['segments'])\n            msg = f'{index} has {shards} shard(s) + {replicas} replica(s) with a sum total of {segments} segments.'\n            expected_count = (shards + shards * replicas) * max_num_segments\n            self.__excludify(segments <= expected_count, exclude, index, msg)\n\n    def filter_closed(self, exclude=True):\n        \"\"\"\n        Filter out closed indices from ``indices``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            indices from ``indices``. If ``exclude=False``, then only matching\n            indices will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering closed indices')\n        self.get_index_state()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['state'] == 'close'\n            self.loggit.debug('Index %s state: %s', index, self.index_info[index]['state'])\n            self.__excludify(condition, exclude, index)\n\n    def filter_empty(self, exclude=True):\n        \"\"\"\n        Filter indices with a document count of zero. Indices that are closed\n        are automatically excluded from consideration due to closed indices reporting\n        a document count of zero.\n\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering empty indices')\n        self.get_index_state()\n        self.get_index_stats()\n        self.filter_closed()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['docs'] == 0\n            self.loggit.debug('Index %s doc count: %s', index, self.index_info[index]['docs'])\n            self.__excludify(condition, exclude, index)\n\n    def filter_opened(self, exclude=True):\n        \"\"\"\n        Filter out opened indices from ``indices``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering open indices')\n        self.get_index_state()\n        self.empty_list_check()\n        for index in self.working_list():\n            condition = self.index_info[index]['state'] == 'open'\n            self.loggit.debug('Index %s state: %s', index, self.index_info[index]['state'])\n            self.__excludify(condition, exclude, index)\n\n    def filter_allocated(self, key=None, value=None, allocation_type='require', exclude=True):\n        \"\"\"\n        Match indices that have the routing allocation rule of ``key=value`` from\n        ``indices``\n\n        :param key: The allocation attribute to check for\n        :param value: The value to check for\n        :param allocation_type: Type of allocation to apply\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is `T`rue`\n        \"\"\"\n        self.loggit.debug('Filtering indices with shard routing allocation rules')\n        if not key:\n            raise MissingArgument('No value for \"key\" provided')\n        if not value:\n            raise MissingArgument('No value for \"value\" provided')\n        if allocation_type not in ['include', 'exclude', 'require']:\n            raise ValueError(f'Invalid \"allocation_type\": {allocation_type}')\n        self.get_index_settings()\n        self.get_index_state()\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            working_list = self._get_indices_settings(lst)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        has_routing = working_list[index]['settings']['index']['routing']['allocation'][allocation_type][key] == value\n                    except KeyError:\n                        has_routing = False\n                    msg = f'{index}: Routing (mis)match: index.routing.allocation.{allocation_type}.{key}={value}.'\n                    self.__excludify(has_routing, exclude, index, msg)\n\n    def filter_none(self):\n        \"\"\"The legendary NULL filter\"\"\"\n        self.loggit.debug('\"None\" filter selected.  No filtering will be done.')\n\n    def filter_by_alias(self, aliases=None, exclude=False):\n        \"\"\"\n        Match indices which are associated with the alias or list of aliases\n        identified by ``aliases``. Indices must appear in all aliases in list\n        ``aliases`` or a 404 error will result, leading to no indices being matched.\n\n        :param aliases: A list of alias names.\n        :type aliases: list\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices matching aliases: \"%s\"', aliases)\n        if not aliases:\n            raise MissingArgument('No value for \"aliases\" provided')\n        aliases = ensure_list(aliases)\n        self.empty_list_check()\n        for lst in chunk_index_list(self.indices):\n            try:\n                has_alias = list(self.client.indices.get_alias(index=to_csv(lst), name=to_csv(aliases)).keys())\n                self.loggit.debug('has_alias: %s', has_alias)\n            except NotFoundError:\n                has_alias = []\n            for index in lst:\n                if index in has_alias:\n                    isness = 'is'\n                    condition = True\n                else:\n                    isness = 'is not'\n                    condition = False\n                msg = f'{index} {isness} associated with aliases: {aliases}'\n                self.__excludify(condition, exclude, index, msg)\n\n    def filter_by_count(self, count=None, reverse=True, use_age=False, pattern=None, source='creation_date', timestring=None, field=None, stats_result='min_value', exclude=True):\n        \"\"\"\n        Remove indices from the actionable list beyond the number ``count``, sorted\n        reverse-alphabetically by default.  If you set ``reverse=False``, it will\n        be sorted alphabetically.\n\n        The default is usually what you will want. If only one kind of index is\n        provided--for example, indices matching ``logstash-%Y.%m.%d`` -- then\n        reverse alphabetical sorting will mean the oldest will remain in the list,\n        because lower numbers in the dates mean older indices.\n\n        By setting ``reverse=False``, then ``index3`` will be deleted before\n        ``index2``, which will be deleted before ``index1``\n\n        ``use_age`` allows ordering indices by age. Age is determined by the index\n        creation date by default, but you can specify an ``source`` of ``name``,\n        ``max_value``, or ``min_value``. The ``name`` `source` requires the\n        timestring argument.\n\n        :param count: Filter indices beyond ``count``.\n        :param reverse: The filtering direction. (default: ``True``).\n        :param use_age: Sort indices by age.  ``source`` is required in this case.\n        :param pattern: Select indices to count from a regular expression pattern.\n            This pattern must have one and only one capture group. This can allow\n            a single ``count`` filter instance to operate against any number of\n            matching patterns, and keep ``count`` of each index in that group.\n            For example, given a ``pattern`` of ``'^(.*)-\\\\d{6}$'``, it will match\n            both ``rollover-000001`` and ``index-999990``, but not\n            ``logstash-2017.10.12``. Following the same example, if my cluster\n            also had ``rollover-000002`` through ``rollover-000010`` and\n            ``index-888888`` through ``index-999999``, it will process both groups\n            of indices, and include or exclude the ``count`` of each.\n        :param source: Source of index age. Can be one of ``name``,\n            ``creation_date``, or ``field_stats``. Default: ``creation_date``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used if ``source=name``.\n        :param field: A timestamp field name.  Only used if ``source=field_stats``.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used if\n            ``source=field_stats``. It determines whether to reference the minimum\n            or maximum value of ``field`` in each index.\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering indices by count')\n        if not count:\n            raise MissingArgument('No value for \"count\" provided')\n        self.get_index_state()\n        self.get_index_settings()\n        working_list = self.working_list()\n        if pattern:\n            try:\n                regex = re.compile(pattern)\n                if regex.groups < 1:\n                    raise ConfigurationError(f'No regular expression group found in {pattern}')\n                if regex.groups > 1:\n                    raise ConfigurationError(f'More than 1 regular expression group found in {pattern}')\n                prune_these = list(filter(lambda x: regex.match(x) is None, working_list))\n                filtered_indices = working_list\n                for index in prune_these:\n                    msg = '{index} does not match regular expression {pattern}.'\n                    condition = True\n                    exclude = True\n                    self.__excludify(condition, exclude, index, msg)\n                    filtered_indices.remove(index)\n                presorted = sorted(filtered_indices, key=lambda x: regex.match(x).group(1))\n            except Exception as exc:\n                raise ActionError(f'Unable to process pattern: \"{pattern}\". Error: {exc}') from exc\n            groups = []\n            for _, g in itertools.groupby(presorted, key=lambda x: regex.match(x).group(1)):\n                groups.append(list(g))\n        else:\n            groups = [working_list]\n        for group in groups:\n            if use_age:\n                if source != 'name':\n                    self.loggit.warning('Cannot get age information from closed indices unless source=\"name\".  Omitting any closed indices.')\n                    self.filter_closed()\n                self._calculate_ages(source=source, timestring=timestring, field=field, stats_result=stats_result)\n                sorted_indices = self._sort_by_age(group, reverse=reverse)\n            else:\n                sorted_indices = sorted(group, reverse=reverse)\n            idx = 1\n            for index in sorted_indices:\n                msg = f'{index} is {idx} of specified count of {count}.'\n                condition = True if idx <= count else False\n                self.__excludify(condition, exclude, index, msg)\n                idx += 1\n\n    def filter_by_shards(self, number_of_shards=None, shard_filter_behavior='greater_than', exclude=False):\n        \"\"\"\n        Match ``indices`` with a given shard count.\n\n        Selects all indices with a shard count ``greater_than`` ``number_of_shards``\n        by default. Use ``shard_filter_behavior`` to select indices with shard\n        count ``greater_than``, ``greater_than_or_equal``, ``less_than``,\n        ``less_than_or_equal``, or ``equal`` to ``number_of_shards``.\n\n        :param number_of_shards: shard threshold\n        :param shard_filter_behavior: Do you want to filter on ``greater_than``,\n            ``greater_than_or_equal``, ``less_than``, ``less_than_or_equal``,\n            or ``equal``?\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by number of shards')\n        if not number_of_shards:\n            raise MissingArgument('No value for \"number_of_shards\" provided')\n        if shard_filter_behavior not in ['greater_than', 'less_than', 'greater_than_or_equal', 'less_than_or_equal', 'equal']:\n            raise ValueError(f'Invalid value for \"shard_filter_behavior\": {shard_filter_behavior}')\n        if number_of_shards < 1 or (shard_filter_behavior == 'less_than' and number_of_shards == 1):\n            raise ValueError(f'Unacceptable value: {number_of_shards} -- \"number_of_shards\" cannot be less than 1. A valid index will have at least one shard.')\n        self.get_index_settings()\n        self.empty_list_check()\n        for index in self.working_list():\n            self.loggit.debug('Filter by number of shards: Index: %s', index)\n            if shard_filter_behavior == 'greater_than':\n                condition = int(self.index_info[index]['number_of_shards']) > number_of_shards\n            elif shard_filter_behavior == 'less_than':\n                condition = int(self.index_info[index]['number_of_shards']) < number_of_shards\n            elif shard_filter_behavior == 'greater_than_or_equal':\n                condition = int(self.index_info[index]['number_of_shards']) >= number_of_shards\n            elif shard_filter_behavior == 'less_than_or_equal':\n                condition = int(self.index_info[index]['number_of_shards']) <= number_of_shards\n            else:\n                condition = int(self.index_info[index]['number_of_shards']) == number_of_shards\n            self.__excludify(condition, exclude, index)\n\n    def filter_period(self, period_type='relative', source='name', range_from=None, range_to=None, date_from=None, date_to=None, date_from_format=None, date_to_format=None, timestring=None, unit=None, field=None, stats_result='min_value', intersect=False, week_starts_on='sunday', epoch=None, exclude=False):\n        \"\"\"\n        Match ``indices`` with ages within a given period.\n\n        :param period_type: Can be either ``absolute`` or ``relative``.  Default\n            is ``relative``. ``date_from`` and ``date_to`` are required when using\n            ``period_type='absolute'``. ``range_from`` and ``range_to`` are required\n            with ``period_type='relative'``.\n        :param source: Source of index age. Can be ``name``, ``creation_date``,\n            or ``field_stats``\n        :param range_from: How many ``unit`` (s) in the past/future is the origin?\n        :param range_to: How many ``unit`` (s) in the past/future is the end point?\n        :param date_from: The simplified date for the start of the range\n        :param date_to: The simplified date for the end of the range.  If this\n            value is the same as ``date_from``, the full value of ``unit`` will be\n            extrapolated for the range.  For example, if ``unit=months``, and\n            ``date_from`` and ``date_to`` are both ``2017.01``, then the entire\n            month of January 2017 will be the absolute date range.\n        :param date_from_format: The :py:func:`time.strftime` string used to\n            parse ``date_from``\n        :param date_to_format: The :py:func:`time.strftime` string used to\n            parse ``date_to``\n        :param timestring: An :py:func:`time.strftime` string to match the datestamp\n            in an index name. Only used for index filtering by ``name``.\n        :param unit: One of ``hours``, ``days``, ``weeks``, ``months``, or ``years``.\n        :param field: A timestamp field name.  Only used for ``field_stats`` based\n            calculations.\n        :param stats_result: Either ``min_value`` or ``max_value``.  Only used in\n            conjunction with ``source='field_stats'`` to choose whether to reference\n            the min or max result value.\n        :param intersect: Only used when ``source='field_stats'``. If ``True``,\n            only indices where both ``min_value`` and ``max_value`` are within the\n            period will be selected. If ``False``, it will use whichever you specified.\n            Default is ``False`` to preserve expected behavior.\n        :param week_starts_on: Either ``sunday`` or ``monday``. Default is ``sunday``\n        :param epoch: An epoch timestamp used to establish a point of reference for\n            calculations. If not provided, the current time will be used.\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by period')\n        if period_type not in ['absolute', 'relative']:\n            raise ValueError(f'Unacceptable value: {period_type} -- \"period_type\" must be either \"absolute\" or \"relative\".')\n        if period_type == 'relative':\n            func = date_range\n            args = [unit, range_from, range_to, epoch]\n            kwgs = {'week_starts_on': week_starts_on}\n            if not isinstance(range_from, int) or not isinstance(range_to, int):\n                raise ConfigurationError('\"range_from\" and \"range_to\" must be integer values')\n        else:\n            func = absolute_date_range\n            args = [unit, date_from, date_to]\n            kwgs = {'date_from_format': date_from_format, 'date_to_format': date_to_format}\n            for reqd in [date_from, date_to, date_from_format, date_to_format]:\n                if not reqd:\n                    raise ConfigurationError('Must provide \"date_from\", \"date_to\", \"date_from_format\", and \"date_to_format\" with absolute period_type')\n        self.get_index_settings()\n        try:\n            start, end = func(*args, **kwgs)\n        except Exception as exc:\n            report_failure(exc)\n        self._calculate_ages(source=source, timestring=timestring, field=field, stats_result=stats_result)\n        for index in self.working_list():\n            try:\n                if source == 'field_stats' and intersect:\n                    min_age = int(self.index_info[index]['age']['min_value'])\n                    max_age = int(self.index_info[index]['age']['max_value'])\n                    msg = f'Index \"{index}\", timestamp field \"{field}\", min_value ({min_age}), max_value ({max_age}), period start: \"{start}\", period end, \"{end}\"'\n                    inrange = min_age >= start and max_age <= end\n                else:\n                    age = int(self.index_info[index]['age'][self.age_keyfield])\n                    msg = f'Index \"{index}\" age ({age}), period start: \"{start}\", period end, \"{end}\"'\n                    inrange = age >= start and age <= end\n                self.__excludify(inrange, exclude, index, msg)\n            except KeyError:\n                self.loggit.debug('Index \"%s\" does not meet provided criteria. Removing from list.', index)\n                self.indices.remove(index)\n\n    def filter_ilm(self, exclude=True):\n        \"\"\"\n        Match indices that have the setting ``index.lifecycle.name``\n\n        :param exclude: If ``exclude=True``, this filter will remove matching\n            ``indices``. If ``exclude=False``, then only matching indices will be\n            kept in ``indices``. Default is ``True``\n        \"\"\"\n        self.loggit.debug('Filtering indices with index.lifecycle.name')\n        index_lists = chunk_index_list(self.indices)\n        if index_lists == [['']]:\n            self.loggit.debug('Empty working list. No ILM indices to filter.')\n            return\n        for lst in index_lists:\n            working_list = self._get_indices_settings(lst)\n            if working_list:\n                for index in list(working_list.keys()):\n                    try:\n                        subvalue = working_list[index]['settings']['index']['lifecycle']\n                        has_ilm = 'name' in subvalue\n                        msg = f'{index} has index.lifecycle.name {subvalue['name']}'\n                    except KeyError:\n                        has_ilm = False\n                        msg = f'index.lifecycle.name is not set for index {index}'\n                    self.__excludify(has_ilm, exclude, index, msg)\n\n    def iterate_filters(self, filter_dict):\n        \"\"\"\n        Iterate over the filters defined in ``config`` and execute them.\n\n        :param filter_dict: The configuration dictionary\n\n        .. note:: ``filter_dict`` should be a dictionary with the following form:\n        .. code-block:: python\n\n                { 'filters' : [\n                        {\n                            'filtertype': 'the_filter_type',\n                            'key1' : 'value1',\n                            ...\n                            'keyN' : 'valueN'\n                        }\n                    ]\n                }\n\n        \"\"\"\n        self.loggit.debug('Iterating over a list of filters')\n        if 'filters' not in filter_dict or len(filter_dict['filters']) < 1:\n            self.loggit.info('No filters in config.  Returning unaltered object.')\n            return\n        self.loggit.debug('All filters: %s', filter_dict['filters'])\n        for fil in filter_dict['filters']:\n            self.loggit.debug('Top of the loop: %s', self.indices)\n            self.loggit.debug('Un-parsed filter args: %s', fil)\n            chk = SchemaCheck(fil, filterstructure(), 'filter', 'IndexList.iterate_filters').result()\n            msg = f'Parsed filter args: {chk}'\n            self.loggit.debug(msg)\n            method = self.__map_method(fil['filtertype'])\n            del fil['filtertype']\n            if fil:\n                self.loggit.debug('Filter args: %s', fil)\n                self.loggit.debug('Pre-instance: %s', self.indices)\n                method(**fil)\n                self.loggit.debug('Post-instance: %s', self.indices)\n            else:\n                method()\n\n    def filter_by_size(self, size_threshold=None, threshold_behavior='greater_than', exclude=False, size_behavior='primary'):\n        \"\"\"\n        Remove indices from the actionable list based on index size.\n\n        ``threshold_behavior``, when set to ``greater_than`` (default), includes\n        if it the index tests to be larger than ``size_threshold``. When set to\n        ``less_than``, it includes if the index is smaller than ``size_threshold``\n\n        :param size_threshold: Filter indices over *n* gigabytes\n        :param threshold_behavior: Size to filter, either ``greater_than`` or\n            ``less_than``. Defaults to ``greater_than`` to preserve backwards\n            compatability.\n        :param size_behavior: Size that used to filter, either ``primary`` or\n            ``total``. Defaults to ``primary``\n        :param exclude: If ``exclude=True``, this filter will remove matching indices\n            from ``indices``. If ``exclude=False``, then only matching indices\n            will be kept in ``indices``. Default is ``False``\n        \"\"\"\n        self.loggit.debug('Filtering indices by index size')\n        if not size_threshold:\n            raise MissingArgument('No value for \"size_threshold\" provided')\n        if size_behavior not in ['primary', 'total']:\n            raise ValueError(f'Invalid value for \"size_behavior\": {size_behavior}')\n        if threshold_behavior not in ['greater_than', 'less_than']:\n            raise ValueError(f'Invalid value for \"threshold_behavior\": {threshold_behavior}')\n        index_size_limit = float(size_threshold) * 2 ** 30\n        msg = 'Cannot get disk usage info from closed indices. Omitting any closed indices.'\n        self.loggit.debug(msg)\n        self.get_index_state()\n        self.get_index_stats()\n        self.filter_closed()\n        working_list = self.working_list()\n        for index in working_list:\n            if size_behavior == 'primary':\n                index_size = self.index_info[index]['primary_size_in_bytes']\n            else:\n                index_size = self.index_info[index]['size_in_bytes']\n            msg = f'{index}, index size is {byte_size(index_size)} and size limit is {byte_size(index_size_limit)}.'\n            if threshold_behavior == 'greater_than':\n                self.__excludify(index_size > index_size_limit, exclude, index, msg)\n            elif threshold_behavior == 'less_than':\n                self.__excludify(index_size < index_size_limit, exclude, index, msg)"
  }
}