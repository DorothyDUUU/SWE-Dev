{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_collection",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_collection.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.collection import Collection\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\n\n\nclass TestPaginator:\n    @property\n    def collection(self) -> Collection:\n        return Collection(\n            name=\"name\",\n            attribute_name=\"attribute\",\n            parent_name=\"Parent\",\n            service_name=ServiceName(\"s3\", \"S3\"),\n            type_annotation=ExternalImport.from_class(ServiceName),\n            object_class_name=\"object\",\n        )\n\n    def test_init(self) -> None:\n        collection = self.collection\n        assert collection.name == \"name\"\n        assert collection.bases\n        assert collection.boto3_doc_link\n\n    def test_get_types(self) -> None:\n        assert len(set(self.collection.iterate_types())) == 2\n",
  "GT_file_code": {
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterator\n\nfrom boto3.resources.collection import ResourceCollection\n\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        name: str,\n        attribute_name: str,\n        parent_name: str,\n        service_name: ServiceName,\n        type_annotation: FakeAnnotation,\n        object_class_name: str,\n    ) -> None:\n        super().__init__(\n            name=name,\n            use_alias=True,\n            bases=[ExternalImport.from_class(ResourceCollection)],\n        )\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        parent_name_part = (\n            \"service-resource\" if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        )\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}\"\n            f\"/{parent_name_part}/{self.attribute_name}.html\"\n        )\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.boto3_doc_link_parent}\"\n            f\"#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}\"\n        )\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over all type annotations.\n        \"\"\"\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()\n",
    "mypy_boto3_builder/structures/class_record.py": "\"\"\"\nBase class for all structures that can be rendered to a class.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.utils.strings import xform_name\n\n\nclass ClassRecord:\n    \"\"\"\n    Base class for all structures that can be rendered to a class.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return \"\"\n\n    @property\n    def alias_name(self) -> str:\n        \"\"\"\n        Class alias name for safe import.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        if not self.use_alias:\n            raise StructureError(f\"Cannot get alias for {self.name} with no alias.\")\n\n        return InternalImport.get_alias(self.name)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over type annotations for methods, attributes and bases.\n        \"\"\"\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract import records from required type annotations.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n\n        return result\n\n    def get_internal_imports(self) -> set[InternalImport]:\n        \"\"\"\n        Get internal imports from methods.\n        \"\"\"\n        result: set[InternalImport] = set()\n        for method in self.methods:\n            for type_annotation in method.iterate_types():\n                if not isinstance(type_annotation, InternalImport):\n                    continue\n                result.add(type_annotation)\n\n        return result\n\n    @property\n    def variable_name(self) -> str:\n        \"\"\"\n        Variable name for an instance of this class.\n        \"\"\"\n        return xform_name(self.name)\n\n    @property\n    def method_names(self) -> list[str]:\n        \"\"\"\n        Unique method names.\n        \"\"\"\n        return sorted({i.name for i in self.methods})\n\n    def get_method(self, name: str) -> Method:\n        \"\"\"\n        Get method by name.\n        \"\"\"\n        for method in self.methods:\n            if method.name == name:\n                return method\n\n        raise StructureError(f\"Method {name} not found\")\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/structures/collection.py": {
      "Collection.__init__": {
        "code": "    def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n        \"\"\"Initialize a Collection instance for managing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The name of the attribute representing the collection.\n- parent_name (str): The name of the parent resource this collection belongs to.\n- service_name (ServiceName): An enum representing the service name associated with the collection.\n- type_annotation (FakeAnnotation): The type annotation for the object contained within the collection.\n- object_class_name (str): The class name of the objects handled by this collection.\n\nThis constructor calls the superclass initializer (`ClassRecord`) to set up the collection, utilizing `ExternalImport.from_class(ResourceCollection)` to incorporate Boto3's ResourceCollection functionality. The service_name attribute is used for generating documentation links related to the specific AWS service, while attribute_name and parent_name contribute to the proper identification of the resource structure within the service context. The type_annotation attribute enables type checking and hinting for the contents of the collection.\"\"\"\n        super().__init__(name=name, use_alias=True, bases=[ExternalImport.from_class(ResourceCollection)])\n        self.service_name = service_name\n        self.attribute_name = attribute_name\n        self.parent_name = parent_name\n        self.type_annotation = type_annotation\n        self.object_class_name = object_class_name",
        "docstring": "Initialize a Collection instance for managing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The name of the attribute representing the collection.\n- parent_name (str): The name of the parent resource this collection belongs to.\n- service_name (ServiceName): An enum representing the service name associated with the collection.\n- type_annotation (FakeAnnotation): The type annotation for the object contained within the collection.\n- object_class_name (str): The class name of the objects handled by this collection.\n\nThis constructor calls the superclass initializer (`ClassRecord`) to set up the collection, utilizing `ExternalImport.from_class(ResourceCollection)` to incorporate Boto3's ResourceCollection functionality. The service_name attribute is used for generating documentation links related to the specific AWS service, while attribute_name and parent_name contribute to the proper identification of the resource structure within the service context. The type_annotation attribute enables type checking and hinting for the contents of the collection.",
        "signature": "def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      },
      "Collection.boto3_doc_link_parent": {
        "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"Generates the link to the parent directory of the Boto3 documentation for the resource collection.\n\nThe method constructs a URL based on the service name and the attribute name of the resource collection. If the `parent_name` is equal to the `SERVICE_RESOURCE` constant, it uses \"service-resource\" in the URL; otherwise, it uses the lowercase version of `parent_name`. \n\nReturns:\n    str: A formatted URL string linking to the parent documentation page for the specified resource collection.\n\nDependencies:\n- `SERVICE_RESOURCE`: A constant defined in the `mypy_boto3_builder.constants` module that represents a specific service resource name.\n- `service_name`: An attribute of type `ServiceName`, which provides the base documentation link through its `boto3_doc_link_parent` property.\n- `attribute_name`: An attribute in the class that holds the specific name of the resource collection being documented.\"\"\"\n        '\\n        Link to boto3 docs parent directory.\\n        '\n        parent_name_part = 'service-resource' if self.parent_name == SERVICE_RESOURCE else self.parent_name.lower()\n        return f'{self.service_name.boto3_doc_link_parent}/{parent_name_part}/{self.attribute_name}.html'",
        "docstring": "Generates the link to the parent directory of the Boto3 documentation for the resource collection.\n\nThe method constructs a URL based on the service name and the attribute name of the resource collection. If the `parent_name` is equal to the `SERVICE_RESOURCE` constant, it uses \"service-resource\" in the URL; otherwise, it uses the lowercase version of `parent_name`. \n\nReturns:\n    str: A formatted URL string linking to the parent documentation page for the specified resource collection.\n\nDependencies:\n- `SERVICE_RESOURCE`: A constant defined in the `mypy_boto3_builder.constants` module that represents a specific service resource name.\n- `service_name`: An attribute of type `ServiceName`, which provides the base documentation link through its `boto3_doc_link_parent` property.\n- `attribute_name`: An attribute in the class that holds the specific name of the resource collection being documented.",
        "signature": "def boto3_doc_link_parent(self) -> str:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      },
      "Collection.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Generates a link to the Boto3 documentation specific to the resource collection represented by this instance. The link is constructed using the parent documentation URL obtained from the `boto3_doc_link_parent` property and appending the class name, parent name, and attribute name associated with this resource.\n\nReturns:\n    str: A formatted URL linking to the relevant Boto3 documentation section for the resource collection.\n\nDependencies:\n- `self.service_name.class_name`: Represents the class name of the service, used to form the URL.\n- `self.parent_name`: The name of the parent resource, which can impact the URL structure.\n- `self.attribute_name`: The attribute name of the resource collection, used within the link.\n\nThis method relies on the initialization of the `Collection` class, where `service_name`, `parent_name`, and `attribute_name` are set during instantiation.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'{self.boto3_doc_link_parent}#{self.service_name.class_name}.{self.parent_name}.{self.attribute_name}'",
        "docstring": "Generates a link to the Boto3 documentation specific to the resource collection represented by this instance. The link is constructed using the parent documentation URL obtained from the `boto3_doc_link_parent` property and appending the class name, parent name, and attribute name associated with this resource.\n\nReturns:\n    str: A formatted URL linking to the relevant Boto3 documentation section for the resource collection.\n\nDependencies:\n- `self.service_name.class_name`: Represents the class name of the service, used to form the URL.\n- `self.parent_name`: The name of the parent resource, which can impact the URL structure.\n- `self.attribute_name`: The attribute name of the resource collection, used within the link.\n\nThis method relies on the initialization of the `Collection` class, where `service_name`, `parent_name`, and `attribute_name` are set during instantiation.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      },
      "Collection.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"Iterate over all type annotations associated with the Collection instance.\n\nThis method yields type annotations from the parent class, as well as additional type annotations defined in the `type_annotation` attribute of the Collection instance. The `type_annotation` is expected to implement the `iterate_types` method, which will provide relevant annotations.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator that yields `FakeAnnotation` instances representing the type annotations.\n\nDependencies:\n    - Inherits from `ClassRecord`, which provides its own implementation of `iterate_types`.\n    - The `type_annotation` attribute must be an instance of `FakeAnnotation` or a subclass that implements `iterate_types` to yield its annotations.\"\"\"\n        '\\n        Iterate over all type annotations.\\n        '\n        yield from super().iterate_types()\n        yield from self.type_annotation.iterate_types()",
        "docstring": "Iterate over all type annotations associated with the Collection instance.\n\nThis method yields type annotations from the parent class, as well as additional type annotations defined in the `type_annotation` attribute of the Collection instance. The `type_annotation` is expected to implement the `iterate_types` method, which will provide relevant annotations.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator that yields `FakeAnnotation` instances representing the type annotations.\n\nDependencies:\n    - Inherits from `ClassRecord`, which provides its own implementation of `iterate_types`.\n    - The `type_annotation` attribute must be an instance of `FakeAnnotation` or a subclass that implements `iterate_types` to yield its annotations.",
        "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
        "type": "Method",
        "class_signature": "class Collection(ClassRecord):"
      }
    },
    "mypy_boto3_builder/structures/class_record.py": {
      "ClassRecord.__init__": {
        "code": "    def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:\n        \"\"\"Initializes a ClassRecord instance that represents a structure capable of being rendered as a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty tuple).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty tuple).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes represented as FakeAnnotation instances (default is an empty tuple).\n- use_alias (bool, optional): A flag indicating whether to use an alias for safe import, defaulting to False.\n\nAttributes:\n- self.name: Stores the class name.\n- self.methods: A list of methods belonging to the class.\n- self.attributes: A list of attributes belonging to the class.\n- self.bases: A list of base classes, allowing for inheritance representation.\n- self.use_alias: Determines if an alias for the class will be used.\n- self.docstring: Initializes an empty string to potentially hold the class's documentation.\n\nThis constructor facilitates the organization of various class elements and supports methods for type iteration and internal import extraction in the ClassRecord class.\"\"\"\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = ''",
        "docstring": "Initializes a ClassRecord instance that represents a structure capable of being rendered as a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty tuple).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty tuple).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes represented as FakeAnnotation instances (default is an empty tuple).\n- use_alias (bool, optional): A flag indicating whether to use an alias for safe import, defaulting to False.\n\nAttributes:\n- self.name: Stores the class name.\n- self.methods: A list of methods belonging to the class.\n- self.attributes: A list of attributes belonging to the class.\n- self.bases: A list of base classes, allowing for inheritance representation.\n- self.use_alias: Determines if an alias for the class will be used.\n- self.docstring: Initializes an empty string to potentially hold the class's documentation.\n\nThis constructor facilitates the organization of various class elements and supports methods for type iteration and internal import extraction in the ClassRecord class.",
        "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class ClassRecord:"
      },
      "ClassRecord.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"Iterate over type annotations for methods, attributes, and base classes contained within the ClassRecord.\n\nThis method yields `FakeAnnotation` instances, allowing iteration over the type annotations associated with each method, attribute, and base class defined in the ClassRecord. It interacts with the `methods`, `attributes`, and `bases` attributes, each of which must contain elements that support the `iterate_types` method. The output can be utilized for further processing, such as extracting import records or analyzing type dependencies.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator yielding type annotations found in methods, attributes, and bases.\"\"\"\n        '\\n        Iterate over type annotations for methods, attributes and bases.\\n        '\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()",
        "docstring": "Iterate over type annotations for methods, attributes, and base classes contained within the ClassRecord.\n\nThis method yields `FakeAnnotation` instances, allowing iteration over the type annotations associated with each method, attribute, and base class defined in the ClassRecord. It interacts with the `methods`, `attributes`, and `bases` attributes, each of which must contain elements that support the `iterate_types` method. The output can be utilized for further processing, such as extracting import records or analyzing type dependencies.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator yielding type annotations found in methods, attributes, and bases.",
        "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
        "type": "Method",
        "class_signature": "class ClassRecord:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        \"\"\"Initialize an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries, such as `boto3.service.Service`.\n\nParameters:\n- source (ImportString): The module import string representing the source of the annotation.\n- name (str, optional): The name of the import, defaults to an empty string.\n- alias (str, optional): A local alias for the import, defaults to an empty string.\n- safe (bool, optional): A flag indicating if the import should be wrapped in a try-except block, defaults to False.\n\nAttributes:\n- self.source: Stores the ImportString representing the source module.\n- self.name: The import name.\n- self.alias: The local alias for the import.\n- self.safe: Indicates whether the import is wrapped safely.\n\nThis constructor interacts with the ImportString class and will be used in conjunction with methods like `from_class`, `render`, and `import_record` within the ExternalImport class to handle type annotations effectively.\"\"\"\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe",
        "docstring": "Initialize an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries, such as `boto3.service.Service`.\n\nParameters:\n- source (ImportString): The module import string representing the source of the annotation.\n- name (str, optional): The name of the import, defaults to an empty string.\n- alias (str, optional): A local alias for the import, defaults to an empty string.\n- safe (bool, optional): A flag indicating if the import should be wrapped in a try-except block, defaults to False.\n\nAttributes:\n- self.source: Stores the ImportString representing the source module.\n- self.name: The import name.\n- self.alias: The local alias for the import.\n- self.safe: Indicates whether the import is wrapped safely.\n\nThis constructor interacts with the ImportString class and will be used in conjunction with methods like `from_class`, `render`, and `import_record` within the ExternalImport class to handle type annotations effectively.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.from_class": {
        "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"Create an instance of `ExternalImport` using an imported class.\n\nThis method attempts to derive the import string and the class name from an existing class object. It retrieves the module in which the class is defined and constructs an `ExternalImport` instance with the module's name and the class's name. \n\nParameters:\n- `cls`: The class type of `ExternalImport` being called.\n- `obj`: The class for which the `ExternalImport` instance is to be created.\n- `alias` (optional): A local name to refer to the imported class.\n- `safe` (optional): A boolean indicating whether the import should be wrapped in a try-except block.\n\nReturns:\n- An instance of `ExternalImport` initialized with the derived module name, class name, optional alias, and safety flag.\n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class object (`obj`) cannot be determined, indicating that the class is not associated with any module.\"\"\"\n        '\\n        Create an instance from an imported class.\\n\\n        Arguments:\\n            value -- Any Class.\\n            alias -- Local name.\\n            safe -- Whether import is wrapped in try-except.\\n        '\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
        "docstring": "Create an instance of `ExternalImport` using an imported class.\n\nThis method attempts to derive the import string and the class name from an existing class object. It retrieves the module in which the class is defined and constructs an `ExternalImport` instance with the module's name and the class's name. \n\nParameters:\n- `cls`: The class type of `ExternalImport` being called.\n- `obj`: The class for which the `ExternalImport` instance is to be created.\n- `alias` (optional): A local name to refer to the imported class.\n- `safe` (optional): A boolean indicating whether the import should be wrapped in a try-except block.\n\nReturns:\n- An instance of `ExternalImport` initialized with the derived module name, class name, optional alias, and safety flag.\n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class object (`obj`) cannot be determined, indicating that the class is not associated with any module.",
        "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value of the ExternalImport instance based on its attributes.\n\nThis method uses the `hash()` function to generate a unique hash value derived from the instance's `source`, `name`, `alias`, and `safe` attributes. These attributes determine how the instance will be treated in hash-based collections such as sets or dictionaries. The `source` is of type `ImportString`, which represents the module import string, while `name` and `alias` are strings representing the import's name and local alias, respectively. The `safe` attribute is a boolean indicating if the import is wrapped in try-except. This method is essential for maintaining the integrity of instances when used in hashed collections.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate the hash value of the ExternalImport instance based on its attributes.\n\nThis method uses the `hash()` function to generate a unique hash value derived from the instance's `source`, `name`, `alias`, and `safe` attributes. These attributes determine how the instance will be treated in hash-based collections such as sets or dictionaries. The `source` is of type `ImportString`, which represents the module import string, while `name` and `alias` are strings representing the import's name and local alias, respectively. The `safe` attribute is a boolean indicating if the import is wrapped in try-except. This method is essential for maintaining the integrity of instances when used in hashed collections.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.from_str": {
        "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"Create an ImportString instance from a dot-separated string representation of an import.\n\nParameters:\n    import_string (str): A string representing the import, formatted as \"module.submodule\".\n\nReturns:\n    ImportString: An instance of ImportString initialized with parts split from the input string.\n\nRaises:\n    StructureError: If the input string is empty or improperly formatted with nested dots.\n\nThis method leverages the ImportString class's capability to manage and validate Python import paths, ensuring correct structure before instantiation.\"\"\"\n        '\\n        Create from string.\\n        '\n        return cls(*import_string.split('.'))",
        "docstring": "Create an ImportString instance from a dot-separated string representation of an import.\n\nParameters:\n    import_string (str): A string representing the import, formatted as \"module.submodule\".\n\nReturns:\n    ImportString: An instance of ImportString initialized with parts split from the input string.\n\nRaises:\n    StructureError: If the input string is empty or improperly formatted with nested dots.\n\nThis method leverages the ImportString class's capability to manage and validate Python import paths, ensuring correct structure before instantiation.",
        "signature": "def from_str(cls, import_string: str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ImportString instance based on its components.\n\nThis method returns an integer that uniquely represents the state of the ImportString\nobject, which is determined by the tuple of its import parts. The hash is primarily \nused in hash-based collections, like sets and dictionaries, to ensure that \nImportString instances are correctly organized.\n\nAttributes:\n- `self.parts`: A tuple containing the components of the import string, which\n  is initialized during the creation of the ImportString instance. This tuple \n  is essential for generating a consistent hash value.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate a hash value for the ImportString instance based on its components.\n\nThis method returns an integer that uniquely represents the state of the ImportString\nobject, which is determined by the tuple of its import parts. The hash is primarily \nused in hash-based collections, like sets and dictionaries, to ensure that \nImportString instances are correctly organized.\n\nAttributes:\n- `self.parts`: A tuple containing the components of the import string, which\n  is initialized during the creation of the ImportString instance. This tuple \n  is essential for generating a consistent hash value.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.__init__": {
        "code": "    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        \"\"\"Initialize a ServiceName instance, representing a specific AWS service.\n\nParameters:\n    name (str): The canonical name of the AWS service (e.g., \"s3\").\n    class_name (str): The corresponding class name for the AWS service (e.g., \"S3\").\n    override_boto3_name (str, optional): An optional name to override the default Boto3 name, if necessary.\n\nAttributes:\n    name: Stores the provided service name.\n    class_name: Stores the provided class name associated with the service.\n    boto3_version: Sets the Boto3 version to a constant predefined as LATEST, indicating the most recent version.\n    override_boto3_name: Stores the optional overridden Boto3 name, if provided.\n\nThis constructor allows for the creation of ServiceName objects, encapsulating details about AWS services used in interaction with the Boto3 library.\"\"\"\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name",
        "docstring": "Initialize a ServiceName instance, representing a specific AWS service.\n\nParameters:\n    name (str): The canonical name of the AWS service (e.g., \"s3\").\n    class_name (str): The corresponding class name for the AWS service (e.g., \"S3\").\n    override_boto3_name (str, optional): An optional name to override the default Boto3 name, if necessary.\n\nAttributes:\n    name: Stores the provided service name.\n    class_name: Stores the provided class name associated with the service.\n    boto3_version: Sets the Boto3 version to a constant predefined as LATEST, indicating the most recent version.\n    override_boto3_name: Stores the optional overridden Boto3 name, if provided.\n\nThis constructor allows for the creation of ServiceName objects, encapsulating details about AWS services used in interaction with the Boto3 library.",
        "signature": "def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"Iterate over all type annotations used in the instance and yield each annotation recursively, starting with the instance itself.\n\nThis method returns an iterator that yields the current instance of the FakeAnnotation class, allowing for recursive traversal of type annotations if subclasses implement their own iteration logic. It interacts with the structure of type annotations defined within subclasses of FakeAnnotation that may contain other FakeAnnotation instances.\n\nNo parameters are required, and the output will be an iterator producing instances of FakeAnnotation, including self.\"\"\"\n        '\\n        Iterate over all used type annotations recursively including self.\\n        '\n        yield self",
        "docstring": "Iterate over all type annotations used in the instance and yield each annotation recursively, starting with the instance itself.\n\nThis method returns an iterator that yields the current instance of the FakeAnnotation class, allowing for recursive traversal of type annotations if subclasses implement their own iteration logic. It interacts with the structure of type annotations defined within subclasses of FakeAnnotation that may contain other FakeAnnotation instances.\n\nNo parameters are required, and the output will be an iterator producing instances of FakeAnnotation, including self.",
        "signature": "def iterate_types(self) -> Iterator['FakeAnnotation']:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__init__": {
          "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
          "docstring": "",
          "signature": "def __init__(self, parent: str, *parts: str) -> None:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {},
    "mypy_boto3_builder/structures/collection.py:Collection:__init__": {},
    "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {},
    "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link": {},
    "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link_parent": {
      "mypy_boto3_builder/service_name.py": {
        "ServiceName.boto3_doc_link_parent": {
          "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'",
          "docstring": "Link to boto3 docs parent directory.",
          "signature": "def boto3_doc_link_parent(self) -> str:",
          "type": "Method",
          "class_signature": "class ServiceName:"
        }
      }
    },
    "mypy_boto3_builder/structures/collection.py:Collection:iterate_types": {},
    "mypy_boto3_builder/structures/class_record.py:ClassRecord:iterate_types": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {},
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_collection\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 import_helpers/\n    \u2502   \u2514\u2500\u2500 import_string.py\n    \u2502       \u251c\u2500\u2500 ImportString.__hash__\n    \u2502       \u2514\u2500\u2500 ImportString.from_str\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u2514\u2500\u2500 ServiceName.__init__\n    \u251c\u2500\u2500 structures/\n    \u2502   \u251c\u2500\u2500 class_record.py\n    \u2502   \u2502   \u251c\u2500\u2500 ClassRecord.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 ClassRecord.iterate_types\n    \u2502   \u2514\u2500\u2500 collection.py\n    \u2502       \u251c\u2500\u2500 Collection.__init__\n    \u2502       \u251c\u2500\u2500 Collection.boto3_doc_link\n    \u2502       \u251c\u2500\u2500 Collection.boto3_doc_link_parent\n    \u2502       \u2514\u2500\u2500 Collection.iterate_types\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u251c\u2500\u2500 ExternalImport.__hash__\n        \u2502   \u251c\u2500\u2500 ExternalImport.__init__\n        \u2502   \u2514\u2500\u2500 ExternalImport.from_class\n        \u2514\u2500\u2500 fake_annotation.py\n            \u2514\u2500\u2500 FakeAnnotation.iterate_types\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for testing and validating the behavior of a collection structure within a larger system, specifically in the context of a service-based architecture. It interacts with service metadata (e.g., AWS S3) and the \"Collection\" structure, ensuring correctness and consistency of the collection's attributes, parent relationships, and external type annotations. By supporting precise type annotation handling and external references, the module simplifies integration with type-safe tooling and improves code reliability. It addresses the need for robust validation of service-related abstractions, aiding developers in building maintainable, strongly-typed frameworks.\n\n## FILE 1: mypy_boto3_builder/structures/collection.py\n\n- CLASS METHOD: Collection.boto3_doc_link_parent\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def boto3_doc_link_parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates the link to the parent directory of the Boto3 documentation for the resource collection.\n\nThe method constructs a URL based on the service name and the attribute name of the resource collection. If the `parent_name` is equal to the `SERVICE_RESOURCE` constant, it uses \"service-resource\" in the URL; otherwise, it uses the lowercase version of `parent_name`. \n\nReturns:\n    str: A formatted URL string linking to the parent documentation page for the specified resource collection.\n\nDependencies:\n- `SERVICE_RESOURCE`: A constant defined in the `mypy_boto3_builder.constants` module that represents a specific service resource name.\n- `service_name`: An attribute of type `ServiceName`, which provides the base documentation link through its `boto3_doc_link_parent` property.\n- `attribute_name`: An attribute in the class that holds the specific name of the resource collection being documented.\n\"\"\"\n```\n\n- CLASS METHOD: Collection.iterate_types\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def iterate_types(self) -> Iterator[FakeAnnotation]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over all type annotations associated with the Collection instance.\n\nThis method yields type annotations from the parent class, as well as additional type annotations defined in the `type_annotation` attribute of the Collection instance. The `type_annotation` is expected to implement the `iterate_types` method, which will provide relevant annotations.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator that yields `FakeAnnotation` instances representing the type annotations.\n\nDependencies:\n    - Inherits from `ClassRecord`, which provides its own implementation of `iterate_types`.\n    - The `type_annotation` attribute must be an instance of `FakeAnnotation` or a subclass that implements `iterate_types` to yield its annotations.\n\"\"\"\n```\n\n- CLASS METHOD: Collection.boto3_doc_link\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a link to the Boto3 documentation specific to the resource collection represented by this instance. The link is constructed using the parent documentation URL obtained from the `boto3_doc_link_parent` property and appending the class name, parent name, and attribute name associated with this resource.\n\nReturns:\n    str: A formatted URL linking to the relevant Boto3 documentation section for the resource collection.\n\nDependencies:\n- `self.service_name.class_name`: Represents the class name of the service, used to form the URL.\n- `self.parent_name`: The name of the parent resource, which can impact the URL structure.\n- `self.attribute_name`: The attribute name of the resource collection, used within the link.\n\nThis method relies on the initialization of the `Collection` class, where `service_name`, `parent_name`, and `attribute_name` are set during instantiation.\n\"\"\"\n```\n\n- CLASS METHOD: Collection.__init__\n  - CLASS SIGNATURE: class Collection(ClassRecord):\n  - SIGNATURE: def __init__(self, *, name: str, attribute_name: str, parent_name: str, service_name: ServiceName, type_annotation: FakeAnnotation, object_class_name: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Collection instance for managing a Boto3 ServiceResource or Resource collection.\n\nParameters:\n- name (str): The name of the collection.\n- attribute_name (str): The name of the attribute representing the collection.\n- parent_name (str): The name of the parent resource this collection belongs to.\n- service_name (ServiceName): An enum representing the service name associated with the collection.\n- type_annotation (FakeAnnotation): The type annotation for the object contained within the collection.\n- object_class_name (str): The class name of the objects handled by this collection.\n\nThis constructor calls the superclass initializer (`ClassRecord`) to set up the collection, utilizing `ExternalImport.from_class(ResourceCollection)` to incorporate Boto3's ResourceCollection functionality. The service_name attribute is used for generating documentation links related to the specific AWS service, while attribute_name and parent_name contribute to the proper identification of the resource structure within the service context. The type_annotation attribute enables type checking and hinting for the contents of the collection.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/structures/class_record.py\n\n- CLASS METHOD: ClassRecord.__init__\n  - CLASS SIGNATURE: class ClassRecord:\n  - SIGNATURE: def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a ClassRecord instance that represents a structure capable of being rendered as a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty tuple).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty tuple).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes represented as FakeAnnotation instances (default is an empty tuple).\n- use_alias (bool, optional): A flag indicating whether to use an alias for safe import, defaulting to False.\n\nAttributes:\n- self.name: Stores the class name.\n- self.methods: A list of methods belonging to the class.\n- self.attributes: A list of attributes belonging to the class.\n- self.bases: A list of base classes, allowing for inheritance representation.\n- self.use_alias: Determines if an alias for the class will be used.\n- self.docstring: Initializes an empty string to potentially hold the class's documentation.\n\nThis constructor facilitates the organization of various class elements and supports methods for type iteration and internal import extraction in the ClassRecord class.\n\"\"\"\n```\n\n- CLASS METHOD: ClassRecord.iterate_types\n  - CLASS SIGNATURE: class ClassRecord:\n  - SIGNATURE: def iterate_types(self) -> Iterator[FakeAnnotation]:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over type annotations for methods, attributes, and base classes contained within the ClassRecord.\n\nThis method yields `FakeAnnotation` instances, allowing iteration over the type annotations associated with each method, attribute, and base class defined in the ClassRecord. It interacts with the `methods`, `attributes`, and `bases` attributes, each of which must contain elements that support the `iterate_types` method. The output can be utilized for further processing, such as extracting import records or analyzing type dependencies.\n\nReturns:\n    Iterator[FakeAnnotation]: An iterator yielding type annotations found in methods, attributes, and bases.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__init__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries, such as `boto3.service.Service`.\n\nParameters:\n- source (ImportString): The module import string representing the source of the annotation.\n- name (str, optional): The name of the import, defaults to an empty string.\n- alias (str, optional): A local alias for the import, defaults to an empty string.\n- safe (bool, optional): A flag indicating if the import should be wrapped in a try-except block, defaults to False.\n\nAttributes:\n- self.source: Stores the ImportString representing the source module.\n- self.name: The import name.\n- self.alias: The local alias for the import.\n- self.safe: Indicates whether the import is wrapped safely.\n\nThis constructor interacts with the ImportString class and will be used in conjunction with methods like `from_class`, `render`, and `import_record` within the ExternalImport class to handle type annotations effectively.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value of the ExternalImport instance based on its attributes.\n\nThis method uses the `hash()` function to generate a unique hash value derived from the instance's `source`, `name`, `alias`, and `safe` attributes. These attributes determine how the instance will be treated in hash-based collections such as sets or dictionaries. The `source` is of type `ImportString`, which represents the module import string, while `name` and `alias` are strings representing the import's name and local alias, respectively. The `safe` attribute is a boolean indicating if the import is wrapped in try-except. This method is essential for maintaining the integrity of instances when used in hashed collections.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.from_class\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an instance of `ExternalImport` using an imported class.\n\nThis method attempts to derive the import string and the class name from an existing class object. It retrieves the module in which the class is defined and constructs an `ExternalImport` instance with the module's name and the class's name. \n\nParameters:\n- `cls`: The class type of `ExternalImport` being called.\n- `obj`: The class for which the `ExternalImport` instance is to be created.\n- `alias` (optional): A local name to refer to the imported class.\n- `safe` (optional): A boolean indicating whether the import should be wrapped in a try-except block.\n\nReturns:\n- An instance of `ExternalImport` initialized with the derived module name, class name, optional alias, and safety flag.\n\nRaises:\n- `TypeAnnotationError`: If the module of the provided class object (`obj`) cannot be determined, indicating that the class is not associated with any module.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ImportString instance based on its components.\n\nThis method returns an integer that uniquely represents the state of the ImportString\nobject, which is determined by the tuple of its import parts. The hash is primarily \nused in hash-based collections, like sets and dictionaries, to ensure that \nImportString instances are correctly organized.\n\nAttributes:\n- `self.parts`: A tuple containing the components of the import string, which\n  is initialized during the creation of the ImportString instance. This tuple \n  is essential for generating a consistent hash value.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.from_str\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def from_str(cls, import_string: str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an ImportString instance from a dot-separated string representation of an import.\n\nParameters:\n    import_string (str): A string representing the import, formatted as \"module.submodule\".\n\nReturns:\n    ImportString: An instance of ImportString initialized with parts split from the input string.\n\nRaises:\n    StructureError: If the input string is empty or improperly formatted with nested dots.\n\nThis method leverages the ImportString class's capability to manage and validate Python import paths, ensuring correct structure before instantiation.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.__init__\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ServiceName instance, representing a specific AWS service.\n\nParameters:\n    name (str): The canonical name of the AWS service (e.g., \"s3\").\n    class_name (str): The corresponding class name for the AWS service (e.g., \"S3\").\n    override_boto3_name (str, optional): An optional name to override the default Boto3 name, if necessary.\n\nAttributes:\n    name: Stores the provided service name.\n    class_name: Stores the provided class name associated with the service.\n    boto3_version: Sets the Boto3 version to a constant predefined as LATEST, indicating the most recent version.\n    override_boto3_name: Stores the optional overridden Boto3 name, if provided.\n\nThis constructor allows for the creation of ServiceName objects, encapsulating details about AWS services used in interaction with the Boto3 library.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.iterate_types\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def iterate_types(self) -> Iterator['FakeAnnotation']:\n  - DOCSTRING: \n```python\n\"\"\"\nIterate over all type annotations used in the instance and yield each annotation recursively, starting with the instance itself.\n\nThis method returns an iterator that yields the current instance of the FakeAnnotation class, allowing for recursive traversal of type annotations if subclasses implement their own iteration logic. It interacts with the structure of type annotations defined within subclasses of FakeAnnotation that may contain other FakeAnnotation instances.\n\nNo parameters are required, and the output will be an iterator producing instances of FakeAnnotation, including self.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/structures/collection.py": "\"\"\"\nBoto3 ServiceResource or Resource collection.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterator\nfrom boto3.resources.collection import ResourceCollection\nfrom mypy_boto3_builder.constants import SERVICE_RESOURCE\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass Collection(ClassRecord):\n    \"\"\"\n    Boto3 ServiceResource or Resource collection.\n    \"\"\"",
    "mypy_boto3_builder/structures/class_record.py": "\"\"\"\nBase class for all structures that can be rendered to a class.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.utils.strings import xform_name\n\nclass ClassRecord:\n    \"\"\"\n    Base class for all structures that can be rendered to a class.\n    \"\"\"\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return ''\n\n    @property\n    def alias_name(self) -> str:\n        \"\"\"\n        Class alias name for safe import.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        if not self.use_alias:\n            raise StructureError(f'Cannot get alias for {self.name} with no alias.')\n        return InternalImport.get_alias(self.name)\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract import records from required type annotations.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n        return result\n\n    def get_internal_imports(self) -> set[InternalImport]:\n        \"\"\"\n        Get internal imports from methods.\n        \"\"\"\n        result: set[InternalImport] = set()\n        for method in self.methods:\n            for type_annotation in method.iterate_types():\n                if not isinstance(type_annotation, InternalImport):\n                    continue\n                result.add(type_annotation)\n        return result\n\n    @property\n    def variable_name(self) -> str:\n        \"\"\"\n        Variable name for an instance of this class.\n        \"\"\"\n        return xform_name(self.name)\n\n    @property\n    def method_names(self) -> list[str]:\n        \"\"\"\n        Unique method names.\n        \"\"\"\n        return sorted({i.name for i in self.methods})\n\n    def get_method(self, name: str) -> Method:\n        \"\"\"\n        Get method by name.\n        \"\"\"\n        for method in self.methods:\n            if method.name == name:\n                return method\n        raise StructureError(f'Method {name} not found')",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return '.'.join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()"
  },
  "call_tree": {
    "tests/structures/test_collection.py:TestPaginator:test_init": {
      "tests/structures/test_collection.py:TestPaginator:collection": {
        "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
            },
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
          },
          "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
        }
      },
      "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link": {
        "mypy_boto3_builder/structures/collection.py:Collection:boto3_doc_link_parent": {
          "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
            "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
          }
        }
      }
    },
    "tests/structures/test_collection.py:TestPaginator:test_get_types": {
      "tests/structures/test_collection.py:TestPaginator:collection": {
        "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/collection.py:Collection:__init__": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
              "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
            },
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
          },
          "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
        }
      },
      "mypy_boto3_builder/structures/collection.py:Collection:iterate_types": {
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:iterate_types": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
        },
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      }
    }
  }
}