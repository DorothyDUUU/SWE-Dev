{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_iosxr",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_iosxr.py",
  "test_code": "import unittest\nfrom ncclient.devices.iosxr import *\n\n\nclass TestIosxrDevice(unittest.TestCase):\n    \n    def setUp(self):\n        self.obj = IosxrDeviceHandler({'name': 'iosxe'})\n\n    def test_add_additional_ssh_connect_params(self):\n        expected = dict()\n        expected[\"unknown_host_cb\"] = iosxr_unknown_host_cb\n        actual = dict()\n        self.obj.add_additional_ssh_connect_params(actual)\n        self.assertDictEqual(expected, actual)\n\n    def test_perform_qualify_check(self):\n        self.assertFalse(self.obj.perform_qualify_check())\n\n    def test_csr_unknown_host_cb(self):\n        self.assertTrue(iosxr_unknown_host_cb('host', 'fingerprint'))\n",
  "GT_file_code": {
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/devices/iosxr.py": "\"\"\"\nHandler for Cisco IOS-XR device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\n\n\nfrom .default import DefaultDeviceHandler\n\ndef iosxr_unknown_host_cb(host, fingerprint):\n        #This will ignore the unknown host check when connecting to IOS-XR devices\n        return True\n\nclass IosxrDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Cisco IOS-XR handler for device specific information.\n\n    \"\"\"\n    def __init__(self, device_params):\n        super(IosxrDeviceHandler, self).__init__(device_params)\n\n    def add_additional_ssh_connect_params(self, kwargs):\n        kwargs['unknown_host_cb'] = iosxr_unknown_host_cb\n\n    def perform_qualify_check(self):\n        return False\n"
  },
  "GT_src_dict": {
    "ncclient/transport/errors.py": {},
    "ncclient/devices/iosxr.py": {
      "iosxr_unknown_host_cb": {
        "code": "def iosxr_unknown_host_cb(host, fingerprint):\n    \"\"\"Callback function to handle unknown host verification when connecting to Cisco IOS-XR devices.\n\nParameters:\n- host (str): The hostname or IP address of the device being connected to.\n- fingerprint (str): The fingerprint of the device's SSH host key.\n\nReturns:\n- bool: Always returns True, thereby ignoring the unknown host check.\n\nThis function is utilized within the `IosxrDeviceHandler` class to allow connections to IOS-XR devices without verifying their host key against known fingerprints, facilitating easier connectivity in environments where device fingerprints may not be pre-approved. It is particularly relevant in scenarios where devices are dynamically deployed or managed.\"\"\"\n    return True",
        "docstring": "Callback function to handle unknown host verification when connecting to Cisco IOS-XR devices.\n\nParameters:\n- host (str): The hostname or IP address of the device being connected to.\n- fingerprint (str): The fingerprint of the device's SSH host key.\n\nReturns:\n- bool: Always returns True, thereby ignoring the unknown host check.\n\nThis function is utilized within the `IosxrDeviceHandler` class to allow connections to IOS-XR devices without verifying their host key against known fingerprints, facilitating easier connectivity in environments where device fingerprints may not be pre-approved. It is particularly relevant in scenarios where devices are dynamically deployed or managed.",
        "signature": "def iosxr_unknown_host_cb(host, fingerprint):",
        "type": "Function",
        "class_signature": null
      },
      "IosxrDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initializes an instance of the IosxrDeviceHandler class, which is a Cisco IOS-XR specific handler \nfor managing device interactions.\n\nParameters:\n- device_params: A dictionary containing parameters necessary for device connection and interaction. \n  This is passed to the superclass (DefaultDeviceHandler) for initialization, ensuring that the \n  required configuration is set up properly.\n\nThis constructor does not return a value but sets up the necessary state for the IosxrDeviceHandler \ninstance, enabling it to handle device-specific operations effectively.\n\nDependencies:\n- Inherits from DefaultDeviceHandler, which provides the generic functionalities and configurations \n  for the Netconf server interactions, allowing the IosxrDeviceHandler to focus on IOS-XR specific \n  implementations while reusing existing functionality from the base class.\"\"\"\n        super(IosxrDeviceHandler, self).__init__(device_params)",
        "docstring": "Initializes an instance of the IosxrDeviceHandler class, which is a Cisco IOS-XR specific handler \nfor managing device interactions.\n\nParameters:\n- device_params: A dictionary containing parameters necessary for device connection and interaction. \n  This is passed to the superclass (DefaultDeviceHandler) for initialization, ensuring that the \n  required configuration is set up properly.\n\nThis constructor does not return a value but sets up the necessary state for the IosxrDeviceHandler \ninstance, enabling it to handle device-specific operations effectively.\n\nDependencies:\n- Inherits from DefaultDeviceHandler, which provides the generic functionalities and configurations \n  for the Netconf server interactions, allowing the IosxrDeviceHandler to focus on IOS-XR specific \n  implementations while reusing existing functionality from the base class.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class IosxrDeviceHandler(DefaultDeviceHandler):"
      },
      "IosxrDeviceHandler.add_additional_ssh_connect_params": {
        "code": "    def add_additional_ssh_connect_params(self, kwargs):\n        \"\"\"Adds additional SSH connection parameters specific to Cisco IOS-XR devices.\n\nThis method updates the provided dictionary of SSH connection parameters by adding a callback function for handling unknown hosts. It sets the 'unknown_host_cb' key to the iosxr_unknown_host_cb function, which is defined outside this class to ignore unknown host checks.\n\nParameters:\n    kwargs (dict): A dictionary of SSH connection parameters to be modified.\n\nReturns:\n    None: This method modifies the input dictionary in place and does not return a value.\n\nDependencies:\n    - iosxr_unknown_host_cb: A callback function that is used to bypass the unknown host verification when connecting to IOS-XR devices.\"\"\"\n        kwargs['unknown_host_cb'] = iosxr_unknown_host_cb",
        "docstring": "Adds additional SSH connection parameters specific to Cisco IOS-XR devices.\n\nThis method updates the provided dictionary of SSH connection parameters by adding a callback function for handling unknown hosts. It sets the 'unknown_host_cb' key to the iosxr_unknown_host_cb function, which is defined outside this class to ignore unknown host checks.\n\nParameters:\n    kwargs (dict): A dictionary of SSH connection parameters to be modified.\n\nReturns:\n    None: This method modifies the input dictionary in place and does not return a value.\n\nDependencies:\n    - iosxr_unknown_host_cb: A callback function that is used to bypass the unknown host verification when connecting to IOS-XR devices.",
        "signature": "def add_additional_ssh_connect_params(self, kwargs):",
        "type": "Method",
        "class_signature": "class IosxrDeviceHandler(DefaultDeviceHandler):"
      },
      "IosxrDeviceHandler.perform_qualify_check": {
        "code": "    def perform_qualify_check(self):\n        \"\"\"Checks whether the IOS-XR device qualifies for the intended operation.\n\nThis method overrides the corresponding method in the DefaultDeviceHandler class \nand always returns False, indicating that the device does not qualify \nfor further interaction or checks. It does not accept any parameters \nand has no side effects. This behavior is specific to the IOS-XR \ndevice handler implementation. \n\nReturns:\n    bool: Always returns False.\"\"\"\n        return False",
        "docstring": "Checks whether the IOS-XR device qualifies for the intended operation.\n\nThis method overrides the corresponding method in the DefaultDeviceHandler class \nand always returns False, indicating that the device does not qualify \nfor further interaction or checks. It does not accept any parameters \nand has no side effects. This behavior is specific to the IOS-XR \ndevice handler implementation. \n\nReturns:\n    bool: Always returns False.",
        "signature": "def perform_qualify_check(self):",
        "type": "Method",
        "class_signature": "class IosxrDeviceHandler(DefaultDeviceHandler):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/iosxr.py:IosxrDeviceHandler:__init__": {
      "ncclient/devices/default.py": {
        "DefaultDeviceHandler.__init__": {
          "code": "    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
          "docstring": "",
          "signature": "def __init__(self, device_params=None):",
          "type": "Method",
          "class_signature": "class DefaultDeviceHandler(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: ncclient-test_iosxr\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u2514\u2500\u2500 iosxr.py\n    \u2502       \u251c\u2500\u2500 IosxrDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 IosxrDeviceHandler.add_additional_ssh_connect_params\n    \u2502       \u251c\u2500\u2500 IosxrDeviceHandler.perform_qualify_check\n    \u2502       \u2514\u2500\u2500 iosxr_unknown_host_cb\n    \u2514\u2500\u2500 transport/\n        \u2514\u2500\u2500 errors.py\n            \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to ensure robust interaction with IOS-XR network devices, providing functionality to validate and manage device-specific behaviors during SSH connections and session handling. It facilitates the addition of device-specific SSH parameters, such as handling unknown host callbacks, to ensure secure and seamless communication with IOS-XR devices. Additionally, it supports verification mechanisms to confirm qualification criteria for device compatibility. By abstracting and automating these connection and validation processes, the module simplifies the management of IOS-XR devices, reducing manual intervention for developers and increasing reliability in network automation workflows.\n\n## FILE 1: ncclient/transport/errors.py\n\n## FILE 2: ncclient/devices/iosxr.py\n\n- CLASS METHOD: IosxrDeviceHandler.__init__\n  - CLASS SIGNATURE: class IosxrDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the IosxrDeviceHandler class, which is a Cisco IOS-XR specific handler \nfor managing device interactions.\n\nParameters:\n- device_params: A dictionary containing parameters necessary for device connection and interaction. \n  This is passed to the superclass (DefaultDeviceHandler) for initialization, ensuring that the \n  required configuration is set up properly.\n\nThis constructor does not return a value but sets up the necessary state for the IosxrDeviceHandler \ninstance, enabling it to handle device-specific operations effectively.\n\nDependencies:\n- Inherits from DefaultDeviceHandler, which provides the generic functionalities and configurations \n  for the Netconf server interactions, allowing the IosxrDeviceHandler to focus on IOS-XR specific \n  implementations while reusing existing functionality from the base class.\n\"\"\"\n```\n\n- CLASS METHOD: IosxrDeviceHandler.add_additional_ssh_connect_params\n  - CLASS SIGNATURE: class IosxrDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def add_additional_ssh_connect_params(self, kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nAdds additional SSH connection parameters specific to Cisco IOS-XR devices.\n\nThis method updates the provided dictionary of SSH connection parameters by adding a callback function for handling unknown hosts. It sets the 'unknown_host_cb' key to the iosxr_unknown_host_cb function, which is defined outside this class to ignore unknown host checks.\n\nParameters:\n    kwargs (dict): A dictionary of SSH connection parameters to be modified.\n\nReturns:\n    None: This method modifies the input dictionary in place and does not return a value.\n\nDependencies:\n    - iosxr_unknown_host_cb: A callback function that is used to bypass the unknown host verification when connecting to IOS-XR devices.\n\"\"\"\n```\n\n- CLASS METHOD: IosxrDeviceHandler.perform_qualify_check\n  - CLASS SIGNATURE: class IosxrDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def perform_qualify_check(self):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks whether the IOS-XR device qualifies for the intended operation.\n\nThis method overrides the corresponding method in the DefaultDeviceHandler class \nand always returns False, indicating that the device does not qualify \nfor further interaction or checks. It does not accept any parameters \nand has no side effects. This behavior is specific to the IOS-XR \ndevice handler implementation. \n\nReturns:\n    bool: Always returns False.\n\"\"\"\n```\n\n- FUNCTION NAME: iosxr_unknown_host_cb\n  - SIGNATURE: def iosxr_unknown_host_cb(host, fingerprint):\n  - DOCSTRING: \n```python\n\"\"\"\nCallback function to handle unknown host verification when connecting to Cisco IOS-XR devices.\n\nParameters:\n- host (str): The hostname or IP address of the device being connected to.\n- fingerprint (str): The fingerprint of the device's SSH host key.\n\nReturns:\n- bool: Always returns True, thereby ignoring the unknown host check.\n\nThis function is utilized within the `IosxrDeviceHandler` class to allow connections to IOS-XR devices without verifying their host key against known fingerprints, facilitating easier connectivity in environments where device fingerprints may not be pre-approved. It is particularly relevant in scenarios where devices are dynamically deployed or managed.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/devices/iosxr.py": "\"\"\"\nHandler for Cisco IOS-XR device specific information.\n\nNote that for proper import, the classname has to be:\n\n    \"<Devicename>DeviceHandler\"\n\n...where <Devicename> is something like \"Default\", \"Nexus\", etc.\n\nAll device-specific handlers derive from the DefaultDeviceHandler, which implements the\ngeneric information needed for interaction with a Netconf server.\n\n\"\"\"\nfrom .default import DefaultDeviceHandler\n\nclass IosxrDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Cisco IOS-XR handler for device specific information.\n\n    \"\"\""
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_iosxr.py:TestIosxrDevice:setUp": {
      "ncclient/devices/iosxr.py:IosxrDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_iosxr.py:TestIosxrDevice:test_add_additional_ssh_connect_params": {
      "ncclient/devices/iosxr.py:IosxrDeviceHandler:add_additional_ssh_connect_params": {}
    },
    "modified_testcases/unit/devices/test_iosxr.py:TestIosxrDevice:test_csr_unknown_host_cb": {
      "ncclient/devices/iosxr.py:iosxr_unknown_host_cb": {}
    },
    "modified_testcases/unit/devices/test_iosxr.py:TestIosxrDevice:test_perform_qualify_check": {
      "ncclient/devices/iosxr.py:IosxrDeviceHandler:perform_qualify_check": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}