{
  "dir_path": "/app/advertools",
  "package_name": "advertools",
  "sample_name": "advertools-test_reverse_dns_lookup",
  "src_dir": "advertools/",
  "test_dir": "tests/",
  "test_file": "tests/test_reverse_dns_lookup.py",
  "test_code": "from advertools import reverse_dns_lookup\nfrom advertools.reverse_dns_lookup import _single_request\n\nip_list = [\n    \"62.235.238.71\",\n    \"62.235.238.71\",\n    \"62.235.238.71\",\n    \"62.235.238.71\",\n    \"62.235.238.71\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"81.241.228.69\",\n    \"95.163.255.29\",\n    \"105.140.165.213\",\n    \"2.239.215.165\",\n    \"2.239.215.165\",\n    \"2.239.215.165\",\n    \"66.249.65.161\",\n    \"66.249.65.161\",\n    \"82.173.111.205\",\n    \"139.59.215.212\",\n    \"84.227.57.137\",\n    \"84.227.57.137\",\n    \"86.74.165.98\",\n    \"194.230.155.248\",\n    \"84.227.57.137\",\n    \"84.227.57.137\",\n    \"84.194.174.248\",\n    \"81.164.191.132\",\n    \"194.230.155.248\",\n    \"94.225.83.80\",\n    \"213.118.187.163\",\n    \"213.118.187.163\",\n    \"86.74.165.98\",\n    \"94.225.83.80\",\n    \"213.118.187.163\",\n    \"195.16.13.29\",\n    \"195.16.13.29\",\n    \"94.225.160.96\",\n    \"213.211.144.181\",\n    \"213.211.144.181\",\n    \"213.211.144.181\",\n    \"194.230.155.248\",\n    \"86.74.165.98\",\n    \"178.197.224.207\",\n    \"195.16.13.29\",\n    \"195.16.13.29\",\n    \"83.78.170.225\",\n]\n\nresult = reverse_dns_lookup(ip_list, max_workers=5)\n\n\ndef test_reverse_dns_correct_columns():\n    column_list = [\n        \"ip_address\",\n        \"count\",\n        \"cum_count\",\n        \"perc\",\n        \"cum_perc\",\n        \"hostname\",\n        \"aliaslist\",\n        \"ipaddrlist\",\n        \"errors\",\n    ]\n    assert all(result.columns == column_list)\n\n\ndef test_reverse_dns_monotonic():\n    assert result[\"count\"].is_monotonic_decreasing\n    assert result[\"cum_count\"].is_monotonic_increasing\n    assert result[\"perc\"].is_monotonic_decreasing\n    assert result[\"cum_perc\"].is_monotonic_increasing\n\n\ndef test_reverse_dns_single_returns_ip_in_result():\n    ip = \"62.235.238.71\"\n    result = _single_request(ip)\n    assert ip == result[0]\n\n\ndef test_reverse_dns_single_returns_error():\n    ip = \"555.555.555.555\"\n    result = _single_request(ip)\n    assert \"Errno\" in result[-1]\n",
  "GT_file_code": {
    "advertools/reverse_dns_lookup.py": "\"\"\"\n.. _reverse_dns_lookup:\n\n.. raw:: html\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js\"></script>\n\nGetting the host name of a list of IP addresses can be useful in verifying\nthe authenticity of those IP addresses. You typically want to do this as part\nof a :ref:`log file analysis <logs>` pipeline. In this case you have requests\nmade to your server claiming to be of a certain user agent/bot name. Performing\na :func:`reverse_dns_lookup` on those IP addresses, will get you the actual\nhost name that they belong to.\n\nWhat the :func:`reverse_dns_lookup` function does, is simply like running the\n`host` command from the command line, but on a massive scale:\n\n.. code-block:: bash\n\n    $ host 66.249.80.0\n    0.80.249.66.in-addr.arpa domain name pointer google-proxy-66-249-80-0.google.com.\n\n\nBecause you usually have a large number of duplicated IP addresses that you\nwant to check, this function makes the process practical and efficient, in\ncomparison to running the command thousands of times from the comand line.\n\nRunning the function is very simple, you simply supply a list of the IP\naddresses that you have. Make sure to **keep the duplicates**, because the\nfunction handles that for you, as well as provide counts and some statistics on\nthe frequency of the IPs:\n\n.. container:: thebe\n\n    .. thebe-button::\n        Run this code\n\n    .. code-block::\n        :class: thebe, thebe-init\n\n        import advertools as adv\n        ip_list = ['66.249.66.194', '66.249.66.194', '66.249.66.194',\n                '66.249.66.91', '66.249.66.91', '130.185.74.243',\n                '31.56.96.51', '5.211.97.39']\n\n        host_df = adv.reverse_dns_lookup(ip_list)\n        host_df\n\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n  ..  ip_address        count    cum_count    perc    cum_perc  hostname                           aliaslist                    ipaddrlist      errors\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n   0  66.249.66.194         3            3   0.375       0.375  crawl-66-249-66-194.googlebot.com  194.66.249.66.in-addr.arpa   66.249.66.194\n   1  66.249.66.91          2            5   0.25        0.625  crawl-66-249-66-91.googlebot.com   91.66.249.66.in-addr.arpa    66.249.66.91\n   2  130.185.74.243        1            6   0.125       0.75   mail.garda.ir                      243.74.185.130.in-addr.arpa  130.185.74.243\n   3  31.56.96.51           1            7   0.125       0.875  31-56-96-51.shatel.ir              51.96.56.31.in-addr.arpa     31.56.96.51\n   4  5.211.97.39           1            8   0.125       1                                                                                      [Errno 1] Unknown host\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n\nAs you can see, in addition to getting hostnames, aliaslist, and ipaddrlist for\nthe IPs you supplied, you also get counts (absolute and cumulative) as well as\npercentages (absolute and cumulative). This can give you a good overview of\nthe relative importance of each IP, and can help focus attention on them as\nneeded.\n\"\"\"  # noqa: E501\n\nimport platform\nimport socket\nfrom concurrent import futures\n\nimport pandas as pd\n\nsystem = platform.system()\n\n_default_max_workders = 60 if system == \"Darwin\" else 600\n\n\ndef _single_request(ip):\n    try:\n        hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)\n        return [ip, hostname, \"@@\".join(aliaslist), \"@@\".join(ipaddrlist)]\n    except Exception as e:\n        return [ip, None, None, None, str(e)]\n\n\ndef reverse_dns_lookup(ip_list, max_workers=_default_max_workders):\n    \"\"\"Return the hostname, aliaslist, and ipaddrlist for a list of IP\n    addresses.\n\n    This is mainly useful for a long list of typically duplicated IP adresses\n    and helps in getting the information very fast. It is basically the\n    equivalent of running the `host` command on the command line many times:\n\n    .. code-block:: bash\n\n        $ host advertools.readthedocs.io\n        advertools.readthedocs.io has address 104.17.32.82\n\n    Parameters\n    ----------\n    ip_list : list\n      A list of IP addresses.\n    max_workers : int\n      The maximum number of workers to use for multi processing.\n\n\n    You also get a simple report about the counts of the IPs to get an overview\n    of the top ones.\n\n    Examples\n    --------\n    >>> import advertools as adv\n    >>> ip_list = [\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.91\",\n    ...     \"66.249.66.91\",\n    ...     \"130.185.74.243\",\n    ...     \"31.56.96.51\",\n    ...     \"5.211.97.39\",\n    ... ]\n    >>> adv.reverse_dns_lookup([ip_list])\n\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n      ..  ip_address        count    cum_count    perc    cum_perc  hostname                           aliaslist                    ipaddrlist      errors\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n       0  66.249.66.194         3            3   0.375       0.375  crawl-66-249-66-194.googlebot.com  194.66.249.66.in-addr.arpa   66.249.66.194\n       1  66.249.66.91          2            5   0.25        0.625  crawl-66-249-66-91.googlebot.com   91.66.249.66.in-addr.arpa    66.249.66.91\n       2  130.185.74.243        1            6   0.125       0.75   mail.garda.ir                      243.74.185.130.in-addr.arpa  130.185.74.243\n       3  31.56.96.51           1            7   0.125       0.875  31-56-96-51.shatel.ir              51.96.56.31.in-addr.arpa     31.56.96.51\n       4  5.211.97.39           1            8   0.125       1                                                                                      [Errno 1] Unknown host\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n    \"\"\"  # noqa: E501\n    socket.setdefaulttimeout(8)\n    count_df = pd.Series(ip_list).value_counts().reset_index()\n    count_df.columns = [\"ip_address\", \"count\"]\n    count_df[\"cum_count\"] = count_df[\"count\"].cumsum()\n    count_df[\"perc\"] = count_df[\"count\"].div(count_df[\"count\"].sum())\n    count_df[\"cum_perc\"] = count_df[\"perc\"].cumsum()\n\n    hosts = []\n    if system == \"Darwin\":\n        with futures.ProcessPoolExecutor(max_workers=max_workers) as executor:\n            for _ip, host in zip(\n                ip_list, executor.map(_single_request, count_df[\"ip_address\"])\n            ):\n                hosts.append(host)\n    else:\n        with futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for host in executor.map(_single_request, count_df[\"ip_address\"]):\n                hosts.append(host)\n    df = pd.DataFrame(hosts)\n    columns = [\"ip\", \"hostname\", \"aliaslist\", \"ipaddrlist\", \"errors\"]\n    if df.shape[1] == 4:\n        columns = columns[:-1]\n    df.columns = columns\n    final_df = pd.merge(\n        count_df, df, left_on=\"ip_address\", right_on=\"ip\", how=\"left\"\n    ).drop(\"ip\", axis=1)\n    return final_df\n"
  },
  "GT_src_dict": {
    "advertools/reverse_dns_lookup.py": {
      "_single_request": {
        "code": "def _single_request(ip):\n    \"\"\"Retrieve the hostname, alias list, and additional IP address list for a given IP address.\n\nParameters\n----------\nip : str\n    A single valid IP address for which to perform reverse DNS lookup.\n\nReturns\n-------\nlist\n    A list containing the provided IP address, its resolved hostname, a string of alias names joined by \"@@\", a string of additional IP addresses joined by \"@@\", or error information if the lookup fails.\n\nRaises\n------\nsocket.error\n    If the provided IP address is invalid or there is an issue with the DNS resolution, an exception will be caught, and an error message will be included in the returned list.\n\nNotes\n-----\nThis function is a helper for the `reverse_dns_lookup` function, allowing batch processing of IP addresses by delegating each lookup to the `_single_request` function in concurrent execution environments. It uses Python's `socket` library for DNS resolution, specifically the `gethostbyaddr` method.\"\"\"\n    try:\n        hostname, aliaslist, ipaddrlist = socket.gethostbyaddr(ip)\n        return [ip, hostname, '@@'.join(aliaslist), '@@'.join(ipaddrlist)]\n    except Exception as e:\n        return [ip, None, None, None, str(e)]",
        "docstring": "Retrieve the hostname, alias list, and additional IP address list for a given IP address.\n\nParameters\n----------\nip : str\n    A single valid IP address for which to perform reverse DNS lookup.\n\nReturns\n-------\nlist\n    A list containing the provided IP address, its resolved hostname, a string of alias names joined by \"@@\", a string of additional IP addresses joined by \"@@\", or error information if the lookup fails.\n\nRaises\n------\nsocket.error\n    If the provided IP address is invalid or there is an issue with the DNS resolution, an exception will be caught, and an error message will be included in the returned list.\n\nNotes\n-----\nThis function is a helper for the `reverse_dns_lookup` function, allowing batch processing of IP addresses by delegating each lookup to the `_single_request` function in concurrent execution environments. It uses Python's `socket` library for DNS resolution, specifically the `gethostbyaddr` method.",
        "signature": "def _single_request(ip):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: advertools-test_reverse_dns_lookup\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 advertools/\n    \u2514\u2500\u2500 reverse_dns_lookup.py\n        \u2514\u2500\u2500 _single_request\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for performing reverse DNS lookups on a given list of IP addresses, enabling the retrieval of associated hostnames and related metadata. It supports efficient batch processing with configurable concurrency through the use of multiple worker threads, ensuring scalable performance for large datasets. The module outputs detailed results, including the frequency and cumulative distribution of IPs, corresponding domain information, and error tracking for invalid or unreachable IPs. This solution streamlines the process of IP-to-hostname resolution, allowing developers and analysts to quickly derive meaningful insights from raw IP address data in a structured format.\n\n## FILE 1: advertools/reverse_dns_lookup.py\n\n- FUNCTION NAME: _single_request\n  - SIGNATURE: def _single_request(ip):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the hostname, alias list, and additional IP address list for a given IP address.\n\nParameters\n----------\nip : str\n    A single valid IP address for which to perform reverse DNS lookup.\n\nReturns\n-------\nlist\n    A list containing the provided IP address, its resolved hostname, a string of alias names joined by \"@@\", a string of additional IP addresses joined by \"@@\", or error information if the lookup fails.\n\nRaises\n------\nsocket.error\n    If the provided IP address is invalid or there is an issue with the DNS resolution, an exception will be caught, and an error message will be included in the returned list.\n\nNotes\n-----\nThis function is a helper for the `reverse_dns_lookup` function, allowing batch processing of IP addresses by delegating each lookup to the `_single_request` function in concurrent execution environments. It uses Python's `socket` library for DNS resolution, specifically the `gethostbyaddr` method.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "advertools/reverse_dns_lookup.py": "\"\"\"\n.. _reverse_dns_lookup:\n\n.. raw:: html\n\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js\"></script>\n\nGetting the host name of a list of IP addresses can be useful in verifying\nthe authenticity of those IP addresses. You typically want to do this as part\nof a :ref:`log file analysis <logs>` pipeline. In this case you have requests\nmade to your server claiming to be of a certain user agent/bot name. Performing\na :func:`reverse_dns_lookup` on those IP addresses, will get you the actual\nhost name that they belong to.\n\nWhat the :func:`reverse_dns_lookup` function does, is simply like running the\n`host` command from the command line, but on a massive scale:\n\n.. code-block:: bash\n\n    $ host 66.249.80.0\n    0.80.249.66.in-addr.arpa domain name pointer google-proxy-66-249-80-0.google.com.\n\n\nBecause you usually have a large number of duplicated IP addresses that you\nwant to check, this function makes the process practical and efficient, in\ncomparison to running the command thousands of times from the comand line.\n\nRunning the function is very simple, you simply supply a list of the IP\naddresses that you have. Make sure to **keep the duplicates**, because the\nfunction handles that for you, as well as provide counts and some statistics on\nthe frequency of the IPs:\n\n.. container:: thebe\n\n    .. thebe-button::\n        Run this code\n\n    .. code-block::\n        :class: thebe, thebe-init\n\n        import advertools as adv\n        ip_list = ['66.249.66.194', '66.249.66.194', '66.249.66.194',\n                '66.249.66.91', '66.249.66.91', '130.185.74.243',\n                '31.56.96.51', '5.211.97.39']\n\n        host_df = adv.reverse_dns_lookup(ip_list)\n        host_df\n\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n  ..  ip_address        count    cum_count    perc    cum_perc  hostname                           aliaslist                    ipaddrlist      errors\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n   0  66.249.66.194         3            3   0.375       0.375  crawl-66-249-66-194.googlebot.com  194.66.249.66.in-addr.arpa   66.249.66.194\n   1  66.249.66.91          2            5   0.25        0.625  crawl-66-249-66-91.googlebot.com   91.66.249.66.in-addr.arpa    66.249.66.91\n   2  130.185.74.243        1            6   0.125       0.75   mail.garda.ir                      243.74.185.130.in-addr.arpa  130.185.74.243\n   3  31.56.96.51           1            7   0.125       0.875  31-56-96-51.shatel.ir              51.96.56.31.in-addr.arpa     31.56.96.51\n   4  5.211.97.39           1            8   0.125       1                                                                                      [Errno 1] Unknown host\n====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n\nAs you can see, in addition to getting hostnames, aliaslist, and ipaddrlist for\nthe IPs you supplied, you also get counts (absolute and cumulative) as well as\npercentages (absolute and cumulative). This can give you a good overview of\nthe relative importance of each IP, and can help focus attention on them as\nneeded.\n\"\"\"\nimport platform\nimport socket\nfrom concurrent import futures\nimport pandas as pd\nsystem = platform.system()\n_default_max_workders = 60 if system == 'Darwin' else 600\n\ndef reverse_dns_lookup(ip_list, max_workers=_default_max_workders):\n    \"\"\"Return the hostname, aliaslist, and ipaddrlist for a list of IP\n    addresses.\n\n    This is mainly useful for a long list of typically duplicated IP adresses\n    and helps in getting the information very fast. It is basically the\n    equivalent of running the `host` command on the command line many times:\n\n    .. code-block:: bash\n\n        $ host advertools.readthedocs.io\n        advertools.readthedocs.io has address 104.17.32.82\n\n    Parameters\n    ----------\n    ip_list : list\n      A list of IP addresses.\n    max_workers : int\n      The maximum number of workers to use for multi processing.\n\n\n    You also get a simple report about the counts of the IPs to get an overview\n    of the top ones.\n\n    Examples\n    --------\n    >>> import advertools as adv\n    >>> ip_list = [\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.194\",\n    ...     \"66.249.66.91\",\n    ...     \"66.249.66.91\",\n    ...     \"130.185.74.243\",\n    ...     \"31.56.96.51\",\n    ...     \"5.211.97.39\",\n    ... ]\n    >>> adv.reverse_dns_lookup([ip_list])\n\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n      ..  ip_address        count    cum_count    perc    cum_perc  hostname                           aliaslist                    ipaddrlist      errors\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n       0  66.249.66.194         3            3   0.375       0.375  crawl-66-249-66-194.googlebot.com  194.66.249.66.in-addr.arpa   66.249.66.194\n       1  66.249.66.91          2            5   0.25        0.625  crawl-66-249-66-91.googlebot.com   91.66.249.66.in-addr.arpa    66.249.66.91\n       2  130.185.74.243        1            6   0.125       0.75   mail.garda.ir                      243.74.185.130.in-addr.arpa  130.185.74.243\n       3  31.56.96.51           1            7   0.125       0.875  31-56-96-51.shatel.ir              51.96.56.31.in-addr.arpa     31.56.96.51\n       4  5.211.97.39           1            8   0.125       1                                                                                      [Errno 1] Unknown host\n    ====  ==============  =======  ===========  ======  ==========  =================================  ===========================  ==============  ======================\n    \"\"\"\n    socket.setdefaulttimeout(8)\n    count_df = pd.Series(ip_list).value_counts().reset_index()\n    count_df.columns = ['ip_address', 'count']\n    count_df['cum_count'] = count_df['count'].cumsum()\n    count_df['perc'] = count_df['count'].div(count_df['count'].sum())\n    count_df['cum_perc'] = count_df['perc'].cumsum()\n    hosts = []\n    if system == 'Darwin':\n        with futures.ProcessPoolExecutor(max_workers=max_workers) as executor:\n            for _ip, host in zip(ip_list, executor.map(_single_request, count_df['ip_address'])):\n                hosts.append(host)\n    else:\n        with futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for host in executor.map(_single_request, count_df['ip_address']):\n                hosts.append(host)\n    df = pd.DataFrame(hosts)\n    columns = ['ip', 'hostname', 'aliaslist', 'ipaddrlist', 'errors']\n    if df.shape[1] == 4:\n        columns = columns[:-1]\n    df.columns = columns\n    final_df = pd.merge(count_df, df, left_on='ip_address', right_on='ip', how='left').drop('ip', axis=1)\n    return final_df"
  },
  "call_tree": {
    "tests/test_reverse_dns_lookup.py:test_reverse_dns_single_returns_ip_in_result": {
      "advertools/reverse_dns_lookup.py:_single_request": {}
    },
    "tests/test_reverse_dns_lookup.py:test_reverse_dns_single_returns_error": {
      "advertools/reverse_dns_lookup.py:_single_request": {}
    }
  }
}