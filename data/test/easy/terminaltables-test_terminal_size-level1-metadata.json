{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_terminal_size",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_terminal_io/test_terminal_size.py",
  "test_code": "\"\"\"Test function in module.\"\"\"\n\nimport pytest\n\nfrom terminaltables3.terminal_io import (\n    DEFAULT_HEIGHT,\n    DEFAULT_WIDTH,\n    INVALID_HANDLE_VALUE,\n    IS_WINDOWS,\n    terminal_size,\n)\n\nfrom tests.test_terminal_io import MockKernel32\n\n\n@pytest.mark.parametrize(\"stderr\", [1, INVALID_HANDLE_VALUE])\n@pytest.mark.parametrize(\"stdout\", [2, INVALID_HANDLE_VALUE])\ndef test_windows(monkeypatch, stderr, stdout):\n    \"\"\"Test function with IS_WINDOWS=True.\n\n    :param monkeypatch: pytest fixture.\n    :param int stderr: Mock handle value.\n    :param int stdout: Mock handle value.\n    \"\"\"\n    monkeypatch.setattr(\"terminaltables3.terminal_io.IS_WINDOWS\", True)\n\n    kernel32 = MockKernel32(stderr=stderr, stdout=stdout)\n    width, height = terminal_size(kernel32)\n\n    if stderr == INVALID_HANDLE_VALUE and stdout == INVALID_HANDLE_VALUE:\n        assert width == DEFAULT_WIDTH\n        assert height == DEFAULT_HEIGHT\n    elif stdout == INVALID_HANDLE_VALUE:\n        assert width == 119\n        assert height == 29\n    elif stderr == INVALID_HANDLE_VALUE:\n        assert width == 75\n        assert height == 28\n    else:\n        assert width == 119\n        assert height == 29\n\n\n@pytest.mark.skipif(str(IS_WINDOWS))\ndef test_nix(monkeypatch):\n    \"\"\"Test function with IS_WINDOWS=False.\n\n    :param monkeypatch: pytest fixture.\n    \"\"\"\n    # Test exception (no terminal within pytest).\n    width, height = terminal_size()\n    assert width == DEFAULT_WIDTH\n    assert height == DEFAULT_HEIGHT\n\n    # Test mocked.\n    monkeypatch.setattr(\"fcntl.ioctl\", lambda *_: b\"\\x1d\\x00w\\x00\\xca\\x02\\x96\\x01\")\n    width, height = terminal_size()\n    assert width == 119\n    assert height == 29\n",
  "GT_file_code": {
    "terminaltables3/terminal_io.py": "\"\"\"Get info about the current terminal window/screen buffer.\"\"\"\n\nimport ctypes\nimport struct\nimport sys\nfrom typing import Tuple, Union\n\nDEFAULT_HEIGHT = 24\nDEFAULT_WIDTH = 79\nINVALID_HANDLE_VALUE = -1\nIS_WINDOWS = sys.platform == \"win32\"\nSTD_ERROR_HANDLE = -12\nSTD_OUTPUT_HANDLE = -11\n\n\ndef get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n    \"\"\"Get information about this current console window (Windows only).\n\n    https://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\n\n    :raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\n\n    :param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\n    :param int handle: stderr or stdout handle.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if handle == INVALID_HANDLE_VALUE:\n        raise OSError(\"Invalid handle.\")\n\n    # Query Win32 API.\n    lpcsbi = ctypes.create_string_buffer(22)  # Populated by GetConsoleScreenBufferInfo.\n    if not kernel32.GetConsoleScreenBufferInfo(handle, lpcsbi):\n        raise ctypes.WinError()  # Subclass of OSError.\n\n    # Parse data.\n    left, top, right, bottom = struct.unpack(\"hhhhHhhhhhh\", lpcsbi.raw)[5:-2]\n    width, height = right - left, bottom - top\n    return width, height\n\n\ndef terminal_size(kernel32=None) -> Tuple[int, int]:\n    \"\"\"Get the width and height of the terminal.\n\n    http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/\n    http://stackoverflow.com/questions/17993814/why-the-irrelevant-code-made-a-difference\n\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            return get_console_info(kernel32, kernel32.GetStdHandle(STD_ERROR_HANDLE))\n        except OSError:\n            try:\n                return get_console_info(\n                    kernel32, kernel32.GetStdHandle(STD_OUTPUT_HANDLE)\n                )\n            except OSError:\n                return DEFAULT_WIDTH, DEFAULT_HEIGHT\n\n    try:\n        device = __import__(\"fcntl\").ioctl(\n            0, __import__(\"termios\").TIOCGWINSZ, \"\\0\\0\\0\\0\\0\\0\\0\\0\"\n        )\n    except OSError:\n        return DEFAULT_WIDTH, DEFAULT_HEIGHT\n    height, width = struct.unpack(\"hhhh\", device)[:2]\n    return width, height\n\n\ndef set_terminal_title(title: Union[str, bytes], kernel32=None) -> bool:\n    \"\"\"Set the terminal title.\n\n    :param title: The title to set (string, unicode, bytes accepted).\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: If title changed successfully (Windows only, always True on Linux/OSX).\n    :rtype: bool\n    \"\"\"\n    try:\n        title_bytes = title.encode(\"utf-8\")\n    except AttributeError:\n        title_bytes = title\n\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            is_ascii = all(ord(c) < 128 for c in title)  # str/unicode.\n        except TypeError:\n            is_ascii = all(c < 128 for c in title)  # bytes.\n        if is_ascii:\n            return kernel32.SetConsoleTitleA(title_bytes) != 0\n        return kernel32.SetConsoleTitleW(title) != 0\n\n    # Linux/OSX.\n    sys.stdout.write(b\"\\033]0;\" + title_bytes + b\"\\007\")\n    return True\n"
  },
  "GT_src_dict": {
    "terminaltables3/terminal_io.py": {
      "terminal_size": {
        "code": "def terminal_size(kernel32=None) -> Tuple[int, int]:\n    \"\"\"Retrieve the current terminal's width and height in characters and lines.\n\nThis function detects the terminal size based on the operating system. On Windows, it utilizes the Win32 API to get console screen buffer information through the `get_console_info` function, first trying the standard error handle, and then falling back to the standard output handle if necessary. It returns default values defined by `DEFAULT_WIDTH` (79 characters) and `DEFAULT_HEIGHT` (24 lines) if there are any failures. For non-Windows systems, it uses Unix system calls (`fcntl` and `termios`) to obtain the terminal dimensions.\n\nParameters:\n- kernel32 (optional): A mock kernel32 object used for testing. If not provided, the function will use the actual `ctypes.windll.kernel32` on Windows.\n\nReturns:\n- Tuple[int, int]: A tuple of two integers representing the terminal width and height.\n\nConstants:\n- IS_WINDOWS (bool): A flag that indicates if the script is running on a Windows platform.\n- DEFAULT_WIDTH (int): The default width (79) used when the terminal size cannot be determined.\n- DEFAULT_HEIGHT (int): The default height (24) used when the terminal size cannot be determined.\"\"\"\n    'Get the width and height of the terminal.\\n\\n    http://code.activestate.com/recipes/440694-determine-size-of-console-window-on-windows/\\n    http://stackoverflow.com/questions/17993814/why-the-irrelevant-code-made-a-difference\\n\\n    :param kernel32: Optional mock kernel32 object. For testing.\\n\\n    :return: Width (number of characters) and height (number of lines) of the terminal.\\n    :rtype: tuple\\n    '\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            return get_console_info(kernel32, kernel32.GetStdHandle(STD_ERROR_HANDLE))\n        except OSError:\n            try:\n                return get_console_info(kernel32, kernel32.GetStdHandle(STD_OUTPUT_HANDLE))\n            except OSError:\n                return (DEFAULT_WIDTH, DEFAULT_HEIGHT)\n    try:\n        device = __import__('fcntl').ioctl(0, __import__('termios').TIOCGWINSZ, '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n    except OSError:\n        return (DEFAULT_WIDTH, DEFAULT_HEIGHT)\n    height, width = struct.unpack('hhhh', device)[:2]\n    return (width, height)",
        "docstring": "Retrieve the current terminal's width and height in characters and lines.\n\nThis function detects the terminal size based on the operating system. On Windows, it utilizes the Win32 API to get console screen buffer information through the `get_console_info` function, first trying the standard error handle, and then falling back to the standard output handle if necessary. It returns default values defined by `DEFAULT_WIDTH` (79 characters) and `DEFAULT_HEIGHT` (24 lines) if there are any failures. For non-Windows systems, it uses Unix system calls (`fcntl` and `termios`) to obtain the terminal dimensions.\n\nParameters:\n- kernel32 (optional): A mock kernel32 object used for testing. If not provided, the function will use the actual `ctypes.windll.kernel32` on Windows.\n\nReturns:\n- Tuple[int, int]: A tuple of two integers representing the terminal width and height.\n\nConstants:\n- IS_WINDOWS (bool): A flag that indicates if the script is running on a Windows platform.\n- DEFAULT_WIDTH (int): The default width (79) used when the terminal size cannot be determined.\n- DEFAULT_HEIGHT (int): The default height (24) used when the terminal size cannot be determined.",
        "signature": "def terminal_size(kernel32=None) -> Tuple[int, int]:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "terminaltables3/terminal_io.py:terminal_size": {
      "terminaltables3/terminal_io.py": {
        "get_console_info": {
          "code": "def get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n    \"\"\"Get information about this current console window (Windows only).\n\n    https://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\n\n    :raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\n\n    :param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\n    :param int handle: stderr or stdout handle.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if handle == INVALID_HANDLE_VALUE:\n        raise OSError('Invalid handle.')\n    lpcsbi = ctypes.create_string_buffer(22)\n    if not kernel32.GetConsoleScreenBufferInfo(handle, lpcsbi):\n        raise ctypes.WinError()\n    left, top, right, bottom = struct.unpack('hhhhHhhhhhh', lpcsbi.raw)[5:-2]\n    width, height = (right - left, bottom - top)\n    return (width, height)",
          "docstring": "Get information about this current console window (Windows only).\n\nhttps://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\n\n:raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\n\n:param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\n:param int handle: stderr or stdout handle.\n\n:return: Width (number of characters) and height (number of lines) of the terminal.\n:rtype: tuple",
          "signature": "def get_console_info(kernel32, handle: int) -> Tuple[int, int]:",
          "type": "Function",
          "class_signature": null
        }
      },
      "tests/test_terminal_io/__init__.py": {
        "MockKernel32.GetStdHandle": {
          "code": "    def GetStdHandle(self, handle):  # noqa\n        \"\"\"Mock GetStdHandle.\n\n        :param int handle: STD_ERROR_HANDLE or STD_OUTPUT_HANDLE.\n        \"\"\"\n        return self.stderr if handle == terminal_io.STD_ERROR_HANDLE else self.stdout",
          "docstring": "Mock GetStdHandle.\n\n:param int handle: STD_ERROR_HANDLE or STD_OUTPUT_HANDLE.",
          "signature": "def GetStdHandle(self, handle):",
          "type": "Method",
          "class_signature": "class MockKernel32:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: terminaltables-test_terminal_size\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u2514\u2500\u2500 terminal_io.py\n        \u2514\u2500\u2500 terminal_size\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to determine and return the dimensions of a terminal interface, adapting to both Windows and Unix-like operating systems. It provides functionality to retrieve terminal width and height, using default values or system-specific configurations when precise terminal metrics are unavailable or invalid. The module ensures compatibility across platforms, handling edge cases such as invalid terminal handles on Windows and non-standard terminal environments on Unix systems, thereby maintaining resilience in diverse runtime conditions. This solves the problem of reliably accessing terminal size information in multi-platform environments, enabling developers to create terminal-based applications or features that dynamically adjust to varying interface dimensions.\n\n## FILE 1: terminaltables3/terminal_io.py\n\n- FUNCTION NAME: terminal_size\n  - SIGNATURE: def terminal_size(kernel32=None) -> Tuple[int, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the current terminal's width and height in characters and lines.\n\nThis function detects the terminal size based on the operating system. On Windows, it utilizes the Win32 API to get console screen buffer information through the `get_console_info` function, first trying the standard error handle, and then falling back to the standard output handle if necessary. It returns default values defined by `DEFAULT_WIDTH` (79 characters) and `DEFAULT_HEIGHT` (24 lines) if there are any failures. For non-Windows systems, it uses Unix system calls (`fcntl` and `termios`) to obtain the terminal dimensions.\n\nParameters:\n- kernel32 (optional): A mock kernel32 object used for testing. If not provided, the function will use the actual `ctypes.windll.kernel32` on Windows.\n\nReturns:\n- Tuple[int, int]: A tuple of two integers representing the terminal width and height.\n\nConstants:\n- IS_WINDOWS (bool): A flag that indicates if the script is running on a Windows platform.\n- DEFAULT_WIDTH (int): The default width (79) used when the terminal size cannot be determined.\n- DEFAULT_HEIGHT (int): The default height (24) used when the terminal size cannot be determined.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/terminal_io.py:get_console_info\n    - tests/test_terminal_io/__init__.py:MockKernel32:GetStdHandle\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/terminal_io.py": "\"\"\"Get info about the current terminal window/screen buffer.\"\"\"\nimport ctypes\nimport struct\nimport sys\nfrom typing import Tuple, Union\nDEFAULT_HEIGHT = 24\nDEFAULT_WIDTH = 79\nINVALID_HANDLE_VALUE = -1\nIS_WINDOWS = sys.platform == 'win32'\nSTD_ERROR_HANDLE = -12\nSTD_OUTPUT_HANDLE = -11\n\ndef get_console_info(kernel32, handle: int) -> Tuple[int, int]:\n    \"\"\"Get information about this current console window (Windows only).\n\n    https://github.com/Robpol86/colorclass/blob/ab42da59/colorclass/windows.py#L111\n\n    :raise OSError: When handle is invalid or GetConsoleScreenBufferInfo API call fails.\n\n    :param ctypes.windll.kernel32 kernel32: Loaded kernel32 instance.\n    :param int handle: stderr or stdout handle.\n\n    :return: Width (number of characters) and height (number of lines) of the terminal.\n    :rtype: tuple\n    \"\"\"\n    if handle == INVALID_HANDLE_VALUE:\n        raise OSError('Invalid handle.')\n    lpcsbi = ctypes.create_string_buffer(22)\n    if not kernel32.GetConsoleScreenBufferInfo(handle, lpcsbi):\n        raise ctypes.WinError()\n    left, top, right, bottom = struct.unpack('hhhhHhhhhhh', lpcsbi.raw)[5:-2]\n    width, height = (right - left, bottom - top)\n    return (width, height)\n\ndef set_terminal_title(title: Union[str, bytes], kernel32=None) -> bool:\n    \"\"\"Set the terminal title.\n\n    :param title: The title to set (string, unicode, bytes accepted).\n    :param kernel32: Optional mock kernel32 object. For testing.\n\n    :return: If title changed successfully (Windows only, always True on Linux/OSX).\n    :rtype: bool\n    \"\"\"\n    try:\n        title_bytes = title.encode('utf-8')\n    except AttributeError:\n        title_bytes = title\n    if IS_WINDOWS:\n        kernel32 = kernel32 or ctypes.windll.kernel32\n        try:\n            is_ascii = all((ord(c) < 128 for c in title))\n        except TypeError:\n            is_ascii = all((c < 128 for c in title))\n        if is_ascii:\n            return kernel32.SetConsoleTitleA(title_bytes) != 0\n        return kernel32.SetConsoleTitleW(title) != 0\n    sys.stdout.write(b'\\x1b]0;' + title_bytes + b'\\x07')\n    return True"
  },
  "call_tree": {
    "tests/test_terminal_io/test_terminal_size.py:test_windows": {
      "tests/test_terminal_io/__init__.py:MockKernel32:__init__": {},
      "terminaltables3/terminal_io.py:terminal_size": {
        "tests/test_terminal_io/__init__.py:MockKernel32:GetStdHandle": {},
        "terminaltables3/terminal_io.py:get_console_info": {
          "tests/test_terminal_io/__init__.py:MockKernel32:GetConsoleScreenBufferInfo": {}
        }
      }
    },
    "tests/test_terminal_io/test_terminal_size.py:test_nix": {
      "terminaltables3/terminal_io.py:terminal_size": {}
    }
  }
}