{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_filter",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/test_filter.py",
  "test_code": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport casbin\nfrom unittest import TestCase\nfrom tests.test_enforcer import get_examples\nfrom casbin.persist.adapters import FilteredFileAdapter\n\n\nclass Filter:\n    # P,G are strings\n    P = []\n    G = []\n\n\nclass TestFilteredFileAdapter(TestCase):\n    def test_init_filtered_adapter(self):\n        adapter = FilteredFileAdapter(get_examples(\"rbac_with_domains_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n        self.assertFalse(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n\n    def test_load_filtered_policy(self):\n        adapter = FilteredFileAdapter(get_examples(\"rbac_with_domains_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n        filter = Filter()\n        filter.P = [\"\", \"domain1\"]\n        filter.G = [\"\", \"\", \"domain1\"]\n        try:\n            e.load_policy()\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n        self.assertTrue(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n        self.assertTrue(e.has_policy([\"admin\", \"domain2\", \"data2\", \"read\"]))\n        try:\n            e.load_filtered_policy(filter)\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n\n        if not e.is_filtered:\n            raise RuntimeError(\"adapter did not set the filtered flag correctly\")\n\n        self.assertTrue(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n        self.assertFalse(e.has_policy([\"admin\", \"domain2\", \"data2\", \"read\"]))\n\n        with self.assertRaises(RuntimeError):\n            e.save_policy()\n\n        with self.assertRaises(RuntimeError):\n            e.get_adapter().save_policy(e.get_model())\n\n    def test_append_filtered_policy(self):\n        adapter = FilteredFileAdapter(get_examples(\"rbac_with_domains_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n        filter = Filter()\n        filter.P = [\"\", \"domain1\"]\n        filter.G = [\"\", \"\", \"domain1\"]\n        try:\n            e.load_policy()\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n        self.assertTrue(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n        self.assertTrue(e.has_policy([\"admin\", \"domain2\", \"data2\", \"read\"]))\n        try:\n            e.load_filtered_policy(filter)\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n\n        if not e.is_filtered:\n            raise RuntimeError(\"adapter did not set the filtered flag correctly\")\n\n        self.assertTrue(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n        self.assertFalse(e.has_policy([\"admin\", \"domain2\", \"data2\", \"read\"]))\n\n        filter.P = [\"\", \"domain2\"]\n        filter.G = [\"\", \"\", \"domain2\"]\n        try:\n            e.load_increment_filtered_policy(filter)\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n\n        self.assertTrue(e.has_policy([\"admin\", \"domain1\", \"data1\", \"read\"]))\n        self.assertTrue(e.has_policy([\"admin\", \"domain2\", \"data2\", \"read\"]))\n\n    def test_filtered_policy_invalid_filter(self):\n        adapter = FilteredFileAdapter(get_examples(\"rbac_with_domains_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n        filter = [\"\", \"domain1\"]\n\n        with self.assertRaises(RuntimeError):\n            e.load_filtered_policy(filter)\n\n    def test_filtered_policy_empty_filter(self):\n        adapter = FilteredFileAdapter(get_examples(\"rbac_with_domains_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n\n        try:\n            e.load_filtered_policy(None)\n        except:\n            raise RuntimeError(\"unexpected error in LoadFilteredPolicy\")\n\n        if e.is_filtered():\n            raise RuntimeError(\"adapter did not reset the filtered flag correctly\")\n\n        try:\n            e.save_policy()\n        except:\n            raise RuntimeError(\"unexpected error in SavePolicy\")\n\n    def test_unsupported_filtered_policy(self):\n        e = casbin.Enforcer(\n            get_examples(\"rbac_with_domains_model.conf\"),\n            get_examples(\"rbac_with_domains_policy.csv\"),\n        )\n        filter = Filter()\n        filter.P = [\"\", \"domain1\"]\n        filter.G = [\"\", \"\", \"domain1\"]\n        with self.assertRaises(ValueError):\n            e.load_filtered_policy(filter)\n\n    def test_filtered_adapter_empty_filepath(self):\n        adapter = FilteredFileAdapter(\"\")\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n\n        with self.assertRaises(RuntimeError):\n            e.load_filtered_policy(None)\n\n    def test_filtered_adapter_invalid_filepath(self):\n        adapter = FilteredFileAdapter(get_examples(\"does_not_exist_policy.csv\"))\n        e = casbin.Enforcer(get_examples(\"rbac_with_domains_model.conf\"), adapter)\n\n        with self.assertRaises(RuntimeError):\n            e.load_filtered_policy(None)\n",
  "GT_file_code": {
    "casbin/core_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport logging\n\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n\n    model_path = \"\"\n    model = None\n    fm = None\n    eft = None\n\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def __init__(self, model=None, adapter=None, enable_log=False):\n        self.logger = logging.getLogger(\"casbin.enforcer\")\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        else:\n            if isinstance(adapter, str):\n                raise RuntimeError(\"Invalid parameters for enforcer.\")\n            else:\n                self.init_with_model_and_adapter(model, adapter)\n\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n\n        if not isinstance(m, Model) or adapter is not None and not isinstance(adapter, Adapter):\n            raise RuntimeError(\"Invalid parameters for enforcer.\")\n\n        self.adapter = adapter\n\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n        self._initialize()\n\n        # Do not initialize the full policy when using a filtered adapter\n        if self.adapter and not self.is_filtered():\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model[\"e\"][\"e\"].value)\n        self.watcher = None\n\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path=\"\", text=\"\"):\n        \"\"\"creates a model.\"\"\"\n\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n\n        return self.model\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n\n        return self.adapter\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n\n        self.adapter = adapter\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n\n        self.watcher = watcher\n        pass\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map[\"g\"]\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError(\"ptype not found\")\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map[\"g\"] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n\n        self.model.clear_policy()\n\n    def init_rm_map(self):\n        if \"g\" in self.model.keys():\n            for ptype in self.model[\"g\"]:\n                assertion = self.model[\"g\"][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n\n        try:\n            self.adapter.load_policy(new_model)\n\n            new_model.sort_policies_by_subject_hierarchy()\n\n            new_model.sort_policies_by_priority()\n\n            new_model.print_policy()\n\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n\n            self.model = new_model\n\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n\n            raise e\n\n    def load_filtered_policy(self, filter):\n        \"\"\"reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n\n        self.model.sort_policies_by_priority()\n\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n\n        return hasattr(self.adapter, \"is_filtered\") and self.adapter.is_filtered()\n\n    def save_policy(self):\n        if self.is_filtered():\n            raise RuntimeError(\"cannot save a filtered policy\")\n\n        self.adapter.save_policy(self.model)\n\n        if self.watcher:\n            if callable(getattr(self.watcher, \"update_for_save_policy\", None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"controls whether to save a policy rule automatically notify the watcher when it is added or removed.\"\"\"\n        self.auto_notify_watcher = auto_notify_watcher\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n\n        for rm in self.rm_map.values():\n            rm.clear()\n\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(\n            rtype=\"r\" + suffix,\n            ptype=\"p\" + suffix,\n            etype=\"e\" + suffix,\n            mtype=\"m\" + suffix,\n        )\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n\n        rtype = \"r\"\n        ptype = \"p\"\n        etype = \"e\"\n        mtype = \"m\"\n\n        if not self.enabled:\n            return [True, []]\n\n        functions = self.fm.get_functions()\n\n        if \"g\" in self.model.keys():\n            for key, ast in self.model[\"g\"].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n\n        if \"m\" not in self.model.keys():\n            raise RuntimeError(\"model is undefined\")\n\n        if \"m\" not in self.model[\"m\"].keys():\n            raise RuntimeError(\"model is undefined\")\n\n        r_tokens = self.model[\"r\"][rtype].tokens\n        p_tokens = self.model[\"p\"][ptype].tokens\n\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError(\"invalid request size\")\n\n        exp_string = self.model[\"m\"][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n\n        policy_effects = set()\n\n        r_parameters = dict(zip(r_tokens, rvals))\n\n        policy_len = len(self.model[\"p\"][ptype].policy)\n\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model[\"p\"][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError(\"invalid policy size\")\n\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n\n                result = expression.eval(parameters)\n\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError(\"matcher result should be bool, int or float\")\n\n                p_eft_key = ptype + \"_eft\"\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if \"allow\" == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif \"deny\" == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n\n        else:\n            if exp_has_eval:\n                raise RuntimeError(\"please make sure rule exists in policy when using eval() in matcher\")\n\n            parameters = r_parameters.copy()\n\n            for token in self.model[\"p\"][ptype].tokens:\n                parameters[token] = \"\"\n\n            result = expression.eval(parameters)\n\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n\n        # Log request.\n\n        req_str = \"Request: \"\n        req_str = req_str + \", \".join([str(v) for v in rvals])\n\n        req_str = req_str + \" ---> %s\" % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            # leaving this in warning for now, if it's very noise this can be changed to info or debug,\n            # or change the log level\n            self.logger.warning(req_str)\n\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model[\"p\"][ptype].policy[explain_index]\n\n        return result, explain_rule\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace(\"&&\", \"and\")\n        expr = expr.replace(\"||\", \"or\")\n        expr = expr.replace(\"!\", \"not\")\n\n        return SimpleEval(expr, functions)\n",
    "casbin/persist/adapters/filtered_file_adapter.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\n\nfrom casbin import persist\n\nfrom .file_adapter import FileAdapter\nfrom ..adapter_filtered import FilteredAdapter\n\n\nclass Filter:\n    # P,G are string []\n    P = []\n    G = []\n\n\nclass FilteredFileAdapter(FileAdapter, FilteredAdapter):\n    filtered = False\n    _file_path = \"\"\n    filter = Filter()\n\n    # new_filtered_adapter is the constructor for FilteredAdapter.\n    def __init__(self, file_path):\n        self.filtered = True\n        self._file_path = file_path\n\n    def load_policy(self, model):\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError(\"invalid file path, file path cannot be empty\")\n        self.filtered = False\n        self._load_policy_file(model)\n\n    # load_filtered_policy loads only policy rules that match the filter.\n    def load_filtered_policy(self, model, filter):\n        if filter == None:\n            return self.load_policy(model)\n\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError(\"invalid file path, file path cannot be empty\")\n\n        try:\n            filter_value = [filter.__dict__[\"P\"]] + [filter.__dict__[\"G\"]]\n        except:\n            raise RuntimeError(\"invalid filter type\")\n\n        self.load_filtered_policy_file(model, filter_value, persist.load_policy_line)\n        self.filtered = True\n\n    def load_filtered_policy_file(self, model, filter, hanlder):\n        with open(self._file_path, \"rb\") as file:\n            while True:\n                line = file.readline()\n                line = line.decode().strip()\n                if line == \"\\n\":\n                    continue\n                if not line:\n                    break\n                if filter_line(line, filter):\n                    continue\n\n                hanlder(line, model)\n\n    # is_filtered returns true if the loaded policy has been filtered.\n    def is_filtered(self):\n        return self.filtered\n\n    def save_policy(self, model):\n        if self.filtered:\n            raise RuntimeError(\"cannot save a filtered policy\")\n\n        self._save_policy_file(model)\n\n\ndef filter_line(line, filter):\n    if filter == None:\n        return False\n\n    p = line.split(\",\")\n    if len(p) == 0:\n        return True\n    filter_slice = []\n\n    if p[0].strip() == \"p\":\n        filter_slice = filter[0]\n    elif p[0].strip() == \"g\":\n        filter_slice = filter[1]\n    return filter_words(p, filter_slice)\n\n\ndef filter_words(line, filter):\n    if len(line) < len(filter) + 1:\n        return True\n    skip_line = False\n    for i, v in enumerate(filter):\n        if len(v) > 0 and (v.strip() != line[i + 1].strip()):\n            skip_line = True\n            break\n\n    return skip_line\n",
    "casbin/management_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom casbin.internal_enforcer import InternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\nfrom casbin.constant.constants import ACTION_INDEX, SUBJECT_INDEX, OBJECT_INDEX\n\n\nclass ManagementEnforcer(InternalEnforcer):\n    \"\"\"\n    ManagementEnforcer = InternalEnforcer + Management API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects(\"p\")\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, SUBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects(\"p\")\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, OBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions(\"p\")\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, ACTION_INDEX)\n        return self.model.get_values_for_field_in_policy(\"p\", ptype, field_index)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles(\"g\")\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy(\"g\", ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy(\"p\")\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy(\"p\", field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy(\"p\", ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy(\"g\")\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy(\"g\", ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy(\"g\", ptype, field_index, *field_values)\n\n    def has_policy(self, *params):\n        \"\"\"determines whether an authorization rule exists.\"\"\"\n        return self.has_named_policy(\"p\", *params)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"p\", ptype, str_slice)\n\n        return self.model.has_policy(\"p\", ptype, list(params))\n\n    def add_policy(self, *params):\n        \"\"\"adds an authorization rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_policy(\"p\", *params)\n\n    def add_policies(self, rules):\n        \"\"\"adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        return self.add_named_policies(\"p\", rules)\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy(\"p\", ptype, str_slice)\n        else:\n            rule_added = self._add_policy(\"p\", ptype, list(params))\n\n        return rule_added\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        return self._add_policies(\"p\", ptype, rules)\n\n    def update_policy(self, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current policy.\"\"\"\n        return self.update_named_policy(\"p\", old_rule, new_rule)\n\n    def update_policies(self, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current policy.\"\"\"\n        return self.update_named_policies(\"p\", old_rules, new_rules)\n\n    def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current named policy.\"\"\"\n        return self._update_policy(\"p\", ptype, old_rule, new_rule)\n\n    def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current named policy.\"\"\"\n        return self._update_policies(\"p\", ptype, old_rules, new_rules)\n\n    def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return self.update_filtered_named_policies(\"p\", new_rules, field_index, *field_values)\n\n    def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return self._update_filtered_policies(\"p\", ptype, new_rules, field_index, *field_values)\n\n    def remove_policy(self, *params):\n        \"\"\"removes an authorization rule from the current policy.\"\"\"\n        return self.remove_named_policy(\"p\", *params)\n\n    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\"\"\"\n        return self.remove_named_policies(\"p\", rules)\n\n    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_policy(\"p\", field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy(\"p\", ptype, str_slice)\n        else:\n            rule_removed = self._remove_policy(\"p\", ptype, list(params))\n\n        return rule_removed\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        return self._remove_policies(\"p\", ptype, rules)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return self._remove_filtered_policy(\"p\", ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n\n        return self.has_named_grouping_policy(\"g\", *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy(\"g\", ptype, str_slice)\n\n        return self.model.has_policy(\"g\", ptype, list(params))\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policy(\"g\", *params)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policies(\"g\", rules)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = self._add_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n            if ptype in self.cond_rm_map:\n                self.model.build_incremental_conditional_role_links(\n                    self.cond_rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules\n                )\n        return rule_added\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        rules_added = self._add_policies(\"g\", ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, \"g\", ptype, rules)\n\n        return rules_added\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        return self.remove_named_grouping_policy(\"g\", *params)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        return self.remove_named_grouping_policies(\"g\", rules)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_grouping_policy(\"g\", field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy(\"g\", ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = self._remove_policy(\"g\", ptype, list(params))\n            rules.append(list(params))\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n        return rule_removed\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = self._remove_policies(\"g\", ptype, rules)\n\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rules)\n\n        return rules_removed\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = self._remove_filtered_policy_returns_effects(\"g\", ptype, field_index, *field_values)\n\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(\n                self.rm_map[ptype], PolicyOp.Policy_remove, \"g\", ptype, rule_removed\n            )\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)\n"
  },
  "GT_src_dict": {
    "casbin/core_enforcer.py": {
      "CoreEnforcer.__init__": {
        "code": "    def __init__(self, model=None, adapter=None, enable_log=False):\n        \"\"\"Initializes a CoreEnforcer instance, defining the primary functionality of an authorization enforcer in the Casbin framework. \n\n    Parameters:\n    - model: Either a string representing the path to the model file or a Model object. Used to define the access control model.\n    - adapter: Can be a string indicating the path to the policy file or an Adapter object, which interfaces with the data storage for policies.\n    - enable_log: A boolean that, if True, enables logging for the enforcer's operations.\n\n    Raises:\n    - RuntimeError: If the parameters are invalid, specifically if a string adapter is provided when the model is not also a string.\n\n    Side Effects:\n    - Configures logging based on the enable_log parameter, affecting how information and errors are logged during operations.\n    - Initializes various internal states and prepares the enforcer for policy management and enforcement based on the provided model and adapter.\n\n    This method relies on helper methods such as init_with_file, init_with_adapter, and init_with_model_and_adapter to appropriately structure the enforcer based on the provided parameters.\"\"\"\n        self.logger = logging.getLogger('casbin.enforcer')\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        elif isinstance(adapter, str):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        else:\n            self.init_with_model_and_adapter(model, adapter)\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()",
        "docstring": "Initializes a CoreEnforcer instance, defining the primary functionality of an authorization enforcer in the Casbin framework. \n\nParameters:\n- model: Either a string representing the path to the model file or a Model object. Used to define the access control model.\n- adapter: Can be a string indicating the path to the policy file or an Adapter object, which interfaces with the data storage for policies.\n- enable_log: A boolean that, if True, enables logging for the enforcer's operations.\n\nRaises:\n- RuntimeError: If the parameters are invalid, specifically if a string adapter is provided when the model is not also a string.\n\nSide Effects:\n- Configures logging based on the enable_log parameter, affecting how information and errors are logged during operations.\n- Initializes various internal states and prepares the enforcer for policy management and enforcement based on the provided model and adapter.\n\nThis method relies on helper methods such as init_with_file, init_with_adapter, and init_with_model_and_adapter to appropriately structure the enforcer based on the provided parameters.",
        "signature": "def __init__(self, model=None, adapter=None, enable_log=False):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.get_model": {
        "code": "    def get_model(self):\n        \"\"\"Retrieves the current model associated with the CoreEnforcer instance.\n\nReturns:\n    Model: The current model (an instance of the Model class) that is used for enforcing access control policies.\n\nThis method provides access to the internal model of the enforcer, which defines the structure and rules for authorization policies. It is essential for retrieving and examining the configured policies and their relationships within the enforcer. This method interacts with the `self.model` attribute, which is initialized when the CoreEnforcer is set up with a model and an adapter.\"\"\"\n        'gets the current model.'\n        return self.model",
        "docstring": "Retrieves the current model associated with the CoreEnforcer instance.\n\nReturns:\n    Model: The current model (an instance of the Model class) that is used for enforcing access control policies.\n\nThis method provides access to the internal model of the enforcer, which defines the structure and rules for authorization policies. It is essential for retrieving and examining the configured policies and their relationships within the enforcer. This method interacts with the `self.model` attribute, which is initialized when the CoreEnforcer is set up with a model and an adapter.",
        "signature": "def get_model(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.get_adapter": {
        "code": "    def get_adapter(self):\n        \"\"\"Retrieves the current policy adapter being used by the CoreEnforcer instance.\n\n    This adapter is responsible for loading, saving, and manipulating policy data. It is\n    set during the initialization of the CoreEnforcer and can be updated or replaced\n    using the `set_adapter` method. This method does not take any parameters.\n\n    Returns:\n        Adapter: The current adapter for the policy, which must implement the Adapter interface.\n\n    Notes:\n        The `adapter` instance variable is expected to be initialized during the \n        enforcer's setup with either a database adapter or a file adapter, allowing \n        the enforcer to read and write policies as required by the application.\"\"\"\n        'gets the current adapter.'\n        return self.adapter",
        "docstring": "Retrieves the current policy adapter being used by the CoreEnforcer instance.\n\nThis adapter is responsible for loading, saving, and manipulating policy data. It is\nset during the initialization of the CoreEnforcer and can be updated or replaced\nusing the `set_adapter` method. This method does not take any parameters.\n\nReturns:\n    Adapter: The current adapter for the policy, which must implement the Adapter interface.\n\nNotes:\n    The `adapter` instance variable is expected to be initialized during the \n    enforcer's setup with either a database adapter or a file adapter, allowing \n    the enforcer to read and write policies as required by the application.",
        "signature": "def get_adapter(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.load_policy": {
        "code": "    def load_policy(self):\n        \"\"\"reloads the policy from the configured adapter into the current model. It clears the existing policy in the model and attempts to load a new policy using the adapter's load_policy method. \n\nIf the loading is successful, it sorts the policies by subject hierarchy and priority. If auto-build role links is enabled, it clears the existing role manager links and rebuilds them based on the newly loaded policies.\n\nThis method interacts with the `adapter` attribute for loading the policy and uses the `rm_map` and `cond_rm_map` attributes to manage role inheritance.\n\nRaises:\n    Exception: If an error occurs during policy loading, or if the loaded model requires rebuilding role links but cannot do so.\n\nSide Effects:\n    The current model's policy is modified. Role links may be rebuilt if configured.\n\nDependencies:\n    - Requires an initialized adapter that implements the load_policy method.\n    - Interacts with Class attributes: `model`, `adapter`, `rm_map`, `cond_rm_map`, `auto_build_role_links`.\"\"\"\n        'reloads the policy from file/database.'\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n        try:\n            self.adapter.load_policy(new_model)\n            new_model.sort_policies_by_subject_hierarchy()\n            new_model.sort_policies_by_priority()\n            new_model.print_policy()\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n            self.model = new_model\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n            raise e",
        "docstring": "reloads the policy from the configured adapter into the current model. It clears the existing policy in the model and attempts to load a new policy using the adapter's load_policy method. \n\nIf the loading is successful, it sorts the policies by subject hierarchy and priority. If auto-build role links is enabled, it clears the existing role manager links and rebuilds them based on the newly loaded policies.\n\nThis method interacts with the `adapter` attribute for loading the policy and uses the `rm_map` and `cond_rm_map` attributes to manage role inheritance.\n\nRaises:\n    Exception: If an error occurs during policy loading, or if the loaded model requires rebuilding role links but cannot do so.\n\nSide Effects:\n    The current model's policy is modified. Role links may be rebuilt if configured.\n\nDependencies:\n    - Requires an initialized adapter that implements the load_policy method.\n    - Interacts with Class attributes: `model`, `adapter`, `rm_map`, `cond_rm_map`, `auto_build_role_links`.",
        "signature": "def load_policy(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.load_filtered_policy": {
        "code": "    def load_filtered_policy(self, filter):\n        \"\"\"Reloads a filtered policy from the file or database into the current model of the CoreEnforcer. This method clears the existing policy, ensuring that only the specified filtered policy is loaded. \n\nParameters:\n- filter: The filter criteria used to limit the loaded policy rules.\n\nRaises:\n- ValueError: If the adapter does not support filtered policies (i.e., it lacks the `is_filtered` attribute). \n\nSide Effects:\n- The existing policy in the model is cleared before loading the new filtered policy.\n- The loaded policy is sorted by priority.\n- The role manager map is initialized based on the loaded policies.\n- If `auto_build_role_links` is enabled, role inheritance relations are rebuilt based on the loaded policy. \n\nThis method interacts with the `adapter` to perform the loading of the filtered policy, and utilizes the `model` attribute to manage the current policy state within the enforcer. Additionally, it relies on these constants defined in the CoreEnforcer class:\n- `model`: Represents the current model's structure.\n- `adapter`: Handles data persistence and policy retrieval.\n- `auto_build_role_links`: A flag that indicates whether role inheritance should be automatically managed after policy changes.\"\"\"\n        'reloads a filtered policy from file/database.'\n        self.model.clear_policy()\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.sort_policies_by_priority()\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()",
        "docstring": "Reloads a filtered policy from the file or database into the current model of the CoreEnforcer. This method clears the existing policy, ensuring that only the specified filtered policy is loaded. \n\nParameters:\n- filter: The filter criteria used to limit the loaded policy rules.\n\nRaises:\n- ValueError: If the adapter does not support filtered policies (i.e., it lacks the `is_filtered` attribute). \n\nSide Effects:\n- The existing policy in the model is cleared before loading the new filtered policy.\n- The loaded policy is sorted by priority.\n- The role manager map is initialized based on the loaded policies.\n- If `auto_build_role_links` is enabled, role inheritance relations are rebuilt based on the loaded policy. \n\nThis method interacts with the `adapter` to perform the loading of the filtered policy, and utilizes the `model` attribute to manage the current policy state within the enforcer. Additionally, it relies on these constants defined in the CoreEnforcer class:\n- `model`: Represents the current model's structure.\n- `adapter`: Handles data persistence and policy retrieval.\n- `auto_build_role_links`: A flag that indicates whether role inheritance should be automatically managed after policy changes.",
        "signature": "def load_filtered_policy(self, filter):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.load_increment_filtered_policy": {
        "code": "    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy appends a filtered policy from the adapter to the current model of the CoreEnforcer instance. It checks if the current adapter supports filtered policies; if not, it raises a ValueError. After loading the policy, it prints the current policies and optionally rebuilds role links if auto-building is enabled.\n\nParameters:\n- filter: The filter criteria used to load a subset of the policy.\n\nReturns:\n- None\n\nSide Effects:\n- May modify the internal policy state of the enforcer by appending new rules.\n- Rebuilds role links if the `auto_build_role_links` attribute is set to True.\n\nDependencies:\n- This method relies on the `adapter` attribute, which must implement filtered policy loading, and the `model` attribute to provide the necessary policy structure. The `auto_build_role_links` boolean flag controls whether role links are rebuilt after loading the policy.\"\"\"\n        'LoadIncrementalFilteredPolicy append a filtered policy from file/database.'\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()",
        "docstring": "LoadIncrementalFilteredPolicy appends a filtered policy from the adapter to the current model of the CoreEnforcer instance. It checks if the current adapter supports filtered policies; if not, it raises a ValueError. After loading the policy, it prints the current policies and optionally rebuilds role links if auto-building is enabled.\n\nParameters:\n- filter: The filter criteria used to load a subset of the policy.\n\nReturns:\n- None\n\nSide Effects:\n- May modify the internal policy state of the enforcer by appending new rules.\n- Rebuilds role links if the `auto_build_role_links` attribute is set to True.\n\nDependencies:\n- This method relies on the `adapter` attribute, which must implement filtered policy loading, and the `model` attribute to provide the necessary policy structure. The `auto_build_role_links` boolean flag controls whether role links are rebuilt after loading the policy.",
        "signature": "def load_increment_filtered_policy(self, filter):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.is_filtered": {
        "code": "    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\n\nThis method checks if the current adapter, which is expected to handle policy persistence, has support for filtering. It verifies this by checking if the method `is_filtered` exists on the adapter and then calls it. The `adapter` is an instance of the `Adapter` class, which is initialized during the `CoreEnforcer` setup, either with a specific adapter type or a file adapter. This method is essential for determining if the enforcer is operating in filtered mode, which affects how policies are loaded and enforced.\"\"\"\n        'returns true if the loaded policy has been filtered.'\n        return hasattr(self.adapter, 'is_filtered') and self.adapter.is_filtered()",
        "docstring": "returns true if the loaded policy has been filtered.\n\nThis method checks if the current adapter, which is expected to handle policy persistence, has support for filtering. It verifies this by checking if the method `is_filtered` exists on the adapter and then calls it. The `adapter` is an instance of the `Adapter` class, which is initialized during the `CoreEnforcer` setup, either with a specific adapter type or a file adapter. This method is essential for determining if the enforcer is operating in filtered mode, which affects how policies are loaded and enforced.",
        "signature": "def is_filtered(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      },
      "CoreEnforcer.save_policy": {
        "code": "    def save_policy(self):\n        \"\"\"Saves the current policy to the adapter. This method first checks if the loaded policy has been filtered; if so, it raises an error as filtered policies cannot be saved. If the policy is valid, it uses the adapter's save_policy method to persist the model. If a watcher is set, it invokes an update method to notify the watcher of the changes. \n\n    Raises:\n        RuntimeError: If attempting to save a filtered policy.\n\n    Dependencies:\n        - `self.adapter`: An instance of an adapter (must implement save_policy) responsible for saving policy data.\n        - `self.model`: The current policy model being managed, which contains the policy information. \n        - `self.watcher`: An optional observer that can be notified after policy changes, enhancing dynamic updates.\"\"\"\n        if self.is_filtered():\n            raise RuntimeError('cannot save a filtered policy')\n        self.adapter.save_policy(self.model)\n        if self.watcher:\n            if callable(getattr(self.watcher, 'update_for_save_policy', None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()",
        "docstring": "Saves the current policy to the adapter. This method first checks if the loaded policy has been filtered; if so, it raises an error as filtered policies cannot be saved. If the policy is valid, it uses the adapter's save_policy method to persist the model. If a watcher is set, it invokes an update method to notify the watcher of the changes. \n\nRaises:\n    RuntimeError: If attempting to save a filtered policy.\n\nDependencies:\n    - `self.adapter`: An instance of an adapter (must implement save_policy) responsible for saving policy data.\n    - `self.model`: The current policy model being managed, which contains the policy information. \n    - `self.watcher`: An optional observer that can be notified after policy changes, enhancing dynamic updates.",
        "signature": "def save_policy(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      }
    },
    "casbin/persist/adapters/filtered_file_adapter.py": {
      "FilteredFileAdapter.__init__": {
        "code": "    def __init__(self, file_path):\n        \"\"\"Initializes a new instance of the FilteredFileAdapter class, which is a combination of FileAdapter and FilteredAdapter, designed for managing policy rules with filtering capabilities.\n\nParameters:\n- file_path (str): The file path to the policy rules file. This path is mandatory for loading policies.\n\nAttributes set during initialization:\n- filtered (bool): Set to True upon initialization, indicating that this adapter is configured to handle filtered policies.\n- _file_path (str): Stores the provided file path for subsequent policy loading operations.\n\nThis constructor does not return any value. It sets up the object to ensure it can load and manage policy rules while allowing for filtering according to specified conditions. The `filtered` attribute interacts with methods like `load_filtered_policy` and `save_policy` to enforce rules on the operations that can be performed on the policies.\"\"\"\n        self.filtered = True\n        self._file_path = file_path",
        "docstring": "Initializes a new instance of the FilteredFileAdapter class, which is a combination of FileAdapter and FilteredAdapter, designed for managing policy rules with filtering capabilities.\n\nParameters:\n- file_path (str): The file path to the policy rules file. This path is mandatory for loading policies.\n\nAttributes set during initialization:\n- filtered (bool): Set to True upon initialization, indicating that this adapter is configured to handle filtered policies.\n- _file_path (str): Stores the provided file path for subsequent policy loading operations.\n\nThis constructor does not return any value. It sets up the object to ensure it can load and manage policy rules while allowing for filtering according to specified conditions. The `filtered` attribute interacts with methods like `load_filtered_policy` and `save_policy` to enforce rules on the operations that can be performed on the policies.",
        "signature": "def __init__(self, file_path):",
        "type": "Method",
        "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
      },
      "FilteredFileAdapter.save_policy": {
        "code": "    def save_policy(self, model):\n        \"\"\"Saves the current policy to the file specified by _file_path. \n   \n    This method raises a RuntimeError if the adapter's current state is filtered, meaning it cannot save a filtered policy. If the state is valid, it calls the _save_policy_file method, which handles the actual saving process using the provided model. \n\n    Parameters:\n    - model: An instance representing the policy model that defines how the policy is structured and saved.\n\n    Raises:\n    - RuntimeError: If the current policy is filtered and cannot be saved.\n\n    Dependencies:\n    - The method relies on the _file_path attribute, which is set during the initialization of the FilteredFileAdapter class. This attribute specifies where the policy will be saved.\"\"\"\n        if self.filtered:\n            raise RuntimeError('cannot save a filtered policy')\n        self._save_policy_file(model)",
        "docstring": "Saves the current policy to the file specified by _file_path. \n\nThis method raises a RuntimeError if the adapter's current state is filtered, meaning it cannot save a filtered policy. If the state is valid, it calls the _save_policy_file method, which handles the actual saving process using the provided model. \n\nParameters:\n- model: An instance representing the policy model that defines how the policy is structured and saved.\n\nRaises:\n- RuntimeError: If the current policy is filtered and cannot be saved.\n\nDependencies:\n- The method relies on the _file_path attribute, which is set during the initialization of the FilteredFileAdapter class. This attribute specifies where the policy will be saved.",
        "signature": "def save_policy(self, model):",
        "type": "Method",
        "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
      }
    },
    "casbin/management_enforcer.py": {
      "ManagementEnforcer.has_policy": {
        "code": "    def has_policy(self, *params):\n        \"\"\"Determines whether a specified authorization rule exists in the current policy.\n\nParameters:\n*params: A variable number of parameters that make up the rule to check. If a single list is passed as a parameter, it is treated as the rule.\n\nReturns:\nbool: True if the specified rule exists in the policy; otherwise, False.\n\nThis method delegates the actual check to `has_named_policy` using the default policy type \"p\". The \"p\" type refers to the policy rules managed by this instance of `ManagementEnforcer`, which inherits from `InternalEnforcer` and has access to a model where policies are defined.\"\"\"\n        'determines whether an authorization rule exists.'\n        return self.has_named_policy('p', *params)",
        "docstring": "Determines whether a specified authorization rule exists in the current policy.\n\nParameters:\n*params: A variable number of parameters that make up the rule to check. If a single list is passed as a parameter, it is treated as the rule.\n\nReturns:\nbool: True if the specified rule exists in the policy; otherwise, False.\n\nThis method delegates the actual check to `has_named_policy` using the default policy type \"p\". The \"p\" type refers to the policy rules managed by this instance of `ManagementEnforcer`, which inherits from `InternalEnforcer` and has access to a model where policies are defined.",
        "signature": "def has_policy(self, *params):",
        "type": "Method",
        "class_signature": "class ManagementEnforcer(InternalEnforcer):"
      }
    }
  },
  "dependency_dict": {
    "casbin/core_enforcer.py:CoreEnforcer:__init__": {
      "casbin/core_enforcer.py": {
        "CoreEnforcer.init_with_file": {
          "code": "    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)",
          "docstring": "initializes an enforcer with a model file and a policy file.",
          "signature": "def init_with_file(self, model_path, policy_path):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        },
        "CoreEnforcer.init_with_adapter": {
          "code": "    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n        self.model_path = model_path",
          "docstring": "initializes an enforcer with a database adapter.",
          "signature": "def init_with_adapter(self, model_path, adapter=None):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "casbin/util/log.py": {
        "disabled_logging": {
          "code": "def disabled_logging():\n    for logger_name in DEFAULT_LOGGING[\"loggers\"].keys():\n        logging.getLogger(logger_name).disabled = True",
          "docstring": "",
          "signature": "def disabled_logging():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
      "casbin/model/policy.py": {
        "Policy.build_role_links": {
          "code": "    def build_role_links(self, rm_map):\n        \"\"\"initializes the roles in RBAC.\"\"\"\n\n        if \"g\" not in self.keys():\n            return\n\n        for ptype, ast in self[\"g\"].items():\n            rm = rm_map.get(ptype)\n            if rm:\n                ast.build_role_links(rm)",
          "docstring": "initializes the roles in RBAC.",
          "signature": "def build_role_links(self, rm_map):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.print_policy": {
          "code": "    def print_policy(self):\n        \"\"\"Log using info\"\"\"\n\n        self.logger.info(\"Policy:\")\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key, ast in self[sec].items():\n                self.logger.info(\"{} : {} : {}\".format(key, ast.value, ast.policy))",
          "docstring": "Log using info",
          "signature": "def print_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.clear_policy": {
          "code": "    def clear_policy(self):\n        \"\"\"clears all current policy.\"\"\"\n\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key in self[sec].keys():\n                self[sec][key].policy = []",
          "docstring": "clears all current policy.",
          "signature": "def clear_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/model/model.py": {
        "Model.sort_policies_by_priority": {
          "code": "    def sort_policies_by_priority(self):\n        for ptype, assertion in self[\"p\"].items():\n            for index, token in enumerate(assertion.tokens):\n                if token == f\"{ptype}_priority\":\n                    assertion.priority_index = index\n                    break\n\n            if assertion.priority_index == -1:\n                continue\n\n            assertion.policy = sorted(\n                assertion.policy,\n                key=lambda x: int(x[assertion.priority_index])\n                if x[assertion.priority_index].isdigit()\n                else x[assertion.priority_index],\n            )\n\n            for i, policy in enumerate(assertion.policy):\n                assertion.policy_map[\",\".join(policy)] = i\n\n        return None",
          "docstring": "",
          "signature": "def sort_policies_by_priority(self):",
          "type": "Method",
          "class_signature": "class Model(Policy):"
        },
        "Model.sort_policies_by_subject_hierarchy": {
          "code": "    def sort_policies_by_subject_hierarchy(self):\n        if self[\"e\"][\"e\"].value != \"subjectPriority(p_eft) || deny\":\n            return\n\n        sub_index = 0\n        domain_index = -1\n        for ptype, assertion in self[\"p\"].items():\n            for index, token in enumerate(assertion.tokens):\n                if token == \"{}_dom\".format(ptype):\n                    domain_index = index\n                    break\n\n            subject_hierarchy_map = self.get_subject_hierarchy_map(self[\"g\"][\"g\"].policy)\n\n            def compare_policy(policy):\n                domain = DEFAULT_DOMAIN\n                if domain_index != -1:\n                    domain = policy[domain_index]\n                name = self.get_name_with_domain(domain, policy[sub_index])\n                return subject_hierarchy_map.get(name, 0)\n\n            assertion.policy = sorted(assertion.policy, key=compare_policy)\n            for i, policy in enumerate(assertion.policy):\n                assertion.policy_map[\",\".join(policy)] = i",
          "docstring": "",
          "signature": "def sort_policies_by_subject_hierarchy(self):",
          "type": "Method",
          "class_signature": "class Model(Policy):"
        }
      },
      "casbin/persist/adapters/filtered_file_adapter.py": {
        "FilteredFileAdapter.load_policy": {
          "code": "    def load_policy(self, model):\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError('invalid file path, file path cannot be empty')\n        self.filtered = False\n        self._load_policy_file(model)",
          "docstring": "",
          "signature": "def load_policy(self, model):",
          "type": "Method",
          "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
        }
      },
      "casbin/rbac/default_role_manager/role_manager.py": {
        "DomainManager.clear": {
          "code": "    def clear(self):\n        super().clear()\n        self.rm_map = dict()",
          "docstring": "",
          "signature": "def clear(self):",
          "type": "Method",
          "class_signature": "class DomainManager(DomainManagerBase):"
        }
      }
    },
    "casbin/management_enforcer.py:ManagementEnforcer:has_policy": {
      "casbin/management_enforcer.py": {
        "ManagementEnforcer.has_named_policy": {
          "code": "    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('p', ptype, str_slice)\n        return self.model.has_policy('p', ptype, list(params))",
          "docstring": "determines whether a named authorization rule exists.",
          "signature": "def has_named_policy(self, ptype, *params):",
          "type": "Method",
          "class_signature": "class ManagementEnforcer(InternalEnforcer):"
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
      "casbin/model/model.py": {
        "Model.sort_policies_by_priority": {
          "code": "    def sort_policies_by_priority(self):\n        for ptype, assertion in self[\"p\"].items():\n            for index, token in enumerate(assertion.tokens):\n                if token == f\"{ptype}_priority\":\n                    assertion.priority_index = index\n                    break\n\n            if assertion.priority_index == -1:\n                continue\n\n            assertion.policy = sorted(\n                assertion.policy,\n                key=lambda x: int(x[assertion.priority_index])\n                if x[assertion.priority_index].isdigit()\n                else x[assertion.priority_index],\n            )\n\n            for i, policy in enumerate(assertion.policy):\n                assertion.policy_map[\",\".join(policy)] = i\n\n        return None",
          "docstring": "",
          "signature": "def sort_policies_by_priority(self):",
          "type": "Method",
          "class_signature": "class Model(Policy):"
        }
      },
      "casbin/core_enforcer.py": {
        "CoreEnforcer.init_rm_map": {
          "code": "    def init_rm_map(self):\n        if 'g' in self.model.keys():\n            for ptype in self.model['g']:\n                assertion = self.model['g'][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm",
          "docstring": "",
          "signature": "def init_rm_map(self):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        },
        "CoreEnforcer.build_role_links": {
          "code": "    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        for rm in self.rm_map.values():\n            rm.clear()\n        self.model.build_role_links(self.rm_map)",
          "docstring": "manually rebuild the role inheritance relations.",
          "signature": "def build_role_links(self):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "casbin/model/policy.py": {
        "Policy.print_policy": {
          "code": "    def print_policy(self):\n        \"\"\"Log using info\"\"\"\n\n        self.logger.info(\"Policy:\")\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key, ast in self[sec].items():\n                self.logger.info(\"{} : {} : {}\".format(key, ast.value, ast.policy))",
          "docstring": "Log using info",
          "signature": "def print_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        },
        "Policy.clear_policy": {
          "code": "    def clear_policy(self):\n        \"\"\"clears all current policy.\"\"\"\n\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key in self[sec].keys():\n                self[sec][key].policy = []",
          "docstring": "clears all current policy.",
          "signature": "def clear_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      },
      "casbin/persist/adapters/filtered_file_adapter.py": {
        "FilteredFileAdapter.load_filtered_policy": {
          "code": "    def load_filtered_policy(self, model, filter):\n        if filter == None:\n            return self.load_policy(model)\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError('invalid file path, file path cannot be empty')\n        try:\n            filter_value = [filter.__dict__['P']] + [filter.__dict__['G']]\n        except:\n            raise RuntimeError('invalid filter type')\n        self.load_filtered_policy_file(model, filter_value, persist.load_policy_line)\n        self.filtered = True",
          "docstring": "",
          "signature": "def load_filtered_policy(self, model, filter):",
          "type": "Method",
          "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:load_increment_filtered_policy": {
      "casbin/core_enforcer.py": {
        "CoreEnforcer.build_role_links": {
          "code": "    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        for rm in self.rm_map.values():\n            rm.clear()\n        self.model.build_role_links(self.rm_map)",
          "docstring": "manually rebuild the role inheritance relations.",
          "signature": "def build_role_links(self):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      },
      "casbin/persist/adapters/filtered_file_adapter.py": {
        "FilteredFileAdapter.load_filtered_policy": {
          "code": "    def load_filtered_policy(self, model, filter):\n        if filter == None:\n            return self.load_policy(model)\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError('invalid file path, file path cannot be empty')\n        try:\n            filter_value = [filter.__dict__['P']] + [filter.__dict__['G']]\n        except:\n            raise RuntimeError('invalid filter type')\n        self.load_filtered_policy_file(model, filter_value, persist.load_policy_line)\n        self.filtered = True",
          "docstring": "",
          "signature": "def load_filtered_policy(self, model, filter):",
          "type": "Method",
          "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
        }
      },
      "casbin/model/policy.py": {
        "Policy.print_policy": {
          "code": "    def print_policy(self):\n        \"\"\"Log using info\"\"\"\n\n        self.logger.info(\"Policy:\")\n        for sec in [\"p\", \"g\"]:\n            if sec not in self.keys():\n                continue\n\n            for key, ast in self[sec].items():\n                self.logger.info(\"{} : {} : {}\".format(key, ast.value, ast.policy))",
          "docstring": "Log using info",
          "signature": "def print_policy(self):",
          "type": "Method",
          "class_signature": "class Policy:"
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
      "casbin/persist/adapters/filtered_file_adapter.py": {
        "FilteredFileAdapter.is_filtered": {
          "code": "    def is_filtered(self):\n        return self.filtered",
          "docstring": "",
          "signature": "def is_filtered(self):",
          "type": "Method",
          "class_signature": "class FilteredFileAdapter(FileAdapter, FilteredAdapter):"
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:save_policy": {}
  },
  "call_tree": {
    "tests/test_filter.py:TestFilteredFileAdapter:test_append_filtered_policy": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:Model": {},
            "casbin/persist/adapter.py:Adapter:Adapter": {},
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_policy": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
        },
        "casbin/model/policy.py:Policy:build_role_links": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/model/assertion.py:Assertion:build_role_links": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
              }
            },
            "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:has_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:has_named_policy": {
          "casbin/model/policy.py:Policy:has_policy": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {}
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy_file": {
            "casbin/persist/adapters/filtered_file_adapter.py:filter_line": {
              "casbin/persist/adapters/filtered_file_adapter.py:filter_words": {}
            },
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          }
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:build_role_links": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          },
          "casbin/model/policy.py:Policy:build_role_links": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_role_links": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                  }
                },
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
            }
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_increment_filtered_policy": {
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy_file": {
            "casbin/persist/adapters/filtered_file_adapter.py:filter_line": {
              "casbin/persist/adapters/filtered_file_adapter.py:filter_words": {}
            },
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:build_role_links": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          },
          "casbin/model/policy.py:Policy:build_role_links": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_role_links": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                  }
                },
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
            }
          }
        }
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_filtered_adapter_empty_filepath": {
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "tests/test_enforcer.py:get_examples": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_policy": {}
        }
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_filtered_adapter_invalid_filepath": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_policy": {}
        }
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_filtered_policy_empty_filter": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_policy": {
            "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
              "casbin/persist/adapter.py:load_policy_line": {}
            }
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          }
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:build_role_links": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          },
          "casbin/model/policy.py:Policy:build_role_links": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_role_links": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                  }
                },
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
            }
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:save_policy": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:_save_policy_file": {}
        }
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_filtered_policy_invalid_filter": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {}
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_init_filtered_adapter": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/management_enforcer.py:ManagementEnforcer:has_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:has_named_policy": {
          "casbin/model/policy.py:Policy:has_policy": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {}
          }
        }
      }
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_load_filtered_policy": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:__init__": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
          "casbin/core_enforcer.py:CoreEnforcer:new_model": {
            "casbin/model/policy.py:Policy:__init__": {},
            "casbin/model/model.py:Model:load_model": {
              "casbin/config/config.py:Config:new_config": {
                "casbin/config/config.py:Config:__init__": {},
                "casbin/config/config.py:Config:_parse": {
                  "casbin/config/config.py:Config:_parse_buffer": {
                    "casbin/config/config.py:Config:_write": {
                      "casbin/config/config.py:Config:add_config": {}
                    }
                  }
                }
              },
              "casbin/model/model.py:Model:_load_section": {
                "casbin/model/model.py:Model:_get_key_suffix": {},
                "casbin/model/model.py:Model:_load_assertion": {
                  "casbin/config/config.py:Config:get": {},
                  "casbin/model/model.py:Model:add_def": {
                    "casbin/model/assertion.py:Assertion:__init__": {},
                    "casbin/model/policy.py:Policy:keys": {},
                    "casbin/model/policy.py:Policy:__setitem__": {},
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/util/util.py:escape_assertion": {},
                    "casbin/util/util.py:remove_comments": {},
                    "casbin/model/model.py:Model:get_params_token": {}
                  }
                }
              }
            }
          },
          "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
            "casbin/model/model.py:Model:print_model": {
              "casbin/model/policy.py:Policy:items": {}
            },
            "casbin/model/function.py:FunctionMap:load_function_map": {
              "casbin/model/function.py:FunctionMap:__init__": {},
              "casbin/model/function.py:FunctionMap:add_function": {}
            },
            "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
              "casbin/model/policy.py:Policy:__getitem__": {},
              "casbin/effect/__init__.py:get_effector": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                "casbin/model/policy.py:Policy:keys": {},
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
              "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_policy": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
        },
        "casbin/model/policy.py:Policy:build_role_links": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/model/assertion.py:Assertion:build_role_links": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
              }
            },
            "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
          }
        }
      },
      "casbin/management_enforcer.py:ManagementEnforcer:has_policy": {
        "casbin/management_enforcer.py:ManagementEnforcer:has_named_policy": {
          "casbin/model/policy.py:Policy:has_policy": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {}
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:load_filtered_policy_file": {
            "casbin/persist/adapters/filtered_file_adapter.py:filter_line": {
              "casbin/persist/adapters/filtered_file_adapter.py:filter_words": {}
            },
            "casbin/persist/adapter.py:load_policy_line": {}
          }
        },
        "casbin/model/model.py:Model:sort_policies_by_priority": {
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          }
        },
        "casbin/model/policy.py:Policy:print_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:build_role_links": {
          "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
            "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
          },
          "casbin/model/policy.py:Policy:build_role_links": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {},
            "casbin/model/assertion.py:Assertion:build_role_links": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_links": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                  }
                },
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {}
                }
              },
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
            }
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:save_policy": {
        "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {
          "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:is_filtered": {}
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:get_adapter": {},
      "casbin/core_enforcer.py:CoreEnforcer:get_model": {},
      "casbin/persist/adapters/filtered_file_adapter.py:FilteredFileAdapter:save_policy": {}
    },
    "tests/test_filter.py:TestFilteredFileAdapter:test_unsupported_filtered_policy": {
      "tests/test_enforcer.py:get_examples": {},
      "casbin/core_enforcer.py:CoreEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
          "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
          "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
            "casbin/core_enforcer.py:CoreEnforcer:new_model": {
              "casbin/model/policy.py:Policy:__init__": {},
              "casbin/model/model.py:Model:load_model": {
                "casbin/config/config.py:Config:new_config": {
                  "casbin/config/config.py:Config:__init__": {},
                  "casbin/config/config.py:Config:_parse": {
                    "casbin/config/config.py:Config:_parse_buffer": {
                      "casbin/config/config.py:Config:_write": {}
                    }
                  }
                },
                "casbin/model/model.py:Model:_load_section": {
                  "casbin/model/model.py:Model:_get_key_suffix": {},
                  "casbin/model/model.py:Model:_load_assertion": {
                    "casbin/config/config.py:Config:get": {},
                    "casbin/model/model.py:Model:add_def": {
                      "casbin/model/assertion.py:Assertion:__init__": {},
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__setitem__": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/util/util.py:escape_assertion": {},
                      "casbin/util/util.py:remove_comments": {},
                      "casbin/model/model.py:Model:get_params_token": {}
                    }
                  }
                }
              }
            },
            "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
              "casbin/model/model.py:Model:print_model": {
                "casbin/model/policy.py:Policy:items": {}
              },
              "casbin/model/function.py:FunctionMap:load_function_map": {
                "casbin/model/function.py:FunctionMap:__init__": {},
                "casbin/model/function.py:FunctionMap:add_function": {}
              },
              "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                "casbin/model/policy.py:Policy:__getitem__": {},
                "casbin/effect/__init__.py:get_effector": {},
                "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                  "casbin/model/policy.py:Policy:keys": {},
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                  }
                }
              },
              "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
              "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                "casbin/model/policy.py:Policy:clear_policy": {
                  "casbin/model/policy.py:Policy:keys": {},
                  "casbin/model/policy.py:Policy:__getitem__": {}
                },
                "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                  "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
                    "casbin/persist/adapter.py:load_policy_line": {}
                  }
                },
                "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                  "casbin/model/policy.py:Policy:__getitem__": {}
                },
                "casbin/model/model.py:Model:sort_policies_by_priority": {
                  "casbin/model/policy.py:Policy:__getitem__": {}
                },
                "casbin/model/policy.py:Policy:print_policy": {
                  "casbin/model/policy.py:Policy:keys": {},
                  "casbin/model/policy.py:Policy:__getitem__": {}
                },
                "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
                },
                "casbin/model/policy.py:Policy:build_role_links": {
                  "casbin/model/policy.py:Policy:keys": {},
                  "casbin/model/policy.py:Policy:__getitem__": {},
                  "casbin/model/assertion.py:Assertion:build_role_links": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:add_link": {},
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_affected_role_managers": {}
                    },
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
                  }
                }
              }
            }
          }
        },
        "casbin/util/log.py:disabled_logging": {}
      },
      "casbin/core_enforcer.py:CoreEnforcer:load_filtered_policy": {
        "casbin/model/policy.py:Policy:clear_policy": {
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {}
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_filter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u251c\u2500\u2500 core_enforcer.py\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.__init__\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.get_adapter\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.get_model\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.is_filtered\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.load_filtered_policy\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.load_increment_filtered_policy\n    \u2502   \u251c\u2500\u2500 CoreEnforcer.load_policy\n    \u2502   \u2514\u2500\u2500 CoreEnforcer.save_policy\n    \u251c\u2500\u2500 management_enforcer.py\n    \u2502   \u2514\u2500\u2500 ManagementEnforcer.has_policy\n    \u2514\u2500\u2500 persist/\n        \u2514\u2500\u2500 adapters/\n            \u2514\u2500\u2500 filtered_file_adapter.py\n                \u251c\u2500\u2500 FilteredFileAdapter.__init__\n                \u2514\u2500\u2500 FilteredFileAdapter.save_policy\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates flexible and filtered policy management for role-based access control (RBAC) using the Casbin authorization library. It extends Casbin's capabilities by integrating a `FilteredFileAdapter`, allowing developers to load and manage filtered data from policy files based on predefined criteria, such as specific domains or roles. The module ensures precision in policy enforcement by supporting dynamic filtering, incremental policy loading, and validation of policies against a defined model while preserving Casbin's core functionality. It solves the problem of efficiently handling large or segmented policy datasets, enabling users to focus on relevant subsets of policies without impacting system performance or operational accuracy.\n\n## FILE 1: casbin/core_enforcer.py\n\n- CLASS METHOD: CoreEnforcer.load_increment_filtered_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def load_increment_filtered_policy(self, filter):\n  - DOCSTRING: \n```python\n\"\"\"\nLoadIncrementalFilteredPolicy appends a filtered policy from the adapter to the current model of the CoreEnforcer instance. It checks if the current adapter supports filtered policies; if not, it raises a ValueError. After loading the policy, it prints the current policies and optionally rebuilds role links if auto-building is enabled.\n\nParameters:\n- filter: The filter criteria used to load a subset of the policy.\n\nReturns:\n- None\n\nSide Effects:\n- May modify the internal policy state of the enforcer by appending new rules.\n- Rebuilds role links if the `auto_build_role_links` attribute is set to True.\n\nDependencies:\n- This method relies on the `adapter` attribute, which must implement filtered policy loading, and the `model` attribute to provide the necessary policy structure. The `auto_build_role_links` boolean flag controls whether role links are rebuilt after loading the policy.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.get_model\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def get_model(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the current model associated with the CoreEnforcer instance.\n\nReturns:\n    Model: The current model (an instance of the Model class) that is used for enforcing access control policies.\n\nThis method provides access to the internal model of the enforcer, which defines the structure and rules for authorization policies. It is essential for retrieving and examining the configured policies and their relationships within the enforcer. This method interacts with the `self.model` attribute, which is initialized when the CoreEnforcer is set up with a model and an adapter.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.load_filtered_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def load_filtered_policy(self, filter):\n  - DOCSTRING: \n```python\n\"\"\"\nReloads a filtered policy from the file or database into the current model of the CoreEnforcer. This method clears the existing policy, ensuring that only the specified filtered policy is loaded. \n\nParameters:\n- filter: The filter criteria used to limit the loaded policy rules.\n\nRaises:\n- ValueError: If the adapter does not support filtered policies (i.e., it lacks the `is_filtered` attribute). \n\nSide Effects:\n- The existing policy in the model is cleared before loading the new filtered policy.\n- The loaded policy is sorted by priority.\n- The role manager map is initialized based on the loaded policies.\n- If `auto_build_role_links` is enabled, role inheritance relations are rebuilt based on the loaded policy. \n\nThis method interacts with the `adapter` to perform the loading of the filtered policy, and utilizes the `model` attribute to manage the current policy state within the enforcer. Additionally, it relies on these constants defined in the CoreEnforcer class:\n- `model`: Represents the current model's structure.\n- `adapter`: Handles data persistence and policy retrieval.\n- `auto_build_role_links`: A flag that indicates whether role inheritance should be automatically managed after policy changes.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.__init__\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def __init__(self, model=None, adapter=None, enable_log=False):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a CoreEnforcer instance, defining the primary functionality of an authorization enforcer in the Casbin framework. \n\nParameters:\n- model: Either a string representing the path to the model file or a Model object. Used to define the access control model.\n- adapter: Can be a string indicating the path to the policy file or an Adapter object, which interfaces with the data storage for policies.\n- enable_log: A boolean that, if True, enables logging for the enforcer's operations.\n\nRaises:\n- RuntimeError: If the parameters are invalid, specifically if a string adapter is provided when the model is not also a string.\n\nSide Effects:\n- Configures logging based on the enable_log parameter, affecting how information and errors are logged during operations.\n- Initializes various internal states and prepares the enforcer for policy management and enforcement based on the provided model and adapter.\n\nThis method relies on helper methods such as init_with_file, init_with_adapter, and init_with_model_and_adapter to appropriately structure the enforcer based on the provided parameters.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.is_filtered\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def is_filtered(self):\n  - DOCSTRING: \n```python\n\"\"\"\nreturns true if the loaded policy has been filtered.\n\nThis method checks if the current adapter, which is expected to handle policy persistence, has support for filtering. It verifies this by checking if the method `is_filtered` exists on the adapter and then calls it. The `adapter` is an instance of the `Adapter` class, which is initialized during the `CoreEnforcer` setup, either with a specific adapter type or a file adapter. This method is essential for determining if the enforcer is operating in filtered mode, which affects how policies are loaded and enforced.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.get_adapter\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def get_adapter(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the current policy adapter being used by the CoreEnforcer instance.\n\nThis adapter is responsible for loading, saving, and manipulating policy data. It is\nset during the initialization of the CoreEnforcer and can be updated or replaced\nusing the `set_adapter` method. This method does not take any parameters.\n\nReturns:\n    Adapter: The current adapter for the policy, which must implement the Adapter interface.\n\nNotes:\n    The `adapter` instance variable is expected to be initialized during the \n    enforcer's setup with either a database adapter or a file adapter, allowing \n    the enforcer to read and write policies as required by the application.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.load_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def load_policy(self):\n  - DOCSTRING: \n```python\n\"\"\"\nreloads the policy from the configured adapter into the current model. It clears the existing policy in the model and attempts to load a new policy using the adapter's load_policy method. \n\nIf the loading is successful, it sorts the policies by subject hierarchy and priority. If auto-build role links is enabled, it clears the existing role manager links and rebuilds them based on the newly loaded policies.\n\nThis method interacts with the `adapter` attribute for loading the policy and uses the `rm_map` and `cond_rm_map` attributes to manage role inheritance.\n\nRaises:\n    Exception: If an error occurs during policy loading, or if the loaded model requires rebuilding role links but cannot do so.\n\nSide Effects:\n    The current model's policy is modified. Role links may be rebuilt if configured.\n\nDependencies:\n    - Requires an initialized adapter that implements the load_policy method.\n    - Interacts with Class attributes: `model`, `adapter`, `rm_map`, `cond_rm_map`, `auto_build_role_links`.\n\"\"\"\n```\n\n- CLASS METHOD: CoreEnforcer.save_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def save_policy(self):\n  - DOCSTRING: \n```python\n\"\"\"\nSaves the current policy to the adapter. This method first checks if the loaded policy has been filtered; if so, it raises an error as filtered policies cannot be saved. If the policy is valid, it uses the adapter's save_policy method to persist the model. If a watcher is set, it invokes an update method to notify the watcher of the changes. \n\nRaises:\n    RuntimeError: If attempting to save a filtered policy.\n\nDependencies:\n    - `self.adapter`: An instance of an adapter (must implement save_policy) responsible for saving policy data.\n    - `self.model`: The current policy model being managed, which contains the policy information. \n    - `self.watcher`: An optional observer that can be notified after policy changes, enhancing dynamic updates.\n\"\"\"\n```\n\n## FILE 2: casbin/persist/adapters/filtered_file_adapter.py\n\n- CLASS METHOD: FilteredFileAdapter.__init__\n  - CLASS SIGNATURE: class FilteredFileAdapter(FileAdapter, FilteredAdapter):\n  - SIGNATURE: def __init__(self, file_path):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the FilteredFileAdapter class, which is a combination of FileAdapter and FilteredAdapter, designed for managing policy rules with filtering capabilities.\n\nParameters:\n- file_path (str): The file path to the policy rules file. This path is mandatory for loading policies.\n\nAttributes set during initialization:\n- filtered (bool): Set to True upon initialization, indicating that this adapter is configured to handle filtered policies.\n- _file_path (str): Stores the provided file path for subsequent policy loading operations.\n\nThis constructor does not return any value. It sets up the object to ensure it can load and manage policy rules while allowing for filtering according to specified conditions. The `filtered` attribute interacts with methods like `load_filtered_policy` and `save_policy` to enforce rules on the operations that can be performed on the policies.\n\"\"\"\n```\n\n- CLASS METHOD: FilteredFileAdapter.save_policy\n  - CLASS SIGNATURE: class FilteredFileAdapter(FileAdapter, FilteredAdapter):\n  - SIGNATURE: def save_policy(self, model):\n  - DOCSTRING: \n```python\n\"\"\"\nSaves the current policy to the file specified by _file_path. \n\nThis method raises a RuntimeError if the adapter's current state is filtered, meaning it cannot save a filtered policy. If the state is valid, it calls the _save_policy_file method, which handles the actual saving process using the provided model. \n\nParameters:\n- model: An instance representing the policy model that defines how the policy is structured and saved.\n\nRaises:\n- RuntimeError: If the current policy is filtered and cannot be saved.\n\nDependencies:\n- The method relies on the _file_path attribute, which is set during the initialization of the FilteredFileAdapter class. This attribute specifies where the policy will be saved.\n\"\"\"\n```\n\n## FILE 3: casbin/management_enforcer.py\n\n- CLASS METHOD: ManagementEnforcer.has_policy\n  - CLASS SIGNATURE: class ManagementEnforcer(InternalEnforcer):\n  - SIGNATURE: def has_policy(self, *params):\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether a specified authorization rule exists in the current policy.\n\nParameters:\n*params: A variable number of parameters that make up the rule to check. If a single list is passed as a parameter, it is treated as the rule.\n\nReturns:\nbool: True if the specified rule exists in the policy; otherwise, False.\n\nThis method delegates the actual check to `has_named_policy` using the default policy type \"p\". The \"p\" type refers to the policy rules managed by this instance of `ManagementEnforcer`, which inherits from `InternalEnforcer` and has access to a model where policies are defined.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/core_enforcer.py": "import copy\nimport logging\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n    model_path = ''\n    model = None\n    fm = None\n    eft = None\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n        if not isinstance(m, Model) or (adapter is not None and (not isinstance(adapter, Adapter))):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        self.adapter = adapter\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n        self._initialize()\n        if self.adapter and (not self.is_filtered()):\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model['e']['e'].value)\n        self.watcher = None\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path='', text=''):\n        \"\"\"creates a model.\"\"\"\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n        self.adapter = adapter\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n        self.watcher = watcher\n        pass\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map['g']\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError('ptype not found')\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map['g'] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n        self.model.clear_policy()\n\n    def init_rm_map(self):\n        if 'g' in self.model.keys():\n            for ptype in self.model['g']:\n                assertion = self.model['g'][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"controls whether to save a policy rule automatically notify the watcher when it is added or removed.\"\"\"\n        self.auto_notify_watcher = auto_notify_watcher\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        for rm in self.rm_map.values():\n            rm.clear()\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(rtype='r' + suffix, ptype='p' + suffix, etype='e' + suffix, mtype='m' + suffix)\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        rtype = 'r'\n        ptype = 'p'\n        etype = 'e'\n        mtype = 'm'\n        if not self.enabled:\n            return [True, []]\n        functions = self.fm.get_functions()\n        if 'g' in self.model.keys():\n            for key, ast in self.model['g'].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n        if 'm' not in self.model.keys():\n            raise RuntimeError('model is undefined')\n        if 'm' not in self.model['m'].keys():\n            raise RuntimeError('model is undefined')\n        r_tokens = self.model['r'][rtype].tokens\n        p_tokens = self.model['p'][ptype].tokens\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError('invalid request size')\n        exp_string = self.model['m'][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n        policy_effects = set()\n        r_parameters = dict(zip(r_tokens, rvals))\n        policy_len = len(self.model['p'][ptype].policy)\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model['p'][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError('invalid policy size')\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n                result = expression.eval(parameters)\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError('matcher result should be bool, int or float')\n                p_eft_key = ptype + '_eft'\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if 'allow' == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif 'deny' == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n        else:\n            if exp_has_eval:\n                raise RuntimeError('please make sure rule exists in policy when using eval() in matcher')\n            parameters = r_parameters.copy()\n            for token in self.model['p'][ptype].tokens:\n                parameters[token] = ''\n            result = expression.eval(parameters)\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n        req_str = 'Request: '\n        req_str = req_str + ', '.join([str(v) for v in rvals])\n        req_str = req_str + ' ---> %s' % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            self.logger.warning(req_str)\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model['p'][ptype].policy[explain_index]\n        return (result, explain_rule)\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace('&&', 'and')\n        expr = expr.replace('||', 'or')\n        expr = expr.replace('!', 'not')\n        return SimpleEval(expr, functions)",
    "casbin/persist/adapters/filtered_file_adapter.py": "import os\nfrom casbin import persist\nfrom .file_adapter import FileAdapter\nfrom ..adapter_filtered import FilteredAdapter\n\nclass Filter:\n    P = []\n    G = []\n\nclass FilteredFileAdapter(FileAdapter, FilteredAdapter):\n    filtered = False\n    _file_path = ''\n    filter = Filter()\n\n    def load_policy(self, model):\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError('invalid file path, file path cannot be empty')\n        self.filtered = False\n        self._load_policy_file(model)\n\n    def load_filtered_policy(self, model, filter):\n        if filter == None:\n            return self.load_policy(model)\n        if not os.path.isfile(self._file_path):\n            raise RuntimeError('invalid file path, file path cannot be empty')\n        try:\n            filter_value = [filter.__dict__['P']] + [filter.__dict__['G']]\n        except:\n            raise RuntimeError('invalid filter type')\n        self.load_filtered_policy_file(model, filter_value, persist.load_policy_line)\n        self.filtered = True\n\n    def load_filtered_policy_file(self, model, filter, hanlder):\n        with open(self._file_path, 'rb') as file:\n            while True:\n                line = file.readline()\n                line = line.decode().strip()\n                if line == '\\n':\n                    continue\n                if not line:\n                    break\n                if filter_line(line, filter):\n                    continue\n                hanlder(line, model)\n\n    def is_filtered(self):\n        return self.filtered\n\ndef filter_line(line, filter):\n    if filter == None:\n        return False\n    p = line.split(',')\n    if len(p) == 0:\n        return True\n    filter_slice = []\n    if p[0].strip() == 'p':\n        filter_slice = filter[0]\n    elif p[0].strip() == 'g':\n        filter_slice = filter[1]\n    return filter_words(p, filter_slice)\n\ndef filter_words(line, filter):\n    if len(line) < len(filter) + 1:\n        return True\n    skip_line = False\n    for i, v in enumerate(filter):\n        if len(v) > 0 and v.strip() != line[i + 1].strip():\n            skip_line = True\n            break\n    return skip_line",
    "casbin/management_enforcer.py": "from casbin.internal_enforcer import InternalEnforcer\nfrom casbin.model.policy_op import PolicyOp\nfrom casbin.constant.constants import ACTION_INDEX, SUBJECT_INDEX, OBJECT_INDEX\n\nclass ManagementEnforcer(InternalEnforcer):\n    \"\"\"\n    ManagementEnforcer = InternalEnforcer + Management API.\n    \"\"\"\n\n    def get_all_subjects(self):\n        \"\"\"gets the list of subjects that show up in the current policy.\"\"\"\n        return self.get_all_named_subjects('p')\n\n    def get_all_named_subjects(self, ptype):\n        \"\"\"gets the list of subjects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, SUBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_objects(self):\n        \"\"\"gets the list of objects that show up in the current policy.\"\"\"\n        return self.get_all_named_objects('p')\n\n    def get_all_named_objects(self, ptype):\n        \"\"\"gets the list of objects that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, OBJECT_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_actions(self):\n        \"\"\"gets the list of actions that show up in the current policy.\"\"\"\n        return self.get_all_named_actions('p')\n\n    def get_all_named_actions(self, ptype):\n        \"\"\"gets the list of actions that show up in the current named policy.\"\"\"\n        field_index = self.model.get_field_index(ptype, ACTION_INDEX)\n        return self.model.get_values_for_field_in_policy('p', ptype, field_index)\n\n    def get_all_roles(self):\n        \"\"\"gets the list of roles that show up in the current named policy.\"\"\"\n        return self.get_all_named_roles('g')\n\n    def get_all_named_roles(self, ptype):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.model.get_values_for_field_in_policy('g', ptype, 1)\n\n    def get_policy(self):\n        \"\"\"gets all the authorization rules in the policy.\"\"\"\n        return self.get_named_policy('p')\n\n    def get_filtered_policy(self, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_policy('p', field_index, *field_values)\n\n    def get_named_policy(self, ptype):\n        \"\"\"gets all the authorization rules in the named policy.\"\"\"\n        return self.model.get_policy('p', ptype)\n\n    def get_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the authorization rules in the named policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('p', ptype, field_index, *field_values)\n\n    def get_grouping_policy(self):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.get_named_grouping_policy('g')\n\n    def get_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.get_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    def get_named_grouping_policy(self, ptype):\n        \"\"\"gets all the role inheritance rules in the policy.\"\"\"\n        return self.model.get_policy('g', ptype)\n\n    def get_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"gets all the role inheritance rules in the policy, field filters can be specified.\"\"\"\n        return self.model.get_filtered_policy('g', ptype, field_index, *field_values)\n\n    def has_named_policy(self, ptype, *params):\n        \"\"\"determines whether a named authorization rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('p', ptype, str_slice)\n        return self.model.has_policy('p', ptype, list(params))\n\n    def add_policy(self, *params):\n        \"\"\"adds an authorization rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_policy('p', *params)\n\n    def add_policies(self, rules):\n        \"\"\"adds authorization rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding rule by adding the new rule.\n        \"\"\"\n        return self.add_named_policies('p', rules)\n\n    def add_named_policy(self, ptype, *params):\n        \"\"\"adds an authorization rule to the current named policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy('p', ptype, str_slice)\n        else:\n            rule_added = self._add_policy('p', ptype, list(params))\n        return rule_added\n\n    def add_named_policies(self, ptype, rules):\n        \"\"\"adds authorization rules to the current named policy.\n\n        If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding by adding the new rule.\"\"\"\n        return self._add_policies('p', ptype, rules)\n\n    def update_policy(self, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current policy.\"\"\"\n        return self.update_named_policy('p', old_rule, new_rule)\n\n    def update_policies(self, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current policy.\"\"\"\n        return self.update_named_policies('p', old_rules, new_rules)\n\n    def update_named_policy(self, ptype, old_rule, new_rule):\n        \"\"\"updates an authorization rule from the current named policy.\"\"\"\n        return self._update_policy('p', ptype, old_rule, new_rule)\n\n    def update_named_policies(self, ptype, old_rules, new_rules):\n        \"\"\"updates authorization rules from the current named policy.\"\"\"\n        return self._update_policies('p', ptype, old_rules, new_rules)\n\n    def update_filtered_policies(self, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_policies deletes old rules and adds new rules.\"\"\"\n        return self.update_filtered_named_policies('p', new_rules, field_index, *field_values)\n\n    def update_filtered_named_policies(self, ptype, new_rules, field_index, *field_values):\n        \"\"\"update_filtered_named_policies deletes old rules and adds new rules.\"\"\"\n        return self._update_filtered_policies('p', ptype, new_rules, field_index, *field_values)\n\n    def remove_policy(self, *params):\n        \"\"\"removes an authorization rule from the current policy.\"\"\"\n        return self.remove_named_policy('p', *params)\n\n    def remove_policies(self, rules):\n        \"\"\"removes authorization rules from the current policy.\"\"\"\n        return self.remove_named_policies('p', rules)\n\n    def remove_filtered_policy(self, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_policy('p', field_index, *field_values)\n\n    def remove_named_policy(self, ptype, *params):\n        \"\"\"removes an authorization rule from the current named policy.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy('p', ptype, str_slice)\n        else:\n            rule_removed = self._remove_policy('p', ptype, list(params))\n        return rule_removed\n\n    def remove_named_policies(self, ptype, rules):\n        \"\"\"removes authorization rules from the current named policy.\"\"\"\n        return self._remove_policies('p', ptype, rules)\n\n    def remove_filtered_named_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes an authorization rule from the current named policy, field filters can be specified.\"\"\"\n        return self._remove_filtered_policy('p', ptype, field_index, *field_values)\n\n    def has_grouping_policy(self, *params):\n        \"\"\"determines whether a role inheritance rule exists.\"\"\"\n        return self.has_named_grouping_policy('g', *params)\n\n    def has_named_grouping_policy(self, ptype, *params):\n        \"\"\"determines whether a named role inheritance rule exists.\"\"\"\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            return self.model.has_policy('g', ptype, str_slice)\n        return self.model.has_policy('g', ptype, list(params))\n\n    def add_grouping_policy(self, *params):\n        \"\"\"adds a role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policy('g', *params)\n\n    def add_grouping_policies(self, rules):\n        \"\"\"adds role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\n        \"\"\"\n        return self.add_named_grouping_policies('g', rules)\n\n    def add_named_grouping_policy(self, ptype, *params):\n        \"\"\"adds a named role inheritance rule to the current policy.\n\n        If the rule already exists, the function returns false and the rule will not be added.\n        Otherwise the function returns true by adding the new rule.\n        \"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_added = self._add_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_added = self._add_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n            if ptype in self.cond_rm_map:\n                self.model.build_incremental_conditional_role_links(self.cond_rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rule_added\n\n    def add_named_grouping_policies(self, ptype, rules):\n        \"\"\"adds named role inheritance rules to the current policy.\n\n        If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n        Otherwise the function returns true for the corresponding policy rule by adding the new rule.\"\"\"\n        rules_added = self._add_policies('g', ptype, rules)\n        if self.auto_build_role_links:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_add, 'g', ptype, rules)\n        return rules_added\n\n    def remove_grouping_policy(self, *params):\n        \"\"\"removes a role inheritance rule from the current policy.\"\"\"\n        return self.remove_named_grouping_policy('g', *params)\n\n    def remove_grouping_policies(self, rules):\n        \"\"\"removes role inheritance rules from the current policy.\"\"\"\n        return self.remove_named_grouping_policies('g', rules)\n\n    def remove_filtered_grouping_policy(self, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current policy, field filters can be specified.\"\"\"\n        return self.remove_filtered_named_grouping_policy('g', field_index, *field_values)\n\n    def remove_named_grouping_policy(self, ptype, *params):\n        \"\"\"removes a role inheritance rule from the current named policy.\"\"\"\n        rules = []\n        if len(params) == 1 and isinstance(params[0], list):\n            str_slice = params[0]\n            rule_removed = self._remove_policy('g', ptype, str_slice)\n            rules.append(str_slice)\n        else:\n            rule_removed = self._remove_policy('g', ptype, list(params))\n            rules.append(list(params))\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rule_removed\n\n    def remove_named_grouping_policies(self, ptype, rules):\n        \"\"\"removes role inheritance rules from the current named policy.\"\"\"\n        rules_removed = self._remove_policies('g', ptype, rules)\n        if self.auto_build_role_links and rules_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rules)\n        return rules_removed\n\n    def remove_filtered_named_grouping_policy(self, ptype, field_index, *field_values):\n        \"\"\"removes a role inheritance rule from the current named policy, field filters can be specified.\"\"\"\n        rule_removed = self._remove_filtered_policy_returns_effects('g', ptype, field_index, *field_values)\n        if self.auto_build_role_links and rule_removed:\n            self.model.build_incremental_role_links(self.rm_map[ptype], PolicyOp.Policy_remove, 'g', ptype, rule_removed)\n        return rule_removed\n\n    def add_function(self, name, func):\n        \"\"\"adds a customized function.\"\"\"\n        self.fm.add_function(name, func)"
  }
}