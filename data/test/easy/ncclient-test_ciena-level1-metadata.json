{
  "dir_path": "/app/ncclient",
  "package_name": "ncclient",
  "sample_name": "ncclient-test_ciena",
  "src_dir": "ncclient/",
  "test_dir": "test/",
  "test_file": "modified_testcases/unit/devices/test_ciena.py",
  "test_code": "import unittest\nfrom ncclient.devices.ciena import *\nfrom ncclient.xml_ import *\n\n\nclass TestCienaDevice(unittest.TestCase):\n    \n    def setUp(self):\n        self.obj = CienaDeviceHandler({'name': 'ciena'})\n\n    def test_get_xml_base_namespace_dict(self):\n        expected = {None: BASE_NS_1_0}\n        self.assertDictEqual(expected, self.obj.get_xml_base_namespace_dict())\n\n    def test_get_xml_extra_prefix_kwargs(self):\n        expected = dict()\n        expected[\"nsmap\"] = self.obj.get_xml_base_namespace_dict()\n        self.assertDictEqual(expected, self.obj.get_xml_extra_prefix_kwargs())\n",
  "GT_file_code": {
    "ncclient/transport/errors.py": "# Copyright 2009 Shikhar Bhushan\n# Copyright 2014 Leonidas Poulopoulos\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#    http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError (TransportError):\n    pass\n",
    "ncclient/devices/ciena.py": "from .default import DefaultDeviceHandler\nfrom ncclient.xml_ import BASE_NS_1_0\n\n\nclass CienaDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Ciena handler for device specific information.\n    \"\"\"\n\n    def __init__(self, device_params):\n        super(CienaDeviceHandler, self).__init__(device_params)\n\n    def get_xml_base_namespace_dict(self):\n        return {None: BASE_NS_1_0}\n\n    def get_xml_extra_prefix_kwargs(self):\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {\"nsmap\": d}\n"
  },
  "GT_src_dict": {
    "ncclient/transport/errors.py": {},
    "ncclient/devices/ciena.py": {
      "CienaDeviceHandler.__init__": {
        "code": "    def __init__(self, device_params):\n        \"\"\"Initializes a CienaDeviceHandler instance with the given device parameters.\n\nParameters:\n    device_params (dict): A dictionary containing parameters specific to the device that this handler will manage.\n\nThis constructor calls the parent class's (__init__ method of DefaultDeviceHandler) constructor to initialize common device handling functionalities.\"\"\"\n        super(CienaDeviceHandler, self).__init__(device_params)",
        "docstring": "Initializes a CienaDeviceHandler instance with the given device parameters.\n\nParameters:\n    device_params (dict): A dictionary containing parameters specific to the device that this handler will manage.\n\nThis constructor calls the parent class's (__init__ method of DefaultDeviceHandler) constructor to initialize common device handling functionalities.",
        "signature": "def __init__(self, device_params):",
        "type": "Method",
        "class_signature": "class CienaDeviceHandler(DefaultDeviceHandler):"
      },
      "CienaDeviceHandler.get_xml_base_namespace_dict": {
        "code": "    def get_xml_base_namespace_dict(self):\n        \"\"\"Retrieve the XML base namespace dictionary for the Ciena device.\n\nThis method returns a dictionary that maps `None` to the constant `BASE_NS_1_0`, which represents the base namespace for XML version 1.0. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and defines the base namespace used in XML communication for devices managed by the CienaDeviceHandler.\n\nReturns:\n    dict: A dictionary containing the XML base namespace mapping.\"\"\"\n        return {None: BASE_NS_1_0}",
        "docstring": "Retrieve the XML base namespace dictionary for the Ciena device.\n\nThis method returns a dictionary that maps `None` to the constant `BASE_NS_1_0`, which represents the base namespace for XML version 1.0. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and defines the base namespace used in XML communication for devices managed by the CienaDeviceHandler.\n\nReturns:\n    dict: A dictionary containing the XML base namespace mapping.",
        "signature": "def get_xml_base_namespace_dict(self):",
        "type": "Method",
        "class_signature": "class CienaDeviceHandler(DefaultDeviceHandler):"
      },
      "CienaDeviceHandler.get_xml_extra_prefix_kwargs": {
        "code": "    def get_xml_extra_prefix_kwargs(self):\n        \"\"\"Returns a dictionary containing XML namespace mappings for use in device-specific XML requests. The method collects the base namespace from the `get_xml_base_namespace_dict` method, which returns a dictionary with the base namespace defined by `BASE_NS_1_0` from the `ncclient.xml_` module. The resulting dictionary is wrapped in another dictionary with the key `\"nsmap\"`, making it suitable for XML processing contexts where namespace mapping is required. This method is primarily used to construct XML payloads needed for communication with Ciena devices.\"\"\"\n        d = {}\n        d.update(self.get_xml_base_namespace_dict())\n        return {'nsmap': d}",
        "docstring": "Returns a dictionary containing XML namespace mappings for use in device-specific XML requests. The method collects the base namespace from the `get_xml_base_namespace_dict` method, which returns a dictionary with the base namespace defined by `BASE_NS_1_0` from the `ncclient.xml_` module. The resulting dictionary is wrapped in another dictionary with the key `\"nsmap\"`, making it suitable for XML processing contexts where namespace mapping is required. This method is primarily used to construct XML payloads needed for communication with Ciena devices.",
        "signature": "def get_xml_extra_prefix_kwargs(self):",
        "type": "Method",
        "class_signature": "class CienaDeviceHandler(DefaultDeviceHandler):"
      }
    }
  },
  "dependency_dict": {
    "ncclient/devices/ciena.py:CienaDeviceHandler:__init__": {
      "ncclient/devices/default.py": {
        "DefaultDeviceHandler.__init__": {
          "code": "    def __init__(self, device_params=None):\n        self.device_params = device_params\n        self.capabilities = []\n        # Turn all exempt errors into lower case, since we don't want those comparisons\n        # to be case sensitive later on. Sort them into exact match, wildcard start,\n        # wildcard end, and full wildcard categories, depending on whether they start\n        # and/or end with a '*'.\n        self._exempt_errors_exact_match = []\n        self._exempt_errors_startwith_wildcard_match = []\n        self._exempt_errors_endwith_wildcard_match = []\n        self._exempt_errors_full_wildcard_match = []\n        for i in xrange(len(self._EXEMPT_ERRORS)):\n            e = self._EXEMPT_ERRORS[i].lower()\n            if e.startswith(\"*\"):\n                if e.endswith(\"*\"):\n                    self._exempt_errors_full_wildcard_match.append(e[1:-1])\n                else:\n                    self._exempt_errors_startwith_wildcard_match.append(e[1:])\n            elif e.endswith(\"*\"):\n                self._exempt_errors_endwith_wildcard_match.append(e[:-1])\n            else:\n                self._exempt_errors_exact_match.append(e)",
          "docstring": "",
          "signature": "def __init__(self, device_params=None):",
          "type": "Method",
          "class_signature": "class DefaultDeviceHandler(object):"
        }
      }
    },
    "ncclient/devices/ciena.py:CienaDeviceHandler:get_xml_extra_prefix_kwargs": {}
  },
  "PRD": "# PROJECT NAME: ncclient-test_ciena\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 ncclient/\n    \u251c\u2500\u2500 devices/\n    \u2502   \u2514\u2500\u2500 ciena.py\n    \u2502       \u251c\u2500\u2500 CienaDeviceHandler.__init__\n    \u2502       \u251c\u2500\u2500 CienaDeviceHandler.get_xml_base_namespace_dict\n    \u2502       \u2514\u2500\u2500 CienaDeviceHandler.get_xml_extra_prefix_kwargs\n    \u2514\u2500\u2500 transport/\n        \u2514\u2500\u2500 errors.py\n            \u2514\u2500\u2500 SessionCloseError.SessionCloseError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and ensure the proper functioning of a handler for Ciena devices within an XML-based network configuration environment. It provides core functionality for managing XML namespace definitions and constructing namespace mappings required for communication with Ciena devices via NETCONF. By offering features such as retrieval of base namespace dictionaries and dynamically generated prefix keyword arguments, it simplifies the process of building and maintaining well-formed XML elements tailored to Ciena's device specifications. This module addresses the challenge of ensuring compatibility and correctness in managing XML namespaces, reducing the complexity for developers integrating with Ciena network devices.\n\n## FILE 1: ncclient/transport/errors.py\n\n## FILE 2: ncclient/devices/ciena.py\n\n- CLASS METHOD: CienaDeviceHandler.__init__\n  - CLASS SIGNATURE: class CienaDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def __init__(self, device_params):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a CienaDeviceHandler instance with the given device parameters.\n\nParameters:\n    device_params (dict): A dictionary containing parameters specific to the device that this handler will manage.\n\nThis constructor calls the parent class's (__init__ method of DefaultDeviceHandler) constructor to initialize common device handling functionalities.\n\"\"\"\n```\n\n- CLASS METHOD: CienaDeviceHandler.get_xml_extra_prefix_kwargs\n  - CLASS SIGNATURE: class CienaDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_extra_prefix_kwargs(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary containing XML namespace mappings for use in device-specific XML requests. The method collects the base namespace from the `get_xml_base_namespace_dict` method, which returns a dictionary with the base namespace defined by `BASE_NS_1_0` from the `ncclient.xml_` module. The resulting dictionary is wrapped in another dictionary with the key `\"nsmap\"`, making it suitable for XML processing contexts where namespace mapping is required. This method is primarily used to construct XML payloads needed for communication with Ciena devices.\n\"\"\"\n```\n\n- CLASS METHOD: CienaDeviceHandler.get_xml_base_namespace_dict\n  - CLASS SIGNATURE: class CienaDeviceHandler(DefaultDeviceHandler):\n  - SIGNATURE: def get_xml_base_namespace_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the XML base namespace dictionary for the Ciena device.\n\nThis method returns a dictionary that maps `None` to the constant `BASE_NS_1_0`, which represents the base namespace for XML version 1.0. The constant `BASE_NS_1_0` is imported from the `ncclient.xml_` module and defines the base namespace used in XML communication for devices managed by the CienaDeviceHandler.\n\nReturns:\n    dict: A dictionary containing the XML base namespace mapping.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "ncclient/transport/errors.py": "from ncclient import NCClientError\n\nclass TransportError(NCClientError):\n    pass\n\nclass SessionError(NCClientError):\n    pass\n\nclass AuthenticationError(TransportError):\n    pass\n\nclass PermissionError(TransportError):\n    pass\n\nclass SessionCloseError(TransportError):\n\n    def __init__(self, in_buf, out_buf=None):\n        msg = 'Unexpected session close'\n        if in_buf:\n            msg += '\\nIN_BUFFER: `%s`' % in_buf\n        if out_buf:\n            msg += ' OUT_BUFFER: `%s`' % out_buf\n        SSHError.__init__(self, msg)\n\nclass SSHError(TransportError):\n    pass\n\nclass SSHUnknownHostError(SSHError):\n\n    def __init__(self, host, fingerprint):\n        SSHError.__init__(self, 'Unknown host key [%s] for [%s]' % (fingerprint, host))\n        self.host = host\n        self.fingerprint = fingerprint\n\nclass NetconfFramingError(TransportError):\n    pass\n\nclass TLSError(TransportError):\n    pass\n\nclass UnixSocketError(TransportError):\n    pass",
    "ncclient/devices/ciena.py": "from .default import DefaultDeviceHandler\nfrom ncclient.xml_ import BASE_NS_1_0\n\nclass CienaDeviceHandler(DefaultDeviceHandler):\n    \"\"\"\n    Ciena handler for device specific information.\n    \"\"\""
  },
  "call_tree": {
    "modified_testcases/unit/devices/test_ciena.py:TestCienaDevice:setUp": {
      "ncclient/devices/ciena.py:CienaDeviceHandler:__init__": {
        "ncclient/devices/default.py:DefaultDeviceHandler:__init__": {}
      }
    },
    "modified_testcases/unit/devices/test_ciena.py:TestCienaDevice:test_get_xml_base_namespace_dict": {
      "ncclient/devices/ciena.py:CienaDeviceHandler:get_xml_base_namespace_dict": {}
    },
    "modified_testcases/unit/devices/test_ciena.py:TestCienaDevice:test_get_xml_extra_prefix_kwargs": {
      "ncclient/devices/ciena.py:CienaDeviceHandler:get_xml_base_namespace_dict": {},
      "ncclient/devices/ciena.py:CienaDeviceHandler:get_xml_extra_prefix_kwargs": {
        "ncclient/devices/ciena.py:CienaDeviceHandler:get_xml_base_namespace_dict": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/test/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py3": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_receive_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/ncclient-image/ncclient/modified_testcases/unit/transport/test_ssh.py:TestSSH:test_run_send_py2": {
      "ncclient/transport/errors.py:SessionCloseError:SessionCloseError": {}
    }
  }
}