{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_currency",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "tests/test_currency.py",
  "test_code": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom decimal import Decimal\nfrom unittest import TestCase\n\nfrom num2words.currency import parse_currency_parts\n\n\nclass CurrencyTestCase(TestCase):\n    def test_parse_currency_parts(self):\n        # integer with cents\n        self.assertEqual(parse_currency_parts(101), (1, 1, False))\n        self.assertEqual(parse_currency_parts(-123), (1, 23, True))\n\n        # integer without cents\n        self.assertEqual(parse_currency_parts(101, is_int_with_cents=False),\n                         (101, 0, False))\n        self.assertEqual(parse_currency_parts(-123, is_int_with_cents=False),\n                         (123, 0, True))\n\n        # float\n        self.assertEqual(parse_currency_parts(1.01), (1, 1, False))\n        self.assertEqual(parse_currency_parts(-1.23), (1, 23, True))\n        self.assertEqual(parse_currency_parts(-1.2), (1, 20, True))\n        self.assertEqual(parse_currency_parts(0.004), (0, 0, False))\n        self.assertEqual(parse_currency_parts(0.005), (0, 1, False))\n        self.assertEqual(parse_currency_parts(0.006), (0, 1, False))\n        self.assertEqual(parse_currency_parts(0.0005), (0, 0, False))\n        self.assertEqual(parse_currency_parts(0.984), (0, 98, False))\n        self.assertEqual(parse_currency_parts(0.989), (0, 99, False))\n        self.assertEqual(parse_currency_parts(0.994), (0, 99, False))\n        self.assertEqual(parse_currency_parts(0.999), (1, 0, False))\n        # self.assertEqual(parse_currency_parts(0.985), (0, 99, False))\n        # self.assertEqual(parse_currency_parts(0.995), (1, 0, False))\n\n        # decimal\n        self.assertEqual(parse_currency_parts(Decimal(\"1.01\")), (1, 1, False))\n        self.assertEqual(parse_currency_parts(Decimal(\"-1.23\")), (1, 23, True))\n        self.assertEqual(parse_currency_parts(Decimal(\"-1.233\")),\n                         (1, 23, True))\n        self.assertEqual(parse_currency_parts(Decimal(\"-1.989\")),\n                         (1, 99, True))\n\n        # string\n        self.assertEqual(parse_currency_parts(\"1.01\"), (1, 1, False))\n        self.assertEqual(parse_currency_parts(\"-1.23\"), (1, 23, True))\n        self.assertEqual(parse_currency_parts(\"-1.2\"), (1, 20, True))\n        self.assertEqual(parse_currency_parts(\"1\"), (1, 0, False))\n",
  "GT_file_code": {
    "num2words/currency.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import division\n\nfrom decimal import ROUND_HALF_UP, Decimal\n\n\ndef parse_currency_parts(value, is_int_with_cents=True):\n    if isinstance(value, int):\n        if is_int_with_cents:\n            # assume cents if value is integer\n            negative = value < 0\n            value = abs(value)\n            integer, cents = divmod(value, 100)\n        else:\n            negative = value < 0\n            integer, cents = abs(value), 0\n\n    else:\n        value = Decimal(value)\n        value = value.quantize(\n            Decimal('.01'),\n            rounding=ROUND_HALF_UP\n        )\n        negative = value < 0\n        value = abs(value)\n        integer, fraction = divmod(value, 1)\n        integer = int(integer)\n        cents = int(fraction * 100)\n\n    return integer, cents, negative\n\n\ndef prefix_currency(prefix, base):\n    return tuple(\"%s %s\" % (prefix, i) for i in base)\n"
  },
  "GT_src_dict": {
    "num2words/currency.py": {
      "parse_currency_parts": {
        "code": "def parse_currency_parts(value, is_int_with_cents=True):\n    \"\"\"Parses a currency value into its integer and cents components, along with a sign indicator.\n\nParameters:\n    value (int or str or Decimal): The value to parse, which can be an integer representing cents or a string/Decimal to represent currency.\n    is_int_with_cents (bool): A flag to determine whether an integer value should be treated as having cents (default is True).\n\nReturns:\n    tuple: A tuple containing three elements:\n        - integer (int): The integer part of the currency value.\n        - cents (int): The fractional part of the currency value in cents.\n        - negative (bool): A boolean indicating if the original value was negative.\n\nThis function uses the `Decimal` class from the `decimal` module to ensure accurate monetary calculations, and employs the `ROUND_HALF_UP` constant for rounding behavior when quantizing the value to two decimal places.\"\"\"\n    if isinstance(value, int):\n        if is_int_with_cents:\n            negative = value < 0\n            value = abs(value)\n            integer, cents = divmod(value, 100)\n        else:\n            negative = value < 0\n            integer, cents = (abs(value), 0)\n    else:\n        value = Decimal(value)\n        value = value.quantize(Decimal('.01'), rounding=ROUND_HALF_UP)\n        negative = value < 0\n        value = abs(value)\n        integer, fraction = divmod(value, 1)\n        integer = int(integer)\n        cents = int(fraction * 100)\n    return (integer, cents, negative)",
        "docstring": "Parses a currency value into its integer and cents components, along with a sign indicator.\n\nParameters:\n    value (int or str or Decimal): The value to parse, which can be an integer representing cents or a string/Decimal to represent currency.\n    is_int_with_cents (bool): A flag to determine whether an integer value should be treated as having cents (default is True).\n\nReturns:\n    tuple: A tuple containing three elements:\n        - integer (int): The integer part of the currency value.\n        - cents (int): The fractional part of the currency value in cents.\n        - negative (bool): A boolean indicating if the original value was negative.\n\nThis function uses the `Decimal` class from the `decimal` module to ensure accurate monetary calculations, and employs the `ROUND_HALF_UP` constant for rounding behavior when quantizing the value to two decimal places.",
        "signature": "def parse_currency_parts(value, is_int_with_cents=True):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: num2words-test_currency\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u2514\u2500\u2500 currency.py\n        \u2514\u2500\u2500 parse_currency_parts\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for parsing and processing numeric currency values into their constituent parts for precise financial calculations and representations. It supports various input formats, including integers, floats, decimal objects, and strings, and extracts data such as whole currency units, fractional cents, and whether the amount is negative. This capability ensures accurate decomposition of currency values, facilitating use cases like formatting, reconciling, or validating monetary data in financial and accounting systems. By standardizing currency parsing, the module addresses the complexities of handling diverse numeric inputs and rounding behaviors, offering developers a reliable tool for consistent currency manipulations.\n\n## FILE 1: num2words/currency.py\n\n- FUNCTION NAME: parse_currency_parts\n  - SIGNATURE: def parse_currency_parts(value, is_int_with_cents=True):\n  - DOCSTRING: \n```python\n\"\"\"\nParses a currency value into its integer and cents components, along with a sign indicator.\n\nParameters:\n    value (int or str or Decimal): The value to parse, which can be an integer representing cents or a string/Decimal to represent currency.\n    is_int_with_cents (bool): A flag to determine whether an integer value should be treated as having cents (default is True).\n\nReturns:\n    tuple: A tuple containing three elements:\n        - integer (int): The integer part of the currency value.\n        - cents (int): The fractional part of the currency value in cents.\n        - negative (bool): A boolean indicating if the original value was negative.\n\nThis function uses the `Decimal` class from the `decimal` module to ensure accurate monetary calculations, and employs the `ROUND_HALF_UP` constant for rounding behavior when quantizing the value to two decimal places.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/currency.py": "from __future__ import division\nfrom decimal import ROUND_HALF_UP, Decimal\n\ndef prefix_currency(prefix, base):\n    return tuple(('%s %s' % (prefix, i) for i in base))"
  },
  "call_tree": {
    "tests/test_currency.py:CurrencyTestCase:test_parse_currency_parts": {
      "num2words/currency.py:parse_currency_parts": {}
    }
  }
}