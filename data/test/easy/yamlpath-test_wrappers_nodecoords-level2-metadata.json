{
  "dir_path": "/app/yamlpath",
  "package_name": "yamlpath",
  "sample_name": "yamlpath-test_wrappers_nodecoords",
  "src_dir": "yamlpath/",
  "test_dir": "tests/",
  "test_file": "tests/test_wrappers_nodecoords.py",
  "test_code": "import pytest\n\nfrom yamlpath.wrappers import NodeCoords\n\nclass Test_wrappers_NodeCoords():\n\t\"\"\"Tests for the NodeCoords class.\"\"\"\n\n\tdef test_generic(self):\n\t\tnode_coord = NodeCoords([], None, None)\n\n\tdef test_repr(self):\n\t\tnode_coord = NodeCoords([], None, None)\n\t\tassert repr(node_coord) == \"NodeCoords('[]', 'None', 'None')\"\n\n\tdef test_str(self):\n\t\tnode_coord = NodeCoords([], None, None)\n\t\tassert str(node_coord) == \"[]\"\n\n\tdef test_gt(self):\n\t\tlhs_nc = NodeCoords(5, None, None)\n\t\trhs_nc = NodeCoords(3, None, None)\n\t\tassert lhs_nc > rhs_nc\n\n\tdef test_null_gt(self):\n\t\tlhs_nc = NodeCoords(5, None, None)\n\t\trhs_nc = NodeCoords(None, None, None)\n\t\tassert not lhs_nc > rhs_nc\n\n\tdef test_lt(self):\n\t\tlhs_nc = NodeCoords(5, None, None)\n\t\trhs_nc = NodeCoords(7, None, None)\n\t\tassert lhs_nc < rhs_nc\n\n\tdef test_null_lt(self):\n\t\tlhs_nc = NodeCoords(5, None, None)\n\t\trhs_nc = NodeCoords(None, None, None)\n\t\tassert not lhs_nc < rhs_nc\n\n\tdef test_isa_null(self):\n\t\tnc = NodeCoords(None, None, None)\n\t\tassert nc.wraps_a(None)\n",
  "GT_file_code": {
    "yamlpath/wrappers/nodecoords.py": "\"\"\"\nImplement NodeCoords.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom typing import Any, List, Optional, Type\n\nfrom yamlpath.types import AncestryEntry, PathSegment\nfrom yamlpath import YAMLPath\n\nclass NodeCoords:\n    \"\"\"\n    Wrap a node's data along with its relative coordinates within its DOM.\n\n    A node's \"coordinates\" includes these properties:\n    1. Reference to the node itself,\n    2. Immediate parent node of the wrapped node,\n    3. Index or Key of the node within its immediate parent\n\n    Additional, optional data can be wrapped along with the node's coordinates\n    to facilitate other specific operations upon the node/DOM.  See the\n    `__init__` method for details.\n    \"\"\"\n\n    # pylint: disable=locally-disabled,too-many-arguments\n    def __init__(\n        self, node: Any, parent: Any, parentref: Any,\n        path: Optional[YAMLPath] = None,\n        ancestry: Optional[List[AncestryEntry]] = None,\n        path_segment: Optional[PathSegment] = None\n    ) -> None:\n        \"\"\"\n        Initialize a new NodeCoords.\n\n        Positional Parameters:\n        1. node (Any) Reference to the ruamel.yaml DOM data element\n        2. parent (Any) Reference to `node`'s immediate DOM parent\n        3. parentref (Any) The `list` index or `dict` key which indicates where\n           within `parent` the `node` is located\n        4. path (YAMLPath) The YAML Path for this node, as reported by its\n           creator process\n        5. ancestry (List[AncestryEntry]) Stack of AncestryEntry (parent,\n           parentref) tracking the hierarchical ancestry of this node through\n           its parent document\n        6. path_segment (PathSegment) The YAML Path segment which most directly\n           caused the generation of this NodeCoords\n\n        Returns: N/A\n\n        Raises:  N/A\n        \"\"\"\n        self.node: Any = node\n        self.parent: Any = parent\n        self.parentref: Any = parentref\n        self.path: Optional[YAMLPath] = path\n        self.ancestry: List[AncestryEntry] = ([]\n                                              if ancestry is None\n                                              else ancestry)\n        self.path_segment: Optional[PathSegment] = path_segment\n\n    def __str__(self) -> str:\n        \"\"\"Get a String representation of this object.\"\"\"\n        return str(self.node)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Generate an eval()-safe representation of this object.\n\n        Assumes all of the ruamel.yaml components are similarly safe.\n        \"\"\"\n        return (\"{}('{}', '{}', '{}')\".format(\n            self.__class__.__name__, self.node, self.parent,\n            self.parentref))\n\n    def __gt__(self, rhs: \"NodeCoords\") -> Any:\n        \"\"\"Indicate whether this node's data is greater-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node > rhs.node\n\n    def __lt__(self, rhs: \"NodeCoords\") -> Any:\n        \"\"\"Indicate whether this node's data is less-than another's.\"\"\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node < rhs.node\n\n    @property\n    def unwrapped_node(self) -> Any:\n        \"\"\"Unwrap the data, no matter how deeply nested it may be.\"\"\"\n        return NodeCoords.unwrap_node_coords(self)\n\n    @property\n    def deepest_node_coord(self) -> \"NodeCoords\":\n        \"\"\"Get the deepest wrapped NodeCoord contained within.\"\"\"\n        return NodeCoords._deepest_node_coord(self)\n\n    def wraps_a(self, compare_type: Type) -> bool:\n        \"\"\"Indicate whether the wrapped node is of a given data-type.\"\"\"\n        if compare_type is None:\n            return self.unwrapped_node is None\n        return isinstance(self.unwrapped_node, compare_type)\n\n    @staticmethod\n    def _deepest_node_coord(node: \"NodeCoords\") -> \"NodeCoords\":\n        \"\"\"Get the deepest nested NodeCoord.\"\"\"\n        if (not isinstance(node, NodeCoords)\n            or not isinstance(node.node, NodeCoords)\n        ):\n            return node\n\n        return NodeCoords._deepest_node_coord(node.node)\n\n    @staticmethod\n    def unwrap_node_coords(data: Any) -> Any:\n        \"\"\"\n        Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\n        Parameters:\n        1. data (Any) the source data to strip.\n\n        Returns:  (Any) the stripped data.\n        \"\"\"\n        if isinstance(data, NodeCoords):\n            return NodeCoords.unwrap_node_coords(data.node)\n\n        if isinstance(data, list):\n            stripped_nodes = []\n            for ele in data:\n                stripped_nodes.append(NodeCoords.unwrap_node_coords(ele))\n            return stripped_nodes\n\n        return data\n"
  },
  "GT_src_dict": {
    "yamlpath/wrappers/nodecoords.py": {
      "NodeCoords.__init__": {
        "code": "    def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:\n        \"\"\"Initialize a new instance of NodeCoords, which encapsulates a node's data along with its positional information within a Document Object Model (DOM).\n\nParameters:\n- node (Any): Reference to the ruamel.yaml DOM data element being wrapped.\n- parent (Any): Reference to the immediate DOM parent of the node.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the node's position within its parent.\n- path (Optional[YAMLPath]): The YAML Path associated with this node.\n- ancestry (Optional[List[AncestryEntry]]): A list of AncestryEntry tracking the node's hierarchical ancestry.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that generated this NodeCoords instance.\n\nReturns: \n- None\n\nAttributes:\nThis constructor sets six attributes: `node`, `parent`, `parentref`, `path`, `ancestry`, and `path_segment`, which are utilized in other class methods for operations such as retrieving unwrapped nodes, comparing nodes, and managing node hierarchy. The `YAMLPath` and `AncestryEntry` types imported from the `yamlpath.types` module are crucial for handling paths and ancestry, facilitating structured interactions with YAML data.\"\"\"\n        \"\\n        Initialize a new NodeCoords.\\n\\n        Positional Parameters:\\n        1. node (Any) Reference to the ruamel.yaml DOM data element\\n        2. parent (Any) Reference to `node`'s immediate DOM parent\\n        3. parentref (Any) The `list` index or `dict` key which indicates where\\n           within `parent` the `node` is located\\n        4. path (YAMLPath) The YAML Path for this node, as reported by its\\n           creator process\\n        5. ancestry (List[AncestryEntry]) Stack of AncestryEntry (parent,\\n           parentref) tracking the hierarchical ancestry of this node through\\n           its parent document\\n        6. path_segment (PathSegment) The YAML Path segment which most directly\\n           caused the generation of this NodeCoords\\n\\n        Returns: N/A\\n\\n        Raises:  N/A\\n        \"\n        self.node: Any = node\n        self.parent: Any = parent\n        self.parentref: Any = parentref\n        self.path: Optional[YAMLPath] = path\n        self.ancestry: List[AncestryEntry] = [] if ancestry is None else ancestry\n        self.path_segment: Optional[PathSegment] = path_segment",
        "docstring": "Initialize a new instance of NodeCoords, which encapsulates a node's data along with its positional information within a Document Object Model (DOM).\n\nParameters:\n- node (Any): Reference to the ruamel.yaml DOM data element being wrapped.\n- parent (Any): Reference to the immediate DOM parent of the node.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the node's position within its parent.\n- path (Optional[YAMLPath]): The YAML Path associated with this node.\n- ancestry (Optional[List[AncestryEntry]]): A list of AncestryEntry tracking the node's hierarchical ancestry.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that generated this NodeCoords instance.\n\nReturns: \n- None\n\nAttributes:\nThis constructor sets six attributes: `node`, `parent`, `parentref`, `path`, `ancestry`, and `path_segment`, which are utilized in other class methods for operations such as retrieving unwrapped nodes, comparing nodes, and managing node hierarchy. The `YAMLPath` and `AncestryEntry` types imported from the `yamlpath.types` module are crucial for handling paths and ancestry, facilitating structured interactions with YAML data.",
        "signature": "def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Return a string representation of the NodeCoords object, specifically its wrapped node.\n\nThis method does not take any parameters and returns a string that represents the node contained within the NodeCoords instance. The output is derived from the `node` attribute, which can reference any type of data, reflecting the current state of the object. This method enables easy visualization and logging of the wrapped node's value.\"\"\"\n        'Get a String representation of this object.'\n        return str(self.node)",
        "docstring": "Return a string representation of the NodeCoords object, specifically its wrapped node.\n\nThis method does not take any parameters and returns a string that represents the node contained within the NodeCoords instance. The output is derived from the `node` attribute, which can reference any type of data, reflecting the current state of the object. This method enables easy visualization and logging of the wrapped node's value.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.__repr__": {
        "code": "    def __repr__(self) -> str:\n        \"\"\"Generate a string representation of the NodeCoords object, designed to be safe for evaluation with eval(). This representation includes the class name, the wrapped node, its parent, and the parent reference. The method assumes that all components from the ruamel.yaml library that may be included in these attributes are also safe for evaluation, thereby maintaining the integrity of the representation when utilized in various contexts involving YAML data structures. There are no parameters or side effects; it simply returns a formatted string.\"\"\"\n        '\\n        Generate an eval()-safe representation of this object.\\n\\n        Assumes all of the ruamel.yaml components are similarly safe.\\n        '\n        return \"{}('{}', '{}', '{}')\".format(self.__class__.__name__, self.node, self.parent, self.parentref)",
        "docstring": "Generate a string representation of the NodeCoords object, designed to be safe for evaluation with eval(). This representation includes the class name, the wrapped node, its parent, and the parent reference. The method assumes that all components from the ruamel.yaml library that may be included in these attributes are also safe for evaluation, thereby maintaining the integrity of the representation when utilized in various contexts involving YAML data structures. There are no parameters or side effects; it simply returns a formatted string.",
        "signature": "def __repr__(self) -> str:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.__gt__": {
        "code": "    def __gt__(self, rhs: 'NodeCoords') -> Any:\n        \"\"\"Indicate whether the node's data in this NodeCoords instance is greater than that of another NodeCoords instance.\n\nParameters:\n- rhs (NodeCoords): The NodeCoords instance to compare against.\n\nReturns:\n- bool: True if this node's data is greater than the other's, False if either node is None or if this node's data is not greater.\n\nThis method interacts with the node's data directly, utilizing Python's comparison operators. Note that the nodes being compared should be compatible with the greater-than operator. If either node is None, the comparison evaluates to False.\"\"\"\n        \"Indicate whether this node's data is greater-than another's.\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node > rhs.node",
        "docstring": "Indicate whether the node's data in this NodeCoords instance is greater than that of another NodeCoords instance.\n\nParameters:\n- rhs (NodeCoords): The NodeCoords instance to compare against.\n\nReturns:\n- bool: True if this node's data is greater than the other's, False if either node is None or if this node's data is not greater.\n\nThis method interacts with the node's data directly, utilizing Python's comparison operators. Note that the nodes being compared should be compatible with the greater-than operator. If either node is None, the comparison evaluates to False.",
        "signature": "def __gt__(self, rhs: 'NodeCoords') -> Any:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.__lt__": {
        "code": "    def __lt__(self, rhs: 'NodeCoords') -> Any:\n        \"\"\"Indicate whether the current node, referred to by `self`, is less than the node in the `rhs` parameter. \n\nParameters:\n- rhs (NodeCoords): Another instance of the NodeCoords class to compare against.\n\nReturns:\n- bool: True if `self.node` is less than `rhs.node`, False if either node is None or if `self.node` is not less than `rhs.node`.\n\nThis method leverages the comparison operators of the underlying node data to determine ordering, assuming that such comparisons are valid for the data types wrapped inside the NodeCoords instances.\"\"\"\n        \"Indicate whether this node's data is less-than another's.\"\n        if self.node is None or rhs.node is None:\n            return False\n        return self.node < rhs.node",
        "docstring": "Indicate whether the current node, referred to by `self`, is less than the node in the `rhs` parameter. \n\nParameters:\n- rhs (NodeCoords): Another instance of the NodeCoords class to compare against.\n\nReturns:\n- bool: True if `self.node` is less than `rhs.node`, False if either node is None or if `self.node` is not less than `rhs.node`.\n\nThis method leverages the comparison operators of the underlying node data to determine ordering, assuming that such comparisons are valid for the data types wrapped inside the NodeCoords instances.",
        "signature": "def __lt__(self, rhs: 'NodeCoords') -> Any:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.unwrapped_node": {
        "code": "    def unwrapped_node(self) -> Any:\n        \"\"\"Unwrap the wrapped node data contained within this NodeCoords instance.\n\nThis property method recursively removes any DOM tracking information from the NodeCoords object, returning the underlying data regardless of how deeply nested it is. It relies on the static method `unwrap_node_coords`, which handles the unwrapping logic for both `NodeCoords` instances and lists containing them.\n\nReturns:\n    Any: The data stripped of NodeCoords wrapping, which may include primitive values, lists, or dictionaries.\n\nDependencies:\n- `NodeCoords.unwrap_node_coords`: A static method that performs the actual unwrapping of NodeCoords and may recursively dive into nested structures.\"\"\"\n        'Unwrap the data, no matter how deeply nested it may be.'\n        return NodeCoords.unwrap_node_coords(self)",
        "docstring": "Unwrap the wrapped node data contained within this NodeCoords instance.\n\nThis property method recursively removes any DOM tracking information from the NodeCoords object, returning the underlying data regardless of how deeply nested it is. It relies on the static method `unwrap_node_coords`, which handles the unwrapping logic for both `NodeCoords` instances and lists containing them.\n\nReturns:\n    Any: The data stripped of NodeCoords wrapping, which may include primitive values, lists, or dictionaries.\n\nDependencies:\n- `NodeCoords.unwrap_node_coords`: A static method that performs the actual unwrapping of NodeCoords and may recursively dive into nested structures.",
        "signature": "def unwrapped_node(self) -> Any:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      },
      "NodeCoords.wraps_a": {
        "code": "    def wraps_a(self, compare_type: Type) -> bool:\n        \"\"\"Indicate whether the wrapped node is of a given data type.\n\nParameters:\n- compare_type (Type): The data type to compare against the type of the wrapped node. If None, the method checks if the unwrapped node is also None.\n\nReturns:\n- bool: True if the wrapped node is an instance of the specified data type or if both are None; otherwise, False.\n\nThis method uses the `unwrapped_node` property, which recursively retrieves the underlying data without its DOM tracking, to perform the type check. This allows for a flexible type comparison of the wrapped node data.\"\"\"\n        'Indicate whether the wrapped node is of a given data-type.'\n        if compare_type is None:\n            return self.unwrapped_node is None\n        return isinstance(self.unwrapped_node, compare_type)",
        "docstring": "Indicate whether the wrapped node is of a given data type.\n\nParameters:\n- compare_type (Type): The data type to compare against the type of the wrapped node. If None, the method checks if the unwrapped node is also None.\n\nReturns:\n- bool: True if the wrapped node is an instance of the specified data type or if both are None; otherwise, False.\n\nThis method uses the `unwrapped_node` property, which recursively retrieves the underlying data without its DOM tracking, to perform the type check. This allows for a flexible type comparison of the wrapped node data.",
        "signature": "def wraps_a(self, compare_type: Type) -> bool:",
        "type": "Method",
        "class_signature": "class NodeCoords:"
      }
    }
  },
  "dependency_dict": {
    "yamlpath/wrappers/nodecoords.py:NodeCoords:wraps_a": {},
    "yamlpath/wrappers/nodecoords.py:NodeCoords:unwrapped_node": {
      "yamlpath/wrappers/nodecoords.py": {
        "NodeCoords.unwrap_node_coords": {
          "code": "    def unwrap_node_coords(data: Any) -> Any:\n        \"\"\"\n        Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\n        Parameters:\n        1. data (Any) the source data to strip.\n\n        Returns:  (Any) the stripped data.\n        \"\"\"\n        if isinstance(data, NodeCoords):\n            return NodeCoords.unwrap_node_coords(data.node)\n        if isinstance(data, list):\n            stripped_nodes = []\n            for ele in data:\n                stripped_nodes.append(NodeCoords.unwrap_node_coords(ele))\n            return stripped_nodes\n        return data",
          "docstring": "Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\nParameters:\n1. data (Any) the source data to strip.\n\nReturns:  (Any) the stripped data.",
          "signature": "def unwrap_node_coords(data: Any) -> Any:",
          "type": "Method",
          "class_signature": "class NodeCoords:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_generic": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_repr": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__repr__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_str": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__str__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_gt": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__gt__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_null_gt": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__gt__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_lt": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__lt__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_null_lt": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__lt__": {}
    },
    "tests/test_wrappers_nodecoords.py:Test_wrappers_NodeCoords:test_isa_null": {
      "yamlpath/wrappers/nodecoords.py:NodeCoords:__init__": {},
      "yamlpath/wrappers/nodecoords.py:NodeCoords:wraps_a": {
        "yamlpath/wrappers/nodecoords.py:NodeCoords:unwrapped_node": {
          "yamlpath/wrappers/nodecoords.py:NodeCoords:unwrap_node_coords": {
            "yamlpath/wrappers/nodecoords.py:NodeCoords:unwrap_node_coords": {
              "[ignored_or_cut_off]": "..."
            }
          }
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: yamlpath-test_wrappers_nodecoords\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamlpath/\n    \u2514\u2500\u2500 wrappers/\n        \u2514\u2500\u2500 nodecoords.py\n            \u251c\u2500\u2500 NodeCoords.__gt__\n            \u251c\u2500\u2500 NodeCoords.__init__\n            \u251c\u2500\u2500 NodeCoords.__lt__\n            \u251c\u2500\u2500 NodeCoords.__repr__\n            \u251c\u2500\u2500 NodeCoords.__str__\n            \u251c\u2500\u2500 NodeCoords.unwrapped_node\n            \u2514\u2500\u2500 NodeCoords.wraps_a\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides unit test coverage for the `NodeCoords` class, a component of the `yamlpath.wrappers` package, ensuring its reliability and correctness. The tests verify the core behavior and properties of the `NodeCoords` class, such as string representation, relational comparisons (`>` and `<`), and its ability to handle `None` values robustly. This module ensures that the `NodeCoords` class operates as expected when representing or comparing nodes within YAML paths, addressing potential edge cases. By validating these functionalities, the module supports developers in building and maintaining systems that rely on accurate and dependable YAML path manipulations while reducing the risk of runtime errors.\n\n## FILE 1: yamlpath/wrappers/nodecoords.py\n\n- CLASS METHOD: NodeCoords.unwrapped_node\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def unwrapped_node(self) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nUnwrap the wrapped node data contained within this NodeCoords instance.\n\nThis property method recursively removes any DOM tracking information from the NodeCoords object, returning the underlying data regardless of how deeply nested it is. It relies on the static method `unwrap_node_coords`, which handles the unwrapping logic for both `NodeCoords` instances and lists containing them.\n\nReturns:\n    Any: The data stripped of NodeCoords wrapping, which may include primitive values, lists, or dictionaries.\n\nDependencies:\n- `NodeCoords.unwrap_node_coords`: A static method that performs the actual unwrapping of NodeCoords and may recursively dive into nested structures.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.wraps_a\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def wraps_a(self, compare_type: Type) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nIndicate whether the wrapped node is of a given data type.\n\nParameters:\n- compare_type (Type): The data type to compare against the type of the wrapped node. If None, the method checks if the unwrapped node is also None.\n\nReturns:\n- bool: True if the wrapped node is an instance of the specified data type or if both are None; otherwise, False.\n\nThis method uses the `unwrapped_node` property, which recursively retrieves the underlying data without its DOM tracking, to perform the type check. This allows for a flexible type comparison of the wrapped node data.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.__str__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn a string representation of the NodeCoords object, specifically its wrapped node.\n\nThis method does not take any parameters and returns a string that represents the node contained within the NodeCoords instance. The output is derived from the `node` attribute, which can reference any type of data, reflecting the current state of the object. This method enables easy visualization and logging of the wrapped node's value.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.__init__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __init__(self, node: Any, parent: Any, parentref: Any, path: Optional[YAMLPath]=None, ancestry: Optional[List[AncestryEntry]]=None, path_segment: Optional[PathSegment]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new instance of NodeCoords, which encapsulates a node's data along with its positional information within a Document Object Model (DOM).\n\nParameters:\n- node (Any): Reference to the ruamel.yaml DOM data element being wrapped.\n- parent (Any): Reference to the immediate DOM parent of the node.\n- parentref (Any): The index (for lists) or key (for dictionaries) indicating the node's position within its parent.\n- path (Optional[YAMLPath]): The YAML Path associated with this node.\n- ancestry (Optional[List[AncestryEntry]]): A list of AncestryEntry tracking the node's hierarchical ancestry.\n- path_segment (Optional[PathSegment]): The specific YAML Path segment that generated this NodeCoords instance.\n\nReturns: \n- None\n\nAttributes:\nThis constructor sets six attributes: `node`, `parent`, `parentref`, `path`, `ancestry`, and `path_segment`, which are utilized in other class methods for operations such as retrieving unwrapped nodes, comparing nodes, and managing node hierarchy. The `YAMLPath` and `AncestryEntry` types imported from the `yamlpath.types` module are crucial for handling paths and ancestry, facilitating structured interactions with YAML data.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.__gt__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __gt__(self, rhs: 'NodeCoords') -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nIndicate whether the node's data in this NodeCoords instance is greater than that of another NodeCoords instance.\n\nParameters:\n- rhs (NodeCoords): The NodeCoords instance to compare against.\n\nReturns:\n- bool: True if this node's data is greater than the other's, False if either node is None or if this node's data is not greater.\n\nThis method interacts with the node's data directly, utilizing Python's comparison operators. Note that the nodes being compared should be compatible with the greater-than operator. If either node is None, the comparison evaluates to False.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.__lt__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __lt__(self, rhs: 'NodeCoords') -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nIndicate whether the current node, referred to by `self`, is less than the node in the `rhs` parameter. \n\nParameters:\n- rhs (NodeCoords): Another instance of the NodeCoords class to compare against.\n\nReturns:\n- bool: True if `self.node` is less than `rhs.node`, False if either node is None or if `self.node` is not less than `rhs.node`.\n\nThis method leverages the comparison operators of the underlying node data to determine ordering, assuming that such comparisons are valid for the data types wrapped inside the NodeCoords instances.\n\"\"\"\n```\n\n- CLASS METHOD: NodeCoords.__repr__\n  - CLASS SIGNATURE: class NodeCoords:\n  - SIGNATURE: def __repr__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a string representation of the NodeCoords object, designed to be safe for evaluation with eval(). This representation includes the class name, the wrapped node, its parent, and the parent reference. The method assumes that all components from the ruamel.yaml library that may be included in these attributes are also safe for evaluation, thereby maintaining the integrity of the representation when utilized in various contexts involving YAML data structures. There are no parameters or side effects; it simply returns a formatted string.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamlpath/wrappers/nodecoords.py": "\"\"\"\nImplement NodeCoords.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nfrom typing import Any, List, Optional, Type\nfrom yamlpath.types import AncestryEntry, PathSegment\nfrom yamlpath import YAMLPath\n\nclass NodeCoords:\n    \"\"\"\n    Wrap a node's data along with its relative coordinates within its DOM.\n\n    A node's \"coordinates\" includes these properties:\n    1. Reference to the node itself,\n    2. Immediate parent node of the wrapped node,\n    3. Index or Key of the node within its immediate parent\n\n    Additional, optional data can be wrapped along with the node's coordinates\n    to facilitate other specific operations upon the node/DOM.  See the\n    `__init__` method for details.\n    \"\"\"\n\n    @property\n    def deepest_node_coord(self) -> 'NodeCoords':\n        \"\"\"Get the deepest wrapped NodeCoord contained within.\"\"\"\n        return NodeCoords._deepest_node_coord(self)\n\n    @staticmethod\n    def _deepest_node_coord(node: 'NodeCoords') -> 'NodeCoords':\n        \"\"\"Get the deepest nested NodeCoord.\"\"\"\n        if not isinstance(node, NodeCoords) or not isinstance(node.node, NodeCoords):\n            return node\n        return NodeCoords._deepest_node_coord(node.node)\n\n    @staticmethod\n    def unwrap_node_coords(data: Any) -> Any:\n        \"\"\"\n        Recursively strips all DOM tracking data off of a NodeCoords wrapper.\n\n        Parameters:\n        1. data (Any) the source data to strip.\n\n        Returns:  (Any) the stripped data.\n        \"\"\"\n        if isinstance(data, NodeCoords):\n            return NodeCoords.unwrap_node_coords(data.node)\n        if isinstance(data, list):\n            stripped_nodes = []\n            for ele in data:\n                stripped_nodes.append(NodeCoords.unwrap_node_coords(ele))\n            return stripped_nodes\n        return data"
  }
}