{
  "dir_path": "/app/yamlpath",
  "package_name": "yamlpath",
  "sample_name": "yamlpath-test_common_parsers",
  "src_dir": "yamlpath/",
  "test_dir": "tests/",
  "test_file": "tests/test_common_parsers.py",
  "test_code": "import pytest\nimport json\nimport datetime as dt\n\nimport ruamel.yaml as ry\nfrom ruamel.yaml import version_info as ryversion\nif ryversion < (0, 17, 22):                   # pragma: no cover\n    from yamlpath.patches.timestamp import (\n        AnchoredTimeStamp,\n        AnchoredDate,\n    )  # type: ignore\nelse:                                         # pragma: no cover\n    # Temporarily fool MYPY into resolving the future-case imports\n    from ruamel.yaml.timestamp import TimeStamp as AnchoredTimeStamp\n    AnchoredDate = AnchoredTimeStamp\n    #from ruamel.yaml.timestamp import AnchoredTimeStamp\n    # From whence shall come AnchoredDate?\n\nfrom yamlpath.enums import YAMLValueFormats\nfrom yamlpath.common import Parsers\n\nclass Test_common_parsers():\n    \"\"\"Tests for the Parsers helper class.\"\"\"\n\n    ###\n    # get_yaml_data (literal=True)\n    ###\n    def test_get_yaml_data_literally(self, quiet_logger):\n        serialized_yaml = \"\"\"---\nhash:\n  key: value\n\nlist:\n  - ichi\n  - ni\n  - san\n\"\"\"\n        yaml = Parsers.get_yaml_editor()\n        (data, loaded) = Parsers.get_yaml_data(\n            yaml, quiet_logger, serialized_yaml,\n            literal=True)\n        assert loaded == True\n        assert data[\"hash\"][\"key\"] == \"value\"\n        assert data[\"list\"][0] == \"ichi\"\n        assert data[\"list\"][1] == \"ni\"\n        assert data[\"list\"][2] == \"san\"\n\n    ###\n    # get_yaml_multidoc_data (literal=True)\n    ###\n    def test_get_yaml_multidoc_data_literally(self, quiet_logger):\n        serialized_yaml = \"\"\"---\ndocument: 1st\nhas: data\n...\n---\ndocument: 2nd\nhas: different data\n\"\"\"\n        yaml = Parsers.get_yaml_editor()\n        doc_id = 0\n        for (data, loaded) in Parsers.get_yaml_multidoc_data(\n                yaml, quiet_logger, serialized_yaml,\n                literal=True):\n            assert loaded == True\n            if doc_id == 0:\n                document = \"1st\"\n                has = \"data\"\n            else:\n                document= \"2nd\"\n                has = \"different data\"\n            doc_id = doc_id + 1\n\n            assert data[\"document\"] == document\n            assert data[\"has\"] == has\n\n    ###\n    # stringify_dates\n    ###\n    def test_stringify_complex_data_with_dates(self):\n        cdata = ry.comments.CommentedMap({\n            \"dates\": ry.comments.CommentedSeq([\n                dt.date(2020, 10, 31),\n                dt.date(2020, 11, 3)\n            ])\n        })\n        sdata = Parsers.stringify_dates(cdata)\n        assert sdata[\"dates\"][0] == \"2020-10-31\"\n        assert sdata[\"dates\"][1] == \"2020-11-03\"\n\n    ###\n    # jsonify_yaml_data\n    ###\n    def test_jsonify_complex_ruamel_data(self):\n        tagged_tag = \"!tagged\"\n        tagged_value = \"tagged value\"\n        tagged_scalar = ry.scalarstring.PlainScalarString(tagged_value)\n        tagged_node = ry.comments.TaggedScalar(tagged_scalar, tag=tagged_tag)\n\n        null_tag = \"!null\"\n        null_value = None\n        null_node = ry.comments.TaggedScalar(None, tag=null_tag)\n\n        cdata = ry.comments.CommentedMap({\n            \"tagged\": tagged_node,\n            \"null\": null_node,\n            \"dates\": ry.comments.CommentedSeq([\n                dt.date(2020, 10, 31),\n                dt.date(2020, 11, 3),\n                AnchoredDate(2020, 12, 1),\n                AnchoredTimeStamp(2021, 1, 13, 1, 2, 3)\n            ]),\n            \"t_bool\": ry.scalarbool.ScalarBoolean(1),\n            \"f_bool\": ry.scalarbool.ScalarBoolean(0)\n        })\n        jdata = Parsers.jsonify_yaml_data(cdata)\n        assert jdata[\"tagged\"] == tagged_value\n        assert jdata[\"null\"] == null_value\n        assert jdata[\"dates\"][0] == \"2020-10-31\"\n        assert jdata[\"dates\"][1] == \"2020-11-03\"\n        assert jdata[\"dates\"][2] == \"2020-12-01\"\n        assert jdata[\"dates\"][3] == \"2021-01-13T01:02:03\"\n        assert jdata[\"t_bool\"] == 1\n        assert jdata[\"f_bool\"] == 0\n\n        jstr = json.dumps(jdata)\n        assert jstr == \"\"\"{\"tagged\": \"tagged value\", \"null\": null, \"dates\": [\"2020-10-31\", \"2020-11-03\", \"2020-12-01\", \"2021-01-13T01:02:03\"], \"t_bool\": true, \"f_bool\": false}\"\"\"\n\n    def test_jsonify_complex_python_data(self):\n        cdata = {\n            \"dates\": [\n                dt.date(2020, 10, 31),\n                dt.date(2020, 11, 3)\n            ],\n            \"bytes\": b\"abc\",\n            \"t_bool\": True,\n            \"f_bool\": False\n        }\n        jdata = Parsers.jsonify_yaml_data(cdata)\n        assert jdata[\"dates\"][0] == \"2020-10-31\"\n        assert jdata[\"dates\"][1] == \"2020-11-03\"\n        assert jdata[\"t_bool\"] == True\n        assert jdata[\"f_bool\"] == False\n\n        jstr = json.dumps(jdata)\n        assert jstr == \"\"\"{\"dates\": [\"2020-10-31\", \"2020-11-03\"], \"bytes\": \"b'abc'\", \"t_bool\": true, \"f_bool\": false}\"\"\"\n",
  "GT_file_code": {
    "yamlpath/common/parsers.py": "\"\"\"\nImplement Parsers, a static library of generally-useful code for data parsers.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nimport warnings\nfrom sys import maxsize, stdin\nfrom datetime import date, datetime\nfrom typing import Any, Dict, Generator, Tuple\n\nimport ruamel.yaml # type: ignore\nfrom ruamel.yaml import YAML\nfrom ruamel.yaml.parser import ParserError\nfrom ruamel.yaml.composer import ComposerError, ReusedAnchorWarning\nfrom ruamel.yaml.constructor import ConstructorError, DuplicateKeyError\nfrom ruamel.yaml.scanner import ScannerError\nfrom ruamel.yaml.scalarbool import ScalarBoolean\nfrom ruamel.yaml.scalarstring import ScalarString\nfrom ruamel.yaml.comments import (\n    CommentedMap, CommentedSet, CommentedSeq, TaggedScalar\n)\nfrom yamlpath.patches.timestamp import (\n    AnchoredTimeStamp,\n    AnchoredDate,\n)\n\nfrom yamlpath.wrappers import ConsolePrinter\nfrom yamlpath.common import Nodes\n\n\nclass Parsers:\n    \"\"\"Helper methods for common YAML/JSON/Compatible parser operations.\"\"\"\n\n    @staticmethod\n    def get_yaml_editor(**kwargs: Any) -> YAML:\n        \"\"\"\n        Build and return a generic YAML editor based on ruamel.yaml.\n\n        Parameters:  N/A\n\n        Keyword Arguments:\n        * explicit_start (bool) True = ensure the YAML Start-of-Document marker\n          (---<EOL>) is written in the output; False = remove it; default=True\n        * explode_aliases (bool) True = convert all aliases (*name) and YAML\n          merge operators (<<: *name) to their referenced content, removing the\n          aliases and merge operators; False = maintain the references;\n          default=False\n        * preserve_quotes (bool) True = retain any and all quoting of keys and\n          values including whatever demarcation symbol was used (\" versus ');\n          False = only quote values when necessary, removing unnecessary\n          demarcation; default=True\n\n        Returns (Any) The ready-for-use YAML editor.\n\n        Raises:  N/A\n        \"\"\"\n        explicit_start = kwargs.pop(\"explicit_start\", True)\n        explode_aliases = kwargs.pop(\"explode_aliases\", False)\n        preserve_quotes = kwargs.pop(\"preserve_quotes\", True)\n\n        # The ruamel.yaml class appears to be missing some typing data, so\n        # these valid assignments cannot be type-checked.\n        yaml = YAML()\n\n        yaml.indent(mapping=2, sequence=4, offset=2)\n        yaml.explicit_start = explicit_start       # type: ignore\n        yaml.preserve_quotes = preserve_quotes     # type: ignore\n        yaml.width = maxsize                       # type: ignore\n\n        if explode_aliases:\n            yaml.default_flow_style = False\n\n        return yaml\n\n    @staticmethod\n    # pylint: disable=too-many-branches,too-many-statements,too-many-locals\n    def get_yaml_data(\n        parser: Any, logger: ConsolePrinter, source: str, **kwargs\n    ) -> Tuple[Any, bool]:\n        \"\"\"\n        Parse YAML/Compatible data and return the ruamel.yaml object result.\n\n        All known issues are caught and distinctively logged.\n\n        Parameters:\n        1. parser (ruamel.yaml.YAML) The YAML data parser\n        2. logger (ConsolePrinter) The logging facility\n        3. source (str) The source file or serialized literal to load; can be -\n           for reading from STDIN (implies literal=True)\n\n        Keyword Arguments:\n        * literal (bool) `source` is literal serialized YAML data rather than a\n          file-spec, so load it directly\n\n        Returns:  Tuple[Any, bool] A tuple containing the document and its\n        success/fail state.  The first field is the parsed document; will be\n        None for empty documents and for documents which could not be read.\n        The second field will be True when there were no errors during parsing\n        and False, otherwise.\n        \"\"\"\n        literal = kwargs.pop(\"literal\", False)\n        yaml_data = None\n        data_available = True\n\n        # This code traps errors and warnings from ruamel.yaml, substituting\n        # lengthy stack-dumps with specific, meaningful feedback.  Further,\n        # some warnings are treated as errors by ruamel.yaml, so these are also\n        # coallesced into cleaner feedback.\n        try:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"error\")\n                if source == \"-\":\n                    yaml_data = parser.load(stdin.read())\n                else:\n                    if literal:\n                        yaml_data = parser.load(source)\n                    else:\n                        with open(source, 'r', encoding='utf-8') as fhnd:\n                            yaml_data = parser.load(fhnd)\n        except KeyboardInterrupt:\n            logger.error(\"Aborting data load due to keyboard interrupt!\")\n            data_available = False\n        except FileNotFoundError:\n            logger.error(\"File not found:  {}\".format(source))\n            data_available = False\n        except ParserError as ex:\n            logger.error(\"YAML parsing error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ComposerError as ex:\n            logger.error(\"YAML composition error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ConstructorError as ex:\n            logger.error(\"YAML construction error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ScannerError as ex:\n            logger.error(\"YAML syntax error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except DuplicateKeyError as dke:\n            omits = [\n                \"while constructing\", \"To suppress this\", \"readthedocs\",\n                \"future releases\", \"the new API\",\n            ]\n            message = str(dke).split(\"\\n\")\n            newmsg = \"\"\n            for line in message:\n                line = line.strip()\n                if not line:\n                    continue\n                write_line = True\n                for omit in omits:\n                    if omit in line:\n                        write_line = False\n                        break\n                if write_line:\n                    newmsg += \"\\n   \" + line\n            logger.error(\"Duplicate Hash key detected:  {}\"\n                        .format(newmsg))\n            data_available = False\n        except ReusedAnchorWarning as raw:\n            logger.error(\"Duplicate YAML Anchor detected:  {}\"\n                        .format(\n                            str(raw)\n                            .replace(\"occurrence   \", \"occurrence \")\n                            .replace(\"\\n\", \"\\n   \")))\n            data_available = False\n\n        return (yaml_data, data_available)\n\n    @staticmethod\n    # pylint: disable=too-many-branches,too-many-statements,too-many-locals\n    def get_yaml_multidoc_data(\n        parser: Any, logger: ConsolePrinter, source: str, **kwargs\n    ) -> Generator[Tuple[Any, bool], None, None]:\n        \"\"\"\n        Parse YAML/Compatible multi-docs and yield each ruamel.yaml object.\n\n        All known issues are caught and distinctively logged.\n\n        Parameters:\n        1. parser (ruamel.yaml.YAML) The YAML data parser\n        2. logger (ConsolePrinter) The logging facility\n        3. source (str) The source file to load; can be - for reading from\n           STDIN\n\n        Keyword Arguments:\n        * literal (bool) `source` is literal serialized YAML data rather than a\n          file-spec, so load it directly\n\n        Returns:  Generator[Tuple[Any, bool], None, None] A tuple for each\n        document as it is parsed.  The first field is the parsed document; will\n        be None for empty documents and for documents which could not be read.\n        The second field will be True when there were no errors during parsing\n        and False, otherwise.\n        \"\"\"\n        literal = kwargs.pop(\"literal\", False)\n\n        # This code traps errors and warnings from ruamel.yaml, substituting\n        # lengthy stack-dumps with specific, meaningful feedback.  Further,\n        # some warnings are treated as errors by ruamel.yaml, so these are also\n        # coallesced into cleaner feedback.\n        has_error = False\n        try:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"error\")\n                if source == \"-\":\n                    doc_yielded = False\n                    for document in parser.load_all(stdin.read()):\n                        doc_yielded = True\n                        logger.debug(\n                            \"Yielding document from {}:\".format(source),\n                            prefix=\"get_yaml_multidoc_data: \", data=document)\n                        yield (document, True)\n\n                    # The user sent a deliberately empty document via STDIN\n                    if not doc_yielded:\n                        yield (\"\", True)\n                else:\n                    if literal:\n                        for document in parser.load_all(source):\n                            yield (document, True)\n                    else:\n                        with open(source, 'r', encoding='utf-8') as fhnd:\n                            for document in parser.load_all(fhnd):\n                                logger.debug(\n                                    \"Yielding document from {}:\"\n                                    .format(source),\n                                    prefix=\"get_yaml_multidoc_data: \",\n                                    data=document)\n                                yield (document, True)\n        except KeyboardInterrupt:\n            has_error = True\n            logger.error(\"Aborting data load due to keyboard interrupt!\")\n        except FileNotFoundError:\n            has_error = True\n            logger.error(\"File not found:  {}\".format(source))\n        except ParserError as ex:\n            has_error = True\n            logger.error(\"YAML parsing error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ComposerError as ex:\n            has_error = True\n            logger.error(\"YAML composition error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ConstructorError as ex:\n            has_error = True\n            logger.error(\"YAML construction error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ScannerError as ex:\n            has_error = True\n            logger.error(\"YAML syntax error {}:  {}\"\n                        .format(str(ex.problem_mark).lstrip(), ex.problem))\n        except DuplicateKeyError as dke:\n            has_error = True\n            omits = [\n                \"while constructing\", \"To suppress this\", \"readthedocs\",\n                \"future releases\", \"the new API\",\n            ]\n            message = str(dke).split(\"\\n\")\n            newmsg = \"\"\n            for line in message:\n                line = line.strip()\n                if not line:\n                    continue\n                write_line = True\n                for omit in omits:\n                    if omit in line:\n                        write_line = False\n                        break\n                if write_line:\n                    newmsg += \"\\n   \" + line\n            logger.error(\"Duplicate Hash key detected:  {}\"\n                        .format(newmsg))\n        except ReusedAnchorWarning as raw:\n            has_error = True\n            logger.error(\"Duplicate YAML Anchor detected:  {}\"\n                        .format(\n                            str(raw)\n                            .replace(\"occurrence   \", \"occurrence \")\n                            .replace(\"\\n\", \"\\n   \")))\n\n        if has_error:\n            yield (None, False)\n\n    @staticmethod\n    def stringify_dates(data: Any) -> Any:\n        \"\"\"\n        Recurse through a data structure, converting all dates to strings.\n\n        The jsonify_yaml_data covers more data-types than just dates.  This\n        stringify_dates method may be removed in a future version in favor of\n        the more comprehensive jsonify_yaml_data method.\n\n        This is required for JSON output, which has no serialization support\n        for native date objects.\n        \"\"\"\n        if isinstance(data, CommentedMap):\n            for key, val in data.items():\n                data[key] = Parsers.stringify_dates(val)\n        elif isinstance(data, CommentedSeq):\n            for idx, ele in enumerate(data):\n                data[idx] = Parsers.stringify_dates(ele)\n        elif isinstance(data, (datetime, date)):\n            return data.isoformat()\n        return data\n\n    @staticmethod\n    # pylint: disable=too-many-branches\n    def jsonify_yaml_data(data: Any) -> Any:\n        \"\"\"\n        Convert all non-JSON-serializable values to strings.\n\n        This is required when writing to JSON, which has no serialization\n        support for certain YAML extensions -- like tags -- and some otherwise\n        native data-types, like dates.\n        \"\"\"\n        if isinstance(data, CommentedMap):\n            for i, k in [\n                (idx, key) for idx, key in enumerate(data.keys())\n                if isinstance(key, TaggedScalar)\n            ]:\n                unwrapped_key = Parsers.jsonify_yaml_data(k)\n                data.insert(i, unwrapped_key, data.pop(k))\n\n            for key, val in data.items():\n                data[key] = Parsers.jsonify_yaml_data(val)\n        elif isinstance(data, dict):\n            for key, val in data.items():\n                data[key] = Parsers.jsonify_yaml_data(val)\n        elif isinstance(data, (list, CommentedSeq)):\n            for idx, ele in enumerate(data):\n                data[idx] = Parsers.jsonify_yaml_data(ele)\n        elif isinstance(data, (set, CommentedSet)):\n            json_repr: Dict[str, None] = {}\n            for set_val in data:\n                json_key_proto = Parsers.jsonify_yaml_data(set_val)\n                json_key = (str(json_key_proto)\n                            if isinstance(json_key_proto, tuple)\n                            else json_key_proto)\n                json_repr[json_key] = None\n            data = json_repr\n        elif isinstance(data, TaggedScalar):\n            if data.tag.value == \"!null\":\n                return None\n            data = Parsers.jsonify_yaml_data(data.value)\n        elif isinstance(data, AnchoredDate):\n            data = data.date().isoformat()\n        elif isinstance(data, AnchoredTimeStamp):\n            data = Nodes.get_timestamp_with_tzinfo(data).isoformat()\n        elif isinstance(data, (datetime, date)):\n            data = data.isoformat()\n        elif isinstance(data, bytes):\n            data = str(data)\n        elif isinstance(data, (ScalarBoolean, bool)):\n            data = bool(data)\n        return data\n\n    @staticmethod\n    def delete_all_comments(dom: Any) -> None:\n        \"\"\"\n        Recursively delete all comments from a YAML document.\n\n        See:\n        https://stackoverflow.com/questions/60080325/how-to-delete-all-comments-in-ruamel-yaml/60099750#60099750\n\n        Parameters:\n        1. dom (Any) The document to strip of all comments.\n\n        Returns:  N/A\n        \"\"\"\n        if dom is None:\n            return\n\n        if isinstance(dom, CommentedMap):\n            for key, val in dom.items():\n                Parsers.delete_all_comments(key)\n                Parsers.delete_all_comments(val)\n        elif isinstance(dom, CommentedSeq):\n            for ele in dom:\n                Parsers.delete_all_comments(ele)\n        try:\n            # literal scalarstring might have comment associated with them\n            attr = \"comment\" if isinstance(dom, ScalarString) \\\n                else ruamel.yaml.comments.Comment.attrib\n            delattr(dom, attr)\n        except AttributeError:\n            pass\n\n    @staticmethod\n    def set_flow_style(node: Any, is_flow: bool) -> None:\n        \"\"\"\n        Recursively apply flow|block style to a node.\n\n        Parameters:\n        1. node (Any) The node to apply flow|block style to.\n        2. is_flow (bool) True=flow-style, False=block-style\n\n        Returns:  N/A\n        \"\"\"\n        if hasattr(node, \"fa\"):\n            if is_flow:\n                node.fa.set_flow_style()\n            else:\n                node.fa.set_block_style()\n\n        if isinstance(node, CommentedMap):\n            for key, val in node.non_merged_items():\n                Parsers.set_flow_style(key, is_flow)\n                Parsers.set_flow_style(val, is_flow)\n        elif isinstance(node, CommentedSeq):\n            for ele in node:\n                Parsers.set_flow_style(ele, is_flow)\n",
    "yamlpath/patches/timestamp.py": "# pylint: skip-file\n\"\"\"\nFix missing anchors from timestamp and date nodes.\n\nThis must be removed once incorporated into ruamel.yaml, likely at version\n0.17.22.\n\nSource: https://sourceforge.net/p/ruamel-yaml/tickets/440/\nCopyright 2022 Anthon van der Neut, William W. Kimball Jr. MBA MSIS\n\"\"\"\nimport ruamel.yaml\nfrom ruamel.yaml.constructor import ConstructorError\nfrom ruamel.yaml.anchor import Anchor\nfrom ruamel.yaml.timestamp import TimeStamp\n\nfrom typing import Any, Dict, Union  # NOQA\nimport datetime\nimport copy\n\n\nclass AnchoredTimeStamp(TimeStamp):\n    \"\"\"Extend TimeStamp to track YAML Anchors.\"\"\"\n\n    def __init__(self, *args: Any, **kw: Any) -> None:\n        \"\"\"Initialize a new instance.\"\"\"\n        self._yaml: Dict[Any, Any] = dict(t=False, tz=None, delta=0)\n\n    def __new__(cls, *args: Any, **kw: Any) -> Any:  # datetime is immutable\n        \"\"\"Create a new, immutable instance.\"\"\"\n        anchor = kw.pop('anchor', None)\n        ts = TimeStamp.__new__(cls, *args, **kw)\n        if anchor is not None:\n            ts.yaml_set_anchor(anchor, always_dump=True)\n        return ts\n\n    def __deepcopy__(self, memo: Any) -> Any:\n        \"\"\"Deeply copy this instance to another.\"\"\"\n        ts = AnchoredTimeStamp(self.year, self.month, self.day, self.hour, self.minute, self.second)\n        ts._yaml = copy.deepcopy(self._yaml)\n        return ts\n\n    @property\n    def anchor(self) -> Any:\n        \"\"\"Access the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            setattr(self, Anchor.attrib, Anchor())\n        return getattr(self, Anchor.attrib)\n\n    def yaml_anchor(self, any: bool = False) -> Any:\n        \"\"\"Get the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            return None\n        if any or self.anchor.always_dump:\n            return self.anchor\n        return None\n\n    def yaml_set_anchor(self, value: Any, always_dump: bool = False) -> None:\n        \"\"\"Set the YAML Anchor.\"\"\"\n        self.anchor.value = value\n        self.anchor.always_dump = always_dump\n\n\nclass AnchoredDate(AnchoredTimeStamp):\n    \"\"\"Define AnchoredDate.\"\"\"\n\n    pass\n\n\ndef construct_anchored_timestamp(\n    self, node: Any, values: Any = None\n) -> Union[AnchoredTimeStamp, AnchoredDate]:\n    \"\"\"Construct an AnchoredTimeStamp.\"\"\"\n    try:\n        match = self.timestamp_regexp.match(node.value)\n    except TypeError:\n        match = None\n    if match is None:\n        raise ConstructorError(\n            None,\n            None,\n            f'failed to construct timestamp from \"{node.value}\"',\n            node.start_mark,\n        )\n    values = match.groupdict()\n    dd = ruamel.yaml.util.create_timestamp(**values)  # this has delta applied\n    delta = None\n    if values['tz_sign']:\n        tz_hour = int(values['tz_hour'])\n        minutes = values['tz_minute']\n        tz_minute = int(minutes) if minutes else 0\n        delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)\n        if values['tz_sign'] == '-':\n            delta = -delta\n    if isinstance(dd, datetime.datetime):\n        data = AnchoredTimeStamp(\n            dd.year, dd.month, dd.day, dd.hour, dd.minute, dd.second, dd.microsecond, anchor=node.anchor\n        )\n    else:\n        data = AnchoredDate(dd.year, dd.month, dd.day, 0, 0, 0, 0, anchor=node.anchor)\n        return data\n    if delta:\n        data._yaml['delta'] = delta\n        tz = values['tz_sign'] + values['tz_hour']\n        if values['tz_minute']:\n            tz += ':' + values['tz_minute']\n        data._yaml['tz'] = tz\n    else:\n        if values['tz']:  # no delta\n            data._yaml['tz'] = values['tz']\n    if values['t']:\n        data._yaml['t'] = True\n    return data\n\nruamel.yaml.constructor.RoundTripConstructor.add_constructor('tag:yaml.org,2002:timestamp', construct_anchored_timestamp)\n\ndef represent_anchored_timestamp(self, data: Any):\n    \"\"\"Render an AnchoredTimeStamp.\"\"\"\n    try:\n        anchor = data.yaml_anchor()\n    except AttributeError:\n        anchor = None\n    inter = 'T' if data._yaml['t'] else ' '\n    _yaml = data._yaml\n    if _yaml['delta']:\n        data += _yaml['delta']\n    if isinstance(data, AnchoredDate):\n        value = data.date().isoformat()\n    else:\n        value = data.isoformat(inter)\n    if _yaml['tz']:\n        value += _yaml['tz']\n    return self.represent_scalar('tag:yaml.org,2002:timestamp', value, anchor=anchor)\n\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredTimeStamp, represent_anchored_timestamp)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredDate, represent_anchored_timestamp)\n"
  },
  "GT_src_dict": {
    "yamlpath/common/parsers.py": {
      "Parsers.get_yaml_editor": {
        "code": "    def get_yaml_editor(**kwargs: Any) -> YAML:\n        \"\"\"Builds and returns a configured YAML editor using the `ruamel.yaml` library. This editor can be customized with parameters to control document formatting, such as whether to include the YAML Start-of-Document marker, how to handle aliases, and the preservation of quotes.\n\nParameters:\n- **explicit_start** (bool): If True, the YAML Start-of-Document marker (---<EOL>) is included in the output. Default is True.\n- **explode_aliases** (bool): If True, all aliases (*name) and YAML merge operators (<<: *name) are expanded to their referenced content, removing them from the output. Default is False.\n- **preserve_quotes** (bool): If True, all quoting of keys and values is retained, preserving the original quoting style (\" vs '). Default is True.\n\nReturns:\n- **YAML**: A fully configured YAML editor instance that is ready for use.\n\nThe function utilizes the `maxsize` constant from the `sys` module to set YAML line width, ensuring compatibility with the largest possible integer. It also handles missing type-checking in `ruamel.yaml` by using type ignores in relevant attribute assignments.\"\"\"\n        '\\n        Build and return a generic YAML editor based on ruamel.yaml.\\n\\n        Parameters:  N/A\\n\\n        Keyword Arguments:\\n        * explicit_start (bool) True = ensure the YAML Start-of-Document marker\\n          (---<EOL>) is written in the output; False = remove it; default=True\\n        * explode_aliases (bool) True = convert all aliases (*name) and YAML\\n          merge operators (<<: *name) to their referenced content, removing the\\n          aliases and merge operators; False = maintain the references;\\n          default=False\\n        * preserve_quotes (bool) True = retain any and all quoting of keys and\\n          values including whatever demarcation symbol was used (\" versus \\');\\n          False = only quote values when necessary, removing unnecessary\\n          demarcation; default=True\\n\\n        Returns (Any) The ready-for-use YAML editor.\\n\\n        Raises:  N/A\\n        '\n        explicit_start = kwargs.pop('explicit_start', True)\n        explode_aliases = kwargs.pop('explode_aliases', False)\n        preserve_quotes = kwargs.pop('preserve_quotes', True)\n        yaml = YAML()\n        yaml.indent(mapping=2, sequence=4, offset=2)\n        yaml.explicit_start = explicit_start\n        yaml.preserve_quotes = preserve_quotes\n        yaml.width = maxsize\n        if explode_aliases:\n            yaml.default_flow_style = False\n        return yaml",
        "docstring": "Builds and returns a configured YAML editor using the `ruamel.yaml` library. This editor can be customized with parameters to control document formatting, such as whether to include the YAML Start-of-Document marker, how to handle aliases, and the preservation of quotes.\n\nParameters:\n- **explicit_start** (bool): If True, the YAML Start-of-Document marker (---<EOL>) is included in the output. Default is True.\n- **explode_aliases** (bool): If True, all aliases (*name) and YAML merge operators (<<: *name) are expanded to their referenced content, removing them from the output. Default is False.\n- **preserve_quotes** (bool): If True, all quoting of keys and values is retained, preserving the original quoting style (\" vs '). Default is True.\n\nReturns:\n- **YAML**: A fully configured YAML editor instance that is ready for use.\n\nThe function utilizes the `maxsize` constant from the `sys` module to set YAML line width, ensuring compatibility with the largest possible integer. It also handles missing type-checking in `ruamel.yaml` by using type ignores in relevant attribute assignments.",
        "signature": "def get_yaml_editor(**kwargs: Any) -> YAML:",
        "type": "Method",
        "class_signature": "class Parsers:"
      },
      "Parsers.get_yaml_data": {
        "code": "    def get_yaml_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Tuple[Any, bool]:\n        \"\"\"Parse YAML or compatible data and return the result along with a success state.\n\nParameters:\n- parser (ruamel.yaml.YAML): The YAML parser instance from the ruamel.yaml library used to load YAML data.\n- logger (ConsolePrinter): An instance of ConsolePrinter for logging errors or other messages during parsing.\n- source (str): A string representing the path to the YAML file or literal data. If set to \"-\", the function reads from standard input (STDIN).\n- **kwargs: Optional keyword arguments, including:\n    - literal (bool): If True, the source is treated as literal serialized YAML data rather than a file path.\n\nReturns:\nTuple[Any, bool]: A tuple containing the parsed YAML document and a success state (True if parsing was successful, False otherwise). The document will be None if it was empty or could not be read.\n\nSide Effects:\nThe function captures and logs various errors and warnings related to YAML parsing, ensuring that the user receives meaningful messages instead of lengthy stack traces. The `data_available` variable tracks whether the data was successfully retrieved.\"\"\"\n        '\\n        Parse YAML/Compatible data and return the ruamel.yaml object result.\\n\\n        All known issues are caught and distinctively logged.\\n\\n        Parameters:\\n        1. parser (ruamel.yaml.YAML) The YAML data parser\\n        2. logger (ConsolePrinter) The logging facility\\n        3. source (str) The source file or serialized literal to load; can be -\\n           for reading from STDIN (implies literal=True)\\n\\n        Keyword Arguments:\\n        * literal (bool) `source` is literal serialized YAML data rather than a\\n          file-spec, so load it directly\\n\\n        Returns:  Tuple[Any, bool] A tuple containing the document and its\\n        success/fail state.  The first field is the parsed document; will be\\n        None for empty documents and for documents which could not be read.\\n        The second field will be True when there were no errors during parsing\\n        and False, otherwise.\\n        '\n        literal = kwargs.pop('literal', False)\n        yaml_data = None\n        data_available = True\n        try:\n            with warnings.catch_warnings():\n                warnings.filterwarnings('error')\n                if source == '-':\n                    yaml_data = parser.load(stdin.read())\n                elif literal:\n                    yaml_data = parser.load(source)\n                else:\n                    with open(source, 'r', encoding='utf-8') as fhnd:\n                        yaml_data = parser.load(fhnd)\n        except KeyboardInterrupt:\n            logger.error('Aborting data load due to keyboard interrupt!')\n            data_available = False\n        except FileNotFoundError:\n            logger.error('File not found:  {}'.format(source))\n            data_available = False\n        except ParserError as ex:\n            logger.error('YAML parsing error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ComposerError as ex:\n            logger.error('YAML composition error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ConstructorError as ex:\n            logger.error('YAML construction error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except ScannerError as ex:\n            logger.error('YAML syntax error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n            data_available = False\n        except DuplicateKeyError as dke:\n            omits = ['while constructing', 'To suppress this', 'readthedocs', 'future releases', 'the new API']\n            message = str(dke).split('\\n')\n            newmsg = ''\n            for line in message:\n                line = line.strip()\n                if not line:\n                    continue\n                write_line = True\n                for omit in omits:\n                    if omit in line:\n                        write_line = False\n                        break\n                if write_line:\n                    newmsg += '\\n   ' + line\n            logger.error('Duplicate Hash key detected:  {}'.format(newmsg))\n            data_available = False\n        except ReusedAnchorWarning as raw:\n            logger.error('Duplicate YAML Anchor detected:  {}'.format(str(raw).replace('occurrence   ', 'occurrence ').replace('\\n', '\\n   ')))\n            data_available = False\n        return (yaml_data, data_available)",
        "docstring": "Parse YAML or compatible data and return the result along with a success state.\n\nParameters:\n- parser (ruamel.yaml.YAML): The YAML parser instance from the ruamel.yaml library used to load YAML data.\n- logger (ConsolePrinter): An instance of ConsolePrinter for logging errors or other messages during parsing.\n- source (str): A string representing the path to the YAML file or literal data. If set to \"-\", the function reads from standard input (STDIN).\n- **kwargs: Optional keyword arguments, including:\n    - literal (bool): If True, the source is treated as literal serialized YAML data rather than a file path.\n\nReturns:\nTuple[Any, bool]: A tuple containing the parsed YAML document and a success state (True if parsing was successful, False otherwise). The document will be None if it was empty or could not be read.\n\nSide Effects:\nThe function captures and logs various errors and warnings related to YAML parsing, ensuring that the user receives meaningful messages instead of lengthy stack traces. The `data_available` variable tracks whether the data was successfully retrieved.",
        "signature": "def get_yaml_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Tuple[Any, bool]:",
        "type": "Method",
        "class_signature": "class Parsers:"
      },
      "Parsers.get_yaml_multidoc_data": {
        "code": "    def get_yaml_multidoc_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Generator[Tuple[Any, bool], None, None]:\n        \"\"\"Parse YAML-compatible multi-document data and yield each parsed result.\n\nThis method uses a specified YAML parser to read multiple documents from a given source (either a file or STDIN) and yields each parsed document along with a boolean indicating success or failure. It also manages and logs errors encountered during parsing.\n\nParameters:\n- parser (Any): An instance of `ruamel.yaml.YAML`, the YAML data parser to handle the parsing operations.\n- logger (ConsolePrinter): An instance of `ConsolePrinter` used for logging errors and debugging information.\n- source (str): The path to the source file to load, or '-' to read from STDIN.\n- **kwargs: Accepts a keyword argument 'literal' (bool), which indicates whether the 'source' contains direct YAML data (if True) rather than a file path.\n\nReturns:\nGenerator[Tuple[Any, bool], None, None]: Yields a tuple for each document parsed; the first element is the parsed document (or None for failures), and the second element indicates if the parsing was successful (True) or if an error occurred (False).\n\nErrors and warnings during parsing are captured and logged, including file not found errors and various YAML parsing exceptions. The `has_error` flag is used to track if any errors occurred during processing, influencing the output generated at the end.\"\"\"\n        '\\n        Parse YAML/Compatible multi-docs and yield each ruamel.yaml object.\\n\\n        All known issues are caught and distinctively logged.\\n\\n        Parameters:\\n        1. parser (ruamel.yaml.YAML) The YAML data parser\\n        2. logger (ConsolePrinter) The logging facility\\n        3. source (str) The source file to load; can be - for reading from\\n           STDIN\\n\\n        Keyword Arguments:\\n        * literal (bool) `source` is literal serialized YAML data rather than a\\n          file-spec, so load it directly\\n\\n        Returns:  Generator[Tuple[Any, bool], None, None] A tuple for each\\n        document as it is parsed.  The first field is the parsed document; will\\n        be None for empty documents and for documents which could not be read.\\n        The second field will be True when there were no errors during parsing\\n        and False, otherwise.\\n        '\n        literal = kwargs.pop('literal', False)\n        has_error = False\n        try:\n            with warnings.catch_warnings():\n                warnings.filterwarnings('error')\n                if source == '-':\n                    doc_yielded = False\n                    for document in parser.load_all(stdin.read()):\n                        doc_yielded = True\n                        logger.debug('Yielding document from {}:'.format(source), prefix='get_yaml_multidoc_data: ', data=document)\n                        yield (document, True)\n                    if not doc_yielded:\n                        yield ('', True)\n                elif literal:\n                    for document in parser.load_all(source):\n                        yield (document, True)\n                else:\n                    with open(source, 'r', encoding='utf-8') as fhnd:\n                        for document in parser.load_all(fhnd):\n                            logger.debug('Yielding document from {}:'.format(source), prefix='get_yaml_multidoc_data: ', data=document)\n                            yield (document, True)\n        except KeyboardInterrupt:\n            has_error = True\n            logger.error('Aborting data load due to keyboard interrupt!')\n        except FileNotFoundError:\n            has_error = True\n            logger.error('File not found:  {}'.format(source))\n        except ParserError as ex:\n            has_error = True\n            logger.error('YAML parsing error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ComposerError as ex:\n            has_error = True\n            logger.error('YAML composition error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ConstructorError as ex:\n            has_error = True\n            logger.error('YAML construction error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n        except ScannerError as ex:\n            has_error = True\n            logger.error('YAML syntax error {}:  {}'.format(str(ex.problem_mark).lstrip(), ex.problem))\n        except DuplicateKeyError as dke:\n            has_error = True\n            omits = ['while constructing', 'To suppress this', 'readthedocs', 'future releases', 'the new API']\n            message = str(dke).split('\\n')\n            newmsg = ''\n            for line in message:\n                line = line.strip()\n                if not line:\n                    continue\n                write_line = True\n                for omit in omits:\n                    if omit in line:\n                        write_line = False\n                        break\n                if write_line:\n                    newmsg += '\\n   ' + line\n            logger.error('Duplicate Hash key detected:  {}'.format(newmsg))\n        except ReusedAnchorWarning as raw:\n            has_error = True\n            logger.error('Duplicate YAML Anchor detected:  {}'.format(str(raw).replace('occurrence   ', 'occurrence ').replace('\\n', '\\n   ')))\n        if has_error:\n            yield (None, False)",
        "docstring": "Parse YAML-compatible multi-document data and yield each parsed result.\n\nThis method uses a specified YAML parser to read multiple documents from a given source (either a file or STDIN) and yields each parsed document along with a boolean indicating success or failure. It also manages and logs errors encountered during parsing.\n\nParameters:\n- parser (Any): An instance of `ruamel.yaml.YAML`, the YAML data parser to handle the parsing operations.\n- logger (ConsolePrinter): An instance of `ConsolePrinter` used for logging errors and debugging information.\n- source (str): The path to the source file to load, or '-' to read from STDIN.\n- **kwargs: Accepts a keyword argument 'literal' (bool), which indicates whether the 'source' contains direct YAML data (if True) rather than a file path.\n\nReturns:\nGenerator[Tuple[Any, bool], None, None]: Yields a tuple for each document parsed; the first element is the parsed document (or None for failures), and the second element indicates if the parsing was successful (True) or if an error occurred (False).\n\nErrors and warnings during parsing are captured and logged, including file not found errors and various YAML parsing exceptions. The `has_error` flag is used to track if any errors occurred during processing, influencing the output generated at the end.",
        "signature": "def get_yaml_multidoc_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Generator[Tuple[Any, bool], None, None]:",
        "type": "Method",
        "class_signature": "class Parsers:"
      },
      "Parsers.stringify_dates": {
        "code": "    def stringify_dates(data: Any) -> Any:\n        \"\"\"Recursively traverse a data structure to convert all date objects into strings formatted as ISO 8601.\n\nParameters:\n- data (Any): The data structure to be processed, which can include various types such as dictionaries, lists, or native date types.\n\nReturns:\n- Any: The modified data structure where all instances of datetime and date have been converted to strings; other types remain unchanged.\n\nThis method is particularly useful for preparing data for JSON serialization, as native date objects are not supported by JSON. It can handle data types defined in the ruamel.yaml library, such as CommentedMap and CommentedSeq, ensuring any nested dates within these structures are also converted. The method might be replaced by the more comprehensive jsonify_yaml_data in future versions.\"\"\"\n        '\\n        Recurse through a data structure, converting all dates to strings.\\n\\n        The jsonify_yaml_data covers more data-types than just dates.  This\\n        stringify_dates method may be removed in a future version in favor of\\n        the more comprehensive jsonify_yaml_data method.\\n\\n        This is required for JSON output, which has no serialization support\\n        for native date objects.\\n        '\n        if isinstance(data, CommentedMap):\n            for key, val in data.items():\n                data[key] = Parsers.stringify_dates(val)\n        elif isinstance(data, CommentedSeq):\n            for idx, ele in enumerate(data):\n                data[idx] = Parsers.stringify_dates(ele)\n        elif isinstance(data, (datetime, date)):\n            return data.isoformat()\n        return data",
        "docstring": "Recursively traverse a data structure to convert all date objects into strings formatted as ISO 8601.\n\nParameters:\n- data (Any): The data structure to be processed, which can include various types such as dictionaries, lists, or native date types.\n\nReturns:\n- Any: The modified data structure where all instances of datetime and date have been converted to strings; other types remain unchanged.\n\nThis method is particularly useful for preparing data for JSON serialization, as native date objects are not supported by JSON. It can handle data types defined in the ruamel.yaml library, such as CommentedMap and CommentedSeq, ensuring any nested dates within these structures are also converted. The method might be replaced by the more comprehensive jsonify_yaml_data in future versions.",
        "signature": "def stringify_dates(data: Any) -> Any:",
        "type": "Method",
        "class_signature": "class Parsers:"
      },
      "Parsers.jsonify_yaml_data": {
        "code": "    def jsonify_yaml_data(data: Any) -> Any:\n        \"\"\"Convert all non-JSON-serializable values in a data structure to their string equivalents.\n\nThis method handles various data types while preparing them for JSON serialization, as JSON does not support certain YAML-specific extensions, such as tags and native date types. It traverses the input data (which can be a dictionary, list, set, or specialized ruamel.yaml types) and converts them as follows:\n- `CommentedMap` and `CommentedSeq` objects are recursively processed.\n- `datetime`, `date`, `AnchoredDate`, and `AnchoredTimeStamp` objects are converted to ISO 8601 string formats.\n- Boolean values and `ScalarBoolean` types are cast to their Python boolean counterparts.\n- The method also addresses `TaggedScalar` objects and handles any null representations.\n\nParameters:\n- data (Any): The input data structure, which may contain various types that need to be converted.\n\nReturns:\n- Any: The transformed data structure with all non-JSON-serializable values converted to strings or appropriate types.\n\nDependencies:\n- This method relies on types from `ruamel.yaml` such as `CommentedMap`, `CommentedSeq`, `TaggedScalar`, and others, which are defined and imported at the beginning of the code.\"\"\"\n        '\\n        Convert all non-JSON-serializable values to strings.\\n\\n        This is required when writing to JSON, which has no serialization\\n        support for certain YAML extensions -- like tags -- and some otherwise\\n        native data-types, like dates.\\n        '\n        if isinstance(data, CommentedMap):\n            for i, k in [(idx, key) for idx, key in enumerate(data.keys()) if isinstance(key, TaggedScalar)]:\n                unwrapped_key = Parsers.jsonify_yaml_data(k)\n                data.insert(i, unwrapped_key, data.pop(k))\n            for key, val in data.items():\n                data[key] = Parsers.jsonify_yaml_data(val)\n        elif isinstance(data, dict):\n            for key, val in data.items():\n                data[key] = Parsers.jsonify_yaml_data(val)\n        elif isinstance(data, (list, CommentedSeq)):\n            for idx, ele in enumerate(data):\n                data[idx] = Parsers.jsonify_yaml_data(ele)\n        elif isinstance(data, (set, CommentedSet)):\n            json_repr: Dict[str, None] = {}\n            for set_val in data:\n                json_key_proto = Parsers.jsonify_yaml_data(set_val)\n                json_key = str(json_key_proto) if isinstance(json_key_proto, tuple) else json_key_proto\n                json_repr[json_key] = None\n            data = json_repr\n        elif isinstance(data, TaggedScalar):\n            if data.tag.value == '!null':\n                return None\n            data = Parsers.jsonify_yaml_data(data.value)\n        elif isinstance(data, AnchoredDate):\n            data = data.date().isoformat()\n        elif isinstance(data, AnchoredTimeStamp):\n            data = Nodes.get_timestamp_with_tzinfo(data).isoformat()\n        elif isinstance(data, (datetime, date)):\n            data = data.isoformat()\n        elif isinstance(data, bytes):\n            data = str(data)\n        elif isinstance(data, (ScalarBoolean, bool)):\n            data = bool(data)\n        return data",
        "docstring": "Convert all non-JSON-serializable values in a data structure to their string equivalents.\n\nThis method handles various data types while preparing them for JSON serialization, as JSON does not support certain YAML-specific extensions, such as tags and native date types. It traverses the input data (which can be a dictionary, list, set, or specialized ruamel.yaml types) and converts them as follows:\n- `CommentedMap` and `CommentedSeq` objects are recursively processed.\n- `datetime`, `date`, `AnchoredDate`, and `AnchoredTimeStamp` objects are converted to ISO 8601 string formats.\n- Boolean values and `ScalarBoolean` types are cast to their Python boolean counterparts.\n- The method also addresses `TaggedScalar` objects and handles any null representations.\n\nParameters:\n- data (Any): The input data structure, which may contain various types that need to be converted.\n\nReturns:\n- Any: The transformed data structure with all non-JSON-serializable values converted to strings or appropriate types.\n\nDependencies:\n- This method relies on types from `ruamel.yaml` such as `CommentedMap`, `CommentedSeq`, `TaggedScalar`, and others, which are defined and imported at the beginning of the code.",
        "signature": "def jsonify_yaml_data(data: Any) -> Any:",
        "type": "Method",
        "class_signature": "class Parsers:"
      }
    },
    "yamlpath/patches/timestamp.py": {
      "AnchoredTimeStamp.__init__": {
        "code": "    def __init__(self, *args: Any, **kw: Any) -> None:\n        \"\"\"Initialize a new instance of the AnchoredTimeStamp class, which extends\nthe TimeStamp class from the ruamel.yaml library to include support for \nYAML Anchors. This constructor sets up an internal dictionary `_yaml` \nthat tracks additional attributes: 't' (a boolean indicating if the \ntimestamp is tagged), 'tz' (time zone information), and 'delta' (a \ntime delta adjustment).\n\nParameters:\n    *args: Positional arguments corresponding to the date and time \n           components, which are forwarded to the parent TimeStamp \n           constructor.\n    **kw: Keyword arguments used for additional options, such as \n           'anchor', which specifies the YAML anchor for the instance.\n\nReturns:\n    None: This method does not return a value but initializes the \n    instance's state.\n\nAttributes:\n    _yaml (dict): A dictionary initialized with default values \n    for 't', 'tz', and 'delta', utilized in other class methods \n    to manage the timestamp's YAML representation.\"\"\"\n        'Initialize a new instance.'\n        self._yaml: Dict[Any, Any] = dict(t=False, tz=None, delta=0)",
        "docstring": "Initialize a new instance of the AnchoredTimeStamp class, which extends\nthe TimeStamp class from the ruamel.yaml library to include support for \nYAML Anchors. This constructor sets up an internal dictionary `_yaml` \nthat tracks additional attributes: 't' (a boolean indicating if the \ntimestamp is tagged), 'tz' (time zone information), and 'delta' (a \ntime delta adjustment).\n\nParameters:\n    *args: Positional arguments corresponding to the date and time \n           components, which are forwarded to the parent TimeStamp \n           constructor.\n    **kw: Keyword arguments used for additional options, such as \n           'anchor', which specifies the YAML anchor for the instance.\n\nReturns:\n    None: This method does not return a value but initializes the \n    instance's state.\n\nAttributes:\n    _yaml (dict): A dictionary initialized with default values \n    for 't', 'tz', and 'delta', utilized in other class methods \n    to manage the timestamp's YAML representation.",
        "signature": "def __init__(self, *args: Any, **kw: Any) -> None:",
        "type": "Method",
        "class_signature": "class AnchoredTimeStamp(TimeStamp):"
      },
      "AnchoredTimeStamp.__new__": {
        "code": "    def __new__(cls, *args: Any, **kw: Any) -> Any:\n        \"\"\"Create a new immutable instance of AnchoredTimeStamp.\n\nThis method overrides the default `__new__` method to initialize an instance of AnchoredTimeStamp, ensuring it tracks YAML anchors. It takes variable positional and keyword arguments, the latter of which can include an 'anchor' key for YAML. If an anchor is provided, it is set on the instance using the `yaml_set_anchor` method with `always_dump` set to `True`.\n\nParameters:\n- cls: The class to instantiate (typically AnchoredTimeStamp).\n- args: Positional arguments corresponding to the parameters of TimeStamp.\n- kw: Keyword arguments that may include 'anchor'.\n\nReturns:\n- An instance of AnchoredTimeStamp, which is immutable.\n\nThis method is dependent on the TimeStamp class from the `ruamel.yaml.timestamp` module, which provides the core functionality for handling timestamps in YAML.\"\"\"\n        'Create a new, immutable instance.'\n        anchor = kw.pop('anchor', None)\n        ts = TimeStamp.__new__(cls, *args, **kw)\n        if anchor is not None:\n            ts.yaml_set_anchor(anchor, always_dump=True)\n        return ts",
        "docstring": "Create a new immutable instance of AnchoredTimeStamp.\n\nThis method overrides the default `__new__` method to initialize an instance of AnchoredTimeStamp, ensuring it tracks YAML anchors. It takes variable positional and keyword arguments, the latter of which can include an 'anchor' key for YAML. If an anchor is provided, it is set on the instance using the `yaml_set_anchor` method with `always_dump` set to `True`.\n\nParameters:\n- cls: The class to instantiate (typically AnchoredTimeStamp).\n- args: Positional arguments corresponding to the parameters of TimeStamp.\n- kw: Keyword arguments that may include 'anchor'.\n\nReturns:\n- An instance of AnchoredTimeStamp, which is immutable.\n\nThis method is dependent on the TimeStamp class from the `ruamel.yaml.timestamp` module, which provides the core functionality for handling timestamps in YAML.",
        "signature": "def __new__(cls, *args: Any, **kw: Any) -> Any:",
        "type": "Method",
        "class_signature": "class AnchoredTimeStamp(TimeStamp):"
      }
    }
  },
  "dependency_dict": {
    "yamlpath/common/parsers.py:Parsers:stringify_dates": {},
    "yamlpath/common/parsers.py:Parsers:jsonify_yaml_data": {}
  },
  "call_tree": {
    "tests/test_common_parsers.py:Test_common_parsers:test_get_yaml_data_literally": {
      "yamlpath/common/parsers.py:Parsers:get_yaml_editor": {},
      "yamlpath/common/parsers.py:Parsers:get_yaml_data": {}
    },
    "tests/test_common_parsers.py:Test_common_parsers:test_get_yaml_multidoc_data_literally": {
      "yamlpath/common/parsers.py:Parsers:get_yaml_editor": {},
      "yamlpath/common/parsers.py:Parsers:get_yaml_multidoc_data": {}
    },
    "tests/test_common_parsers.py:Test_common_parsers:test_stringify_complex_data_with_dates": {
      "yamlpath/common/parsers.py:Parsers:stringify_dates": {
        "yamlpath/common/parsers.py:Parsers:stringify_dates": {
          "[ignored_or_cut_off]": "..."
        }
      }
    },
    "tests/test_common_parsers.py:Test_common_parsers:test_jsonify_complex_ruamel_data": {
      "yamlpath/patches/timestamp.py:AnchoredTimeStamp:__new__": {},
      "yamlpath/patches/timestamp.py:AnchoredTimeStamp:__init__": {},
      "yamlpath/common/parsers.py:Parsers:jsonify_yaml_data": {
        "yamlpath/common/parsers.py:Parsers:jsonify_yaml_data": {
          "[ignored_or_cut_off]": "..."
        }
      }
    },
    "tests/test_common_parsers.py:Test_common_parsers:test_jsonify_complex_python_data": {
      "yamlpath/common/parsers.py:Parsers:jsonify_yaml_data": {
        "yamlpath/common/parsers.py:Parsers:jsonify_yaml_data": {
          "[ignored_or_cut_off]": "..."
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: yamlpath-test_common_parsers\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamlpath/\n    \u251c\u2500\u2500 common/\n    \u2502   \u2514\u2500\u2500 parsers.py\n    \u2502       \u251c\u2500\u2500 Parsers.get_yaml_data\n    \u2502       \u251c\u2500\u2500 Parsers.get_yaml_editor\n    \u2502       \u251c\u2500\u2500 Parsers.get_yaml_multidoc_data\n    \u2502       \u251c\u2500\u2500 Parsers.jsonify_yaml_data\n    \u2502       \u2514\u2500\u2500 Parsers.stringify_dates\n    \u2514\u2500\u2500 patches/\n        \u2514\u2500\u2500 timestamp.py\n            \u251c\u2500\u2500 AnchoredTimeStamp.__init__\n            \u2514\u2500\u2500 AnchoredTimeStamp.__new__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides utilities for parsing, processing, and converting YAML data structures using the `ruamel.yaml` library. It supports loading YAML data both as single documents and multi-document streams while preserving data integrity and enabling seamless manipulation of nested structures. Additionally, the module includes functionality to transform complex YAML data, such as dates, tagged values, and boolean types, into a JSON-compatible format to ensure interoperability with other systems and applications. By standardizing YAML handling and offering robust compatibility with JSON, the module simplifies the integration and processing of structured data for developers, addressing common challenges in handling heterogeneous data formats.\n\n## FILE 1: yamlpath/common/parsers.py\n\n- CLASS METHOD: Parsers.jsonify_yaml_data\n  - CLASS SIGNATURE: class Parsers:\n  - SIGNATURE: def jsonify_yaml_data(data: Any) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nConvert all non-JSON-serializable values in a data structure to their string equivalents.\n\nThis method handles various data types while preparing them for JSON serialization, as JSON does not support certain YAML-specific extensions, such as tags and native date types. It traverses the input data (which can be a dictionary, list, set, or specialized ruamel.yaml types) and converts them as follows:\n- `CommentedMap` and `CommentedSeq` objects are recursively processed.\n- `datetime`, `date`, `AnchoredDate`, and `AnchoredTimeStamp` objects are converted to ISO 8601 string formats.\n- Boolean values and `ScalarBoolean` types are cast to their Python boolean counterparts.\n- The method also addresses `TaggedScalar` objects and handles any null representations.\n\nParameters:\n- data (Any): The input data structure, which may contain various types that need to be converted.\n\nReturns:\n- Any: The transformed data structure with all non-JSON-serializable values converted to strings or appropriate types.\n\nDependencies:\n- This method relies on types from `ruamel.yaml` such as `CommentedMap`, `CommentedSeq`, `TaggedScalar`, and others, which are defined and imported at the beginning of the code.\n\"\"\"\n```\n\n- CLASS METHOD: Parsers.stringify_dates\n  - CLASS SIGNATURE: class Parsers:\n  - SIGNATURE: def stringify_dates(data: Any) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nRecursively traverse a data structure to convert all date objects into strings formatted as ISO 8601.\n\nParameters:\n- data (Any): The data structure to be processed, which can include various types such as dictionaries, lists, or native date types.\n\nReturns:\n- Any: The modified data structure where all instances of datetime and date have been converted to strings; other types remain unchanged.\n\nThis method is particularly useful for preparing data for JSON serialization, as native date objects are not supported by JSON. It can handle data types defined in the ruamel.yaml library, such as CommentedMap and CommentedSeq, ensuring any nested dates within these structures are also converted. The method might be replaced by the more comprehensive jsonify_yaml_data in future versions.\n\"\"\"\n```\n\n- CLASS METHOD: Parsers.get_yaml_data\n  - CLASS SIGNATURE: class Parsers:\n  - SIGNATURE: def get_yaml_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Tuple[Any, bool]:\n  - DOCSTRING: \n```python\n\"\"\"\nParse YAML or compatible data and return the result along with a success state.\n\nParameters:\n- parser (ruamel.yaml.YAML): The YAML parser instance from the ruamel.yaml library used to load YAML data.\n- logger (ConsolePrinter): An instance of ConsolePrinter for logging errors or other messages during parsing.\n- source (str): A string representing the path to the YAML file or literal data. If set to \"-\", the function reads from standard input (STDIN).\n- **kwargs: Optional keyword arguments, including:\n    - literal (bool): If True, the source is treated as literal serialized YAML data rather than a file path.\n\nReturns:\nTuple[Any, bool]: A tuple containing the parsed YAML document and a success state (True if parsing was successful, False otherwise). The document will be None if it was empty or could not be read.\n\nSide Effects:\nThe function captures and logs various errors and warnings related to YAML parsing, ensuring that the user receives meaningful messages instead of lengthy stack traces. The `data_available` variable tracks whether the data was successfully retrieved.\n\"\"\"\n```\n\n- CLASS METHOD: Parsers.get_yaml_editor\n  - CLASS SIGNATURE: class Parsers:\n  - SIGNATURE: def get_yaml_editor(**kwargs: Any) -> YAML:\n  - DOCSTRING: \n```python\n\"\"\"\nBuilds and returns a configured YAML editor using the `ruamel.yaml` library. This editor can be customized with parameters to control document formatting, such as whether to include the YAML Start-of-Document marker, how to handle aliases, and the preservation of quotes.\n\nParameters:\n- **explicit_start** (bool): If True, the YAML Start-of-Document marker (---<EOL>) is included in the output. Default is True.\n- **explode_aliases** (bool): If True, all aliases (*name) and YAML merge operators (<<: *name) are expanded to their referenced content, removing them from the output. Default is False.\n- **preserve_quotes** (bool): If True, all quoting of keys and values is retained, preserving the original quoting style (\" vs '). Default is True.\n\nReturns:\n- **YAML**: A fully configured YAML editor instance that is ready for use.\n\nThe function utilizes the `maxsize` constant from the `sys` module to set YAML line width, ensuring compatibility with the largest possible integer. It also handles missing type-checking in `ruamel.yaml` by using type ignores in relevant attribute assignments.\n\"\"\"\n```\n\n- CLASS METHOD: Parsers.get_yaml_multidoc_data\n  - CLASS SIGNATURE: class Parsers:\n  - SIGNATURE: def get_yaml_multidoc_data(parser: Any, logger: ConsolePrinter, source: str, **kwargs) -> Generator[Tuple[Any, bool], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nParse YAML-compatible multi-document data and yield each parsed result.\n\nThis method uses a specified YAML parser to read multiple documents from a given source (either a file or STDIN) and yields each parsed document along with a boolean indicating success or failure. It also manages and logs errors encountered during parsing.\n\nParameters:\n- parser (Any): An instance of `ruamel.yaml.YAML`, the YAML data parser to handle the parsing operations.\n- logger (ConsolePrinter): An instance of `ConsolePrinter` used for logging errors and debugging information.\n- source (str): The path to the source file to load, or '-' to read from STDIN.\n- **kwargs: Accepts a keyword argument 'literal' (bool), which indicates whether the 'source' contains direct YAML data (if True) rather than a file path.\n\nReturns:\nGenerator[Tuple[Any, bool], None, None]: Yields a tuple for each document parsed; the first element is the parsed document (or None for failures), and the second element indicates if the parsing was successful (True) or if an error occurred (False).\n\nErrors and warnings during parsing are captured and logged, including file not found errors and various YAML parsing exceptions. The `has_error` flag is used to track if any errors occurred during processing, influencing the output generated at the end.\n\"\"\"\n```\n\n## FILE 2: yamlpath/patches/timestamp.py\n\n- CLASS METHOD: AnchoredTimeStamp.__new__\n  - CLASS SIGNATURE: class AnchoredTimeStamp(TimeStamp):\n  - SIGNATURE: def __new__(cls, *args: Any, **kw: Any) -> Any:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new immutable instance of AnchoredTimeStamp.\n\nThis method overrides the default `__new__` method to initialize an instance of AnchoredTimeStamp, ensuring it tracks YAML anchors. It takes variable positional and keyword arguments, the latter of which can include an 'anchor' key for YAML. If an anchor is provided, it is set on the instance using the `yaml_set_anchor` method with `always_dump` set to `True`.\n\nParameters:\n- cls: The class to instantiate (typically AnchoredTimeStamp).\n- args: Positional arguments corresponding to the parameters of TimeStamp.\n- kw: Keyword arguments that may include 'anchor'.\n\nReturns:\n- An instance of AnchoredTimeStamp, which is immutable.\n\nThis method is dependent on the TimeStamp class from the `ruamel.yaml.timestamp` module, which provides the core functionality for handling timestamps in YAML.\n\"\"\"\n```\n\n- CLASS METHOD: AnchoredTimeStamp.__init__\n  - CLASS SIGNATURE: class AnchoredTimeStamp(TimeStamp):\n  - SIGNATURE: def __init__(self, *args: Any, **kw: Any) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a new instance of the AnchoredTimeStamp class, which extends\nthe TimeStamp class from the ruamel.yaml library to include support for \nYAML Anchors. This constructor sets up an internal dictionary `_yaml` \nthat tracks additional attributes: 't' (a boolean indicating if the \ntimestamp is tagged), 'tz' (time zone information), and 'delta' (a \ntime delta adjustment).\n\nParameters:\n    *args: Positional arguments corresponding to the date and time \n           components, which are forwarded to the parent TimeStamp \n           constructor.\n    **kw: Keyword arguments used for additional options, such as \n           'anchor', which specifies the YAML anchor for the instance.\n\nReturns:\n    None: This method does not return a value but initializes the \n    instance's state.\n\nAttributes:\n    _yaml (dict): A dictionary initialized with default values \n    for 't', 'tz', and 'delta', utilized in other class methods \n    to manage the timestamp's YAML representation.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamlpath/common/parsers.py": "\"\"\"\nImplement Parsers, a static library of generally-useful code for data parsers.\n\nCopyright 2020, 2021 William W. Kimball, Jr. MBA MSIS\n\"\"\"\nimport warnings\nfrom sys import maxsize, stdin\nfrom datetime import date, datetime\nfrom typing import Any, Dict, Generator, Tuple\nimport ruamel.yaml\nfrom ruamel.yaml import YAML\nfrom ruamel.yaml.parser import ParserError\nfrom ruamel.yaml.composer import ComposerError, ReusedAnchorWarning\nfrom ruamel.yaml.constructor import ConstructorError, DuplicateKeyError\nfrom ruamel.yaml.scanner import ScannerError\nfrom ruamel.yaml.scalarbool import ScalarBoolean\nfrom ruamel.yaml.scalarstring import ScalarString\nfrom ruamel.yaml.comments import CommentedMap, CommentedSet, CommentedSeq, TaggedScalar\nfrom yamlpath.patches.timestamp import AnchoredTimeStamp, AnchoredDate\nfrom yamlpath.wrappers import ConsolePrinter\nfrom yamlpath.common import Nodes\n\nclass Parsers:\n    \"\"\"Helper methods for common YAML/JSON/Compatible parser operations.\"\"\"\n\n    @staticmethod\n    def delete_all_comments(dom: Any) -> None:\n        \"\"\"\n        Recursively delete all comments from a YAML document.\n\n        See:\n        https://stackoverflow.com/questions/60080325/how-to-delete-all-comments-in-ruamel-yaml/60099750#60099750\n\n        Parameters:\n        1. dom (Any) The document to strip of all comments.\n\n        Returns:  N/A\n        \"\"\"\n        if dom is None:\n            return\n        if isinstance(dom, CommentedMap):\n            for key, val in dom.items():\n                Parsers.delete_all_comments(key)\n                Parsers.delete_all_comments(val)\n        elif isinstance(dom, CommentedSeq):\n            for ele in dom:\n                Parsers.delete_all_comments(ele)\n        try:\n            attr = 'comment' if isinstance(dom, ScalarString) else ruamel.yaml.comments.Comment.attrib\n            delattr(dom, attr)\n        except AttributeError:\n            pass\n\n    @staticmethod\n    def set_flow_style(node: Any, is_flow: bool) -> None:\n        \"\"\"\n        Recursively apply flow|block style to a node.\n\n        Parameters:\n        1. node (Any) The node to apply flow|block style to.\n        2. is_flow (bool) True=flow-style, False=block-style\n\n        Returns:  N/A\n        \"\"\"\n        if hasattr(node, 'fa'):\n            if is_flow:\n                node.fa.set_flow_style()\n            else:\n                node.fa.set_block_style()\n        if isinstance(node, CommentedMap):\n            for key, val in node.non_merged_items():\n                Parsers.set_flow_style(key, is_flow)\n                Parsers.set_flow_style(val, is_flow)\n        elif isinstance(node, CommentedSeq):\n            for ele in node:\n                Parsers.set_flow_style(ele, is_flow)",
    "yamlpath/patches/timestamp.py": "\"\"\"\nFix missing anchors from timestamp and date nodes.\n\nThis must be removed once incorporated into ruamel.yaml, likely at version\n0.17.22.\n\nSource: https://sourceforge.net/p/ruamel-yaml/tickets/440/\nCopyright 2022 Anthon van der Neut, William W. Kimball Jr. MBA MSIS\n\"\"\"\nimport ruamel.yaml\nfrom ruamel.yaml.constructor import ConstructorError\nfrom ruamel.yaml.anchor import Anchor\nfrom ruamel.yaml.timestamp import TimeStamp\nfrom typing import Any, Dict, Union\nimport datetime\nimport copy\n\nclass AnchoredTimeStamp(TimeStamp):\n    \"\"\"Extend TimeStamp to track YAML Anchors.\"\"\"\n\n    def __deepcopy__(self, memo: Any) -> Any:\n        \"\"\"Deeply copy this instance to another.\"\"\"\n        ts = AnchoredTimeStamp(self.year, self.month, self.day, self.hour, self.minute, self.second)\n        ts._yaml = copy.deepcopy(self._yaml)\n        return ts\n\n    @property\n    def anchor(self) -> Any:\n        \"\"\"Access the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            setattr(self, Anchor.attrib, Anchor())\n        return getattr(self, Anchor.attrib)\n\n    def yaml_anchor(self, any: bool=False) -> Any:\n        \"\"\"Get the YAML Anchor.\"\"\"\n        if not hasattr(self, Anchor.attrib):\n            return None\n        if any or self.anchor.always_dump:\n            return self.anchor\n        return None\n\n    def yaml_set_anchor(self, value: Any, always_dump: bool=False) -> None:\n        \"\"\"Set the YAML Anchor.\"\"\"\n        self.anchor.value = value\n        self.anchor.always_dump = always_dump\n\nclass AnchoredDate(AnchoredTimeStamp):\n    \"\"\"Define AnchoredDate.\"\"\"\n    pass\n\ndef construct_anchored_timestamp(self, node: Any, values: Any=None) -> Union[AnchoredTimeStamp, AnchoredDate]:\n    \"\"\"Construct an AnchoredTimeStamp.\"\"\"\n    try:\n        match = self.timestamp_regexp.match(node.value)\n    except TypeError:\n        match = None\n    if match is None:\n        raise ConstructorError(None, None, f'failed to construct timestamp from \"{node.value}\"', node.start_mark)\n    values = match.groupdict()\n    dd = ruamel.yaml.util.create_timestamp(**values)\n    delta = None\n    if values['tz_sign']:\n        tz_hour = int(values['tz_hour'])\n        minutes = values['tz_minute']\n        tz_minute = int(minutes) if minutes else 0\n        delta = datetime.timedelta(hours=tz_hour, minutes=tz_minute)\n        if values['tz_sign'] == '-':\n            delta = -delta\n    if isinstance(dd, datetime.datetime):\n        data = AnchoredTimeStamp(dd.year, dd.month, dd.day, dd.hour, dd.minute, dd.second, dd.microsecond, anchor=node.anchor)\n    else:\n        data = AnchoredDate(dd.year, dd.month, dd.day, 0, 0, 0, 0, anchor=node.anchor)\n        return data\n    if delta:\n        data._yaml['delta'] = delta\n        tz = values['tz_sign'] + values['tz_hour']\n        if values['tz_minute']:\n            tz += ':' + values['tz_minute']\n        data._yaml['tz'] = tz\n    elif values['tz']:\n        data._yaml['tz'] = values['tz']\n    if values['t']:\n        data._yaml['t'] = True\n    return data\nruamel.yaml.constructor.RoundTripConstructor.add_constructor('tag:yaml.org,2002:timestamp', construct_anchored_timestamp)\n\ndef represent_anchored_timestamp(self, data: Any):\n    \"\"\"Render an AnchoredTimeStamp.\"\"\"\n    try:\n        anchor = data.yaml_anchor()\n    except AttributeError:\n        anchor = None\n    inter = 'T' if data._yaml['t'] else ' '\n    _yaml = data._yaml\n    if _yaml['delta']:\n        data += _yaml['delta']\n    if isinstance(data, AnchoredDate):\n        value = data.date().isoformat()\n    else:\n        value = data.isoformat(inter)\n    if _yaml['tz']:\n        value += _yaml['tz']\n    return self.represent_scalar('tag:yaml.org,2002:timestamp', value, anchor=anchor)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredTimeStamp, represent_anchored_timestamp)\nruamel.yaml.representer.RoundTripRepresenter.add_representer(AnchoredDate, represent_anchored_timestamp)"
  }
}