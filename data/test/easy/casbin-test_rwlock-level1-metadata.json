{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_rwlock",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/util/test_rwlock.py",
  "test_code": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom unittest import TestCase\nfrom casbin.util.rwlock import RWLockWrite\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport queue\n\n\nclass TestRWLock(TestCase):\n    def gen_locks(self):\n        rw_lock = RWLockWrite()\n        rl = rw_lock.gen_rlock()\n        wl = rw_lock.gen_wlock()\n        return (rl, wl)\n\n    def test_multiple_readers(self):\n        [rl, _] = self.gen_locks()\n\n        delay = 5 / 1000  # 5ms\n        num_readers = 1000\n        start = time.time()\n\n        def read():\n            with rl:\n                time.sleep(delay)\n\n        executor = ThreadPoolExecutor(num_readers)\n        futures = [executor.submit(read) for i in range(num_readers)]\n        [future.result() for future in futures]\n        exec_time = time.time() - start\n\n        self.assertLess(exec_time, delay * num_readers)\n\n    def test_single_writer(self):\n        [_, wl] = self.gen_locks()\n\n        delay = 5 / 1000  # 5ms\n        num_writers = 10\n        start = time.time()\n\n        def write():\n            with wl:\n                time.sleep(delay)\n\n        executor = ThreadPoolExecutor(num_writers)\n        futures = [executor.submit(write) for i in range(num_writers)]\n        [future.result() for future in futures]\n        exec_time = time.time() - start\n\n        self.assertGreaterEqual(exec_time, delay * num_writers)\n\n    def test_writer_preference(self):\n        [rl, wl] = self.gen_locks()\n\n        q = queue.Queue()\n        delay = 5 / 1000  # 5ms\n        start = time.time()\n\n        def read():\n            with rl:\n                time.sleep(delay)\n                q.put(\"r\")\n\n        def write():\n            with wl:\n                time.sleep(delay)\n                q.put(\"w\")\n\n        executor = ThreadPoolExecutor(10)\n        futures = [executor.submit(read) for i in range(3)]\n        time.sleep(1 / 1000)\n        futures += [executor.submit(write) for i in range(3)]\n        time.sleep(1 / 1000)\n        futures += [executor.submit(read) for i in range(3)]\n        [future.result() for future in futures]\n\n        sequence = \"\"\n        while not q.empty():\n            sequence += q.get()\n\n        self.assertEqual(sequence, \"rrrwwwrrr\")\n",
  "GT_file_code": {
    "casbin/util/rwlock.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom threading import RLock, Condition\n\n# This implementation was adapted from https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock\n\n\nclass RWLockWrite:\n    \"\"\"write preferring readers-wirter lock\"\"\"\n\n    def __init__(self):\n        self._lock = RLock()\n        self._cond = Condition(self._lock)\n        self._active_readers = 0\n        self._waiting_writers = 0\n        self._writer_active = False\n\n    def aquire_read(self):\n        with self._lock:\n            while self._waiting_writers > 0 or self._writer_active:\n                self._cond.wait()\n            self._active_readers += 1\n\n    def release_read(self):\n        with self._lock:\n            self._active_readers -= 1\n            if self._active_readers == 0:\n                self._cond.notify_all()\n\n    def aquire_write(self):\n        with self._lock:\n            self._waiting_writers += 1\n            while self._active_readers > 0 or self._writer_active:\n                self._cond.wait()\n            self._waiting_writers -= 1\n            self._writer_active = True\n\n    def release_write(self):\n        with self._lock:\n            self._writer_active = False\n            self._cond.notify_all()\n\n    def gen_rlock(self):\n        return ReadRWLock(self)\n\n    def gen_wlock(self):\n        return WriteRWLock(self)\n\n\nclass ReadRWLock:\n    def __init__(self, rwlock):\n        self.rwlock = rwlock\n\n    def __enter__(self):\n        self.rwlock.aquire_read()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.rwlock.release_read()\n        return False\n\n\nclass WriteRWLock:\n    def __init__(self, rwlock):\n        self.rwlock = rwlock\n\n    def __enter__(self):\n        self.rwlock.aquire_write()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.rwlock.release_write()\n        return False\n"
  },
  "GT_src_dict": {
    "casbin/util/rwlock.py": {
      "RWLockWrite.__init__": {
        "code": "    def __init__(self):\n        \"\"\"Initializes an instance of the RWLockWrite class, which implements a write-preferential readers-writer lock mechanism. \n\n This constructor sets up the following attributes:\n \n - `self._lock`: A reentrant lock (RLock) used to synchronize access to shared resources.\n - `self._cond`: A condition variable associated with `_lock`, allowing threads to wait for state changes.\n - `self._active_readers`: An integer tracking the number of currently active readers accessing the resource.\n - `self._waiting_writers`: An integer counting the number of writers waiting to acquire the lock.\n - `self._writer_active`: A boolean indicating whether a writer is currently holding the lock.\n\n These attributes help manage concurrent access, ensuring that multiple readers can access a resource simultaneously while preventing writers from accessing it when readers are active.\"\"\"\n        self._lock = RLock()\n        self._cond = Condition(self._lock)\n        self._active_readers = 0\n        self._waiting_writers = 0\n        self._writer_active = False",
        "docstring": "Initializes an instance of the RWLockWrite class, which implements a write-preferential readers-writer lock mechanism. \n\nThis constructor sets up the following attributes:\n\n- `self._lock`: A reentrant lock (RLock) used to synchronize access to shared resources.\n- `self._cond`: A condition variable associated with `_lock`, allowing threads to wait for state changes.\n- `self._active_readers`: An integer tracking the number of currently active readers accessing the resource.\n- `self._waiting_writers`: An integer counting the number of writers waiting to acquire the lock.\n- `self._writer_active`: A boolean indicating whether a writer is currently holding the lock.\n\nThese attributes help manage concurrent access, ensuring that multiple readers can access a resource simultaneously while preventing writers from accessing it when readers are active.",
        "signature": "def __init__(self):",
        "type": "Method",
        "class_signature": "class RWLockWrite:"
      },
      "RWLockWrite.gen_rlock": {
        "code": "    def gen_rlock(self):\n        \"\"\"Generates a read lock for the RWLockWrite instance.\n\nThis method creates an instance of ReadRWLock, which provides a context manager for acquiring and releasing a read lock. The context manager ensures that the read lock is properly acquired and released, adhering to the locking mechanism defined in the RWLockWrite class.\n\nReturns:\n    ReadRWLock: An instance of ReadRWLock that manages the read lock context.\n\nDependencies:\n    Relies on the RWLockWrite class's methods `aquire_read` and `release_read` to manage access to shared resources.\"\"\"\n        return ReadRWLock(self)",
        "docstring": "Generates a read lock for the RWLockWrite instance.\n\nThis method creates an instance of ReadRWLock, which provides a context manager for acquiring and releasing a read lock. The context manager ensures that the read lock is properly acquired and released, adhering to the locking mechanism defined in the RWLockWrite class.\n\nReturns:\n    ReadRWLock: An instance of ReadRWLock that manages the read lock context.\n\nDependencies:\n    Relies on the RWLockWrite class's methods `aquire_read` and `release_read` to manage access to shared resources.",
        "signature": "def gen_rlock(self):",
        "type": "Method",
        "class_signature": "class RWLockWrite:"
      },
      "RWLockWrite.gen_wlock": {
        "code": "    def gen_wlock(self):\n        \"\"\"Creates and returns a new instance of the WriteRWLock class, which is used to acquire a write lock on the RWLockWrite instance. The WriteRWLock instance facilitates managing exclusive write access to resources while ensuring that no readers can access those resources during the write operation. \n\nThis method does not take any parameters and returns an instance of WriteRWLock. When the returned lock object is used within a context manager (with statement), it will acquire the write lock when entering the block and release it upon exiting. \n\nDependencies include the RWLockWrite class itself, which maintains state through attributes like _waiting_writers and _writer_active, ensuring proper synchronization between writers and readers.\"\"\"\n        return WriteRWLock(self)",
        "docstring": "Creates and returns a new instance of the WriteRWLock class, which is used to acquire a write lock on the RWLockWrite instance. The WriteRWLock instance facilitates managing exclusive write access to resources while ensuring that no readers can access those resources during the write operation. \n\nThis method does not take any parameters and returns an instance of WriteRWLock. When the returned lock object is used within a context manager (with statement), it will acquire the write lock when entering the block and release it upon exiting. \n\nDependencies include the RWLockWrite class itself, which maintains state through attributes like _waiting_writers and _writer_active, ensuring proper synchronization between writers and readers.",
        "signature": "def gen_wlock(self):",
        "type": "Method",
        "class_signature": "class RWLockWrite:"
      },
      "ReadRWLock.__enter__": {
        "code": "    def __enter__(self):\n        \"\"\"Acquires a read lock on the associated `RWLockWrite` instance for the duration of the context. This method blocks until it is safe to read, which occurs when there are no active writers or waiting writers. It is part of the context management protocol, enabling the use of `with` statements for automatic lock management.\n\nParameters:\n- self: An instance of `ReadRWLock`, which internally holds a reference to a `RWLockWrite`.\n\nReturns:\n- None: This method does not return a value but ensures the reader can access shared resources once the lock is acquired.\n\nSide effects:\n- Increases the `_active_readers` count in the associated `RWLockWrite` instance, allowing concurrent read access.\n\nDependencies:\n- Relies on the `aquire_read` method of the `RWLockWrite` class to manage access control.\"\"\"\n        self.rwlock.aquire_read()",
        "docstring": "Acquires a read lock on the associated `RWLockWrite` instance for the duration of the context. This method blocks until it is safe to read, which occurs when there are no active writers or waiting writers. It is part of the context management protocol, enabling the use of `with` statements for automatic lock management.\n\nParameters:\n- self: An instance of `ReadRWLock`, which internally holds a reference to a `RWLockWrite`.\n\nReturns:\n- None: This method does not return a value but ensures the reader can access shared resources once the lock is acquired.\n\nSide effects:\n- Increases the `_active_readers` count in the associated `RWLockWrite` instance, allowing concurrent read access.\n\nDependencies:\n- Relies on the `aquire_read` method of the `RWLockWrite` class to manage access control.",
        "signature": "def __enter__(self):",
        "type": "Method",
        "class_signature": "class ReadRWLock:"
      },
      "ReadRWLock.__exit__": {
        "code": "    def __exit__(self, exc_type, exc_value, traceback):\n        \"\"\"Exits the read lock context by releasing the read lock associated with the instance of ReadRWLock. This method is called automatically upon exiting a `with` statement block that utilizes the ReadRWLock. \n\nParameters:\n- exc_type (type): The type of the exception raised, if any.\n- exc_value (Exception): The value of the exception raised, if any.\n- traceback (traceback): The traceback object for the exception, if any.\n\nReturns:\n- bool: Always returns False, indicating that any exception raised will not be suppressed.\n\nThis method interacts with the `release_read` method of the `RWLockWrite` class to decrement the count of active readers and notify any waiting writers, ensuring proper synchronization in concurrent environments.\"\"\"\n        self.rwlock.release_read()\n        return False",
        "docstring": "Exits the read lock context by releasing the read lock associated with the instance of ReadRWLock. This method is called automatically upon exiting a `with` statement block that utilizes the ReadRWLock. \n\nParameters:\n- exc_type (type): The type of the exception raised, if any.\n- exc_value (Exception): The value of the exception raised, if any.\n- traceback (traceback): The traceback object for the exception, if any.\n\nReturns:\n- bool: Always returns False, indicating that any exception raised will not be suppressed.\n\nThis method interacts with the `release_read` method of the `RWLockWrite` class to decrement the count of active readers and notify any waiting writers, ensuring proper synchronization in concurrent environments.",
        "signature": "def __exit__(self, exc_type, exc_value, traceback):",
        "type": "Method",
        "class_signature": "class ReadRWLock:"
      }
    }
  },
  "dependency_dict": {
    "casbin/util/rwlock.py:RWLockWrite:gen_rlock": {
      "casbin/util/rwlock.py": {
        "ReadRWLock.__init__": {
          "code": "    def __init__(self, rwlock):\n        self.rwlock = rwlock",
          "docstring": "",
          "signature": "def __init__(self, rwlock):",
          "type": "Method",
          "class_signature": "class ReadRWLock:"
        }
      }
    },
    "casbin/util/rwlock.py:RWLockWrite:gen_wlock": {
      "casbin/util/rwlock.py": {
        "WriteRWLock.__init__": {
          "code": "    def __init__(self, rwlock):\n        self.rwlock = rwlock",
          "docstring": "",
          "signature": "def __init__(self, rwlock):",
          "type": "Method",
          "class_signature": "class WriteRWLock:"
        }
      }
    },
    "casbin/util/rwlock.py:ReadRWLock:__enter__": {
      "casbin/util/rwlock.py": {
        "RWLockWrite.aquire_read": {
          "code": "    def aquire_read(self):\n        with self._lock:\n            while self._waiting_writers > 0 or self._writer_active:\n                self._cond.wait()\n            self._active_readers += 1",
          "docstring": "",
          "signature": "def aquire_read(self):",
          "type": "Method",
          "class_signature": "class RWLockWrite:"
        }
      }
    },
    "casbin/util/rwlock.py:ReadRWLock:__exit__": {
      "casbin/util/rwlock.py": {
        "RWLockWrite.release_read": {
          "code": "    def release_read(self):\n        with self._lock:\n            self._active_readers -= 1\n            if self._active_readers == 0:\n                self._cond.notify_all()",
          "docstring": "",
          "signature": "def release_read(self):",
          "type": "Method",
          "class_signature": "class RWLockWrite:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_rwlock\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u2514\u2500\u2500 util/\n        \u2514\u2500\u2500 rwlock.py\n            \u251c\u2500\u2500 RWLockWrite.__init__\n            \u251c\u2500\u2500 RWLockWrite.gen_rlock\n            \u251c\u2500\u2500 RWLockWrite.gen_wlock\n            \u251c\u2500\u2500 ReadRWLock.__enter__\n            \u2514\u2500\u2500 ReadRWLock.__exit__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a testing framework to validate the functionality and performance of a reader-writer lock implementation, specifically the `RWLockWrite` utility from Casbin. Its primary purpose is to ensure thread-safe concurrent access management by evaluating scenarios where multiple readers, writers, or a combination of both interact with shared resources. Key capabilities include verifying that multiple readers can access the resource simultaneously without delays, ensuring that writers have exclusive access when necessary, and confirming writer-priority behavior in concurrent operations. This module addresses the critical need for developers to confirm concurrency control mechanisms, ensuring reliability and correctness in systems where efficient and safe resource sharing is essential.\n\n## FILE 1: casbin/util/rwlock.py\n\n- CLASS METHOD: RWLockWrite.gen_wlock\n  - CLASS SIGNATURE: class RWLockWrite:\n  - SIGNATURE: def gen_wlock(self):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates and returns a new instance of the WriteRWLock class, which is used to acquire a write lock on the RWLockWrite instance. The WriteRWLock instance facilitates managing exclusive write access to resources while ensuring that no readers can access those resources during the write operation. \n\nThis method does not take any parameters and returns an instance of WriteRWLock. When the returned lock object is used within a context manager (with statement), it will acquire the write lock when entering the block and release it upon exiting. \n\nDependencies include the RWLockWrite class itself, which maintains state through attributes like _waiting_writers and _writer_active, ensuring proper synchronization between writers and readers.\n\"\"\"\n```\n\n- CLASS METHOD: ReadRWLock.__enter__\n  - CLASS SIGNATURE: class ReadRWLock:\n  - SIGNATURE: def __enter__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nAcquires a read lock on the associated `RWLockWrite` instance for the duration of the context. This method blocks until it is safe to read, which occurs when there are no active writers or waiting writers. It is part of the context management protocol, enabling the use of `with` statements for automatic lock management.\n\nParameters:\n- self: An instance of `ReadRWLock`, which internally holds a reference to a `RWLockWrite`.\n\nReturns:\n- None: This method does not return a value but ensures the reader can access shared resources once the lock is acquired.\n\nSide effects:\n- Increases the `_active_readers` count in the associated `RWLockWrite` instance, allowing concurrent read access.\n\nDependencies:\n- Relies on the `aquire_read` method of the `RWLockWrite` class to manage access control.\n\"\"\"\n```\n\n- CLASS METHOD: RWLockWrite.__init__\n  - CLASS SIGNATURE: class RWLockWrite:\n  - SIGNATURE: def __init__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the RWLockWrite class, which implements a write-preferential readers-writer lock mechanism. \n\nThis constructor sets up the following attributes:\n\n- `self._lock`: A reentrant lock (RLock) used to synchronize access to shared resources.\n- `self._cond`: A condition variable associated with `_lock`, allowing threads to wait for state changes.\n- `self._active_readers`: An integer tracking the number of currently active readers accessing the resource.\n- `self._waiting_writers`: An integer counting the number of writers waiting to acquire the lock.\n- `self._writer_active`: A boolean indicating whether a writer is currently holding the lock.\n\nThese attributes help manage concurrent access, ensuring that multiple readers can access a resource simultaneously while preventing writers from accessing it when readers are active.\n\"\"\"\n```\n\n- CLASS METHOD: ReadRWLock.__exit__\n  - CLASS SIGNATURE: class ReadRWLock:\n  - SIGNATURE: def __exit__(self, exc_type, exc_value, traceback):\n  - DOCSTRING: \n```python\n\"\"\"\nExits the read lock context by releasing the read lock associated with the instance of ReadRWLock. This method is called automatically upon exiting a `with` statement block that utilizes the ReadRWLock. \n\nParameters:\n- exc_type (type): The type of the exception raised, if any.\n- exc_value (Exception): The value of the exception raised, if any.\n- traceback (traceback): The traceback object for the exception, if any.\n\nReturns:\n- bool: Always returns False, indicating that any exception raised will not be suppressed.\n\nThis method interacts with the `release_read` method of the `RWLockWrite` class to decrement the count of active readers and notify any waiting writers, ensuring proper synchronization in concurrent environments.\n\"\"\"\n```\n\n- CLASS METHOD: RWLockWrite.gen_rlock\n  - CLASS SIGNATURE: class RWLockWrite:\n  - SIGNATURE: def gen_rlock(self):\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a read lock for the RWLockWrite instance.\n\nThis method creates an instance of ReadRWLock, which provides a context manager for acquiring and releasing a read lock. The context manager ensures that the read lock is properly acquired and released, adhering to the locking mechanism defined in the RWLockWrite class.\n\nReturns:\n    ReadRWLock: An instance of ReadRWLock that manages the read lock context.\n\nDependencies:\n    Relies on the RWLockWrite class's methods `aquire_read` and `release_read` to manage access to shared resources.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/util/rwlock.py": "from threading import RLock, Condition\n\nclass RWLockWrite:\n    \"\"\"write preferring readers-wirter lock\"\"\"\n\n    def aquire_read(self):\n        with self._lock:\n            while self._waiting_writers > 0 or self._writer_active:\n                self._cond.wait()\n            self._active_readers += 1\n\n    def release_read(self):\n        with self._lock:\n            self._active_readers -= 1\n            if self._active_readers == 0:\n                self._cond.notify_all()\n\n    def aquire_write(self):\n        with self._lock:\n            self._waiting_writers += 1\n            while self._active_readers > 0 or self._writer_active:\n                self._cond.wait()\n            self._waiting_writers -= 1\n            self._writer_active = True\n\n    def release_write(self):\n        with self._lock:\n            self._writer_active = False\n            self._cond.notify_all()\n\nclass ReadRWLock:\n\n    def __init__(self, rwlock):\n        self.rwlock = rwlock\n\nclass WriteRWLock:\n\n    def __init__(self, rwlock):\n        self.rwlock = rwlock\n\n    def __enter__(self):\n        self.rwlock.aquire_write()\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.rwlock.release_write()\n        return False"
  },
  "call_tree": {
    "tests/util/test_rwlock.py:TestRWLock:test_multiple_readers": {
      "tests/util/test_rwlock.py:TestRWLock:gen_locks": {
        "casbin/util/rwlock.py:RWLockWrite:__init__": {},
        "casbin/util/rwlock.py:RWLockWrite:gen_rlock": {
          "casbin/util/rwlock.py:ReadRWLock:__init__": {}
        },
        "casbin/util/rwlock.py:RWLockWrite:gen_wlock": {
          "casbin/util/rwlock.py:WriteRWLock:__init__": {}
        }
      }
    },
    "tests/util/test_rwlock.py:TestRWLock:read": {
      "casbin/util/rwlock.py:ReadRWLock:__enter__": {
        "casbin/util/rwlock.py:RWLockWrite:aquire_read": {}
      },
      "casbin/util/rwlock.py:ReadRWLock:__exit__": {
        "casbin/util/rwlock.py:RWLockWrite:release_read": {}
      }
    }
  }
}